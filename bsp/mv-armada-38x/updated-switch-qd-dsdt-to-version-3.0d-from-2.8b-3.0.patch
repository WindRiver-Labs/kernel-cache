From 5a826ef7e0bc18b81e9af950ef62a71df96afbaf Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Mon, 15 Oct 2012 14:11:44 +0200
Subject: [PATCH 0281/1825] - updated switch (/qd-dsdt/) to version 3.0d (from
 2.8b --> 3.0D - from KW40)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e3c037b4a2b093c86b1806cb046f26841a6a0919

Change-Id: I00ed8e249790e82b0716a1475cb670041bc90d52

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/README    |   28 -
 .../plat-armada/mv_hal/qd-dsdt/Diag/ev96122mii.c   |  213 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/makefile  |   49 -
 .../plat-armada/mv_hal/qd-dsdt/Diag/msApiInit.c    |  115 -
 .../mv_hal/qd-dsdt/Diag/msApiMultiInit.c           |  424 -
 .../arm/plat-armada/mv_hal/qd-dsdt/Diag/msSample.h |  187 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/osSem.c   |  232 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdFFmii.c |  156 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInit.c  |  287 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInt.c   |  355 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSim.c   | 2004 --
 .../plat-armada/mv_hal/qd-dsdt/Diag/qdSimRegs.h    |  131 -
 .../plat-armada/mv_hal/qd-dsdt/Diag/sampleTest.c   |  447 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/testApi.c | 8717 ---------
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/utils.c   |  711 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/vctTest.c |  181 -
 .../plat-armada/mv_hal/qd-dsdt/Include/Copyright.h |    4 +-
 .../arm/plat-armada/mv_hal/qd-dsdt/Include/gtMad.h |  214 +
 .../arm/plat-armada/mv_hal/qd-dsdt/Include/gtPTP.h |  499 +
 .../mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h  |  428 +-
 .../mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h     |  268 +-
 .../mv_hal/qd-dsdt/Include/h/msApi/gtVct.h         |  189 +-
 .../mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h | 1707 +-
 .../mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h |   94 +-
 .../plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h | 4101 +++--
 .../mv_hal/qd-dsdt/Include/msApiMadConfig.h        |   31 -
 .../mv_hal/qd-dsdt/Include/msApiPrototype.h        |19570 +++++++++++---------
 .../mv_hal/qd-dsdt/Include/msApiSelect.h           |   53 +
 .../mv_hal/qd-dsdt/Include/msApiTypes.h            |   24 +-
 arch/arm/plat-armada/mv_hal/qd-dsdt/README         |  393 -
 arch/arm/plat-armada/mv_hal/qd-dsdt/README_SW.txt  |  393 +
 .../qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c |  596 +-
 .../qd-dsdt/sample/Initialization/msApiInit.c      |  131 +-
 .../qd-dsdt/sample/Initialization/msSample.h       |   73 +-
 .../mv_hal/qd-dsdt/sample/Interrupt/qdInt.c        |  699 +-
 .../qd-dsdt/sample/LoadBalance/loadBalance.c       |   65 +-
 .../plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c    |  488 +-
 .../mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c |   12 +-
 .../mv_hal/qd-dsdt/sample/QoSSetup/qos.c           |  351 +-
 .../arm/plat-armada/mv_hal/qd-dsdt/sample/makefile |    4 +-
 .../mv_hal/qd-dsdt/src/driver/gtDrvConfig.c        | 1206 +-
 .../mv_hal/qd-dsdt/src/driver/gtHwCntl.c           | 2296 ++-
 .../plat-armada/mv_hal/qd-dsdt/src/driver/makefile |   23 +-
 arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile   |   40 +-
 .../mv_hal/qd-dsdt/src/msapi/gtAdvVct.c            | 2043 +-
 .../mv_hal/qd-dsdt/src/msapi/gtAdvVct_mad.c        |  228 +
 .../mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c            | 3097 ++--
 .../mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c           |  316 +-
 .../mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c            | 1759 +-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c |  426 +-
 .../mv_hal/qd-dsdt/src/msapi/gtEvents.c            | 1294 +-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c  | 2186 ++-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c  | 1992 +-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c | 2414 ++--
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c   | 8896 +++++----
 .../mv_hal/qd-dsdt/src/msapi/gtPTPHidden.c         |  271 +
 .../mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c           | 3986 ++--
 .../mv_hal/qd-dsdt/src/msapi/gtPhyCtrl_mad.c       | 2189 +++
 .../mv_hal/qd-dsdt/src/msapi/gtPhyInt.c            |  213 +-
 .../mv_hal/qd-dsdt/src/msapi/gtPhyInt_mad.c        |  273 +
 .../mv_hal/qd-dsdt/src/msapi/gtPolicy.c            |  324 +-
 .../mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c          | 5121 +++---
 .../mv_hal/qd-dsdt/src/msapi/gtPortLed.c           | 1452 +-
 .../mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c      | 2400 ++--
 .../mv_hal/qd-dsdt/src/msapi/gtPortRmon.c          | 1015 +-
 .../mv_hal/qd-dsdt/src/msapi/gtPortStat.c          |  100 +-
 .../mv_hal/qd-dsdt/src/msapi/gtPriTable.c          | 1769 +-
 .../mv_hal/qd-dsdt/src/msapi/gtQosMap.c            | 1256 +-
 .../mv_hal/qd-dsdt/src/msapi/gtSysConfig.c         | 1474 +-
 .../mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c           | 7694 +++++----
 .../mv_hal/qd-dsdt/src/msapi/gtSysStatus.c         |  114 +-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtTCAM.c  |  979 +
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c   | 1569 +-
 .../mv_hal/qd-dsdt/src/msapi/gtVct_mad.c           |  226 +
 .../mv_hal/qd-dsdt/src/msapi/gtWeight.c            |  579 +-
 .../plat-armada/mv_hal/qd-dsdt/src/msapi/makefile  |   18 +-
 .../mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c       |  751 +-
 .../mv_hal/qd-dsdt/src/platform/makefile           |   15 +-
 .../arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs |    2 +-
 .../plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs  |   19 +-
 .../plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules |    7 +-
 .../plat-armada/mv_hal/qd-dsdt/tools/makewce.defs  |   10 +-
 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv   |   14 +-
 .../plat-armada/mv_hal/qd-dsdt/tools/setenv.bat    |   11 +-
 84 files changed, 52213 insertions(+), 54478 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/README
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/ev96122mii.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/makefile
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiInit.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiMultiInit.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msSample.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/osSem.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdFFmii.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInit.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInt.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSim.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSimRegs.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/sampleTest.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/testApi.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/utils.c
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/vctTest.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/Copyright.h
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtMad.h
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtPTP.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvConfig.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvEvents.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/gtVct.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtSem.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/platformDeps.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApi.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiMadConfig.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiPrototype.h
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiSelect.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiTypes.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiWince.h
 delete mode 100644 arch/arm/plat-armada/mv_hal/qd-dsdt/README
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/README_SW.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/mvCompVer.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/802_1q.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/advCableTest.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/cableTest.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/flowCtrl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/header.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/msSample.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/qdSimRegs.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/ev96122mii.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msApiInit.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msSample.h
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/osSem.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/qdSim.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/qdInt.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/loadBalance.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/macAddr.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/minimizeCPUTraffic.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MultiDevice/msApiInit.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl2.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/portMonitor.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/qos.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/README
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/rmon.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/trailer.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/hgVlan.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/readme.txt
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/sample/makefile
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvConfig.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvEvents.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtHwCntl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/makefile
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct_mad.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStp.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStu.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtEvents.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPCSCtrl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTPHidden.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl_mad.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt_mad.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPolicy.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortLed.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortPav.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRmon.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStat.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStatus.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPriTable.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtQosMap.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysConfig.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysStatus.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtTCAM.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtUtils.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c
 create mode 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct_mad.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVersion.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtWeight.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/makefile
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtDebug.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtSem.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/makefile
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/platformDeps.c
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.rules
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.defs
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.rules
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv
 mode change 100644 => 100755 arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv.bat

diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/README b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/README
deleted file mode 100644
index 5ab23b7..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/README
+++ /dev/null
@@ -1,28 +0,0 @@
-This directory includes a test program that runs on Marvell platform, such as
-DB-88E6218, RD-88E6218, DB-88E6318, and RD-88E6318 with VxWorks.
-It is not part of the DSDT Driver Suite, rather, 
-it runs through each and every API of the Driver Suite to test it out. 
-
-Please notes that it is provided for "Reference Only" and some of the system 
-specific files cannot be compiled unless related BSP is provided.
-
-The test program covers :
-
-1) How to initialize single or multiple Marvell SOHO Switchs.
-	msApiInit.c : Single Address Mode Device
-	msApiMultiInit.c : Multiple Address Mode Device
-
-	Refer to Device DataSheet for detailed information of each Address Mode.
-	
-2) How to utilize each APIs. (testApi.c)
-
-3) How to provide two platform specific MII access routines. 
-	(qdFFMii.c for 88E6218 board, ev96122mii.c for EV-96122 board)
-
-4) How to enable SOHO Switch Interrupt, if applicable. (qdInt.c)
-
-5) How to run VCT(Virtual Cable Tester) test. (vctTest.c)
-
-6) How to provide Semaphore routines if required. (osSem.c)
-
-       
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/ev96122mii.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/ev96122mii.c
deleted file mode 100644
index 2c3b88d..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/ev96122mii.c
+++ /dev/null
@@ -1,213 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* ev96122mii.c
-*
-* DESCRIPTION:
-*       SMI access routines for EV-96122 board
-*
-* DEPENDENCIES:   Platform.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#include <msSample.h>
-
-/*
- * For each platform, all we need is 
- * 1) Assigning functions into 
- * 		fgtReadMii : to read MII registers, and
- * 		fgtWriteMii : to write MII registers.
- *
- * 2) Register Interrupt (Not Defined Yet.)
-*/
-
-/* 
- *  EV-96122 Specific Definition
-*/
-
-#define SMI_OP_CODE_BIT_READ                    1
-#define SMI_OP_CODE_BIT_WRITE                   0
-#define SMI_BUSY                                1<<28
-#define READ_VALID                              1<<27
-
-#ifdef FIREFOX
-#define ETHER_SMI_REG                   0x10 
-#define internalRegBaseAddr 0x80008000
-#define NONE_CACHEABLE		0x00000000
-#define CACHEABLE			0x00000000
-#define SMI_RX_TIMEOUT		1000
-#else
-#define ETHER_SMI_REG                   0x080810 
-#define internalRegBaseAddr 0x14000000
-#define NONE_CACHEABLE		0xa0000000
-#define CACHEABLE			0x80000000
-#define SMI_RX_TIMEOUT		10000000
-#endif
-
-typedef unsigned int              SMI_REG;
-
-#ifdef LE /* Little Endian */          	
-#define SHORT_SWAP(X) (X)
-#define WORD_SWAP(X) (X)
-#define LONG_SWAP(X) ((l64)(X))
-
-#else    /* Big Endian */
-#define SHORT_SWAP(X) ((X <<8 ) | (X >> 8))
-
-#define WORD_SWAP(X) (((X)&0xff)<<24)+      \
-                    (((X)&0xff00)<<8)+      \
-                    (((X)&0xff0000)>>8)+    \
-                    (((X)&0xff000000)>>24)
-
-#define LONG_SWAP(X) ( (l64) (((X)&0xffULL)<<56)+               \
-                            (((X)&0xff00ULL)<<40)+              \
-                            (((X)&0xff0000ULL)<<24)+            \
-                            (((X)&0xff000000ULL)<<8)+           \
-                            (((X)&0xff00000000ULL)>>8)+         \
-                            (((X)&0xff0000000000ULL)>>24)+      \
-                            (((X)&0xff000000000000ULL)>>40)+    \
-                            (((X)&0xff00000000000000ULL)>>56))   
-
-#endif
-
-#define GT_REG_READ(offset, pData)                                          \
-*pData = ( (volatile unsigned int)*((unsigned int *)                        \
-           (NONE_CACHEABLE | internalRegBaseAddr | (offset))) );            \
-*pData = WORD_SWAP(*pData)
-
-#define GT_REG_WRITE(offset, data)                                          \
-(volatile unsigned int)*((unsigned int *)(NONE_CACHEABLE |                  \
-          internalRegBaseAddr | (offset))) = WORD_SWAP(data)
-
-typedef enum _bool{false,true} bool;
-
-/*****************************************************************************
-*
-* bool etherReadMIIReg (unsigned int portNumber , unsigned int MIIReg,
-* unsigned int* value)
-*
-* Description
-* This function will access the MII registers and will read the value of
-* the MII register , and will retrieve the value in the pointer.
-* Inputs
-* portNumber - one of the 2 possiable Ethernet ports (0-1).
-* MIIReg - the MII register offset.
-* Outputs
-* value - pointer to unsigned int which will receive the value.
-* Returns Value
-* true if success.
-* false if fail to make the assignment.
-* Error types (and exceptions if exist)
-*/
-
-GT_BOOL gtBspReadMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                        unsigned int* value)
-{
-SMI_REG smiReg;
-unsigned int phyAddr;
-unsigned int timeOut = 10; /* in 100MS units */
-int i;
-
-/* first check that it is not busy */
-    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-    if(smiReg & SMI_BUSY) 
-    {
-        for(i = 0 ; i < SMI_RX_TIMEOUT ; i++);
-        do {
-            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-            if(timeOut-- < 1 ) {
-    	        return false;
-    	    }
-        } while (smiReg & SMI_BUSY);
-    }
-/* not busy */
-
-    phyAddr = portNumber;
-
-    smiReg =  (phyAddr << 16) | (SMI_OP_CODE_BIT_READ << 26) | (MIIReg << 21) |
-         SMI_OP_CODE_BIT_READ<<26;
-
-    GT_REG_WRITE (ETHER_SMI_REG,*((unsigned int*)&smiReg));
-    timeOut = 10; /* initialize the time out var again */
-    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-    if(!(smiReg & READ_VALID)) 
-        {
-            i=0;
-            while(i < SMI_RX_TIMEOUT)
-            {
-                i++;
-            }
-        {
-        }
-        do {
-            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-            if(timeOut-- < 1 ) {
-    	        return false;
-    	    }
-        } while (!(smiReg & READ_VALID));
-     }
-    *value = (unsigned int)(smiReg & 0xffff);
-    
-    return true;
-
-
-}
-
-/*****************************************************************************
-* 
-* bool etherWriteMIIReg (unsigned int portNumber , unsigned int MIIReg,
-* unsigned int value)
-* 
-* Description
-* This function will access the MII registers and will write the value
-* to the MII register.
-* Inputs
-* portNumber - one of the 2 possiable Ethernet ports (0-1).
-* MIIReg - the MII register offset.
-* value -the value that will be written.
-* Outputs
-* Returns Value
-* true if success.
-* false if fail to make the assignment.
-* Error types (and exceptions if exist)
-*/
-
-GT_BOOL gtBspWriteMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                       unsigned int value)
-{
-SMI_REG smiReg;
-unsigned int phyAddr;
-unsigned int timeOut = 10; /* in 100MS units */
-int i;
-
-/* first check that it is not busy */
-    GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-    if(smiReg & SMI_BUSY) 
-    {
-        for(i = 0 ; i < SMI_RX_TIMEOUT ; i++);
-        do {
-            GT_REG_READ (ETHER_SMI_REG,(unsigned int*)&smiReg);
-            if(timeOut-- < 1 ) {
-    	        return false;
-    	    }
-        } while (smiReg & SMI_BUSY);
-    }
-/* not busy */
-
-    phyAddr = portNumber;
-
-    smiReg = 0; /* make sure no garbage value in reserved bits */
-    smiReg = smiReg | (phyAddr << 16) | (SMI_OP_CODE_BIT_WRITE << 26) |
-             (MIIReg << 21) | (value & 0xffff);
-
-    GT_REG_WRITE (ETHER_SMI_REG,*((unsigned int*)&smiReg));
-
-    return(true);
-}
-
-
-void gtBspMiiInit(GT_QD_DEV* dev)
-{
-	return;	
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/makefile
deleted file mode 100644
index 1b98f20..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/makefile
+++ /dev/null
@@ -1,49 +0,0 @@
-# makefile - build main object file
-#
-# modification history
-# --------------------
-# 04-15-02,mj	created
-#
-#######################################################################
-
-DEMONAME = msDiag
-WORK_TO_DO = $(DEMONAME).o
-
-exe : $(WORK_TO_DO)
-
-# Include common variable definitions
-include $(TOOL_DIR)/make.defs
-
-.PHONY : exe
-
-QDLIB = $(LIB_DIR)/$(PROJ_NAME).o
-
-OBJDIRS	= $(subst /,\,$(dir $(QDLIB)))
-
-#CSOURCES = osSem.c ev96122mii.c testApi.c qdSim.c msApiInit.c utils.c vctTest.c
-#CSOURCES = osSem.c testApi.c qdSim.c utils.c vctTest.c
-CSOURCES = osSem.c testApi.c qdSim.c utils.c vctTest.c msApiMultiInit.c
-
-COBJECTS  	= $(CSOURCES:.c=.o)
-AOBJECTS  	= $(ASOURCES:.s=.o)
-ifeq ($(OBJECTS),)
-OBJECTS  	= $(COBJECTS) $(AOBJECTS)
-endif
-
-ifeq ($(TARGET_CPU),ARM)
-EXTRA_DEFINE	+= -DFIREFOX
-endif
-
-$(DEMONAME).o : $(OBJECTS) $(QDLIB)
-	$(LD) $(LDFLAGS) -Map $(DEMONAME).map -o $(DEMONAME).o $(OBJECTS) $(QDLIB)
-
-$(OBJECTS) : %.o : %.c
-.c.o :
-	$(CC) $(CFLAGS) $(EXTRA_DEFINE) $(EXTRA_INCLUDE) $(ADDED_CFLAGS) -c $< -o $(notdir $@)
-
-.PHONY : clean
-clean :
-	$(RM) *.o
-	$(RM) *.map
-
-#end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiInit.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiInit.c
deleted file mode 100644
index 9a027c8..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiInit.c
+++ /dev/null
@@ -1,115 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* msApiInit.c
-*
-* DESCRIPTION:
-*       MS API initialization routine
-*
-* DEPENDENCIES:   Platform
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-#include "msSample.h"
-/*
-#define MULTI_ADDR_MODE
-#define MANUAL_MODE
-*/
-
-GT_SYS_CONFIG   cfg;
-GT_QD_DEV       diagDev;
-GT_QD_DEV       *dev=&diagDev;
-
-
-/*
- *  Initialize the QuarterDeck. This should be done in BSP driver init routine.
- *	Since BSP is not combined with QuarterDeck driver, we are doing here.
-*/
-
-GT_STATUS qdStart(int cpuPort, int useQdSim, int devId) /* devId is used for simulator only */
-{
-GT_STATUS status;
-
-	/*
-	 *  Register all the required functions to QuarterDeck Driver.
-	*/
-	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
-	memset((char*)&diagDev,0,sizeof(GT_QD_DEV));
-
-	if(useQdSim == 0) /* use EV-96122 */
-	{
-		cfg.BSPFunctions.readMii   = gtBspReadMii;
-		cfg.BSPFunctions.writeMii  = gtBspWriteMii;
-#ifdef USE_SEMAPHORE
-		cfg.BSPFunctions.semCreate = osSemCreate;
-		cfg.BSPFunctions.semDelete = osSemDelete;
-		cfg.BSPFunctions.semTake   = osSemWait;
-		cfg.BSPFunctions.semGive   = osSemSignal;
-#else
-		cfg.BSPFunctions.semCreate = NULL;
-		cfg.BSPFunctions.semDelete = NULL;
-		cfg.BSPFunctions.semTake   = NULL;
-		cfg.BSPFunctions.semGive   = NULL;
-#endif
-		gtBspMiiInit(dev);
-	}
-	else	/* use QuaterDeck Simulator (No QD Device Required.) */
-	{
-		cfg.BSPFunctions.readMii   = qdSimRead;
-		cfg.BSPFunctions.writeMii  = qdSimWrite;
-#ifdef USE_SEMAPHORE
-		cfg.BSPFunctions.semCreate = osSemCreate;
-		cfg.BSPFunctions.semDelete = osSemDelete;
-		cfg.BSPFunctions.semTake   = osSemWait;
-		cfg.BSPFunctions.semGive   = osSemSignal;
-#else
-		cfg.BSPFunctions.semCreate = NULL;
-		cfg.BSPFunctions.semDelete = NULL;
-		cfg.BSPFunctions.semTake   = NULL;
-		cfg.BSPFunctions.semGive   = NULL;
-#endif
-
-		qdSimInit(devId,0);
-	}
-
-	cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
-	cfg.cpuPortNum = cpuPort;
-#ifdef MANUAL_MODE	/* not defined. this is only for sample */
-	/* user may want to use this mode when there are two QD switchs on the same MII bus. */
-	cfg.mode.scanMode = SMI_MANUAL_MODE;	/* Use QD located at manually defined base addr */
-	cfg.mode.baseAddr = 0x10;	/* valid value in this case is either 0 or 0x10 */
-#else
-#ifdef MULTI_ADDR_MODE
-	cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	/* find a QD in indirect access mode */
-	cfg.mode.baseAddr = 1;		/* this is the phyAddr used by QD family device. 
-								Valid value are 1 ~ 31.*/
-#else
-	cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;	/* Scan 0 or 0x10 base address to find the QD */
-	cfg.mode.baseAddr = 0;
-#endif
-#endif
-	if((status=qdLoadDriver(&cfg, dev)) != GT_OK)
-	{
-		MSG_PRINT(("qdLoadDriver return Failed\n"));
-		return status;
-	}
-
-	MSG_PRINT(("Device ID     : 0x%x\n",dev->deviceId));
-	MSG_PRINT(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
-	MSG_PRINT(("No of Ports   : %d\n",dev->numOfPorts));
-	MSG_PRINT(("CPU Ports     : %d\n",dev->cpuPortNum));
-
-	/*
-	 *  start the QuarterDeck
-	*/
-	if((status=sysEnable(dev)) != GT_OK)
-	{
-		MSG_PRINT(("sysConfig return Failed\n"));
-		return status;
-	}
-
-	MSG_PRINT(("QuarterDeck has been started.\n"));
-
-	return GT_OK;
-}
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiMultiInit.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiMultiInit.c
deleted file mode 100644
index 4488842..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msApiMultiInit.c
+++ /dev/null
@@ -1,424 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* msApiInit.c
-*
-* DESCRIPTION:
-*		MS API initialization routine for devices supporting Multi Address Mode,
-*		such as 88E6183. Following setup will be used for this sample code.
-*
-*	  	------------------
-*		|CPU Ethernet Dev|
-*		------------------
-*		 |		
-*		 |		
-*		 |   8--------------9    8--------------9   8--------------
-*		 |----| QD Device 0|------| QD Device 1|-----| QD Device 2|
-*             --------------      --------------     --------------
-*               0 1 2 ... 7         0 1 2 ... 7        0 1 2 ... 7
-*
-*
-*		Ethernet port of CPU is connected to port 8 of Device 0,
-*		port 9 of Device 0 is connected to port 8 of Device 1, and
-*		port 9 of Device 1 is connected to port 8 of Device 2.
-*
-*		Device 0 uses Phy Address 1, 
-*		Device 1 uses Phy Address 2, and
-*		Device 2 uses Phy Address 3
-*		Notes: Phy Address 0 cannot be used in a Multi Chip Address Mode.
-*
-*		Each Switch Device has to be configured to Multi Chip Address Mode.
-*		For detailed information for Multi Chip Address Mode configuration,
-*		please refer to your device's Datasheet.
-*
-* DEPENDENCIES:   Platform
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-#include "msSample.h"
-
-/*
-#define MULTI_ADDR_MODE
-#define MANUAL_MODE
-*/
-
-#define MULTI_ADDR_MODE
-#define N_OF_QD_DEVICES		2	/* number of 88E6183 devices connected */
-
-#define DEVICE0_ID		1
-#define DEVICE1_ID		DEVICE0_ID + 1
-#define DEVICE2_ID		DEVICE0_ID + 2
-
-#define DEVICE0_PHY_ADDR	0x11
-#define DEVICE1_PHY_ADDR	DEVICE0_PHY_ADDR + 1
-#define DEVICE2_PHY_ADDR	DEVICE0_PHY_ADDR + 2
-
-#define S_CPU_DEVICE		DEVICE0_ID
-
-#define DEVICE0_CPU_PORT		7
-#define DEVICE0_CASCADE_PORT	6
-#define DEVICE1_CPU_PORT		7
-#define DEVICE1_CASCADE_PORT	6
-#define DEVICE2_CPU_PORT		7
-#define DEVICE2_CASCADE_PORT	6
-
-extern GT_QD_DEV       	qddev[4];
-
-GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES] = {0,};
-GT_QD_DEV       *qdDev0 = &qddev[1];
-GT_QD_DEV       *qdDev1 = NULL;
-GT_QD_DEV       *qdDev2 = NULL;
-
-/*
- * read mii register - see qdFFmii.c
- */ 
-extern GT_BOOL ffReadMii(GT_QD_DEV* dev, 
-		      unsigned int portNumber , 
-		      unsigned int MIIReg, unsigned int* value
-		      );
-
-/*
- * write mii register - see qdFFmii.c
- */ 
-extern GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
-		       unsigned int portNumber , 
-		       unsigned int MIIReg, 
-		       unsigned int value
-		       );
-
-GT_STATUS RubyStart(int phyAddr, GT_QD_DEV* d)
-{
-	GT_STATUS status = GT_FAIL;
-	GT_SYS_CONFIG   cfg;
-
-	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
-	MSG_PRINT(("Size of GT_QD_DEV %i\n",sizeof(GT_QD_DEV)));
-
-	if(d == NULL)
-	{
-		MSG_PRINT(("Device Structure is NULL.\n"));
-		return GT_FAIL;
-	}
-
-	memset((char*)d,0,sizeof(GT_QD_DEV));
-
-	cfg.BSPFunctions.readMii   = ffReadMii;
-	cfg.BSPFunctions.writeMii  = ffWriteMii;
-#ifdef USE_SEMAPHORE
-	cfg.BSPFunctions.semCreate = osSemCreate;
-	cfg.BSPFunctions.semDelete = osSemDelete;
-	cfg.BSPFunctions.semTake   = osSemWait;
-	cfg.BSPFunctions.semGive   = osSemSignal;
-#else
-	cfg.BSPFunctions.semCreate = NULL;
-	cfg.BSPFunctions.semDelete = NULL;
-	cfg.BSPFunctions.semTake   = NULL;
-	cfg.BSPFunctions.semGive   = NULL;
-#endif
-
-	cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
-	cfg.cpuPortNum = 10;
-
-	cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	
-	cfg.mode.baseAddr = phyAddr;	/* valid value in this case is either 0 or 0x10 */
-
-	if((status=qdLoadDriver(&cfg, d)) != GT_OK)
-	{
-		MSG_PRINT(("qdLoadDriver return Failed\n"));
-		return status;
-	}
-
-	MSG_PRINT(("Device ID     : 0x%x\n",d->deviceId));
-	MSG_PRINT(("PHY Addr      : 0x%x\n",d->phyAddr));
-	MSG_PRINT(("Base Addr     : 0x%x\n",d->baseRegAddr));
-	MSG_PRINT(("CPU Ports     : %d\n",d->cpuPortNum));
-	MSG_PRINT(("N Ports       : %d\n",d->numOfPorts));
-	MSG_PRINT(("Device Group  : 0x%x\n",d->devName));
-	MSG_PRINT(("QDDev         : %#x\n",(unsigned long)&d));
-
-	/*
-	 *  start the QuarterDeck
-	*/
-	if((status=sysEnable(d)) != GT_OK)
-	{
-		MSG_PRINT(("sysConfig return Failed\n"));
-		return status;
-	}
-
-	return GT_OK;
-}
-
-GT_STATUS SwStart(int phyAddr, GT_QD_DEV* d)
-{
-	return RubyStart(phyAddr,d);
-}
-
-GT_QD_DEV* loadDev(GT_QD_DEV* dev, int mode, int phyAddr, int cpuPort, unsigned int cfgMode)
-{
-	GT_QD_DEV* d = dev;
-	GT_STATUS status = GT_FAIL;
-	GT_SYS_CONFIG   cfg;
-
-	if((int)dev == -1)
-		goto printUse;
-
-	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
-
-	if(d == NULL)
-	{
-		d = (GT_QD_DEV*)malloc(sizeof(GT_QD_DEV));
-		
-		if(d == NULL)
-		{
-			MSG_PRINT(("Failed to allocate Device Structure\n"));
-			return NULL;
-		}
-	}
-
-	memset((char*)d,0,sizeof(GT_QD_DEV));
-
-	cfg.BSPFunctions.readMii   = ffReadMii;
-	cfg.BSPFunctions.writeMii  = ffWriteMii;
-#ifdef USE_SEMAPHORE
-	cfg.BSPFunctions.semCreate = osSemCreate;
-	cfg.BSPFunctions.semDelete = osSemDelete;
-	cfg.BSPFunctions.semTake   = osSemWait;
-	cfg.BSPFunctions.semGive   = osSemSignal;
-#else
-	cfg.BSPFunctions.semCreate = NULL;
-	cfg.BSPFunctions.semDelete = NULL;
-	cfg.BSPFunctions.semTake   = NULL;
-	cfg.BSPFunctions.semGive   = NULL;
-#endif
-
-	cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
-	cfg.cpuPortNum = cpuPort;
-	cfg.skipInitSetup = (GT_U32)cfgMode;
-
-	switch(mode)
-	{
-		case SMI_MANUAL_MODE:		/* Use QD located at manually defined base addr */
-		case SMI_MULTI_ADDR_MODE:	/* Use QD in multi chip address mode */
-			cfg.mode.scanMode = mode;	
-			cfg.mode.baseAddr = phyAddr;	/* valid value in this case is either 0 or 0x10 */
-			break;
-		case SMI_AUTO_SCAN_MODE:	/* Scan 0 or 0x10 base address to find the QD */
-			cfg.mode.scanMode = mode;
-			cfg.mode.baseAddr = 0;
-			break;
-		default:
-			MSG_PRINT(("Unknown Mode %i\n",mode));
-			goto printUse;
-	}
-
-	if((status=qdLoadDriver(&cfg, d)) != GT_OK)
-	{
-		MSG_PRINT(("qdLoadDriver return Failed\n"));
-		goto loadErr;
-	}
-
-	MSG_PRINT(("Device ID     : 0x%x\n",d->deviceId));
-	MSG_PRINT(("PHY Addr      : 0x%x\n",d->phyAddr));
-	MSG_PRINT(("Base Addr     : 0x%x\n",d->baseRegAddr));
-	MSG_PRINT(("CPU Ports     : %d\n",d->cpuPortNum));
-
-	/*
-	 *  start the QuarterDeck
-	*/
-	if((status=sysEnable(d)) != GT_OK)
-	{
-		MSG_PRINT(("sysConfig return Failed\n"));
-		goto loadErr;
-	}
-
-	return d;
-
-printUse:
-	MSG_PRINT(("Usage: loadDev(Dev,mode,phyAddr,cpuPort)\n",SMI_AUTO_SCAN_MODE));
-	MSG_PRINT(("\tSMI_AUTO_SCAN_MODE :  %i\n",SMI_AUTO_SCAN_MODE));
-	MSG_PRINT(("\tSMI_MANUAL_MODE :     %i\n",SMI_MANUAL_MODE));
-	MSG_PRINT(("\tSMI_MULTI_ADDR_MODE : %i\n",SMI_MULTI_ADDR_MODE));
-	MSG_PRINT(("Example: loadDev(0,1,0x10,5)\n"));
-	MSG_PRINT(("for Manual mode, phy base address 0x10, and cpu port 5\n"));
-	
-loadErr:
-	
-	if(dev)
-		return NULL;
-
-	if(d)
-		free(d);
-
-	return NULL;
-}
-
-/*
- * Initialize each Switch Devices. This should be done in BSP driver init routine.
- *	Since BSP is not combined with QuarterDeck driver, we are doing here.
- * This routine will setup Switch Devices according to the above description.
-*/
-GT_STATUS qdMultiDevStart()
-{
-	GT_STATUS status = GT_FAIL;
-	int cpuPort;
-	int cascadePort;
-	int i,j;
-
-	/* 
-	 *	Create QD Device Structure for each device.
-	 */
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-	{
-		if(qdMultiDev[i] == NULL)
-		{
-			qdMultiDev[i] = (GT_QD_DEV*)malloc(sizeof(GT_QD_DEV));
-		
-			if(qdMultiDev[i] == NULL)
-			{
-				while(i--)
-				{
-					free(qdMultiDev[i]);
-					qdMultiDev[i] = NULL;
-				}
-				return GT_FAIL;
-			}
-		}
-
-		memset((char*)qdMultiDev[i],0,sizeof(GT_QD_DEV));
-	}
-	
-	/*
-	 *  Register all the required functions to QuarterDeck Driver for each device.
-	*/
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-	{
-		switch (i)
-		{
-			case 0: /* if we are registering device 0 */
-				cpuPort = DEVICE0_CPU_PORT;
-				break;
-			case 1: /* if we are registering device 1 */
-				cpuPort = DEVICE1_CPU_PORT;	/* where device 0 is connected */
-				break;
-			case 2: /* if we are registering device 2 */
-				cpuPort = DEVICE2_CPU_PORT;	/* where device 1 is connected */
-				break;
-			default: /* we don't have any more device. it shouldn't happen in our sample setup. */
-				goto errorExit;
-		}
-
-		MSG_PRINT(("Initializing QD Device %i...\n",i));
-		if(loadDev(qdMultiDev[i],SMI_MULTI_ADDR_MODE,DEVICE0_PHY_ADDR + i,cpuPort,0) == NULL)
-		{
-			MSG_PRINT(("QD Device %i is not initialized.\n",i));
-			free(qdMultiDev[i]);
-			qdMultiDev[i] = NULL;
-			continue;
-		}
-
-		/* 
-			Now, we need to configure Cascading information for each devices.
-			1. Set Interswitch port mode for port 8 and 9 for device 0,1,and 2,
-				so that switch device can expect Marvell Tag from frames 
-				ingressing/egressing this port.
-			2. Set CPU Port information (for To_CPU frame) for each port of device.
-			3. Set Cascading Port information (for From_CPU fram) for each device.
-			4. Set Device ID (if required)
-				Note: DeviceID is hardware configurable.
-		*/
-		switch (i)
-		{
-			case 0: /* if we are registering device 0 */
-				cpuPort = DEVICE0_CPU_PORT; 		/* where CPU Enet port is connected */
-				cascadePort = DEVICE0_CASCADE_PORT;	/* where device 1 is connected */
-				qdDev0 = qdMultiDev[i];
-				MSG_PRINT(("Use qdDev0 to access Device 0.\n"));
-				break;
-			case 1: /* if we are registering device 1 */
-				cpuPort = DEVICE1_CPU_PORT; 		/* where device 0 is connected */
-				cascadePort = DEVICE1_CASCADE_PORT;	/* where device 2 is connected */
-				qdDev1 = qdMultiDev[i];
-				MSG_PRINT(("Use qdDev1 to access Device 1.\n"));
-				break;
-			case 2: /* if we are registering device 2 */
-				cpuPort = DEVICE2_CPU_PORT; 		/* where device 1 is connected */
-				cascadePort = DEVICE2_CASCADE_PORT;	/* no need to setup for the given sample setup */
-				qdDev2 = qdMultiDev[i];
-				MSG_PRINT(("Use qdDev2 to access Device 2.\n"));
-				break;
-			default: /* we don't have any more device. it shouldn't happen in our sample setup. */
-				goto errorExit;
-		}
-
-		/*
-			1. Set Interswitch port mode for port 8 and 9 for device 0,1,and 2,
-				so that switch device can expect Marvell Tag from frames 
-				ingressing/egressing this port.
-			2. Set CPU Port information (for To_CPU frame) for each port of device.
-		*/			
-		MSG_PRINT(("Setting InterSwitch Port and CPU Port...\n"));
-		for(j=0; j<qdMultiDev[i]->numOfPorts; j++)
-		{
-			if((j == cpuPort) || (j == cascadePort))
-			{
-				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_TRUE)) != GT_OK)
-				{
-					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode TRUE)\n",status,j));
-					break;
-				}
-			}
-			else
-			{
-				if((status=gprtSetInterswitchPort(qdMultiDev[i],j,GT_FALSE)) != GT_OK)
-				{
-					MSG_PRINT(("gprtSetInterswitchPort returned %i (port %i, mode FALSE)\n",status,j));
-					break;
-				}
-			}
-
-			if((status=gprtSetCPUPort(qdMultiDev[i],j,cpuPort)) != GT_OK)
-			{
-				MSG_PRINT(("gprtSetCPUPort returned %i\n",status));
-					break;
-			}
-		}
-
-		/*
-			3. Set Cascading Port information (for From_CPU fram) for each device.
-		*/	 	
-		MSG_PRINT(("Setting Cascade Port...\n"));
-		if((status=gsysSetCascadePort(qdMultiDev[i],cascadePort)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetCascadePort returned %i\n",status));
-			continue;
-		}
-
-		/*
-			4. Set Device ID (if required)
-		*/	 	
-		MSG_PRINT(("Setting Device ID (%i)...\n",DEVICE0_ID+i));
-		if((status=gsysSetDeviceNumber(qdMultiDev[i],DEVICE0_ID+i)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetDeviceNumber returned %i\n",status));
-			continue;
-		}
-
-	}	
-
-	return GT_OK;
-
-errorExit:
-
-	/* code will be reached here only if N_OF_QD_DEVICES > 3 */
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-	{
-		if(qdMultiDev[i] != NULL)
-		{
-	  		free(qdMultiDev[i]);
-			qdMultiDev[i] = NULL;
-		}
-	}	
-
-	return GT_FAIL;
-}
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msSample.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msSample.h
deleted file mode 100644
index de7c449..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/msSample.h
+++ /dev/null
@@ -1,187 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* msSample.h
-*
-* DESCRIPTION:
-*       Types definitions for Sample program
-*
-* DEPENDENCIES:   Platform.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#ifndef __pfTesth
-#define __pfTesth
-
-#ifdef _VXWORKS
-#include "vxWorks.h"
-#include "logLib.h"
-#endif
-#include "stdio.h"
-#include "stdarg.h"
-#include "stdlib.h"
-#include "time.h"
-#include "string.h"
-
-#include "msApi.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef GT_U32 (*GT_API_VOID) (GT_QD_DEV*);
-typedef int (*GT_CMP_FUNC) (void*, int, int);
-
-typedef GT_STATUS (*GT_API_SET_BOOL) (GT_QD_DEV*, GT_BOOL);
-typedef GT_STATUS (*GT_API_GET_BOOL) (GT_QD_DEV*, GT_BOOL*);
-
-typedef GT_STATUS (*GT_API_SET_U16) (GT_QD_DEV*, GT_U16);
-typedef GT_STATUS (*GT_API_GET_U16) (GT_QD_DEV*, GT_U16*);
-
-typedef GT_STATUS (*GT_API_SET_U32) (GT_QD_DEV*, GT_U32);
-typedef GT_STATUS (*GT_API_GET_U32) (GT_QD_DEV*, GT_U32*);
-
-typedef GT_STATUS (*GT_API_MAC_ADDR) (GT_QD_DEV*, GT_ETHERADDR*);
-
-typedef GT_STATUS (*GT_API_SET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL);
-typedef GT_STATUS (*GT_API_GET_PORT_BOOL) (GT_QD_DEV*, GT_LPORT,GT_BOOL*);
-
-typedef GT_STATUS (*GT_API_SET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16);
-typedef GT_STATUS (*GT_API_GET_PORT_U16) (GT_QD_DEV*, GT_LPORT,GT_U16*);
-
-typedef GT_STATUS (*GT_API_SET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32);
-typedef GT_STATUS (*GT_API_GET_PORT_U32) (GT_QD_DEV*, GT_LPORT,GT_U32*);
-
-typedef GT_STATUS (*GT_API_SET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8);
-typedef GT_STATUS (*GT_API_GET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8*);
-
-typedef struct _TEST_API
-{
-	union
-	{
-		GT_API_SET_BOOL bool;
-		GT_API_SET_U16 u16;
-		GT_API_SET_U32 u32;
-		GT_API_MAC_ADDR mac;
-		GT_API_SET_PORT_BOOL port_bool;
-		GT_API_SET_PORT_U8 port_u8;
-		GT_API_SET_PORT_U16 port_u16;
-		GT_API_SET_PORT_U32 port_u32;
-	} setFunc;
-
-	union
-	{
-		GT_API_GET_BOOL bool;
-		GT_API_GET_U16 u16;
-		GT_API_GET_U32 u32;
-		GT_API_MAC_ADDR mac;
-		GT_API_GET_PORT_BOOL port_bool;
-		GT_API_GET_PORT_U8 port_u8;
-		GT_API_GET_PORT_U16 port_u16;
-		GT_API_GET_PORT_U32 port_u32;
-	} getFunc;
-
-}TEST_API;
-
-typedef struct _TEST_STRUCT
-{
-	char strTest[16];
-	GT_API_VOID testFunc;
-	GT_U32 testResults;
-} TEST_STRUCT;
-
-#define MSG_PRINT(x) testPrint x
-
-#define MAX_MAC_ENTRIES	    8192
-#define TEST_MAC_ENTRIES 	64
-#define MAX_BUCKET_SIZE		2048
-
-typedef struct _TEST_ATU_ENTRY
-{
-	GT_ATU_ENTRY atuEntry[TEST_MAC_ENTRIES];
-}TEST_ATU_ENTRY;
-
-typedef struct _ATU_ENTRY_INFO
-{
-	GT_ATU_ENTRY atuEntry;
-	GT_U16	hash;
-	GT_U16	bucket;
-} ATU_ENTRY_INFO;
-
-extern GT_SYS_CONFIG   pfTestSysCfg;
-extern ATU_ENTRY_INFO *gAtuEntry;
-extern GT_QD_DEV       *dev;
-
-GT_STATUS qdStart(int,int,int);
-GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data);
-GT_STATUS qdSimSetGlobalInt(unsigned short u16Data);
-
-GT_STATUS testAll(GT_QD_DEV*);
-void testPrint(char* format, ...);
-GT_U32 testATU(GT_QD_DEV *dev);
-GT_STATUS testATUStress(GT_QD_DEV *dev);
-GT_U32 testVTU(GT_QD_DEV *dev);
-
-extern FGT_INT_HANDLER qdIntHandler;
-
-int vtuEntryCmpFunc(void* buf, int a, int b);
-int atuEntryCmpFunc(void* buf, int a, int b);
-GT_STATUS gtSort(int list[], GT_CMP_FUNC cmpFunc, void* buf, GT_U32 len);
-GT_U16 createATUList(GT_QD_DEV *dev, TEST_ATU_ENTRY atuEntry[], GT_U16 entrySize, GT_U16 dbNumSize, 
-					GT_U16 sameMacsInEachDb, GT_U16 bSize);
-GT_STATUS testFillUpAtu(GT_QD_DEV *dev, ATU_ENTRY_INFO *atuEntry, GT_U8 atuSize, 
-					GT_U32 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state);
-GT_U16 runQDHash(GT_U8* eaddr, GT_U16 dbNum, int bSize, GT_U16* pHash, 
-					GT_U16* preBucket, GT_U16* posBucket);
-GT_STATUS testDisplayATUList(GT_QD_DEV *dev);
-
-#ifdef USE_SEMAPHORE
-GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state);
-GT_STATUS osSemDelete(GT_SEM smid);
-GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut);
-GT_STATUS osSemSignal(GT_SEM smid);
-#endif
-
-GT_BOOL gtBspReadMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                      unsigned int* value);
-GT_BOOL gtBspWriteMii ( GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                       unsigned int value);
-void gtBspMiiInit(GT_QD_DEV* dev);
-
-GT_BOOL qdSimRead (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int* value);
-GT_BOOL qdSimWrite (GT_QD_DEV* dev,unsigned int portNumber , unsigned int miiReg, unsigned int value);
-void qdSimInit(GT_DEVICE devId, int baseAddr);
-
-
-#if 1 /* This is for testing */
-
-#define TEST_MASK		0
-#define TEST_MASK_0		0
-#define TEST_MASK_1		1
-#define TEST_MASK_2		2
-#define TEST_MASK_3		3
-#define TEST_MASK_4		4
-#define TEST_MASK_5		5
-#define TEST_MASK_6		6
-#define TEST_MASK_7		7
-
-#define GET_TEST_MASK(_index, _mask)	\
-		((_index == 0)?_mask##_0:		\
-		(_index == 1)?_mask##_1:		\
-		(_index == 2)?_mask##_2:		\
-		(_index == 3)?_mask##_3:		\
-		(_index == 4)?_mask##_4:		\
-		(_index == 5)?_mask##_5:		\
-		(_index == 6)?_mask##_6:		\
-		(_index == 7)?_mask##_7:0)
-
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif   /* __pfTesth */
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/osSem.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/osSem.c
deleted file mode 100644
index 7c95204..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/osSem.c
+++ /dev/null
@@ -1,232 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* osSem.c
-*
-* DESCRIPTION:
-*       Semaphore related routines
-*
-* DEPENDENCIES:
-*       OS Dependent.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#ifdef _VXWORKS
-#include "vxWorks.h"
-#include "semLib.h"
-#include "errnoLib.h"
-#include "objLib.h"
-int sysClkRateGet(void);
-
-#elif defined(WIN32)
-#include "windows.h"
-/* #include "wdm.h" */
-#elif defined(LINUX)
-#include "/usr/include/semaphore.h"
-typedef    sem_t          semaphore ;
-#endif
-
-#include <msApi.h>
-
-GT_SEM osSemCreate( GT_SEM_BEGIN_STATE state);
-GT_STATUS osSemDelete(GT_SEM smid);
-GT_STATUS osSemWait(  GT_SEM smid, GT_U32 timeOut);
-GT_STATUS osSemSignal(GT_SEM smid);
-
-/*******************************************************************************
-* osSemCreate
-*
-* DESCRIPTION:
-*       Create semaphore.
-*
-* INPUTS:
-*       name   - semaphore Name
-*       init   - init value of semaphore counter
-*       count  - max counter (must be >= 1)
-*
-* OUTPUTS:
-*       smid - semaphore Id
-*
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-GT_SEM osSemCreate(GT_SEM_BEGIN_STATE state)
-{
-#ifdef _VXWORKS
-#if 0
-	return (GT_SEM)semBCreate(SEM_Q_FIFO, state);
-#else
-	GT_SEM semid;
-	semid =(GT_SEM)semBCreate(SEM_Q_FIFO, state);
-	return semid;
-#endif
-
-#elif defined(WIN32)
-	return (GT_SEM)CreateSemaphore(NULL, state, 1, NULL);
-#elif defined(LINUX)
-	semaphore lxSem;
-
-	sem_init(&lxSem, state, 1);
-	return lxSem;
-#else
-	return 1;
-#endif
-	return GT_OK;
-}
-
-/*******************************************************************************
-* osSemDelete
-*
-* DESCRIPTION:
-*       Delete semaphore.
-*
-* INPUTS:
-*       smid - semaphore Id
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-GT_STATUS osSemDelete(GT_SEM smid)
-{
-#ifdef _VXWORKS
-	STATUS rc;
-
-	rc = semDelete((SEM_ID) smid);
-	if (rc != OK)
-		return GT_FAIL;
-
-#elif defined(WIN32)
-	if (CloseHandle((HANDLE)smid) == 0)
-		return GT_FAIL;
-
-#elif defined(LINUX)
-	sem_destroy((semaphore*) smid);
-#else
-	return GT_OK;
-#endif
-
-	return GT_OK;
-}
-
-/*******************************************************************************
-* osSemWait
-*
-* DESCRIPTION:
-*       Wait on semaphore.
-*
-* INPUTS:
-*       smid    - semaphore Id
-*       timeOut - time out in miliseconds or 0 to wait forever
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       OS_TIMEOUT - on time out
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-GT_STATUS osSemWait(GT_SEM smid, GT_U32 timeOut)
-{
-#ifdef _VXWORKS
-	STATUS rc;
-
-	if (timeOut == 0)
-	rc = semTake ((SEM_ID) smid, WAIT_FOREVER);
-	else
-	{
-		int num, delay;
-
-		num = sysClkRateGet();
-		delay = (num * timeOut) / 1000;
-		if (delay < 1)
-			rc = semTake ((SEM_ID) smid, 1);
-		else
-			rc = semTake ((SEM_ID) smid, delay);
-	}
-
-	if (rc != OK)
-	{
-		if (errno == S_objLib_OBJ_TIMEOUT)
-			return GT_TIMEOUT;
-		else
-			return GT_FAIL;
-	}
-
-#elif defined(WIN32)
-	DWORD rc;
-
-	rc = WaitForSingleObject((HANDLE)smid, timeOut);
-
-	if (rc == WAIT_ABANDONED)
-		return GT_FAIL;
-	if (rc == WAIT_TIMEOUT)
-		return GT_TIMEOUT;
-
-#elif defined(LINUX)
-	sem_wait((semaphore*) smid) ; 
-#else
-	return GT_OK;
-
-#endif
-
-	return GT_OK;
-}
-
-/*******************************************************************************
-* osSemSignal
-*
-* DESCRIPTION:
-*       Signal a semaphore.
-*
-* INPUTS:
-*       smid    - semaphore Id
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-GT_STATUS osSemSignal(GT_SEM smid)
-{
-#ifdef _VXWORKS
-	STATUS rc;
-	rc = semGive ((SEM_ID) smid);
-	if (rc != OK)
-		return GT_FAIL;
-
-#elif defined(WIN32)
-	if(ReleaseSemaphore((HANDLE) smid, 1, NULL) == 0)
-		return GT_FAIL;
-
-#elif defined(LINUX)
-	sem_post((semaphore*) smid) ; 
-#else
-	return GT_OK;
-#endif
-	return GT_OK;
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdFFmii.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdFFmii.c
deleted file mode 100644
index 7092e9b..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdFFmii.c
+++ /dev/null
@@ -1,156 +0,0 @@
-/*******************************************************************************
-*                Copyright 2002, Marvell International Ltd.
-* This code contains confidential information of Marvell semiconductor, inc.
-* no rights are granted herein under any patent, mask work right or copyright
-* of Marvell or any third party.
-* Marvell reserves the right at its sole discretion to request that this code
-* be immediately returned to Marvell. This code is provided "as is".
-* Marvell makes no warranties, express, implied or otherwise, regarding its
-* accuracy, completeness or performance.
-*********************************************************************************/
-/* 
- * FILENAME:    $Workfile: qdFFmii.c $ 
- * REVISION:    $Revision: 8 $ 
- * LAST UPDATE: $Modtime: 3/03/03 3:24a $ 
- * 
- * DESCRIPTION: SMI access routines for Firefox board
- *     
- */
-#include "mv_platform.h"
-#include "mv_os.h"
-#include "mv_qd.h"
-
-/*
- * For each platform, all we need is 
- * 1) Assigning functions into 
- * 		fgtReadMii : to read MII registers, and
- * 		fgtWriteMii : to write MII registers.
- *
- * 2) Register Interrupt (Not Defined Yet.)
-*/
-
-/* 
- *  Firefox Specific Definition
- */
-#define SMI_OP_CODE_BIT_READ                    1
-#define SMI_OP_CODE_BIT_WRITE                   0
-#define SMI_BUSY                                1<<28
-#define READ_VALID                              1<<27
-
-#define SMI_TIMEOUT_COUNTER				1000
-
-/*****************************************************************************
-*
-* GT_BOOL qdFFReadMii (GT_QD_DEV* dev, unsigned int portNumber , 
-*                      unsigned int MIIReg, unsigned int* value)
-*
-* Description
-* This function will access the MII registers and will read the value of
-* the MII register , and will retrieve the value in the pointer.
-* Inputs
-* portNumber - one of the 2 possiable Ethernet ports (0-1).
-* MIIReg - the MII register offset.
-* Outputs
-* value - pointer to unsigned int which will receive the value.
-* Returns Value
-* true if success.
-* false if fail to make the assignment.
-* Error types (and exceptions if exist)
-*/
-GT_BOOL ffReadMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                        unsigned int* value)
-{
- 	GT_U32			smiReg;
-	unsigned int	phyAddr;
-	unsigned int	timeOut = SMI_TIMEOUT_COUNTER; /* in 100MS units */
-	int	i;
-
-	/* first check that it is not busy */
-    smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);	
-    if (smiReg & SMI_BUSY) 
-    {
-        for(i=0; i<SMI_TIMEOUT_COUNTER; i++);
-        do 
-		{
-            smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);
-            if (timeOut-- < 1) 
-			{
-                return GT_FALSE;
-    	    }			
-        } while (smiReg & SMI_BUSY);
-    }	
-	/* not busy */
-    phyAddr = portNumber;
-    smiReg =  (phyAddr << 16) | (SMI_OP_CODE_BIT_READ << 26) | (MIIReg << 21) 
-			| SMI_OP_CODE_BIT_READ << 26;
-
-    gtOsGtRegWrite(GT_REG_ETHER_SMI_REG, smiReg);
-    timeOut = SMI_TIMEOUT_COUNTER; /* initialize the time out var again */
-    smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);
-    if (!(smiReg & READ_VALID)) 
-    {
-		for(i = 0 ; i < SMI_TIMEOUT_COUNTER; i++);
-        do 
-		{
-            smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);
-            if (timeOut-- < 1 ) 
-			{
-                return GT_FALSE;
-    	    }
-        } while (!(smiReg & READ_VALID));
-    }
-    *value = (unsigned int)(smiReg & 0xffff);    
-
-    return GT_TRUE;
-}
-
-/*****************************************************************************
-* 
-* GT_BOOL qdFFWriteMii (GT_QD_DEV* dev, unsigned int portNumber , 
-*                       unsigned int MIIReg, unsigned int value)
-* 
-* Description
-* This function will access the MII registers and will write the value
-* to the MII register.
-* Inputs
-* portNumber - one of the 2 possiable Ethernet ports (0-1).
-* MIIReg - the MII register offset.
-* value -the value that will be written.
-* Outputs
-* Returns Value
-* true if success.
-* false if fail to make the assignment.
-* Error types (and exceptions if exist)
-*/
-GT_BOOL ffWriteMii (GT_QD_DEV* dev, unsigned int portNumber , unsigned int MIIReg,
-                       unsigned int value)
-{
-	GT_U32			smiReg;
-	unsigned int	phyAddr;
-	unsigned int	timeOut = SMI_TIMEOUT_COUNTER; /* in 100MS units */
-	int	i;
-
-	/* first check that it is not busy */	
-    smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);
-    if (smiReg & SMI_BUSY) 
-    {
-   	    for(i=0; i<SMI_TIMEOUT_COUNTER; i++);
-        do 
-		{
-            smiReg = gtOsGtRegRead(GT_REG_ETHER_SMI_REG);
-            if (timeOut-- < 1) 
-			{
-                return GT_FALSE;
-    	    }			
-        } while (smiReg & SMI_BUSY);
-    }
-	/* not busy */
-    phyAddr = portNumber;
-
-    smiReg = 0; /* make sure no garbage value in reserved bits */
-    smiReg = smiReg | (phyAddr << 16) | (SMI_OP_CODE_BIT_WRITE << 26) |
-             (MIIReg << 21) | (value & 0xffff);	
-    gtOsGtRegWrite(GT_REG_ETHER_SMI_REG, smiReg);	
-
-    return GT_TRUE;
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInit.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInit.c
deleted file mode 100644
index 503a1df..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInit.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/*******************************************************************************
-*                Copyright 2002, Marvell International Ltd.
-* This code contains confidential information of Marvell semiconductor, inc.
-* no rights are granted herein under any patent, mask work right or copyright
-* of Marvell or any third party.
-* Marvell reserves the right at its sole discretion to request that this code
-* be immediately returned to Marvell. This code is provided "as is".
-* Marvell makes no warranties, express, implied or otherwise, regarding its
-* accuracy, completeness or performance.
-*********************************************************************************/
-/* 
- * FILENAME:    $Workfile: qdInit.c $ 
- * REVISION:    $Revision: 12 $ 
- * LAST UPDATE: $Modtime: 3/03/03 12:01p $ 
- * 
- * DESCRIPTION: QD initialization module
- *     
- */
-#include "mv_qd.h"
-#include "mv_debug.h"
-#include "mv_os.h"
-
-void qdStatus(void);
-
-
-/*
- * A system configuration structure
- * It used to configure the QD driver with configuration data
- * and with platform specific implementation functions 
- */
-GT_SYS_CONFIG   	cfg;
-
-/*
- * The QD device.
- * This struct is a logical representation of the QD switch HW device.
- */
-GT_QD_DEV       	qddev[4] = {{0}};
-
-/*
- * The QD device pointer.
- * A constant pointer to the one and only QD device.
- */
-GT_QD_DEV       	*qd_dev = &qddev[0];
-GT_QD_DEV       	*qd_ext = &qddev[1];
-
-
-/*
- * read mii register - see qdFFmii.c
- */ 
-extern GT_BOOL ffReadMii(GT_QD_DEV* dev, 
-		      unsigned int portNumber , 
-		      unsigned int MIIReg, unsigned int* value
-		      );
-
-/*
- * write mii register - see qdFFmii.c
- */ 
-extern GT_BOOL ffWriteMii(GT_QD_DEV* dev, 
-		       unsigned int portNumber , 
-		       unsigned int MIIReg, 
-		       unsigned int value
-		       );
-
-/*
- * A phy patch for deviceId == GT_88E6063
- */
-static GT_STATUS phyPatch(GT_QD_DEV *dev)
-{
-	GT_U32 u32Data;
-	/*
-	 * Set Bit2 of Register 29 of any phy
-	 */
-    if(gsysReadMiiReg(dev, dev->baseRegAddr,29,&u32Data) != GT_OK)
-	{		
-		return GT_FAIL;
-	}
-
-    if(gsysWriteMiiReg(dev, (GT_U32)dev->baseRegAddr,29,(GT_U16)(u32Data|0x4)) != GT_OK)
-	{		
-		return GT_FAIL;
-	}
-
-	/*
-	 * ReSet Bit6 of Register 30 of any phy
-	 */
-    if(gsysReadMiiReg(dev,dev->baseRegAddr,30,&u32Data) != GT_OK)
-	{		
-		return GT_FAIL;
-	}
-
-    if(gsysWriteMiiReg(dev, (GT_U32)dev->baseRegAddr,30,(GT_U16)(u32Data&(~0x40))) != GT_OK)
-	{		
-		return GT_FAIL;
-	}
-	return GT_OK;
-}
-
-/*
-*  Initialize the QuarterDeck. This should be done in BSP driver init routine.
-*	Since BSP is not combined with QuarterDeck driver, we are doing here.
-*/
-GT_STATUS qdStart(void) /* devId is used for simulator only */
-{
-	GT_STATUS status;
-	/*
-	 *  Register all the required functions to QuarterDeck Driver.
-	 */
-	cfg.BSPFunctions.readMii   = ffReadMii;
-	cfg.BSPFunctions.writeMii  = ffWriteMii;
-#ifdef USE_SEMAPHORE
-	cfg.BSPFunctions.semCreate = osSemCreate;
-	cfg.BSPFunctions.semDelete = osSemDelete;
-	cfg.BSPFunctions.semTake   = osSemWait;
-	cfg.BSPFunctions.semGive   = osSemSignal;
-#else /* USE_SEMAPHORE */
-	cfg.BSPFunctions.semCreate = NULL;
-	cfg.BSPFunctions.semDelete = NULL;
-	cfg.BSPFunctions.semTake   = NULL;
-	cfg.BSPFunctions.semGive   = NULL;
-#endif /* USE_SEMAPHORE */
-
-	cfg.initPorts = GT_TRUE;	
-	cfg.cpuPortNum = GT_CPU_SWITCH_PORT;	
-	qd_dev->cpuPortNum = GT_CPU_SWITCH_PORT;	
-	if((status = qdLoadDriver(&cfg, qd_dev)) != GT_OK) {		
-	  gtOsPrintf("qdLoadDriver is failed: status = 0x%x\n", status);
-	  return status;
-	}
-	
-	/*
-	*  start the QuarterDeck
-	*/
-	if (qd_dev->deviceId == GT_88E6063) {
-	  phyPatch(qd_dev);
-	}
-
-	/* to which VID should we set the CPU_PORT? (1 is temporary)*/
-	if((status = gvlnSetPortVid(qd_dev, GT_CPU_SWITCH_PORT, 5)) != GT_OK) {
-	  gtOsPrintf("gprtSetPortVid returned fail for CPU port.\n");
-	  return status;
-	}
-
-#ifdef QD_TRAILER_MODE
-	/* set ingress trailer mode*/
-	gprtSetIngressMode(qd_dev, GT_CPU_SWITCH_PORT, GT_TRAILER_INGRESS);	
-	/* set egress trailer*/
-	gprtSetTrailerMode(qd_dev, GT_CPU_SWITCH_PORT, GT_TRUE);
-#endif
-
-#ifdef QD_HEADER_MODE
-	if((status = gprtSetHeaderMode(qd_dev, GT_CPU_SWITCH_PORT, GT_TRUE)) != GT_OK)
-	{
-	  gtOsPrintf("gprtSetHeaderMode return Failed\n");
-	  return status;
-	}   
-#endif
-
-	return GT_OK;    
-}
-
-
-void qdClose(void) 
-{
-	if (qd_dev->devEnabled)
-		qdUnloadDriver(qd_dev);
-}
-
-
-GT_STATUS qdInit(void)
-{
-	GT_STATUS	 status = GT_OK;	
-	unsigned int i;
-
-	status = qdStart();
-	if (GT_OK != status)
-	{
-		gtOsPrintf("qdStart is failed: status = 0x%x\n", status);
-		return status;
-	}
-
-#ifdef DB_6093_88E6218
-	/* start 88E6090 device, assumes SMI Address 0x11 and CPU Port 10 */
-
-	if(loadDev(qd_ext, SMI_MULTI_ADDR_MODE, 0x11, 10) == NULL)
-	{
-		gtOsPrintf("Failed to start External Device. Please check the SMI Address 0x11!\n");
-	}
-
-	/* allow larger than 1522 bytes of frame (header + marvell tag) */
-	gsysSetMaxFrameSize(qd_dev,GT_FALSE);
-
-#endif
-
-    for (i=0; i<qd_dev->numOfPorts; i++) 
-    {
-      /* default port prio to three */
-      gcosSetPortDefaultTc(qd_dev, i, 3);       
-      /* disable IP TOS Prio */
-      gqosIpPrioMapEn(qd_dev, i, GT_FALSE);  
-      /* disable QOS Prio */
-      gqosUserPrioMapEn(qd_dev, i, GT_FALSE);
-      /* Force flow control for all ports */
-      gprtSetForceFc(qd_dev, i, GT_FALSE);
-    }
-
-	/* Enable port #6 */
-	status = gstpSetPortState(qd_dev, 6, GT_PORT_FORWARDING);
-
-	if((status = gprtClearAllCtr(qd_dev)) != GT_OK)
-	{		
-		return status;
-	}	
-	for (i=0; i<GT_CPU_SWITCH_PORT; i++)
-	{
-		gprtSetMcRateLimit(qd_dev, i, GT_MC_100_PERCENT_RL);
-	}
-
-#ifdef QD_DEBUG
-    for (i=0; i<qd_dev->numOfPorts; i++) 
-	{
-		short sdata;
-	  
-	  	hwReadPortReg(qd_dev, i, 0x4, &sdata);
-	  	gtOsPrintf("Control reg for port[%d] is: %x\n",i,sdata);
-
-	  	hwReadPortReg(qd_dev, i, 0x0, &sdata);
-	  	gtOsPrintf("Status reg for port[%d] is: %x\n",i,sdata);
-
-	}
-    qdStatus();
-#endif /* QD_DEBUG */
-
-    gtOsPrintf("QD initiated\n");
-
-	return status;    
-}
-
-static const char* qdPortStpStates[] = 
-	{"DISABLE",
-     "BLOCKING",
-     "LEARNING",
-     "FORWARDING"};	
-
-static char* qdPortListToStr(GT_LPORT* portList, int portListNum,
-							char* portListStr)
-{
-	int	port, idx, strIdx=0;
-	
-	for(idx=0; idx<portListNum; idx++)
-	{
-		port = portList[idx];
-		sprintf(&portListStr[strIdx], "%d,", port);
-		strIdx = strlen(portListStr);
-	}
-	portListStr[strIdx] = '\0';
-	return portListStr;
-}
-
-void qdStatus(void)
-{
-	int 				port;
-	GT_BOOL				linkState;
-	GT_PORT_STP_STATE 	stpState;
-	GT_PORT_STAT    	counters;
-	GT_U16				pvid;
-	GT_LPORT 			portList[GT_NUM_OF_SWITCH_PORTS];
-    GT_U8    			portNum;
-	char				portListStr[100];
-
-	gtOsPrintf("Port  Link   PVID    Group       State       RxCntr      TxCntr\n\n");
-
-    for (port=0; port<GT_NUM_OF_SWITCH_PORTS; port++) 
-	{
-		gprtGetLinkState(qd_dev, port, &linkState);
-		gstpGetPortState(qd_dev, port, &stpState);
-		gprtGetPortCtr(qd_dev,port, &counters);
-		gstpGetPortState(qd_dev, port, &stpState);
-		gvlnGetPortVid(qd_dev, port, &pvid);
-		gvlnGetPortVlanPorts(qd_dev, port, portList, &portNum);
-		qdPortListToStr(portList, portNum, portListStr);
-
-		gtOsPrintf(" %d.   %4s    %d     %-10s  %-10s   0x%-8x  0x%-8x\n",
-					port, (linkState==GT_TRUE) ? "UP" : "DOWN",
-					pvid, portListStr, qdPortStpStates[stpState],
-					counters.rxCtr, counters.txCtr);
-	}
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInt.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInt.c
deleted file mode 100644
index c274554..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdInt.c
+++ /dev/null
@@ -1,355 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* qdInt.c
-*
-* DESCRIPTION:
-*		This sample shows how to call QuarterDeck Interrupt handler when QD INT
-*		raised, and how to take care each Interrupt Cause.
-*
-* DEPENDENCIES:   NONE.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#include "msSample.h"
-
-#ifdef QD_DEBUG
-#ifdef _VXWORKS
-#define INT_MSG_PRINT	logMsg
-#else
-#define INT_MSG_PRINT	printf
-#endif
-#else	/* QD_DEBUG */
-#define INT_MSG_PRINT(_x,_a0,_a1,_a2,_a3,_a4,_a5)	while(0){}
-#endif
-
-GT_U32 QDIntMask = GT_VTU_PROB|GT_ATU_PROB|GT_PHY_INTERRUPT;
-
-/*
- *	To enable quarterDeck interrupt, you need to call eventSetActive() and
- *	gprtPhyIntEnable(), as following sample routine.
- *	sampleQDIntEnable will enable all interrupt causes.
- *	For Port, GT_ATU_FULL, GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
- *	are enabled.
- *	For every Phy (0 ~ 4), GT_SPEED_CHANGED, GT_DUPLEX_CHANGED, GT_PAGE_RECEIVED,
- *	GT_AUTO_NEG_COMPLETED, GT_LINK_STATUS_CHANGED, GT_SYMBOL_ERROR, 
- *	GT_FALSE_CARRIER, GT_FIFO_FLOW, GT_CROSSOVER_CHANGED, GT_POLARITY_CHANGED,
- *	and GT_JABBER are enabled.
-*/
-GT_STATUS qdIntEnable(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_U16 data;
-	int port;
-
-	/* 
-	 *	Enable QuarterDeck interrupt for ATUFull, ATUDone, PHYInt, and EEInt.
-	 *	If writing 0 into eventSetActive(), all port interrupt will be disabled.
-	*/
-	data = QDIntMask;
-	if((status = eventSetActive(dev,data)) != GT_OK)
-	{
-		MSG_PRINT(("eventSetActive returned fail.\n"));
-		return status;
-	}
-
-	/* 
-	 *	Enable Phy interrupt for every possible interrupt cause.
-	 *	If writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
-	*/
-	data = 	GT_SPEED_CHANGED|GT_DUPLEX_CHANGED|GT_LINK_STATUS_CHANGED;
-
-	for(port=0; port<3; port++)
-	{
-		if((status = gprtPhyIntEnable(dev,port,data)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
-			return status;
-		}
-	}
-
-	return GT_OK;
-}
-
-/*
- *	Disable QuarterDeck Interrupt.
-*/
-GT_STATUS qdIntDisable(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	int port;
-
-	/* 
-	 *	Writing 0 into eventSetActive(), all port interrupt will be disabled.
-	*/
-	if((status = eventSetActive(dev,0)) != GT_OK)
-	{
-		MSG_PRINT(("eventSetActive returned fail.\n"));
-		return status;
-	}
-
-	for(port=0; port<3; port++)
-	{
-		if((status = gprtPhyIntEnable(dev,port,0)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
-			return status;
-		}
-	}
-
-	return GT_OK;
-}
-
-
-/*
- *	Assume that the following function, sampleQDIntVector(), is registered 
- *	when BSP calls intConnect for QD Interrupt.
- *	This sample will show how to deal with QuarterDeck Interrupt.
-*/
-GT_STATUS qdIntVector(GT_QD_DEV *dev)
-{
-	GT_U16 intCause,data,phyIntCause;
-    GT_VTU_INT_STATUS vtuIntStatus;
-    GT_ATU_INT_STATUS atuIntStatus;
-	int port;
-
-	/*
-	 *	Disable QuarterDeck Interrupt in System Level.
-	 *	ToDo...
-	*/
-
-	/*
-	 *	Check if QD generated the interrupt.
-	*/
-	if(eventGetIntStatus(dev,&intCause) != GT_TRUE)
-	{
-		/* QD didn't generate the interrupt. */
-		return GT_FAIL;
-	}
-
-	/*
-	 *	QD generated interrupt with the reason in intCause.
-	*/
-	if(intCause & GT_VTU_PROB)
-	{
-		INT_MSG_PRINT("VTU PROB INT for Dev %#x.\n",(int)dev,0,0,0,0,0);
-		/* 
-		 *	VTU member violation, miss violation, or full violation.
-		*/
-		do
-		{
-			if(gvtuGetIntStatus(dev, &vtuIntStatus) != GT_OK)
-			{
-				/* reading VTU Int Status Failed */
-				INT_MSG_PRINT("VTU INT Status read failure.\n",0,0,0,0,0,0);
-				break;
-			}
-			INT_MSG_PRINT("VTU INT : Cause %#x, SPID %i, VID %i\n",vtuIntStatus.vtuIntCause,vtuIntStatus.spid,vtuIntStatus.vid,0,0,0);
-		} while (vtuIntStatus.vtuIntCause);
-	}
-
-	if(intCause & GT_ATU_PROB)
-	{
-		/* 
-		 *	ATU cannot load or learn a new mapping due to all the available
-		 *	locations for an address being locked.
-		 *	ToDo...
-		*/
-		INT_MSG_PRINT("ATU PROB INT for Dev %#x.\n",(int)dev,0,0,0,0,0);
-
-		do
-		{
-			if(gatuGetIntStatus(dev, &atuIntStatus) != GT_OK)
-			{
-				/* reading ATU Int Status Failed */
-				INT_MSG_PRINT("ATU INT Status read failure.\n",0,0,0,0,0,0);
-				break;
-			}
-			INT_MSG_PRINT("ATU INT : Cause %#x, SPID %i, DBNum %i\n",atuIntStatus.atuIntCause,atuIntStatus.spid,atuIntStatus.dbNum,0,0,0);
-			INT_MSG_PRINT("ATU INT : MAC %02x-%02x-%02x-%02x-%02x-%02x\n",
-									atuIntStatus.macAddr.arEther[0],
-									atuIntStatus.macAddr.arEther[1],
-									atuIntStatus.macAddr.arEther[2],
-									atuIntStatus.macAddr.arEther[3],
-									atuIntStatus.macAddr.arEther[4],
-									atuIntStatus.macAddr.arEther[5]);
-		} while (atuIntStatus.atuIntCause);
-
-	}
-
-	if(intCause & GT_ATU_DONE)
-	{
-		/* 
-		 *	There is a transitions from a one to a zero on ATUBusy bit
-		 *	(Refer to ATU Operation Register.)
-		 *	ToDo...
-		*/
-		INT_MSG_PRINT("ATU Done INT for Dev %#x.\n",(int)dev,0,0,0,0,0);
-	}
-
-#if 1
-
-	if(intCause & GT_PHY_INTERRUPT)
-	{
-		/* 
-		 *	At least one of the Phy generated interrupt.
-		 *	We need to read Phy Interrupt Summary and go through each phy
-		 *	based on the summary.
-		*/
-
-		if(gprtGetPhyIntPortSummary(dev,&data) != GT_OK)
-		{
-			return GT_FAIL;
-		}
-
-		INT_MSG_PRINT("Phy INT (Port Vector %#x).\n",(int)data,0,0,0,0,0);
-
-		port = 0;
-		while(data)
-		{
-			if(data & 0x01)
-			{
-				/*
-				 *	Call gprtGetPhyIntStatus to get intCause
-				*/
-				if(gprtGetPhyIntStatus(dev,port,&phyIntCause) != GT_OK)
-				{
-					/* 
-					 *	Something wrong with the system. Need to do the 
-					 *	necessary work. 
-					 *	ToDo...
-					*/
-				}
-
-				INT_MSG_PRINT("Port %i: %#x.\n",port,phyIntCause,0,0,0,0);
-
-				if(phyIntCause & GT_SPEED_CHANGED)
-				{
-					/* 
-					 *	Speed has been changed.
-					 *	ToDo...
-					*/
-					INT_MSG_PRINT("SPEED CHANGE\n",0,0,0,0,0,0);
-				}
-
-				if(phyIntCause & GT_DUPLEX_CHANGED)
-				{
-					/* 
-					 *	Duplex mode has been changed.
-					 *	ToDo...
-					*/
-					INT_MSG_PRINT("DUPLEX CHANGE\n",0,0,0,0,0,0);
-				}
-
-				if(phyIntCause & GT_PAGE_RECEIVED)
-				{
-					/* 
-					 *	Page received.
-					 *	ToDo...
-					*/
-
-					INT_MSG_PRINT("PAGE RECEIVED\n",0,0,0,0,0,0);
-				}
-
-				if(phyIntCause & GT_AUTO_NEG_COMPLETED)
-				{
-					/* 
-					 *	AutoNegotiation completed.
-					 *	ToDo...
-					*/
-					INT_MSG_PRINT("AUTO NEG COMPLETED\n",0,0,0,0,0,0);
-
-				}
-
-				if(phyIntCause & GT_LINK_STATUS_CHANGED)
-				{
-					/* 
-					 *	Link Status changed.
-					 *	ToDo...
-					*/
-
-					INT_MSG_PRINT("LINK CHANGE\n",0,0,0,0,0,0);
-				}
-
-				if(phyIntCause & GT_SYMBOL_ERROR)
-				{
-					/* 
-					 *	Symbol error
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_FALSE_CARRIER)
-				{
-					/* 
-					 *	False Carrier.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_FIFO_FLOW)
-				{
-					/* 
-					 *	Fifo Overflow/underflow error
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_CROSSOVER_CHANGED)
-				{
-					/* 
-					 *	MDI/MDIX crossover changed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_POLARITY_CHANGED)
-				{
-					/* 
-					 *	Polarity changed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_JABBER)
-				{
-					/* 
-					 *	Jabber
-					 *	ToDo...
-					*/
-
-				}
-			}
-
-			data >>= 1;
-			port++;
-		}
-	}
-
-	if(intCause & GT_EE_INTERRUPT)
-	{
-		/* 
-		 *	EEPROM is done loading registers.
-		 *	ToDo...
-		*/
-
-	}
-
-
-	/*
-	 *	Now, all the QuarterDeck related interrupt have been cleared,
-	 *	so it's OK to enable QuarterDeck Interrupt in System Level.
-	 *	ToDo...
-	*/
-
-#endif
-	
-	return GT_OK;
-
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSim.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSim.c
deleted file mode 100644
index 557df5f..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSim.c
+++ /dev/null
@@ -1,2004 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* qdSim.c
-*
-* DESCRIPTION:
-*       Simulate QuaterDeck Device(88E6052)'s register map. When QuareterDeck API 
-*		try to read/write a bit or bits into QuaterDeck, the simulator will redirect to
-* 		its own memory place and performing the function very close to QuaterDeck.
-*		For example, 
-*		1) user can set/reset a certain bit of QuarterDeck registers(Phy,Port,and General registers).
-*		2) user can access ATU (flush, load, purge, etc. with max MAC addresses of 32)
-*		3) user can manually generate an Interrupt and test the Interrupt routine.
-*		4) when user read a register, it will clear a certain register if it's a Self Clear register.
-*		5) when user write a register, it will return ERROR if it's read only register.
-*		 
-*
-* DEPENDENCIES:   QuaterDeck (88E6052) Register MAP.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#include <msApi.h>
-#include <qdSimRegs.h>
-
-#define IS_BROADCAST_ADDR(_addr)                                \
-            (((_addr)[0] == 0xFF) && ((_addr)[1] == 0xFF) &&    \
-             ((_addr)[2] == 0xFF) && ((_addr)[3] == 0xFF) &&    \
-             ((_addr)[4] == 0xFF) && ((_addr)[5] == 0xFF))
-
-#define IS_GLOBAL_REG(_port)	((int)(_port) == qdSimDev.qdSimGlobalRegBase)
-#define IS_PORT_REG(_port) (((int)(_port) >= qdSimDev.qdSimPortBase) && ((int)(_port) < qdSimDev.qdSimPortBase + qdSimDev.qdSimNumOfPorts))
-#define IS_PHY_REG(_port) (((int)(_port) >= qdSimDev.qdSimPhyBase) && ((int)(_port) < qdSimDev.qdSimPhyBase + qdSimDev.qdSimNumOfPhys))
-
-typedef struct _QD_SIM_DEV
-{
-	int qdSimUsed;
-	unsigned int qdSimDevId;
-	int qdSimNumOfPorts;
-	int qdSimPortBase;
-	int qdSimNumOfPhys;
-	int qdSimPhyBase;
-	int qdSimGlobalRegBase;
-	int qdSimPortStatsClear[10];
-	int qdSimStatsCapturedPort;
-	int vtuSize;
-	int atuSize;
-} QD_SIM_DEV;
-
-static QD_SIM_DEV qdSimDev = {0};
-
-void qdSimRegsInit();
-GT_BOOL qdSimRead (GT_QD_DEV *dev, unsigned int portNumber , unsigned int miiReg, unsigned int* value);
-GT_BOOL qdSimWrite(GT_QD_DEV *dev, unsigned int portNumber , unsigned int miiReg, unsigned int value);
-
-/*
- *	This Array will simulate the QuarterDeck Registers.
- *	To use it, qdSimRegs has to be initialized with its default values and
- *	Call qdSimRead and qdSimWrite functions.
-*/
-#define MAX_SMI_ADDRESS		0x20
-#define MAX_REG_ADDRESS		0x20
-#define MAX_ATU_ADDRESS		0x800
-#define MAX_QD_VTU_ENTRIES	0x40
-
-GT_U16 qdSimRegs[MAX_SMI_ADDRESS][MAX_REG_ADDRESS];
-
-typedef struct _QDSIM_ATU_ENTRY
-{
-	GT_U16 atuData;
-	GT_U16 DBNum;
-	GT_U8 atuMac[6];
-} QDSIM_ATU_ENTRY;
-
-/* 
-	Since QuarterDeck Simulator supports only fixed size of atu entry,
-	we are going with array list not dynamic linked list.
-*/
-typedef struct _QDSIM_ATU_NODE
-{
-	QDSIM_ATU_ENTRY atuEntry;
-	GT_U32 nextEntry;
-} QDSIM_ATU_NODE;
-
-typedef struct _QDSIM_ATU_LIST
-{
-	int atuSize;
-	GT_U32 head;
-} QDSIM_ATU_LIST;
-
-QDSIM_ATU_NODE ATUNode[MAX_ATU_ADDRESS];
-QDSIM_ATU_LIST ATUList;
-
-typedef struct _QDSIM_VTU_ENTRY
-{
-	GT_U16 DBNum;
-	GT_U16 memberTag[10];
-	GT_U16 vid;
-} QDSIM_VTU_ENTRY;
-
-/* 
-	Since QuarterDeck Simulator supports only fixed size of atu entry,
-	we are going with array list not dynamic linked list.
-*/
-typedef struct _QDSIM_VTU_NODE
-{
-	QDSIM_VTU_ENTRY vtuEntry;
-	GT_U32 nextEntry;
-} QDSIM_VTU_NODE;
-
-typedef struct _QDSIM_VTU_LIST
-{
-	int vtuSize;
-	GT_U32 head;
-} QDSIM_VTU_LIST;
-
-QDSIM_VTU_NODE VTUNode[MAX_QD_VTU_ENTRIES];
-QDSIM_VTU_LIST VTUList;
-
-/*******************************************************************************
-* qdMemSet
-*
-* DESCRIPTION:
-*       Set a block of memory
-*
-* INPUTS:
-*       start  - start address of memory block for setting
-*       simbol - character to store, converted to an unsigned char
-*       size   - size of block to be set
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       Pointer to set memory block
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-void * qdMemSet
-(
-    IN void * start,
-    IN int    symbol,
-    IN GT_U32 size
-)
-{
-	GT_U32 i;
-	char* buf;
-	
-	buf = (char*)start;
-		
-	for(i=0; i<size; i++)
-	{
-		*buf++ = (char)symbol;
-	}
-
-	return start;
-}
-
-/*******************************************************************************
-* qdMemCpy
-*
-* DESCRIPTION:
-*       Copies 'size' characters from the object pointed to by 'source' into
-*       the object pointed to by 'destination'. If copying takes place between
-*       objects that overlap, the behavior is undefined.
-*
-* INPUTS:
-*       destination - destination of copy
-*       source      - source of copy
-*       size        - size of memory to copy
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       Pointer to destination
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-void * qdMemCpy
-(
-    IN void *       destination,
-    IN const void * source,
-    IN GT_U32       size
-)
-{
-	GT_U32 i;
-	char* buf;
-	char* src;
-	
-	buf = (char*)destination;
-	src = (char*)source;
-		
-	for(i=0; i<size; i++)
-	{
-		*buf++ = *src++;
-	}
-
-	return destination;
-}
-
-/*******************************************************************************
-* qdMemCmp
-*
-* DESCRIPTION:
-*       Compares given memories.
-*
-* INPUTS:
-*       src1 - source 1
-*       src2 - source 2
-*       size - size of memory to copy
-*
-* OUTPUTS:
-*       None
-*
-* RETURNS:
-*       0, if equal.
-*		negative number, if src1 < src2.
-*		positive number, if src1 > src2.
-*
-* COMMENTS:
-*       None
-*
-*******************************************************************************/
-int qdMemCmp
-(
-    IN char src1[],
-    IN char src2[],
-    IN GT_U32 size
-)
-{
-	GT_U32 i;
-	int value;
-
-	for(i=0; i<size; i++)
-	{
-		if((value = (int)(src1[i] - src2[i])) != 0)
-			return value; 
-	}
-
-	return 0;
-}
-
-/*
-	Compare the given ethernet addresses.
-	0, if they are equal.
-	Negative int, if mac2 is bigger than mac1.
-	Positive int, if mac1 is bigger than mac2.
-*/
-int cmpEtherMac(unsigned char* mac1, unsigned char* mac2)
-{
-	int i, tmp;
-
-	for(i=0; i<6; i++)
-	{
-		if((tmp = mac1[i] - mac2[i]) != 0)
-			return tmp;
-	}
-	return 0;
-}
-
-/*
-	entry index, if found.
-	MAX_ATU_ADDRESS, otherwise.
-*/
-int qdSimATUFindNext(QDSIM_ATU_ENTRY* entry)
-{
-	int i;
-	int node = ATUList.head;
-
-	if (IS_BROADCAST_ADDR(entry->atuMac))
-	{
-		if(ATUList.atuSize != 0)
-		{
-			if (ATUNode[node].atuEntry.DBNum == entry->DBNum)
-				return node;
-			else
-			{
-				for(i=0; i<ATUList.atuSize; i++)
-				{
-					if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
-						return node;
-					node = ATUNode[node].nextEntry;
-				}
-			}
-				
-		}
-		return MAX_ATU_ADDRESS;
-	}
-
-	for(i=0; i<ATUList.atuSize; i++)
-	{
-		if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) > 0)
-		{
-			if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
-				break;
-		}
-		node = ATUNode[node].nextEntry;
-	}
-
-	if (i == ATUList.atuSize)
-		return MAX_ATU_ADDRESS;
-
-	return node;
-}
-
-/*
-	Return 1, if added successfully.
-	Return 0, otherwise.
-*/
-GT_BOOL qdSimATUAdd(QDSIM_ATU_ENTRY* entry)
-{
-	int i, freeNode, preNode, node;
-
-	preNode = node = ATUList.head;
-
-	if (ATUList.atuSize >= MAX_ATU_ADDRESS)
-		return GT_FALSE;
-
-	/* find a free entry from our global memory. */
-	for(i=0; i<MAX_ATU_ADDRESS; i++)
-	{
-		if(ATUNode[i].nextEntry == MAX_ATU_ADDRESS)
-			break;
-	}
-	
-	if (i==MAX_ATU_ADDRESS)
-	{
-		return GT_FALSE;
-	}
-
-	freeNode = i;
-
-	/* find the smallest entry which is bigger than the given entry */
-	for(i=0; i<ATUList.atuSize; i++)
-	{
-		if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) >= 0)
-			break;
-		preNode = node;
-		node = ATUNode[node].nextEntry;
-	}	
-
-	/* if the same Mac address is in the list and dbnum is identical, then just update and return. */
-	if (i != ATUList.atuSize)
-		if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) == 0)
-		{
-			if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
-			{
-				ATUNode[node].atuEntry.atuData = entry->atuData;
-				return GT_TRUE;
-			}
-		}
-
-	qdMemCpy(ATUNode[freeNode].atuEntry.atuMac, entry->atuMac, 6);
-	ATUNode[freeNode].atuEntry.atuData = entry->atuData;
-	ATUNode[freeNode].atuEntry.DBNum = entry->DBNum;
-
-	/* Add it to head */
-	if (i == 0)
-	{
-		ATUNode[freeNode].nextEntry = ATUList.head;
-		ATUList.head = freeNode;
-	}
-	/* Add it to tail */
-	else if (i == ATUList.atuSize)
-	{
-		ATUNode[preNode].nextEntry = freeNode;
-		ATUNode[freeNode].nextEntry = ATUList.head;
-	}
-	/* Add it in the middle of the list */
-	else
-	{
-		ATUNode[freeNode].nextEntry = ATUNode[preNode].nextEntry;
-		ATUNode[preNode].nextEntry = freeNode;
-	}
-	ATUList.atuSize++;
-	return GT_TRUE;
-}
-
-
-/*
-	Return 1, if added successfully.
-	Return 0, otherwise.
-*/
-GT_BOOL qdSimATUDel(QDSIM_ATU_ENTRY* entry)
-{
-	int i, preNode, node;
-
-	preNode = node = ATUList.head;
-
-	/* find the entry */
-	for(i=0; i<ATUList.atuSize; i++)
-	{
-		if(cmpEtherMac(ATUNode[node].atuEntry.atuMac,entry->atuMac) == 0)
-		{
-			if(ATUNode[node].atuEntry.DBNum == entry->DBNum)
-				break;
-		}
-		preNode = node;
-		node = ATUNode[node].nextEntry;
-	}	
-
-	if (i == ATUList.atuSize)
-	{
-		/* cannot find the given entry to be deleted. */
-		return GT_FALSE;
-	}
-
-	/* Delete it from head */
-	if (i == 0)
-	{
-		ATUList.head = ATUNode[node].nextEntry;
-	}
-	/* Delete it in the middle of the list */
-	else if (i != ATUList.atuSize-1)
-	{
-		ATUNode[preNode].nextEntry = ATUNode[node].nextEntry;
-	}
-	ATUList.atuSize--;
-	ATUNode[node].nextEntry = MAX_ATU_ADDRESS;
-
-	return GT_TRUE;
-}
-
-
-GT_BOOL qdSimATUFlushUnlockedEntry()
-{
-	int i;
-
-	for (i=0; i<MAX_ATU_ADDRESS; i++)
-	{
-		if(((ATUNode[i].atuEntry.atuData & 0xF) != 0xF)	&&
-			(!(ATUNode[i].atuEntry.atuMac[0] & 1)) 		&&
-			(ATUNode[i].nextEntry != MAX_ATU_ADDRESS))
-		{
-			qdSimATUDel(&ATUNode[i].atuEntry);
-		}			
-	}
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimATUFlushInDB(int dbNum)
-{
-	int i;
-
-	for (i=0; i<MAX_ATU_ADDRESS; i++)
-	{
-		if(ATUNode[i].atuEntry.DBNum != dbNum)
-			continue;
-		qdSimATUDel(&ATUNode[i].atuEntry);
-	}
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimATUFlushUnlockedInDB(int dbNum)
-{
-	int i;
-
-	for (i=0; i<MAX_ATU_ADDRESS; i++)
-	{
-		if(ATUNode[i].atuEntry.DBNum != dbNum)
-			continue;
-		
-		if(((ATUNode[i].atuEntry.atuData & 0xF) != 0xF)	&&
-			(!(ATUNode[i].atuEntry.atuMac[0] & 1)) 		&&
-			(ATUNode[i].nextEntry != MAX_ATU_ADDRESS))
-		{
-			qdSimATUDel(&ATUNode[i].atuEntry);
-		}			
-	}
-	return GT_TRUE;
-}
-
-
-void qdSimATUInit()
-{
-	int i;
-
-	qdMemSet((char*)ATUNode, 0, sizeof(ATUNode));
-
-	/* MAX_ATU_ADDRESS means entry i is free, otherwise, it's not free */
-	for (i=0; i<MAX_ATU_ADDRESS; i++)
-		ATUNode[i].nextEntry = MAX_ATU_ADDRESS;
-
-	ATUList.atuSize = 0;	
-	ATUList.head = 0;	
-}
-
-void qdSimGetATUInfo(QDSIM_ATU_ENTRY* entry)
-{
-	entry->atuData = qdSimRegs[qdSimDev.qdSimGlobalRegBase][12];
-	entry->atuMac[0] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] >> 8) & 0xFF;
-	entry->atuMac[1] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] & 0xFF;
-	entry->atuMac[2] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] >> 8) & 0xFF;
-	entry->atuMac[3] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] & 0xFF;
-	entry->atuMac[4] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] >> 8) & 0xFF;
-	entry->atuMac[5] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] & 0xFF;
-	entry->DBNum = qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] & 0xF;
-	return;
-}
-
-void qdSimSetATUInfo(QDSIM_ATU_ENTRY* entry)
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = entry->atuData;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = (entry->atuMac[0]<<8) | entry->atuMac[1];
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = (entry->atuMac[2]<<8) | entry->atuMac[3];
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = (entry->atuMac[4]<<8) | entry->atuMac[5];
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (entry->DBNum & 0xF);
-
-	return;
-}
-
-void qdSimReSetATUInfo()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = 0;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = 0xFFFF;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = 0xFFFF;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = 0xFFFF;
-
-	return;
-}
-
-GT_BOOL qdSimATUOperation(unsigned int value)
-{
-	QDSIM_ATU_ENTRY entry;
-	int	index;
-
-	switch((value & 0x7000) >> 12)
-	{
-		case 1:
-			/* Flush ALL */
-			qdSimATUInit();
-			break;
-		case 2:
-			/* Flush all unlocked entries */
-			return qdSimATUFlushUnlockedEntry();
-		case 3:
-			/* Load or Purge entry */
-			qdSimGetATUInfo(&entry);
-			if(entry.atuData & 0xF)
-				return qdSimATUAdd(&entry);
-			else
-				return qdSimATUDel(&entry);
-			break;
-		case 4:
-			/* Get Next Entry */
-			qdSimGetATUInfo(&entry);
-			index = qdSimATUFindNext(&entry);
-			if (index == MAX_ATU_ADDRESS)
-			{
-				qdSimReSetATUInfo();
-				return GT_TRUE;
-			}
-			else
-			{
-				qdSimSetATUInfo(&ATUNode[index].atuEntry);
-				return GT_TRUE;
-			}
-			break;
-		case 5:
-			/* Flush ALL in a DBNum */
-			return qdSimATUFlushInDB(value & 0xF);
-			break;
-		case 6:
-			/* Flush all unlocked entries */
-			return qdSimATUFlushUnlockedInDB(value & 0xF);
-		default:
-			break;
-	}
-	return GT_TRUE;
-}
-
-/*
-	VTU Related Routines
-*/
-
-/*
-	entry index, if found.
-	MAX_QD_VTU_ENTRIES, otherwise.
-*/
-int qdSimVTUFindNext(QDSIM_VTU_ENTRY* entry)
-{
-	int i;
-	int node = VTUList.head;
-
-	if (entry->vid == 0xFFF)
-	{
-		if(VTUList.vtuSize != 0)
-			return node;
-		else
-			return MAX_QD_VTU_ENTRIES;
-	}
-		
-	for(i=0; i<VTUList.vtuSize; i++)
-	{
-		if(VTUNode[node].vtuEntry.vid > entry->vid)
-			break;
-		node = VTUNode[node].nextEntry;
-	}
-
-	if (i == VTUList.vtuSize)
-		return MAX_QD_VTU_ENTRIES;
-
-	return node;
-}
-
-/*
-	Return 1, if added successfully.
-	Return 0, otherwise.
-*/
-GT_BOOL qdSimVTUAdd(QDSIM_VTU_ENTRY* entry)
-{
-	int i, freeNode, preNode, node;
-
-	preNode = node = VTUList.head;
-
-	if (VTUList.vtuSize >= qdSimDev.vtuSize)
-		return GT_FALSE;
-
-	/* find a free entry from our global memory. */
-	for(i=0; i<MAX_QD_VTU_ENTRIES; i++)
-	{
-		if(VTUNode[i].nextEntry == MAX_QD_VTU_ENTRIES)
-			break;
-	}
-	
-	if (i==MAX_QD_VTU_ENTRIES)
-	{
-		return GT_FALSE;
-	}
-
-	freeNode = i;
-
-	/* find the smallest entry which is bigger than the given entry */
-	for(i=0; i<VTUList.vtuSize; i++)
-	{
-		if(VTUNode[node].vtuEntry.vid >= entry->vid)
-			break;
-		preNode = node;
-		node = VTUNode[node].nextEntry;
-	}	
-
-	/* if the same vid is in the list, then just update and return. */
-	if (i != VTUList.vtuSize)
-		if(VTUNode[node].vtuEntry.vid == entry->vid)
-		{
-			qdMemCpy(&VTUNode[node].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
-			return GT_TRUE;
-		}
-
-	qdMemCpy(&VTUNode[freeNode].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
-
-	/* Add it to head */
-	if (i == 0)
-	{
-		VTUNode[freeNode].nextEntry = VTUList.head;
-		VTUList.head = freeNode;
-	}
-	/* Add it to tail */
-	else if (i == VTUList.vtuSize)
-	{
-		VTUNode[preNode].nextEntry = freeNode;
-		VTUNode[freeNode].nextEntry = VTUList.head;
-	}
-	/* Add it in the middle of the list */
-	else
-	{
-		VTUNode[freeNode].nextEntry = VTUNode[preNode].nextEntry;
-		VTUNode[preNode].nextEntry = freeNode;
-	}
-	VTUList.vtuSize++;
-	return GT_TRUE;
-}
-
-
-/*
-	Return 1, if added successfully.
-	Return 0, otherwise.
-*/
-GT_BOOL qdSimVTUDel(QDSIM_VTU_ENTRY* entry)
-{
-	int i, preNode, node;
-
-	preNode = node = VTUList.head;
-
-	/* find the entry */
-	for(i=0; i<VTUList.vtuSize; i++)
-	{
-		if(VTUNode[node].vtuEntry.vid == entry->vid)
-			break;
-		preNode = node;
-		node = VTUNode[node].nextEntry;
-	}	
-
-	if (i == VTUList.vtuSize)
-	{
-		/* cannot find the given entry to be deleted. */
-		return GT_FALSE;
-	}
-
-	/* Delete it from head */
-	if (i == 0)
-	{
-		VTUList.head = VTUNode[node].nextEntry;
-	}
-	/* Delete it in the middle of the list */
-	else if (i != VTUList.vtuSize-1)
-	{
-		VTUNode[preNode].nextEntry = VTUNode[node].nextEntry;
-	}
-	VTUList.vtuSize--;
-	VTUNode[node].nextEntry = MAX_QD_VTU_ENTRIES;
-
-	return GT_TRUE;
-}
-
-
-/*
-	Return 1, if added successfully.
-	Return 0, otherwise.
-*/
-GT_BOOL qdSimVTUUpdate(QDSIM_VTU_ENTRY* entry)
-{
-	int i;
-	int node = VTUList.head;
-
-	/* find the entry */
-	for(i=0; i<VTUList.vtuSize; i++)
-	{
-		if(VTUNode[node].vtuEntry.vid == entry->vid)
-			break;
-		node = VTUNode[node].nextEntry;
-	}	
-
-	if (i == VTUList.vtuSize)
-	{
-		/* cannot find the given entry to be deleted. */
-		return GT_FALSE;
-	}
-
-	/* Update the found entry */
-	qdMemCpy(&VTUNode[node].vtuEntry, entry, sizeof(QDSIM_VTU_ENTRY));
-
-	return GT_TRUE;
-}
-
-void qdSimVTUInit()
-{
-	int i;
-
-	qdMemSet((char*)VTUNode, 0, sizeof(VTUNode));
-
-	/* MAX_ATU_ADDRESS means entry i is free, otherwise, it's not free */
-	for (i=0; i<MAX_QD_VTU_ENTRIES; i++)
-		VTUNode[i].nextEntry = MAX_QD_VTU_ENTRIES;
-
-	VTUList.vtuSize = 0;	
-	VTUList.head = 0;	
-}
-
-void qdSimGetVTUInfo(QDSIM_VTU_ENTRY* entry)
-{
-	entry->DBNum = qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] & 0xF;
-	entry->vid = qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] & 0x1FFF;
-	entry->memberTag[0] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] & 0x3;
-	entry->memberTag[1] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 4) & 0x3;
-	entry->memberTag[2] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 8) & 0x3;
-	entry->memberTag[3] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] >> 12) & 0x3;
-	entry->memberTag[4] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] & 0x3;
-	entry->memberTag[5] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 4) & 0x3;
-	entry->memberTag[6] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 8) & 0x3;
-	entry->memberTag[7] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] >> 12) & 0x3;
-	entry->memberTag[8] = qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] & 0x3;
-	entry->memberTag[9] = (qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] >> 4) & 0x3;
-
-	return;
-}
-
-void qdSimSetVTUInfo(QDSIM_VTU_ENTRY* entry)
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= entry->DBNum;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = (entry->vid & 0xFFF) | 0x1000;
-
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 	entry->memberTag[0] |
-						(entry->memberTag[1] << 4) |
-						(entry->memberTag[2] << 8) |
-						(entry->memberTag[3] << 12);
-
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] = 	entry->memberTag[4] |
-						(entry->memberTag[5] << 4) |
-						(entry->memberTag[6] << 8) |
-						(entry->memberTag[7] << 12);
-
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] = 	entry->memberTag[8] |
-						(entry->memberTag[9] << 4);
-
-	return;
-}
-
-void qdSimReSetVTUInfo()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0xFFF;
-
-	return;
-}
-
-void qdSimVTUGetViolation()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xFFF;
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= 1;	/* assume port 1 causes the violation */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 1;	/* assume vid 1 causes the violation */
-}
-
-void qdSimVTUResetBusy()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0x8000;
-
-	return;
-}
-
-GT_BOOL qdSimVTUOperation(unsigned int value)
-{
-	QDSIM_VTU_ENTRY entry;
-	int	index;
-
-	if(!(value & 0x8000))
-		return GT_FALSE;
-
-	qdSimVTUResetBusy();
-
-	switch((value & 0x7000) >> 12)
-	{
-		case 1:
-			/* Flush ALL */
-			qdSimVTUInit();
-			break;
-		case 3:
-			/* Load or Purge entry */
-			qdSimGetVTUInfo(&entry);
-			if(entry.vid & 0x1000)
-			{
-				entry.vid &= ~0x1000;
-				return qdSimVTUAdd(&entry);
-			}
-			else
-				return qdSimVTUDel(&entry);
-			break;
-		case 4:
-			/* Get Next Entry */
-			qdSimGetVTUInfo(&entry);
-			entry.vid &= ~0x1000;
-			index = qdSimVTUFindNext(&entry);
-			if (index == MAX_QD_VTU_ENTRIES)
-			{
-				qdSimReSetVTUInfo();
-				return GT_TRUE;
-			}
-			else
-			{
-				qdSimSetVTUInfo(&VTUNode[index].vtuEntry);
-				return GT_TRUE;
-			}
-			break;
-		case 7:
-			qdSimVTUGetViolation();
-			break;
-		default:
-			break;
-	}
-	return GT_TRUE;
-}
-
-void qdSimStatsInit()
-{
-	int i;
-
-	for(i=0; i<qdSimDev.qdSimNumOfPorts; i++)
-		qdSimDev.qdSimPortStatsClear[i] = 0;
-
-}
-
-GT_BOOL qdSimStatsOperation(unsigned int value)
-{
-	int	i;
-
-	if(!(value & 0x8000))
-		return GT_FALSE;
-
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] &= ~0x8000;
-
-	switch((value & 0x7000) >> 12)
-	{
-		case 1:
-			/* Flush ALL */
-			for(i=0; i<qdSimDev.qdSimNumOfPorts; i++)
-				qdSimDev.qdSimPortStatsClear[i] = 1;
-			break;
-		case 2:
-			/* Flush a port */
-			if ((value & 0x3F) >= (unsigned int)qdSimDev.qdSimNumOfPorts)
-				return GT_FALSE;
-			qdSimDev.qdSimPortStatsClear[value & 0x3F] = 1;
-			break;
-		case 4:
-			/* Read a counter */
-			if(qdSimDev.qdSimPortStatsClear[qdSimDev.qdSimStatsCapturedPort] == 1)
-			{
-				qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;
-				qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;
-			}
-			else
-			{
-				qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = qdSimDev.qdSimStatsCapturedPort;
-				qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = value & 0x3F;
-			}
-			break;
-		case 5:
-			if ((value & 0x3F) >= (unsigned int)qdSimDev.qdSimNumOfPorts)
-				return GT_FALSE;
-			qdSimDev.qdSimStatsCapturedPort = value & 0x3F;
-			break;
-		default:
-			return GT_FALSE;
-	}
-	return GT_TRUE;
-}
-
-#define QD_PHY_CONTROL_RW (QD_PHY_RESET|QD_PHY_LOOPBACK|QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_POWER|QD_PHY_RESTART_AUTONEGO|QD_PHY_DUPLEX)
-#define QD_PHY_CONTROL_RO (~QD_PHY_CONTROL_RW)
-
-GT_BOOL qdSimPhyControl(unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-
-	/* reset all the Read Only bits. */
-	value &= QD_PHY_CONTROL_RW;
-
-	/* If powerDown is set, add Reset and Restart Auto bits. */
-	if(value & QD_PHY_POWER)
-	{
-		value |= (QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
-		qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-		return GT_TRUE;
-	}
-
-	/* If Power Down was set, clear Reset and Restart Auto bits. */
-	if(qdSimRegs[portNumber][miiReg] & QD_PHY_POWER)
-	{
-		value &= ~(QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
-		qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-		return GT_TRUE;
-	}
-
-	/* If Reset or Restart Auto set, replace with current value and clear Reset/Restart Auto. */
-	if (value & (QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO))
-	{
-		value &= ~(QD_PHY_RESET|QD_PHY_RESTART_AUTONEGO);
-		qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-		return GT_TRUE;
-	}
-	else
-	{
-		value &= ~(QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_DUPLEX);
-		qdSimRegs[portNumber][miiReg] &= (QD_PHY_SPEED|QD_PHY_AUTONEGO|QD_PHY_DUPLEX);
-		qdSimRegs[portNumber][miiReg] |= (GT_U16)value;
-		return GT_TRUE;
-	}
-
-	return GT_TRUE;
-}
-
-void qdSimRegsInit_6021()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;	/* VTU Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;	/* VTU VID Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;	/* Stats Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;	/* Stats Counter Register Bytes 3,2 */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;	/* Stats Counter Register Bytes 1,0 */
-}
-
-void qdSimRegsInit_6063()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;	/* VTU Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;	/* VTU VID Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;	/* Stats Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;	/* Stats Counter Register Bytes 3,2 */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;	/* Stats Counter Register Bytes 1,0 */
-}
-
-void qdSimRegsInit_6083()
-{
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] = 0;	/* VTU Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][6] = 0;	/* VTU VID Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][7] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][8] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][9] = 0;	/* VTU Data Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][29] = 0;	/* Stats Operation Register */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][30] = 0;	/* Stats Counter Register Bytes 3,2 */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][31] = 0;	/* Stats Counter Register Bytes 1,0 */
-}
-
-void qdSimRegsInit()
-{
-	int i;
-
-	qdMemSet(qdSimRegs, 0xff, sizeof(qdSimRegs));
-	
-	/* 
-		PHY Registers Setup
-	*/
-	for(i=0; i<qdSimDev.qdSimNumOfPhys; i++)
-	{
-		qdSimRegs[i][0] = 0x3100;	/* PHY Control */
-		qdSimRegs[i][1] = 0x7849;	/* PHY Status */
-		qdSimRegs[i][2] = 0x0141;	/* PHY Id 1 */
-		qdSimRegs[i][3] = 0x0c1f;	/* PHY Id 2 */
-		qdSimRegs[i][4] = 0x01e1;	/* AutoNego Ad */
-		qdSimRegs[i][5] = 0;		/* Partner Ability */
-		qdSimRegs[i][6] = 4;		/* AutoNego Expansion */
-		qdSimRegs[i][7] = 0x2001;	/* Next Page Transmit */
-		qdSimRegs[i][8] = 0;		/* Link Partner Next Page */
-		qdSimRegs[i][16] = 0x130;	/* Phy Specific Control */
-		qdSimRegs[i][17] = 0x40;	/* Phy Specific Status */
-		qdSimRegs[i][18] = 0;		/* Phy Interrupt Enable */
-		qdSimRegs[i][19] = 0x40;	/* Phy Interrupt Status */
-		qdSimRegs[i][20] = 0;		/* Interrupt Port Summary */
-		qdSimRegs[i][21] = 0;		/* Receive Error Counter */
-		qdSimRegs[i][22] = 0xa34;	/* LED Parallel Select */
-		qdSimRegs[i][23] = 0x3fc;	/* LED Stream Select */
-		qdSimRegs[i][24] = 0x42bf;	/* LED Control */
-	}
-
-	/*
-		Port Registers Setup
-	*/
-	for(i=qdSimDev.qdSimPortBase; i<qdSimDev.qdSimNumOfPorts+qdSimDev.qdSimPortBase; i++)
-	{
-		qdSimRegs[i][0] = 0x800;	/* Port Status */
-		qdSimRegs[i][3] = (GT_U16)qdSimDev.qdSimDevId << 4;	/* Switch ID */
-		qdSimRegs[i][4] = 0x7f;	/* Port Control */
-		qdSimRegs[i][6] = 0x7f & (~(1 << (i-8)));	/* Port Based Vlan Map */
-		qdSimRegs[i][7] = 1;		/* Default Port Vlan ID & Priority */
-		qdSimRegs[i][16] = 0;		/* Rx Frame Counter */
-		qdSimRegs[i][17] = 0;		/* Tx Frame Counter */
-	}
-
-	/*
-		Global Registers Setup
-	*/
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][0] = 0x3c01;	/* Global Status */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][1] = 0;		/* Switch Mac Addr 0 ~ 1 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][2] = 0;		/* Switch Mac Addr 2 ~ 3 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][3] = 0;		/* Switch Mac Addr 4 ~ 5 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][4] = 0x81;	/* Global Control */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][10] = 0x1130;		/* ATU Control */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] = 0;				/* ATU Operation */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][12] = 0;				/* ATU Data */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][13] = 0;				/* ATU Mac Addr 0 ~ 1 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][14] = 0;				/* ATU Mac Addr 2 ~ 3 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][15] = 0;				/* ATU Mac Addr 4 ~ 5 byte */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][16] = 0;			/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][17] = 0;			/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][18] = 0x5555;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][19] = 0x5555;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][20] = 0xaaaa;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][21] = 0xaaaa;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][22] = 0xffff;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][23] = 0xffff;	/* IP-PRI Mapping */
-	qdSimRegs[qdSimDev.qdSimGlobalRegBase][24] = 0xfa41;	/* IEEE-PRI Mapping */
-			  
-	switch(qdSimDev.qdSimDevId)
-	{
-		case GT_88E6021:
-			qdSimRegsInit_6021();
-			break;
-		case GT_88E6063:
-		case GT_FF_HG:
-		case GT_FF_EG:
-		case GT_FH_VPN:
-			qdSimRegsInit_6063();
-			break;
-		case GT_88E6083:
-			qdSimRegsInit_6083();
-			break;
-		default:
-			break;
-	}
-}
-
-GT_BOOL qdSimRead_6052(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
-{
-	*value = (unsigned int) qdSimRegs[portNumber][miiReg];
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					qdSimRegs[portNumber][miiReg] &= ~0xF;
-					if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
-						qdSimRegs[portNumber][miiReg] |= 0x2;
-
-					break;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-			case QD_REG_GLOBAL_CONTROL:
-			case QD_REG_ATU_CONTROL:
-			case QD_REG_ATU_OPERATION:
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-					break;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-			case QD_REG_SWITCH_ID:
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-					break;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					break;
-			case QD_PHY_INT_ENABLE_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-					qdSimRegs[portNumber][miiReg] = 0;
-					qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
-					break;
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					*value = (unsigned int) qdSimRegs[0][miiReg];
-					break;
-		}
-	}
-
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimRead_6021(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
-{
-	*value = (unsigned int) qdSimRegs[portNumber][miiReg];
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					qdSimRegs[portNumber][miiReg] &= ~0x7F;
-					if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
-						qdSimRegs[portNumber][miiReg] |= 0x2;
-
-					break;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-			case QD_REG_VTU_OPERATION:
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-			case QD_REG_GLOBAL_CONTROL:
-			case QD_REG_ATU_CONTROL:
-			case QD_REG_ATU_OPERATION:
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-			case QD_REG_STATS_OPERATION:
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					break;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-			case QD_REG_SWITCH_ID:
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-			case QD_REG_Q_COUNTER:
-					break;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					break;
-			case QD_PHY_INT_ENABLE_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-					qdSimRegs[portNumber][miiReg] = 0;
-					qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
-					break;
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					*value = (unsigned int) qdSimRegs[0][miiReg];
-					break;
-		}
-	}
-
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimRead_6063(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
-{
-	*value = (unsigned int) qdSimRegs[portNumber][miiReg];
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					qdSimRegs[portNumber][miiReg] &= ~0x7F;
-					if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
-						qdSimRegs[portNumber][miiReg] |= 0x2;
-
-					break;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-			case QD_REG_VTU_OPERATION:
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-			case QD_REG_GLOBAL_CONTROL:
-			case QD_REG_ATU_CONTROL:
-			case QD_REG_ATU_OPERATION:
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-			case QD_REG_STATS_OPERATION:
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					break;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-			case QD_REG_SWITCH_ID:
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-			case QD_REG_Q_COUNTER:
-					break;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					break;
-			case QD_PHY_INT_ENABLE_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-					qdSimRegs[portNumber][miiReg] = 0;
-					qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
-					break;
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					*value = (unsigned int) qdSimRegs[0][miiReg];
-					break;
-		}
-	}
-
-	return GT_TRUE;
-}
-
-
-GT_BOOL qdSimRead_6083(unsigned int portNumber , unsigned int miiReg, unsigned int* value)
-{
-	*value = (unsigned int) qdSimRegs[portNumber][miiReg];
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					qdSimRegs[portNumber][miiReg] &= ~0x7F;
-					if(qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG])
-						qdSimRegs[portNumber][miiReg] |= 0x2;
-
-					break;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-			case QD_REG_VTU_OPERATION:
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-			case QD_REG_GLOBAL_CONTROL:
-			case QD_REG_ATU_CONTROL:
-			case QD_REG_ATU_OPERATION:
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-			case QD_REG_STATS_OPERATION:
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					break;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-			case QD_REG_SWITCH_ID:
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-			case QD_REG_Q_COUNTER:
-					break;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					break;
-			case QD_PHY_INT_ENABLE_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-					qdSimRegs[portNumber][miiReg] = 0;
-					qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
-					break;
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					*value = (unsigned int) qdSimRegs[0][miiReg];
-					break;
-		}
-	}
-
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimRead (GT_QD_DEV *dev,unsigned int portNumber , unsigned int miiReg, unsigned int* value)
-{
-	if (portNumber >= MAX_SMI_ADDRESS)
-		portNumber -= MAX_SMI_ADDRESS;
-
-	if ((portNumber >= MAX_SMI_ADDRESS) || (miiReg >= MAX_REG_ADDRESS))
-		return GT_FALSE;
-
-	switch(qdSimDev.qdSimDevId)
-	{
-		case GT_88E6051:
-		case GT_88E6052:
-			return qdSimRead_6052(portNumber, miiReg, value);
-		case GT_88E6021:
-			return qdSimRead_6021(portNumber, miiReg, value);
-		case GT_88E6063:
-		case GT_FF_HG:
-		case GT_FF_EG:
-		case GT_FH_VPN:
-			return qdSimRead_6063(portNumber, miiReg, value);
-		case GT_88E6083:
-			return qdSimRead_6083(portNumber, miiReg, value);
-		default:
-			break;
-	}
-
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimWrite_6052 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-	GT_BOOL status;
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					/* readonly register */
-					return GT_FALSE;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-					break;
-			case QD_REG_GLOBAL_CONTROL:
-					if(value & 0x200)
-					{
-						/* Reload EEPROM values */
-						qdSimRegsInit();
-						qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
-						return GT_TRUE;
-					}
-					break;
-			case QD_REG_ATU_CONTROL:
-					value &= ~0x8000;
-					break;
-			case QD_REG_ATU_OPERATION:
-					status = qdSimATUOperation(value);
-					return status;
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-					break;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-			case QD_REG_SWITCH_ID:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-					break;
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-					/* readonly registers */
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					return qdSimPhyControl(portNumber,miiReg,value);
-			case QD_PHY_INT_ENABLE_REG:
-			case QD_PHY_AUTONEGO_AD_REG:
-			case QD_PHY_NEXTPAGE_TX_REG:
-			case QD_PHY_SPEC_CONTROL_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else
-		return GT_FALSE;
-
-	qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimWrite_6021 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-	GT_BOOL status;
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					/* readonly register */
-					return GT_FALSE;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-					break;
-			case QD_REG_VTU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
-					status = qdSimVTUOperation(value);
-					return status;
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-					break;
-			case QD_REG_GLOBAL_CONTROL:
-					if(value & 0x200)
-					{
-						/* Reload EEPROM values */
-						qdSimRegsInit();
-						qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
-						return GT_TRUE;
-					}
-					break;
-			case QD_REG_ATU_CONTROL:
-					value &= ~0x8000;
-					break;
-			case QD_REG_ATU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
-					status = qdSimATUOperation(value);
-					return status;
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-					break;
-			case QD_REG_STATS_OPERATION:
-					status = qdSimStatsOperation(value);
-					return status;
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-					if(portNumber > 9)
-					{
-						qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
-						qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
-						return GT_TRUE;
-					}
-			case QD_REG_SWITCH_ID:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-					break;
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_Q_COUNTER:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					return qdSimPhyControl(portNumber,miiReg,value);
-			case QD_PHY_INT_ENABLE_REG:
-			case QD_PHY_AUTONEGO_AD_REG:
-			case QD_PHY_NEXTPAGE_TX_REG:
-			case QD_PHY_SPEC_CONTROL_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else
-		return GT_FALSE;
-
-	qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimWrite_6063 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-	GT_BOOL status;
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					/* readonly register */
-					return GT_FALSE;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-					break;
-			case QD_REG_VTU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
-					status = qdSimVTUOperation(value);
-					return status;
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-					break;
-			case QD_REG_GLOBAL_CONTROL:
-					if(value & 0x200)
-					{
-						/* Reload EEPROM values */
-						qdSimRegsInit();
-						qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
-						return GT_TRUE;
-					}
-					break;
-			case QD_REG_ATU_CONTROL:
-					value &= ~0x8000;
-					break;
-			case QD_REG_ATU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
-					status = qdSimATUOperation(value);
-					return status;
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-					break;
-			case QD_REG_STATS_OPERATION:
-					status = qdSimStatsOperation(value);
-					return status;
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-					if(portNumber > 12)
-					{
-						qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
-						qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
-						return GT_TRUE;
-					}
-			case QD_REG_SWITCH_ID:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-					break;
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_Q_COUNTER:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					return qdSimPhyControl(portNumber,miiReg,value);
-			case QD_PHY_INT_ENABLE_REG:
-			case QD_PHY_AUTONEGO_AD_REG:
-			case QD_PHY_NEXTPAGE_TX_REG:
-			case QD_PHY_SPEC_CONTROL_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else
-		return GT_FALSE;
-
-	qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-	return GT_TRUE;
-}
-
-GT_BOOL qdSimWrite_6083 (unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-	GT_BOOL status;
-
-	if (IS_GLOBAL_REG(portNumber))	/* Global register */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_GLOBAL_STATUS:
-					/* readonly register */
-					return GT_FALSE;
-			case QD_REG_MACADDR_01:
-			case QD_REG_MACADDR_23:
-			case QD_REG_MACADDR_45:
-					break;
-			case QD_REG_VTU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][5] |= (value & 0xF);
-					status = qdSimVTUOperation(value);
-					return status;
-			case QD_REG_VTU_VID_REG:
-			case QD_REG_VTU_DATA1_REG:
-			case QD_REG_VTU_DATA2_REG:
-			case QD_REG_VTU_DATA3_REG:
-					break;
-			case QD_REG_GLOBAL_CONTROL:
-					if(value & 0x200)
-					{
-						/* Reload EEPROM values */
-						qdSimRegsInit();
-						qdSimRegs[portNumber][QD_REG_GLOBAL_STATUS] |= 0x1;
-						return GT_TRUE;
-					}
-					break;
-			case QD_REG_ATU_CONTROL:
-					value &= ~0x8000;
-					break;
-			case QD_REG_ATU_OPERATION:
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] &= ~0xF;
-					qdSimRegs[qdSimDev.qdSimGlobalRegBase][11] |= (value & 0xF);
-					status = qdSimATUOperation(value);
-					return status;
-			case QD_REG_ATU_DATA_REG:
-			case QD_REG_ATU_MAC_01:
-			case QD_REG_ATU_MAC_23:
-			case QD_REG_ATU_MAC_45:
-			case QD_REG_IP_PRI_REG0:
-			case QD_REG_IP_PRI_REG1:
-			case QD_REG_IP_PRI_REG2:
-			case QD_REG_IP_PRI_REG3:
-			case QD_REG_IP_PRI_REG4:
-			case QD_REG_IP_PRI_REG5:
-			case QD_REG_IP_PRI_REG6:
-			case QD_REG_IP_PRI_REG7:
-			case QD_REG_IEEE_PRI:
-					break;
-			case QD_REG_STATS_OPERATION:
-					status = qdSimStatsOperation(value);
-					return status;
-			case QD_REG_STATS_COUNTER3_2:
-			case QD_REG_STATS_COUNTER1_0:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PORT_REG(portNumber))	/* Port registers */
-	{
-		switch(miiReg)
-		{
-			case QD_REG_PORT_STATUS:
-					if(portNumber > 12)
-					{
-						qdSimRegs[portNumber][miiReg] &= ~QD_PORT_STATUS_DUPLEX;
-						qdSimRegs[portNumber][miiReg] |= (value & QD_PORT_STATUS_DUPLEX);
-						return GT_TRUE;
-					}
-			case QD_REG_SWITCH_ID:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_PORT_CONTROL:
-			case QD_REG_PORT_VLAN_MAP:
-			case QD_REG_PVID:
-			case QD_REG_RATE_CTRL:
-			case QD_REG_PAV:
-					break;
-			case QD_REG_RXCOUNTER:
-			case QD_REG_TXCOUNTER:
-					/* readonly registers */
-					return GT_FALSE;
-			case QD_REG_Q_COUNTER:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else if(IS_PHY_REG(portNumber))	/* phy registers */
-	{
-		switch(miiReg)
-		{
-			case QD_PHY_CONTROL_REG:
-					return qdSimPhyControl(portNumber,miiReg,value);
-			case QD_PHY_INT_ENABLE_REG:
-			case QD_PHY_AUTONEGO_AD_REG:
-			case QD_PHY_NEXTPAGE_TX_REG:
-			case QD_PHY_SPEC_CONTROL_REG:
-					break;
-			case QD_PHY_INT_STATUS_REG:
-			case QD_PHY_INT_PORT_SUMMARY_REG:
-					return GT_FALSE;
-			default:
-					return GT_FALSE;
-		}
-	}
-	else
-		return GT_FALSE;
-
-	qdSimRegs[portNumber][miiReg] = (GT_U16)value;
-	return GT_TRUE;
-}
-
-
-GT_BOOL qdSimWrite (GT_QD_DEV *dev,unsigned int portNumber , unsigned int miiReg, unsigned int value)
-{
-	if (portNumber >= MAX_SMI_ADDRESS)
-		portNumber -= MAX_SMI_ADDRESS;
-
-	if ((portNumber >= MAX_SMI_ADDRESS) || (miiReg >= MAX_REG_ADDRESS))
-		return GT_FALSE;
-
-	switch(qdSimDev.qdSimDevId)
-	{
-		case GT_88E6051:
-		case GT_88E6052:
-			return qdSimWrite_6052(portNumber, miiReg, value);
-		case GT_88E6021:
-			return qdSimWrite_6021(portNumber, miiReg, value);
-		case GT_88E6063:
-		case GT_FF_HG:
-		case GT_FF_EG:
-		case GT_FH_VPN:
-			return qdSimWrite_6063(portNumber, miiReg, value);
-		case GT_88E6083:
-			return qdSimWrite_6083(portNumber, miiReg, value);
-
-		default:
-			break;
-	}
-
-	return GT_TRUE;
-}
-
-GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data)
-{
-	if(!qdSimDev.qdSimUsed)
-		return GT_FAIL;
-
-	qdSimRegs[portNumber][QD_PHY_INT_STATUS_REG] = u16Data;
-	if(u16Data)
-		qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] |= (1<<portNumber);
-	else
-		qdSimRegs[0][QD_PHY_INT_PORT_SUMMARY_REG] &= ~(1<<portNumber);
-	
-	qdSimRegs[MAX_SMI_ADDRESS-1][QD_REG_GLOBAL_STATUS] |= 0x2;
-	return GT_OK;
-}
-
-GT_STATUS qdSimSetGlobalInt(unsigned short u16Data)
-{
-	if(!qdSimDev.qdSimUsed)
-		return GT_FAIL;
-
-	qdSimRegs[MAX_SMI_ADDRESS-1][QD_REG_GLOBAL_STATUS] |= (u16Data & 0xF);
-	return GT_OK;
-}
-
-
-void qdSimInit(GT_DEVICE devId, int baseAddr)
-{
-	qdSimDev.qdSimUsed = 1;
-
-	qdSimDev.qdSimDevId = devId;
-	qdSimDev.vtuSize = 0;
-
-	qdSimDev.qdSimPhyBase = baseAddr;
-	qdSimDev.qdSimPortBase = baseAddr + 0x8;
-	qdSimDev.qdSimGlobalRegBase = baseAddr + 0xF;
-
-	switch(devId)
-	{
-		case GT_88E6021:
-			qdSimDev.vtuSize = 16;
-			qdSimDev.qdSimNumOfPhys = 2;
-			qdSimDev.qdSimNumOfPorts = 3;
-			break;
-		case GT_88E6051:
-			qdSimDev.qdSimNumOfPhys = 5;
-			qdSimDev.qdSimNumOfPorts = 6;
-			break;
-		case GT_88E6063:
-		case GT_FH_VPN:
-			qdSimDev.vtuSize = 64;
-		case GT_88E6052:
-		case GT_FF_HG:
-		case GT_FF_EG:
-			qdSimDev.qdSimNumOfPhys = 5;
-			qdSimDev.qdSimNumOfPorts = 7;
-			break;
-		case GT_88E6083:
-			qdSimDev.vtuSize = 64;
-			qdSimDev.qdSimNumOfPhys = 8;
-			qdSimDev.qdSimNumOfPorts = 10;
-			qdSimDev.qdSimPhyBase = 0;
-			qdSimDev.qdSimPortBase = 0x10;
-			qdSimDev.qdSimGlobalRegBase = 0x1b;
-			break;
-		default:
-			qdSimDev.vtuSize = 64;
-			qdSimDev.qdSimDevId = GT_88E6063;
-			qdSimDev.qdSimNumOfPhys = 5;
-			qdSimDev.qdSimNumOfPorts = 7;
-			break;
-	}
-
-	qdSimATUInit();
-	qdSimVTUInit();
-	qdSimRegsInit();
-
-	return;
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSimRegs.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSimRegs.h
deleted file mode 100644
index 7976f8b..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/qdSimRegs.h
+++ /dev/null
@@ -1,131 +0,0 @@
-#include <Copyright.h>
-
-/********************************************************************************
-* gtSimRegs.h
-*
-* DESCRIPTION:
-*       This file includes the declaration of the struct to hold the addresses
-*       of switch (global & per-port).
-*
-* DEPENDENCIES:
-*       QuarterDeck register MAP.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#ifndef __qdSimRegsh
-#define __qdSimRegsh
-
-/* QuarterDeck Per Port Registers */
-#define QD_REG_PORT_STATUS		0x0
-#define QD_REG_SWITCH_ID		0x3
-#define QD_REG_PORT_CONTROL		0x4
-#define QD_REG_PORT_VLAN_MAP	0x6
-#define QD_REG_PVID				0x7
-#define QD_REG_RATE_CTRL		0xA
-#define QD_REG_PAV				0xB
-#define QD_REG_RXCOUNTER		0x10
-#define QD_REG_TXCOUNTER		0x11
-#define QD_REG_Q_COUNTER		0x1B
-
-/* QuarterDeck Global Registers */
-#define QD_REG_GLOBAL_STATUS	0x0
-#define QD_REG_MACADDR_01		0x1
-#define QD_REG_MACADDR_23		0x2
-#define QD_REG_MACADDR_45		0x3
-#define QD_REG_GLOBAL_CONTROL	0x4
-
-/* the following VTU entries are added for Fullsail and Clippership */
-#define QD_REG_VTU_OPERATION		0x5
-#define QD_REG_VTU_VID_REG		0x6
-#define QD_REG_VTU_DATA1_REG		0x7
-#define QD_REG_VTU_DATA2_REG		0x8
-#define QD_REG_VTU_DATA3_REG		0x9
-#define QD_REG_STATS_OPERATION		0x1D
-#define QD_REG_STATS_COUNTER3_2		0x1E
-#define QD_REG_STATS_COUNTER1_0		0x1F
- 
-#define QD_REG_ATU_CONTROL		0xA
-#define QD_REG_ATU_OPERATION	0xB
-#define QD_REG_ATU_DATA_REG		0xC
-#define QD_REG_ATU_MAC_BASE		0xD
-#define QD_REG_ATU_MAC_01		0xD
-#define QD_REG_ATU_MAC_23		0xE
-#define QD_REG_ATU_MAC_45		0xF
-#define QD_REG_IP_PRI_BASE		0x10
-#define QD_REG_IP_PRI_REG0		0x10
-#define QD_REG_IP_PRI_REG1		0x11
-#define QD_REG_IP_PRI_REG2		0x12
-#define QD_REG_IP_PRI_REG3		0x13
-#define QD_REG_IP_PRI_REG4		0x14
-#define QD_REG_IP_PRI_REG5		0x15
-#define QD_REG_IP_PRI_REG6		0x16
-#define QD_REG_IP_PRI_REG7		0x17
-#define QD_REG_IEEE_PRI			0x18
-
-/* Definition for QD_REG_PORT_STATUS */
-#define QD_PORT_STATUS_DUPLEX	0x200
-
-/* Definitions for MIB Counter */
-#define GT_STATS_NO_OP			0x0
-#define GT_STATS_FLUSH_ALL		0x1
-#define GT_STATS_FLUSH_PORT		0x2
-#define GT_STATS_READ_COUNTER		0x4
-#define GT_STATS_CAPTURE_PORT		0x5
-
-#define QD_PHY_CONTROL_REG				0
-#define QD_PHY_AUTONEGO_AD_REG			4
-#define QD_PHY_NEXTPAGE_TX_REG			7
-#define QD_PHY_SPEC_CONTROL_REG			16
-#define QD_PHY_INT_ENABLE_REG			18
-#define QD_PHY_INT_STATUS_REG			19
-#define QD_PHY_INT_PORT_SUMMARY_REG		20
-
-/* Bit Definition for QD_PHY_CONTROL_REG */
-#define QD_PHY_RESET			0x8000
-#define QD_PHY_LOOPBACK			0x4000
-#define QD_PHY_SPEED			0x2000
-#define QD_PHY_AUTONEGO			0x1000
-#define QD_PHY_POWER			0x800
-#define QD_PHY_ISOLATE			0x400
-#define QD_PHY_RESTART_AUTONEGO		0x200
-#define QD_PHY_DUPLEX			0x100
-
-#define QD_PHY_POWER_BIT				11
-#define QD_PHY_RESTART_AUTONEGO_BIT		9
-
-/* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
-#define QD_PHY_NEXTPAGE			0x8000
-#define QD_PHY_REMOTEFAULT		0x4000
-#define QD_PHY_PAUSE			0x400
-#define QD_PHY_100_FULL			0x100
-#define QD_PHY_100_HALF			0x80
-#define QD_PHY_10_FULL			0x40
-#define QD_PHY_10_HALF			0x20
-
-#define QD_PHY_MODE_AUTO_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
-#define QD_PHY_MODE_100_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF)
-#define QD_PHY_MODE_10_AUTO		(QD_PHY_10_FULL | QD_PHY_10_HALF)
-#define QD_PHY_MODE_AUTO_FULL	(QD_PHY_100_FULL | QD_PHY_10_FULL)
-#define QD_PHY_MODE_AUTO_HALF	(QD_PHY_100_HALF | QD_PHY_10_HALF)
-
-#define QD_PHY_MODE_100_FULL	QD_PHY_100_FULL
-#define QD_PHY_MODE_100_HALF	QD_PHY_100_HALF
-#define QD_PHY_MODE_10_FULL		QD_PHY_10_FULL	
-#define QD_PHY_MODE_10_HALF		QD_PHY_10_HALF	
-
-/* Bit definition for QD_PHY_INT_ENABLE_REG */
-#define QD_PHY_INT_SPEED_CHANGED		0x4000
-#define QD_PHY_INT_DUPLEX_CHANGED		0x2000
-#define QD_PHY_INT_PAGE_RECEIVED		0x1000
-#define QD_PHY_INT_AUTO_NEG_COMPLETED		0x800
-#define QD_PHY_INT_LINK_STATUS_CHANGED		0x400
-#define QD_PHY_INT_SYMBOL_ERROR			0x200
-#define QD_PHY_INT_FALSE_CARRIER		0x100
-#define QD_PHY_INT_FIFO_FLOW			0x80
-#define QD_PHY_INT_CROSSOVER_CHANGED		0x40
-#define QD_PHY_INT_POLARITY_CHANGED		0x2
-#define QD_PHY_INT_JABBER			0x1
-
-#endif /* __qdSimRegsh */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/sampleTest.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/sampleTest.c
deleted file mode 100644
index 58f7848..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/sampleTest.c
+++ /dev/null
@@ -1,447 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* sample.c
-*
-* DESCRIPTION:
-*		This is a sample program shows how to use DSDT APIs.
-*		
-* DEPENDENCIES:
-*
-* FILE REVISION NUMBER:
-*
-* COMMENTS:
-*******************************************************************************/
-
-#include "msSample.h"
-
-#define N_OF_QD_DEVICES	2
-extern GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES];
-
-GT_STATUS qdMultiDevStart();
-GT_STATUS sampleIsolatedCPUPort(GT_QD_DEV *dev, GT_U8* macAddr);
-GT_STATUS setTagMode(int vid, char* tag);
-GT_STATUS crossChipTrunkSetup();
-
-
-GT_STATUS enableTag()
-{
-	char tag[4] = {0xc0,0,0,0x1};
-	setTagMode(2,tag);
-	return GT_OK;
-}
-
-
-GT_STATUS sampleTest()
-{
-	GT_U8 macAddr[6] = {0x0,0x23,0x45,0x67,0x89,0xab};
-	qdMultiDevStart();
-	enableTag();
-	sampleIsolatedCPUPort(qdMultiDev[0],macAddr);
-	crossChipTrunkSetup();
-	return GT_OK;
-}
-
-/*
-	0) Remove CPU port from VLAN Member Table.
-	   (this sample deals with Port Based Vlan only.)
-	1) Mirror ARPs to the CPU with To_CPU Marvell Tag
-	2) Convert unicast frames directed to the CPU into To_CPU Marvell Tag
-	Assumption : Device ID, Cascading Port, CPU Port, and Interswitch Port are
-		already set properly. For more information, please refer to the 
-		sample/MultiDevice/msApiInit.c
-*/
-
-GT_STATUS sampleIsolatedCPUPort(GT_QD_DEV *dev, GT_U8* macAddr)
-{
-	GT_STATUS status;
-	int i;
-	GT_LPORT memPorts[16], cpuPort;
-	GT_U8 memPortsLen, index;
-    GT_ATU_ENTRY macEntry;
-
-	cpuPort = (GT_LPORT)dev->cpuPortNum;
-
-	/*
-	 *	Remove CPU port from VLAN Member Table.
-	*/ 
-	for(i=0; i<dev->numOfPorts; i++)
-	{
-		if((status = gvlnGetPortVlanPorts(dev,(GT_LPORT)i,memPorts,&memPortsLen)) != GT_OK)
-		{
-			MSG_PRINT(("gvlnGetPortVlanPorts return Failed\n"));
-			return status;
-		}
-
-		for(index=0; index<memPortsLen; index++)
-		{
-			if (memPorts[index] == cpuPort)
-				break;
-		}
-
-		if(index != memPortsLen)
-		{
-			/* CPU Port is the member of the port vlan */
-			if((memPortsLen-1) != index)
-			{
-				memPorts[index] = memPorts[memPortsLen-1];
-			}
-			memPortsLen--;
-
-			if((status = gvlnSetPortVlanPorts(dev,(GT_LPORT)i,memPorts,memPortsLen)) != GT_OK)
-			{
-				MSG_PRINT(("gvlnSetPortVlanPorts return Failed\n"));
-				return status;
-			}
-		}
-	}
-
-	/*
-	 *	Mirror ARPs to the CPU with To_CPU Marvell Tag.
-	*/
-	if((status = gsysSetARPDest(dev,cpuPort)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetARPDest return Failed\n"));
-		return status;
-	}
-
-	/*
-	 *	Convert unicast frames directed to the CPU into To_CPU Marvell Tag.
-	 *  This sample assumes that DBNum is not used. If DBNum is used,
-	 *  the macEntry has to be added for each DBNum used.
-	*/
-	memset(&macEntry,0,sizeof(GT_ATU_ENTRY));
-	memcpy(macEntry.macAddr.arEther,macAddr,6);
-	macEntry.portVec = 1 << dev->cpuPortNum;
-	macEntry.prio = 0;			/* Priority (2bits). When these bits are used they override
-								any other priority determined by the frame's data */
-	macEntry.entryState.ucEntryState = GT_UC_TO_CPU_STATIC;
-	macEntry.DBNum = 0;
-	macEntry.trunkMember = GT_FALSE;
-
-	if((status = gfdbAddMacEntry(dev,&macEntry)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetARPDest return Failed\n"));
-		return status;
-	}
-
-	
-	return GT_OK;
-}
-
-
-/*
-	Assumption 1: Device ID, Cascading Port, CPU Port, and Interswitch Port are
-		already set properly. For more information, please refer to the 
-		sample/MultiDevice/msApiInit.c
-
-	Assumption 2: Port 0,1,2 of Device 0 and Port 0 of Device 1 are member of a 
-		trunk with Trunk ID 1.
-*/
-
-GT_STATUS sampleFixedCrossChipTrunk(GT_QD_DEV *dev[])
-{
-	GT_STATUS status;
-	int i;
-	GT_U32 mask, trunkBit, trunkId;
-
-	/*
-	 *	Enable Trunk for each member of the Trunk and set the Trunk ID (1).
-	*/ 
-
-	trunkId = 1;
-
-	if((dev[0] == NULL) || (!dev[0]->devEnabled))
-	{
-		printf("Device 0 is not initialized\n");
-		return GT_FAIL;
-	}
-	if((dev[1] == NULL) || (!dev[1]->devEnabled))
-	{
-		printf("Device 1 is not initialized\n");
-		return GT_FAIL;
-	}
-
-	/* setup for Device 0 port 0 */
-	if((status = gprtSetTrunkPort(dev[0],0,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 0 port 1 */
-	if((status = gprtSetTrunkPort(dev[0],1,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 0 port 2 */
-	if((status = gprtSetTrunkPort(dev[0],2,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 1 port 0 */
-	if((status = gprtSetTrunkPort(dev[1],0,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-
-	/*
-	 *	Set Trunk Route Table for the given Trunk ID.
-	*/ 
-
-	/* setup for Device 0, trunk ID 1 : port 0,1,2, and 9 (cascading port, assumption1) */
-	if((status = gsysSetTrunkRouting(dev[0],trunkId,0x7|0x200)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 1, trunk ID 1 : port 0, and 8 (cascading port, assumption1) */
-	if((status = gsysSetTrunkRouting(dev[1],trunkId,0x1|0x100)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-		return status;
-	}
-
-
-	/*
-	 *	Set Trunk Mask Table for load balancing.
-	*/ 
-
-	/*
-	   Trunk Mask Table for Device 0:
- 
-						10	9	8	7	6	5	4	3	2	1	0
-	   TrunkMask[0]		1	1	1	1	1	1	1	1	0	0	1
-	   TrunkMask[1]		1	1	1	1	1	1	1	1	0	1	0
-	   TrunkMask[2]		1	1	1	1	1	1	1	1	1	0	0
-	   TrunkMask[3]		1	1	1	1	1	1	1	1	0	0	0
-	   TrunkMask[4]		1	1	1	1	1	1	1	1	0	0	1
-	   TrunkMask[5]		1	1	1	1	1	1	1	1	0	1	0
-	   TrunkMask[6]		1	1	1	1	1	1	1	1	1	0	0
-	   TrunkMask[7]		1	1	1	1	1	1	1	1	0	0	0
-
-
-	   Trunk Mask Table for Device 1:
- 
-						10	9	8	7	6	5	4	3	2	1	0
-	   TrunkMask[0]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[1]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[2]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[3]		1	1	1	1	1	1	1	1	1	1	1
-	   TrunkMask[4]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[5]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[6]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[7]		1	1	1	1	1	1	1	1	1	1	1
-
-	*/
-
-	/* setup for Device 0 */
-	for(i=0; i<8; i++)
-	{
-		if((i%4) == 3)
-		{
-			trunkBit = 0;
-		}
-		else
-		{
-			trunkBit = 1 << (i%4);
-		}		
-
-		mask = 0x7F8 | trunkBit;
-	
-		if((status = gsysSetTrunkMaskTable(dev[0],i,mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-
-	}
-	
-	/* setup for Device 1 */
-	for(i=0; i<8; i++)
-	{
-		if((i%4) == 3)
-		{
-			trunkBit = 1;
-		}
-		else
-		{
-			trunkBit = 0;
-		}		
-
-		mask = 0x7FE | trunkBit;
-	
-		if((status = gsysSetTrunkMaskTable(dev[1],i,mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-
-	}
-	return GT_OK;
-}
-
-#define MAX_PORT_IN_TRUNK 4
-
-typedef struct _TRUNK_SET {
-	GT_U32	devIndex;
-	GT_U32	port;
-} TRUNK_SET;
-
-typedef struct _TRUNK_MEMBER {
-	GT_U32	trunkId;
-	GT_U32	nTrunkPort;
-	TRUNK_SET trunkSet[MAX_PORT_IN_TRUNK];
-} TRUNK_MEMBER;
-
-GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm);
-
-/*
-	Setup Trunk with the following member ports:
-		Port 0,1,2 of Device 0, and
-		Port 0 of Device 1,
-	where Device 0 is the first Switch Device Structure in qdMultiDev array 
-	and Device 1 is the second Switch Device Structure in qdMultiDev array.
-*/
-GT_STATUS crossChipTrunkSetup()
-{
-	TRUNK_MEMBER tm;
-
-	tm.trunkId = 1;
-	tm.nTrunkPort = 4;
-	tm.trunkSet[0].devIndex = 0;
-	tm.trunkSet[0].port = 0;
-	tm.trunkSet[1].devIndex = 0;
-	tm.trunkSet[1].port = 1;
-	tm.trunkSet[2].devIndex = 0;
-	tm.trunkSet[2].port = 2;
-	tm.trunkSet[3].devIndex = 1;
-	tm.trunkSet[3].port = 0;
-
-	return sampleCrossChipTrunk(qdMultiDev, &tm);
-}
-
-GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm)
-{
-	GT_STATUS status;
-	int i,j,index;
-	GT_U32 mask, trunkId;
-	TRUNK_SET* ts;
-	GT_U32 portVec[N_OF_QD_DEVICES];	
-	GT_U32 casecadeVec = 0xC0;	/* Port 6 and 7. ToDo : get this value from user or device */
-
-	/*
-	 *	Enable Trunk for each member of the Trunk and set the Trunk ID (1).
-	*/ 
-
-	printf("Setting TRUNK\n");
-	printf("Trunk ID : %i\n",(unsigned int)tm->trunkId);
-	printf("N Ports  : %i\n",(unsigned int)tm->nTrunkPort);
-	printf("1st Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[0].devIndex,(unsigned int)tm->trunkSet[0].port);
-	printf("2nd Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[1].devIndex,(unsigned int)tm->trunkSet[1].port);
-	printf("3rd Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[2].devIndex,(unsigned int)tm->trunkSet[2].port);
-	printf("4th Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[3].devIndex,(unsigned int)tm->trunkSet[3].port);
-
-	trunkId = tm->trunkId;
-
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-		portVec[i] = 0;
-
-	printf("Enabling TRUNK for each member port.\n");
-	for(i=0; i<tm->nTrunkPort; i++)
-	{
-		ts = &tm->trunkSet[i];
-
-		if(ts->devIndex >= N_OF_QD_DEVICES)
-		{
-			printf("Device %i is supported. Max Device Number is %i\n",(unsigned int)ts->devIndex,N_OF_QD_DEVICES-1);
-			return GT_FAIL;
-		}
-
-		if((dev[ts->devIndex] == NULL) || (!dev[ts->devIndex]->devEnabled))
-		{
-			printf("Device %i is not initialized\n",(unsigned int)ts->devIndex);
-			return GT_FAIL;
-		}
-
-		/* enabled trunk on the given port */
-		if((status = gprtSetTrunkPort(dev[ts->devIndex],ts->port,GT_TRUE,trunkId)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-			return status;
-		}
-
-		portVec[ts->devIndex] |= (1 << ts->port);
-	}
-
-	/*
-	 *	Set Trunk Route Table for the given Trunk ID.
-	*/ 
-	printf("Setting TRUNK Routing Table\n");
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-	{
-		if((dev[i] == NULL) || (!dev[i]->devEnabled))
-		{
-			printf("Device %i is not initialized\n",i);
-			break;
-		}
-
-		if((status = gsysSetTrunkRouting(dev[i],trunkId,portVec[i]|casecadeVec)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-			return status;
-		}
-	}
-
-	/*
-	 *	Set Trunk Mask Table for load balancing.
-	*/ 
-	printf("Setting TRUNK Mask for Load Balancing\n");
-	for(i=0; i<8; i++)
-	{
-		/* choose a port to be used for the given addr combo index */
-		index = i % tm->nTrunkPort;
-		ts = &tm->trunkSet[index];
-		
-		for(j=0; j<N_OF_QD_DEVICES; j++)
-		{
-			if((dev[j] == NULL) || (!dev[j]->devEnabled))
-			{
-				printf("Device %i is not initialized\n",j);
-				continue;
-			}
-
-			if(portVec[j] == 0)
-				continue;
-
-			if((status = gsysGetTrunkMaskTable(dev[j],i,&mask)) != GT_OK)
-			{
-				MSG_PRINT(("gsysGetTrunkMaskTable return Failed\n"));
-				return status;
-			}
-
-			mask &= ~portVec[j];
-
-			if(ts->devIndex == j)
-				mask |= (1 << ts->port);
-			
-			if((status = gsysSetTrunkMaskTable(dev[j],i,mask)) != GT_OK)
-			{
-				MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-				return status;
-			}
-		}
-	}
-	
-	return GT_OK;
-}
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/testApi.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/testApi.c
deleted file mode 100644
index 13db481..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/testApi.c
+++ /dev/null
@@ -1,8717 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* testApi.c
-*
-* DESCRIPTION:
-*       API test functions
-*
-* DEPENDENCIES:   Platform.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-#include "msSample.h"
-
-/*
-#define TEST_DEBUG
-*/
-#define MAX_TEST_RUN			16
-
-ATU_ENTRY_INFO *gAtuEntry = NULL;
-int gAgeDelayTime = 0;
-
-GT_U32 testSysCtrl(GT_QD_DEV *dev);
-GT_U32 testPort(GT_QD_DEV *dev);
-GT_U32 testATU(GT_QD_DEV *dev);
-GT_U32 testVlan(GT_QD_DEV *dev);
-GT_U32 testSTP(GT_QD_DEV *dev);
-GT_U32 testPhy(GT_QD_DEV *dev);
-GT_U32 testPortStatus(GT_QD_DEV *dev);
-GT_U32 testQoSRule(GT_QD_DEV *dev);
-GT_U32 testQoSMap(GT_QD_DEV *dev);
-GT_U32 testRMON(GT_QD_DEV *dev);
-GT_U32 testVTU(GT_QD_DEV *dev);
-GT_U32 testSysStatus(GT_QD_DEV *dev);
-GT_U32 testPortRateCtrl(GT_QD_DEV *dev);
-GT_U32 testPortPAV(GT_QD_DEV *dev);
-GT_U32 testInterrupt(GT_QD_DEV *dev);
-GT_U32 testPCSCtrl(GT_QD_DEV *dev);
-GT_U32 testPIRL(GT_QD_DEV *dev);
-
-TEST_STRUCT testStruct[] = 
-	{
-	{"SysCtrl    :", testSysCtrl,    0},
-	{"PortCtrl   :", testPort,       0},
-	{"ATU        :", testATU,        0},
-	{"VLAN       :", testVlan,       0},
-	{"STP        :", testSTP,        0},
-	{"PhyCtrl    :", testPhy,        0},
-	{"Port Status:", testPortStatus, 0},
-	{"QoS Rule   :", testQoSRule,    0},
-	{"QoS Map    :", testQoSMap,     0},
-	{"RMON       :", testRMON,       0},
-	{"VTU        :", testVTU,        0},
-	{"Sys Status :", testSysStatus,  0},
-	{"Port Rate  :", testPortRateCtrl, 0},
-	{"Port PAV   :", testPortPAV,    0},
-	{"PCSCtrl    :", testPCSCtrl,    0},
-	/*Interrupt is tested only on simulator
-	{"Interrupt  :", testInterrupt,  GT_OK},
-	*/
-	{"PIRL       :", testPIRL,    0},
-	{"", NULL,GT_OK}
-	};
-#if 0
-TEST_STRUCT testStructG[] = 
-	{
-	{"SysCtrl(G)    :", testSysCtrlG,    0},
-	{"PortCtrl(G)   :", testPortG,       0},
-	{"ATU(G)        :", testATUG,        0},
-	{"VLAN(G)       :", testVlanG,       0},
-	{"STP(G)        :", testSTPG,        0},
-	{"PhyCtrl(G)    :", testPhyG,        0},
-	{"Port Status(G):", testPortStatusG, 0},
-	{"QoS Rule(G)   :", testQoSRuleG,    0},
-	{"QoS Map(G)    :", testQoSMapG,     0},
-	{"RMON(G)       :", testRMONG,       0},
-	{"VTU(G)        :", testVTUG,        0},
-	{"Sys Status(G) :", testSysStatusG,  0},
-	{"Port Rate(G)  :", testPortRateCtrlG, 0},
-	{"Port PAV(G)   :", testPortPAVG,    0},
-	/*Interrupt is tested only on simulator
-	{"Interrupt  :", testInterrupt,  GT_OK},
-	*/
-	{"", NULL,GT_OK}
-	};
-#endif
-
-void testDisplayStatus(GT_STATUS status)
-{
-	switch(status)
-	{
-		case GT_OK :
-			MSG_PRINT(("Passed.\n"));
-			break;
-		case GT_FAIL :
-			MSG_PRINT(("Failed.\n"));
-			break;
-		case GT_BAD_PARAM :
-			MSG_PRINT(("Bad Parameter.\n"));
-			break;
-		case GT_NOT_SUPPORTED :
-			MSG_PRINT(("Not Supported.\n"));
-			break;
-		case GT_NOT_FOUND :
-			MSG_PRINT(("Not Found.\n"));
-			break;
-		case GT_NO_MORE :
-			MSG_PRINT(("No more Item.\n"));
-			break;
-		case GT_NO_SUCH :
-			MSG_PRINT(("No Such Item.\n"));
-			break;
-		default:
-			MSG_PRINT(("Failed.\n"));
-			break;
-	}
-}
-
-void printATUEntry(GT_ATU_ENTRY *entry)
-{
-	MSG_PRINT(("(%02x-%02x-%02x-%02x-%02x-%02x), DBNum %i, PortVec %#x, Pri %#x, State %#x\n",
-					entry->macAddr.arEther[0],
-					entry->macAddr.arEther[1],
-					entry->macAddr.arEther[2],
-					entry->macAddr.arEther[3],
-					entry->macAddr.arEther[4],
-					entry->macAddr.arEther[5],
-					entry->DBNum,
-					entry->portVec,
-					entry->prio,
-					entry->entryState.mcEntryState));
-}
-
-void dumpMemory(char* startAddr, int length)
-{	int i;
-
-	printf("\n");
-	while(length>16)
-	{
-		for(i=0; i<16; i++)
-			printf("%02x ",(unsigned char)*startAddr++);
-		printf("\n");
-		length -= 16;
-	}
-	for(i=0; i<length; i++)
-		printf("%02x ",(unsigned char)*startAddr++);
-	printf("\n");
-}
-
-GT_STATUS testBoolType(GT_QD_DEV *dev, TEST_API* api)
-{
-	GT_STATUS status;
-	GT_BOOL orgValue, tmpValue;
-	GT_STATUS testResult = GT_OK;
-	
-	/* Get the Original value */
-	if((status=api->getFunc.bool(dev,&orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Set to 1 */
-	if((status=api->setFunc.bool(dev,GT_TRUE)) != GT_OK)
-	{
-		MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Get the modified value */
-	if((status=api->getFunc.bool(dev,&tmpValue)) != GT_OK)
-	{
-		MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	if(tmpValue != GT_TRUE)
-	{
-		MSG_PRINT(("Test Value Mismatch (expected GT_TRUE).\n"));
-		testResult = GT_FAIL;
-	}
-
-	/* Set to 0 */
-	if((status=api->setFunc.bool(dev,GT_FALSE)) != GT_OK)
-	{
-		MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Get the modified value */
-	if((status=api->getFunc.bool(dev,&tmpValue)) != GT_OK)
-	{
-		MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	if(tmpValue != GT_FALSE)
-	{
-		MSG_PRINT(("Test Value Mismatch (expected GT_FALSE).\n"));
-		testResult = GT_FAIL;
-	}
-
-	/* Set to original value */
-	if((status=api->setFunc.bool(dev,orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	return testResult;		
-}
-
-GT_STATUS testU16Type(GT_QD_DEV *dev, TEST_API* api, int testLimit)
-{
-	GT_STATUS status;
-	GT_U16 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-		
-	/* Get the Original value */
-	if((status=api->getFunc.u16(dev,&orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Reading U16 Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Set to 0 */
-	for(i=0; i<(GT_U16)testLimit; i++)
-	{
-		if((status=api->setFunc.u16(dev,i)) != GT_OK)
-		{
-			MSG_PRINT(("Writing U16 Value Failed (%#x, value %i).\n", status,i));
-			return status;
-		}
-
-		/* Get the modified value */
-		if((status=api->getFunc.u16(dev,&tmpValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U16 Value Failed (%#x, value %i).\n", status,i));
-			return status;
-		}
-
-		if(tmpValue != i)
-		{
-			MSG_PRINT(("Test Value Mismatch (write %i, read %i).\n",i,tmpValue));
-			testResult = GT_FAIL;
-		}
-	}
-
-	/* Set to original value */
-	if((status=api->setFunc.u16(dev,orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Writing U16 Value Failed (%#x, org value %i).\n", status, orgValue));
-		return status;
-	}
-
-	return testResult;		
-}
-
-
-GT_STATUS testU32Type(GT_QD_DEV *dev, TEST_API* api, int testLimit)
-{
-	GT_STATUS status;
-	GT_U32 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-		
-	/* Get the Original value */
-	if((status=api->getFunc.u32(dev,&orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Reading U32 Value Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Set to 0 */
-	for(i=0; i<(GT_U32)testLimit; i++)
-	{
-		if((status=api->setFunc.u32(dev,i)) != GT_OK)
-		{
-			MSG_PRINT(("Writing U32 Value Failed (%#x, value %i).\n", status,i));
-			return status;
-		}
-
-		/* Get the modified value */
-		if((status=api->getFunc.u32(dev,&tmpValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U32 Value Failed (%#x, value %i).\n", status,i));
-			return status;
-		}
-
-		if(tmpValue != i)
-		{
-			MSG_PRINT(("Test Value Mismatch (write %i, read %i).\n",i,tmpValue));
-			testResult = GT_FAIL;
-		}
-	}
-
-	/* Set to original value */
-	if((status=api->setFunc.u32(dev,orgValue)) != GT_OK)
-	{
-		MSG_PRINT(("Writing U32 Value Failed (%#x, org value %i).\n", status, orgValue));
-		return status;
-	}
-
-	return testResult;		
-}
-
-
-GT_STATUS testMacType(GT_QD_DEV *dev, TEST_API* api)
-{
-	GT_STATUS status;
-	GT_ETHERADDR orgMac, tmpMacIn, tmpMacOut;
-	GT_STATUS testResult = GT_OK;
-		
-	/* Get the Discard Excessive state */
-	if((status=api->getFunc.mac(dev,&orgMac)) != GT_OK)
-	{
-		MSG_PRINT(("Reading MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	tmpMacIn.arEther[0] = 0xAA;
-	tmpMacIn.arEther[1] = 0xAA;
-	tmpMacIn.arEther[2] = 0xAA;
-	tmpMacIn.arEther[3] = 0xAA;
-	tmpMacIn.arEther[4] = 0xAA;
-	tmpMacIn.arEther[5] = 0xAA;
-
-	/* Set the Discard Excessive state */
-	if((status=api->setFunc.mac(dev,&tmpMacIn)) != GT_OK)
-	{
-		MSG_PRINT(("Writing MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Get the Discardl Excessive state */
-	if((status=api->getFunc.mac(dev,&tmpMacOut)) != GT_OK)
-	{
-		MSG_PRINT(("Reading MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	if(memcmp(&tmpMacIn,&tmpMacOut,6) != 0)
-	{
-		MSG_PRINT(("Unexpected MAC address(%#x-%#x-%#x-%#x-%#x-%#x)\n",
-					tmpMacOut.arEther[0],
-					tmpMacOut.arEther[1],
-					tmpMacOut.arEther[2],
-					tmpMacOut.arEther[3],
-					tmpMacOut.arEther[4],
-					tmpMacOut.arEther[5]));
-
-		testResult = GT_FAIL;
-	}
-
-	tmpMacIn.arEther[0] = 0x54;
-	tmpMacIn.arEther[1] = 0x55;
-	tmpMacIn.arEther[2] = 0x55;
-	tmpMacIn.arEther[3] = 0x55;
-	tmpMacIn.arEther[4] = 0x55;
-	tmpMacIn.arEther[5] = 0x55;
-
-	/* Set the Discard Excessive state */
-	if((status=api->setFunc.mac(dev,&tmpMacIn)) != GT_OK)
-	{
-		MSG_PRINT(("Writing MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Get the Discardl Excessive state */
-	if((status=api->getFunc.mac(dev,&tmpMacOut)) != GT_OK)
-	{
-		MSG_PRINT(("Reading MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	if(memcmp(&tmpMacIn,&tmpMacOut,6) != 0)
-	{
-		MSG_PRINT(("Unexpected MAC address(%#x-%#x-%#x-%#x-%#x-%#x)\n",
-					tmpMacOut.arEther[0],
-					tmpMacOut.arEther[1],
-					tmpMacOut.arEther[2],
-					tmpMacOut.arEther[3],
-					tmpMacOut.arEther[4],
-					tmpMacOut.arEther[5]));
-
-		testResult = GT_FAIL;
-	}
-
-	tmpMacIn.arEther[0] = 0x00;
-	tmpMacIn.arEther[1] = 0x00;
-	tmpMacIn.arEther[2] = 0x00;
-	tmpMacIn.arEther[3] = 0x00;
-	tmpMacIn.arEther[4] = 0x00;
-	tmpMacIn.arEther[5] = 0x01;
-
-	/* Set the Discard Excessive state */
-	if((status=api->setFunc.mac(dev,&tmpMacIn)) != GT_OK)
-	{
-		MSG_PRINT(("Writing MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	/* Get the Discardl Excessive state */
-	if((status=api->getFunc.mac(dev,&tmpMacOut)) != GT_OK)
-	{
-		MSG_PRINT(("Reading MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	if(memcmp(&tmpMacIn,&tmpMacOut,6) != 0)
-	{
-		MSG_PRINT(("Unexpected MAC address(%#x-%#x-%#x-%#x-%#x-%#x)\n",
-					tmpMacOut.arEther[0],
-					tmpMacOut.arEther[1],
-					tmpMacOut.arEther[2],
-					tmpMacOut.arEther[3],
-					tmpMacOut.arEther[4],
-					tmpMacOut.arEther[5]));
-
-		testResult = GT_FAIL;
-	}
-
-	/* Set the Discard Excessive state with original value */
-	if((status=api->setFunc.mac(dev,&orgMac)) != GT_OK)
-	{
-		MSG_PRINT(("Writing MAC Address Failed (%#x).\n", status));
-		return status;
-	}
-
-	return testResult;		
-}
-
-
-GT_STATUS testPortBoolType(GT_QD_DEV *dev, TEST_API* api)
-{
-	GT_STATUS status;
-	GT_BOOL orgValue, tmpValue;
-	GT_STATUS testResult = GT_OK;
-	GT_LPORT port;
-	int portIndex;
-		
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		/* Get the Original value */
-		if((status=api->getFunc.port_bool(dev,port,&orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Set to 1 */
-		if((status=api->setFunc.port_bool(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Get the modified value */
-		if((status=api->getFunc.port_bool(dev,port,&tmpValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		if(tmpValue != GT_TRUE)
-		{
-			MSG_PRINT(("Test Value Mismatch (expected GT_TRUE).\n"));
-			testResult = GT_FAIL;
-		}
-
-		/* Set to 0 */
-		if((status=api->setFunc.port_bool(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Get the modified value */
-		if((status=api->getFunc.port_bool(dev,port,&tmpValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		if(tmpValue != GT_FALSE)
-		{
-			MSG_PRINT(("Test Value Mismatch (expected GT_FALSE).\n"));
-			testResult = GT_FAIL;
-		}
-
-		/* Set to original value */
-		if((status=api->setFunc.port_bool(dev,port,orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Writing Bool Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		if (testResult != GT_OK)
-			return testResult;
-
-	}
-	return testResult;		
-}
-
-
-GT_STATUS testPortU8Type(GT_QD_DEV *dev, TEST_API* api, int testLimit)
-{
-	GT_STATUS status;
-	GT_U8 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-	GT_LPORT port;
-	int portIndex;
-		
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		/* Get the Original value */
-		if((status=api->getFunc.port_u8(dev,port,&orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U8 Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Set to 0 */
-		for(i=0; i<(GT_U8)testLimit; i++)
-		{
-			if((status=api->setFunc.port_u8(dev,port,i)) != GT_OK)
-			{
-				MSG_PRINT(("Writing U8 Value Failed (%#x).\n", status));
-				return status;
-			}
-
-			/* Get the modified value */
-			if((status=api->getFunc.port_u8(dev,port,&tmpValue)) != GT_OK)
-			{
-				MSG_PRINT(("Reading U8 Value Failed (%#x).\n", status));
-				return status;
-			}
-
-			if(tmpValue != i)
-			{
-				MSG_PRINT(("U16 Value Mismatch (port %i, write %#x, read %#x).\n", portIndex,i,tmpValue));
-				testResult = GT_FAIL;
-			}
-		}
-
-		/* Set to original value */
-		if((status=api->setFunc.port_u8(dev,port,orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Writing U8 Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		if (testResult != GT_OK)
-			return testResult;
-
-	}
-	return testResult;		
-}
-
-GT_STATUS testPortU16Type(GT_QD_DEV *dev, TEST_API* api, int testLimit)
-{
-	GT_STATUS status;
-	GT_U16 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-	GT_LPORT port;
-	int portIndex;
-		
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		/* Get the Original value */
-		if((status=api->getFunc.port_u16(dev,port,&orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U16 Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Set to 0 */
-		for(i=0; i<(GT_U16)testLimit; i++)
-		{
-			if((status=api->setFunc.port_u16(dev,port,i)) != GT_OK)
-			{
-				MSG_PRINT(("Writing U16 Value Failed (%#x).\n", status));
-				return status;
-			}
-
-			/* Get the modified value */
-			if((status=api->getFunc.port_u16(dev,port,&tmpValue)) != GT_OK)
-			{
-				MSG_PRINT(("Reading U16 Value Failed (%#x).\n", status));
-				return status;
-			}
-
-			if(tmpValue != i)
-			{
-				MSG_PRINT(("U16 Value Mismatch (port %i, write %#x, read %#x).\n", portIndex,i,tmpValue));
-				testResult = GT_FAIL;
-				return GT_FAIL; /* MJ Temp */
-			}
-		}
-
-		/* Set to original value */
-		if((status=api->setFunc.port_u16(dev,port,orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Writing U16 Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		if (testResult != GT_OK)
-			return testResult;
-
-	}
-	return testResult;		
-}
-
-GT_STATUS testPortU32Type(GT_QD_DEV *dev, TEST_API* api, int testLimit)
-{
-	GT_STATUS status;
-	GT_U32 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-	GT_LPORT port;
-	int portIndex;
-		
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-		
-		/* Get the Original value */
-		if((status=api->getFunc.port_u32(dev,port,&orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U32 Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Set to 0 */
-		for(i=0; i<(GT_U32)testLimit; i++)
-		{
-			if((status=api->setFunc.port_u32(dev,port,i)) != GT_OK)
-			{
-				MSG_PRINT(("Writing U32 Value Failed (port%i,data%i,%#x).\n", port,i,status));
-				return status;
-			}
-
-			/* Get the modified value */
-			if((status=api->getFunc.port_u32(dev,port,&tmpValue)) != GT_OK)
-			{
-				MSG_PRINT(("Reading U32 Value Failed (%#x).\n", status));
-				return status;
-			}
-
-			if(tmpValue != i)
-			{
-				MSG_PRINT(("U16 Value Mismatch (port %i, write %#x, read %#x).\n", port,i,tmpValue));
-				testResult = GT_FAIL;
-			}
-		}
-
-		/* Set to original value */
-		if((status=api->setFunc.port_u32(dev,port,orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Writing Org Value Failed (value %i,%#x).\n", orgValue,status));
-			return status;
-		}
-
-		if (testResult != GT_OK)
-			return testResult;
-
-	}
-	return testResult;		
-}
-
-GT_STATUS testU32U32Type(GT_QD_DEV *dev, TEST_API* api, int indexLimit, int testLimit)
-{
-	GT_STATUS status;
-	GT_U32 orgValue, tmpValue, i;
-	GT_STATUS testResult = GT_OK;
-	int index;
-
-	for(index=0; index<indexLimit; index++)
-	{
-		/* Get the Original value */
-		if((status=api->getFunc.port_u32(dev,index,&orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Reading U32 Org Value Failed (%#x).\n", status));
-			return status;
-		}
-
-		/* Set to 0 */
-		for(i=0; i<(GT_U32)testLimit; i++)
-		{
-			if((status=api->setFunc.port_u32(dev,index,i)) != GT_OK)
-			{
-				MSG_PRINT(("Writing U32 Value Failed (%#x) index:%i,value:%i.\n", status,index,i));
-				return status;
-			}
-
-			/* Get the modified value */
-			if((status=api->getFunc.port_u32(dev,index,&tmpValue)) != GT_OK)
-			{
-				MSG_PRINT(("Reading U32 Value Failed (%#x) index:%i,value:%i.\n", status,index,i));
-				return status;
-			}
-
-			if(tmpValue != i)
-			{
-				MSG_PRINT(("U16 Value Mismatch (index %i, write %#x, read %#x).\n", index,i,tmpValue));
-				testResult = GT_FAIL;
-			}
-		}
-
-		/* Set to original value */
-		if((status=api->setFunc.port_u32(dev,index,orgValue)) != GT_OK)
-		{
-			MSG_PRINT(("Writing U32 Org Value Failed (%#x) index:%i,value:%i.\n", status,index,orgValue));
-			return status;
-		}
-
-		if (testResult != GT_OK)
-			return testResult;
-
-	}
-	return testResult;		
-}
-
-GT_STATUS testTrunkPortSetup(GT_QD_DEV *dev, int portIndex)
-{
-	GT_STATUS status;
-	GT_U32 orgTrunkId, trunkId, tmpId;
-	GT_LPORT port;
-	GT_BOOL orgEn, tmpEn;
-
-	port = (GT_LPORT)portIndex;
-
-	if((status = gprtGetTrunkPort(dev,port,&orgEn,&orgTrunkId)) != GT_OK)
-	{
-		MSG_PRINT(("Getting Org. TrunkPort setup failed (port%i, status:%#x).\n", port,status));
-		return status;		
-	}
-
-	for(trunkId=0; trunkId<16; trunkId++)
-	{
-		if((status = gprtSetTrunkPort(dev,port,GT_TRUE,trunkId)) != GT_OK)
-		{
-			MSG_PRINT(("Setting TrunkPort setup failed (port%i,trunkId:%i,status:%#x).\n", port,trunkId,status));
-			return status;		
-		}
-
-		if((status = gprtGetTrunkPort(dev,port,&tmpEn,&tmpId)) != GT_OK)
-		{
-			MSG_PRINT(("Getting TrunkPort setup failed (port%i, status:%#x).\n", port,status));
-			return status;		
-		}
-
-		if((tmpEn != GT_TRUE) || (tmpId != trunkId))
-		{
-			MSG_PRINT(("TrunkPort Enable failed (ID:%i,%i).\n", trunkId,tmpId));
-			return status;		
-		}
-
-	}
-
-	if((status = gprtSetTrunkPort(dev,port,GT_FALSE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("Setting TrunkPort setup failed (port%i,trunkId:%i,status:%#x).\n", port,trunkId,status));
-		return status;		
-	}
-
-	if((status = gprtGetTrunkPort(dev,port,&tmpEn,&tmpId)) != GT_OK)
-	{
-		MSG_PRINT(("Getting TrunkPort setup failed (port%i, status:%#x).\n", port,status));
-		return status;		
-	}
-
-	if(tmpEn != GT_FALSE)
-	{
-		MSG_PRINT(("TrunkPort Disable failed (En:%i,%i).\n", GT_FALSE,tmpEn));
-		return status;		
-	}
-
-	if((status = gprtSetTrunkPort(dev,port,orgEn,orgTrunkId)) != GT_OK)
-	{
-		MSG_PRINT(("Setting TrunkPort setup failed (port%i,trunkId:%i,status:%#x).\n", port,trunkId,status));
-		return status;		
-	}
-
-	return GT_OK;
-}
-
-GT_U32 testSysCtrlG(GT_QD_DEV *dev )
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	GT_U32 data;
-	TEST_API testAPI;
-
-	/*
-	 *  PPU Setup API
-	 */
-	testAPI.getFunc.bool = gsysGetPPUEn;
-	testAPI.setFunc.bool = gsysSetPPUEn;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("PPU Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Cascade Port Setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetCascadePort;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetCascadePort;
-	if((status = testU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Cascade Port Setup API test "));
-	testDisplayStatus(status);
-	/*
-	 *  Device Number Setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetDeviceNumber;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetDeviceNumber;
-	if((status = testU32Type(dev,&testAPI,32)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Device Number Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Core Tag Type setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetCoreTagType;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetCoreTagType;
-	if((status = testU16Type(dev,&testAPI,64)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Core Tag Type Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  IngressMonitorDest setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetIngressMonitorDest;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetIngressMonitorDest;
-	if((status = testU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IngressMonitorDest Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  EngressMonitorDest setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetEgressMonitorDest;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetEgressMonitorDest;
-	if((status = testU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("EngressMonitorDest Setup API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			return testResults;
-		default:
-			break;
-	}			
-
-	/*
-	 *  ARPDest setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetARPDest;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetARPDest;
-	if((status = testU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ARPDest Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Rsvd2CpuEnables setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetRsvd2CpuEnables;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetRsvd2CpuEnables;
-	if((status = testU16Type(dev,&testAPI,0x8001)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Rsvd2CpuEnables Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Rsvd2Cpu setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetRsvd2Cpu;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetRsvd2Cpu;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Rsvd2Cpu Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  MGMTPri setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetMGMTPri;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetMGMTPri;
-	if((status = testU16Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MGMTPri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  UseDoubleTagData setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetUseDoubleTagData;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetUseDoubleTagData;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("UseDoubleTagData Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  PreventLoops setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetPreventLoops;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetPreventLoops;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("PreventLoops Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FlowControlMessage setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetFlowControlMessage;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetFlowControlMessage;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FlowControlMessage Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetForceFlowControlPri setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetForceFlowControlPri;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetForceFlowControlPri;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ForceFlowControlPri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FcPri setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetFCPri;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetFCPri;
-	if((status = testU16Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FCPri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetHashTrunk setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetHashTrunk;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetHashTrunk;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("HashTrunk Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FlowCtrlDelay Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gsysGetFlowCtrlDelay;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gsysSetFlowCtrlDelay;
-	if((status = testU32U32Type(dev,&testAPI,3,0x2000)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FlowCtrlDelay Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DevRoutingTable Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gsysGetDevRoutingTable;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gsysSetDevRoutingTable;
-	if((status = testU32U32Type(dev,&testAPI,32,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DevRoutingTable Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  TrunkMaskTable Setup
-	 */
-	switch (dev->deviceId)
-	{
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-				data = 4;
-				break;
-		default:
-				data = 8;
-				break;
-	}
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gsysGetTrunkMaskTable;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gsysSetTrunkMaskTable;
-	if((status = testU32U32Type(dev,&testAPI,data,(1<<(dev->numOfPorts-1)))) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("TrunkMaskTable Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetTrunkRouting Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gsysGetTrunkRouting;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gsysSetTrunkRouting;
-	if((status = testU32U32Type(dev,&testAPI,8,(1<<(dev->numOfPorts-1)))) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("TrunkRouting Setup API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6092:
-		case GT_88E6095:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-			if (dev->revision < 2)
-				return testResults;
-			break;
-		case GT_88E6131:
-		case GT_88E6108:
-		default:
-			break;
-	}			
-
-	/*
-	 *  gsysSetRateLimitMode Setup
-	 */
-	testAPI.getFunc.bool = (GT_API_GET_BOOL)gsysGetRateLimitMode;
-	testAPI.setFunc.bool = (GT_API_SET_BOOL)gsysSetRateLimitMode;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Rate Limit Mode Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetAgeInt Setup
-	 */
-	testAPI.getFunc.bool = gsysGetAgeInt;
-	testAPI.setFunc.bool = gsysSetAgeInt;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Age Interrupt Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetForceSnoopPri setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetForceSnoopPri;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetForceSnoopPri;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ForceSnoopPri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Snoop Pri setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetSnoopPri;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetSnoopPri;
-	if((status = testU16Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Snoop Pri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  gsysSetForceARPPri setup API
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetForceARPPri;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetForceARPPri;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ForceARPPri Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  ARP Pri setup API
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gsysGetARPPri;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gsysSetARPPri;
-	if((status = testU16Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ARP Pri Setup API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6131:
-		case GT_88E6108:
-			return testResults;
-		default:
-			break;
-	}			
-
-	/*
-	 *  Use Port Schedule API
-	 */
-	testAPI.getFunc.bool = gsysGetUsePortSchedule;
-	testAPI.setFunc.bool = gsysSetUsePortSchedule;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Use Port Schedule API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Use Old Header API
-	 */
-	testAPI.getFunc.bool = gsysGetOldHader;
-	testAPI.setFunc.bool = gsysSetOldHader;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Use Old Header API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Recursive Stripping Disable API
-	 */
-	testAPI.getFunc.bool = gsysGetRecursiveStrippingDisable;
-	testAPI.setFunc.bool = gsysSetRecursiveStrippingDisable;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Recursive Stripping Disable API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  CPU Port
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gsysGetCPUPort;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gsysSetCPUPort;
-	if((status = testU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("CPU Port API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-GT_U32 testSysCtrl(GT_QD_DEV *dev )
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	/* Sw Reset */
-	if((status=gsysSwReset(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSwReset returned Fail (%#x).\n", status));
-		testResults |= 1 << status;
-		return testResults;
-	}
-	testResult = GT_OK;
-
-	/*
-	 *  Testing Discard Excessive State API
-	 */
-	testAPI.getFunc.bool = gsysGetDiscardExcessive;
-	testAPI.setFunc.bool = gsysSetDiscardExcessive;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DiscardExcessive API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Testing Scheduling Mose API
-	 */
-	testAPI.getFunc.bool = gsysGetSchedulingMode;
-	testAPI.setFunc.bool = gsysSetSchedulingMode;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Scheduling Mode API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Testing Max Frame Size API
-	 */
-	testAPI.getFunc.bool = gsysGetMaxFrameSize;
-	testAPI.setFunc.bool = gsysSetMaxFrameSize;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MAX Frame Size API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Testing WatchDog API
-	 */
-	testAPI.getFunc.bool = gsysGetWatchDog;
-	testAPI.setFunc.bool = gsysSetWatchDog;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("WatchDog API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Testing PerPortDuplexPauseMac API
-	 */
-	testAPI.getFunc.bool = gsysGetPerPortDuplexPauseMac;
-	testAPI.setFunc.bool = gsysSetPerPortDuplexPauseMac;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Per Port Duplex Pause Mac API test "));
-	testDisplayStatus(status);
-
-
-#if 0
-	/*
-	 *  Retransmit Mode API
-	 */
-	testAPI.getFunc.bool = gsysGetRetransmitMode;
-	testAPI.setFunc.bool = gsysSetRetransmitMode;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Retransmit Mode API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Limit Backoff API
-	 */
-	testAPI.getFunc.bool = gsysGetLimitBackoff;
-	testAPI.setFunc.bool = gsysSetLimitBackoff;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Limit Backoff API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Rsv Queue's Request Priority API
-	 */
-	testAPI.getFunc.bool = gsysGetRsvReqPri;
-	testAPI.setFunc.bool = gsysSetRsvReqPri;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Rsv Queue's Request Priority API test "));
-	testDisplayStatus(status);
-#endif
-
-	/*
-	 *  Testing DuplexPauseMac API
-	 */
-	testAPI.getFunc.mac = gsysGetDuplexPauseMac;
-	testAPI.setFunc.mac = gsysSetDuplexPauseMac;
-	if((status = testMacType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Duplex Pause Mac API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			testResults |= testSysCtrlG(dev);
-			break;
-		default:
-			break;
-	}
-	
-#if 0
-	/* Reload EEPROM value */
-	if((status=gsysReLoad(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gsysReLoad returned Fail (%#x).\n", status));
-		testResults |= 1 << status;
-		return testResults;
-	}
-#endif
-
-	return testResults;
-}
-
-GT_U32 testPCSCtrl(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Inband Auto-Nego Bypass Setup API
-	 */
-	testAPI.getFunc.port_bool = gpcsGetAnBypassMode;
-	testAPI.setFunc.port_bool = gpcsSetAnBypassMode;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Inband Auto-Nego Bypass Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  PCS Inband Auto-Nego Setup API
-	 */
-	testAPI.getFunc.port_bool = gpcsGetPCSAnEn;
-	testAPI.setFunc.port_bool = gpcsSetPCSAnEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("PCS Inband Auto-Nego Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Link Value Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetLinkValue;
-	testAPI.setFunc.port_bool = gpcsSetLinkValue;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Link Value Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Forced Link Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetForcedLink;
-	testAPI.setFunc.port_bool = gpcsSetForcedLink;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Forced Link Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Duplex Value Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetDpxValue;
-	testAPI.setFunc.port_bool = gpcsSetDpxValue;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Duplex Value Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Forced Duplex Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetForcedDpx;
-	testAPI.setFunc.port_bool = gpcsSetForcedDpx;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Forced Duplex Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Forced Speed Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gpcsGetForceSpeed;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gpcsSetForceSpeed;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Forced Speed Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Flow control Value Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetFCValue;
-	testAPI.setFunc.port_bool = gpcsSetFCValue;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Flow Control Value Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Forced Flow control Setup
-	 */
-	testAPI.getFunc.port_bool = gpcsGetForcedFC;
-	testAPI.setFunc.port_bool = gpcsSetForcedFC;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Forced Flow Control Setup API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-GT_U32 testPortEnhancedFE(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-	int portIndex;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Drop on Lock
-	 */
-	testAPI.getFunc.port_bool = gprtGetDropOnLock;
-	testAPI.setFunc.port_bool = gprtSetDropOnLock;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Drop on Lock API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Double Tag
-	 */
-	testAPI.getFunc.port_bool = gprtGetDoubleTag;
-	testAPI.setFunc.port_bool = gprtSetDoubleTag;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Double Tag API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Interswitch Port
-	 */
-	testAPI.getFunc.port_bool = gprtGetInterswitchPort;
-	testAPI.setFunc.port_bool = gprtSetInterswitchPort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Interswith port setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Learning Disable
-	 */
-	testAPI.getFunc.port_bool = gprtGetLearnDisable;
-	testAPI.setFunc.port_bool = gprtSetLearnDisable;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Learning Disable API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FCS Ignore
-	 */
-	testAPI.getFunc.port_bool = gprtGetIgnoreFCS;
-	testAPI.setFunc.port_bool = gprtSetIgnoreFCS;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FCS Ignore API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  VTU Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetVTUPriOverride;
-	testAPI.setFunc.port_bool = gprtSetVTUPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("VTU Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetSAPriOverride;
-	testAPI.setFunc.port_bool = gprtSetSAPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DA Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetDAPriOverride;
-	testAPI.setFunc.port_bool = gprtSetDAPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DA Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  CPU Port Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetCPUPort;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetCPUPort;
-	if((status = testPortU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("CPU Port Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Locked Port Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetLockedPort;
-	testAPI.setFunc.port_bool = gprtSetLockedPort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Locked Port Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Ignore Wrong Data Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetIgnoreWrongData;
-	testAPI.setFunc.port_bool = gprtSetIgnoreWrongData;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Ignore Wrong Data Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  UseCoreTag Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetUseCoreTag;
-	testAPI.setFunc.port_bool = gprtSetUseCoreTag;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("UseCoreTag Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DiscardTagged Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDiscardTagged;
-	testAPI.setFunc.port_bool = gprtSetDiscardTagged;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DiscardTagged Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DiscardUntagged Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDiscardUntagged;
-	testAPI.setFunc.port_bool = gprtSetDiscardUntagged;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DiscardUntagged Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  MapDA Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetMapDA;
-	testAPI.setFunc.port_bool = gprtSetMapDA;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MapDA Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DefaultForward Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDefaultForward;
-	testAPI.setFunc.port_bool = gprtSetDefaultForward;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DefaultForward Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  EgressMonitorSource Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetEgressMonitorSource;
-	testAPI.setFunc.port_bool = gprtSetEgressMonitorSource;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("EgressMonitorSource Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  IngressMonitorSource Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetIngressMonitorSource;
-	testAPI.setFunc.port_bool = gprtSetIngressMonitorSource;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IngressMonitorSource Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  MessagePort Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetMessagePort;
-	testAPI.setFunc.port_bool = gprtSetMessagePort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MessagePort Setup API test "));
-	testDisplayStatus(status);
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		if((status = testTrunkPortSetup(dev,portIndex)) != GT_OK)
-		{
-			testResult = GT_FAIL;
-			testResults |= 1 << status;
-			portIndex = 0xFF;
-			break;		
-		}
-	}
-	MSG_PRINT(("TrunkPort Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  AGE Int Setup
-	 */
-	testAPI.getFunc.port_bool = geventGetAgeIntEn;
-	testAPI.setFunc.port_bool = geventSetAgeIntEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("AGE Interrupt Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA Filtering
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetSAFiltering;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetSAFiltering;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA Filtering Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  ARP to CPU Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetARPtoCPU;
-	testAPI.setFunc.port_bool = gprtSetARPtoCPU;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ARP to CPU Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Egress Flood
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetEgressFlood;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetEgressFlood;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Egress Flood Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Port Scheduling
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetPortSched;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetPortSched;
-	if((status = testPortU32Type(dev,&testAPI,2)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Port Scheduling Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Provider Tag
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetProviderTag;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetProviderTag;
-	if((status = testPortU32Type(dev,&testAPI,0xFF)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Provider Tag Setup API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-GT_U32 testPortG(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-	int portIndex;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Drop on Lock
-	 */
-	testAPI.getFunc.port_bool = gprtGetDropOnLock;
-	testAPI.setFunc.port_bool = gprtSetDropOnLock;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Drop on Lock API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Double Tag
-	 */
-	testAPI.getFunc.port_bool = gprtGetDoubleTag;
-	testAPI.setFunc.port_bool = gprtSetDoubleTag;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Double Tag API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Interswitch Port
-	 */
-	testAPI.getFunc.port_bool = gprtGetInterswitchPort;
-	testAPI.setFunc.port_bool = gprtSetInterswitchPort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Interswith port setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Learning Disable
-	 */
-	testAPI.getFunc.port_bool = gprtGetLearnDisable;
-	testAPI.setFunc.port_bool = gprtSetLearnDisable;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Learning Disable API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FCS Ignore
-	 */
-	testAPI.getFunc.port_bool = gprtGetIgnoreFCS;
-	testAPI.setFunc.port_bool = gprtSetIgnoreFCS;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FCS Ignore API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  VTU Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetVTUPriOverride;
-	testAPI.setFunc.port_bool = gprtSetVTUPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("VTU Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetSAPriOverride;
-	testAPI.setFunc.port_bool = gprtSetSAPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DA Priority Override
-	 */
-	testAPI.getFunc.port_bool = gprtGetDAPriOverride;
-	testAPI.setFunc.port_bool = gprtSetDAPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DA Priority Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  CPU Port Setup
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetCPUPort;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetCPUPort;
-	if((status = testPortU32Type(dev,&testAPI,dev->numOfPorts)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("CPU Port Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Locked Port Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetLockedPort;
-	testAPI.setFunc.port_bool = gprtSetLockedPort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Locked Port Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Ignore Wrong Data Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetIgnoreWrongData;
-	testAPI.setFunc.port_bool = gprtSetIgnoreWrongData;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Ignore Wrong Data Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  UseCoreTag Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetUseCoreTag;
-	testAPI.setFunc.port_bool = gprtSetUseCoreTag;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("UseCoreTag Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DiscardTagged Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDiscardTagged;
-	testAPI.setFunc.port_bool = gprtSetDiscardTagged;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DiscardTagged Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DiscardUntagged Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDiscardUntagged;
-	testAPI.setFunc.port_bool = gprtSetDiscardUntagged;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DiscardUntagged Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  MapDA Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetMapDA;
-	testAPI.setFunc.port_bool = gprtSetMapDA;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MapDA Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DefaultForward Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDefaultForward;
-	testAPI.setFunc.port_bool = gprtSetDefaultForward;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DefaultForward Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  EgressMonitorSource Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetEgressMonitorSource;
-	testAPI.setFunc.port_bool = gprtSetEgressMonitorSource;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("EgressMonitorSource Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  IngressMonitorSource Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetIngressMonitorSource;
-	testAPI.setFunc.port_bool = gprtSetIngressMonitorSource;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IngressMonitorSource Setup API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			return testResults;
-		default:
-			break;
-	}			
-	
-	/*
-	 *  MessagePort Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetMessagePort;
-	testAPI.setFunc.port_bool = gprtSetMessagePort;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("MessagePort Setup API test "));
-	testDisplayStatus(status);
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		if((status = testTrunkPortSetup(dev,portIndex)) != GT_OK)
-		{
-			testResult = GT_FAIL;
-			testResults |= 1 << status;
-			portIndex = 0xFF;
-			break;		
-		}
-	}
-	MSG_PRINT(("TrunkPort Setup API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6092:
-		case GT_88E6095:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-			if (dev->revision < 1)
-				return testResults;
-			break;
-		case GT_88E6131:
-		case GT_88E6108:
-			break;
-		default:
-			return testResults;
-	}			
-	
-	/*
-	 *  Discard Broadcast Mode Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetDiscardBCastMode;
-	testAPI.setFunc.port_bool = gprtSetDiscardBCastMode;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Discard BCast Setup API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  FC On RateLimit Mode Setup
-	 */
-	testAPI.getFunc.port_bool = gprtGetFCOnRateLimitMode;
-	testAPI.setFunc.port_bool = gprtSetFCOnRateLimitMode;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("FC On RateLimit Setup API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-GT_U32 testPort(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Force FlowControl
-	 */
-	testAPI.getFunc.port_bool = gprtGetForceFc;
-	testAPI.setFunc.port_bool = gprtSetForceFc;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Force FlowControl API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Trailer Mode
-	 */
-	testAPI.getFunc.port_bool = gprtGetTrailerMode;
-	testAPI.setFunc.port_bool = gprtSetTrailerMode;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Trailer Mode API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Ingress Mode
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetIngressMode;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetIngressMode;
-	if((status = testPortU32Type(dev,&testAPI,3)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Ingress Mode API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Muticast Rate Limit
-	 *  This feature is only avalable on 6021/6051/6052
-	 *  It is replace with Rate Control Register in Clippership and beyond
-	 */
-	if( (dev->deviceId == GT_88E6021) ||
-	    (dev->deviceId == GT_88E6051) ||
-	    (dev->deviceId == GT_88E6052) 
-	  ){
-
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetMcRateLimit;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetMcRateLimit;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Multicast Rate Limit API test "));
-	testDisplayStatus(status);
-	};
-
-	/*
-	 *  IGMP Snoop
-	 */
-	testAPI.getFunc.port_bool = gprtGetIGMPSnoop;
-	testAPI.setFunc.port_bool = gprtSetIGMPSnoop;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IGMP Snoop API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Header Mode
-	 */
-	testAPI.getFunc.port_bool = gprtGetHeaderMode;
-	testAPI.setFunc.port_bool = gprtSetHeaderMode;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Header Mode API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			testResults |= testPortG(dev);
-			break;
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			testResults |= testPortEnhancedFE(dev);
-			break;
-		default:
-			break;
-	}			
-	return testResults;
-}
-
-GT_U32 testPortRCforEnhancedFE(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = GT_OK;
-
-	/*
-	 *  VID NRL En
-	 */
-	testAPI.getFunc.port_bool = grcGetVidNrlEn;
-	testAPI.setFunc.port_bool = grcSetVidNrlEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("VID NRL En API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA NRL En
-	 */
-	testAPI.getFunc.port_bool = grcGetSaNrlEn;
-	testAPI.setFunc.port_bool = grcSetSaNrlEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA NRL En API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DA NRL En
-	 */
-	testAPI.getFunc.port_bool = grcGetDaNrlEn;
-	testAPI.setFunc.port_bool = grcSetDaNrlEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DA NRL En API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Egress Limit Mode
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)grcGetELimitMode;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)grcSetELimitMode;
-	if((status = testPortU32Type(dev,&testAPI,3)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Egress Limit Mode API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Rsvd NRL En
-	 */
-	testAPI.getFunc.bool = grcGetRsvdNrlEn;
-	testAPI.setFunc.bool = grcSetRsvdNrlEn;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Rsvd NRL En API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-GT_U32 testPortRateCtrl(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, tmpResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-	GT_LPORT port;
-	int portIndex;
-	GT_BURST_RATE bLimit, rbLimit, obLimit;
-	GT_BURST_SIZE bSize, rbSize, obSize;
-	GT_U32 RateCtrl[5];
-
-	testResult = GT_OK;
-
-	/*
-	 *  Ingress Rate Limit Mode
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)grcGetLimitMode;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)grcSetLimitMode;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Ingress Rate Limit Mode API test "));
-	testDisplayStatus(status);
-
-
-	/*
-	 *  Priority 3 Frames Rate Limit
-	 */
-	testAPI.getFunc.port_bool = grcGetPri3Rate;
-	testAPI.setFunc.port_bool = grcSetPri3Rate;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Priority 3 Frames Rate Limit API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Priority 2 Frames Rate Limit
-	 */
-	testAPI.getFunc.port_bool = grcGetPri2Rate;
-	testAPI.setFunc.port_bool = grcSetPri2Rate;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Priority 2 Frames Rate Limit API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Priority 1 Frames Rate Limit
-	 */
-	testAPI.getFunc.port_bool = grcGetPri1Rate;
-	testAPI.setFunc.port_bool = grcSetPri1Rate;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Priority 1 Frames Rate Limit API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Priority 0 Frames Rate Limit
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)grcGetPri0Rate;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)grcSetPri0Rate;
-	if((status = testPortU32Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Priority 0 Frames Rate Limit API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Included Bytes in Rate Control API
-	 */
-	tmpResult = GT_OK;
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		GT_BOOL limitMGMT, countIFG, countPre;
-		GT_BOOL orgLimitMGMT, orgCountIFG, orgCountPre;
-		GT_BOOL tmpLimitMGMT, tmpCountIFG, tmpCountPre;
-
-		port = portIndex;
-		
-		if((status = grcGetBytesCount(dev,port,&orgLimitMGMT,&orgCountIFG,&orgCountPre)) != GT_OK)
-		{
-			MSG_PRINT(("grcSetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			tmpResult = status;
-			break;
-		}
-
-		limitMGMT = GT_TRUE;
-		countIFG = GT_FALSE;
-		countPre = GT_TRUE;
-
-		if((status = grcSetBytesCount(dev,port,limitMGMT,countIFG,countPre)) != GT_OK)
-		{
-			MSG_PRINT(("grcSetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = grcGetBytesCount(dev,port,&tmpLimitMGMT,&tmpCountIFG,&tmpCountPre))
-			!= GT_OK)
-		{
-			MSG_PRINT(("grcGetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if ((limitMGMT != tmpLimitMGMT) ||
-			(countIFG != tmpCountIFG) ||
-			(countPre != tmpCountPre))
-		{
-			MSG_PRINT(("grcGetBytesCount returned unexpected value(s)\n"));
-			MSG_PRINT(("Expecting: limitMgmg %i, countIFG %i, countPre %i\n",
-						limitMGMT,countIFG,countPre));
-			MSG_PRINT(("Returned : limitMgmg %i, countIFG %i, countPre %i\n",
-						tmpLimitMGMT,tmpCountIFG,tmpCountPre));
-			tmpResult = GT_FAIL;
-			testResults |= 1 << tmpResult;
-		}
-
-		limitMGMT = GT_FALSE;
-		countIFG = GT_TRUE;
-		countPre = GT_FALSE;
-
-		if((status = grcSetBytesCount(dev,port,limitMGMT,countIFG,countPre)) != GT_OK)
-		{
-			MSG_PRINT(("grcSetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = grcGetBytesCount(dev,port,&tmpLimitMGMT,&tmpCountIFG,&tmpCountPre))
-			!= GT_OK)
-		{
-			MSG_PRINT(("grcGetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if ((limitMGMT != tmpLimitMGMT) ||
-			(countIFG != tmpCountIFG) ||
-			(countPre != tmpCountPre))
-		{
-			MSG_PRINT(("grcGetBytesCount returned unexpected value(s)\n"));
-			MSG_PRINT(("Expecting: limitMgmg %i, countIFG %i, countPre %i\n",
-						limitMGMT,countIFG,countPre));
-			MSG_PRINT(("Returned : limitMgmg %i, countIFG %i, countPre %i\n",
-						tmpLimitMGMT,tmpCountIFG,tmpCountPre));
-			tmpResult = GT_FAIL;
-			testResults |= 1 << tmpResult;
-		}
-
-		if((status = grcSetBytesCount(dev,port,orgLimitMGMT,orgCountIFG,orgCountPre))
-			!= GT_OK)
-		{
-			MSG_PRINT(("grcSetBytesCount returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	}
-	if(tmpResult != GT_OK)
-	{
-		MSG_PRINT(("Count Bytes API test Failed.\n"));
-		testResult = tmpResult;
-		testResults |= 1 << testResult;
-	}
-	else
-	{
-		MSG_PRINT(("Count Bytes API test Passed.\n"));
-	}
-
-	/*
-	 *  Egress Rate Limit
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)grcGetEgressRate;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)grcSetEgressRate;
-	if((status = testPortU32Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Egress Rate Limit API test "));
-	testDisplayStatus(status);
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6092:
-		case GT_88E6095:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-			if (dev->revision < 1)
-				return testResults;
-			break;
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			testResults |= testPortRCforEnhancedFE(dev);
-			break;
-		case GT_88E6131:
-		case GT_88E6108:
-			break;
-		default:
-			return testResults;
-	}			
-
-	/*
-	 *  Burst Size based Rate Limit API
-	 */
-	RateCtrl[0] = 0x7FFFF; /* No_Limit, 64k ~ 256M */
-	RateCtrl[1] = 0x7FFFD; /* No_Limit, 128k ~ 256M */
-	RateCtrl[2] = 0x7FFF9; /* No_Limit, 256k ~ 256M */
-	RateCtrl[3] = 0x7FFE1; /* No_Limit, 512k ~ 256M */
-	RateCtrl[4] = 0;
-	if(grcGetBurstRate(dev,0,&rbSize,&rbLimit) == GT_NOT_SUPPORTED)
-		testResult = GT_NOT_SUPPORTED;
-	else
-	{
-		testResult = GT_OK;
-
-		for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-		{
-			if((status=grcGetBurstRate(dev,portIndex,&obSize,&obLimit)) != GT_OK)
-			{
-				MSG_PRINT(("Get Burst Rate returned wrong (bsize %i, rate %i)\n",obSize,obLimit));
-				testResult = GT_FAIL;
-				testResults |= 1 << status;
-				break;
-			}
-
-			for(bSize=GT_BURST_SIZE_12K; bSize<=GT_BURST_SIZE_96K+1; bSize++)
-			{
-				for(bLimit=GT_BURST_NO_LIMIT; bLimit<=GT_BURST_256M+1; bLimit++)
-				{
-					if((status=grcSetBurstRate(dev,portIndex,bSize,bLimit)) != GT_OK)
-					{
-						if(RateCtrl[bSize] & (1<<bLimit))
-						{
-							MSG_PRINT(("Burst Rate Control returned wrong (bsize %i, rate %i)\n",bSize,bLimit));
-							testResult = GT_FAIL;
-							testResults |= 1 << GT_FAIL;
-						}
-					}
-					else
-					{
-						if (!(RateCtrl[bSize] & (1<<bLimit)))
-						{
-							MSG_PRINT(("Burst Rate Control returned GT_OK (bsize %i, rate %i)\n",bSize,bLimit));
-							testResult = GT_FAIL;
-							testResults |= 1 << GT_FAIL;
-							continue;
-						}
-
-						if((status=grcGetBurstRate(dev,portIndex,&rbSize,&rbLimit)) != GT_OK)
-						{
-							MSG_PRINT(("Get Burst Rate returned wrong (bsize %i, rate %i)\n",bSize,bLimit));
-							testResult = GT_FAIL;
-							testResults |= 1 << status;
-						}
-
-						if ((bSize != rbSize) || (bLimit != rbLimit))
-						{
-							MSG_PRINT(("Burst Rate returned value not consistant (bsize %i %i, rate %i %i)\n",
-										bSize,rbSize,bLimit,rbLimit));
-							testResult = GT_FAIL;
-							testResults |= 1 << GT_FAIL;
-						}
-					}
-				}
-			}
-
-			if((status=grcSetBurstRate(dev,portIndex,obSize,obLimit)) != GT_OK)
-			{
-				MSG_PRINT(("Set Burst Rate returned wrong (bsize %i, rate %i)\n",obSize,obLimit));
-				testResult = GT_FAIL;
-				testResults |= 1 << status;
-				break;
-			}
-		}
-	}
-
-	MSG_PRINT(("Burst Rate Limit API test "));
-	testDisplayStatus(testResult);
-
-	/*
-	 *  TCP/IP Burst Rate Limit API
-	 */
-	RateCtrl[0] = 0x7FF; /* No_Limit, 64k ~ 1500k */
-	if(grcGetTCPBurstRate(dev,0,&rbLimit) == GT_NOT_SUPPORTED)
-		testResult = GT_NOT_SUPPORTED;
-	else
-	{
-		testResult = GT_OK;
-
-		for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-		{
-			if((status=grcGetTCPBurstRate(dev,portIndex,&obLimit)) != GT_OK)
-			{
-				MSG_PRINT(("Get TCP Burst Rate returned wrong (rate %i)\n",obLimit));
-				testResult = GT_FAIL;
-				testResults |= 1 << status;
-				break;
-			}
-
-			for(bLimit=GT_BURST_NO_LIMIT; bLimit<=GT_BURST_256M; bLimit++)
-			{
-				if(grcSetTCPBurstRate(dev,portIndex,bLimit) != GT_OK)
-				{
-					if(RateCtrl[0] & (1<<bLimit))
-					{
-						MSG_PRINT(("TCP Burst Rate Control returned wrong (rate %i)\n",bLimit));
-						testResult = GT_FAIL;
-						testResults |= 1 << GT_FAIL;
-					}
-				}
-				else
-				{
-					if((status=grcGetTCPBurstRate(dev,portIndex,&rbLimit)) != GT_OK)
-					{
-						MSG_PRINT(("Get TCP Burst Rate returned wrong (rate %i)\n",bLimit));
-						testResult = GT_FAIL;
-						testResults |= 1 << status;
-					}
-
-					if (bLimit != rbLimit)
-					{
-						MSG_PRINT(("TCP Burst Rate returned value not consistant (rate %i %i)\n",
-									bLimit,rbLimit));
-						testResult = GT_FAIL;
-						testResults |= 1 << GT_FAIL;
-					}
-				}
-			}		
-
-			if((status=grcSetTCPBurstRate(dev,portIndex,obLimit)) != GT_OK)
-			{
-				MSG_PRINT(("Get TCP Burst Rate returned wrong (rate %i)\n",obLimit));
-				testResult = GT_FAIL;
-				testResults |= 1 << status;
-				break;
-			}
-
-		}
-	}
-	MSG_PRINT(("TCP Burst Rate Limit API test "));
-	testDisplayStatus(testResult);
-
-	return testResults;
-}
-
-GT_U32 testPortPAV(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Port Association Vector API
-	 */
-	testAPI.getFunc.port_u16 = gpavGetPAV;
-	testAPI.setFunc.port_u16 = gpavSetPAV;
-	if((status = testPortU16Type(dev,&testAPI,(1<<dev->numOfPorts)-1)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Port Association Vector API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Ingress Monitor
-	 */
-	testAPI.getFunc.port_bool = gpavGetIngressMonitor;
-	testAPI.setFunc.port_bool = gpavSetIngressMonitor;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Ingress Monitor API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-
-GT_U32 testATUSetup(GT_QD_DEV *dev )
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	/*
-	 *  Learn2All Setup API
-	 */
-	testAPI.getFunc.bool = gfdbGetLearn2All;
-	testAPI.setFunc.bool = gfdbSetLearn2All;
-	if((status = testBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Learn2All Setup API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-
-GT_STATUS testDisplayATUList(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_ATU_ENTRY tmpMacEntry;
-	GT_U32 dbNum,i;
-	int entries;
-
-	MSG_PRINT(("ATU List:\n"));
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6051:
-		case GT_88E6052:
-		case GT_FF_HG:
-		case GT_FF_EG:
-			dbNum = 1;
-			break;
-		case GT_88E6021:
-		case GT_88E6061:
-		case GT_88E6063:
-		case GT_FH_VPN:
-		case GT_88E6083:
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			dbNum = 16;
-			break;
-		case GT_88E6065:
-			dbNum = 64;
-			break;
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			dbNum = 256;
-			break;
-		default:
-			dbNum = 1;
-			break;
-	}
-
-	for(i=0; i<dbNum; i++)
-	{
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.DBNum = (GT_U8)i;
-		entries = 0;
-		MSG_PRINT(("DB %i :\n",i));
-		while(1)
-		{
-			/* Get the sorted list of MAC Table. */
-			if((status = gfdbGetAtuEntryNext(dev,&tmpMacEntry)) != GT_OK)
-			{
-				break;
-			}
-			entries++;
-			printATUEntry(&tmpMacEntry);
-
-		}
-		MSG_PRINT(("DB %i : entry %i\n",i,entries));
-
-	}
-	return GT_OK;
-}
-
-GT_U16 testDisplayAtuDbNumList(GT_QD_DEV *dev,GT_U32 dbNum)
-{
-	GT_STATUS status;
-	GT_ATU_ENTRY tmpMacEntry;
-	GT_U16 entries = 0;
-
-	MSG_PRINT(("ATU List for DBNum %i:\n", dbNum));
-
-	memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-	tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-	while(1)
-	{
-		/* Get the sorted list of MAC Table. */
-		if((status = gfdbGetAtuEntryNext(dev,&tmpMacEntry)) != GT_OK)
-		{
-			break;
-		}
-
-		entries++;
-		printATUEntry(&tmpMacEntry);
-	}
-	return entries;
-}
-
-/*******************************************************************************
-* testATUDBNum
-*
-* DESCRIPTION:
-*       Testing ATU related APIs.
-*		(SetAtuSize, SetAgingTimeout, GetAgingTimeRange, LearnEnable, AddEntry,
-*		DeleteEntry, GetFirst, GetNext, FindEntry, Flush, GetDynamicCount)
-*		
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on fail
-*
-* COMMENTS:
-*		1. Setup ATU Size.
-*		2. Disable AGING.
-*		3. Disable Learning.
-*		4. Flush all the ATU Entries.
-*		5. Create ATU Entries (random, with arg).
-*		6. Keep the Sorted list of the entries.
-*		7. Write the entries into the device.
-*		8. Check the Dynamic Counter.
-*		9. Get the First Entry and Check if it's correct.
-*		10.Delete the First entry.
-*		11.Get the First Entry and check if it's correct.
-*		12.Get the next entry and check if it's correct.
-*		13.Find the middle entry and check if it's correct.
-*		14.Find the last entry and check if it's correct.
-*		15.Find the next entry of the last entry.(It should fail.)
-*		16.Find the deleted entry.(It should fail.)
-*		17.Repeat 9 ~ 16 for each DBNum
-*		18.If the device supports MOVE, 
-*			18.1 Move all the entries in DB (maxDbNum-1) to port 1 and verify
-*			18.2 Move all the entries to port 0 and verify
-*		19.Check Dynamic count.
-*		20.Flush All in a DB
-*
-*******************************************************************************/
-GT_STATUS testAtuDbNum(GT_QD_DEV *dev,int arg, GT_U32 entrySize, GT_U32 maxDbNum, GT_U8 sameMacs, GT_U8 atuSize)
-{
-	GT_STATUS status;
-	GT_STATUS testResult = GT_OK;
-	GT_U32 u32Data1, u32Data2, dbNum;
-	TEST_ATU_ENTRY *macEntry;
-	int *macList[256];
-	GT_ATU_ENTRY tmpMacEntry;
-	int i, j, dynamicMacs;
-	GT_BOOL found;
-	GT_BOOL sapphire, aging15, moveAllowed;
-	GT_LPORT port, portDest;
-	GT_STATUS secResult;
-	volatile int timer;
-
-	if(entrySize < 4)
-		entrySize = 4;
-
-	if(entrySize > TEST_MAC_ENTRIES)
-		entrySize = TEST_MAC_ENTRIES;
-
-	if (entrySize*maxDbNum > (256 << atuSize))
-	{
-		entrySize = (256 << atuSize) / maxDbNum;
-	}
-
-	macEntry = NULL;
-	for(dbNum=0; dbNum < maxDbNum; dbNum++)
-		macList[dbNum] = NULL;
-	
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			sapphire = GT_TRUE;
-			aging15 = GT_TRUE;
-			moveAllowed = GT_TRUE;
-			break;
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			moveAllowed = GT_TRUE;
-			sapphire = GT_FALSE;
-			aging15 = GT_TRUE;
-			break;
-		default:
-			moveAllowed = GT_FALSE;
-			sapphire = GT_FALSE;
-			aging15 = GT_FALSE;
-			break;
-	}			
-	/* Set ATU Size will cause ATU reset and SW reset, so call before any other setup. */
-	MSG_PRINT(("Setting ATU Size : %i\n",256<<atuSize));
-	if((status = gfdbSetAtuSize(dev,atuSize)) != GT_OK)
-	{
-		if(sapphire != GT_TRUE)
-		{
-			MSG_PRINT(("gfdbSetAtuSize returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-	}
-
-	/* Aging Time Range is between 16 and 4080 */
-	MSG_PRINT(("Getting Aging Time Range... \n"));
-	if((status = gfdbGetAgingTimeRange(dev,&u32Data1, &u32Data2)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbAgingTimeRange returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	if((u32Data2 != 16) || (u32Data1 != 4080))
-	{
-		if(aging15 != GT_TRUE)
-		{
-			MSG_PRINT(("AgingTimeRange is between %d and %d.\n",u32Data1,u32Data2));
-			testResult = GT_FAIL;
-		}
-	}
-
-	/* Disable Aging */
-	MSG_PRINT(("Disable Aging Timeout... \n"));
-	if((status = gfdbSetAgingTimeout(dev,0)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAgingTimeout returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	/* Disable Learning */
-	MSG_PRINT(("Disable Learning... \n"));
-	if((status = gfdbLearnEnable(dev,GT_FALSE)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbLearnEnable returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	/* Flush all addresses from the ATU table. */
-	MSG_PRINT(("Flush out all the entries in the ATU Table ... \n"));
-	if((status = gfdbFlush(dev,GT_FLUSH_ALL)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbFlush returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	/* Get Atu Dynamic Count, which should be 0, since we flush them all. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	MSG_PRINT(("Atu Dynamic Count : %d.\n", u32Data1));
-
-	if(u32Data1)
-	{
-		testResult = GT_FAIL;
-	}
-	
-	/* Now ATU table is clean. Play with our own MAC entries */	
-	MSG_PRINT(("Setup Testing Table... \n"));
-
-	macEntry = (TEST_ATU_ENTRY*)malloc(maxDbNum*sizeof(TEST_ATU_ENTRY));
-	if(macEntry == NULL)
-	{
-		MSG_PRINT(("Failed to allocate MAC Entries. \n"));
-		goto errorExit;
-	}
-
-	memset(macEntry,0,sizeof(macEntry));
-
-	for(dbNum=0; dbNum < maxDbNum; dbNum++)
-	{
-		macList[dbNum] = (int*)malloc(TEST_MAC_ENTRIES*sizeof(int));
-		if(macList[dbNum] == NULL)
-		{
-			MSG_PRINT(("Failed to allocate MAC Entries. \n"));
-			goto errorExit;
-		}
-	}
-
-	MSG_PRINT(("Creating ATU List... \n"));
-	dynamicMacs = createATUList(dev,macEntry,entrySize,(GT_U16)maxDbNum,sameMacs,64 << atuSize);
-
-	if (dynamicMacs > entrySize*maxDbNum)
-	{
-		MSG_PRINT(("Cannot create ATU List for testing... \n"));
-		goto errorExit;
-	}
-
-	for(i=0; i<entrySize; i++)
-	{
-		for(dbNum=0; dbNum < maxDbNum; dbNum++)
-		{
-			macList[dbNum][i] = i;
-		}
-	}	
-
-	/* Get Sorted List for the arg, 0 or 1. */
-
-	MSG_PRINT(("Sorting the created ATU List... \n"));
-	for(dbNum=0; dbNum < maxDbNum; dbNum++)
-		gtSort(macList[dbNum], atuEntryCmpFunc, (void*)macEntry[dbNum].atuEntry, entrySize);
-
-	MSG_PRINT(("Writing ATU Entries... \n"));
-	for (dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-
-		for(i=0; i<entrySize; i++)
-		{
-			switch (arg)
-			{
-				case 0: /* ascending order */
-					j = macList[dbNum][i];
-					break;
-				case 1: /* descending order */
-					j = macList[dbNum][entrySize - 1 - i];
-					break;
-				default:
-					j = i;
-					break;
-			}
-
-			if((status = gfdbAddMacEntry(dev,&macEntry[dbNum].atuEntry[j])) != GT_OK)
-			{
-				MSG_PRINT(("gfdbAddMacEntry returned "));
-				testDisplayStatus(status);
-				dumpMemory((char*)&macEntry[dbNum].atuEntry[j], sizeof(GT_ATU_ENTRY));
-				MSG_PRINT(("dbNum %i, entry %i\n",dbNum,j));
-				goto errorExit;
-			}
-
-#ifdef TEST_DEBUG
-			printATUEntry(&macEntry[dbNum].atuEntry[j]);
-			
-			memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-			tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-			if((status = gfdbGetAtuEntryFirst(dev,&tmpMacEntry)) != GT_OK)
-			{
-				MSG_PRINT(("gfdbGetAtuEntryFirst returned "));
-				testDisplayStatus(status);
-				MSG_PRINT(("Expected entry:"));
-				dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][0]], sizeof(GT_ATU_ENTRY));
-				testDisplayATUList(dev);
-				goto errorExit;
-			}
-
-			if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][0]], sizeof(GT_ATU_ENTRY)))
-			{
-				MSG_PRINT(("gfdbGetAtuEntryFirst returned wrong entry."));
-				dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-				MSG_PRINT(("Expected entry:"));
-				dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][0]], sizeof(GT_ATU_ENTRY));
-		
-				testDisplayATUList(dev);
-				goto errorExit;
-			}
-#endif
-		}	
-	}
-
-	timer = gAgeDelayTime;
-	while(timer>0)
-		timer--;
-
-#ifdef TEST_DEBUG
-	testDisplayATUList(dev);
-#endif
-	/* 
-		Now we have entrySize*16 entries in the table. 
-	*/
-
-	/* Get Atu Dynamic Count, which should be dynamicMacs. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	MSG_PRINT(("Dynamic Macs in the table : %d\n", dynamicMacs));
-	if (u32Data1 != dynamicMacs)
-	{
-		MSG_PRINT(("Atu Dynamic Count returned %d.(should be %d)\n", u32Data1,dynamicMacs));
-		testResult = GT_FAIL;
-	}
-
-	/* Get First Entry in the Table, which should be macEntry[0]. */
-
-	for (dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-		MSG_PRINT(("Running ATU Test for DBNum %i\n", dbNum));
-
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-		if((status = gfdbGetAtuEntryFirst(dev,&tmpMacEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbGetAtuEntryFirst returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][0]], sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbGetAtuEntryFirst returned wrong entry."));
-			dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expected entry:"));
-			dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][0]], sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Getting First Entry is passed. \n"));
-
-		/* Delete the first entry for each DBNum */
-		MSG_PRINT(("Delete the First Entry\n"));
-
-		if((status = gfdbDelAtuEntry(dev,&macEntry[dbNum].atuEntry[macList[dbNum][0]])) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if(!(macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[0] & 0x1) && 
-			(macEntry[dbNum].atuEntry[macList[dbNum][0]].entryState.ucEntryState == GT_UC_DYNAMIC))
-				dynamicMacs--;
-
-		/* Get First Entry in the Table, which should be macEntry[1]. */
-
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-		if((status = gfdbGetAtuEntryFirst(dev,&tmpMacEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbGetAtuEntryFirst returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][1]], sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbGetAtuEntryFirst returned wrong entry:"));
-			dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-		
-			MSG_PRINT(("Expecting entry."));
-			dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][1]], sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Getting First Entry is passed. \n"));
-
-		if((status = gfdbGetAtuEntryNext(dev,&tmpMacEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbGetAtuEntryNext returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][2]], sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbGetAtuEntryNext returned wrong entry."));
-			dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expected entry:"));
-			dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][2]], sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Getting Next Entry is passed. \n"));
-
-		/* Find Mac Entry (use macEntry[TEST_MAC_ENTRIES/2]) */
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		i = entrySize/2;
-		tmpMacEntry.macAddr.arEther[0] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the middle entry.\n"));
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Successfully Found the middle Mac Entry (PASS). \n"));
-
-		if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][i]], sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry."));
-			dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expected entry:"));
-			dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][i]], sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Found Entry is valid (PASS). \n"));
-
-		/* Find Mac Entry (use macEntry[TEST_MAC_ENTRIES-1]) */
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		i = entrySize-1;
-		tmpMacEntry.macAddr.arEther[0] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the last entry.\n"));
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Successfully Found the last Mac Entry (PASS). \n"));
-
-		if(memcmp(&tmpMacEntry, &macEntry[dbNum].atuEntry[macList[dbNum][i]], sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry."));
-			dumpMemory((char*)&tmpMacEntry, sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expected entry:"));
-			dumpMemory((char*)&macEntry[dbNum].atuEntry[macList[dbNum][i]], sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Found Entry is valid (PASS). \n"));
-
-		/* Error Checking */
-
-		/* Now tmpMacEntry is pointing to the last entry. So, GetNext should return error */
-		i = entrySize-1;
-		tmpMacEntry.macAddr.arEther[0] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-		if((status = gfdbGetAtuEntryNext(dev,&tmpMacEntry)) == GT_OK)
-		{
-			MSG_PRINT(("gfdbGetAtuEntryNext should return fail.\n"));
-			printATUEntry(&tmpMacEntry);
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("Getting Next Entry from the last entry returned %i (PASS).\n", status));
-
-		/* macEntry[0] has been deleted. So, finding the entry should return not found */
-
-		if((status = gfdbFindAtuMacEntry(dev,&macEntry[dbNum].atuEntry[macList[dbNum][0]],&found)) == GT_OK)
-		{
-			if (found == GT_TRUE)
-			{
-				MSG_PRINT(("gfdbFindAtuMacEntry should not be found.(%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[0],
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[1],
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[2],
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[3],
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[4],
-						macEntry[dbNum].atuEntry[macList[dbNum][0]].macAddr.arEther[5]));
-				testResult = GT_FAIL;
-			}
-			else
-				MSG_PRINT(("Finding invalid entry returned not found (PASS).\n"));
-
-		}
-		else
-		{
-			MSG_PRINT(("Finding invalid entry returned not OK (PASS).\n"));
-		}
-	}
-	/* If the device supports MOVE, 
-	 *		Move all the entries in DB 0 to port 1 and verify
-	 *		Move all the entries to port 0 and verify
-	*/
-
-	if (moveAllowed)
-	{
-		secResult = GT_OK;
-		
-		/* move all the entries in DB (maxDbNum-1) to port 1 */
-		portDest = 1;
-		dbNum = maxDbNum-1;
-
-		MSG_PRINT(("Moving entries to Port 1... (in DB %i) \n", dbNum));
-		
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if(port == portDest)
-				continue;
-
-			if((status = gfdbMoveInDB(dev,GT_MOVE_ALL,(GT_U8)dbNum,port,portDest)) != GT_OK)
-			{
-				MSG_PRINT(("gfdbMove returned "));
-				testDisplayStatus(status);
-				if (status == GT_NOT_SUPPORTED)
-					break;
-				goto errorExit;
-			}
-		}
-
-		/* verify Move, First Entry has been deleted from previous test */
-		for(i=1; i<entrySize; i++)
-		{
-			if (status == GT_NOT_SUPPORTED)
-				break;
-
-			memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-			tmpMacEntry.macAddr.arEther[0] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[0];
-			tmpMacEntry.macAddr.arEther[1] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[1];
-			tmpMacEntry.macAddr.arEther[2] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[2];
-			tmpMacEntry.macAddr.arEther[3] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[3];
-			tmpMacEntry.macAddr.arEther[4] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[4];
-			tmpMacEntry.macAddr.arEther[5] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[5];
-
-			tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-			if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-			{
-				MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-				testDisplayStatus(status);
-				goto errorExit;
-			}
-			
-			if (found == GT_FALSE)
-			{
-				MSG_PRINT(("Cannot find the last entry.\n"));
-				secResult = GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			/* verify if the port is portDest */
-			if ((tmpMacEntry.portVec & (1 << portDest)) == 0)
-			{
-				MSG_PRINT(("Move to port %i failed (portVec %#x, dbnum %i, orgVec %#x).\n",
-							portDest,tmpMacEntry.portVec,dbNum,
-							macEntry[dbNum].atuEntry[macList[dbNum][i]].portVec));
-				MSG_PRINT(("Entry : \n"));
-				printATUEntry(&tmpMacEntry);
-				secResult = GT_FAIL;
-				testResult = GT_FAIL;
-			}
-		}
-
-		if(secResult == GT_FAIL)
-		{
-			MSG_PRINT(("Moving entry Failed.\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Moving entry Passed.\n"));                          
-		}
-		
-		/* move all the entries to port 0 */
-		portDest = 0;
-		secResult = GT_OK;
-		MSG_PRINT(("Moving entries to Port 0...\n"));                          
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if(port == portDest)
-				continue;
-
-			if((status = gfdbMove(dev,GT_MOVE_ALL,port,portDest)) != GT_OK)
-			{
-				MSG_PRINT(("gfdbMove returned "));
-				testDisplayStatus(status);
-				if (status == GT_NOT_SUPPORTED)
-					break;
-				goto errorExit;
-			}
-		}
-
-		/* verify Move. First Entry has been deleted from previous test */
-		for(i=1; i<entrySize; i++)
-		{
-			if (status == GT_NOT_SUPPORTED)
-				break;
-
-			for (dbNum=0; dbNum<maxDbNum; dbNum++)
-			{
-				memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-				tmpMacEntry.macAddr.arEther[0] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[0];
-				tmpMacEntry.macAddr.arEther[1] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[1];
-				tmpMacEntry.macAddr.arEther[2] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[2];
-				tmpMacEntry.macAddr.arEther[3] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[3];
-				tmpMacEntry.macAddr.arEther[4] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[4];
-				tmpMacEntry.macAddr.arEther[5] = macEntry[dbNum].atuEntry[macList[dbNum][i]].macAddr.arEther[5];
-
-				tmpMacEntry.DBNum = (GT_U8)dbNum;
-
-				if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-				{
-					MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-					testDisplayStatus(status);
-					goto errorExit;
-				}
-			
-				if (found == GT_FALSE)
-				{
-					MSG_PRINT(("Cannot find the last entry.\n"));
-					secResult = GT_FAIL;
-					testResult = GT_FAIL;
-				}
-				/* verify if the port is portDest */
-				if ((tmpMacEntry.portVec & (1 << portDest)) == 0)
-				{
-					MSG_PRINT(("Move to port %i failed (portVec %#x, dbnum %i, orgVec %#x).\n",
-								portDest,tmpMacEntry.portVec,dbNum,
-								macEntry[dbNum].atuEntry[macList[dbNum][i]].portVec));
-					MSG_PRINT(("Entry :\n"));
-					printATUEntry(&tmpMacEntry);
-					secResult = GT_FAIL;
-					testResult = GT_FAIL;
-				}
-			}
-		}
-
-		if(secResult == GT_FAIL)
-		{
-			MSG_PRINT(("Moving entry Failed.\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Moving entry Passed.\n"));                          
-		}
-
-	}
-
-
-	MSG_PRINT(("Checking Dynamic Count... \n"));
-	/* Get Atu Dynamic Count, which should be dynamicMacs. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	if (u32Data1 != dynamicMacs)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned %d (should be %d).\n",u32Data1,dynamicMacs));
-		testResult = GT_FAIL;
-	}
-	else
-		MSG_PRINT(("Dynamic Entries : %d (PASS).\n",u32Data1));
-
-	/* Flush all non-static addresses from the ATU table. */
-	MSG_PRINT(("Flush out all the Dynamic Entries...\n"));
-	for (dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-		if((status = gfdbFlushInDB(dev,GT_FLUSH_ALL_UNBLK,dbNum)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFlushInDB returned "));
-			testDisplayStatus(status);
-			if (status == GT_NOT_SUPPORTED)
-				break;
-			goto errorExit;
-		}
-	}
-
-	if (dbNum != maxDbNum)
-	{
-		MSG_PRINT(("Call gfdbFlush \n"));
-		if((status = gfdbFlush(dev,GT_FLUSH_ALL_UNBLK)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFlush returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-	}
-
-	/* Get Atu Dynamic Count, which should be 0. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned "));
-		testDisplayStatus(status);
-		goto errorExit;
-	}
-
-	if (u32Data1)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned %d (should be 0).\n",u32Data1));
-		testResult = GT_FAIL;
-	}
-	else
-		MSG_PRINT(("Dynamic Entries : %d (PASS).\n",u32Data1));
-
-	/* Flush all addresses from the ATU table. */
-	MSG_PRINT(("Flush out all the Entries...\n"));
-	for (dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-		if((status = gfdbFlushInDB(dev,GT_FLUSH_ALL,dbNum)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFlushInDB returned "));
-			testDisplayStatus(status);
-			if (status == GT_NOT_SUPPORTED)
-				break;
-			goto errorExit;
-		}
-	}
-
-	if (dbNum != maxDbNum)
-	{
-		MSG_PRINT(("Call gfdbFlush \n"));
-		if((status = gfdbFlush(dev,GT_FLUSH_ALL_UNBLK)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFlush returned "));
-			testDisplayStatus(status);
-			goto errorExit;
-		}
-	}
-
-	return testResult;
-
-errorExit:
-
-	for(dbNum=0; dbNum < maxDbNum; dbNum++)
-		if(macList[dbNum])
-			free(macList[dbNum]);
-	if(macEntry)
-		free(macEntry);
-	return status;
-}
-
-GT_STATUS testFillUpAtu(GT_QD_DEV *dev,ATU_ENTRY_INFO *atuEntry, GT_U8 atuSize, GT_U32 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state)
-{
-	char buckets[MAX_BUCKET_SIZE];
-	GT_U16 binSize,bSize;
-	GT_U16 hash, bucket, tmpBucket, preBucket;
-	GT_U32 maxMacs,entry,i,addr;
-	char eaddr[6];
-
-	if(atuSize >= 5)
-		return GT_BAD_PARAM;
-
-	maxMacs = 256 << atuSize;
-	bSize = 64 << atuSize;
-	binSize = 4;
-
-	gtMemSet(buckets,0,MAX_BUCKET_SIZE);
-
-	i = entry = 0;
-
-	while(1)
-	{
-		if (i == 0xFFFFFFFF)
-		{
-			MSG_PRINT(("32bit is not enough.\n"));
-			return GT_FAIL;
-		}
-
-		i++;
-
-		if ((i & 0xFFFFFF) == 0)
-		{
-			MSG_PRINT(("loop %#x : entry %#x\n", i,entry));
-			dumpMemory(buckets,bSize);
-		}
-
-		*(GT_U16*)eaddr = first2Bytes;
-		eaddr[2] = (i >> 24) & 0xff;
-		eaddr[3] = (i >> 16) & 0xff;
-		eaddr[4] = (i >> 8) & 0xff;
-		eaddr[5] = i & 0xff;
-		bucket = runQDHash(eaddr, dbNum, bSize, &hash, &preBucket, &tmpBucket);
-		if(buckets[bucket] == binSize)
-			continue;
-		addr = bucket*binSize + buckets[bucket];
-		buckets[bucket]++;
-		memcpy(atuEntry[addr].atuEntry.macAddr.arEther,eaddr,6);
-		atuEntry[addr].atuEntry.entryState.ucEntryState = state;
-		atuEntry[addr].atuEntry.portVec = 1;
-		atuEntry[addr].atuEntry.prio = 0;
-		atuEntry[addr].atuEntry.DBNum = (GT_U8)dbNum;
-		atuEntry[addr].hash = hash;
-		atuEntry[addr].bucket = bucket;
-#if 0
-		MSG_PRINT(("EADDR : %02x-%02x-%02x-%02x, ", eaddr[2],eaddr[3],eaddr[4],eaddr[5]));
-		MSG_PRINT(("Hash : %03x, ", hash));
-		MSG_PRINT(("bucket : %03x, ", preBucket));
-		MSG_PRINT(("bucket(db) : %03x, ", bucket));
-		MSG_PRINT(("bins : %02x\n", buckets[bucket]-1));
-#endif
-		entry++;
-		if (entry >= maxMacs)
-		{
-			MSG_PRINT(("loop %#x\n", i));
-			break;
-		}
-		
-	}
-
-	return GT_OK;
-}
-
-/*
-	1. Set ATU Size.
-	2. Disable AGING.
-	3. Disable Learning.
-	4. Flush all the ATU entries.
-	5. Check Dynamic Counts.
-	6. Create Filled ATU Table in system memory with EntryState = 0x7.
-	7. Write the table into the device.
-	8. Compare ATU Entries.
-	9. Create Filled ATU Table in system memory with EntryState = 0x7.
-	10.Write the table into the device.
-	11.Compare ATU Entries. (Only First Entry in each bucket got replaced.)
-	12.Create Filled ATU Table in system memory with EntryState = 0xF.
-	13.Write the table into the device.
-	14.Compare ATU Entries.
-	15.Write the table which was created in step 9.
-	16.Make it sure that no entry is written.
-*/
-GT_STATUS testFilledATU(GT_QD_DEV *dev,GT_U8 atuSize, GT_U32 dbNum)
-{
-	GT_STATUS testResult, status;
-	ATU_ENTRY_INFO *atuEntry;
-	ATU_ENTRY_INFO *tmpAtuEntry;
-	ATU_ENTRY_INFO *tmpSingleAtuEntry;
-	GT_ATU_ENTRY tmpMacEntry;
-	GT_U16 maxMacs, i;
-	GT_BOOL found;
-	GT_U32 u32Data;
-
-	if(atuSize > 5)
-		return GT_FAIL;
-
-	testResult = GT_OK;
-	maxMacs = 256 << atuSize;
-
-	if (gAtuEntry == NULL)
-		gAtuEntry = (ATU_ENTRY_INFO *)malloc(sizeof(ATU_ENTRY_INFO)*4096);
-
-	atuEntry = gAtuEntry;
-
-	gtMemSet(atuEntry,0,sizeof(ATU_ENTRY_INFO)*maxMacs);
-
-	MSG_PRINT(("Setting ATU Size : %i\n",256<<atuSize));
-	if((status = gfdbSetAtuSize(dev,atuSize)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAtuSize returned "));
-		testDisplayStatus(status);
-		if (status != GT_NOT_SUPPORTED)
-			return status;
-	}
-
-	MSG_PRINT(("Disable Aging Timeout... \n"));
-	if((status = gfdbSetAgingTimeout(dev,0)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAgingTimeout returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	/* Disable Learning */
-	MSG_PRINT(("Disable Learning... \n"));
-	if((status = gfdbLearnEnable(dev,GT_FALSE)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAtuSize returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	/* Flush all addresses from the ATU table. */
-	MSG_PRINT(("Flush out all the entries in the ATU Table ... \n"));
-	if((status = gfdbFlush(dev,GT_FLUSH_ALL)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbFlush returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	/* Get Atu Dynamic Count, which should be 0, since we flush them all. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	MSG_PRINT(("Atu Dynamic Count : %d.\n", u32Data));
-
-	/*
-	 *	Entry State 0x7
-	 */
-
-	MSG_PRINT(("Getting ATU List(%i).\n",maxMacs));
-	if((status=testFillUpAtu(dev,atuEntry,atuSize,dbNum,0,GT_UC_DYNAMIC)) != GT_OK)
-	{
-		MSG_PRINT(("testFillUpAtu returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	MSG_PRINT(("Writing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		if((status = gfdbAddMacEntry(dev,&atuEntry[i].atuEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			return status;
-		}
-	}
-
-	MSG_PRINT(("Comparing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.macAddr.arEther[0] = atuEntry[i].atuEntry.macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = atuEntry[i].atuEntry.macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = atuEntry[i].atuEntry.macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = atuEntry[i].atuEntry.macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = atuEntry[i].atuEntry.macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = atuEntry[i].atuEntry.macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = atuEntry[i].atuEntry.DBNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			MSG_PRINT(("Entry to find : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-			return status;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the Entry : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-
-			testResult = GT_FAIL;
-			return testResult;
-		}
-
-		if(memcmp(&tmpMacEntry, &atuEntry[i].atuEntry, sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry.\n"));
-			dumpMemory((char*)&tmpMacEntry,sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expecting:\n"));
-			dumpMemory((char*)&atuEntry[i].atuEntry,sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-		{	
-			if(((i & 0x3F) == 0) && (i != 0))
-				MSG_PRINT(("Compared %i ATU Entries.\n",i));
-		}
-	}
-
-	/*
-	 *	Entry State 0x7
-	 */
-
-	if((tmpAtuEntry = (ATU_ENTRY_INFO *)malloc(sizeof(ATU_ENTRY_INFO)*maxMacs)) == NULL)
-		return GT_FAIL;
-	gtMemSet(tmpAtuEntry,0,sizeof(ATU_ENTRY_INFO)*maxMacs);
-
-	MSG_PRINT(("Getting ATU List(%i).\n",maxMacs));
-	if((status=testFillUpAtu(dev,tmpAtuEntry,atuSize,dbNum,0xA0A0,GT_UC_DYNAMIC)) != GT_OK)
-	{
-		MSG_PRINT(("testFillUpAtu returned "));
-		testDisplayStatus(status);
-		free(tmpAtuEntry);
-		return status;
-	}
-	MSG_PRINT(("Writing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		if((status = gfdbAddMacEntry(dev,&tmpAtuEntry[i].atuEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			free(tmpAtuEntry);
-			return status;
-		}
-	}
-
-	MSG_PRINT(("Comparing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		if ((i%4) == 0)
-			tmpSingleAtuEntry = &tmpAtuEntry[i+3];
-		else
-			tmpSingleAtuEntry = &atuEntry[i];
-
-		tmpMacEntry.macAddr.arEther[0] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = tmpSingleAtuEntry->atuEntry.macAddr.arEther[5];
-		tmpMacEntry.DBNum = tmpSingleAtuEntry->atuEntry.DBNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			MSG_PRINT(("Entry to find : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-			free(tmpAtuEntry);
-			return status;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the Entry : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-
-			free(tmpAtuEntry);
-			testResult = GT_FAIL;
-			return testResult;
-		}
-
-		if(memcmp(&tmpMacEntry, &(tmpSingleAtuEntry->atuEntry), sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry.\n"));
-			dumpMemory((char*)&tmpMacEntry,sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expecting:\n"));
-			dumpMemory((char*)&(tmpSingleAtuEntry->atuEntry),sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-		{	
-			if(((i & 0x3F) == 0) && (i != 0))
-				MSG_PRINT(("Compared %i ATU Entries.\n",i));
-		}
-	}
-
-	/*
-	 *	Entry State 0xF
-	 */
-
-	MSG_PRINT(("Getting ATU List(%i).\n",maxMacs));
-	gtMemSet(atuEntry,0,sizeof(ATU_ENTRY_INFO)*maxMacs);
-	if((status=testFillUpAtu(dev,atuEntry,atuSize,dbNum,0xAA00,GT_UC_STATIC)) != GT_OK)
-	{
-		MSG_PRINT(("testFillUpAtu returned "));
-		testDisplayStatus(status);
-		free(tmpAtuEntry);
-		return status;
-	}
-
-	MSG_PRINT(("Writing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		if((status = gfdbAddMacEntry(dev,&atuEntry[i].atuEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			free(tmpAtuEntry);
-			return status;
-		}
-	}
-
-	MSG_PRINT(("Comparing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.macAddr.arEther[0] = atuEntry[i].atuEntry.macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = atuEntry[i].atuEntry.macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = atuEntry[i].atuEntry.macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = atuEntry[i].atuEntry.macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = atuEntry[i].atuEntry.macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = atuEntry[i].atuEntry.macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = atuEntry[i].atuEntry.DBNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			MSG_PRINT(("Entry to find : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-			free(tmpAtuEntry);
-			return status;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the Entry : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-
-			testResult = GT_FAIL;
-			free(tmpAtuEntry);
-			return testResult;
-		}
-
-		if(memcmp(&tmpMacEntry, &atuEntry[i].atuEntry, sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry.\n"));
-			dumpMemory((char*)&tmpMacEntry,sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expecting:\n"));
-			dumpMemory((char*)&atuEntry[i].atuEntry,sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-		{	
-			if(((i & 0x3F) == 0) && (i != 0))
-				MSG_PRINT(("Compared %i ATU Entries.\n",i));
-		}
-	}
-
-	MSG_PRINT(("Writing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		if((status = gfdbAddMacEntry(dev,&tmpAtuEntry[i].atuEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			free(tmpAtuEntry);
-			return status;
-		}
-	}
-
-	MSG_PRINT(("Comparing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		memset(&tmpMacEntry,0,sizeof(GT_ATU_ENTRY));
-		tmpMacEntry.macAddr.arEther[0] = atuEntry[i].atuEntry.macAddr.arEther[0];
-		tmpMacEntry.macAddr.arEther[1] = atuEntry[i].atuEntry.macAddr.arEther[1];
-		tmpMacEntry.macAddr.arEther[2] = atuEntry[i].atuEntry.macAddr.arEther[2];
-		tmpMacEntry.macAddr.arEther[3] = atuEntry[i].atuEntry.macAddr.arEther[3];
-		tmpMacEntry.macAddr.arEther[4] = atuEntry[i].atuEntry.macAddr.arEther[4];
-		tmpMacEntry.macAddr.arEther[5] = atuEntry[i].atuEntry.macAddr.arEther[5];
-
-		tmpMacEntry.DBNum = atuEntry[i].atuEntry.DBNum;
-
-		if((status = gfdbFindAtuMacEntry(dev,&tmpMacEntry,&found)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned "));
-			testDisplayStatus(status);
-			MSG_PRINT(("Entry to find : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-			free(tmpAtuEntry);
-			return status;
-		}
-
-		if (found == GT_FALSE)
-		{
-			MSG_PRINT(("Cannot find the Entry : (%#x-%#x-%#x-%#x-%#x-%#x)\n",
-						tmpMacEntry.macAddr.arEther[0],
-						tmpMacEntry.macAddr.arEther[1],
-						tmpMacEntry.macAddr.arEther[2],
-						tmpMacEntry.macAddr.arEther[3],
-						tmpMacEntry.macAddr.arEther[4],
-						tmpMacEntry.macAddr.arEther[5]));
-
-			testResult = GT_FAIL;
-			free(tmpAtuEntry);
-			return testResult;
-		}
-
-		if(memcmp(&tmpMacEntry, &atuEntry[i].atuEntry, sizeof(GT_ATU_ENTRY)))
-		{
-			MSG_PRINT(("gfdbFindAtuMacEntry returned wrong entry.\n"));
-			dumpMemory((char*)&tmpMacEntry,sizeof(GT_ATU_ENTRY));
-			MSG_PRINT(("Expecting:\n"));
-			dumpMemory((char*)&atuEntry[i].atuEntry,sizeof(GT_ATU_ENTRY));
-
-			testResult = GT_FAIL;
-		}
-		else
-		{	
-			if(((i & 0x3F) == 0) && (i != 0))
-				MSG_PRINT(("Compared %i ATU Entries.\n",i));
-		}
-	}
-	
-	/* Flush all addresses from the ATU table. */
-	free(tmpAtuEntry);
-	MSG_PRINT(("Flush out all the entries in the ATU Table ... \n"));
-	if((status = gfdbFlush(dev,GT_FLUSH_ALL)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbFlush returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if(testResult == GT_OK)
-		MSG_PRINT(("PASSED with Atu Size %i\n", 256<<atuSize));
-	else
-		MSG_PRINT(("FAILED with Atu Size %i\n", 256<<atuSize));
-
-	return testResult;
-}
-
-GT_U32 testATU(GT_QD_DEV *dev)
-{
-	GT_STATUS testResult, status;
-	GT_U32 testResults = 0;
-	int arg, atuSize, sameMacs, dbNum, atuStart, atuEnd;
-	GT_BOOL dbNumSupport = GT_FALSE;
-
-	testResult = GT_OK;
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6051:
-		case GT_FF_EG:
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_4096;
-			break;
-
-		case GT_88E6021:
-		case GT_88E6060:
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			/* dbNum test is not performed at this time */
-			dbNumSupport = GT_TRUE;
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_256;
-			atuEnd = ATU_SIZE_2048;
-			break;
-
-		case GT_88E6052:
-		case GT_FF_HG:
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_2048;
-			break;
-
-		case GT_88E6063:
-		case GT_FH_VPN:
-		case GT_88E6083:
-			/* dbNum test is not performed at this time */
-			dbNumSupport = GT_TRUE;
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_2048;
-			break;
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			/* dbNum test is not performed at this time */
-			dbNumSupport = GT_TRUE;
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_4096;
-			atuEnd = ATU_SIZE_4096;
-			break;
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			/* dbNum test is not performed at this time */
-			dbNumSupport = GT_TRUE;
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_4096;
-			atuEnd = ATU_SIZE_8192;
-			break;
-		default:
-			MSG_PRINT(("Cannot run ATU test.(Unknown device)\n"));
-			return GT_FAIL;
-	}
-
-	switch (dev->deviceId)
-	{
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-				if(testATUSetup(dev) != GT_OK)
-					return GT_FAIL;
-		default:
-				break;
-	}
-
-	for(arg=0; arg<1; arg++)
-	{
-		for(atuSize=atuStart; atuSize<=atuEnd; atuSize++)
-		{
-			if(dbNumSupport == GT_TRUE)
-			{
-				dbNum = (64<<atuSize)/TEST_MAC_ENTRIES;
-				if (dbNum > 16)
-					dbNum = 16;
-			}
-			else
-				dbNum = 1;
-
-			for(sameMacs=0;sameMacs<=dbNum;sameMacs+=4)
-			{
-				MSG_PRINT(("Running ATU Test : arg %i, macEntries %i, dbNum %i, atuSize %i\n",
-							arg, TEST_MAC_ENTRIES, dbNum, 256 << atuSize));
-				if((status=testAtuDbNum(dev,arg,TEST_MAC_ENTRIES,dbNum,sameMacs,atuSize)) != GT_OK)
-				{
-					MSG_PRINT(("ATU Test Fail(%d), arg %i,dbNum %i,sameMacs %i,atuSize %i\n", 
-								status,arg,dbNum,sameMacs,256<<atuSize));
-					testResult = GT_FAIL;
-					testResults |= 1 << status;
-					break;
-				}
-				else
-				{
-					MSG_PRINT(("ATU Test Pass with arg %i\n", arg));
-				}
-				MSG_PRINT((" \n"));
-			}
-			if (testResult != GT_OK)
-				break;
-		}
-		if (testResult != GT_OK)
-			break;
-	}
-
-#if 0
-	MSG_PRINT(("Exercising Full ATU Table...\n"));
-	for(atuSize=atuStart; atuSize<=atuEnd; atuSize++)
-	{
-		if((status = testFilledATU(dev,atuSize,0)) != GT_OK)
-		{
-			testResults |= 1 << status;
-			testResult = GT_FAIL;
-		}
-		if(dbNumSupport == GT_TRUE)
-		{
-		  if((status = testFilledATU(dev,atuSize,15)) != GT_OK)
-		  {
-			testResults |= 1 << status;
-			testResult = GT_FAIL;
-		  }
-		}
-	}
-#endif
-
-	/* Sw Reset */
-	if((status=gsysSwReset(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSwReset returned Fail (%#x).\n", status));
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	return testResults;
-}
-
-
-GT_STATUS testATUStress(GT_QD_DEV *dev)
-{
-	GT_STATUS testResult, status;
-	int arg, atuSize, sameMacs, dbNum, maxDbNum, atuStart, atuEnd;
-	GT_BOOL dbNumSupport = GT_FALSE;
-
-	testResult = GT_OK;
-	maxDbNum = 16;
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6051:
-		case GT_FF_EG:
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_4096;
-			break;
-
-		case GT_88E6021:
-		case GT_88E6060:
-		case GT_88E6031:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6061:
-		case GT_88E6065:
-			dbNumSupport = GT_TRUE;
-			atuStart = ATU_SIZE_256;
-			atuEnd = ATU_SIZE_2048;
-			break;
-
-		case GT_88E6052:
-		case GT_FF_HG:
-			dbNumSupport = GT_FALSE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_2048;
-			break;
-
-		case GT_88E6063:
-		case GT_FH_VPN:
-		case GT_88E6083:
-			dbNumSupport = GT_TRUE;
-			atuStart = ATU_SIZE_512;
-			atuEnd = ATU_SIZE_2048;
-			break;
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			dbNumSupport = GT_TRUE;
-			atuStart = ATU_SIZE_4096;
-			atuEnd = ATU_SIZE_4096;
-			break;
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-			dbNumSupport = GT_TRUE;
-			maxDbNum = 256;
-			atuStart = ATU_SIZE_4096;
-			atuEnd = ATU_SIZE_4096;
-			break;
-		case GT_88E6131:
-		case GT_88E6108:
-			dbNumSupport = GT_TRUE;
-			maxDbNum = 256;
-			atuStart = ATU_SIZE_1024;
-			atuEnd = ATU_SIZE_1024;
-			break;
-		default:
-			MSG_PRINT(("Cannot run ATU test.(Unknown device)\n"));
-			return GT_FAIL;
-	}
-
-	for(arg=0; arg<3; arg++)
-	{
-		for(atuSize=atuStart; atuSize<=atuEnd; atuSize++)
-		{
-			if(dbNumSupport == GT_TRUE)
-			{
-				if(atuStart == atuEnd)
-				{
-					dbNum = maxDbNum;
-				}
-				else
-				{
-					dbNum = (64<<atuSize)/TEST_MAC_ENTRIES;
-					if (dbNum > maxDbNum)
-						dbNum = maxDbNum;
-				}
-			}
-			else
-				dbNum = 1;
-
-			for(sameMacs=0;sameMacs<=4;sameMacs+=2)
-			{
-				MSG_PRINT(("Running ATU Test: arg %i,macEntries %i,dbNum %i,atuSize %i,sameMac %i\n",
-							arg, TEST_MAC_ENTRIES, dbNum, 256 << atuSize, sameMacs));
-				if((status=testAtuDbNum(dev,arg,TEST_MAC_ENTRIES,dbNum,sameMacs,atuSize)) != GT_OK)
-				{
-					MSG_PRINT(("ATU Test Fail(%d), arg %i,dbNum %i,sameMacs %i,atuSize %i\n", 
-								status,arg,dbNum,sameMacs,256<< atuSize));
-					testResult = GT_FAIL;
-					break;
-				}
-				else
-				{
-					MSG_PRINT(("ATU Test Pass with arg %i\n", arg));
-				}
-				MSG_PRINT((" \n"));
-			}
-			if (testResult != GT_OK)
-				break;
-
-		}
-		if (testResult != GT_OK)
-			break;
-	}
-
-	MSG_PRINT(("Exercising Full ATU Table...\n"));
-	for(atuSize=atuStart; atuSize<=atuEnd; atuSize++)
-	{
-		if((status = testFilledATU(dev,atuSize,0)) != GT_OK)
-			testResult = GT_FAIL;
-		if((status = testFilledATU(dev,atuSize,maxDbNum-1)) != GT_OK)
-			testResult = GT_FAIL;
-	}
-
-	/* Sw Reset */
-	if((status=gsysSwReset(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSwReset returned Fail (%#x).\n", status));
-		return status;
-	}
-
-	return testResult;
-}
-
-
-/*******************************************************************************
-* testVlan
-*
-* DESCRIPTION:
-*       Testing Vlan related APIs. (Set/Get)
-*		(EgressMode, VlanTunnel, PortVlanPorts, PortUserPriLsb, and PortVid access)
-*		
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on fail
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-GT_U32 testVlan(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, mapTest;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-	GT_LPORT port;
-	GT_LPORT portList[MAX_SWITCH_PORTS];
-	GT_LPORT tmpPortList[MAX_SWITCH_PORTS];
-	GT_LPORT orgPortList[MAX_SWITCH_PORTS];
-	GT_U8 i, portCount, orgCount, tmpCount;
-	int portIndex;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Egress Mode
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gprtGetEgressMode;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gprtSetEgressMode;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Egress Mode API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Vlan Tunnel
-	 */
-	testAPI.getFunc.port_bool = gprtGetVlanTunnel;
-	testAPI.setFunc.port_bool = gprtSetVlanTunnel;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Vlan Tunnel API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  user priority (VPT) LSB bit
-	 */
-	testAPI.getFunc.port_bool = gvlnGetPortUserPriLsb;
-	testAPI.setFunc.port_bool = gvlnSetPortUserPriLsb;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("user priority (VPT) LSB bit API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Port VID
-	 */
-	testAPI.getFunc.port_u16 = gvlnGetPortVid;
-	testAPI.setFunc.port_u16 = gvlnSetPortVid;
-	if((status = testPortU16Type(dev,&testAPI,7)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Port VID API test "));
-	testDisplayStatus(status);
-
-	/* Port Vlan Mapping */
-	mapTest = GT_OK;
-
-	portCount = (4 < (dev->numOfPorts-1))?4:(dev->numOfPorts-1);
-
-	for(portIndex=0; portIndex<portCount; portIndex++)
-		portList[portIndex] = portIndex;
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		if((status = gvlnGetPortVlanPorts(dev,port,orgPortList,&orgCount)) != GT_OK)
-		{
-			MSG_PRINT(("gvlnGetPortVlanPorts returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gvlnSetPortVlanPorts(dev,port,portList,portCount)) != GT_OK)
-		{
-			MSG_PRINT(("gvlnSetPortVlanPorts returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gvlnGetPortVlanPorts(dev,port,tmpPortList,&tmpCount)) != GT_OK)
-		{
-			MSG_PRINT(("gvlnGetPortVlanPorts returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if (portCount != tmpCount)
-		{
-			MSG_PRINT(("gvlnGetPortVlanPorts returned wrong portCount(%i:%i).\n",portCount,tmpCount));
-			mapTest = GT_FAIL;
-			testResults |= 1 << mapTest;
-		}
-		
-		for(i=0; i<portCount; i++)
-		{
-			if(tmpPortList[i] != portList[i])
-			{
-				MSG_PRINT(("Returned wrong portList(i %d, port %d, should be port %d).\n"
-							,i,tmpPortList[i],portList[i]));
-				mapTest = GT_FAIL;
-				testResults |= 1 << mapTest;
-			}
-		}
-
-		if((status = gvlnSetPortVlanPorts(dev,port,orgPortList,orgCount)) != GT_OK)
-		{
-			MSG_PRINT(("gvlnSetPortVlanPorts returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	}
-	if(mapTest != GT_OK)
-	{
-		MSG_PRINT(("VLAN MAP API Test Fail.\n"));
-		testResult = mapTest;
-	}
-	else
-		MSG_PRINT(("VLAN MAP API Test Pass.\n"));
-
-#ifdef DEBUG_FEATURE 
-	/*
-	 *  Port DBNum
-	 */
-	testAPI.getFunc.port_u8 = gvlnGetPortVlanDBNum;
-	testAPI.setFunc.port_u8 = gvlnSetPortVlanDBNum;
-	if((status = testPortU8Type(dev,&testAPI,16)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Port DBNum API test "));
-	testDisplayStatus(status);
-#endif
-
-	/*
-	 *  Port Vlan 802.1Q Mode
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gvlnGetPortVlanDot1qMode;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gvlnSetPortVlanDot1qMode;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Port 802.1Q Mode API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Force Default VID
-	 */
-	testAPI.getFunc.port_bool = gvlnGetPortVlanForceDefaultVID;
-	testAPI.setFunc.port_bool = gvlnSetPortVlanForceDefaultVID;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Force Default VID API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Force MAP
-	 */
-	testAPI.getFunc.port_bool = gvlnGetForceMap;
-	testAPI.setFunc.port_bool = gvlnSetForceMap;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Force MAP API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-
-}
-
-/*******************************************************************************
-* testSTP
-*
-* DESCRIPTION:
-*       Test STP(Spanning Tree Protocol) related APIs
-*		
-* RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on fail
-*
-* COMMENTS:
-*       None.
-*
-*******************************************************************************/
-GT_U32 testSTP(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, sectionResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = sectionResult = GT_OK;
-
-	/*
-	 *	STP Port State
-	 */
-	testAPI.getFunc.port_u32 = (GT_API_GET_PORT_U32)gstpGetPortState;
-	testAPI.setFunc.port_u32 = (GT_API_SET_PORT_U32)gstpSetPortState;
-	if((status = testPortU32Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("STP Port State API test "));
-	testDisplayStatus(status);
-
-	return testResults;
-}
-
-
-GT_U32 testPhy1(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	GT_LPORT port;
-	GT_U16 u16Data, tmpData;
-	GT_PHY_AUTO_MODE mode;
-	int portIndex, nPhys;
-
-	testResult = GT_OK;
-	switch(dev->numOfPorts)
-	{
-		case 3:
-			nPhys = 2;
-			break;
-		default:
-			nPhys = 5;
-			break;
-	}
-
-	for(portIndex=0; portIndex<nPhys; portIndex++)
-	{
-		port = portIndex;
-		
-		if(port == dev->cpuPortNum)
-			continue;
-
-		/* Test Reset API */
-		MSG_PRINT(("Reset Phy (port %i).\n",port));
-		if((status = gprtPhyReset(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyReset returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u16Data & 0x1000))
-		{
-			MSG_PRINT(("gprtPhyReset failed.\n"));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Reset, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-
-
-		/* 
-		 *  Set AutoNego disable, LoopBack enable, 100Mbps, Duplex On,
-		 */
-		if((status = gprtPortAutoNegEnable(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortAutoNegEnable returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortLoopback(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortLoopback returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortSpeed(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortSpeed returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortDuplexMode(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortDuplexMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(0x6100 != (u16Data & 0x6100))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x6100).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-		{
-			if(u16Data & 0x1000)
-			{
-				MSG_PRINT(("Set Failed (%#x, should be 0x6100).\n", u16Data));
-				testResults |= 1 << GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			else
-				MSG_PRINT(("After Loopback and 100Full, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-		}
-
-		/* 
-		 *  Set 10Mbps, Half Duplex.
-		 */
-		if((status = gprtSetPortLoopback(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortLoopback returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortSpeed(dev,port,PHY_SPEED_10_MBPS)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortSpeed returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortDuplexMode(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortDuplexMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(u16Data != 0x0000)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0000).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After 10Half, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-
-		/* 
-		 *  Set Power Down
-		 */
-		if((status = gprtPortPowerDown(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortPowerDown returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* Power Down bit should be set. */
-		if(!(u16Data & 0x0800))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0800).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After PowerDown, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-
-		/* 
-		 *  Set Power Up
-		 */
-		if((status = gprtPortPowerDown(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortPowerDown returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After power up, Power Down bit should be cleared.*/
-		if(u16Data &= 0x0800)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0000).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Power back up, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-
-		/* 
-		 *  Set Autonego and Restart AutoNego.
-		 */
-		if((status = gprtPortAutoNegEnable(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortAutoNegEnable returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtPortRestartAutoNeg(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortRestartAutoNeg returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u16Data & 0x1000))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x1000).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Auto, Phy (port %i) Reg 0 : %#x.\n",port,u16Data));
-
-
-		/*
-		 *	Enable PAUSE
-		*/
-		if((status = gprtSetPause(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,4,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u16Data & 0x400))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x400).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Pause set, Phy (port %i) Reg 4 : %#x.\n",port,u16Data));
-
-		/*
-		 *	Disable PAUSE
-		*/
-		if((status = gprtSetPause(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gprtGetPhyReg(dev,port,4,&u16Data) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(u16Data & 0x400)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x00).\n", u16Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Pause reset, Phy (port %i) Reg 4 : %#x.\n",port,u16Data));
-
-		/*
-		 *	Disable PAUSE
-		*/
-		for(mode=SPEED_AUTO_DUPLEX_AUTO;mode<=SPEED_AUTO_DUPLEX_HALF;mode++)
-		{
-			switch(mode)
-			{
-				case SPEED_1000_DUPLEX_AUTO:
-				case SPEED_1000_DUPLEX_FULL:
-				case SPEED_1000_DUPLEX_HALF:
-						continue;
-				default:
-						break;
-			}
-
-			if((status = gprtSetPortAutoMode(dev,port,mode)) != GT_OK)
-			{
-				MSG_PRINT(("gprtSetPortAutoMode returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			/* Autonego should be enabled. */
-	    	if(gprtGetPhyReg(dev,port,0,&u16Data) != GT_OK)
-			{
-				MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-				testResults |= 1 << GT_FAIL;
-				return testResults;
-			}
-
-			/* After reset AutoNego should be enabled. */
-			if(!(u16Data & 0x1000))
-			{
-				MSG_PRINT(("Set Failed (%#x, should be 0x1000).\n", u16Data));
-				testResults |= 1 << GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			else
-			{
-		    	if(gprtGetPhyReg(dev,port,4,&u16Data) != GT_OK)
-				{
-					MSG_PRINT(("gprtGetPhyReg returned Fail.\n"));
-					testResults |= 1 << GT_FAIL;
-					return testResults;
-				}
-
-				switch(mode)
-				{
-					case SPEED_AUTO_DUPLEX_AUTO:
-							tmpData = 0x1e0;
-							break;
-					case SPEED_100_DUPLEX_AUTO:
-							tmpData = 0x180;
-							break;
-					case SPEED_10_DUPLEX_AUTO:
-							tmpData = 0x060;
-							break;
-					case SPEED_AUTO_DUPLEX_FULL:
-							tmpData = 0x140;
-							break;
-					case SPEED_AUTO_DUPLEX_HALF:
-							tmpData = 0x0a0;
-							break;
-					default:
-							tmpData = 0;
-							break;
-				}
-
-				if((u16Data & 0x1e0) != tmpData)
-				{
-					MSG_PRINT(("Set AutoMode(%i) Failed (%#x, should be %#x).\n", mode,u16Data,tmpData));
-					testResult = GT_FAIL;
-					testResults |= 1 << GT_FAIL;
-				}
-				else
-					MSG_PRINT(("After Mode(%d) set, Phy (port %i) Reg 4 : %#x.\n",mode,port,u16Data));
-
-			}
-		}
-
-
-	}
-	return testResults;
-}
-
-GT_U32 testPhy2(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	GT_LPORT port;
-	GT_U32 u32Data, tmpData;
-	GT_PHY_AUTO_MODE mode;
-	int portIndex, nPhys;
-
-	testResult = GT_OK;
-	switch(dev->numOfPorts)
-	{
-		case 3:
-			nPhys = 2;
-			break;
-		default:
-			nPhys = 5;
-			break;
-	}
-
-	for(portIndex=0; portIndex<nPhys; portIndex++)
-	{
-		port = portIndex;
-		
-		if(port == dev->cpuPortNum)
-			continue;
-
-		/* Test Reset API */
-		MSG_PRINT(("Reset Phy (port %i).\n",port));
-		if((status = gprtPhyReset(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyReset returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev, dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u32Data & 0x1000))
-		{
-			MSG_PRINT(("gprtPhyReset failed.\n"));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Reset, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-
-
-		/* 
-		 *  Set AutoNego disable, LoopBack enable, 100Mbps, Duplex On,
-		 */
-		if((status = gprtPortAutoNegEnable(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortAutoNegEnable returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortLoopback(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortLoopback returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortSpeed(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortSpeed returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortDuplexMode(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortDuplexMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev, dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(0x6100 != (u32Data & 0x6100))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x6100).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-		{
-			if(u32Data & 0x1000)
-			{
-				MSG_PRINT(("Set Failed (%#x, should be 0x6100).\n", u32Data));
-				testResults |= 1 << GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			else
-				MSG_PRINT(("After Loopback and 100Full, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-		}
-
-		/* 
-		 *  Set 10Mbps, Half Duplex.
-		 */
-		if((status = gprtSetPortLoopback(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortLoopback returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortSpeed(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortSpeed returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtSetPortDuplexMode(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortDuplexMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(u32Data != 0x0000)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0000).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After 10Half, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-
-		/* 
-		 *  Set Power Down
-		 */
-		if((status = gprtPortPowerDown(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortPowerDown returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* Power Down bit should be set. */
-		if(!(u32Data & 0x0800))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0800).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After PowerDown, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-
-		/* 
-		 *  Set Power Up
-		 */
-		if((status = gprtPortPowerDown(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortPowerDown returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After power up, Power Down bit should be cleared.*/
-		if(u32Data &= 0x0800)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x0000).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Power back up, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-
-		/* 
-		 *  Set Autonego and Restart AutoNego.
-		 */
-		if((status = gprtPortAutoNegEnable(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortAutoNegEnable returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gprtPortRestartAutoNeg(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPortRestartAutoNeg returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u32Data & 0x1000))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x1000).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Auto, Phy (port %i) Reg 0 : %#x.\n",port,u32Data));
-
-
-		/*
-		 *	Enable PAUSE
-		*/
-		if((status = gprtSetPause(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,4,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(!(u32Data & 0x400))
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x400).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Pause set, Phy (port %i) Reg 4 : %#x.\n",port,u32Data));
-
-		/*
-		 *	Disable PAUSE
-		*/
-		if((status = gprtSetPause(dev,port,GT_FALSE)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-	    if(gsysReadMiiReg(dev,dev->baseRegAddr+port,4,&u32Data) != GT_OK)
-		{
-			MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-			testResults |= 1 << GT_FAIL;
-			return testResults;
-		}
-
-		/* After reset AutoNego should be enabled. */
-		if(u32Data & 0x400)
-		{
-			MSG_PRINT(("Set Failed (%#x, should be 0x00).\n", u32Data));
-			testResults |= 1 << GT_FAIL;
-			testResult = GT_FAIL;
-		}
-		else
-			MSG_PRINT(("After Pause reset, Phy (port %i) Reg 4 : %#x.\n",port,u32Data));
-
-		/*
-		 *	Disable PAUSE
-		*/
-		for(mode=SPEED_AUTO_DUPLEX_AUTO;mode<=SPEED_AUTO_DUPLEX_HALF;mode++)
-		{
-			if((status = gprtSetPortAutoMode(dev,port,mode)) != GT_OK)
-			{
-				MSG_PRINT(("gprtSetPortAutoMode returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			/* Autonego should be enabled. */
-	    	if(gsysReadMiiReg(dev,dev->baseRegAddr+port,0,&u32Data) != GT_OK)
-			{
-				MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-				testResults |= 1 << GT_FAIL;
-				return testResults;
-			}
-
-			/* After reset AutoNego should be enabled. */
-			if(!(u32Data & 0x1000))
-			{
-				MSG_PRINT(("Set Failed (%#x, should be 0x1000).\n", u32Data));
-				testResults |= 1 << GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			else
-			{
-		    	if(gsysReadMiiReg(dev,dev->baseRegAddr+port,4,&u32Data) != GT_OK)
-				{
-					MSG_PRINT(("gsysReadMiiReg returned Fail.\n"));
-					testResults |= 1 << GT_FAIL;
-					return testResults;
-				}
-
-				switch(mode)
-				{
-					case SPEED_AUTO_DUPLEX_AUTO:
-							tmpData = 0x1e0;
-							break;
-					case SPEED_100_DUPLEX_AUTO:
-							tmpData = 0x180;
-							break;
-					case SPEED_10_DUPLEX_AUTO:
-							tmpData = 0x060;
-							break;
-					case SPEED_AUTO_DUPLEX_FULL:
-							tmpData = 0x140;
-							break;
-					case SPEED_AUTO_DUPLEX_HALF:
-							tmpData = 0x0a0;
-							break;
-					default:
-							tmpData = 0;
-							break;
-				}
-
-				if((u32Data & 0x1e0) != tmpData)
-				{
-					MSG_PRINT(("Set AutoMode(%i) Failed (%#x, should be %#x).\n", mode,u32Data,tmpData));
-					testResult = GT_FAIL;
-					testResults |= 1 << GT_FAIL;
-				}
-				else
-					MSG_PRINT(("After Mode(%d) set, Phy (port %i) Reg 4 : %#x.\n",mode,port,u32Data));
-
-			}
-		}
-
-
-	}
-	return testResults;
-}
-
-GT_U32 testPhy(GT_QD_DEV *dev)
-{
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			MSG_PRINT(("Not Implemented.\n"));
-			break;
-		default:
-			return testPhy1(dev);	
-	}
-	return 0;
-}
-
-GT_STATUS readStatistics(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_LPORT port;
-	GT_PORT_STAT portStat;
-
-	MSG_PRINT(("Current Port Statistics\n"));
-	for (port=0; port<dev->numOfPorts; port++)
-	{
-		if((status = gprtGetPortCtr(dev,port,&portStat)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPortCtr returned fail.\n"));
-			return status;
-		}
-
-		MSG_PRINT(("Port %i : Rx %i, Tx %i.\n",port,portStat.rxCtr,portStat.txCtr));
-	}
-
-	MSG_PRINT(("After Clear Port Statistics\n"));
-	for (port=0; port<dev->numOfPorts; port++)
-	{
-		if((status = gprtClearAllCtr(dev)) != GT_OK)
-		{
-			MSG_PRINT(("gprtClearAllCtr returned fail.\n"));
-			return status;
-		}
-
-		if((status = gprtGetPortCtr(dev,port,&portStat)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPortCtr returned fail.\n"));
-			return status;
-		}
-
-		MSG_PRINT(("Port %i : Rx %i, Tx %i.\n",port,portStat.rxCtr,portStat.txCtr));
-	}
-	return GT_OK;
-}
-
-GT_STATUS testGoodPkt(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-
-	if((status = gprtSetCtrMode(dev,GT_CTR_ALL)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetCtrMode returned fail.\n"));
-		return status;
-	}
-	return GT_OK;
-}
-
-GT_STATUS testBadPkt(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-
-	if((status = gprtSetCtrMode(dev,GT_CTR_ERRORS)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetCtrMode returned fail.\n"));
-		return status;
-	}
-	return GT_OK;
-}
-
-
-GT_U32 testPortStatus(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	GT_LPORT port;
-	GT_BOOL mode;
-	GT_U32	u32Mode;
-	GT_U16	u16Mode;
-	int portIndex;
-
-	testResult = GT_OK;
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-		
-		MSG_PRINT(("Port %i :\n",port));
-
-		if((status = gprtGetPartnerLinkPause(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPartnerLinkPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("His Link Pause : %i    ",(int)mode));
-
-		if((status = gprtGetSelfLinkPause(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetSelfLinkPause returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("My Link Pause  : %i\n",(int)mode));
-
-		if((status = gprtGetLinkState(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetLinkState returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Link Status    : %i    ",(int)mode));
-
-		if((status = gprtGetResolve(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetResolve returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Resolve        : %i\n",(int)mode));
-
-		if((status = gprtGetPortMode(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPortMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Port Mode      : %i    ",(int)mode));
-
-		if((status = gprtGetPhyMode(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPhyMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Phy Mode       : %i\n",(int)mode));
-
-		if((status = gprtGetSpeed(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetSpeed returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Port Speed     : %i    ",(int)mode));
-
-		if((status = gprtGetDuplex(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetDuplex returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Port Duplex    : %i\n",(int)mode));
-
-		MSG_PRINT(("Setting Port Duplex : %i\n",1-(int)mode));
-		if((status = gprtSetDuplex(dev,port,1-mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetDuplex returned "));
-			testDisplayStatus(status);
-			switch(dev->deviceId)
-			{
-				case GT_88E6021:
-					if(port != dev->cpuPortNum)
-						break;
-					else
-					{
-						testResults |= 1 << status;
-						if(status == GT_FAIL)
-						return testResults;
-					}
-				case GT_88E6051:
-				case GT_88E6052:
-				case GT_FF_HG:
-				case GT_FF_EG:
-					break;
-				case GT_88E6063:
-				case GT_FH_VPN:
-					if(port < 5)
-						break;
-					else
-					{
-						testResults |= 1 << status;
-						if(status == GT_FAIL)
-						return testResults;
-					}
-					break;
-				default:
-					break;
-			}
-
-		}
-		else
-		{
-			GT_BOOL tmpMode;
-			if((status = gprtGetDuplex(dev,port,&tmpMode)) != GT_OK)
-			{
-				MSG_PRINT(("gprtGetDuplex returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-			if(tmpMode != (1-mode))
-			{
-				MSG_PRINT(("Setting Port Duplex Failed (current mode %i)\n",tmpMode));
-				testResults |= 1 << GT_FAIL;
-				testResult = GT_FAIL;
-			}
-			else
-				MSG_PRINT(("Setting Port Duplex Passed.\n"));
-
-			MSG_PRINT(("Setting Port Duplex : %i\n",mode));
-			if((status = gprtSetDuplex(dev,port,mode)) != GT_OK)
-			{
-				MSG_PRINT(("gprtSetDuplex returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				if(status == GT_FAIL)
-					return testResults;
-			}
-
-			if((status = gprtGetDuplex(dev,port,&tmpMode)) != GT_OK)
-			{
-				MSG_PRINT(("gprtGetDuplex returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-			if(tmpMode != mode)
-			{
-				MSG_PRINT(("Setting Port Duplex Failed (current mode %i)\n",tmpMode));
-				testResult = GT_FAIL;
-				testResults |= 1 << GT_FAIL;
-			}
-			else
-				MSG_PRINT(("Setting Port Duplex Passed.\n"));
-
-		}
-
-		if((status = gprtGetTxPaused(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetTxPaused returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("TxPaused       : %i    ",(int)mode));
-
-		if((status = gprtGetFlowCtrl(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetFlowCtrl returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("FlowCtrl       : %i\n",(int)mode));
-
-		if((status = gprtGetPxMode(dev,port,&u32Mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetPxMode returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("PxMode         : %i    ",(int)u32Mode));
-
-		if((status = gprtGetMiiInterface(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetMiiInterface returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Mii Interface  : %i\n",(int)mode));
-
-		if((status = gprtGetHdFlowDis(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetHdFlowDis returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("HD Flow Dis.   : %i    ",(int)mode));
-
-		if((status = gprtGetFdFlowDis(dev,port,&mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetFdFlowDis returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("FD Flow Dis.   : %i\n",(int)mode));
-
-		if((status = gprtGetOutQSize(dev,port,&u16Mode)) != GT_OK)
-		{
-			MSG_PRINT(("gprtGetOutQSize returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-		MSG_PRINT(("Out Q Size     : %i\n",(int)u16Mode));
-
-	}
-
-	return testResults;
-}
-
-GT_U32 testQoSRule(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	TEST_API testAPI;
-
-	testResult = GT_OK;
-
-	/*
-	 *  Priority Map Rule (IEEE if Both IEEE and IP)
-	 */
-	testAPI.getFunc.port_bool = gqosGetPrioMapRule;
-	testAPI.setFunc.port_bool = gqosSetPrioMapRule;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Priority Map Rule API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  IP Priority Map Rule (use IP)
-	 */
-	testAPI.getFunc.port_bool = gqosGetIpPrioMapEn;
-	testAPI.setFunc.port_bool = gqosIpPrioMapEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IP Priority Map Rule API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  IEEE Priority Map Rule (use IEEE Tag)
-	 */
-	testAPI.getFunc.port_bool = gqosGetUserPrioMapEn;
-	testAPI.setFunc.port_bool = gqosUserPrioMapEn;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("IEEE Priority Map Rule API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  VID FPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetVIDFPriOverride;
-	testAPI.setFunc.port_bool = gqosSetVIDFPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("VID FPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA FPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetSAFPriOverride;
-	testAPI.setFunc.port_bool = gqosSetSAFPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA FPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DA FPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetDAFPriOverride;
-	testAPI.setFunc.port_bool = gqosSetDAFPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DA FPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  VID QPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetVIDQPriOverride;
-	testAPI.setFunc.port_bool = gqosSetVIDQPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("VID QPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  SA QPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetSAQPriOverride;
-	testAPI.setFunc.port_bool = gqosSetSAQPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("SA QPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  DA QPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetDAQPriOverride;
-	testAPI.setFunc.port_bool = gqosSetDAQPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("DA QPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  ARP QPri Override
-	 */
-	testAPI.getFunc.port_bool = gqosGetARPQPriOverride;
-	testAPI.setFunc.port_bool = gqosSetARPQPriOverride;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ARP QPri Override API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Force QPri
-	 */
-	testAPI.getFunc.port_bool = gqosGetForceQPri;
-	testAPI.setFunc.port_bool = gqosSetForceQPri;
-	if((status = testPortBoolType(dev,&testAPI)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Force QPri API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  QPri Value
-	 */
-	testAPI.getFunc.port_u8 = gqosGetQPriValue;
-	testAPI.setFunc.port_u8 = gqosSetQPriValue;
-	if((status = testPortU8Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("QPri Value API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  Default FPri Value
-	 */
-	testAPI.getFunc.port_u8 = gqosGetDefFPri;
-	testAPI.setFunc.port_u8 = gqosSetDefFPri;
-	if((status = testPortU8Type(dev,&testAPI,8)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Default FPri Value API test "));
-	testDisplayStatus(status);
-
-	/*
-	 *  ARP QPri Value
-	 */
-	testAPI.getFunc.u16 = (GT_API_GET_U16)gqosGetArpQPri;
-	testAPI.setFunc.u16 = (GT_API_SET_U16)gqosSetArpQPri;
-	if((status = testU16Type(dev,&testAPI,4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("ARP QPri Value API test "));
-	testDisplayStatus(status);
-
-
-	return testResults;
-}
-
-GT_U32 testQoSMapG(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, sectionResult;
-	GT_U32 testResults = 0;
-	GT_U8 priority, remapped, tmpPri;
-	GT_LPORT port;
-	int portIndex;
-
-	testResult = sectionResult = GT_OK;
-
-	for(priority=0; priority<8; priority++)
-	{
-		remapped = 7 - priority;
-
-		for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-		{
-			port = portIndex;
-					
-			if((status = gqosSetTagRemap(dev,portIndex, priority, remapped)) != GT_OK)
-			{
-				MSG_PRINT(("gqosSetTagRemap returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			tmpPri = 8;
-			if((status = gqosGetTagRemap(dev,portIndex, priority, &tmpPri)) != GT_OK)
-			{
-				MSG_PRINT(("gqosGetTagRemap returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			if (tmpPri != remapped)
-			{
-				MSG_PRINT(("QoS Remapping setup problem (pri:%#x,remap:%#x,port).\n",priority, remapped, port));
-				sectionResult = GT_FAIL;
-				testResults |= 1 << GT_FAIL;
-			}
-		}
-	}
-
-	if(sectionResult == GT_OK)
-	{
-		MSG_PRINT(("QoS Remapping setup Pass.\n"));
-	}
-	else
-	{
-		MSG_PRINT(("Qos Remapping setup Fail.\n"));
-		testResult = sectionResult;
-		sectionResult = GT_OK;
-	}
-
-	return testResults;
-}
-
-GT_U32 testQoSMap(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, sectionResult;
-	GT_U32 testResults = 0;
-	GT_U8 priority, trClass;
-	TEST_API testAPI;
-
-	testResult = sectionResult = GT_OK;
-
-	/*
-	 *  Default Traffic Class Map
-	 */
-	testAPI.getFunc.port_u8 = gcosGetPortDefaultTc;
-	testAPI.setFunc.port_u8 = gcosSetPortDefaultTc;
-	if((status = testPortU8Type(dev,&testAPI, 4)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Default Traffic Class Setup "));
-	testDisplayStatus(status);
-
-	for(priority=0; priority<8; priority++)
-	{
-		if((status = gcosSetUserPrio2Tc(dev,priority,(priority&0x3))) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetUserPrio2Tc returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gcosGetUserPrio2Tc(dev,priority,&trClass)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetUserPrio2Tc returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if (trClass != (priority&0x3))
-		{
-			MSG_PRINT(("IEEE traffic Class setup problem (tr:%#x,pr:%#x).\n",trClass,priority));
-			sectionResult = GT_FAIL;
-			testResults |= 1 << GT_FAIL;
-		}
-	}
-
-	if(sectionResult == GT_OK)
-	{
-		MSG_PRINT(("IEEE traffic Class setup Pass.\n"));
-	}
-	else
-	{
-		MSG_PRINT(("IEEE traffic Class setup Fail.\n"));
-		testResult = sectionResult;
-		sectionResult = GT_OK;
-	}
-
-	for(priority=0; priority<0x40; priority++)
-	{
-		if((status = gcosSetDscp2Tc(dev,priority,(priority&0x3))) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gcosGetDscp2Tc(dev,priority,&trClass)) != GT_OK)
-		{
-			MSG_PRINT(("gcosGetDscp2Tc returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if (trClass != (priority&0x3))
-		{
-			MSG_PRINT(("IP traffic Class setup problem (tr:%#x,pr:%#x).\n",trClass,priority));
-			sectionResult = GT_FAIL;
-			testResults |= 1 << GT_FAIL;
-		}
-	}
-	if(sectionResult == GT_OK)
-	{
-		MSG_PRINT(("IP traffic Class setup Pass.\n"));
-	}
-	else
-	{
-		MSG_PRINT(("IP traffic Class setup Fail.\n"));
-		testResult = sectionResult;
-		sectionResult = GT_OK;
-	}
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6065:
-			testResults |= testQoSMapG(dev);
-			break;
-		default:
-			break;
-	}			
-	return testResults;
-}
-
-
-GT_U32 testInterrupt(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult;
-	GT_U32 testResults = 0;
-	GT_LPORT port;
-	GT_U16 data, portIntCause, phyIntCause, tmpData;
-	int portIndex, phyCount;
-
-	MSG_PRINT(("\ntesting Interrupt Handler : \n"));
-
-	testResult = GT_OK;
-
-	MSG_PRINT(("\nSetting up Interrupt Test...\n"));
-
-	/* Enable QuarterDeck interrupt for ATUFull, ATUDone, PHYInt, and EEInt */
-	data = GT_ATU_FULL|GT_ATU_DONE|GT_PHY_INTERRUPT|GT_EE_INTERRUPT;
-	if((status = eventSetActive(dev,data)) != GT_OK)
-	{
-		MSG_PRINT(("eventSetActive returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	/* 
-	 Enable Phy interrupt for Link Status Change, Speed Change,
-	 *	AutoNego Complete, and Duplex Changed for all phys.
-	*/
-	data = GT_SPEED_CHANGED|GT_DUPLEX_CHANGED|GT_AUTO_NEG_COMPLETED|GT_LINK_STATUS_CHANGED;
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6021:
-			phyCount = 2;
-			break;
-		case GT_88E6051:
-			phyCount = 4;
-			break;
-		case GT_88E6052:
-		case GT_88E6063:
-		case GT_FF_HG:
-		case GT_FF_EG:
-		case GT_FH_VPN:
-			phyCount = 5;
-			break;
-		default:
-			MSG_PRINT(("Unknown DEVICE. Assuming 88E6052.\n"));
-			phyCount = 5;
-			break;
-	}
-
-	for(portIndex=0; portIndex<phyCount; portIndex++)
-	{
-		port = portIndex;
-
-		if((status = gprtPhyIntEnable(dev,port,data)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyIntEnable returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-	}
-
-	/* Set QuarterDeck interrupt ATUFull, PHYInt, and EEInt */
-	portIntCause = GT_ATU_FULL|GT_PHY_INTERRUPT|GT_EE_INTERRUPT;
-	if(qdSimSetGlobalInt(portIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	/* 
-	 * 	Set PHY Interrupt Link Status Change, Speed Change, and AutoNego
-	 * 	Complete for Port 0 and Port 4.
-	*/
-	phyIntCause = GT_SPEED_CHANGED|GT_AUTO_NEG_COMPLETED|GT_LINK_STATUS_CHANGED;
-	if(qdSimSetPhyInt(0,phyIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	if(qdSimSetPhyInt(4,phyIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	MSG_PRINT(("Calling QD Interrupt Handler with portInt %#x, phyInt %#x\n",portIntCause,phyIntCause));
-
-	/*
-	 *	Call QuarterDeck Interrupt Handler.
-	*/
-	if(eventGetIntStatus(dev,&tmpData) != GT_TRUE)
-	{
-		MSG_PRINT(("qdIntHander returned GT_FALSE.\n"));
-		testResults |= 1 << GT_FAIL;
-		return testResults;
-	}
-
-	if(tmpData != portIntCause)
-	{
-		MSG_PRINT(("qdIntHander returned wrong intCause(%#x).\n",tmpData));
-		testResults |= 1 << GT_FAIL;
-		testResult = GT_FAIL;
-	}
-	else
-		MSG_PRINT(("QD Interrupt Handler returned intCause(%#x).\n",tmpData));
-
-
-	/*
-	 *	Call gprtGetPhyIntPortSummary to get Port Int Summary
-	*/
-	if((status = gprtGetPhyIntPortSummary(dev,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntPortSummary returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != 0x11)	/* port 0 and port 4 should be set. */
-	{
-		MSG_PRINT(("gprtGetPhyIntPortSummary returned wrong summary(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("Port Summary returned %#x.\n",tmpData));
-
-	/*
-	 *	Call gprtGetPhyIntStatus to get intCause
-	*/
-	if((status = gprtGetPhyIntStatus(dev,0,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != phyIntCause)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned wrong phyIntCause(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("PHY Int Status(port 0) returned %#x.\n",tmpData));
-		
-	/*
-	 *	Call gprtGetPhyIntStatus to get intCause
-	*/
-	if((status = gprtGetPhyIntStatus(dev,4,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != phyIntCause)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned wrong phyIntCause(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("PHY Int Status(port 4) returned %#x.\n",tmpData));
-
-	/* Set QuarterDeck interrupt ATUFull, PHYInt, and EEInt */
-	portIntCause = GT_PHY_INTERRUPT;
-	if(qdSimSetGlobalInt(portIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	/* 
-	 * 	Set PHY Interrupt Link Status Change, Speed Change, and AutoNego
-	 * 	Complete for Port 0 and Port 4.
-	*/
-	phyIntCause = GT_SPEED_CHANGED|GT_DUPLEX_CHANGED;
-	if(qdSimSetPhyInt(0,phyIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	if(qdSimSetPhyInt(3,phyIntCause) != GT_OK)
-	{
-		MSG_PRINT(("QD Simulator is not used.\n"));
-		testResults |= 1 << GT_NOT_SUPPORTED;
-		return testResults;
-	}
-
-	MSG_PRINT(("\nCalling QD Interrupt Handler with portInt %#x, phyInt %#x\n",portIntCause,phyIntCause));
-
-	/*
-	 *	Call QuarterDeck Interrupt Handler.
-	*/
-	if(eventGetIntStatus(dev,&tmpData) != GT_TRUE)
-	{
-		MSG_PRINT(("qdIntHander returned GT_FALSE.\n"));
-		testResults |= 1 << GT_FAIL;
-		return testResults;
-	}
-
-	if(tmpData != portIntCause)
-	{
-		MSG_PRINT(("qdIntHander returned wrong intCause(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("QD Interrupt Handler returned intCause(%#x).\n",tmpData));
-
-
-	/*
-	 *	Call gprtGetPhyIntPortSummary to get Port Int Summary
-	*/
-	if((status = gprtGetPhyIntPortSummary(dev,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntPortSummary returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != 0x9)	/* port 0 and port 3 should be set. */
-	{
-		MSG_PRINT(("gprtGetPhyIntPortSummary returned wrong summary(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("Port Summary returned %#x.\n",tmpData));
-
-	/*
-	 *	Call gprtGetPhyIntStatus to get intCause
-	*/
-	if((status = gprtGetPhyIntStatus(dev,0,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != phyIntCause)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned wrong phyIntCause(%#x).\n",tmpData));
-		testResults |= 1 << GT_FAIL;
-		testResult = GT_FAIL;
-	}
-	else
-		MSG_PRINT(("PHY Int Status(port 0) returned %#x.\n",tmpData));
-	
-	/*
-	 *	Call gprtGetPhyIntStatus to get intCause
-	*/
-	if((status = gprtGetPhyIntStatus(dev,3,&tmpData)) != GT_OK)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	if(tmpData != phyIntCause)
-	{
-		MSG_PRINT(("gprtGetPhyIntStatus returned wrong phyIntCause(%#x).\n",tmpData));
-		testResult = GT_FAIL;
-		testResults |= 1 << GT_FAIL;
-	}
-	else
-		MSG_PRINT(("PHY Int Status(port 3) returned %#x.\n",tmpData));
-
-	return testResults;
-}
-
-void testDisplayCounter(GT_STATS_COUNTER_SET *statsCounter)
-{
-	MSG_PRINT(("InUnicasts    %08i    ", statsCounter->InUnicasts));
-	MSG_PRINT(("InBroadcasts  %08i   \n", statsCounter->InBroadcasts));
-	MSG_PRINT(("InPause       %08i    ", statsCounter->InPause));
-	MSG_PRINT(("InMulticasts  %08i   \n", statsCounter->InMulticasts));
-	MSG_PRINT(("InFCSErr      %08i    ", statsCounter->InFCSErr));
-	MSG_PRINT(("AlignErr      %08i   \n", statsCounter->AlignErr));
-	MSG_PRINT(("InGoodOctets  %08i    ", statsCounter->InGoodOctets));
-	MSG_PRINT(("InBadOctets   %08i   \n", statsCounter->InBadOctets));
-	MSG_PRINT(("Undersize     %08i    ", statsCounter->Undersize));
-	MSG_PRINT(("Fragments     %08i   \n", statsCounter->Fragments));
-	MSG_PRINT(("In64Octets    %08i    ", statsCounter->In64Octets));
-	MSG_PRINT(("In127Octets   %08i   \n", statsCounter->In127Octets));
-	MSG_PRINT(("In255Octets   %08i    ", statsCounter->In255Octets));
-	MSG_PRINT(("In511Octets   %08i   \n", statsCounter->In511Octets));
-	MSG_PRINT(("In1023Octets  %08i    ", statsCounter->In1023Octets));
-	MSG_PRINT(("InMaxOctets   %08i   \n", statsCounter->InMaxOctets));
-	MSG_PRINT(("Jabber        %08i    ", statsCounter->Jabber));
-	MSG_PRINT(("Oversize      %08i   \n", statsCounter->Oversize));
-	MSG_PRINT(("InDiscards    %08i    ", statsCounter->InDiscards));
-	MSG_PRINT(("Filtered      %08i   \n", statsCounter->Filtered));
-	MSG_PRINT(("OutUnicasts   %08i    ", statsCounter->OutUnicasts));
-	MSG_PRINT(("OutBroadcasts %08i   \n", statsCounter->OutBroadcasts));
-	MSG_PRINT(("OutPause      %08i    ", statsCounter->OutPause));
-	MSG_PRINT(("OutMulticasts %08i   \n", statsCounter->OutMulticasts));
-	MSG_PRINT(("OutFCSErr     %08i    ", statsCounter->OutFCSErr));
-	MSG_PRINT(("OutGoodOctets %08i   \n", statsCounter->OutGoodOctets));
-	MSG_PRINT(("Out64Octets   %08i    ", statsCounter->Out64Octets));
-	MSG_PRINT(("Out127Octets  %08i   \n", statsCounter->Out127Octets));
-	MSG_PRINT(("Out255Octets  %08i    ", statsCounter->Out255Octets));
-	MSG_PRINT(("Out511Octets  %08i   \n", statsCounter->Out511Octets));
-	MSG_PRINT(("Out1023Octets %08i    ", statsCounter->Out1023Octets));
-	MSG_PRINT(("OutMaxOctets  %08i   \n", statsCounter->OutMaxOctets));
-	MSG_PRINT(("Collisions    %08i    ", statsCounter->Collisions));
-	MSG_PRINT(("Late          %08i   \n", statsCounter->Late));
-	MSG_PRINT(("Excessive     %08i    ", statsCounter->Excessive));
-	MSG_PRINT(("Multiple      %08i   \n", statsCounter->Multiple));
-	MSG_PRINT(("Single        %08i    ", statsCounter->Single));
-	MSG_PRINT(("Deferred      %08i   \n", statsCounter->Deferred));
-	MSG_PRINT(("OutDiscards   %08i   \n", statsCounter->OutDiscards));
-}
-
-GT_STATUS testDisplayRMONCounter(GT_QD_DEV *dev,GT_LPORT port)
-{
-	GT_STATUS status;
-	GT_STATS_COUNTER_SET	statsCounterSet;
-
-	MSG_PRINT(("Getting counters for port %i.\n", port));
-		
-	if((status = gstatsGetPortAllCounters(dev,port,&statsCounterSet)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsGetPortAllCounters returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	testDisplayCounter(&statsCounterSet);
-	return GT_OK;
-}
-
-GT_U32 testRMON1(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, tmpResult;
-	GT_U32 testResults = 0;
-	GT_STATS_COUNTERS	counter;
-	GT_STATS_COUNTER_SET	statsCounterSet;
-	GT_U32	statsData;
-	GT_LPORT port;	
-	int portIndex;
-
-	testResult=GT_OK;
-
-	MSG_PRINT(("\ntesting RMON Counter :\n"));
-	MSG_PRINT(("RMON testing assumes no more activities in the device.\n"));
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		tmpResult = GT_OK;
-		port = portIndex;
-
-		MSG_PRINT(("Getting all counters for port %i.\n", port));
-		
-		if((status = gstatsGetPortAllCounters(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		MSG_PRINT(("Getting individual counter for port %i.\n", port));
-
-		for(counter=STATS_InUnicasts; counter<=STATS_OutDiscards; counter++)
-		{
-			if((status = gstatsGetPortCounter(dev,port, counter, &statsData)) != GT_OK)
-			{
-				MSG_PRINT(("gstatsGetPortCounter returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			if (statsData != *((GT_U32*)&statsCounterSet + counter))
-			{
-				MSG_PRINT(("gstatsGetPortCounter(%i) mismatches gstatsGetPortAllCounter (%i : %i).\n",
-							counter,statsData,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Comparing counters: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Comparing counters: (FAIL)\n"));
-		}
-
-		if (!(port % 2))
-			continue;
-
-		MSG_PRINT(("Flushing the counter for port %i\n",port));
-
-		tmpResult = GT_OK;
-
-		if((status = gstatsFlushPort(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsFlushPort returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gstatsGetPortAllCounters(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS_InUnicasts; counter<=STATS_OutDiscards; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (counter : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Flush: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Flush: (FAIL)\n"));
-		}
-
-	}
-
-	/* Now RMON counters of the ports with even numbers are flushed */
-	MSG_PRINT(("Flushing the counters for all port\n"));
-	tmpResult = GT_OK;
-	if((status = gstatsFlushAll(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsFlushAll returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		if((status = gstatsGetPortAllCounters(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS_InUnicasts; counter<=STATS_OutDiscards; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (stats : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-	}			
-
-	if(tmpResult == GT_OK)
-	{
-		MSG_PRINT(("Flush ALL: (PASS)\n"));
-	}
-	else
-	{
-		MSG_PRINT(("Flush ALL: (FAIL)\n"));
-	}
-
-	return testResults;
-}
-
-void testDisplayCounter2(GT_STATS_COUNTER_SET2 *statsCounter)
-{
-	MSG_PRINT(("InGoodOctetsHi  %08i    ", statsCounter->InGoodOctetsHi));
-	MSG_PRINT(("InGoodOctetsLo  %08i   \n", statsCounter->InGoodOctetsLo));
-	MSG_PRINT(("InBadOctets     %08i    ", statsCounter->InBadOctets));
-	MSG_PRINT(("OutDiscards     %08i   \n", statsCounter->OutDiscards));
-	MSG_PRINT(("InGoodFrames    %08i    ", statsCounter->InGoodFrames));
-	MSG_PRINT(("InBadFrames     %08i   \n", statsCounter->InBadFrames));
-	MSG_PRINT(("InBroadcasts    %08i    ", statsCounter->InBroadcasts));
-	MSG_PRINT(("InMulticasts    %08i   \n", statsCounter->InMulticasts));
-	MSG_PRINT(("64Octets        %08i    ", statsCounter->Octets64));
-	MSG_PRINT(("127Octets       %08i   \n", statsCounter->Octets127));
-	MSG_PRINT(("255Octets       %08i    ", statsCounter->Octets255));
-	MSG_PRINT(("511Octets       %08i   \n", statsCounter->Octets511));
-	MSG_PRINT(("1023Octets      %08i    ", statsCounter->Octets1023));
-	MSG_PRINT(("MaxOctets       %08i   \n", statsCounter->OctetsMax));
-	MSG_PRINT(("OutOctetsHi     %08i    ", statsCounter->OutOctetsHi));
-	MSG_PRINT(("OutOctetsLo     %08i   \n", statsCounter->OutOctetsLo));
-	MSG_PRINT(("OutFrames       %08i    ", statsCounter->OutFrames));
-	MSG_PRINT(("Excessive       %08i   \n", statsCounter->Excessive));
-	MSG_PRINT(("OutMulticasts   %08i    ", statsCounter->OutMulticasts));
-	MSG_PRINT(("OutBroadcasts   %08i    ", statsCounter->OutBroadcasts));
-	MSG_PRINT(("InBadMACCtrl    %08i    ", statsCounter->InBadMACCtrl));
-	MSG_PRINT(("OutPause        %08i   \n", statsCounter->OutPause));
-	MSG_PRINT(("InPause         %08i    ", statsCounter->InPause));
-	MSG_PRINT(("InDiscards      %08i   \n", statsCounter->InDiscards));
-	MSG_PRINT(("Undersize       %08i    ", statsCounter->Undersize));
-	MSG_PRINT(("Fragments       %08i   \n", statsCounter->Fragments));
-	MSG_PRINT(("Oversize        %08i    ", statsCounter->Oversize));
-	MSG_PRINT(("Jabber          %08i   \n", statsCounter->Jabber));
-	MSG_PRINT(("MACRcvErr       %08i    ", statsCounter->MACRcvErr));
-	MSG_PRINT(("InFCSErr        %08i   \n", statsCounter->InFCSErr));
-	MSG_PRINT(("Collisions      %08i    ", statsCounter->Collisions));
-	MSG_PRINT(("Late            %08i   \n", statsCounter->Late));
-}
-
-GT_STATUS testDisplayRMONCounter2(GT_QD_DEV *dev,GT_LPORT port)
-{
-	GT_STATUS status;
-	GT_STATS_COUNTER_SET2 statsCounterSet;
-
-	MSG_PRINT(("Getting counters for port %i.\n", port));
-		
-	if((status = gstatsGetPortAllCounters2(dev,port,&statsCounterSet)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsGetPortAllCounters2 returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	testDisplayCounter2(&statsCounterSet);
-	return GT_OK;
-}
-
-GT_U32 testRMON2(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, tmpResult;
-	GT_U32 testResults = 0;
-	GT_STATS_COUNTERS2 counter;
-	GT_STATS_COUNTER_SET2 statsCounterSet;
-	GT_U32	statsData;
-	GT_LPORT port;	
-	int portIndex;
-	TEST_API testAPI;
-
-	testResult=GT_OK;
-
-	/*
-	 *	Histogram Mode Setup
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gstatsGetHistogramMode;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gstatsSetHistogramMode;
-	if((status = testU32Type(dev,&testAPI,3)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Histogram Mode Setup API test "));
-	testDisplayStatus(status);
-	MSG_PRINT(("\ntesting RMON Counter :\n"));
-	MSG_PRINT(("RMON testing assumes no more activities in the device.\n"));
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		tmpResult = GT_OK;
-		port = portIndex;
-
-		MSG_PRINT(("Getting all counters for port %i.\n", port));
-		
-		if((status = gstatsGetPortAllCounters2(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters2 returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		MSG_PRINT(("Getting individual counter for port %i.\n", port));
-
-		for(counter=STATS2_InGoodOctetsHi; counter<=STATS2_Late; counter++)
-		{
-			if((status = gstatsGetPortCounter2(dev,port, counter, &statsData)) != GT_OK)
-			{
-				MSG_PRINT(("gstatsGetPortCounter2 returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			if (statsData != *((GT_U32*)&statsCounterSet + counter))
-			{
-				MSG_PRINT(("gstatsGetPortCounter2(%i) mismatches gstatsGetPortAllCounter2 (%i : %i).\n",
-							counter,statsData,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Comparing counters: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Comparing counters: (FAIL)\n"));
-		}
-
-		if (!(port % 2))
-			continue;
-
-		MSG_PRINT(("Flushing the counter for port %i\n",port));
-
-		tmpResult = GT_OK;
-
-		if((status = gstatsFlushPort(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsFlushPort returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gstatsGetPortAllCounters2(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS2_InGoodOctetsHi; counter<=STATS2_Late; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (counter : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Flush: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Flush: (FAIL)\n"));
-		}
-
-	}
-
-	/* Now RMON counters of the ports with even numbers are flushed */
-	MSG_PRINT(("Flushing the counters for all port\n"));
-	tmpResult = GT_OK;
-	if((status = gstatsFlushAll(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsFlushAll returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		if((status = gstatsGetPortAllCounters2(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS2_InGoodOctetsHi; counter<=STATS2_Late; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (stats : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-	}			
-
-	if(tmpResult == GT_OK)
-	{
-		MSG_PRINT(("Flush ALL: (PASS)\n"));
-	}
-	else
-	{
-		MSG_PRINT(("Flush ALL: (FAIL)\n"));
-	}
-
-	return testResults;
-}
-
-void testDisplayCounter3(GT_STATS_COUNTER_SET3 *statsCounter)
-{
-	MSG_PRINT(("InGoodOctetsLo  %08i    ", statsCounter->InGoodOctetsLo));
-	MSG_PRINT(("InGoodOctetsHi  %08i   \n", statsCounter->InGoodOctetsHi));
-	MSG_PRINT(("InBadOctets     %08i    ", statsCounter->InBadOctets));
-	MSG_PRINT(("OutFCSErr       %08i   \n", statsCounter->OutFCSErr));
-	MSG_PRINT(("InUnicasts      %08i    ", statsCounter->InUnicasts));
-	MSG_PRINT(("Deferred        %08i   \n", statsCounter->Deferred));
-	MSG_PRINT(("InBroadcasts    %08i    ", statsCounter->InBroadcasts));
-	MSG_PRINT(("InMulticasts    %08i   \n", statsCounter->InMulticasts));
-	MSG_PRINT(("64Octets        %08i    ", statsCounter->Octets64));
-	MSG_PRINT(("127Octets       %08i   \n", statsCounter->Octets127));
-	MSG_PRINT(("255Octets       %08i    ", statsCounter->Octets255));
-	MSG_PRINT(("511Octets       %08i   \n", statsCounter->Octets511));
-	MSG_PRINT(("1023Octets      %08i    ", statsCounter->Octets1023));
-	MSG_PRINT(("MaxOctets       %08i   \n", statsCounter->OctetsMax));
-	MSG_PRINT(("OutOctetsLo     %08i    ", statsCounter->OutOctetsLo));
-	MSG_PRINT(("OutOctetsHi     %08i   \n", statsCounter->OutOctetsHi));
-	MSG_PRINT(("OutUnicasts     %08i    ", statsCounter->OutUnicasts));
-	MSG_PRINT(("Excessive       %08i   \n", statsCounter->Excessive));
-	MSG_PRINT(("OutMulticasts   %08i    ", statsCounter->OutMulticasts));
-	MSG_PRINT(("OutBroadcasts   %08i   \n", statsCounter->OutBroadcasts));
-	MSG_PRINT(("Single          %08i    ", statsCounter->Single));
-	MSG_PRINT(("OutPause        %08i   \n", statsCounter->OutPause));
-	MSG_PRINT(("InPause         %08i    ", statsCounter->InPause));
-	MSG_PRINT(("Multiple        %08i   \n", statsCounter->Multiple));
-	MSG_PRINT(("Undersize       %08i    ", statsCounter->Undersize));
-	MSG_PRINT(("Fragments       %08i   \n", statsCounter->Fragments));
-	MSG_PRINT(("Oversize        %08i    ", statsCounter->Oversize));
-	MSG_PRINT(("Jabber          %08i   \n", statsCounter->Jabber));
-	MSG_PRINT(("InMACRcvErr     %08i    ", statsCounter->InMACRcvErr));
-	MSG_PRINT(("InFCSErr        %08i   \n", statsCounter->InFCSErr));
-	MSG_PRINT(("Collisions      %08i    ", statsCounter->Collisions));
-	MSG_PRINT(("Late            %08i   \n", statsCounter->Late));
-}
-
-GT_STATUS testDisplayRMONCounter3(GT_QD_DEV *dev,GT_LPORT port)
-{
-	GT_STATUS status;
-	GT_STATS_COUNTER_SET3 statsCounterSet;
-
-	MSG_PRINT(("Getting counters for port %i.\n", port));
-		
-	if((status = gstatsGetPortAllCounters3(dev,port,&statsCounterSet)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsGetPortAllCounters3 returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	testDisplayCounter3(&statsCounterSet);
-	return GT_OK;
-}
-
-GT_U32 testRMON3(GT_QD_DEV *dev)
-{
-	GT_STATUS status, testResult, tmpResult;
-	GT_U32 testResults = 0;
-	GT_STATS_COUNTERS3 counter;
-	GT_STATS_COUNTER_SET3 statsCounterSet;
-	GT_U32	statsData;
-	GT_LPORT port;	
-	int portIndex;
-	TEST_API testAPI;
-
-	testResult=GT_OK;
-
-	/*
-	 *	Histogram Mode Setup
-	 */
-	testAPI.getFunc.u32 = (GT_API_GET_U32)gstatsGetHistogramMode;
-	testAPI.setFunc.u32 = (GT_API_SET_U32)gstatsSetHistogramMode;
-	if((status = testU32Type(dev,&testAPI,3)) != GT_OK)
-	{
-		testResult = GT_FAIL;
-		testResults |= 1 << status;
-	}
-	MSG_PRINT(("Histogram Mode Setup API test "));
-	testDisplayStatus(status);
-	MSG_PRINT(("\ntesting RMON Counter :\n"));
-	MSG_PRINT(("RMON testing assumes no more activities in the device.\n"));
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		tmpResult = GT_OK;
-		port = portIndex;
-
-		MSG_PRINT(("Getting all counters for port %i.\n", port));
-		
-		if((status = gstatsGetPortAllCounters3(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters3 returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		MSG_PRINT(("Getting individual counter for port %i.\n", port));
-
-		for(counter=STATS3_InGoodOctetsLo; counter<=STATS3_Late; counter++)
-		{
-			if((status = gstatsGetPortCounter3(dev,port, counter, &statsData)) != GT_OK)
-			{
-				MSG_PRINT(("gstatsGetPortCounter3 returned "));
-				testDisplayStatus(status);
-				testResults |= 1 << status;
-				return testResults;
-			}
-
-			if (statsData != *((GT_U32*)&statsCounterSet + counter))
-			{
-				MSG_PRINT(("gstatsGetPortCounter3(%i) mismatches gstatsGetPortAllCounter3 (%i : %i).\n",
-							counter,statsData,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Comparing counters: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Comparing counters: (FAIL)\n"));
-		}
-
-		if (!(port % 2))
-			continue;
-
-		MSG_PRINT(("Flushing the counter for port %i\n",port));
-
-		tmpResult = GT_OK;
-
-		if((status = gstatsFlushPort(dev,port)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsFlushPort returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		if((status = gstatsGetPortAllCounters3(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS3_InGoodOctetsLo; counter<=STATS3_Late; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (counter : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-		if(tmpResult == GT_OK)
-		{
-			MSG_PRINT(("Flush: (PASS)\n"));
-		}
-		else
-		{
-			MSG_PRINT(("Flush: (FAIL)\n"));
-		}
-
-	}
-
-	/* Now RMON counters of the ports with even numbers are flushed */
-	MSG_PRINT(("Flushing the counters for all port\n"));
-	tmpResult = GT_OK;
-	if((status = gstatsFlushAll(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gstatsFlushAll returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		return testResults;
-	}
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		if((status = gstatsGetPortAllCounters3(dev,port,&statsCounterSet)) != GT_OK)
-		{
-			MSG_PRINT(("gstatsGetPortAllCounters returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			return testResults;
-		}
-
-		for(counter=STATS3_InGoodOctetsLo; counter<=STATS3_Late; counter++)
-		{
-			if (*((GT_U32*)&statsCounterSet + counter) != 0)
-			{
-				MSG_PRINT(("gstatsFlushPort(%i) failed (stats : %i).\n",
-							counter,*((GT_U32*)&statsCounterSet + counter)));
-				testResult = GT_FAIL;
-				tmpResult = GT_FAIL;
-				testResults |= 1 << tmpResult;
-				continue;
-			}
-		}
-
-	}			
-
-	if(tmpResult == GT_OK)
-	{
-		MSG_PRINT(("Flush ALL: (PASS)\n"));
-	}
-	else
-	{
-		MSG_PRINT(("Flush ALL: (FAIL)\n"));
-	}
-
-	return testResults;
-}
-
-GT_U32 testRMON(GT_QD_DEV *dev)
-{
-	GT_U32 testResults;
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6153:
-		case GT_88E6183:
-			testResults = testRMON2(dev);
-			break;
-		case GT_88E6093:
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6065:
-			testResults = testRMON3(dev);
-			break;
-		default:
-			testResults = testRMON1(dev);
-			break;
-	}
-
-	return testResults;
-}
-
-void testDisplayVTUEntry(GT_QD_DEV *dev, GT_VTU_ENTRY *vtuEntry)
-{
-	GT_LPORT port;	
-	int portIndex;
-
-	MSG_PRINT(("DBNum:%i, VID:%i, ",vtuEntry->DBNum,vtuEntry->vid));
-	MSG_PRINT(("Tag: "));
-
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-
-		MSG_PRINT(("%#x ",port,vtuEntry->vtuData.memberTagP[port]));
-	}
-	MSG_PRINT(("\n"));
-
-	MSG_PRINT(("%i,%i,%i,%i,%i,%i,%i\n",
-				vtuEntry->vidPriOverride,
-				vtuEntry->vidPriority,
-				vtuEntry->vidExInfo.useVIDFPri,
-				vtuEntry->vidExInfo.vidFPri,
-				vtuEntry->vidExInfo.useVIDQPri,
-				vtuEntry->vidExInfo.vidQPri,
-				vtuEntry->vidExInfo.vidNRateLimit
-				));
-
-}
-
-void testDisplayVTUList(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-    GT_VTU_ENTRY vtuEntry;
-
-	memset(&vtuEntry,0,sizeof(GT_VTU_ENTRY));
-	vtuEntry.vid = 0xfff;
-	if((status = gvtuGetEntryFirst(dev,&vtuEntry)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryCount returned "));
-		testDisplayStatus(status);
-		return;
-	}
-
-	testDisplayVTUEntry(dev,&vtuEntry);
-
-	while(1)
-	{
-		if((status = gvtuGetEntryNext(dev,&vtuEntry)) != GT_OK)
-		{
-			break;
-		}
-		testDisplayVTUEntry(dev,&vtuEntry);
-	}
-
-}
-
-GT_STATUS testWriteVTU(GT_QD_DEV *dev, GT_VTU_ENTRY *vtuEntry, GT_U32 vid, GT_U32 DBNum, GT_U32 portVec)
-{
-	int i;
-
-	vtuEntry->vid = vid & 0xFFF;
-	vtuEntry->DBNum = DBNum & 0xF;
-	vtuEntry->vidPriOverride = 0;
-	vtuEntry->vidPriority = 0;
-
-	for(i=0; i<16; i++)
-	{
-		if((portVec>>i) & 0x1)
-			vtuEntry->vtuData.memberTagP[i] = 3;
-		else
-			vtuEntry->vtuData.memberTagP[i] = 0;
-			
-	}
-
-	return GT_OK;
-}
-
-/*
-	VTU APIs Test Scenario:
-	1) Flush VTU entries and check Entry Count.
-	2) Create a list of 16 VID entries based on arg param.
-		(descending, ascending, and random order)
-	3) Add a Entry.
-	4) check Entry Count, call EntryFirst and EntryNext.
-	5) Add 16/64/4096 more Entries.(Last entry should be failed to be added)
-	6) Delete 2 valid entries and 1 invalid entry
-	7) Check Entry Count, and try to find a valid entry and deleted entry.
-*/
-
-GT_STATUS testVTUCtrl(GT_QD_DEV *dev,int arg)
-{
-#define MAX_VTU_ENTRIES	4096
-	GT_STATUS status, testResult, tmpResult;
-    GT_VTU_ENTRY vtuEntry[MAX_VTU_ENTRIES+1];
-    GT_VTU_ENTRY tmpVtuEntry;
-	GT_U32 u32Data1, u32Data2, u32Data3, maxDbNum, priType;
-	GT_BOOL found;
-	int i, j, portIndex;
-	GT_LPORT port;
-	int maxVtuEntries;
-	GT_BOOL supportMaxEntry = GT_FALSE;
-
-	testResult = GT_OK;
-	maxDbNum = 1;
-
-	switch(dev->deviceId)
-	{
-		case GT_88E6021:
-			maxVtuEntries = 16;
-			maxDbNum = 1;
-			priType =  0;	/* no VID Priority override support */
-			break;
-		case GT_88E6063:
-		case GT_FH_VPN:
-		case GT_88E6083:
-			maxVtuEntries = 64;
-			maxDbNum = 16;
-			priType =  0;	/* no VID Priority override support */
-			break;
-		case GT_88E6153:
-		case GT_88E6183:
-		case GT_88E6093:
-			maxVtuEntries = 64;
-			maxDbNum = 16;
-			supportMaxEntry = GT_TRUE;
-			priType =  1;	/* VID Priority override support */
-			break;
-		case GT_88E6031:
-		case GT_88E6061:
-			maxVtuEntries = 16;
-			maxDbNum = 16;
-			priType =  2;	/* Extended VID Priority override support */
-			break;
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6065:
-			maxVtuEntries = 64;
-			maxDbNum = 64;
-			priType =  3;	/* Extended VID Priority override support */
-			break;
-		case GT_88E6095:
-		case GT_88E6092:
-		case GT_88E6152:
-		case GT_88E6155:
-		case GT_88E6182:
-		case GT_88E6185:
-		case GT_88E6131:
-		case GT_88E6108:
-			maxVtuEntries = 64;
-			maxDbNum = 256;
-			supportMaxEntry = GT_TRUE;
-			priType =  1;	/* VID Priority override support */
-			break;
-		default:
-			maxVtuEntries = 16;
-			priType =  0;	/* no VID Priority override support */
-			break;
-	}
-
-	/* 1) Flush VTU entries and check Entry Count */
-	MSG_PRINT(("Flushing VTU entries: "));
-	if((status = gvtuFlush(dev)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuFlush returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if((status = gvtuGetEntryCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryCount returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if(u32Data1 != 0)
-	{
-		MSG_PRINT(("\nEntryCount %i (Failed, should be 0)\n",u32Data1));
-		testResult = GT_FAIL;
-	}
-	else
-	{
-		MSG_PRINT(("(PASS)\n"));
-	}
-
-	/*
-		2) Create a list of 16 VID entries based on arg param.
-			(descending, ascending, and random order)
-	*/
-	MSG_PRINT(("Creating a list of %i VID\n",maxVtuEntries+1));
-	srand((unsigned)time(NULL));
-	switch (arg)
-	{
-		case 0: /* Ascending order */
-			/* check if it supports MX_VTU_ENTRIES */
-			if (maxVtuEntries == MAX_VTU_ENTRIES)
-			{
-				for(i=0; i<maxVtuEntries+1; i++)
-				{
-					memset(&vtuEntry[i],0,sizeof(GT_VTU_ENTRY));
-					vtuEntry[i].DBNum = 1;
-					vtuEntry[i].vid = i;
-					for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-					{
-						port = portIndex;
-
-						vtuEntry[i].vtuData.memberTagP[port] = (vtuEntry[i].vid+port)%4;
-					}
-					switch(priType)
-					{
-						case 0:
-							break;
-						case 1:
-							vtuEntry[i].vidPriOverride = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if(vtuEntry[i].vidPriOverride == GT_TRUE)
-								vtuEntry[i].vidPriority = (GT_U8)(rand() & 0x7);
-							break;
-						case 2:
-							vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							break;
-						case 3:
-							vtuEntry[i].vidExInfo.useVIDFPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if (vtuEntry[i].vidExInfo.useVIDFPri == GT_TRUE)
-								vtuEntry[i].vidExInfo.vidFPri = (GT_U8)(rand() & 0x7);
-							vtuEntry[i].vidExInfo.useVIDQPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if (vtuEntry[i].vidExInfo.useVIDQPri == GT_TRUE)
-								vtuEntry[i].vidExInfo.vidQPri = (GT_U8)(rand() & 0x3);
-							vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							break;
-						default:
-							break;
-					}
-				}
-				break;
-			}
-
-			u32Data1 = (rand()%1024) + 1;
-			u32Data2 = (rand()%32) + 1;
-			for(i=0; i<maxVtuEntries+1; i++)
-			{
-				memset(&vtuEntry[i],0,sizeof(GT_VTU_ENTRY));
-				vtuEntry[i].DBNum = 1;
-				vtuEntry[i].vid = u32Data1 + u32Data2 * i;
-				for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-				{
-					port = portIndex;
-
-					vtuEntry[i].vtuData.memberTagP[port] = (vtuEntry[i].vid+port)%4;
-				}
-				switch(priType)
-				{
-					case 0:
-						break;
-					case 1:
-						vtuEntry[i].vidPriOverride = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if(vtuEntry[i].vidPriOverride == GT_TRUE)
-							vtuEntry[i].vidPriority = (GT_U8)(rand() & 0x7);
-						break;
-					case 2:
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					case 3:
-						vtuEntry[i].vidExInfo.useVIDFPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDFPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidFPri = (GT_U8)(rand() & 0x7);
-						vtuEntry[i].vidExInfo.useVIDQPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDQPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidQPri = (GT_U8)(rand() & 0x3);
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					default:
-						break;
-				}
-			}
-			break;
-
-		case 1: /* Descending order */
-			/* check if it supports MX_VTU_ENTRIES */
-			if (maxVtuEntries == MAX_VTU_ENTRIES)
-			{
-				for(i=0; i<maxVtuEntries; i++)
-				{
-					memset(&vtuEntry[i],0,sizeof(GT_VTU_ENTRY));
-					vtuEntry[i].DBNum = 2;
-					vtuEntry[i].vid = maxVtuEntries - i;
-					for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-					{
-						port = portIndex;
-
-						vtuEntry[i].vtuData.memberTagP[port] = (vtuEntry[i].vid+port)%4;
-					}
-					switch(priType)
-					{
-						case 0:
-							break;
-						case 1:
-							vtuEntry[i].vidPriOverride = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if(vtuEntry[i].vidPriOverride == GT_TRUE)
-								vtuEntry[i].vidPriority = (GT_U8)(rand() & 0x7);
-							break;
-						case 2:
-							vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							break;
-						case 3:
-							vtuEntry[i].vidExInfo.useVIDFPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if (vtuEntry[i].vidExInfo.useVIDFPri == GT_TRUE)
-								vtuEntry[i].vidExInfo.vidFPri = (GT_U8)(rand() & 0x7);
-							vtuEntry[i].vidExInfo.useVIDQPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							if (vtuEntry[i].vidExInfo.useVIDQPri == GT_TRUE)
-								vtuEntry[i].vidExInfo.vidQPri = (GT_U8)(rand() & 0x3);
-							vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-							break;
-						default:
-							break;
-					}
-				}
-				memset(&vtuEntry[i],0,sizeof(GT_VTU_ENTRY));
-				vtuEntry[i].DBNum = 2;
-				vtuEntry[i].vid = 5;	/* choose any value. this entry is only for checking error. */
-				for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-				{
-					port = portIndex;
-
-					vtuEntry[i].vtuData.memberTagP[port] = (vtuEntry[i].vid+port)%4;
-				}
-
-				break;
-			
-			}
-			u32Data1 = (rand()%1024) + 1;
-			u32Data2 = (rand()%32) + 1;
-			for(i=0; i<maxVtuEntries+1; i++)
-			{
-				memset(&vtuEntry[maxVtuEntries-i],0,sizeof(GT_VTU_ENTRY));
-				vtuEntry[maxVtuEntries-i].DBNum = 2;
-				vtuEntry[maxVtuEntries-i].vid = u32Data1 + u32Data2 * i;
-				for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-				{
-					port = portIndex;
-
-					vtuEntry[maxVtuEntries-i].vtuData.memberTagP[port] = (vtuEntry[maxVtuEntries-i].vid+port)%4;
-				}
-				switch(priType)
-				{
-					case 0:
-						break;
-					case 1:
-						vtuEntry[i].vidPriOverride = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if(vtuEntry[i].vidPriOverride == GT_TRUE)
-							vtuEntry[i].vidPriority = (GT_U8)(rand() & 0x7);
-						break;
-					case 2:
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					case 3:
-						vtuEntry[i].vidExInfo.useVIDFPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDFPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidFPri = (GT_U8)(rand() & 0x7);
-						vtuEntry[i].vidExInfo.useVIDQPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDQPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidQPri = (GT_U8)(rand() & 0x3);
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					default:
-						break;
-				}
-			}
-			break;
-
-		default: /* random order */
-			for(i=0; i<maxVtuEntries+1; i++)
-			{
-				memset(&vtuEntry[i],0,sizeof(GT_VTU_ENTRY));
-				vtuEntry[i].DBNum = (maxDbNum > i)?(maxDbNum-i)%maxDbNum:(i-maxDbNum)%maxDbNum;
-				vtuEntry[i].vid = (rand() & 0xF) | ((rand() & 0xF) << 4) | ((rand() & 0xF) << 8);
-				for(j=0; j<i; j++)
-				{
-					if(vtuEntry[j].vid == vtuEntry[i].vid)
-					{
-						vtuEntry[i].vid = (rand() & 0xF) | ((rand() & 0xF) << 4) | ((rand() & 0xF) << 8);
-						j = -1;
-					}
-				}
-
-				for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-				{
-					port = portIndex;
-
-					vtuEntry[i].vtuData.memberTagP[port] = (vtuEntry[i].vid+port)%4;
-				}
-				switch(priType)
-				{
-					case 0:
-						break;
-					case 1:
-						vtuEntry[i].vidPriOverride = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if(vtuEntry[i].vidPriOverride == GT_TRUE)
-							vtuEntry[i].vidPriority = (GT_U8)(rand() & 0x7);
-						break;
-					case 2:
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					case 3:
-						vtuEntry[i].vidExInfo.useVIDFPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDFPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidFPri = (GT_U8)(rand() & 0x7);
-						vtuEntry[i].vidExInfo.useVIDQPri = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						if (vtuEntry[i].vidExInfo.useVIDQPri == GT_TRUE)
-							vtuEntry[i].vidExInfo.vidQPri = (GT_U8)(rand() & 0x3);
-						vtuEntry[i].vidExInfo.vidNRateLimit = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-						break;
-					default:
-						break;
-				}
-			}
-			break;
-
-	}			 
-
-#if 0	/* display VTU entries */
-	for(i=0; i<maxVtuEntries+1; i++)
-		testDisplayVTUEntry(dev,&vtuEntry[i]);
-#endif
-
-	/*
-		3) Add a Entry.
-	*/
-	MSG_PRINT(("Adding a Entry: "));
-	if((status = gvtuAddEntry(dev,&vtuEntry[0])) != GT_OK)
-	{
-		MSG_PRINT(("gvtuAddEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	/*
-		4) check Entry Count, call EntryFirst and EntryNext
-	*/
-	if((status = gvtuGetEntryCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryCount returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if(u32Data1 != 1)
-	{
-		MSG_PRINT(("\nEntryCount %i (Failed, should be 1)\n",u32Data1));
-		testResult = GT_FAIL;
-	}
-	else
-	{
-		MSG_PRINT(("(PASS)\n"));
-	}
-
-	MSG_PRINT(("Getting the first Entry: "));
-	memset(&tmpVtuEntry,0,sizeof(GT_VTU_ENTRY));
-	tmpVtuEntry.vid = 0xfff;
-	if((status = gvtuGetEntryFirst(dev,&tmpVtuEntry)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryCount returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if(memcmp(&tmpVtuEntry,&vtuEntry[0],sizeof(GT_VTU_ENTRY)) != 0)
-	{
-		MSG_PRINT(("Unexpected VTU entry\n"));
-		testDisplayVTUEntry(dev,&tmpVtuEntry);
-		testResult = GT_FAIL;
-	}
-	else
-	{
-		MSG_PRINT(("(PASS)\n"));
-	}
-
-	if((status = gvtuGetEntryNext(dev,&tmpVtuEntry)) == GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryNext should returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	/*
-		5) Add 16 more Entries.(Last entry should be failed to be added)
-	*/
-	MSG_PRINT(("Adding %i VTU entries: ",maxVtuEntries+1));
-	for(i=1; i<maxVtuEntries; i++)
-	{
-		if((status = gvtuAddEntry(dev,&vtuEntry[i])) != GT_OK)
-		{
-			MSG_PRINT(("gvtuAddEntry returned "));
-			testDisplayStatus(status);
-			MSG_PRINT(("Failed VID : %i\n",vtuEntry[i].vid));
-			MSG_PRINT(("Number of Entries should be in VTU : %i\n",i));
-			return status;
-		}
-	}
-
-	if(supportMaxEntry != GT_TRUE)
-	{
-		if((status = gvtuAddEntry(dev,&vtuEntry[maxVtuEntries])) == GT_OK)
-		{
-			MSG_PRINT(("gvtuAddEntry should return "));
-			testDisplayStatus(GT_FAIL);
-			for(i=0; i<maxVtuEntries+1; i++)
-				testDisplayVTUEntry(dev,&vtuEntry[i]);
-			return GT_FAIL;
-		}
-	}
-	MSG_PRINT(("(PASS)\n"));
-
-	/*
-		6) Delete 3 valid entries and 1 invalid entry
-	*/
-	MSG_PRINT(("Deleting entries: "));
-	u32Data1 = 0;
-	u32Data2 = 12;
-	u32Data3 = maxVtuEntries-1;
-	if((status = gvtuDelEntry(dev,&vtuEntry[u32Data1])) != GT_OK)
-	{
-		MSG_PRINT(("gvtuDelEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-	if((status = gvtuDelEntry(dev,&vtuEntry[u32Data2])) != GT_OK)
-	{
-		MSG_PRINT(("gvtuDelEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-	if((status = gvtuDelEntry(dev,&vtuEntry[u32Data3])) != GT_OK)
-	{
-		MSG_PRINT(("gvtuDelEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-#if 0
-	if((status = gvtuDelEntry(dev,&vtuEntry[maxVtuEntries])) == GT_OK)
-	{
-		MSG_PRINT(("gvtuDelEntry should not return "));
-		testDisplayStatus(status);
-		return status;
-	}
-#endif
-	/*
-		7) Check Entry Count, and try to find a valid entry and deleted entry.
-	*/
-
-	MSG_PRINT(("Checking Entry count: "));
-	if((status = gvtuGetEntryCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuGetEntryCount returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if(u32Data1 != maxVtuEntries-3)
-	{
-		MSG_PRINT(("EntryCount %i (Failed, should be %i)\n",u32Data1,maxVtuEntries-3));
-		testResult = GT_FAIL;
-	}
-	else
-	{
-		MSG_PRINT(("(PASS)\n"));
-	}
-
-	MSG_PRINT(("Finding entries: "));
-
-	tmpResult = GT_OK;
-
-	memset(&tmpVtuEntry,0,sizeof(GT_VTU_ENTRY));
-	tmpVtuEntry.vid = vtuEntry[2].vid;
-	if((status = gvtuFindVidEntry(dev,&tmpVtuEntry, &found)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if (found != GT_TRUE)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned OK with Found not true\n"));
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	if(memcmp(&tmpVtuEntry,&vtuEntry[2],sizeof(GT_VTU_ENTRY)) != 0)
-	{
-		MSG_PRINT(("Unexpected VTU entry (%i)\n",2));
-		testDisplayVTUEntry(dev,&tmpVtuEntry);
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	memset(&tmpVtuEntry,0,sizeof(GT_VTU_ENTRY));
-	tmpVtuEntry.vid = vtuEntry[14].vid;
-	if((status = gvtuFindVidEntry(dev,&tmpVtuEntry, &found)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if (found != GT_TRUE)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned OK with Found not true\n"));
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	if(memcmp(&tmpVtuEntry,&vtuEntry[14],sizeof(GT_VTU_ENTRY)) != 0)
-	{
-		MSG_PRINT(("Unexpected VTU entry (%i)\n", 14));
-		testDisplayVTUEntry(dev,&tmpVtuEntry);
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	memset(&tmpVtuEntry,0,sizeof(GT_VTU_ENTRY));
-	tmpVtuEntry.vid = vtuEntry[4].vid;
-	if((status = gvtuFindVidEntry(dev,&tmpVtuEntry, &found)) != GT_OK)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	if (found != GT_TRUE)
-	{
-		MSG_PRINT(("gvtuFindVidEntry returned OK with Found not true\n"));
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	if(memcmp(&tmpVtuEntry,&vtuEntry[4],sizeof(GT_VTU_ENTRY)) != 0)
-	{
-		MSG_PRINT(("Unexpected VTU entry (%i)\n", 4));
-		testDisplayVTUEntry(dev,&tmpVtuEntry);
-		testResult = GT_FAIL;
-		tmpResult = GT_FAIL;
-	}
-
-	/* try to find deleted entry */
-	MSG_PRINT(("Find Deleted Entry... "));
-	memset(&tmpVtuEntry,0,sizeof(GT_VTU_ENTRY));
-	tmpVtuEntry.vid = vtuEntry[u32Data2].vid;
-	if((status = gvtuFindVidEntry(dev,&tmpVtuEntry, &found)) == GT_OK)
-	{
-		if(found == GT_TRUE)
-		{
-			MSG_PRINT(("gvtuFindVidEntry found a deleted entry.\n"));
-			testDisplayVTUEntry(dev,&tmpVtuEntry);
-			testResult = GT_FAIL;
-			tmpResult = GT_FAIL;
-		}
-	}
-
-	if(tmpResult == GT_OK)
-		MSG_PRINT(("(PASS)\n"));
-
-	return testResult;
-}
-
-GT_U32 testVTU(GT_QD_DEV *dev)
-{
-	GT_STATUS testResult, status;
-	GT_U32 testResults = 0;
-	int arg;
-
-	testResult = GT_OK;
-
-	for(arg=0; arg<5; arg++)
-	{
-		if((status=testVTUCtrl(dev,arg)) != GT_OK)
-		{
-			MSG_PRINT(("VTU Test Fail(%d) with arg %i\n", status,arg));
-			testResults |= 1 << status;
-			testResult = GT_FAIL;
-		}
-		else
-		{
-			MSG_PRINT(("VTU Test Pass with arg %i\n", arg));
-		}
-		MSG_PRINT((" \n"));
-	}
-
-	return testResults;
-}
-
-GT_U32 testSysStatus(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_U32 testResults = 0;
-	GT_BOOL mode;
-	GT_U16	data;
-	GT_U32	u32data;
-
-	MSG_PRINT(("Get Switch Mode\n"));
-
-	if((status = gsysGetSW_Mode(dev,&mode)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetSW_Mode returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("Switch Mode : %i\n",(int)mode));
-
-	MSG_PRINT(("Get Init Ready\n"));
-
-	if((status = gsysGetInitReady(dev,&mode)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetInitReady returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("Init Ready : %i\n",(int)mode));
-
-	MSG_PRINT(("Get Free Q Size\n"));
-
-	if((status = gsysGetFreeQSize(dev,&data)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetFreeQSize returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("Free QSize : %i\n",(int)data));
-
-	if((status = gsysGetPPUState(dev,(GT_PPU_STATE*)&u32data)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetPPUState returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("PPU State  : %i\n",(int)u32data));
-
-#ifdef DEBUG_FEATURE
-	MSG_PRINT(("Get QC Pointer Collision\n"));
-
-	if((status = gsysGetPtrCollision(dev,&mode)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetPtrCollision returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("QC Pointer Collision : %i\n",(int)mode));
-
-	MSG_PRINT(("Get Dest. PortVector Corrupt\n"));
-
-	if((status = gsysGetDpvCorrupt(dev,&mode)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetDpvCorrupt returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("Dest. PortVector Corrupt : %i\n",(int)mode));
-
-	MSG_PRINT(("Get Missing Pointer Error\n"));
-
-	if((status = gsysGetMissingPointers(dev,&mode)) != GT_OK)
-	{
-		MSG_PRINT(("gsysGetMissingPointers returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-		if (status == GT_FAIL)
-			return testResults;
-	}
-	MSG_PRINT(("Missing Pointer Error : %i\n",(int)mode));
-#endif
-
-	return testResults;
-}
-
-GT_U32 fillupPIRLData(GT_QD_DEV *dev, GT_PIRL_DATA *pdata, GT_U32 *vec)
-{
-	GT_U32	data;
-	GT_LPORT port;
-	GT_BOOL	restrict;
-
-	switch (dev->deviceId)
-	{
-		case GT_88E6031:
-		case GT_88E6061:
-			restrict = GT_TRUE;
-			break;
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6065:
-			restrict = GT_FALSE;
-			break;
-		default:
-			return GT_NOT_SUPPORTED;
-	}
-
-	/* Ingress Rate */
-	data = rand() % 200001;
-	if(data == 0)
-		data = 64;
-	else if(data < 1000)
-		data = data - (data % 64);
-	else if(data < 100000)
-		data = data - (data % 1000);
-	else
-		data = data - (data % 10000);
-
-	pdata->ingressRate = data;
-
-	pdata->accountQConf = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-	pdata->accountFiltered = (rand() & 0x1)?GT_TRUE:GT_FALSE;
-	pdata->ebsLimitAction = (rand() & 0x1);
-	if (restrict)
-	{
-		pdata->bktRateType = 0;
-		pdata->bktTypeMask = (rand() & 0xF);
-	}
-	else
-	{
-		pdata->bktRateType = (rand() & 0x1);
-		if (pdata->bktRateType == 0)
-			pdata->bktTypeMask = (rand() & 0x7F);
-		else
-			pdata->bktTypeMask = 0;
-	}
-
-	pdata->byteTobeCounted = (rand() % 3);
-
-	*vec = rand() & ((1<<dev->numOfPorts) - 1);
-	if(*vec == 0)
-		*vec = 0x7;
-
-	if(pdata->ebsLimitAction == 0)
-	{
-		return GT_OK;
-	}
-
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(*vec & (1 << port))
-			pdata->fcDeassertMode[port] = port & 0x1;
-	}
-
-	return GT_OK;
-}
-
-GT_U32 testPIRL(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_U32 testResults = 0;
-	GT_U32	i, portVec[12], tmpPortVec, pirlSize;
-	GT_PIRL_DATA	pirlData[12], tmpPirlData;
-	
-	srand((unsigned)time(NULL));
-
-	memset(&pirlData[0],0,sizeof(GT_PIRL_DATA));
-
-	switch (dev->deviceId)
-	{
-		case GT_88E6031:
-			pirlSize = 3;
-			break;
-		case GT_88E6061:
-		case GT_88E6035:
-			pirlSize = 6;
-			break;
-		case GT_88E6055:
-		case GT_88E6065:
-			pirlSize = 12;
-			break;
-		default:
-			return 1 << GT_NOT_SUPPORTED;
-	}
-
-
-	MSG_PRINT(("Try Invalid PIRL API call\n"));
-
-	/* try PIRL APIs without Activating it */
-
-	pirlData[0].ingressRate = 64;
-
-	if((status = gpirlUpdateParam(dev, 0, &pirlData[0])) == GT_OK)
-	{
-		MSG_PRINT(("gpirlUpdateParam returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << GT_FAIL;
-	}
-	if (status == GT_NOT_SUPPORTED)
-		return status;
-
-	portVec[0] = 0x7;
-
-	if((status = gpirlUpdatePortVec(dev, 0, portVec[0])) == GT_OK)
-	{
-		MSG_PRINT(("gpirlUpdateParam returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << GT_FAIL;
-	}
-
-	if (testResults)
-	{
-		MSG_PRINT(("Invalid PIRL API call failed\n"));
-	}
-	else
-	{
-		MSG_PRINT(("Invalid PIRL API call successed\n"));
-	}
-
-
-	/* Activate PIRL */
-	MSG_PRINT(("Filling up the PIRL Data...\n"));
-	for(i=0; i<pirlSize; i++)
-	{
-		memset(&pirlData[i],0,sizeof(GT_PIRL_DATA));
-		fillupPIRLData(dev, &pirlData[i], &portVec[i]);
-	}		
-
-	MSG_PRINT(("Activate Pirl...\n"));
-	for(i=0; i<pirlSize; i++)
-	{
-		if((status = gpirlActivate(dev,i,portVec[i],&pirlData[i])) != GT_OK)
-		{
-			MSG_PRINT(("gpirlActivate returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-		}
-		if (status == GT_FAIL)
-			return testResults;
-	}	
-
-	MSG_PRINT(("Comparing...\n"));
-	for(i=0; i<pirlSize; i++)
-	{
-		memset(&tmpPirlData,0,sizeof(GT_PIRL_DATA));
-		if((status = gpirlReadParam(dev,i,&tmpPirlData)) != GT_OK)
-		{
-			MSG_PRINT(("gpirlReadParam returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-			continue;
-		}
-
-		if(memcmp(&tmpPirlData, &pirlData[i], sizeof(GT_PIRL_DATA)))
-		{
-			MSG_PRINT(("gpirlReadParam returned wrong entry (unit %i).",i));
-			dumpMemory((char*)&tmpPirlData, sizeof(GT_PIRL_DATA));
-			MSG_PRINT(("Expected entry:"));
-			dumpMemory((char*)&pirlData[i], sizeof(GT_PIRL_DATA));
-			testResults |= 1 << GT_FAIL;
-		}
-
-		if((status = gpirlReadPortVec(dev,i,&tmpPortVec)) != GT_OK)
-		{
-			MSG_PRINT(("gpirlReadParam returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-		}
-
-		if(tmpPortVec != portVec[i])
-		{
-			MSG_PRINT(("gpirlReadPortVec returned wrong data (unit %i) : %#x.\n",i,tmpPortVec));
-			MSG_PRINT(("Expected vector: %#x\n",portVec[i]));
-			testResults |= 1 << GT_FAIL;
-		}
-	}
-
-	i = 1;	/* IRL Unit number to be played with */
-
-	MSG_PRINT(("Update Unit %i's IRL Data.\n",i));
-
-	memset(&pirlData[i],0,sizeof(GT_PIRL_DATA));
-	fillupPIRLData(dev, &pirlData[i], &portVec[i]);
-	
-	if((status = gpirlUpdateParam(dev,i,&pirlData[i])) != GT_OK)
-	{
-		MSG_PRINT(("gpirlUpdateParam returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-	}
-	if (status == GT_FAIL)
-		return testResults;
-	
-	if((status = gpirlUpdatePortVec(dev,i,portVec[i])) != GT_OK)
-	{
-		MSG_PRINT(("gpirlUpdatePortVec returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-	}
-	if (status == GT_FAIL)
-		return testResults;
-	
-	MSG_PRINT(("Comparing Updated data...\n"));
-
-	memset(&tmpPirlData,0,sizeof(GT_PIRL_DATA));
-	if((status = gpirlReadParam(dev,i,&tmpPirlData)) != GT_OK)
-	{
-		MSG_PRINT(("gpirlReadParam returned "));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-	}
-
-	if(memcmp(&tmpPirlData, &pirlData[i], sizeof(GT_PIRL_DATA)))
-	{
-		MSG_PRINT(("gpirlReadParam returned wrong entry (unit %i).",i));
-		dumpMemory((char*)&tmpPirlData, sizeof(GT_PIRL_DATA));
-		MSG_PRINT(("Expected entry:"));
-		dumpMemory((char*)&pirlData[i], sizeof(GT_PIRL_DATA));
-		testResults |= 1 << GT_FAIL;
-	}
-
-	if((status = gpirlReadPortVec(dev,i,&tmpPortVec)) != GT_OK)
-	{
-		MSG_PRINT(("gpirlReadParam returned \n"));
-		testDisplayStatus(status);
-		testResults |= 1 << status;
-	}
-
-	if(tmpPortVec != portVec[i])
-	{
-		MSG_PRINT(("gpirlReadPortVec returned wrong data (unit %i) : %#x.\n",i,tmpPortVec));
-		MSG_PRINT(("Expected vector: %#x\n",portVec[i]));
-		testResults |= 1 << GT_FAIL;
-	}
-
-	MSG_PRINT(("Deactivate Pirl...\n"));
-	for(i=0; i<pirlSize; i++)
-	{
-		if((status = gpirlDeactivate(dev,i)) != GT_OK)
-		{
-			MSG_PRINT(("gpirlDeactivate returned "));
-			testDisplayStatus(status);
-			testResults |= 1 << status;
-		}
-		if (status == GT_FAIL)
-			return testResults;
-	}	
-
-	return testResults;
-}
-
-
-GT_STATUS testPartialAll(GT_QD_DEV *dev, GT_U32 tests)
-{
-	int i,j;
-	GT_STATUS testResult = GT_OK;
-	GT_U32	testResults[32];
-	
-	i = 0;
-	while(1)
-	{
-		if (testStruct[i].testFunc == NULL)
-			break;
-
-		if (!(tests & (1<<i)))
-		{
-			i++;
-			continue;
-		}
-
-		testResults[i] = testStruct[i].testFunc(dev);
-		i++;
-	}
-
-	printf("\nTest Result\n");
-	i = 0;
-	while(1)
-	{
-		if (testStruct[i].testFunc == NULL)
-			break;
-
-		if (!(tests & (1<<i)))
-		{
-			i++;
-			continue;
-		}
-
-		printf("%s ",testStruct[i].strTest);
-		
-		if(testResults[i] == 0)
-		{
-		 	printf("PASS\n");
-			i++;
-			continue;
-		}
-		for(j=0;j<32;j++)
-		{
-			if(testResults[i] & (1<<j))
-			{
-				switch(j)
-				{
-					case GT_OK:
-						printf("PASS ");
-						break;
-					case GT_FAIL :
-						printf("one or more Failure ");
-						break;
-					case GT_NOT_SUPPORTED :
-						printf("one or more Not Supported ");
-						break;
-					default:
-						printf("one or more FAIL ");
-						break;
-				}
-			}
-		}
-		printf("\n");
-		i++;
-	}
-
-	return testResult;
-}
-
-
-GT_STATUS testAll(GT_QD_DEV *dev)
-{
-	int i,j;
-	GT_STATUS testResult = GT_OK;
-	
-	i = 0;
-	while(1)
-	{
-		if (testStruct[i].testFunc == NULL)
-			break;
-
-		MSG_PRINT(("\nTesting %s\n",testStruct[i].strTest));
-		
-		testStruct[i].testResults = testStruct[i].testFunc(dev);
-		i++;
-	}
-
-	MSG_PRINT(("\nTest Result\n"));
-	i = 0;
-	while(1)
-	{
-		if (testStruct[i].testFunc == NULL)
-			break;
-
-		MSG_PRINT(("%s ",testStruct[i].strTest));
-		
-		if(testStruct[i].testResults == 0)
-		{
-		 	MSG_PRINT(("PASS\n"));
-			i++;
-			continue;
-		}
-		for(j=0;j<32;j++)
-		{
-			if(testStruct[i].testResults & (1<<j))
-			{
-				switch(j)
-				{
-					case GT_OK:
-						MSG_PRINT(("PASS "));
-						break;
-					case GT_FAIL :
-						MSG_PRINT(("one or more Failure "));
-						break;
-					case GT_NOT_SUPPORTED :
-						MSG_PRINT(("one or more Not Supported "));
-						break;
-					default:
-						MSG_PRINT(("one or more FAIL "));
-						break;
-				}
-			}
-		}
-		MSG_PRINT(("\n"));
-		i++;
-	}
-
-	return testResult;
-}
-
-
-/*
- * Start Packet Generator.
- * Input:
- *      pktload - enum GT_PG_PAYLOAD (GT_PG_PAYLOAD_RANDOM or GT_PG_PAYLOAD_5AA5)
- *      length  - enum GT_PG_LENGTH  (GT_PG_LENGTH_64 or GT_PG_LENGTH_1514)
- *      tx      - enum GT_PG_TX      (GT_PG_TX_NORMAL or GT_PG_TX_ERROR)
-*/
-GT_STATUS testStartPktGen
-(
-    GT_QD_DEV      *dev,
-    GT_LPORT       port,
-    GT_PG_PAYLOAD  payload,
-    GT_PG_LENGTH   length,
-    GT_PG_TX       tx
-)
-{
-    GT_STATUS status;
-    GT_PG     pktInfo;
-
-    if (dev == 0)
-    {
-        MSG_PRINT(("GT driver is not initialized\n"));
-        return GT_FAIL;
-    }
-
-    MSG_PRINT(("Start Packet Generator for port %i\n",(int)port));
-
-    pktInfo.payload = payload; /* Pseudo-random, 5AA55AA5... */
-    pktInfo.length = length;   /* 64 bytes, 1514 bytes */
-    pktInfo.tx = tx;           /* normal packet, error packet */
-
-    /*
-     *	Start Packet Generator
-    */
-    if((status = gprtSetPktGenEnable(dev,port,GT_TRUE,&pktInfo)) != GT_OK)
-    {
-        MSG_PRINT(("gprtSetPktGenEnable return Failed\n"));
-        return status;
-    }
-
-    return GT_OK;
-}
-
-
-/*
- * Stop Packet Generator.
- */
-GT_STATUS testStopPktGen(GT_QD_DEV *dev,GT_LPORT port)
-{
-    GT_STATUS status;
-
-    if (dev == 0)
-    {
-        MSG_PRINT(("GT driver is not initialized\n"));
-        return GT_FAIL;
-    }
-
-    MSG_PRINT(("Stopping Packet Generator for port %i\n",(int)port));
-
-    /*
-     *	Start Packet Generator
-    */
-    if((status = gprtSetPktGenEnable(dev,port,GT_FALSE,NULL)) != GT_OK)
-    {
-        MSG_PRINT(("gprtSetPktGenEnable return Failed\n"));
-        return status;
-    }
-
-    return GT_OK;
-}
-
-void testDisplayCableTestResult
-(
-	GT_TEST_STATUS *cableStatus, 
-	GT_CABLE_LEN *cableLen
-)
-{
-	switch(*cableStatus)
-	{
-		case GT_TEST_FAIL:
-			MSG_PRINT(("Cable Test Failed\n"));
-			break;
-		case GT_NORMAL_CABLE:
-			MSG_PRINT(("Cable Test Passed. No problem found.\n"));
-			switch(cableLen->normCableLen)
-			{
-				case GT_LESS_THAN_50M:
-					MSG_PRINT(("Cable Length is less than 50M.\n"));
-					break;
-				case GT_50M_80M:
-					MSG_PRINT(("Cable Length is between 50M and 80M.\n"));
-					break;
-				case GT_80M_110M:
-					MSG_PRINT(("Cable Length is between 80M and 110M.\n"));
-					break;
-				case GT_110M_140M:
-					MSG_PRINT(("Cable Length is between 110M and 140M.\n"));
-					break;
-				case GT_MORE_THAN_140:
-					MSG_PRINT(("Cable Length is over 140M.\n"));
-					break;
-				default:
-					MSG_PRINT(("Cable Length is unknown.\n"));
-					break;
-			}
-			break;
-		case GT_OPEN_CABLE:
-			MSG_PRINT(("Cable Test Passed. Cable is open.\n"));
-			MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
-			break;
-		case GT_SHORT_CABLE:
-			MSG_PRINT(("Cable Test Passed. Cable is short.\n"));
-			MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
-			break;
-		default:
-			MSG_PRINT(("Unknown Test Result.\n"));
-			break;
-	}
-}
-
-GT_STATUS dumpATUInfo(ATU_ENTRY_INFO *atuInfo, int entry)
-{
-	int i;
-
-	for(i=0; i<entry; i++)
-	{
-		printATUEntry(&atuInfo->atuEntry);
-		atuInfo++;
-	}
-	return GT_OK;
-}
-
-GT_STATUS testWriteATU(GT_QD_DEV *dev,GT_U8 atuSize,GT_U8 dbNum,GT_U32 entryState,GT_U32 macHiAddr,GT_U32 entries)
-{
-	GT_STATUS status;
-	ATU_ENTRY_INFO *atuEntry;
-	GT_U16 maxMacs, i;
-
-	if(atuSize >= 5)
-		return GT_FAIL;
-
-	if(entries == 0)
-		maxMacs = 256 << atuSize;
-	else
-		maxMacs = entries;
-
-	if (gAtuEntry == NULL)
-		gAtuEntry = (ATU_ENTRY_INFO *)malloc(sizeof(ATU_ENTRY_INFO)*4096);
-
-	atuEntry = gAtuEntry;
-
-	gtMemSet(atuEntry,0,sizeof(ATU_ENTRY_INFO)*maxMacs);
-
-	MSG_PRINT(("Getting ATU List(%i).\n",maxMacs));
-	if((status=testFillUpAtu(dev,atuEntry,atuSize,dbNum,(GT_U16)macHiAddr,entryState)) != GT_OK)
-	{
-		MSG_PRINT(("testFillUpAtu returned "));
-		testDisplayStatus(status);
-		return status;
-	}
-
-	MSG_PRINT(("Writing ATU List(%i).\n",maxMacs));
-	for(i=0; i<maxMacs; i++)
-	{
-		if((status = gfdbAddMacEntry(dev,&atuEntry[i].atuEntry)) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned "));
-			testDisplayStatus(status);
-			return status;
-		}
-	}
-
-	return GT_OK;
-}
-
-GT_STATUS runRWDir(GT_QD_DEV *dev, int port, int reg, int iter, int startV, int endV, int timeout)
-{
-	int i;
-	GT_U32 data, tmpData;
-	volatile int d;
-
-	for (i=0; i<iter; i++)
-	{
-		for(data = startV; data <= endV; data++)
-		{
-			gsysWriteMiiReg(dev,port,reg,data);
-	        for(d = 0 ; d <timeout  ; d++);
-			gsysReadMiiReg(dev,port,reg,&tmpData);
-			if(data != tmpData)
-			{
-				MSG_PRINT(("Data Mismatch : iter %i, wrote %#x, read %#x \n",i,data,tmpData));
-				return GT_FAIL;
-			}
-		}
-		
-	}
-	MSG_PRINT(("Success\n"));
-	return GT_OK;
-}
-
-GT_STATUS testDisplayTrunkRouting(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	GT_U32 route, id;
-
-	printf("Trunk Routing Table\n");
-
-	for (id=0; id<16; id++)
-	{
-		if((status = gsysGetTrunkRouting(dev,id,&route)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-			return status;
-		}
-		if(!route)
-			continue;
-		printf("ID %i : %#x\n",(int)id,(int)route);
-	}
-	return GT_OK;
-}
-
-GT_STATUS testDisplayTrunkMask(GT_QD_DEV *dev)
-{
-	GT_STATUS status;
-	int i;
-	GT_U32 mask;
-
-	printf("Trunk Mask Table\n");
-
-	for (i=0; i<8; i++)
-	{
-		if((status = gsysGetTrunkMaskTable(dev,i,&mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-		printf("%i : %#x\n",i+1,(int)mask);
-	}
-	return GT_OK;
-}
-
-GT_STATUS qdStatusShow(GT_QD_DEV *dev)
-{
-	GT_U32 regBaseAddr,u32Data;
-	GT_LPORT port;
-	int portIndex;
-
-	regBaseAddr	= dev->baseRegAddr;
-
-	MSG_PRINT(("Switch Status (offset 0): "));
-	gsysReadMiiReg(dev,regBaseAddr+0xF,0,&u32Data);
-	MSG_PRINT(("%#04x\n",u32Data & 0xFFFF));
-	
-	MSG_PRINT(("VTU Status (offset 5)   : "));
-	gsysReadMiiReg(dev,regBaseAddr+0xF,5,&u32Data);
-	MSG_PRINT(("%#04x\n",u32Data & 0xFFFF));
-	
-	for(portIndex=0; portIndex<dev->numOfPorts; portIndex++)
-	{
-		port = portIndex;
-		
-		MSG_PRINT(("Port %i Status (offset 0): ", port));
-		gsysReadMiiReg(dev,regBaseAddr+0x8+port,0,&u32Data);
-		MSG_PRINT(("%#04x\n",u32Data & 0xFFFF));
-	}
-	return GT_OK;
-}
-GT_STATUS testHelp()
-{
-	MSG_PRINT(("qdStart - to Initialize QuarterDeck driver\n"));
-	MSG_PRINT(("testSysCtrl - to test System Control API\n"));
-	MSG_PRINT(("testPort - to test Port Control API\n"));
-	MSG_PRINT(("testATU - to test ATU related API\n"));
-	MSG_PRINT(("testRMON - to test RMON related API\n"));
-	MSG_PRINT(("testVTU - to test VTU related API\n"));
-	MSG_PRINT(("testSysStatus - to test System Status related API\n"));
-	MSG_PRINT(("testVlan - to test Vlan related API\n"));
-	MSG_PRINT(("testSTP - to test STP related API\n"));
-	MSG_PRINT(("testPhy - to test Phy related API\n"));
-	MSG_PRINT(("testPortStatus - to test Port Status related API\n"));
-	MSG_PRINT(("testQosRule - to test QoS Rule related API\n"));
-	MSG_PRINT(("testQosMap - to test QoS Map related API\n"));
-	MSG_PRINT(("testPortRateCtrl - to test Port Rate Control API\n"));
-	MSG_PRINT(("testPortPAV - to test Port Association Vector API\n"));
-	MSG_PRINT(("testInterrupt - to test Interrupt related API\n"));
-	MSG_PRINT(("testAll - to run all the test specified above.\n"));
-	MSG_PRINT(("\n"));
-	MSG_PRINT(("vctTest - to run Virtual Cable Test on a given port.\n"));
-	MSG_PRINT(("defaultVlan - to setup Vlan for firewall app\n"));
-	MSG_PRINT(("readStatistics - to read statistics\n"));
-	MSG_PRINT(("testGoodPkt - to setup Good Packet only mode\n"));
-	MSG_PRINT(("testBadPkt - to setup Bad Packet only mode\n"));
-	MSG_PRINT(("testDisplayATUList - to display ATU list in the device\n"));
-	MSG_PRINT(("testDisplayRMONCounter - to display RMON counter of a port\n"));
-	MSG_PRINT(("testDisplayVTUList - to display VTU list in the device\n"));
-	MSG_PRINT(("qdStatusShow - to display the status of the device\n"));
-
-	return GT_OK;
-}
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/utils.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/utils.c
deleted file mode 100644
index 8327638..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/utils.c
+++ /dev/null
@@ -1,711 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* utils.c
-*
-* DESCRIPTION:
-*       Collection of Utility functions
-*
-* DEPENDENCIES:   Platform.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-#include "msSample.h"
-
-static GT_U16 hashMode = 0;
-int testPrintEnable = 1;
-
-void testPrint(char* format, ...)
-{
-	va_list argP;
-	char dbgStr[1000] = "";
-
-	if(testPrintEnable == 0)
-		return;
-
-	va_start(argP, format);
-
-	vsprintf(dbgStr, format, argP);
-
-	printf("%s",dbgStr);
-
-	return;
-}
-
-int vtuEntryCmpFunc(void* buf, int a, int b)
-{
-    GT_VTU_ENTRY* vtuEntry = (GT_VTU_ENTRY*)buf;
-
-	if ((vtuEntry+a)->vid > (vtuEntry+b)->vid)
-		return 1;
-	else if ((vtuEntry+a)->vid < (vtuEntry+b)->vid)
-		return -1;
-	else
-		return 0;
-}
-
-int atuEntryCmpFunc(void* buf, int a, int b)
-{
-	GT_ATU_ENTRY *atuEntry = (GT_ATU_ENTRY *)buf;
-	GT_U8* aChar,* bChar;
-	int i;
-
-	aChar = (GT_U8*)((atuEntry+a)->macAddr.arEther);
-	bChar = (GT_U8*)((atuEntry+b)->macAddr.arEther);
-
-	for (i=0; i<6; i++)
-	{
-		if(*aChar > *bChar)
-			return 1;
-		else if (*aChar < *bChar)
-			return -1;
-		aChar++;
-		bChar++;
-	}
-
-	return 0;
-
-}
-
-/* insertion sort */
-GT_STATUS gtSort(int list[], GT_CMP_FUNC cmpFunc, void* buf, GT_U32 len)
-{
-	GT_U32 index;
-	int curValue, preValue;
-
-	if (len <= 1)
-		return GT_FAIL;
-
-	preValue = list[0];
-
-	for (index = 1; index < len; ++index)
-	{
-		curValue = list[index];
-		if ((*cmpFunc)(buf, preValue, curValue) > 0)
-		{
-			/* out of order: list[index-1] > list[index] */
-			GT_U32 index2;
-			list[index] = preValue; /* move up the larger item first */
-
-			/* find the insertion point for the smaller item */
-			for (index2 = index - 1; index2 > 0;)
-			{
-				int temp_val = list[index2 - 1];
-				if ((*cmpFunc)(buf, temp_val, curValue) > 0)
-				{
-					list[index2--] = temp_val;
-					/* still out of order, move up 1 slot to make room */
-				}
-				else
-					break;
-			}
-			list[index2] = curValue; /* insert the smaller item right here */
-		}
-		else
-		{
-			/* in order, advance to next element */
-			preValue = curValue;
-		}
-	}
-	return GT_OK;
-}
- 
-
-GT_U16 hashFunction(char eaddr[])
-{
-	GT_U16 crc_reg;
-	GT_U8 crc_in;
-	int i,j;
-
-	crc_reg=0;
-	
-	for(i=0; i<6; i++)
-	{
-		crc_in = eaddr[5-i];
-		for(j=0; j<8; j++)
-		{
-			crc_reg = ((((crc_in & 1) ^ ((crc_reg>>15) & 1)) ^ 
-						((crc_reg>>14) & 1)) << 15)				|	/* bit 15 */
-						((crc_reg & 0x3FFC) << 1) 				|	/* bit 14:3 */
-						((((crc_in & 1) ^ ((crc_reg>>15) & 1)) ^ 
-						((crc_reg>>1) & 1)) << 2) 				|	/* bit 2 */
-						((crc_reg & 1) << 1)					| 	/* bit 1 */
-						((crc_in & 1) ^ ((crc_reg>>15) & 1));		/* bit 0 */
-
-			crc_in >>= 1;
-		}
-	}
-
-	return crc_reg;
-}
-
-
-GT_U16 hashToBucket(GT_U16 hash, GT_U16 mode)
-{
-	GT_U16 bucket;
-
-	switch (mode)
-	{
-		case 0:
-			bucket = 
-			(((hash >> 7) & 1) << 10) |		/* bit 10 */
-			(((hash >> 11) & 1) << 9) |		/* bit 9 */
-			(((hash >> 3 ) & 1) << 8) |		/* bit 8 */
-			(((hash >> 14) & 1) << 7) |		/* bit 7 */
-			(((hash >> 12) & 1) << 6) |		/* bit 6 */
-			(((hash >> 10) & 1) << 5) |		/* bit 5 */
-			(((hash >> 8 ) & 1) << 4) |		/* bit 4 */
-			(((hash >> 6 ) & 1) << 3) |		/* bit 3 */
-			(((hash >> 4 ) & 1) << 2) |		/* bit 2 */
-			(((hash >> 2 ) & 1) << 1) |		/* bit 1 */
-			(( hash >> 0 ) & 1); 			/* bit 0 */
-			break;
-		case 1:
-			bucket = 
-			(((hash >> 2) & 1) << 10) |		/* bit 10 */
-			(((hash >> 12) & 1) << 9) |		/* bit 9 */
-			(((hash >> 0 ) & 1) << 8) |		/* bit 8 */
-			(((hash >> 10) & 1) << 7) |		/* bit 7 */
-			(((hash >> 8 ) & 1) << 6) |		/* bit 6 */
-			(((hash >> 7 ) & 1) << 5) |		/* bit 5 */
-			(((hash >> 6 ) & 1) << 4) |		/* bit 4 */
-			(((hash >> 5 ) & 1) << 3) |		/* bit 3 */
-			(((hash >> 4 ) & 1) << 2) |		/* bit 2 */
-			(((hash >> 3 ) & 1) << 1) |		/* bit 1 */
-			(( hash >> 1 ) & 1); 			/* bit 0 */
-			break;
-		case 2:
-			bucket = 
-			(((hash >> 13) & 1) << 10)|		/* bit 10 */
-			(((hash >> 15) & 1) << 9) |		/* bit 9 */
-			(((hash >> 3 ) & 1) << 8) |		/* bit 8 */
-			(((hash >> 14) & 1) << 7) |		/* bit 7 */
-			(((hash >> 12) & 1) << 6) |		/* bit 6 */
-			(((hash >> 11) & 1) << 5) |		/* bit 5 */
-			(((hash >> 10) & 1) << 4) |		/* bit 4 */
-			(((hash >> 9 ) & 1) << 3) |		/* bit 3 */
-			(((hash >> 8 ) & 1) << 2) |		/* bit 2 */
-			(((hash >> 7 ) & 1) << 1) |		/* bit 1 */
-			(( hash >> 5 ) & 1); 			/* bit 0 */
-			break;
-		case 3:
-			bucket = 
-			(((hash >> 10) & 1) << 10)|		/* bit 10 */
-			(((hash >> 8 ) & 1) << 9) |		/* bit 9 */
-			(((hash >> 7 ) & 1) << 8) |		/* bit 8 */
-			(((hash >> 13) & 1) << 7) |		/* bit 7 */
-			(((hash >> 12) & 1) << 6) |		/* bit 6 */
-			(((hash >> 10) & 1) << 5) |		/* bit 5 */
-			(((hash >> 9 ) & 1) << 4) |		/* bit 4 */
-			(((hash >> 6 ) & 1) << 3) |		/* bit 3 */
-			(((hash >> 5 ) & 1) << 2) |		/* bit 2 */
-			(((hash >> 3 ) & 1) << 1) |		/* bit 1 */
-			(( hash >> 2 ) & 1); 			/* bit 0 */
-			break;
-		default:
-			/* treat as case 0 */
-			bucket = 
-			(((hash >> 7) & 1) << 10) |		/* bit 10 */
-			(((hash >> 11) & 1) << 9) |		/* bit 9 */
-			(((hash >> 3 ) & 1) << 8) |		/* bit 8 */
-			(((hash >> 14) & 1) << 7) |		/* bit 7 */
-			(((hash >> 12) & 1) << 6) |		/* bit 6 */
-			(((hash >> 10) & 1) << 5) |		/* bit 5 */
-			(((hash >> 8 ) & 1) << 4) |		/* bit 4 */
-			(((hash >> 6 ) & 1) << 3) |		/* bit 3 */
-			(((hash >> 4 ) & 1) << 2) |		/* bit 2 */
-			(((hash >> 2 ) & 1) << 1) |		/* bit 1 */
-			(( hash >> 0 ) & 1); 			/* bit 0 */
-			break;
-	}
-	return bucket;
-}
-
-GT_U16 dbNumMap(GT_U32 bucket, GT_U32 dbNum)
-{
-	return (GT_U16)(bucket + dbNum);
-}
-
-GT_U16 runQDHash(GT_U8* eaddr, GT_U16 dbNum, int bSize, GT_U16* pHash, GT_U16* preBucket, GT_U16* posBucket)
-{
-	GT_U16 hash, bucket;
-
-	hash = hashFunction(eaddr);
-	if (pHash)
-		*pHash = hash;
-	bucket = hashToBucket(hash,hashMode);
-	bucket &= (bSize-1);
-	if (preBucket)
-		*preBucket = bucket;
-	bucket = dbNumMap(bucket,dbNum);
-	if (posBucket)
-		*posBucket = bucket;
-	bucket &= (bSize-1);
-
-	return bucket;
-}
-
-GT_U16 hashTest(unsigned int maxMacs, int maxDbNum, int bSize)
-{
-	char eaddr[6] = {0,0,0,0,0,0};
-	char buckets[MAX_BUCKET_SIZE];
-	GT_U32 i, dbNum;
-	GT_U16 hash, bucket, tmpBucket;
-
-	gtMemSet(buckets,0,MAX_BUCKET_SIZE);
-
-	for(dbNum=0; dbNum<(GT_U32)maxDbNum; dbNum++)
-	{
-		MSG_PRINT(("DBNum %i:\n", dbNum));
-		for(i=1; i<maxMacs; i++)
-		{
-			eaddr[2] = (char)((i >> 24) & 0xff);
-			eaddr[3] = (char)((i >> 16) & 0xff);
-			eaddr[4] = (char)((i >> 8) & 0xff);
-			eaddr[5] = (char)(i & 0xff);
-			tmpBucket=runQDHash((GT_U8*)eaddr, (GT_U16)dbNum, bSize, &hash, &bucket, NULL);
-			buckets[tmpBucket]++;
-			MSG_PRINT(("EADDR : %02x-%02x-%02x-%02x, ", eaddr[2],eaddr[3],eaddr[4],eaddr[5]));
-			MSG_PRINT(("Hash : %03x, ", hash));
-			MSG_PRINT(("bucket : %03x, ", bucket));
-			MSG_PRINT(("bins : %02x\n", buckets[tmpBucket]-1));
-		}
-
-	}
-
-	return 0;
-}
-
-GT_U16 hashFindEntriesInBucket(unsigned int maxMacs, int bucketNum, int bSize)
-{
-	char eaddr[6] = {0,0,0,0,0,0};
-	char buckets[MAX_BUCKET_SIZE];
-	GT_U32 i, dbNum;
-	GT_U16 hash, bucket, tmpBucket;
-
-	gtMemSet(buckets,0,MAX_BUCKET_SIZE);
-
-	dbNum = 0;
-	MSG_PRINT(("DBNum %i:\n", dbNum));
-	for(i=1; i<maxMacs; i++)
-	{
-		eaddr[2] = (char)((i >> 24) & 0xff);
-		eaddr[3] = (char)((i >> 16) & 0xff);
-		eaddr[4] = (char)((i >> 8) & 0xff);
-		eaddr[5] = (char)(i & 0xff);
-		tmpBucket=runQDHash((GT_U8*)eaddr, (GT_U16)dbNum, bSize, &hash, &bucket, NULL);
-		buckets[tmpBucket]++;
-		if (tmpBucket != bucketNum)
-			continue;
-		MSG_PRINT(("EADDR : %02x-%02x-%02x-%02x, ", eaddr[2],eaddr[3],eaddr[4],eaddr[5]));
-		MSG_PRINT(("Hash : %03x, ", hash));
-		MSG_PRINT(("bucket : %03x, ", bucket));
-		MSG_PRINT(("bins : %02x\n", buckets[tmpBucket]-1));
-	}
-
-	return 0;
-}
-
-void displayHash(char* eaddr, GT_U16 dbNum, GT_U32 bSize)
-{
-	GT_U16 hash, posBucket, preBucket;
-
-	posBucket=runQDHash(eaddr, dbNum, bSize, &hash, &preBucket, NULL);
-	MSG_PRINT(("EADDR : %02x-%02x-%02x-%02x, ", eaddr[2],eaddr[3],eaddr[4],eaddr[5]));
-	MSG_PRINT(("Hash : %03x, ", hash));
-	MSG_PRINT(("bucket : %03x, ", preBucket));
-	MSG_PRINT(("bucket(db) : %03x, ", posBucket));
-	MSG_PRINT(("bSize : %03x\n", bSize));
-}
-
-GT_U16 hashWrap(int bSize, int entry)
-{
-	char eaddr[6] = {0,0,0,0,0,0};
-	char buckets[MAX_BUCKET_SIZE];
-	GT_U32 i, maxMacs;
-	GT_U16 hash, bucket, tmpBucket, preBucket;
-	int wrapping = 0;
-	maxMacs =0xFFFFFFFF;
-	gtMemSet(buckets,0,MAX_BUCKET_SIZE);
-
-	MSG_PRINT(("Wrapped Entry :\n"));
-	for(i=1; i<maxMacs; i++)
-	{
-		eaddr[2] = (char)((i >> 24) & 0xff);
-		eaddr[3] = (char)((i >> 16) & 0xff);
-		eaddr[4] = (char)((i >> 8) & 0xff);
-		eaddr[5] = (char)(i & 0xff);
-		tmpBucket = runQDHash(eaddr, 15, bSize, &hash, &preBucket, &bucket);
-		buckets[tmpBucket]++;
-		if(bucket != tmpBucket)
-		{
-			wrapping++;
-			MSG_PRINT(("EADDR : %02x-%02x-%02x-%02x, ", eaddr[2],eaddr[3],eaddr[4],eaddr[5]));
-			MSG_PRINT(("Hash : %03x, ", hash));
-			MSG_PRINT(("bucket : %03x, ", preBucket));
-			MSG_PRINT(("bucket(db) : %03x, ", tmpBucket));
-			MSG_PRINT(("bins : %02x\n", buckets[tmpBucket]-1));
-		}
-		if (wrapping >= entry)
-			break;
-	}
-
-	return wrapping;
-}
-
-/*
-	This routine will create ATU Entry List.
-	Input
-		entrySize - entry size for each dbNum
-		dbNumSize - number of DBNums
-		sameMacs  - how many same MAC addresses are in the ATU database.
-				 	Each of the same addresses are beloging to different DBNum.
-*/
-GT_U16 createATUList(GT_QD_DEV *dev,TEST_ATU_ENTRY entry[], GT_U16 entrySize, GT_U16 dbNumSize, GT_U16 sameMacs, GT_U16 bSize)
-{
-	GT_U16 i;
-	char* buckets;
-	GT_U16 dynamicMacs = 0;
-	GT_U16 bucket,dbNum,binSize;
-	GT_BOOL	exPrio, fqPri;
-
-	if(dbNumSize == 0)
-		return entrySize+1;
-	if(entrySize < sameMacs)
-		return entrySize+1;
-
-	buckets = (char*)malloc(MAX_BUCKET_SIZE);
-	if(buckets == NULL)
-	{
-		printf("No more available memories\n");
-		return -1;
-	}
-	gtMemSet(buckets,0,MAX_BUCKET_SIZE);
-
-#ifndef TEST_DEBUG
-	srand((unsigned)time(NULL));
-#else
-	srand((unsigned)1);
-#endif
-
-	binSize = 4;
-	switch(dev->deviceId)
-	{
-		case GT_88E6131:
-		case GT_88E6108:
-			hashMode = 1;
-			exPrio = GT_FALSE;
-			fqPri = GT_FALSE;
-			break;
-		case GT_88E6031:
-		case GT_88E6061:
-			hashMode = 1;
-			exPrio = GT_TRUE;
-			fqPri = GT_FALSE;
-			break;
-		case GT_88E6035:
-		case GT_88E6055:
-		case GT_88E6065:
-			hashMode = 1;
-			exPrio = GT_TRUE;
-			fqPri = GT_TRUE;
-			break;
-		default:
-			exPrio = GT_FALSE;
-			fqPri = GT_FALSE;
-			hashMode = 0;
-			break;
-	}			
-
-	for(i=0; i<entrySize; i++)
-	{
-		if(sameMacs)
-		{
-			memset(&entry[0].atuEntry[i],0,sizeof(GT_ATU_ENTRY));
-			
-			*(GT_U16*)entry[0].atuEntry[i].macAddr.arEther = (GT_U16)rand();
-			*(GT_U16*)(entry[0].atuEntry[i].macAddr.arEther+2) = (GT_U16)(rand() & 0xFFFF);
-
-			do 
-			{
-				GT_U16 tmpBucket[256];
-				*(GT_U16*)(entry[0].atuEntry[i].macAddr.arEther+4) = (GT_U16)(rand() & 0xFFFF);
-
-				for (dbNum=0; dbNum<dbNumSize; dbNum++)
-				{
-					/* In current implementation, each dbNum will located in different bucket. */
-
-					tmpBucket[dbNum] = runQDHash(entry[0].atuEntry[i].macAddr.arEther, dbNum, bSize, NULL,NULL,NULL);
-					if (buckets[tmpBucket[dbNum]] >= binSize)
-					{
-						/* if bucket is full, find another entry. */
-						break;
-					}
-					else
-					{
-						continue;
-					}
-				}
-
-				if (dbNum == dbNumSize)
-				{
-					/* we found a entry which meets our requirement. */
-					entry[0].atuEntry[i].portVec = (GT_U32)(rand() & 0x3FF) % (1<<dev->numOfPorts);
-					if(entry[0].atuEntry[i].portVec == 0)
-						entry[0].atuEntry[i].portVec = 0x3;
-					if(!exPrio)
-					{
-						entry[0].atuEntry[i].prio = (GT_U8)(rand() & 0x3);
-					}
-					else
-					{
-						entry[0].atuEntry[i].exPrio.macQPri = (GT_U8)(rand() & 0x3);
-						if(fqPri)
-						{
-							entry[0].atuEntry[i].exPrio.macFPri = (GT_U8)(rand() & 0x7);
-							entry[0].atuEntry[i].exPrio.useMacFPri = GT_TRUE;
-						}
-					}
-
-					if(entry[0].atuEntry[i].macAddr.arEther[0] & 0x1)
-					{
-						entry[0].atuEntry[i].entryState.mcEntryState = GT_MC_STATIC;
-					}
-					else
-					{
-						entry[0].atuEntry[i].entryState.ucEntryState = GT_UC_DYNAMIC;
-						dynamicMacs+=dbNumSize;
-					}
-
-					buckets[tmpBucket[0]]++;
-					for (dbNum=1; dbNum<dbNumSize; dbNum++)
-					{
-						buckets[tmpBucket[dbNum]]++;
-						memcpy(&entry[dbNum].atuEntry[i],&entry[0].atuEntry[i],sizeof(GT_ATU_ENTRY));
-						entry[dbNum].atuEntry[i].DBNum = (GT_U8)dbNum;
-					}
-#ifdef TEST_DEBUG
-					MSG_PRINT(("MAC : %02x-%02x-%02x-%02x-%02x-%02x, ",
-									entry[dbNum].atuEntry[i].macAddr.arEther[0],
-									entry[dbNum].atuEntry[i].macAddr.arEther[1],
-									entry[dbNum].atuEntry[i].macAddr.arEther[2],
-									entry[dbNum].atuEntry[i].macAddr.arEther[3],
-									entry[dbNum].atuEntry[i].macAddr.arEther[4],
-									entry[dbNum].atuEntry[i].macAddr.arEther[5] ));
-					MSG_PRINT(("dbNum 0 ~ %x, bucket %03x ~ %03x\n", dbNumSize, tmpBucket[0], tmpBucket[dbNumSize-1]));
-#endif
-					break;	/* we are done with current dbNum. so exit the while loop */
-				}
-			} while (1);
-
-			sameMacs--;
-		}
-		else
-		{
-			for(dbNum=0; dbNum<dbNumSize; dbNum++)
-			{
-				memset(&entry[dbNum].atuEntry[i],0,sizeof(GT_ATU_ENTRY));
-			
-				*(GT_U16*)entry[dbNum].atuEntry[i].macAddr.arEther = (GT_U16)rand();
-				*(GT_U16*)(entry[dbNum].atuEntry[i].macAddr.arEther+2) = (GT_U16)(rand() & 0xFFFF);
-
-				do 
-				{
-					*(GT_U16*)(entry[dbNum].atuEntry[i].macAddr.arEther+4) = (GT_U16)(rand() & 0xFFFF);
-
-					bucket=runQDHash(entry[dbNum].atuEntry[i].macAddr.arEther, dbNum, bSize, NULL,NULL,NULL);
-					if (buckets[bucket] >= binSize)
-						continue;
-					else
-					{
-#ifdef TEST_DEBUG
-						MSG_PRINT(("MAC : %02x-%02x-%02x-%02x-%02x-%02x, ",
-									entry[dbNum].atuEntry[i].macAddr.arEther[0],
-									entry[dbNum].atuEntry[i].macAddr.arEther[1],
-									entry[dbNum].atuEntry[i].macAddr.arEther[2],
-									entry[dbNum].atuEntry[i].macAddr.arEther[3],
-									entry[dbNum].atuEntry[i].macAddr.arEther[4],
-									entry[dbNum].atuEntry[i].macAddr.arEther[5] ));
-						MSG_PRINT(("dbNum : %04x, ", dbNum));
-						MSG_PRINT(("bucket : %03x, bins : %02x\n", bucket,buckets[bucket]));
-#endif
-						buckets[bucket]++;
-						break;
-					}
-
-				} while (1);
-
-				entry[dbNum].atuEntry[i].portVec = (GT_U32)(rand() & 0x3FF) % (1<<dev->numOfPorts);
-				if(entry[dbNum].atuEntry[i].portVec == 0)
-					entry[dbNum].atuEntry[i].portVec = 0x3;
-				if(!exPrio)
-				{
-					entry[dbNum].atuEntry[i].prio = (GT_U8)(rand() & 0x3);
-				}
-				else
-				{
-					entry[dbNum].atuEntry[i].exPrio.macQPri = (GT_U8)(rand() & 0x3);
-					if(fqPri)
-					{
-						entry[dbNum].atuEntry[i].exPrio.macFPri = (GT_U8)(rand() & 0x7);
-						entry[dbNum].atuEntry[i].exPrio.useMacFPri = GT_TRUE;
-					}
-				}
-				entry[dbNum].atuEntry[i].DBNum = (GT_U8)dbNum;
-
-				if(entry[dbNum].atuEntry[i].macAddr.arEther[0] & 0x1)
-				{
-					entry[dbNum].atuEntry[i].entryState.mcEntryState = GT_MC_STATIC;
-				}
-				else
-				{
-					entry[dbNum].atuEntry[i].entryState.ucEntryState = GT_UC_DYNAMIC;
-					dynamicMacs++;
-				}
-			}
-		}
-	}
-
-	free(buckets);
-
-	return dynamicMacs;
-}
-
-
-GT_STATUS testFixedAtu(GT_QD_DEV *dev,GT_U8 dbNum,GT_U8 atuSize)
-{
-	GT_STATUS status;
-	GT_ATU_ENTRY macEntry[16];
-	int i;
-	GT_U32 u32Data1;
-
-	/* Set ATU Size will cause ATU reset and SW reset, so call before any other setup. */
-	MSG_PRINT(("Setting ATU Size\n"));
-	if((status = gfdbSetAtuSize(dev,atuSize)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAtuSize returned fail.\n"));
-		return status;
-	}
-
-	/* Disable Aging */
-	MSG_PRINT(("Disable Aging Timeout... \n"));
-	if((status = gfdbSetAgingTimeout(dev,0)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAgingTimeout returned fail.\n"));
-		return status;
-	}
-
-	/* Disable Learning */
-	MSG_PRINT(("Disable Learning... \n"));
-	if((status = gfdbLearnEnable(dev,GT_FALSE)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbSetAtuSize returned fail.\n"));
-		return status;
-	}
-
-	/* Flush all addresses from the ATU table. */
-	MSG_PRINT(("Flush out all the entries in the ATU Table ... \n"));
-	if((status = gfdbFlush(dev,GT_FLUSH_ALL)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbFlush returned fail.\n"));
-		return status;
-	}
-
-	/* Get Atu Dynamic Count, which should be 0, since we flush them all. */
-	if((status = gfdbGetAtuDynamicCount(dev,&u32Data1)) != GT_OK)
-	{
-		MSG_PRINT(("gfdbGetAtuDynamicCount returned fail.\n"));
-		return status;
-	}
-
-	MSG_PRINT(("Atu Dynamic Count : %d.\n", u32Data1));
-
-	/* Now ATU table is clean. Play with our own MAC entries */	
-	MSG_PRINT(("Setup Testing Table... \n"));
-
-	gtMemSet(macEntry,0,sizeof(macEntry));
-
-	/* bucket 0xee */
-	*(GT_U16*)&macEntry[0].macAddr.arEther[4] = 0xd1b;
-	macEntry[0].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[0].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[1].macAddr.arEther[4] = 0xd1e;
-	macEntry[1].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[1].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[2].macAddr.arEther[4] = 0xddb;
-	macEntry[2].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[2].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[3].macAddr.arEther[4] = 0xdde;
-	macEntry[3].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[3].DBNum = dbNum;
-
-	/* bucket 0xef */
-	*(GT_U16*)&macEntry[4].macAddr.arEther[4] = 0xd1a;
-	macEntry[4].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[4].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[5].macAddr.arEther[4] = 0xd1f;
-	macEntry[5].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[5].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[6].macAddr.arEther[4] = 0xdda;
-	macEntry[6].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[6].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[7].macAddr.arEther[4] = 0xddf;
-	macEntry[7].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[7].DBNum = dbNum;
-
-	/* bucket 0xf0 */
-	*(GT_U16*)&macEntry[8].macAddr.arEther[4] = 0x440;
-	macEntry[8].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[8].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[9].macAddr.arEther[4] = 0x485;
-	macEntry[9].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[9].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[10].macAddr.arEther[4] = 0x1123;
-	macEntry[10].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[10].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[11].macAddr.arEther[4] = 0x1223;
-	macEntry[11].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[11].DBNum = dbNum;
-
-	/* bucket 0xf0 */
-	*(GT_U16*)&macEntry[12].macAddr.arEther[4] = 0x441;
-	macEntry[12].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[12].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[13].macAddr.arEther[4] = 0x484;
-	macEntry[13].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[13].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[14].macAddr.arEther[4] = 0xb41;
-	macEntry[14].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[14].DBNum = dbNum;
-
-	*(GT_U16*)&macEntry[15].macAddr.arEther[4] = 0x444;
-	macEntry[15].entryState.ucEntryState = GT_UC_DYNAMIC;
-	macEntry[15].DBNum = dbNum;
-
-	
-	for(i=0; i<16; i++)
-	{
-		displayHash(macEntry[i].macAddr.arEther,dbNum,64<<atuSize);
-		if((status = gfdbAddMacEntry(dev,&macEntry[i])) != GT_OK)
-		{
-			MSG_PRINT(("gfdbAddMacEntry returned fail.\n"));
-			return status;
-		}
-	}
-
-	testDisplayATUList(dev);
-	return GT_OK;
-
-}
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/vctTest.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/vctTest.c
deleted file mode 100644
index 589ad61..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Diag/vctTest.c
+++ /dev/null
@@ -1,181 +0,0 @@
-#include <Copyright.h>
-/********************************************************************************
-* testApi.c
-*
-* DESCRIPTION:
-*       API test functions
-*
-* DEPENDENCIES:   Platform.
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-#include "msSample.h"
-
-void displayVCTResult
-(
-	GT_TEST_STATUS *cableStatus, 
-	GT_CABLE_LEN *cableLen
-)
-{
-	switch(*cableStatus)
-	{
-		case GT_TEST_FAIL:
-			MSG_PRINT(("Cable Test Failed\n"));
-			break;
-		case GT_NORMAL_CABLE:
-			MSG_PRINT(("Cable Test Passed. No problem found.\n"));
-			switch(cableLen->normCableLen)
-			{
-				case GT_LESS_THAN_50M:
-					MSG_PRINT(("Cable Length is less than 50M.\n"));
-					break;
-				case GT_50M_80M:
-					MSG_PRINT(("Cable Length is between 50M and 80M.\n"));
-					break;
-				case GT_80M_110M:
-					MSG_PRINT(("Cable Length is between 80M and 110M.\n"));
-					break;
-				case GT_110M_140M:
-					MSG_PRINT(("Cable Length is between 110M and 140M.\n"));
-					break;
-				case GT_MORE_THAN_140:
-					MSG_PRINT(("Cable Length is over 140M.\n"));
-					break;
-				default:
-					MSG_PRINT(("Cable Length is unknown.\n"));
-					break;
-			}
-			break;
-		case GT_IMPEDANCE_MISMATCH:
-			MSG_PRINT(("Cable Test Passed with Impedance Mismatch.\n"));
-			MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
-			break;
-		case GT_OPEN_CABLE:
-			MSG_PRINT(("Cable Test Passed. Cable is open.\n"));
-			MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
-			break;
-		case GT_SHORT_CABLE:
-			MSG_PRINT(("Cable Test Passed. Cable is short.\n"));
-			MSG_PRINT(("Approximatly %i meters from the tested port.\n",cableLen->errCableLen));
-			break;
-		default:
-			MSG_PRINT(("Unknown Test Result.\n"));
-			break;
-	}
-}
-
-
-GT_STATUS vctTest(GT_QD_DEV *dev,GT_LPORT port)
-{
-	GT_STATUS status;
-    GT_CABLE_STATUS cableStatus;
-	int i;
-
-	if (dev == 0)
-	{
-		MSG_PRINT(("QD driver is not initialized\n"));
-		return GT_FAIL;
-#if 0
-		dev = &qdDev;
-		memset(dev, 0, sizeof(GT_QD_DEV));
-		dev->fgtReadMii = gtBspReadMii;
-		dev->fgtWriteMii = gtBspWriteMii;
-#endif
-	}
-
-	/*
-	 *	Start and get Cable Test Result
-	*/
-	if((status = gvctGetCableDiag(dev,port, &cableStatus)) != GT_OK)
-	{
-		MSG_PRINT(("gvctGetCableDiag return Failed\n"));
-		return status;
-	}
-
-	MSG_PRINT(("Cable Test Result for Port %i\n",port));
-
-	if(cableStatus.phyType == PHY_100M)
-	{
-		MSG_PRINT(("RX PAIR :\n"));
-		displayVCTResult(&cableStatus.cableStatus[MDI_RX_PAIR],
-									&cableStatus.cableLen[MDI_RX_PAIR]);
-		MSG_PRINT(("TX PAIR :\n"));
-		displayVCTResult(&cableStatus.cableStatus[MDI_TX_PAIR],
-									&cableStatus.cableLen[MDI_TX_PAIR]);
-	}
-	else /* phyType must be PHY_1000M */
-	{
-		for(i=0; i<GT_MDI_PAIR_NUM; i++)
-		{
-			MSG_PRINT(("MDI PAIR %i:\n",i));
-			displayVCTResult(&cableStatus.cableStatus[i],
-									&cableStatus.cableLen[i]);
-		}
-	}
-
-	return GT_OK;
-}
-
-
-GT_STATUS getExtendedStatus(GT_QD_DEV *dev,GT_LPORT port)
-{
-	GT_STATUS status;
-	GT_1000BT_EXTENDED_STATUS extendedStatus;
-	int i;
-
-	if (dev == 0)
-	{
-		MSG_PRINT(("QD driver is not initialized\n"));
-		return GT_FAIL;
-#if 0
-		dev = &qdDev;
-		memset(dev, 0, sizeof(GT_QD_DEV));
-		dev->fgtReadMii = gtBspReadMii;
-		dev->fgtWriteMii = gtBspWriteMii;
-#endif
-	}
-
-	/*
-	 * 	Start getting Extended Information.
-	 */
-	if((status = gvctGet1000BTExtendedStatus(dev,port, &extendedStatus)) != GT_OK)
-	{
-		MSG_PRINT(("gvctGetCableDiag return Failed\n"));
-		return status;
-	}
-
-	if (!extendedStatus.isValid)
-	{
-		MSG_PRINT(("Not able to get Extended Status.\n"));
-		return status;
-
-	}
-
-	/* Pair Polarity */
-	MSG_PRINT(("Pair Polarity:\n"));
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		MSG_PRINT(("MDI PAIR %i: %s\n",i,
-				(extendedStatus.pairPolarity[i] == GT_POSITIVE)?"Positive":"Negative"));
-	}
-	
-	/* Pair Swap */
-	MSG_PRINT(("Pair Swap:\n"));
-	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
-	{
-		MSG_PRINT(("CHANNEL PAIR %i: %s\n",i,
-				(extendedStatus.pairSwap[i] == GT_STRAIGHT_CABLE)?"Straight":"Crossover"));
-	}
-	
-	/* Pair Polarity */
-	MSG_PRINT(("Pair Skew:\n"));
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		MSG_PRINT(("MDI PAIR %i: %ins\n",i,extendedStatus.pairSkew[i]));
-	}
-	
-	return GT_OK;
-}
-
-
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/Copyright.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/Copyright.h
old mode 100644
new mode 100755
index 4875a66..5802480
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/Copyright.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/Copyright.h
@@ -54,7 +54,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef _msCopyright_h
 #define _msCopyright_h
 
-#define MSAPI_COPYRIGHT "Copyright 2000~2009, Marvell International Ltd."
-#define MSAPI_VERSION "2.8b"
+#define MSAPI_COPYRIGHT "Copyright 2000~2011, Marvell International Ltd."
+#define MSAPI_VERSION "3.0D"
 
 #endif /* _msCopyright_h */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtMad.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtMad.h
new file mode 100755
index 0000000..5ae3d8b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtMad.h
@@ -0,0 +1,214 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtMad.h
+*
+* DESCRIPTION:
+*       MAD API header file.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+);
+GT_STATUS gvctGetAdvExtendedStatus_mad
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+);
+#include <Copyright.h>
+
+
+GT_STATUS gprtPhyReset_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
+);
+GT_STATUS gprtSetPortLoopback_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+);
+
+GT_STATUS gprtSetPortSpeed_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_SPEED speed
+);
+GT_STATUS gprtPortAutoNegEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+);
+GT_STATUS gprtPortPowerDown_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+);
+GT_STATUS gprtPortRestartAutoNeg_mad
+( 
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+);
+GT_STATUS gprtSetPortDuplexMode_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+);
+GT_STATUS gprtSetPortAutoMode_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
+);
+GT_STATUS gprtSetPause_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_PAUSE_MODE state
+);
+GT_STATUS gprtSetDTEDetect_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+);
+GT_STATUS gprtGetDTEDetectStatus_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+);
+GT_STATUS gprtSetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+);
+GT_STATUS gprtGetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+);
+GT_STATUS gprtSetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+);
+GT_STATUS gprtGetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+);
+GT_STATUS gprtSet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+);
+GT_STATUS gprtGet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+);
+GT_STATUS gprtGetPhyLinkStatus_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+);
+GT_STATUS gprtSetPktGenEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+);
+GT_STATUS gprtGetSerdesMode_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
+);
+GT_STATUS gprtSetSerdesMode_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
+);
+GT_STATUS gprtGetPhyReg_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+GT_STATUS gprtSetPhyReg_mad
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            inData
+);
+GT_STATUS gprtGetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+);
+GT_STATUS gprtSetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 inData
+);
+GT_STATUS gprtPhyIntEnable_mad
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT    port,
+IN GT_U16    intType
+);
+GT_STATUS gprtGetPhyIntStatus_mad
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+);
+GT_STATUS gprtGetPhyIntPortSummary_mad
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+);
+GT_STATUS gvctGetCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+GT_STATUS gvctGet1000BTExtendedStatus_mad
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtPTP.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtPTP.h
new file mode 100755
index 0000000..09ca56c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/gtPTP.h
@@ -0,0 +1,499 @@
+#ifdef CONFIG_AVB_FPGA
+
+/*******************************************************************************
+* gptpGetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine gets interrupt status of PTP logic.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        ptpInt    - PTP Int Status
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntStatus
+*
+* DESCRIPTION:
+*       This routine sets interrupt status of PTP logic.
+*
+* INPUTS:
+*    ptpInt    - PTP Int Status
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntStatus
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
+);
+
+/*******************************************************************************
+* gptpSetFPGAIntEn
+*
+* DESCRIPTION:
+*       This routine enables PTP interrupt.
+*
+* INPUTS:
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetFPGAIntEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
+);
+
+/*******************************************************************************
+* gptpGetClockSource
+*
+* DESCRIPTION:
+*       This routine gets PTP Clock source setup.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
+);
+
+/*******************************************************************************
+* gptpSetClockSource
+*
+* DESCRIPTION:
+*       This routine sets PTP Clock source setup.
+*
+* INPUTS:
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetClockSource
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
+);
+
+/*******************************************************************************
+* gptpGetP9Mode
+*
+* DESCRIPTION:
+*       This routine gets Port 9 Mode.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
+);
+
+/*******************************************************************************
+* gptpSetP9Mode
+*
+* DESCRIPTION:
+*       This routine sets Port 9 Mode.
+*
+* INPUTS:
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetP9Mode
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
+);
+
+/*******************************************************************************
+* gptpReset
+*
+* DESCRIPTION:
+*       This routine performs software reset for PTP logic.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpReset
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjustEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PTP Duty Cycle Adjustment.
+*
+* INPUTS:
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjustEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
+);
+
+/*******************************************************************************
+* gptpGetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine gets clock duty cycle adjustment value.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpSetCycleAdjust
+*
+* DESCRIPTION:
+*       This routine sets clock duty cycle adjustment value.
+*
+* INPUTS:
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetCycleAdjust
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
+);
+
+/*******************************************************************************
+* gptpGetPLLEn
+*
+* DESCRIPTION:
+*       This routine checks if PLL is enabled.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpGetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
+);
+
+/*******************************************************************************
+* gptpSetPLLEn
+*
+* DESCRIPTION:
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
+*
+*******************************************************************************/
+GT_STATUS gptpSetPLLEn
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
+);
+
+/*******************************************************************************
+* gptpGetDDSReg
+*
+* DESCRIPTION:
+*       This routine gets DDS register data.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*
+* OUTPUTS:
+*    ddsData    - register data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpGetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
+);
+
+/*******************************************************************************
+* gptpSetDDSReg
+*
+* DESCRIPTION:
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*
+* INPUTS:
+*    ddsReg    - DDS Register
+*    ddsData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetDDSReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
+);
+
+/*******************************************************************************
+* gptpUpdateDDSReg
+*
+* DESCRIPTION:
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*
+* INPUTS:
+*    none
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpUpdateDDSReg
+(
+    IN  GT_QD_DEV     *dev
+);
+
+/*******************************************************************************
+* gptpSetADFReg
+*
+* DESCRIPTION:
+*       This routine sets ADF4156 register data.
+*
+* INPUTS:
+*    adfData    - register data
+*
+* OUTPUTS:
+*    none
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gptpSetADFReg
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
+);
+
+#endif  /*  CONFIG_AVB_FPGA */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvConfig.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvConfig.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvEvents.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvEvents.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h
old mode 100644
new mode 100755
index a2c6774..6826403
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtDrvSwRegs.h
@@ -15,221 +15,285 @@
 #define __gtDrvSwRegsh
 
 /* QuarterDeck Per Port Registers */
-#define QD_REG_PORT_STATUS		0x0
-#define QD_REG_PCS_CONTROL		0x1		/* for Sapphire family */
-#define QD_REG_LIMIT_PAUSE_CONTROL		0x2		/* Jamming control register */
-#define QD_REG_SWITCH_ID		0x3
-#define QD_REG_PORT_CONTROL		0x4
-#define QD_REG_PORT_CONTROL1		0x5
-#define QD_REG_PORT_VLAN_MAP		0x6
-#define QD_REG_PVID			0x7
-#define QD_REG_PORT_CONTROL2		0x8	/* for Sapphire family */
-#define QD_REG_INGRESS_RATE_CTRL	0x9	/* for Sapphire family */
-#define QD_REG_EGRESS_RATE_CTRL		0xA	/* for Sapphire family */
-#define QD_REG_RATE_CTRL0		0x9
-#define QD_REG_RATE_CTRL		0xA
-#define QD_REG_PAV			0xB
-#define QD_REG_PORT_ATU_CONTROL		0xC
-#define QD_REG_PRI_OVERRIDE		0xD
-#define QD_REG_POLICY_CONTROL	0xE
-#define QD_REG_PORT_ETH_TYPE	0xF
-#define QD_REG_RX_COUNTER		0x10
-#define QD_REG_TX_COUNTER		0x11
-#define QD_REG_DROPPED_COUNTER	0x12
-
-#define QD_REG_INDISCARD_LO_COUNTER		0x10
-#define QD_REG_INDISCARD_HI_COUNTER		0x11
-#define QD_REG_INFILTERED_COUNTER		0x12
-#define QD_REG_OUTFILTERED_COUNTER		0x13
-
-#define QD_REG_LED_CONTROL		0x16
-
-#define QD_REG_Q_COUNTER		0x1B
-#define QD_REG_RATE_CONTROL		0x0A
-#define QD_REG_PORT_ASSOCIATION		0x0B
-#define QD_REG_IEEE_PRI_REMAP_3_0	0x18	/* for Sapphire family */
-#define QD_REG_IEEE_PRI_REMAP_7_4	0x19	/* for Sapphire family */
-
-#define QD_REG_PROVIDER_TAG		0x1A		/* for Schooner family */
+#define QD_REG_PORT_STATUS        0x0
+#define QD_REG_PCS_CONTROL        0x1        /* for Sapphire family */
+#define QD_REG_LIMIT_PAUSE_CONTROL        0x2        /* Jamming control register */
+#define QD_REG_SWITCH_ID        0x3
+#define QD_REG_PORT_CONTROL        0x4
+#define QD_REG_PORT_CONTROL1        0x5
+#define QD_REG_PORT_VLAN_MAP        0x6
+#define QD_REG_PVID            0x7
+#define QD_REG_PORT_CONTROL2        0x8    /* for Sapphire family */
+#define QD_REG_INGRESS_RATE_CTRL    0x9    /* for Sapphire family */
+#define QD_REG_EGRESS_RATE_CTRL        0xA    /* for Sapphire family */
+#define QD_REG_RATE_CTRL0        0x9
+#define QD_REG_RATE_CTRL        0xA
+#define QD_REG_PAV            0xB
+#define QD_REG_PORT_ATU_CONTROL        0xC
+#define QD_REG_PRI_OVERRIDE        0xD
+#define QD_REG_POLICY_CONTROL    0xE
+#define QD_REG_PORT_ETH_TYPE    0xF
+#define QD_REG_RX_COUNTER        0x10
+#define QD_REG_TX_COUNTER        0x11
+#define QD_REG_DROPPED_COUNTER    0x12
+
+#define QD_REG_INDISCARD_LO_COUNTER        0x10
+#define QD_REG_INDISCARD_HI_COUNTER        0x11
+#define QD_REG_INFILTERED_COUNTER        0x12
+#define QD_REG_OUTFILTERED_COUNTER        0x13
+
+#define QD_REG_LED_CONTROL        0x16
+
+#define QD_REG_Q_COUNTER        0x1B
+#define QD_REG_RATE_CONTROL        0x0A
+#define QD_REG_PORT_ASSOCIATION        0x0B
+#define QD_REG_IEEE_PRI_REMAP_3_0    0x18    /* for Sapphire family */
+#define QD_REG_IEEE_PRI_REMAP_7_4    0x19    /* for Sapphire family */
+
+#define QD_REG_PROVIDER_TAG        0x1A        /* for Schooner family */
 
 /* QuarterDeck Global Registers */
-#define QD_REG_GLOBAL_STATUS		0x0
-#define QD_REG_MACADDR_01		0x1
-#define QD_REG_MACADDR_23		0x2
-#define QD_REG_MACADDR_45		0x3
-#define QD_REG_GLOBAL_CONTROL		0x4
-#define QD_REG_GLOBAL_CONTROL2		0x1C	/* for Sapphire, Schooner family */
-#define QD_REG_CORETAG_TYPE		0x19		/* for Ruby family */
-#define QD_REG_IP_MAPPING_TABLE	0x19		/* for Amber family */
-#define QD_REG_MONITOR_CONTROL	0x1A		/* for Ruby family */
-#define QD_REG_MANGEMENT_CONTROL	0x1A	/* for Schooner family */
-#define QD_REG_TOTAL_FREE_COUNTER	0x1B	/* for Schooner family */
+#define QD_REG_GLOBAL_STATUS        0x0
+#define QD_REG_MACADDR_01        0x1
+#define QD_REG_MACADDR_23        0x2
+#define QD_REG_MACADDR_45        0x3
+#define QD_REG_GLOBAL_CONTROL        0x4
+#define QD_REG_GLOBAL_CONTROL2        0x1C    /* for Sapphire, Schooner family */
+#define QD_REG_CORETAG_TYPE        0x19        /* for Ruby family */
+#define QD_REG_IP_MAPPING_TABLE    0x19        /* for Amber family */
+#define QD_REG_MONITOR_CONTROL    0x1A        /* for Ruby family */
+#define QD_REG_MANGEMENT_CONTROL    0x1A    /* for Schooner family */
+#define QD_REG_TOTAL_FREE_COUNTER    0x1B    /* for Schooner family */
 
 /* QuarterDeck Global 2 Registers */
-#define QD_REG_PHYINT_SOURCE	0x0
-#define QD_REG_DEVINT_SOURCE	0x0
-#define QD_REG_DEVINT_MASK		0x1
-#define QD_REG_MGMT_ENABLE_2X	0x2
-#define QD_REG_MGMT_ENABLE		0x3
-#define QD_REG_FLOWCTRL_DELAY	0x4
-#define QD_REG_MANAGEMENT		0x5
-#define QD_REG_ROUTING_TBL		0x6
-#define QD_REG_TRUNK_MASK_TBL	0x7
-#define QD_REG_TRUNK_ROUTING	0x8
-#define QD_REG_INGRESS_RATE_COMMAND	0x9
-#define QD_REG_INGRESS_RATE_DATA	0xA
-#define QD_REG_PVT_ADDR			0xB
-#define QD_REG_PVT_DATA			0xC
-#define QD_REG_SWITCH_MAC		0xD
-#define QD_REG_ATU_STATS		0xE
-#define QD_REG_PRIORITY_OVERRIDE	0xF
-#define QD_REG_EEPROM_COMMAND	0x14
-#define QD_REG_EEPROM_DATA		0x15
-#define QD_REG_PTP_COMMAND		0x16
-#define QD_REG_PTP_DATA			0x17
-#define QD_REG_SMI_PHY_CMD		0x18
-#define QD_REG_SMI_PHY_DATA		0x19
-#define QD_REG_SCRATCH_MISC		0x1A
-#define QD_REG_WD_CONTROL		0x1B
-#define QD_REG_QOS_WEIGHT		0x1C
-#define QD_REG_SDET_POLARITY	0x1D
-
-
-/* Definition for STU,VTU,RMON,and ATU Registers */
-#define QD_REG_ATU_FID_REG		0x1
-#define QD_REG_VTU_FID_REG		0x2
-#define QD_REG_STU_SID_REG		0x3
-#define QD_REG_VTU_OPERATION		0x5
-#define QD_REG_VTU_VID_REG		0x6
-#define QD_REG_VTU_DATA1_REG		0x7
-#define QD_REG_VTU_DATA2_REG		0x8
-#define QD_REG_VTU_DATA3_REG		0x9
-#define QD_REG_STATS_OPERATION		0x1D
-#define QD_REG_STATS_COUNTER3_2		0x1E
-#define QD_REG_STATS_COUNTER1_0		0x1F
+#define QD_REG_PHYINT_SOURCE    0x0
+#define QD_REG_DEVINT_SOURCE    0x0
+#define QD_REG_DEVINT_MASK        0x1
+#define QD_REG_MGMT_ENABLE_2X    0x2
+#define QD_REG_MGMT_ENABLE        0x3
+#define QD_REG_FLOWCTRL_DELAY    0x4
+#define QD_REG_MANAGEMENT        0x5
+#define QD_REG_ROUTING_TBL        0x6
+#define QD_REG_TRUNK_MASK_TBL    0x7
+#define QD_REG_TRUNK_ROUTING    0x8
+#define QD_REG_INGRESS_RATE_COMMAND    0x9
+#define QD_REG_INGRESS_RATE_DATA    0xA
+#define QD_REG_PVT_ADDR            0xB
+#define QD_REG_PVT_DATA            0xC
+#define QD_REG_SWITCH_MAC        0xD
+#define QD_REG_ATU_STATS        0xE
+#define QD_REG_PRIORITY_OVERRIDE    0xF
+#define QD_REG_EEPROM_COMMAND    0x14
+#define QD_REG_EEPROM_DATA        0x15
+#define QD_REG_PTP_COMMAND        0x16
+#define QD_REG_PTP_DATA            0x17
+#define QD_REG_SMI_PHY_CMD        0x18
+#define QD_REG_SMI_PHY_DATA        0x19
+#define QD_REG_SCRATCH_MISC        0x1A
+#define QD_REG_WD_CONTROL        0x1B
+#define QD_REG_QOS_WEIGHT        0x1C
+#define QD_REG_SDET_POLARITY    0x1D
+
+/* QuarterDeck Global 3 Registers */
+#define QD_REG_TCAM_OPERATION         0x0
+#define QD_REG_TCAM_P0_KEYS_1         0x2
+#define QD_REG_TCAM_P0_KEYS_2         0x3
+#define QD_REG_TCAM_P0_KEYS_3         0x4
+#define QD_REG_TCAM_P0_KEYS_4         0x5
+#define QD_REG_TCAM_P0_MATCH_DATA_1   0x6
+#define QD_REG_TCAM_P0_MATCH_DATA_2   0x7
+#define QD_REG_TCAM_P0_MATCH_DATA_3   0x8
+#define QD_REG_TCAM_P0_MATCH_DATA_4   0x9
+#define QD_REG_TCAM_P0_MATCH_DATA_5   0xa
+#define QD_REG_TCAM_P0_MATCH_DATA_6   0xb
+#define QD_REG_TCAM_P0_MATCH_DATA_7   0xc
+#define QD_REG_TCAM_P0_MATCH_DATA_8   0xd
+#define QD_REG_TCAM_P0_MATCH_DATA_9   0xe
+#define QD_REG_TCAM_P0_MATCH_DATA_10  0xf
+#define QD_REG_TCAM_P0_MATCH_DATA_11  0x10
+#define QD_REG_TCAM_P0_MATCH_DATA_12  0x11
+#define QD_REG_TCAM_P0_MATCH_DATA_13  0x12
+#define QD_REG_TCAM_P0_MATCH_DATA_14  0x13
+#define QD_REG_TCAM_P0_MATCH_DATA_15  0x14
+#define QD_REG_TCAM_P0_MATCH_DATA_16  0x15
+#define QD_REG_TCAM_P0_MATCH_DATA_17  0x16
+#define QD_REG_TCAM_P0_MATCH_DATA_18  0x17
+#define QD_REG_TCAM_P0_MATCH_DATA_19  0x18
+#define QD_REG_TCAM_P0_MATCH_DATA_20  0x19
+#define QD_REG_TCAM_P0_MATCH_DATA_21  0x1a
+#define QD_REG_TCAM_P0_MATCH_DATA_22  0x1b
+
+#define QD_REG_TCAM_P1_MATCH_DATA_23   0x2
+#define QD_REG_TCAM_P1_MATCH_DATA_24   0x3
+#define QD_REG_TCAM_P1_MATCH_DATA_25   0x4
+#define QD_REG_TCAM_P1_MATCH_DATA_26   0x5
+#define QD_REG_TCAM_P1_MATCH_DATA_27   0x6
+#define QD_REG_TCAM_P1_MATCH_DATA_28   0x7
+#define QD_REG_TCAM_P1_MATCH_DATA_29   0x8
+#define QD_REG_TCAM_P1_MATCH_DATA_30   0x9
+#define QD_REG_TCAM_P1_MATCH_DATA_31   0xa
+#define QD_REG_TCAM_P1_MATCH_DATA_32   0xb
+#define QD_REG_TCAM_P1_MATCH_DATA_33   0xc
+#define QD_REG_TCAM_P1_MATCH_DATA_34   0xd
+#define QD_REG_TCAM_P1_MATCH_DATA_35   0xe
+#define QD_REG_TCAM_P1_MATCH_DATA_36   0xf
+#define QD_REG_TCAM_P1_MATCH_DATA_37   0x10
+#define QD_REG_TCAM_P1_MATCH_DATA_38   0x11
+#define QD_REG_TCAM_P1_MATCH_DATA_39   0x12
+#define QD_REG_TCAM_P1_MATCH_DATA_40   0x13
+#define QD_REG_TCAM_P1_MATCH_DATA_41   0x14
+#define QD_REG_TCAM_P1_MATCH_DATA_42   0x15
+#define QD_REG_TCAM_P1_MATCH_DATA_43   0x16
+#define QD_REG_TCAM_P1_MATCH_DATA_44   0x17
+#define QD_REG_TCAM_P1_MATCH_DATA_45   0x18
+#define QD_REG_TCAM_P1_MATCH_DATA_46   0x19
+#define QD_REG_TCAM_P1_MATCH_DATA_47   0x1a
+#define QD_REG_TCAM_P1_MATCH_DATA_48   0x1b
+
+#define QD_REG_TCAM_P2_ACTION_1        0x2
+#define QD_REG_TCAM_P2_ACTION_2        0x3
+#define QD_REG_TCAM_P2_ACTION_3        0x4
+#define QD_REG_TCAM_P2_ACTION_4        0x5
+#define QD_REG_TCAM_P2_DEBUG_PORT      0x1c
+#define QD_REG_TCAM_P2_ALL_HIT         0x1f
+
+
+
+/* Global 1 Registers Definition for STU,VTU,RMON,and ATU Registers */
+#define QD_REG_ATU_FID_REG        0x1
+#define QD_REG_VTU_FID_REG        0x2
+#define QD_REG_STU_SID_REG        0x3
+#define QD_REG_VTU_OPERATION        0x5
+#define QD_REG_VTU_VID_REG        0x6
+#define QD_REG_VTU_DATA1_REG        0x7
+#define QD_REG_VTU_DATA2_REG        0x8
+#define QD_REG_VTU_DATA3_REG        0x9
+#define QD_REG_STATS_OPERATION        0x1D
+#define QD_REG_STATS_COUNTER3_2        0x1E
+#define QD_REG_STATS_COUNTER1_0        0x1F
  
-#define QD_REG_ATU_CONTROL		0xA
-#define QD_REG_ATU_OPERATION		0xB
-#define QD_REG_ATU_DATA_REG		0xC
-#define QD_REG_ATU_MAC_BASE		0xD
-#define QD_REG_IP_PRI_BASE		0x10
-#define QD_REG_IEEE_PRI			0x18
+#define QD_REG_ATU_CONTROL        0xA
+#define QD_REG_ATU_OPERATION        0xB
+#define QD_REG_ATU_DATA_REG        0xC
+#define QD_REG_ATU_MAC_BASE        0xD
+#define QD_REG_IP_PRI_BASE        0x10
+#define QD_REG_IEEE_PRI            0x18
 
 
 /* Definitions for MIB Counter */
-#define GT_STATS_NO_OP			0x0
-#define GT_STATS_FLUSH_ALL		0x1
-#define GT_STATS_FLUSH_PORT		0x2
-#define GT_STATS_READ_COUNTER		0x4
-#define GT_STATS_CAPTURE_PORT		0x5
-
-#define QD_PHY_CONTROL_REG			0
-#define QD_PHY_AUTONEGO_AD_REG			4
-#define QD_PHY_NEXTPAGE_TX_REG			7
-#define QD_PHY_AUTONEGO_1000AD_REG		9
-#define QD_PHY_SPEC_CONTROL_REG			16
-#define QD_PHY_INT_ENABLE_REG			18
-#define QD_PHY_INT_STATUS_REG			19
-#define QD_PHY_INT_PORT_SUMMARY_REG		20
+#define GT_STATS_NO_OP            0x0
+#define GT_STATS_FLUSH_ALL        0x1
+#define GT_STATS_FLUSH_PORT        0x2
+#define GT_STATS_READ_COUNTER        0x4
+#define GT_STATS_CAPTURE_PORT        0x5
+
+#define QD_PHY_CONTROL_REG            0
+#define QD_PHY_AUTONEGO_AD_REG            4
+#define QD_PHY_NEXTPAGE_TX_REG            7
+#define QD_PHY_AUTONEGO_1000AD_REG        9
+#define QD_PHY_SPEC_CONTROL_REG            16
+#define QD_PHY_INT_ENABLE_REG            18
+#define QD_PHY_INT_STATUS_REG            19
+#define QD_PHY_INT_PORT_SUMMARY_REG        20
 
 /* Definitions for VCT registers */
 #define QD_REG_MDI0_VCT_STATUS     16
 #define QD_REG_MDI1_VCT_STATUS     17
 #define QD_REG_MDI2_VCT_STATUS     18
 #define QD_REG_MDI3_VCT_STATUS     19
-#define QD_REG_ADV_VCT_CONTROL_5	23
-#define QD_REG_ADV_VCT_CONTROL_8	20
+#define QD_REG_ADV_VCT_CONTROL_5    23
+#define QD_REG_ADV_VCT_CONTROL_8    20
 #define QD_REG_PAIR_SKEW_STATUS    20
 #define QD_REG_PAIR_SWAP_STATUS    21
 
-
 /* Bit Definition for QD_PHY_CONTROL_REG */
-#define QD_PHY_RESET			0x8000
-#define QD_PHY_LOOPBACK			0x4000
-#define QD_PHY_SPEED			0x2000
-#define QD_PHY_AUTONEGO			0x1000
-#define QD_PHY_POWER			0x800
-#define QD_PHY_ISOLATE			0x400
-#define QD_PHY_RESTART_AUTONEGO		0x200
-#define QD_PHY_DUPLEX			0x100
-#define QD_PHY_SPEED_MSB		0x40
-
-#define QD_PHY_POWER_BIT			11
-#define QD_PHY_RESTART_AUTONEGO_BIT		9
+#define QD_PHY_RESET            0x8000
+#define QD_PHY_LOOPBACK            0x4000
+#define QD_PHY_SPEED            0x2000
+#define QD_PHY_AUTONEGO            0x1000
+#define QD_PHY_POWER            0x800
+#define QD_PHY_ISOLATE            0x400
+#define QD_PHY_RESTART_AUTONEGO        0x200
+#define QD_PHY_DUPLEX            0x100
+#define QD_PHY_SPEED_MSB        0x40
+
+#define QD_PHY_POWER_BIT            11
+#define QD_PHY_RESTART_AUTONEGO_BIT        9
 
 /* Bit Definition for QD_PHY_AUTONEGO_AD_REG */
-#define QD_PHY_NEXTPAGE			0x8000
-#define QD_PHY_REMOTEFAULT		0x4000
-#define QD_PHY_PAUSE			0x400
-#define QD_PHY_100_FULL			0x100
-#define QD_PHY_100_HALF			0x80
-#define QD_PHY_10_FULL			0x40
-#define QD_PHY_10_HALF			0x20
-
-#define QD_PHY_MODE_AUTO_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
-#define QD_PHY_MODE_100_AUTO	(QD_PHY_100_FULL | QD_PHY_100_HALF)
-#define QD_PHY_MODE_10_AUTO		(QD_PHY_10_FULL | QD_PHY_10_HALF)
-#define QD_PHY_MODE_AUTO_FULL	(QD_PHY_100_FULL | QD_PHY_10_FULL)
-#define QD_PHY_MODE_AUTO_HALF	(QD_PHY_100_HALF | QD_PHY_10_HALF)
-
-#define QD_PHY_MODE_100_FULL	QD_PHY_100_FULL
-#define QD_PHY_MODE_100_HALF	QD_PHY_100_HALF
-#define QD_PHY_MODE_10_FULL		QD_PHY_10_FULL	
-#define QD_PHY_MODE_10_HALF		QD_PHY_10_HALF	
+#define QD_PHY_NEXTPAGE            0x8000
+#define QD_PHY_REMOTEFAULT        0x4000
+#define QD_PHY_PAUSE            0x400
+#define QD_PHY_100_FULL            0x100
+#define QD_PHY_100_HALF            0x80
+#define QD_PHY_10_FULL            0x40
+#define QD_PHY_10_HALF            0x20
+
+#define QD_PHY_MODE_AUTO_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF | QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_100_AUTO    (QD_PHY_100_FULL | QD_PHY_100_HALF)
+#define QD_PHY_MODE_10_AUTO        (QD_PHY_10_FULL | QD_PHY_10_HALF)
+#define QD_PHY_MODE_AUTO_FULL    (QD_PHY_100_FULL | QD_PHY_10_FULL)
+#define QD_PHY_MODE_AUTO_HALF    (QD_PHY_100_HALF | QD_PHY_10_HALF)
+
+#define QD_PHY_MODE_100_FULL    QD_PHY_100_FULL
+#define QD_PHY_MODE_100_HALF    QD_PHY_100_HALF
+#define QD_PHY_MODE_10_FULL        QD_PHY_10_FULL    
+#define QD_PHY_MODE_10_HALF        QD_PHY_10_HALF    
 
 /* Gigabit Phy related definition */
-#define QD_GIGPHY_1000X_FULL_CAP	0x8
-#define QD_GIGPHY_1000X_HALF_CAP	0x4
-#define QD_GIGPHY_1000T_FULL_CAP	0x2
-#define QD_GIGPHY_1000T_HALF_CAP	0x1
+#define QD_GIGPHY_1000X_FULL_CAP    0x8
+#define QD_GIGPHY_1000X_HALF_CAP    0x4
+#define QD_GIGPHY_1000T_FULL_CAP    0x2
+#define QD_GIGPHY_1000T_HALF_CAP    0x1
 
-#define QD_GIGPHY_1000X_CAP		(QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
-#define QD_GIGPHY_1000T_CAP		(QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
+#define QD_GIGPHY_1000X_CAP        (QD_GIGPHY_1000X_FULL_CAP|QD_GIGPHY_1000X_HALF_CAP)
+#define QD_GIGPHY_1000T_CAP        (QD_GIGPHY_1000T_FULL_CAP|QD_GIGPHY_1000T_HALF_CAP)
 
-#define QD_GIGPHY_1000X_FULL		0x20
-#define QD_GIGPHY_1000X_HALF		0x40
+#define QD_GIGPHY_1000X_FULL        0x20
+#define QD_GIGPHY_1000X_HALF        0x40
 
-#define QD_GIGPHY_1000T_FULL		0x200
-#define QD_GIGPHY_1000T_HALF		0x100
+#define QD_GIGPHY_1000T_FULL        0x200
+#define QD_GIGPHY_1000T_HALF        0x100
 
 /* Bit definition for QD_PHY_INT_ENABLE_REG */
-#define QD_PHY_INT_SPEED_CHANGED		0x4000
-#define QD_PHY_INT_DUPLEX_CHANGED		0x2000
-#define QD_PHY_INT_PAGE_RECEIVED		0x1000
-#define QD_PHY_INT_AUTO_NEG_COMPLETED		0x800
-#define QD_PHY_INT_LINK_STATUS_CHANGED		0x400
-#define QD_PHY_INT_SYMBOL_ERROR			0x200
-#define QD_PHY_INT_FALSE_CARRIER		0x100
-#define QD_PHY_INT_FIFO_FLOW			0x80
-#define QD_PHY_INT_CROSSOVER_CHANGED		0x40
-#define QD_PHY_INT_POLARITY_CHANGED		0x2
-#define QD_PHY_INT_JABBER			0x1
+#define QD_PHY_INT_SPEED_CHANGED        0x4000
+#define QD_PHY_INT_DUPLEX_CHANGED        0x2000
+#define QD_PHY_INT_PAGE_RECEIVED        0x1000
+#define QD_PHY_INT_AUTO_NEG_COMPLETED        0x800
+#define QD_PHY_INT_LINK_STATUS_CHANGED        0x400
+#define QD_PHY_INT_SYMBOL_ERROR            0x200
+#define QD_PHY_INT_FALSE_CARRIER        0x100
+#define QD_PHY_INT_FIFO_FLOW            0x80
+#define QD_PHY_INT_CROSSOVER_CHANGED        0x40
+#define QD_PHY_INT_POLARITY_CHANGED        0x2
+#define QD_PHY_INT_JABBER            0x1
 
 
 /* Bit definition for DEVICE Interrupt */
-#define QD_DEV_INT_WATCHDOG			0x8000
-#define QD_DEV_INT_JAMLIMIT			0x4000
-#define QD_DEV_INT_DUPLEX_MISMATCH	0x2000
+#define QD_DEV_INT_WATCHDOG            0x8000
+#define QD_DEV_INT_JAMLIMIT            0x4000
+#define QD_DEV_INT_DUPLEX_MISMATCH    0x2000
+#define QD_DEV_INT_WAKE_EVENT         0x1000
 
 /* Definition for Multi Address Mode */
-#define QD_REG_SMI_COMMAND		0x0
-#define QD_REG_SMI_DATA			0x1
+#define QD_REG_SMI_COMMAND        0x0
+#define QD_REG_SMI_DATA            0x1
 
 /* Bit definition for QD_REG_SMI_COMMAND */
-#define QD_SMI_BUSY				0x8000
-#define QD_SMI_MODE				0x1000
-#define QD_SMI_MODE_BIT			12
-#define QD_SMI_OP_BIT			10
-#define QD_SMI_OP_SIZE			2
-#define QD_SMI_DEV_ADDR_BIT		5
-#define QD_SMI_DEV_ADDR_SIZE	5
-#define QD_SMI_REG_ADDR_BIT		0
-#define QD_SMI_REG_ADDR_SIZE	5
-
-#define QD_SMI_CLAUSE45			0
-#define QD_SMI_CLAUSE22			1
-
-#define QD_SMI_WRITE			0x01
-#define QD_SMI_READ				0x02
+#define QD_SMI_BUSY                0x8000
+#define QD_SMI_MODE                0x1000
+#define QD_SMI_MODE_BIT            12
+#define QD_SMI_OP_BIT            10
+#define QD_SMI_OP_SIZE            2
+#define QD_SMI_DEV_ADDR_BIT        5
+#define QD_SMI_DEV_ADDR_SIZE    5
+#define QD_SMI_REG_ADDR_BIT        0
+#define QD_SMI_REG_ADDR_SIZE    5
+
+#define QD_SMI_CLAUSE45            0
+#define QD_SMI_CLAUSE22            1
+
+#define QD_SMI_WRITE            0x01
+#define QD_SMI_READ                0x02
 
 #endif /* __gtDrvSwRegsh */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h
old mode 100644
new mode 100755
index 5d459df..d146daf
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/driver/gtHwCntl.h
@@ -27,6 +27,7 @@ extern "C" {
 /* This macro is used to calculate the register's SMI   */
 /* device address, according to the baseAddr            */
 /* field in the Switch configuration struct.            */
+extern GT_U8 portToSmiMapping(GT_QD_DEV *dev, GT_U8 portNum, GT_U32 accessType);
 #define CALC_SMI_DEV_ADDR(_dev, _portNum, _accessType)        \
             portToSmiMapping(_dev, _portNum, _accessType)
 
@@ -42,23 +43,24 @@ extern "C" {
 
 /* Start address of phy related register.               */
 #define PHY_REGS_START_ADDR     0x0
-#define PHY_REGS_START_ADDR_8PORT	0x0
+#define PHY_REGS_START_ADDR_8PORT    0x0
 
 /* Start address of ports related register.             */
-#define PORT_REGS_START_ADDR    	0x8
-#define PORT_REGS_START_ADDR_8PORT	0x10
+#define PORT_REGS_START_ADDR        0x8
+#define PORT_REGS_START_ADDR_8PORT    0x10
 
 /* Start address of global register.                    */
 #define GLOBAL_REGS_START_ADDR  0xF
 #define GLOBAL_REGS_START_ADDR_8PORT  0x1B
 
-#define PHY_ACCESS			1
-#define PORT_ACCESS			2
-#define GLOBAL_REG_ACCESS	3
-#define GLOBAL2_REG_ACCESS	4
+#define PHY_ACCESS            1
+#define PORT_ACCESS            2
+#define GLOBAL_REG_ACCESS    3
+#define GLOBAL2_REG_ACCESS    4
+#define GLOBAL3_REG_ACCESS    5
 
-#define QD_SMI_ACCESS_LOOP		1000
-#define QD_SMI_TIMEOUT			2
+#define QD_SMI_ACCESS_LOOP        1000
+#define QD_SMI_TIMEOUT            2
 
 
 /****************************************************************************/
@@ -205,8 +207,8 @@ GT_STATUS hwSetPhyRegField
 * INPUTS:
 *       portNum     - Port number to write the register for.
 *       u16Data     - data should be written into Phy control register.
-*					  if this value is 0xFF, normal operation occcurs (read, 
-*					  update, and write back.)
+*                      if this value is 0xFF, normal operation occcurs (read, 
+*                      update, and write back.)
 *
 * OUTPUTS:
 *       None.
@@ -222,7 +224,7 @@ GT_STATUS hwPhyReset
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_U8     portNum,
-	IN	GT_U16		u16Data
+    IN    GT_U16        u16Data
 );
 
 
@@ -236,7 +238,7 @@ GT_STATUS hwPhyReset
 *       portNum - Port number to read the register for.
 *       pageNum - Page number of the register to be read.
 *       regAddr - The register's address.
-*		anyPage - register list(vector) that are common to all pages
+*        anyPage - register list(vector) that are common to all pages
 *
 * OUTPUTS:
 *       data    - The read register's data.
@@ -251,12 +253,12 @@ GT_STATUS hwPhyReset
 *******************************************************************************/
 GT_STATUS hwReadPagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	OUT GT_U16   *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
 );
 
 
@@ -270,7 +272,7 @@ GT_STATUS hwReadPagedPhyReg
 *       portNum - Port number to write the register for.
 *       pageNum - Page number of the register to be written.
 *       regAddr - The register's address.
-*		anyPage - Register list(vector) that are common to all pages
+*        anyPage - Register list(vector) that are common to all pages
 *       data    - The data to be written.
 *
 * OUTPUTS:
@@ -286,12 +288,12 @@ GT_STATUS hwReadPagedPhyReg
 *******************************************************************************/
 GT_STATUS hwWritePagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
 );
 
 /*******************************************************************************
@@ -299,15 +301,15 @@ GT_STATUS hwWritePagedPhyReg
 *
 * DESCRIPTION:
 *       This function reads a specified field from a switch's port phy register
-*		in page mode.
+*        in page mode.
 *
 * INPUTS:
 *       portNum     - Port number to read the register for.
-*       pageNum 	- Page number of the register to be read.
+*       pageNum     - Page number of the register to be read.
 *       regAddr     - The register's address.
 *       fieldOffset - The field start bit index. (0 - 15)
 *       fieldLength - Number of bits to read.
-*		anyPage - Register list(vector) that are common to all pages
+*        anyPage - Register list(vector) that are common to all pages
 *
 * OUTPUTS:
 *       data        - The read register field.
@@ -329,7 +331,7 @@ GT_STATUS hwGetPagedPhyRegField
     IN  GT_U8    regAddr,
     IN  GT_U8    fieldOffset,
     IN  GT_U8    fieldLength,
-	IN  GT_U32	 anyPage,
+    IN  GT_U32     anyPage,
     OUT GT_U16   *data
 );
 
@@ -338,15 +340,15 @@ GT_STATUS hwGetPagedPhyRegField
 *
 * DESCRIPTION:
 *       This function writes to specified field in a switch's port phy register
-*		in page mode
+*        in page mode
 *
 * INPUTS:
 *       portNum     - Port number to write the register for.
-*       pageNum 	- Page number of the register to be read.
+*       pageNum     - Page number of the register to be read.
 *       regAddr     - The register's address.
 *       fieldOffset - The field start bit index. (0 - 15)
 *       fieldLength - Number of bits to write.
-*		anyPage 	- Register list(vector) that are common to all pages
+*        anyPage     - Register list(vector) that are common to all pages
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -369,7 +371,7 @@ GT_STATUS hwSetPagedPhyRegField
     IN  GT_U8    regAddr,
     IN  GT_U8    fieldOffset,
     IN  GT_U8    fieldLength,
-	IN  GT_U32	 anyPage,
+    IN  GT_U32     anyPage,
     IN  GT_U16   data
 );
 
@@ -518,7 +520,7 @@ GT_STATUS hwSetPortRegField
 * INPUTS:
 *       portNum     - Port number to write the register for.
 *       regAddr     - The register's address.
-*       mask 		- The bits to write.
+*       mask         - The bits to write.
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -530,7 +532,7 @@ GT_STATUS hwSetPortRegField
 *
 * COMMENTS:
 *       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
-*			and 0010b is written to bit[3:0]
+*            and 0010b is written to bit[3:0]
 *
 *******************************************************************************/
 GT_STATUS hwSetPortRegBits
@@ -803,7 +805,7 @@ GT_STATUS hwSetGlobal2RegField
 *
 * INPUTS:
 *       regAddr     - The register's address.
-*       mask 		- The bits to write.
+*       mask         - The bits to write.
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -815,7 +817,7 @@ GT_STATUS hwSetGlobal2RegField
 *
 * COMMENTS:
 *       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
-*			and 0010b is written to bit[3:0]
+*            and 0010b is written to bit[3:0]
 *
 *******************************************************************************/
 GT_STATUS hwSetGlobal2RegBits
@@ -826,6 +828,162 @@ GT_STATUS hwSetGlobal2RegBits
     IN  GT_U16   data
 );
 
+/****************************************************************************/
+/* Global 3 registers related functions.                                      */
+/****************************************************************************/
+
+/*******************************************************************************
+* hwReadGlobal3Reg
+*
+* DESCRIPTION:
+*       This function reads a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadGlobal3Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwWriteGlobal3Reg
+*
+* DESCRIPTION:
+*       This function writes to a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr - The register's address.
+*       data    - The data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteGlobal3Reg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U16    data
+);
+
+
+/*******************************************************************************
+* hwGetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function reads a specified field from a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
+*
+* OUTPUTS:
+*       data        - The read register field.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
+*
+*******************************************************************************/
+GT_STATUS hwGetGlobal3RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    OUT GT_U16    *data
+);
+
+
+/*******************************************************************************
+* hwSetGlobal3RegField
+*
+* DESCRIPTION:
+*       This function writes to specified field in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegField
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     regAddr,
+    IN  GT_U8     fieldOffset,
+    IN  GT_U8     fieldLength,
+    IN  GT_U16    data
+);
+
+/*******************************************************************************
+* hwSetGlobal3RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+);
+
 /*******************************************************************************
 * hwReadMiiReg
 *
@@ -885,6 +1043,40 @@ GT_STATUS hwWriteMiiReg
     IN  GT_U16    data
 );
 
+#ifdef GT_RMGMT_ACCESS
+
+/*******************************************************************************
+* hwAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwAccessMultiRegs
+(
+    IN GT_QD_DEV *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/gtVct.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/gtVct.h
old mode 100644
new mode 100755
index a810c45..1c58a1b
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/gtVct.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/gtVct.h
@@ -33,144 +33,145 @@
 extern "C" {
 #endif
 
-#define MARVELL_OUI_MSb		0x0141
-#define MARVELL_OUI_LSb		0x0C00
-#define OUI_LSb_MASK		0xFC00
-#define PHY_MODEL_MASK		0x03F0
-#define PHY_REV_MASK		0x000F
-
-#define DEV_E3082		0x8 << 4
-#define DEV_E104X		0x2 << 4
-#define DEV_E1111		0xC << 4
-#define DEV_E1112		0x9 << 4
-#define DEV_E114X		0xD << 4
-#define DEV_E1149		0xA << 4
-#define DEV_E1181		0xE << 4
-#define DEV_EC010		0x3 << 4
-#define DEV_G15LV		0xB << 4	/* 88E6165 internal copper phy, 88E1240 */
-#define DEV_S15LV		0x0 << 4	/* 88E6165 internal SERDES */
-#define DEV_G65G		0x27 << 4	/* 88E6375 internal copper phy, 88E1340 */
+#define MARVELL_OUI_MSb        0x0141
+#define MARVELL_OUI_LSb        0x0C00
+#define OUI_LSb_MASK        0xFC00
+#define PHY_MODEL_MASK        0x03F0
+#define PHY_REV_MASK        0x000F
+
+#define DEV_E3082        0x8 << 4
+#define DEV_E104X        0x2 << 4
+#define DEV_E1111        0xC << 4
+#define DEV_E1112        0x9 << 4
+#define DEV_E114X        0xD << 4
+#define DEV_E1149        0xA << 4
+#define DEV_E1181        0xE << 4
+#define DEV_EC010        0x3 << 4
+#define DEV_G15LV        0xB << 4    /* 88E6165 internal copper phy, 88E1240 */
+#define DEV_S15LV        0x0 << 4    /* 88E6165 internal SERDES */
+#define DEV_MELODY       0x26 << 4   /* 88EC000 internal copper phy, 88E3020-88E6250 */
+#define DEV_G65G        0x27 << 4    /* 88E6375 internal copper phy, 88E1340 */
 
 typedef struct _GT_PHY_INFO
 {
-	GT_U32	phyId;		/* Marvell PHY ID (register 3) */
-	GT_U32	anyPage;	/* each bit represents if the corresponding register is any page */
-	GT_U32	flag;		/* see below for definition */
-	GT_U8	vctType;	/* VCT Register Type */
-	GT_U8	exStatusType;	/* EX Status Register Type */
-	GT_U8	dteType;	/* DTE Register Type */
-	GT_U8	pktGenType;	/* Pkt Generator Reg. Type */
-	GT_U8	macIfLoopType;		/* MAC IF Loopback Reg. Type */
-	GT_U8	lineLoopType;		/* Line Loopback Reg. Type */
-	GT_U8	exLoopType;		/* External Loopback Reg. Type */
-	GT_U8	pageType;		/* Page Restriction Type */
+    GT_U32    phyId;        /* Marvell PHY ID (register 3) */
+    GT_U32    anyPage;    /* each bit represents if the corresponding register is any page */
+    GT_U32    flag;        /* see below for definition */
+    GT_U8    vctType;    /* VCT Register Type */
+    GT_U8    exStatusType;    /* EX Status Register Type */
+    GT_U8    dteType;    /* DTE Register Type */
+    GT_U8    pktGenType;    /* Pkt Generator Reg. Type */
+    GT_U8    macIfLoopType;        /* MAC IF Loopback Reg. Type */
+    GT_U8    lineLoopType;        /* Line Loopback Reg. Type */
+    GT_U8    exLoopType;        /* External Loopback Reg. Type */
+    GT_U8    pageType;        /* Page Restriction Type */
 } GT_PHY_INFO;
 
 /* GT_PHY_INFO flag definition */
-#define GT_PHY_VCT_CAPABLE		0x0001
-#define GT_PHY_DTE_CAPABLE		0x0002
-#define GT_PHY_EX_CABLE_STATUS	0x0004
-#define GT_PHY_ADV_VCT_CAPABLE	0x0008
-#define GT_PHY_PKT_GENERATOR	0x0010
-#define GT_PHY_MAC_IF_LOOP		0x0100
-#define GT_PHY_LINE_LOOP		0x0200
-#define GT_PHY_EXTERNAL_LOOP	0x0400
-#define GT_PHY_RESTRICTED_PAGE	0x0800
-#define GT_PHY_GIGABIT			0x8000
-#define GT_PHY_COPPER			0x4000
-#define GT_PHY_FIBER			0x2000
-#define GT_PHY_SERDES_CORE		0x1000
+#define GT_PHY_VCT_CAPABLE        0x0001
+#define GT_PHY_DTE_CAPABLE        0x0002
+#define GT_PHY_EX_CABLE_STATUS    0x0004
+#define GT_PHY_ADV_VCT_CAPABLE    0x0008
+#define GT_PHY_PKT_GENERATOR    0x0010
+#define GT_PHY_MAC_IF_LOOP        0x0100
+#define GT_PHY_LINE_LOOP        0x0200
+#define GT_PHY_EXTERNAL_LOOP    0x0400
+#define GT_PHY_RESTRICTED_PAGE    0x0800
+#define GT_PHY_GIGABIT            0x8000
+#define GT_PHY_COPPER            0x4000
+#define GT_PHY_FIBER            0x2000
+#define GT_PHY_SERDES_CORE        0x1000
 
 /* VCT Register Type */
-#define GT_PHY_VCT_TYPE1	1	/* 10/100 Fast Ethernet */
-#define GT_PHY_VCT_TYPE2	2	/* 1000M without page support */
-#define GT_PHY_VCT_TYPE3	3	/* 1000M without page but with work around */
-#define GT_PHY_VCT_TYPE4	4	/* 1000M with page support */
+#define GT_PHY_VCT_TYPE1    1    /* 10/100 Fast Ethernet */
+#define GT_PHY_VCT_TYPE2    2    /* 1000M without page support */
+#define GT_PHY_VCT_TYPE3    3    /* 1000M without page but with work around */
+#define GT_PHY_VCT_TYPE4    4    /* 1000M with page support */
 
 /* ADV VCT Register Type */
-#define GT_PHY_ADV_VCT_TYPE1	5	/* 88E1181 type device, not supported */
-#define GT_PHY_ADV_VCT_TYPE2	6	/* 88E6165 family devies */
+#define GT_PHY_ADV_VCT_TYPE1    5    /* 88E1181 type device, not supported */
+#define GT_PHY_ADV_VCT_TYPE2    6    /* 88E6165 family devies */
 
 /* Extended Status Type */
-#define GT_PHY_EX_STATUS_TYPE1	1	/* 88E1111, 88E1141, 88E1145 */
-#define GT_PHY_EX_STATUS_TYPE2	2	/* 88E1112 */
-#define GT_PHY_EX_STATUS_TYPE3	3	/* 88E1149 */
-#define GT_PHY_EX_STATUS_TYPE4	4	/* 88E1181 */
-#define GT_PHY_EX_STATUS_TYPE5	5	/* 88E1116 */
-#define GT_PHY_EX_STATUS_TYPE6	6	/* 88E6165 family devices */
+#define GT_PHY_EX_STATUS_TYPE1    1    /* 88E1111, 88E1141, 88E1145 */
+#define GT_PHY_EX_STATUS_TYPE2    2    /* 88E1112 */
+#define GT_PHY_EX_STATUS_TYPE3    3    /* 88E1149 */
+#define GT_PHY_EX_STATUS_TYPE4    4    /* 88E1181 */
+#define GT_PHY_EX_STATUS_TYPE5    5    /* 88E1116 */
+#define GT_PHY_EX_STATUS_TYPE6    6    /* 88E6165 family devices */
 
 /* DTE Register Type */
-#define GT_PHY_DTE_TYPE1	1	/* 10/100 Fast Ethernet with workaround */
-#define GT_PHY_DTE_TYPE2	2	/* 1000M without page support */
-#define GT_PHY_DTE_TYPE3	3	/* 1000M without page but with work around */
-#define GT_PHY_DTE_TYPE4	4	/* 1000M with page support */
-#define GT_PHY_DTE_TYPE5	5	/* 10/100 Fast Ethernet */
+#define GT_PHY_DTE_TYPE1    1    /* 10/100 Fast Ethernet with workaround */
+#define GT_PHY_DTE_TYPE2    2    /* 1000M without page support */
+#define GT_PHY_DTE_TYPE3    3    /* 1000M without page but with work around */
+#define GT_PHY_DTE_TYPE4    4    /* 1000M with page support */
+#define GT_PHY_DTE_TYPE5    5    /* 10/100 Fast Ethernet */
 
 /* Pkt Generator Register Type */
-#define GT_PHY_PKTGEN_TYPE1	1	/* Uses Register 30 */
-#define GT_PHY_PKTGEN_TYPE2	2	/* Uses Register 16 */
-#define GT_PHY_PKTGEN_TYPE3	3	/* Uses Register 25 */
+#define GT_PHY_PKTGEN_TYPE1    1    /* Uses Register 30 */
+#define GT_PHY_PKTGEN_TYPE2    2    /* Uses Register 16 */
+#define GT_PHY_PKTGEN_TYPE3    3    /* Uses Register 25 */
 
 /* MAC Interface Loopback Register Type */
-#define GT_PHY_LOOPBACK_TYPE0	0	/* Don't do anything */
-#define GT_PHY_LOOPBACK_TYPE1	1	/* 0.14 only */
-#define GT_PHY_LOOPBACK_TYPE2	2	/* For DEV_G15LV like device */
-#define GT_PHY_LOOPBACK_TYPE3	3	/* For DEV_S15LV like device */
-#define GT_PHY_LOOPBACK_TYPE4	4	/* For DEV_E1111 like device */
+#define GT_PHY_LOOPBACK_TYPE0    0    /* Don't do anything */
+#define GT_PHY_LOOPBACK_TYPE1    1    /* 0.14 only */
+#define GT_PHY_LOOPBACK_TYPE2    2    /* For DEV_G15LV like device */
+#define GT_PHY_LOOPBACK_TYPE3    3    /* For DEV_S15LV like device */
+#define GT_PHY_LOOPBACK_TYPE4    4    /* For DEV_E1111 like device */
 
 /* Line Loopback Register Type */
-#define GT_PHY_LINE_LB_TYPE1	1	/* 0_2.14 */
-#define GT_PHY_LINE_LB_TYPE2	2	/* 21_2.14 */
-#define GT_PHY_LINE_LB_TYPE3	3	/* 20.14 */
-#define GT_PHY_LINE_LB_TYPE4	4	/* 16.12 */
+#define GT_PHY_LINE_LB_TYPE1    1    /* 0_2.14 */
+#define GT_PHY_LINE_LB_TYPE2    2    /* 21_2.14 */
+#define GT_PHY_LINE_LB_TYPE3    3    /* 20.14 */
+#define GT_PHY_LINE_LB_TYPE4    4    /* 16.12 */
 
 /* External Loopback Register Type */
-#define GT_PHY_EX_LB_TYPE0	0	/* Don't do anything */
-#define GT_PHY_EX_LB_TYPE1	1	/* For DEV_E1111 like dev */
-#define GT_PHY_EX_LB_TYPE2	2	/* For DEV_E1149 like dev */
+#define GT_PHY_EX_LB_TYPE0    0    /* Don't do anything */
+#define GT_PHY_EX_LB_TYPE1    1    /* For DEV_E1111 like dev */
+#define GT_PHY_EX_LB_TYPE2    2    /* For DEV_E1149 like dev */
 
 /* Restricted Page Access Type */
-#define GT_PHY_PAGE_WRITE_BACK	0	/* For every device */
-#define GT_PHY_PAGE_DIS_AUTO1	1	/* For 88E1111 type */
-#define GT_PHY_PAGE_DIS_AUTO2	2	/* For 88E1121 type */
-#define GT_PHY_NO_PAGE			3	/* No Pages */
+#define GT_PHY_PAGE_WRITE_BACK    0    /* For every device */
+#define GT_PHY_PAGE_DIS_AUTO1    1    /* For 88E1111 type */
+#define GT_PHY_PAGE_DIS_AUTO2    2    /* For 88E1121 type */
+#define GT_PHY_NO_PAGE            3    /* No Pages */
 
 
 /* definition for formula to calculate actual distance */
 #ifdef FP_SUPPORT
-#define FORMULA_PHY100M(_data)	((_data)*0.7861 - 18.862)
-#define FORMULA_PHY1000M(_data)	((_data)*0.8018 - 28.751)
+#define FORMULA_PHY100M(_data)    ((_data)*0.7861 - 18.862)
+#define FORMULA_PHY1000M(_data)    ((_data)*0.8018 - 28.751)
 #else
-#define FORMULA_PHY100M(_data)	(((long)(_data)*7861 - 188620)/10000 + (((((long)(_data)*7861 - 188620)%10000) >= 5000)?1:0))
-#define FORMULA_PHY1000M(_data)	(((long)(_data)*8018 - 287510)/10000 + (((((long)(_data)*8018 - 287510)%10000) >= 5000)?1:0))
+#define FORMULA_PHY100M(_data)    (((long)(_data)*7861 - 188620)/10000 + (((((long)(_data)*7861 - 188620)%10000) >= 5000)?1:0))
+#define FORMULA_PHY1000M(_data)    (((long)(_data)*8018 - 287510)/10000 + (((((long)(_data)*8018 - 287510)%10000) >= 5000)?1:0))
 #endif
 
-#define GT_ADV_VCT_CALC(_data)	    \
+#define GT_ADV_VCT_CALC(_data)        \
         (((long)(_data)*8333 - 191667)/10000 + (((((long)(_data)*8333 - 191667)%10000) >= 5000)?1:0))
 
-#define GT_ADV_VCT_CALC_SHORT(_data)	    \
+#define GT_ADV_VCT_CALC_SHORT(_data)        \
         (((long)(_data)*7143 - 71429)/10000 + (((((long)(_data)*7143 - 71429)%10000) >= 5000)?1:0)) 
 
 /* macro to check VCT Failure */
-#define IS_VCT_FAILED(_reg)		\
-		(((_reg) & 0xFF) == 0xFF)
+#define IS_VCT_FAILED(_reg)        \
+        (((_reg) & 0xFF) == 0xFF)
 
 /* macro to find out if Amplitude is zero */
-#define IS_ZERO_AMPLITUDE(_reg)	\
-		(((_reg) & 0x7F00) == 0)
+#define IS_ZERO_AMPLITUDE(_reg)    \
+        (((_reg) & 0x7F00) == 0)
 
 /* macro to retrieve Amplitude */
-#define GET_AMPLITUDE(_reg)	\
-		(((_reg) & 0x7F00) >> 8)
-		
+#define GET_AMPLITUDE(_reg)    \
+        (((_reg) & 0x7F00) >> 8)
+        
 /* macro to find out if Amplitude is positive */
-#define IS_POSITIVE_AMPLITUDE(_reg)	\
-		(((_reg) & 0x8000) == 0x8000)
+#define IS_POSITIVE_AMPLITUDE(_reg)    \
+        (((_reg) & 0x8000) == 0x8000)
 
 typedef struct _VCT_REGISTER
 {
-	GT_U8	page;
-	GT_U8	regOffset;
+    GT_U8    page;
+    GT_U8    regOffset;
 } VCT_REGISTER;
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h
old mode 100644
new mode 100755
index 175ee31..87f4bcb
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/msApi/msApiInternal.h
@@ -26,22 +26,30 @@ extern "C" {
 #define GT_PORTVEC_2_LPORTVEC(_pvec)       (GT_U32)((_pvec) & 0xffff)
 #define GT_LPORT_2_PHY(_lport)      (GT_U8)((_lport) & 0xff)
 #else
-#define GT_LPORT_2_PORT(_lport)      lport2port(dev->validPortVec, _lport)
-#define GT_PORT_2_LPORT(_port)       port2lport(dev->validPortVec, _port)
-#define GT_LPORTVEC_2_PORTVEC(_lvec)	lportvec2portvec(dev->validPortVec, _lvec)
-#define GT_PORTVEC_2_LPORTVEC(_pvec)	portvec2lportvec(dev->validPortVec, _pvec)
-#define GT_LPORT_2_PHY(_lport) 			lport2phy(dev,_lport)
+ #define GT_LPORT_2_PHY(_lport)       lport2phy(dev,_lport)
+ #ifdef GT_PORT_MAP_IN_DEV
+  #define GT_LPORT_2_PORT(_lport)      dev->lport2port(dev->validPortVec, _lport)
+  #define GT_PORT_2_LPORT(_port)       dev->port2lport(dev->validPortVec, _port)
+  #define GT_LPORTVEC_2_PORTVEC(_lvec) dev->lportvec2portvec(dev->validPortVec, _lvec)
+  #define GT_PORTVEC_2_LPORTVEC(_pvec) dev->portvec2lportvec(dev->validPortVec, _pvec)
+ #else
+  #define GT_LPORT_2_PORT(_lport)      lport2port(dev->validPortVec, _lport)
+  #define GT_PORT_2_LPORT(_port)       port2lport(dev->validPortVec, _port)
+  #define GT_LPORTVEC_2_PORTVEC(_lvec) lportvec2portvec(dev->validPortVec, _lvec)
+  #define GT_PORTVEC_2_LPORTVEC(_pvec) portvec2lportvec(dev->validPortVec, _pvec)
 #endif
 
-#define GT_IS_PORT_SET(_portVec, _port)	\
-			((_portVec) & (0x1 << (_port)))
+#endif
+
+#define GT_IS_PORT_SET(_portVec, _port)    \
+            ((_portVec) & (0x1 << (_port)))
 
-#define GT_IS_IRLUNIT_VALID(_dev,_unit)		\
-		(((_dev)->deviceId == GT_88E6065)?(_unit < 12):	\
-		(((_dev)->deviceId == GT_88E6055)?(_unit < 12):	\
-		(((_dev)->deviceId == GT_88E6061)?(_unit < 6):	\
-		(((_dev)->deviceId == GT_88E6035)?(_unit < 6):	\
-										 (_unit < 3)))))
+#define GT_IS_IRLUNIT_VALID(_dev,_unit)        \
+        (((_dev)->deviceId == GT_88E6065)?(_unit < 12):    \
+        (((_dev)->deviceId == GT_88E6055)?(_unit < 12):    \
+        (((_dev)->deviceId == GT_88E6061)?(_unit < 6):    \
+        (((_dev)->deviceId == GT_88E6035)?(_unit < 6):    \
+                                         (_unit < 3)))))
 
 
 /* The following macro converts a binary    */
@@ -73,710 +81,997 @@ extern "C" {
             (binVal) = (((boolVal) == GT_TRUE) ? 0 : 1)
 
 /* Bit definition for devStorage */
-/* Ingress/Egress Rate type (grcSetPri0Rate,	grcSetEgressRate) */
-#define GT_RATE_ENUM_NOT_USED		0x10000
-#define GT_RATE_ENUM_USED			0x00000
+/* Ingress/Egress Rate type (grcSetPri0Rate,    grcSetEgressRate) */
+#define GT_RATE_ENUM_NOT_USED        0x10000
+#define GT_RATE_ENUM_USED        0x00000
 
 /* device name - devName */
-#define DEV_88E6051                      0x0001    /* quarterdeck 6051      */
-#define DEV_88E6052                      0x0002    /* quarterdeck 6052      */
-#define DEV_88E6021                      0x0004    /* fullsail              */
-#define DEV_88E6060                      0x0008    /* Gondola               */
-#define DEV_88E6063                      0x0010    /* clippership 6063      */
-#define DEV_FF_EG                        0x0020    /* FireFox-EG            */
-#define DEV_FF_HG                        0x0040    /* FireFox-HG            */
-#define DEV_FH_VPN                       0x0080    /* FireHawk-VPN          */
-#define DEV_88E6083                      0x0100    /* Octane 6083           */
-#define DEV_88E6181                      0x0200    /* Sapphire 88E6181      */
-#define DEV_88E6183                      0x0400    /* Sapphire 88E6153,88E6183 */
-#define DEV_88E6093	 	                 0x0800   /* 88E6093                  */
-#define DEV_88E6092	 	                 0x1000   /* 88E6092                  */
-#define DEV_88E6095	 	                 0x2000   /* 88E6095                  */
-#define DEV_88E6182                      0x4000   /* Jade 88E6152, 88E6182 */
-#define DEV_88E6185                      0x8000   /* Jade 88E6155, 88E6185 */
-#define DEV_88E6108                      0x10000   /* 88E6108 */
-#define DEV_88E6061                      0x20000   /* 88E6031, 88E6061 */
-#define DEV_88E6065                      0x40000   /* 88E6035, 88E6055, 88E6065 */
-#define DEV_88E6096                      0x80000   /* 88E6096, 88E6046 */
-#define DEV_88E6097                      0x100000   /* 88E6097, 88E6047 */
-#define DEV_88E6161                      0x200000   /* 88E6161 */
-#define DEV_88E6165                      0x400000   /* 88E6165 */
-
-#define DEV_88E6351                      0x800000   /* 88E6351 */
-#define DEV_88E6175                      0x1000000  /* 88E6175 */
-#define DEV_88E6171                      0x2000000  /* 88E6125 and 88E6171 */
-#define DEV_88E6371                      0x4000000  /* 88E6321, 88E6350 */
-
-#define DEV_88E6097_FAMILY	( DEV_88E6096 | DEV_88E6097 )
-#define DEV_88E6165_FAMILY	( DEV_88E6161 | DEV_88E6165 )
-
-#define DEV_88E6351_AVB_FAMILY	( DEV_88E6351 | DEV_88E6371 )
-#define DEV_88E6351_NO_AVB_FAMILY	( DEV_88E6175 | DEV_88E6171 )
-#define DEV_88E6351_FAMILY	( DEV_88E6351_AVB_FAMILY | DEV_88E6351_NO_AVB_FAMILY)
-
-#define DEV_88E6095_FAMILY	( DEV_88E6092 | DEV_88E6095 )
-#define DEV_88E6185_FAMILY	( DEV_88E6182 | DEV_88E6185 | DEV_88E6108)
-
-#define DEV_88E6065_FAMILY	( DEV_88E6061 | DEV_88E6065 )
+#define DEV_88E6051              0x0001    /* quarterdeck 6051      */
+#define DEV_88E6052              0x0002    /* quarterdeck 6052      */
+#define DEV_88E6021              0x0004    /* fullsail              */
+#define DEV_88E6060              0x0008    /* Gondola               */
+#define DEV_88E6063              0x0010    /* clippership 6063      */
+#define DEV_FF_EG                0x0020    /* FireFox-EG            */
+#define DEV_FF_HG                0x0040    /* FireFox-HG            */
+#define DEV_FH_VPN               0x0080    /* FireHawk-VPN          */
+#define DEV_88E6083              0x0100    /* Octane 6083           */
+#define DEV_88E6181              0x0200    /* Sapphire 88E6181      */
+#define DEV_88E6183              0x0400    /* Sapphire 88E6153,88E6183 */
+#define DEV_88E6093				 0x0800   /* 88E6093                  */
+#define DEV_88E6092	             0x1000   /* 88E6092                  */
+#define DEV_88E6095              0x2000   /* 88E6095                  */
+#define DEV_88E6182              0x4000   /* Jade 88E6152, 88E6182 */
+#define DEV_88E6185              0x8000   /* Jade 88E6155, 88E6185 */
+#define DEV_88E6108              0x10000   /* 88E6108 */
+#define DEV_88E6061              0x20000   /* 88E6031, 88E6061 */
+#define DEV_88E6065              0x40000   /* 88E6035, 88E6055, 88E6065 */
+#define DEV_88E6096              0x80000   /* 88E6096, 88E6046 */
+#define DEV_88E6097              0x100000   /* 88E6097, 88E6047 */
+#define DEV_88E6161              0x200000   /* 88E6161 */
+#define DEV_88E6165              0x400000   /* 88E6165 */
+#define DEV_88E6351              0x800000   /* 88E6351 */
+#define DEV_88E6175              0x1000000  /* 88E6175 */
+#define DEV_88E6171              0x2000000  /* 88E6125 and 88E6171 */
+#define DEV_88E6371              0x4000000  /* 88E6321, 88E6350 */
+#define DEV_88E6172              0x8000000  /* 88E6172 */
+#define DEV_88E6176              0x10000000 /* 88E6176 */
+#define DEV_88E6240              0x20000000 /* 88E6240 */
+#define DEV_88E6352              0x40000000 /* 88E6352 */
+
+/* device name 1 - devName1. These name for extended device family */
+#define DEV_88EC000                      0x000000001  /* Melody 88EC0XX  */
+#define DEV_88E3020                      0x000000010  /* Spannaker 88E3020  */
+#define DEV_88E6020                      0x000000020  /* Spannaker 88E6020  */
+#define DEV_88E6070                      0x000000040  /* Spannaker 88E6070  */
+#define DEV_88E6071                      0x000000080  /* Spannaker 88E6071  */
+#define DEV_88E6220                      0x000000100  /* Spannaker 88E6220  */
+#define DEV_88E6250                      0x000000200  /* Spannaker 88E6250  */
+
+
+#define DEV_88E6097_FAMILY    ( DEV_88E6096 | DEV_88E6097 )
+#define G1_DEV_88E6097_FAMILY     0
+#define DEV_88E6165_FAMILY    ( DEV_88E6161 | DEV_88E6165 )
+#define G1_DEV_88E6165_FAMILY     0
+
+#define DEV_88E6351_AVB_FAMILY    ( DEV_88E6351 | DEV_88E6371 )
+#define G1_DEV_88E6351_AVB_FAMILY      0
+#define DEV_88E6351_NO_AVB_FAMILY    (DEV_88E6171)
+#define G1_DEV_88E6351_NO_AVB_FAMILY   0
+#define DEV_88E6351_FAMILY    ( DEV_88E6351_AVB_FAMILY | DEV_88E6351_NO_AVB_FAMILY)
+#define G1_DEV_88E6351_FAMILY      0
+
+#define DEV_88E6352_AVB_FAMILY    ( DEV_88E6352 | DEV_88E6240 )
+#define G1_DEV_88E6352_AVB_FAMILY      0
+#define DEV_88E6352_NO_AVB_FAMILY    (DEV_88E6172 | DEV_88E6176)
+#define G1_DEV_88E6352_NO_AVB_FAMILY   0
+#define DEV_88E6352_FAMILY    ( DEV_88E6352_AVB_FAMILY | DEV_88E6352_NO_AVB_FAMILY)
+#define G1_DEV_88E6352_FAMILY      0
+
+/* AVB family includes all avb chips except Melody and SpannakAv */
+#define DEV_AVB_FAMILY    ( DEV_88E6351_AVB_FAMILY | DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_AVB_FAMILY      0
+
+#define DEV_TCAM_FAMILY    ( DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_TCAM_FAMILY      0
+
+#define DEV_88EC000_FAMILY            0
+#define G1_DEV_88EC000_FAMILY     (DEV_88EC000)
+#define DEV_88ESPANNAK_FAMILY            0
+#define G1_DEV_88ESPANNAK_FAMILY  (DEV_88E3020 | DEV_88E6020 | DEV_88E6070 | DEV_88E6071 | DEV_88E6220  | DEV_88E6250 )
+#define DEV_FE_AVB_FAMILY            0
+#define G1_DEV_FE_AVB_FAMILY     ( G1_DEV_88EC000_FAMILY | G1_DEV_88ESPANNAK_FAMILY )
+
+#define DEV_88E6095_FAMILY    ( DEV_88E6092 | DEV_88E6095 )
+#define G1_DEV_88E6095_FAMILY     0
+#define DEV_88E6185_FAMILY    ( DEV_88E6182 | DEV_88E6185 | DEV_88E6108)
+#define G1_DEV_88E6185_FAMILY     0
+
+#define DEV_88E6065_FAMILY    ( DEV_88E6061 | DEV_88E6065 )
+#define G1_DEV_88E6065_FAMILY     0
 
 #define DEV_NEW_FEATURE_IN_REV (DEV_88E6095_FAMILY | DEV_88E6182 | DEV_88E6185)
-
-#define DEV_BURST_RATE		( DEV_88E6108 )
-#define DEV_DROP_BCAST		( DEV_88E6108 )
-#define DEV_ARP_PRI	    ( DEV_88E6108 )
-#define DEV_SNOOP_PRI	    ( DEV_88E6108 )
-#define DEV_SERDES_CORE	( DEV_88E6108 | DEV_88E6165_FAMILY )
-
-#define DEV_AGE_INTERRUPT		\
-						( DEV_88E6108 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_AGE_INT_GLOBAL2	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_AGE_OUT_INT		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_AGE_HOLD			\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_DEVICE_INTERRUPT	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_DEVICE_INT_TYPE1	\
-						( DEV_88E6097_FAMILY )	/* Serdes Int bit[10:8] */
-#define DEV_DEVICE_INT_TYPE2	\
-						( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )	/* Serdes Int bit[12:11], Phy Int bit[4:0] */
-
-#define DEV_WATCHDOG_EVENT		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_PORT_BASED_AGE_INT	( DEV_88E6065_FAMILY )
-
-#define DEV_DEV_PHY_INTERRUPT	\
-						( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )	/* device interrupt includes phy int */
-
-#define DEV_AVB_INTERRUPT		\
-						( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_AUTO_REFRESH_LOCKED	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_PPU_PHY_ACCESS			\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_PPU_PHY_ACCESS_RES	( DEV_88E6097_FAMILY )
-
-#define DEV_PPU_READ_ONLY			\
-						( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_PPU_SERDES_ACCESS_RES	( DEV_88E6165_FAMILY )
-
-#define DEV_NO_EGRESS_POLICY		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
+#define G1_DEV_NEW_FEATURE_IN_REV  0
+
+#define DEV_BURST_RATE        ( DEV_88E6108 )
+#define G1_DEV_BURST_RATE     0
+#define DEV_DROP_BCAST        ( DEV_88E6108 )
+#define G1_DEV_DROP_BCAST     0
+#define DEV_ARP_PRI            ( DEV_88E6108 )
+#define G1_DEV_ARP_PRI             0
+#define DEV_SNOOP_PRI            ( DEV_88E6108 )
+#define G1_DEV_SNOOP_PRI      0
+#define DEV_SERDES_CORE    ( DEV_88E6108 | DEV_88E6165_FAMILY )
+#define G1_DEV_SERDES_CORE     0
+
+#define DEV_AGE_INTERRUPT  ( DEV_88E6108 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_INTERRUPT       ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_AGE_INT_GLOBAL2    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AGE_INT_GLOBAL2     (G1_DEV_FE_AVB_FAMILY)    
+#define DEV_AGE_OUT_INT        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_OUT_INT     ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_AGE_HOLD        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_AGE_HOLD         ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_DEVICE_INTERRUPT    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_DEVICE_INTERRUPT    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_DEVICE_INT_TYPE1    ( DEV_88E6097_FAMILY )    /* Serdes Int bit[10:8] */
+#define G1_DEV_DEVICE_INT_TYPE1    0    /* Serdes Int bit[10:8] */
+#define DEV_DEVICE_INT_TYPE2    ( DEV_88E6165_FAMILY)    
+#define G1_DEV_DEVICE_INT_TYPE2    0    
+#define DEV_DEVICE_INT_TYPE3    (  DEV_88E6352_FAMILY )    
+#define G1_DEV_DEVICE_INT_TYPE3    ( G1_DEV_FE_AVB_FAMILY )    
+
+#define DEV_WATCHDOG_EVENT    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_WATCHDOG_EVENT    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PORT_BASED_AGE_INT    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PORT_BASED_AGE_INT    0
+#define DEV_DEV_PHY_INTERRUPT    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)    /* device interrupt includes phy int */
+#define G1_DEV_DEV_PHY_INTERRUPT    ( G1_DEV_FE_AVB_FAMILY )    /* device interrupt includes phy int */
+
+#define DEV_AVB_INTERRUPT      ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AVB_INTERRUPT      ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_AUTO_REFRESH_LOCKED    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_AUTO_REFRESH_LOCKED    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PPU_PHY_ACCESS    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PPU_PHY_ACCESS    0
+#define DEV_PPU_PHY_ACCESS_RES    ( DEV_88E6097_FAMILY )
+#define G1_DEV_PPU_PHY_ACCESS_RES    0
+
+#define DEV_PPU_READ_ONLY    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PPU_READ_ONLY     ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PPU_SERDES_ACCESS_RES    ( DEV_88E6165_FAMILY )
+#define G1_DEV_PPU_SERDES_ACCESS_RES    0
+
+#define DEV_NO_EGRESS_POLICY    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_NO_EGRESS_POLICY    0
 
 /* DEV_8PORT_SWITCH is used to access the given device's Register Map */
-#define DEV_8PORT_SWITCH	( DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
-							  DEV_88E6093 | DEV_88E6097_FAMILY |			\
-							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-							  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
+#define DEV_8PORT_SWITCH    ( DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | \
+        DEV_88E6097_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | \
+        DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_8PORT_SWITCH 0
+
+/* DEV_MELODY_SWITCH is used to access the given device's Register Map */
+#define DEV_MELODY_SWITCH    0
+#define G1_DEV_MELODY_SWITCH    ( DEV_88EC000 | G1_DEV_88ESPANNAK_FAMILY )
 
-#define DEV_PORT_SECURITY	( DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 	\
-							  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define DEV_PORT_SECURITY    ( DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_PORT_SECURITY    0
 
-#define DEV_BROADCAST_INVALID	( DEV_88E6051 | DEV_88E6052 | DEV_FF_EG | DEV_FF_HG)
+#define DEV_BROADCAST_INVALID    ( DEV_88E6051 | DEV_88E6052 | DEV_FF_EG | DEV_FF_HG)
+#define G1_DEV_BROADCAST_INVALID 0
 
 /* Configurable ATU Size */
-#define DEV_ATU_256_2048 		( DEV_88E6021 | DEV_88E6060 | DEV_88E6065_FAMILY )
-#define DEV_ATU_562_2048 		\
-						( DEV_88E6052 | DEV_88E6063 | DEV_FF_HG | 	\
-						  DEV_FH_VPN | DEV_88E6083 )
-
-#define DEV_ATU_SIZE_FIXED	DEV_GIGABIT_SWITCH
-
-#define DEV_ATU_1024	(DEV_88E6108)	/* Not used */
-#define DEV_ATU_8192	(DEV_88E6095_FAMILY | DEV_88E6182 | DEV_88E6185)	/* Not used */
-
-#define DEV_ATU_LIMIT		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_ATU_LIMIT_READ		\
-						( DEV_88E6351_FAMILY )
-
-#define DEV_DBNUM_FULL 	\
-						( DEV_88E6021 | DEV_88E6060 | DEV_88E6063 | 	\
-						  DEV_FH_VPN |  DEV_88E6083 |					\
-						  DEV_88E6183 | DEV_88E6093 | DEV_88E6061 )
-
-#define DEV_DBNUM_64 	( DEV_88E6065 )
-#define DEV_DBNUM_256 	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-#define DEV_DBNUM_4096 	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_STATIC_ADDR	\
-						( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |			\
-						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
-						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | 	\
-						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |		\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_TRAILER		\
-						( DEV_88E6021 | DEV_FF_HG | DEV_88E6052 |  		\
-						  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
-
-#define DEV_TRAILER_P5		( DEV_FF_EG )
-#define DEV_TRAILER_P4P5	( DEV_88E6060 )
-
-#define DEV_HEADER		\
-						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |	\
-						  DEV_88E6083 |	DEV_88E6183 | DEV_88E6093 | \
-						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |	\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_HEADER_P5		( DEV_FF_EG )
-#define DEV_HEADER_P4P5  	( DEV_88E6060 )
+#define DEV_ATU_256_2048     ( DEV_88E6021 | DEV_88E6060 | DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_256_2048     0
+#define DEV_ATU_562_2048     ( DEV_88E6052 | DEV_88E6063 | DEV_FF_HG | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_ATU_562_2048     0
+
+#define DEV_ATU_SIZE_FIXED    DEV_GIGABIT_SWITCH
+#define G1_DEV_ATU_SIZE_FIXED    G1_DEV_GIGABIT_SWITCH
+
+#define DEV_ATU_1024    (DEV_88E6108)    /* Not used */
+#define G1_DEV_ATU_1024    0    /* Not used */
+#define DEV_ATU_8192    (DEV_88E6095_FAMILY | DEV_88E6182 | DEV_88E6185)    /* Not used */
+#define G1_DEV_ATU_8192    0    /* Not used */
+
+#define DEV_ATU_LIMIT        ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_ATU_LIMIT    0
+
+#define DEV_ATU_LIMIT_READ    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_ATU_LIMIT_READ    0
+
+#define DEV_DBNUM_FULL     ( DEV_88E6021 | DEV_88E6060 | DEV_88E6063 |     \
+      DEV_FH_VPN |  DEV_88E6083 |  DEV_88E6183 | DEV_88E6093 | DEV_88E6061 )
+#define G1_DEV_DBNUM_FULL     0
+
+#define DEV_DBNUM_64     ( DEV_88E6065 )
+#define G1_DEV_DBNUM_64     ( G1_DEV_88EC000_FAMILY  | G1_DEV_88ESPANNAK_FAMILY)
+#define DEV_DBNUM_256     ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_DBNUM_256     0
+#define DEV_DBNUM_4096     ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_DBNUM_4096    0 
+
+#define DEV_STATIC_ADDR    ( DEV_88E6060 | DEV_88E6021 | DEV_FF_EG | DEV_FF_HG | DEV_88E6052 | DEV_88E6063 | \
+            DEV_FH_VPN | DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_STATIC_ADDR    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_TRAILER     ( DEV_88E6021 | DEV_FF_HG | DEV_88E6052 |          \
+      DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_TRAILER     0
+
+#define DEV_TRAILER_P5        ( DEV_FF_EG )
+#define G1_DEV_TRAILER_P5    0
+#define DEV_TRAILER_P4P5    (DEV_88E6060)
+#define G1_DEV_TRAILER_P4P5    0
+
+#define DEV_HEADER    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 |    DEV_88E6183 | \
+        DEV_88E6093 |  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_HEADER    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_HEADER_P5        ( DEV_FF_EG )
+#define G1_DEV_HEADER_P5    0
+#define DEV_HEADER_P4P5      (DEV_88E6060)
+#define G1_DEV_HEADER_P4P5      0
 
 /* DEV_QoS : Devices with multiple Queues for QoS Priority Support */
-#define DEV_QoS			\
-						( DEV_88E6021 | DEV_FF_HG |	DEV_88E6051 | 		\
-						  DEV_88E6052 | DEV_88E6063 | DEV_FH_VPN |		\
-						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 	\
-						  DEV_88E6093 | DEV_88E6095_FAMILY |			\
-						  DEV_88E6185_FAMILY | DEV_88E6065_FAMILY | 	\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_QoS_FPRI_QPRI	( DEV_88E6065_FAMILY )
-#define DEV_QoS_WEIGHT		( DEV_88E6097 | DEV_88E6165 | DEV_88E6351_AVB_FAMILY | DEV_88E6175 )
-
-#define DEV_TAGGING			DEV_QoS
-
-#define DEV_EGRESS_DOUBLE_TAGGING	\
-						( DEV_QoS & ~(DEV_88E6051 | DEV_88E6092 | DEV_88E6182 | \
-									  DEV_88E6061 ) )
-
-#define DEV_INGRESS_DOUBLE_TAGGING	\
-						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-						  DEV_88E6095 | DEV_88E6185 | DEV_88E6108 )
-
-#define DEV_PRIORITY_REMAPPING		\
-						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-						  DEV_88E6095 | DEV_88E6185 | DEV_88E6108 |		\
-						  DEV_88E6065 | DEV_88E6097_FAMILY | 			\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-
-#define DEV_802_1Q		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
-						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
-						  DEV_88E6095 | DEV_88E6092 | DEV_88E6185_FAMILY |	\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |			\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_802_1S		( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 | DEV_88E6065 )
-#define DEV_802_1S_STU	( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_802_1W		( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | 	\
-						  DEV_88E6185 | DEV_88E6108 | DEV_88E6065 |		\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_ATU_15SEC_AGING	( DEV_GIGABIT_SWITCH | DEV_88E6065_FAMILY )
-#define DEV_ATU_RM_PORTS	( DEV_88E6093_FAMILY | DEV_88E6065 )
-#define DEV_ATU_EXT_PRI		( DEV_88E6065_FAMILY )
-
-#define DEV_VTU_EXT_INFO	( DEV_88E6065_FAMILY )
-
-#define DEV_RMON		( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | 			\
-						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
-						  DEV_88E6092 | DEV_88E6095 | DEV_88E6185_FAMILY |	\
-						  DEV_88E6065 | DEV_88E6097_FAMILY |				\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY ) 
-
-#define DEV_RMON_TYPE_1	( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 ) 
+#define DEV_QoS        ( DEV_88E6021 | DEV_FF_HG | DEV_88E6051 | DEV_88E6052 | DEV_88E6063 | \
+        DEV_FH_VPN | DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | \
+        DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | DEV_88E6065_FAMILY |     \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_QoS    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_QoS_FPRI_QPRI    ( DEV_88E6065_FAMILY )
+#define G1_DEV_QoS_FPRI_QPRI    0
+
+#define DEV_QoS_WEIGHT        ( DEV_88E6097 | DEV_88E6165 | DEV_AVB_FAMILY | DEV_88E6175 | DEV_88E6352_FAMILY)
+#define G1_DEV_QoS_WEIGHT    0
+
+#define DEV_TAGGING            (DEV_QoS)
+#define G1_DEV_TAGGING         (G1_DEV_QoS)
+
+#define DEV_EGRESS_DOUBLE_TAGGING ( DEV_QoS & ~(DEV_88E6051 | DEV_88E6092 | DEV_88E6182 | DEV_88E6061))
+#define G1_DEV_EGRESS_DOUBLE_TAGGING 0
+
+#define DEV_INGRESS_DOUBLE_TAGGING    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095 | DEV_88E6185 | DEV_88E6108 )
+#define G1_DEV_INGRESS_DOUBLE_TAGGING    0
+
+#define DEV_PRIORITY_REMAPPING        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | \
+    DEV_88E6185 | DEV_88E6108 | DEV_88E6065 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_PRIORITY_REMAPPING  ( G1_DEV_FE_AVB_FAMILY )
+
+
+#define DEV_802_1Q    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |     \
+              DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+              DEV_88E6095 | DEV_88E6092 | DEV_88E6185_FAMILY |\
+              DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |    \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_802_1Q    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_802_1S    ( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 | DEV_88E6065 )
+#define G1_DEV_802_1S    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_802_1S_STU    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_802_1S_STU    0
+
+#define DEV_802_1W    ( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 |     \
+              DEV_88E6185 | DEV_88E6108 | DEV_88E6065 |    \
+              DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_802_1W    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_ATU_15SEC_AGING    ( DEV_GIGABIT_SWITCH | DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_15SEC_AGING    0
+#define DEV_ATU_RM_PORTS    ( DEV_88E6093_FAMILY | DEV_88E6065 )
+#define G1_DEV_ATU_RM_PORTS    0
+#define DEV_ATU_EXT_PRI        ( DEV_88E6065_FAMILY )
+#define G1_DEV_ATU_EXT_PRI     ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_VTU_EXT_INFO    ( DEV_88E6065_FAMILY )
+#define G1_DEV_VTU_EXT_INFO    0
+#define DEV_RMON    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |     \
+              DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |     \
+              DEV_88E6092 | DEV_88E6095 | DEV_88E6185_FAMILY |\
+              DEV_88E6065 | DEV_88E6097_FAMILY |        \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY ) 
+#define G1_DEV_RMON    ( G1_DEV_FE_AVB_FAMILY ) 
+
+#define DEV_RMON_TYPE_1    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 ) 
+#define G1_DEV_RMON_TYPE_1    0 
 #define DEV_RMON_TYPE_2 ( DEV_88E6183 )
-#define DEV_RMON_TYPE_3 	\
-						( DEV_88E6093 | DEV_88E6095 | DEV_88E6092 | 	\
-						  DEV_88E6185_FAMILY | DEV_88E6065 | 			\
-						  DEV_88E6097_FAMILY |		\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_RMON_REALTIME_SUPPORT	\
-						( DEV_88E6065 | DEV_88E6065_FAMILY |	\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |	\
-						  DEV_88E6351_FAMILY )
-#define DEV_RMON_PORT_BITS	( DEV_88E6065 | DEV_88E6065_FAMILY )
-
-#define DEV_IGMP_SNOOPING	\
-						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
-						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |			\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |			\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_PORT_MONITORING	\
-						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 | 		\
-						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |			\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |			\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_ENABLE_MONITORING	\
-						( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |			\
-						  DEV_88E6065_FAMILY )
-
-#define DEV_MC_RATE_PERCENT	\
-						( DEV_88E6021 | DEV_88E6051 | DEV_88E6052 )
-
-#define DEV_MC_RATE_KBPS	\
-						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 )
-
-#define DEV_INGRESS_RATE_KBPS	\
-						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
-						  DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
-
-#define DEV_EGRESS_RATE_KBPS	\
-						( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 		\
-						  DEV_88E6093 | DEV_88E6095 | DEV_88E6185 | 		\
-						  DEV_88E6108 | DEV_88E6065_FAMILY | 				\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_ELIMIT_FRAME_BASED	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_PIRL_RESOURCE	\
-						( DEV_88E6065_FAMILY )
-
-#define DEV_PIRL2_RESOURCE	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_RESTRICTED_PIRL_RESOURCE	\
-						( DEV_88E6061 )
-
-#define DEV_RESTRICTED_PIRL2_RESOURCE	\
-						( DEV_88E6096 | DEV_88E6161 | DEV_88E6171 )
-
-
-#define DEV_NONE_RATE_LIMIT		\
-						( DEV_88E6065 )
-
-#define DEV_MII_DUPLEX_CONFIG	\
-						( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |			\
-						  DEV_88E6083 )
-
-#define DEV_QD_PLUS 	\
-					( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |					\
-					  DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |				\
-					  DEV_88E6083 | DEV_88E6181 | DEV_88E6183 | 			\
-					  DEV_88E6093 | 										\
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |				\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY  |			\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_FASTETH_SWITCH	\
-					( DEV_88E6051 | DEV_88E6052 | DEV_88E6021 | 		\
-					  DEV_FF_EG | DEV_FF_HG | DEV_88E6060 | 			\
-					  DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 |			\
-					  DEV_88E6065_FAMILY )
-
-#define DEV_ENHANCED_FE_SWITCH		( DEV_88E6065_FAMILY )
-
-#define DEV_EXTERNAL_PHY	\
-					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |			\
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |			\
-					  DEV_88E6097_FAMILY )
-
-#define DEV_EXTERNAL_PHY_ONLY	( DEV_88E6181 | DEV_88E6183 | DEV_88E6182 | DEV_88E6185 )
+#define G1_DEV_RMON_TYPE_2 0
+#define DEV_RMON_TYPE_3     \
+        ( DEV_88E6093 | DEV_88E6095 | DEV_88E6092 |     \
+          DEV_88E6185_FAMILY | DEV_88E6065 |             \
+          DEV_88E6097_FAMILY |        \
+          DEV_88E6165_FAMILY | DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_RMON_TYPE_3 ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_RMON_REALTIME_SUPPORT    \
+        ( DEV_88E6065 | DEV_88E6065_FAMILY |    \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RMON_REALTIME_SUPPORT    ( G1_DEV_FE_AVB_FAMILY)
+#define DEV_RMON_PORT_BITS    \
+        ( DEV_88E6065 | DEV_88E6065 | DEV_88E6352_FAMILY )
+#define G1_DEV_RMON_PORT_BITS    \
+   ( G1_DEV_FE_AVB_FAMILY)
+
+#define DEV_IGMP_SNOOPING    \
+    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |         \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_IGMP_SNOOPING    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PORT_MONITORING    \
+    ( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |         \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_MONITORING    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_ENABLE_MONITORING    \
+    ( DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6183 | DEV_88E6093 |            \
+      DEV_88E6065_FAMILY )
+#define G1_DEV_ENABLE_MONITORING    0
+#define DEV_MC_RATE_PERCENT    ( DEV_88E6021 | DEV_88E6051 | DEV_88E6052 )
+#define G1_DEV_MC_RATE_PERCENT    0
+
+#define DEV_MC_RATE_KBPS    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 )
+#define G1_DEV_MC_RATE_KBPS    0
+
+#define DEV_INGRESS_RATE_KBPS    \
+    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |         \
+      DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY)
+#define G1_DEV_INGRESS_RATE_KBPS 0
+
+#define DEV_EGRESS_RATE_KBPS    \
+    ( DEV_FF_HG | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |         \
+      DEV_88E6093 | DEV_88E6095 | DEV_88E6185 |         \
+      DEV_88E6108 | DEV_88E6065_FAMILY |                 \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |         \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EGRESS_RATE_KBPS    ( G1_DEV_FE_AVB_FAMILY)
+
+#define DEV_ELIMIT_FRAME_BASED    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ELIMIT_FRAME_BASED    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PIRL_RESOURCE    \
+    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PIRL_RESOURCE    0
+
+#define DEV_PIRL2_RESOURCE    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PIRL2_RESOURCE     \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_RESTRICTED_PIRL_RESOURCE    \
+    ( DEV_88E6061 )
+#define G1_DEV_RESTRICTED_PIRL_RESOURCE    0
+
+#define DEV_RESTRICTED_PIRL2_RESOURCE    \
+                        ( DEV_88E6096 | DEV_88E6161 | DEV_88E6171 )
+#define G1_DEV_RESTRICTED_PIRL2_RESOURCE    0
+
+#define DEV_NONE_RATE_LIMIT        \
+    ( DEV_88E6065 )  
+#define G1_DEV_NONE_RATE_LIMIT        0
+
+#define DEV_MII_DUPLEX_CONFIG    \
+    ( DEV_88E6021 | DEV_88E6063 | DEV_FH_VPN |            \
+      DEV_88E6083 )
+#define G1_DEV_MII_DUPLEX_CONFIG    0
+
+#define DEV_QD_PLUS     \
+    ( DEV_88E6021 | DEV_FF_EG | DEV_FF_HG |            \
+      DEV_88E6060 | DEV_88E6063 | DEV_FH_VPN |        \
+      DEV_88E6083 | DEV_88E6181 | DEV_88E6183 |             \
+      DEV_88E6093 |                        \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY  |            \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_QD_PLUS     \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FASTETH_SWITCH    \
+    ( DEV_88E6051 | DEV_88E6052 | DEV_88E6021 |         \
+      DEV_FF_EG | DEV_FF_HG | DEV_88E6060 |             \
+      DEV_88E6063 | DEV_FH_VPN | DEV_88E6083 |            \
+      DEV_88E6065_FAMILY )
+#define G1_DEV_FASTETH_SWITCH    0
+#define DEV_ENHANCED_FE_SWITCH        ( DEV_88E6065_FAMILY )
+#define G1_DEV_ENHANCED_FE_SWITCH    0
+
+#define DEV_EXTERNAL_PHY    \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |            \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |            \
+      DEV_88E6097_FAMILY )
+#define G1_DEV_EXTERNAL_PHY    0
+
+#define DEV_EXTERNAL_PHY_ONLY    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6182 | DEV_88E6185 )
+#define G1_DEV_EXTERNAL_PHY_ONLY    0
 
 #define DEV_INTERNAL_GPHY   ( DEV_88E6108 )
-
-#define DEV_FC_WITH_VALUE			\
-					( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |	\
-					  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |					\
-					  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_FC_STATUS				\
-					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | 	\
-					  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |		\
-					  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_FC_DIS_STATUS	( DEV_88E6065_FAMILY )
-
-#define DEV_CORE_TAG		( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-#define DEV_PCS_LINK		( DEV_88E6093 | DEV_88E6095_FAMILY | 	\
-							  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |	\
-							  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_MGMII_STATUS	( DEV_88E6093 | DEV_88E6095_FAMILY | 	\
-							  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |	\
-							  DEV_88E6165_FAMILY )
-
-#define DEV_MGMII_REVERSE_STATUS	( DEV_88E6165_FAMILY )
-
-#define DEV_88E6183_FAMILY		( DEV_88E6183 | DEV_88E6185_FAMILY )
-#define DEV_88E6093_FAMILY		( DEV_88E6093 | DEV_88E6095_FAMILY | 		\
-								  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |	\
-								  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_UNMANAGED_SWITCH	( DEV_88E6181 )
-
-#define DEV_PCS					\
-					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | 	\
-					  DEV_88E6097_FAMILY )
-
-#define DEV_GIGABIT_SWITCH		\
-					( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | 	\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_GIGABIT_MANAGED_SWITCH	\
-					( DEV_88E6183 | DEV_88E6093 | \
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY | 	\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_CASCADE_PORT	\
-					( DEV_88E6183 | DEV_88E6093 | \
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-
-#define DEV_CROSS_CHIP_VLAN		\
-					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-#define DEV_CROSS_CHIP_PORT_VLAN	\
-					( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |	\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_TRUNK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_8_TRUNKING	( DEV_88E6092 | DEV_88E6182 )
-
-#define DEV_TRUNK_NEW_ID_LOCATION	\
-					( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_REDUCED_TRUNK	( DEV_88E6065_FAMILY )
-
-#define DEV_STACKING	\
-					( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 |		\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_FRAME_SIZE_1632		\
-					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )		/* Not used */
-
-#define DEV_FLOW_CTRL_DELAY		\
-					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-					  DEV_88E6351_FAMILY )
+#define G1_DEV_INTERNAL_GPHY   0
+
+#define DEV_FC_WITH_VALUE            \
+    ( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |            \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FC_WITH_VALUE            \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_FC_STATUS                \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FC_STATUS                \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_FC_DIS_STATUS    ( DEV_88E6065_FAMILY )
+#define G1_DEV_FC_DIS_STATUS    0
+
+#define DEV_CORE_TAG    ( DEV_88E6093 | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CORE_TAG    0
+#define DEV_PCS_LINK    ( DEV_88E6093 | DEV_88E6095_FAMILY |     \
+              DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |    \
+              DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PCS_LINK    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_MGMII_STATUS    ( DEV_88E6093 | DEV_88E6095_FAMILY |     \
+                  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY | \
+                  DEV_88E6165_FAMILY )
+#define G1_DEV_MGMII_STATUS    0
+
+#define DEV_MGMII_REVERSE_STATUS    ( DEV_88E6165_FAMILY )
+#define G1_DEV_MGMII_REVERSE_STATUS    0
+
+#define DEV_88E6183_FAMILY        ( DEV_88E6183 | DEV_88E6185_FAMILY )
+#define G1_DEV_88E6183_FAMILY        0
+#define DEV_88E6093_FAMILY    ( DEV_88E6093 | DEV_88E6095_FAMILY |\
+                  DEV_88E6185_FAMILY | DEV_88E6097_FAMILY |\
+                  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_88E6093_FAMILY    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_UNMANAGED_SWITCH    ( DEV_88E6181 )
+#define G1_DEV_UNMANAGED_SWITCH    0
+
+#define DEV_PCS                    \
+        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY )
+#define G1_DEV_PCS                    0
+
+#define DEV_GIGABIT_SWITCH        \
+        ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_GIGABIT_SWITCH        0
+
+#define DEV_GIGABIT_MANAGED_SWITCH    \
+        ( DEV_88E6183 | DEV_88E6093 | \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |     \
+          DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+          DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_GIGABIT_MANAGED_SWITCH    0
+
+#define DEV_CASCADE_PORT    \
+        ( DEV_88E6183 | DEV_88E6093 | \
+          DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CASCADE_PORT 0
+
+
+#define DEV_CROSS_CHIP_VLAN        \
+        ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CROSS_CHIP_VLAN        0
+
+#define DEV_CROSS_CHIP_PORT_VLAN    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_CROSS_CHIP_PORT_VLAN    0
+
+#define DEV_TRUNK    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |    \
+              DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |    \
+              DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TRUNK    0
+
+#define DEV_8_TRUNKING    ( DEV_88E6092 | DEV_88E6182 )
+#define G1_DEV_8_TRUNKING    0
+
+#define DEV_TRUNK_NEW_ID_LOCATION    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TRUNK_NEW_ID_LOCATION     0
+
+#define DEV_REDUCED_TRUNK    ( DEV_88E6065_FAMILY )
+#define G1_DEV_REDUCED_TRUNK   \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_STACKING    \
+    ( DEV_88E6095 | DEV_88E6185 | DEV_88E6108 |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_STACKING    0
+
+#define DEV_FRAME_SIZE_1632        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )        /* Not used */
+#define G1_DEV_FRAME_SIZE_1632        0        /* Not used */
+
+#define DEV_FLOW_CTRL_DELAY        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FLOW_CTRL_DELAY        0
 
 /* port based CPU Port */
-#define DEV_ENHANCED_CPU_PORT	\
-					( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-					  DEV_88E6351_FAMILY )
-
-#define DEV_CPU_DEST_PER_PORT	\
-					( DEV_88E6183 | DEV_88E6093 | \
-					  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-#define DEV_CPU_PORT	( DEV_88E6065_FAMILY )
-#define DEV_MULTICAST	( DEV_88E6065_FAMILY )
-
-#define DEV_CPU_DEST		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_MIRROR_DEST	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_QVLAN_ONLY		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
-#define DEV_5BIT_PORT		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_SDET_POLARITY	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
-#define DEV_LIMITED_SDET	\
-						( DEV_88E6165_FAMILY ) 	/* only port 4 & 5 support SDET Polarity */
+#define DEV_ENHANCED_CPU_PORT    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_CPU_PORT    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_CPU_DEST_PER_PORT    \
+    ( DEV_88E6183 | DEV_88E6093 | \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_CPU_DEST_PER_PORT   0
+
+#define DEV_CPU_PORT    ( DEV_88E6065_FAMILY )
+#define G1_DEV_CPU_PORT    0
+#define DEV_MULTICAST    ( DEV_88E6065_FAMILY )
+#define G1_DEV_MULTICAST    0
+
+#define DEV_CPU_DEST        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_CPU_DEST        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_MIRROR_DEST    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MIRROR_DEST    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_QVLAN_ONLY        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
+#define G1_DEV_QVLAN_ONLY        0
+#define DEV_5BIT_PORT        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_5BIT_PORT        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_SDET_POLARITY    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY )
+#define G1_DEV_SDET_POLARITY    0
+#define DEV_LIMITED_SDET    \
+        ( DEV_88E6165_FAMILY )     /* only port 4 & 5 support SDET Polarity */
+
+#define G1_DEV_LIMITED_SDET    0    /* only port 4 & 5 support SDET Polarity */
 
 /* supports Reserved Multicast, etc */
-#define DEV_ENHANCED_MULTICAST	\
-						( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_ENHANCED_MULTICAST_2X	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
-						  DEV_88E6351_FAMILY )
-
-
-#define DEV_ARP_DEST_SUPPORT		( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-#define DEV_MARVELL_TAG_FLOW_CTRL	\
-						( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-						  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |		\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_USE_DOUBLE_TAG_DATA		\
-						( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )		/* Not Used */
-
-#define DEV_MARVELL_TAG_LOOP_BLOCK	( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
-
-#define DEV_LOOPBACK_FILTER		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_FLOOD_BROADCAST		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_TAG_FLOW_CONTROL		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_ALWAYS_USE_VTU		( DEV_88E6097_FAMILY )
-
-#define DEV_RM_ONE_PTAG			\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-					
-#define DEV_PRIORITY_OVERRIDE	\
-						( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 | 	\
-						  DEV_88E6185 | DEV_88E6108 | DEV_88E6097_FAMILY |	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_EXT_PRIORITY_OVERRIDE		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_PRIORITY_OVERRIDE_TABLE	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_FQPRI_IN_TABLE		( DEV_88E6065 )
-
-#define DEV_FQPRI_OVERRIDE		( DEV_88E6065 )
-
-#define DEV_Px_MODE 	( DEV_88E6065_FAMILY )
-
-#define DEV_SA_FILTERING	\
-						( DEV_88E6065 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
-						  DEV_88E6351_FAMILY )
-
-#define DEV_ARP_TO_CPU		\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_EGRESS_FLOOD	\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_FORCE_MAP		( DEV_88E6065_FAMILY )
-
-#define DEV_PORT_SCHEDULE	( DEV_88E6065 )
-
-#define DEV_PORT_MIXED_SCHEDULE		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_OUT_Q_SIZE		\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_OUT_Q_512		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-#define DEV_FULL_Q_COUNTER		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_PROVIDER_TAG	( DEV_88E6065_FAMILY )
-
-#define DEV_OLD_HEADER		( DEV_88E6065_FAMILY )
-
-#define DEV_RECURSIVE_TAG_STRIP		( DEV_88E6065_FAMILY )
-
-#define DEV_FORCE_WITH_VALUE			\
-						( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 | 	\
-						  DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |		\
-						  DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |		\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
+#define DEV_ENHANCED_MULTICAST    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_MULTICAST    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_ENHANCED_MULTICAST_2X    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ENHANCED_MULTICAST_2X    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+
+#define DEV_ARP_DEST_SUPPORT    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_ARP_DEST_SUPPORT    ( G1_DEV_88E6095_FAMILY | G1_DEV_88E6185_FAMILY )
+#define DEV_MARVELL_TAG_FLOW_CTRL    \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |        \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MARVELL_TAG_FLOW_CTRL    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_USE_DOUBLE_TAG_DATA        \
+    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )        /* Not Used */
+#define G1_DEV_USE_DOUBLE_TAG_DATA        0        /* Not Used */
+
+#define DEV_MARVELL_TAG_LOOP_BLOCK    ( DEV_88E6095_FAMILY | DEV_88E6185_FAMILY )
+#define G1_DEV_MARVELL_TAG_LOOP_BLOCK    0
+
+#define DEV_LOOPBACK_FILTER        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_LOOPBACK_FILTER        \
+    (G1_DEV_FE_AVB_FAMILY )
+#define DEV_FLOOD_BROADCAST        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FLOOD_BROADCAST        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_TAG_FLOW_CONTROL        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_TAG_FLOW_CONTROL        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_ALWAYS_USE_VTU        ( DEV_88E6097_FAMILY )
+#define G1_DEV_ALWAYS_USE_VTU        0
+
+#define DEV_RM_ONE_PTAG            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RM_ONE_PTAG            \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+                    
+#define DEV_PRIORITY_OVERRIDE    \
+    ( DEV_88E6183 | DEV_88E6093 | DEV_88E6095 |     \
+      DEV_88E6185 | DEV_88E6108 | DEV_88E6097_FAMILY |    \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PRIORITY_OVERRIDE    \
+      ( G1_DEV_FE_AVB_FAMILY)
+
+#define DEV_EXT_PRIORITY_OVERRIDE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EXT_PRIORITY_OVERRIDE        \
+      ( G1_DEV_FE_AVB_FAMILY)
+
+#define DEV_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FQPRI_IN_TABLE        ( DEV_88E6065 )
+#define G1_DEV_FQPRI_IN_TABLE     0
+
+#define DEV_MACPRI_IN_TABLE        0
+#define G1_DEV_MACPRI_IN_TABLE     ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FQPRI_OVERRIDE        ( DEV_88E6065 )
+#define G1_DEV_FQPRI_OVERRIDE        0
+
+#define DEV_Px_MODE     ( DEV_88E6065_FAMILY )
+#define G1_DEV_Px_MODE     0
+
+#define DEV_SA_FILTERING    \
+    ( DEV_88E6065 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SA_FILTERING    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_ARP_TO_CPU        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ARP_TO_CPU        \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_EGRESS_FLOOD    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EGRESS_FLOOD    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FORCE_MAP        ( DEV_88E6065_FAMILY )
+#define G1_DEV_FORCE_MAP    0
+
+#define DEV_PORT_SCHEDULE    ( DEV_88E6065 )
+#define G1_DEV_PORT_SCHEDULE    0
+
+#define DEV_PORT_MIXED_SCHEDULE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_MIXED_SCHEDULE        \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_OUT_Q_SIZE        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_OUT_Q_SIZE        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_OUT_Q_512        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_OUT_Q_512        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_FULL_Q_COUNTER        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FULL_Q_COUNTER        \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PROVIDER_TAG    ( DEV_88E6065_FAMILY )
+#define G1_DEV_PROVIDER_TAG    0
+
+#define DEV_OLD_HEADER        ( DEV_88E6065_FAMILY )
+#define G1_DEV_OLD_HEADER        0
+#define DEV_RECURSIVE_TAG_STRIP        ( DEV_88E6065_FAMILY )
+#define G1_DEV_RECURSIVE_TAG_STRIP        0
+
+#define DEV_FORCE_WITH_VALUE            \
+    ( DEV_88E6181 | DEV_88E6183 | DEV_88E6093 |     \
+      DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |        \
+      DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FORCE_WITH_VALUE            \
+    ( G1_DEV_FE_AVB_FAMILY )
 
 /* Grouping ATU Entry State for Unicast */
 
-#define DEV_UC_7_DYNAMIC		\
-					( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |	DEV_88E6185_FAMILY |	\
-					  DEV_88E6183 | DEV_88E6093 | DEV_88E6097_FAMILY |					\
-					  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_UC_NO_PRI_TO_CPU_STATIC_NRL		\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_UC_TO_CPU_STATIC_NRL			\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_UC_NO_PRI_STATIC_NRL			\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_UC_STATIC_NRL					\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_UC_NO_PRI_TO_CPU_STATIC			\
-					( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |	DEV_88E6185_FAMILY |	\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_UC_TO_CPU_STATIC			\
-					( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |	DEV_88E6185_FAMILY |	\
-					  DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_UC_NO_PRI_STATIC			\
-					( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |	DEV_88E6185_FAMILY |	\
-					  DEV_88E6183 | DEV_88E6093 | DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | \
-					  DEV_88E6351_FAMILY )
-
-#define DEV_UC_STATIC	( DEV_STATIC_ADDR )
+#define DEV_UC_7_DYNAMIC        \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |    DEV_88E6185_FAMILY |\
+      DEV_88E6183 | DEV_88E6093 | DEV_88E6097_FAMILY |        \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_7_DYNAMIC        \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_UC_NO_PRI_TO_CPU_STATIC_NRL        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_TO_CPU_STATIC_NRL        \
+    (  G1_DEV_FE_AVB_FAMILY )
+#define DEV_UC_TO_CPU_STATIC_NRL            \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_TO_CPU_STATIC_NRL            \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_UC_NO_PRI_STATIC_NRL            \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_STATIC_NRL            \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_UC_STATIC_NRL                    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_STATIC_NRL                    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_UC_NO_PRI_TO_CPU_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_TO_CPU_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_UC_TO_CPU_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY | DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_TO_CPU_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_UC_NO_PRI_STATIC            \
+    ( DEV_88E6065_FAMILY | DEV_88E6095_FAMILY |    DEV_88E6185_FAMILY |\
+      DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |\
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_UC_NO_PRI_STATIC            \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_UC_STATIC    ( DEV_STATIC_ADDR )
+#define G1_DEV_UC_STATIC    ( G1_DEV_STATIC_ADDR )
 
 
 /* Grouping ATU Entry State for Multicast */
 
-#define DEV_MC_MGM_STATIC_UNLIMITED_RATE		\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE	\
-						( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY | 	\
-						  DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
+#define DEV_MC_MGM_STATIC_UNLIMITED_RATE        \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MC_MGM_STATIC_UNLIMITED_RATE        \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE    \
+    ( DEV_88E6065_FAMILY | DEV_88E6097_FAMILY |     \
+      DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE    \
+    ( G1_DEV_FE_AVB_FAMILY )
 
-#define DEV_MC_STATIC_UNLIMITED_RATE	( DEV_STATIC_ADDR & ~DEV_88E6052 )
+#define DEV_MC_STATIC_UNLIMITED_RATE    ( DEV_STATIC_ADDR & ~DEV_88E6052 )
+#define G1_DEV_MC_STATIC_UNLIMITED_RATE    ( G1_DEV_STATIC_ADDR )
 
-#define DEV_MC_MGM_STATIC		( DEV_STATIC_ADDR )
+#define DEV_MC_MGM_STATIC    ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_MGM_STATIC    ( G1_DEV_STATIC_ADDR )
 
-#define DEV_MC_STATIC				( DEV_STATIC_ADDR )
-#define DEV_MC_PRIO_MGM_STATIC		( DEV_STATIC_ADDR )
+#define DEV_MC_STATIC            ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_STATIC        ( G1_DEV_STATIC_ADDR )
+#define DEV_MC_PRIO_MGM_STATIC        ( DEV_STATIC_ADDR )
+#define G1_DEV_MC_PRIO_MGM_STATIC    ( G1_DEV_STATIC_ADDR )
 
 #define DEV_MC_PRIO_STATIC_UNLIMITED_RATE ( DEV_STATIC_ADDR & ~ (DEV_88E6083|DEV_88E6052) )
+#define G1_DEV_MC_PRIO_STATIC_UNLIMITED_RATE ( G1_DEV_STATIC_ADDR )
 
-#define DEV_MC_PRIO_STATIC		( DEV_STATIC_ADDR & ~DEV_88E6083 )
+#define DEV_MC_PRIO_STATIC        ( DEV_STATIC_ADDR & ~DEV_88E6083 )
+#define G1_DEV_MC_PRIO_STATIC        ( G1_DEV_STATIC_ADDR )
 
 
 /* Grouping Devices that support Pause Limit */
-#define DEV_PAUSE_LIMIT		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
+#define DEV_PAUSE_LIMIT        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PAUSE_LIMIT        \
+    ( G1_DEV_FE_AVB_FAMILY )
 
 /* Grouping Devices that support Frame Mode */
-#define DEV_FRAME_MODE			\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | 	\
-						  DEV_88E6351_FAMILY )
-
-#define DEV_POLICY			\
-						( DEV_88E6097 | DEV_88E6165 | DEV_88E6351_AVB_FAMILY | DEV_88E6175 )
-
-#define DEV_PORT_ETYPE		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_FID_REG		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_FRAME_TO_REGISTER	\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_RMU_MODE	( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_SWITCH_MAC_REG		\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_ATU_STATS			\
-						( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-
-#define DEV_JUMBO_MODE		\
-						( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY )
-#define DEV_PTP		( DEV_88E6165_FAMILY | DEV_88E6351_AVB_FAMILY )
-#define DEV_PTP_2		( DEV_88E6351_AVB_FAMILY )
-#define DEV_TAI		( DEV_88E6351_AVB_FAMILY )
-#define DEV_AVB_POLICY	( DEV_88E6351_AVB_FAMILY )
-#define DEV_QAV		( DEV_88E6351_AVB_FAMILY )
-
-#define DEV_TSM_RESOURCE	( DEV_88E6351_AVB_FAMILY )
-
-#define DEV_200BASE_CFG	( DEV_88E6351_FAMILY )
-#define DEV_RGMII_TIMING	( DEV_88E6351_FAMILY )
-#define DEV_Q_COUNTER_TABLE	( DEV_88E6351_FAMILY )
-#define DEV_LED_CFG		( DEV_88E6351_FAMILY )
-
-#define DEV_MAC_AVB		( DEV_88E6351_AVB_FAMILY )
-
-#define DEV_CLK_125		( DEV_88E6351_FAMILY )
-
-#define DEV_QAVB_PRIORITY_OVERRIDE_TABLE	\
-						( DEV_88E6351_AVB_FAMILY )
-#define DEV_FRAME_PRIORITY_OVERRIDE_TABLE	\
-						( DEV_88E6351_FAMILY )
-
-#define DEV_SCRATCH_MISC_CTRL		( DEV_88E6351_FAMILY )
-#define DEV_IP_MAPPING_TABLE		( DEV_88E6351_FAMILY )
-#define DEV_EEPROM					( DEV_88E6351_FAMILY )
-
+#define DEV_FRAME_MODE            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY |     \
+      DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FRAME_MODE            \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_POLICY            \
+    ( DEV_88E6097 | DEV_88E6165 | DEV_AVB_FAMILY | DEV_88E6175)
+#define G1_DEV_POLICY    ( G1_DEV_88E6351_FAMILY | G1_DEV_FE_AVB_FAMILY )
+#define DEV_PORT_ETYPE        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_PORT_ETYPE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_FID_REG        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FID_REG    0
+
+#define DEV_FRAME_TO_REGISTER    \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_FRAME_TO_REGISTER   0
+
+#define DEV_RMU_MODE    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_RMU_MODE  0
+
+#define DEV_DA_CHECK    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY )
+#define G1_DEV_DA_CHECK  0
+
+#define DEV_DA_CHECK_1    ( DEV_88E6352_FAMILY )
+#define G1_DEV_DA_CHECK_1  0
+
+#define DEV_HEADER_TYPE    (DEV_88E6352_FAMILY)
+#define G1_DEV_HEADER_TYPE  0
+
+#define DEV_COUNTER_MODE    (DEV_88E6352_FAMILY)
+#define G1_DEV_COUNTER_MODE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_SWITCH_MAC_REG        \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SWITCH_MAC_REG    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_SWITCH_WOL_WOF_REG       (DEV_88E6352_FAMILY)
+#define G1_DEV_SWITCH_WOL_WOF_REG    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_ATU_STATS            \
+    ( DEV_88E6097_FAMILY | DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_ATU_STATS    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_JUMBO_MODE        \
+    ( DEV_88E6165_FAMILY | DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_JUMBO_MODE  \
+    ( G1_DEV_88E6165_FAMILY | G1_DEV_88E6351_FAMILY| DEV_88E6352_FAMILY)
+#define DEV_PTP        ( DEV_88E6165_FAMILY | DEV_AVB_FAMILY )
+#define G1_DEV_PTP    \
+    ( G1_DEV_FE_AVB_FAMILY)
+#define DEV_PTP_2        ( DEV_AVB_FAMILY )
+#define G1_DEV_PTP_2        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_TAI        ( DEV_AVB_FAMILY )
+#define G1_DEV_TAI    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_TAI_MULTI_PTP_SYNC    ( DEV_AVB_FAMILY)
+#define G1_DEV_TAI_MULTI_PTP_SYNC    0
+#define DEV_TAI_EXT_CLK    ( DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_TAI_EXT_CLK    0
+#define DEV_ARRV_TS_MODE    ( DEV_88E6352_AVB_FAMILY)
+#define G1_DEV_ARRV_TS_MODE    0
+
+
+#define DEV_AVB_POLICY    ( DEV_AVB_FAMILY )
+#define G1_DEV_AVB_POLICY\
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_AVB_POLICY_RECOVER_CLK    ( DEV_AVB_FAMILY )
+#define G1_DEV_AVB_POLICY_RECOVER_CLK 0
+
+#define DEV_QAV        ( DEV_AVB_FAMILY )
+#define G1_DEV_QAV    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_QAV_QPRI_QTS_TOKEN        ( DEV_88E6351_AVB_FAMILY | DEV_88E6352_AVB_FAMILY )
+#define G1_DEV_QAV_QPRI_QTS_TOKEN    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_QAV_QPRI_RATE        0
+#define G1_DEV_QAV_QPRI_RATE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_QAV_ISO_DELAY_LIMIT        ( DEV_AVB_FAMILY )
+#define G1_DEV_QAV_ISO_DELAY_LIMIT    0
+
+#define DEV_TSM_RESOURCE    ( DEV_AVB_FAMILY )
+#define G1_DEV_TSM_RESOURCE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_200BASE_CFG    ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_200BASE_CFG        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_RGMII_TIMING    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_RGMII_TIMING        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_Q_COUNTER_TABLE    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_Q_COUNTER_TABLE        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_LED_CFG        ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_LED_CFG            ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_MAC_AVB        ( DEV_AVB_FAMILY)
+#define G1_DEV_MAC_AVB            ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_CLK_125        ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_CLK_125            ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_QAVB_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_AVB_FAMILY )
+#define G1_DEV_QAVB_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_FRAME_PRIORITY_OVERRIDE_TABLE    \
+    ( DEV_88E6351_FAMILY| DEV_88E6352_FAMILY )
+#define G1_DEV_FRAME_PRIORITY_OVERRIDE_TABLE    \
+    ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_SCRATCH_MISC_CTRL        ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_SCRATCH_MISC_CTRL        ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_IP_MAPPING_TABLE        ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_IP_MAPPING_TABLE            ( G1_DEV_FE_AVB_FAMILY )
+#define DEV_EEPROM            ( DEV_88E6351_FAMILY | DEV_88E6352_FAMILY)
+#define G1_DEV_EEPROM            ( G1_DEV_88E6351_FAMILY)
+
+#define DEV_RMGMT        (DEV_88E6351_FAMILY | DEV_88E6352_FAMILY| DEV_88E6097_FAMILY |DEV_88E6165_FAMILY)
+#define G1_DEV_RMGMT        ( G1_DEV_FE_AVB_FAMILY )
+
+#define DEV_PHY_ACCESS_NO_DIRECTLY    0
+#define G1_DEV_PHY_ACCESS_NO_DIRECTLY    ( G1_DEV_88ESPANNAK_FAMILY )
+
+#define DEV_TCAM        ( DEV_88E6352_FAMILY )
+#define G1_DEV_TCAM        0
 
 /* Macros to utilize Device Group */
 
-#define IS_IN_DEV_GROUP(dev,_group) (dev->devName & (_group))
+#define IS_IN_DEV_GROUP(dev,_group) ((dev->devName & (_group))||(dev->devName1 & (G1_##_group)))
 
 /* need to check port number(_hwPort) later */
-#define IS_VALID_API_CALL(dev,_hwPort, _devName)	    	\
-	((_hwPort == GT_INVALID_PORT) ? GT_BAD_PARAM :			\
-	(!(dev->devName & (_devName)) ? GT_NOT_SUPPORTED : GT_OK))
+#define IS_VALID_API_CALL(dev,_hwPort, _devName)            \
+    ((_hwPort == GT_INVALID_PORT) ? GT_BAD_PARAM :            \
+    (!((dev->devName & (_devName))||(dev->devName1 & (G1_##_devName))) ? GT_NOT_SUPPORTED : GT_OK))
 
-#define DOES_DEVPORT_SUPPORT_PCS(dev, _hwPort)			\
-	(!(dev->devName & DEV_GIGABIT_SWITCH) || \
-	 (dev->devName & DEV_INTERNAL_GPHY) ||   \
-	(!(dev->devName & DEV_EXTERNAL_PHY_ONLY) && (((_hwPort) < 8) || ((_hwPort) > 10)))	\
-	? 0 : 1)
+#define DOES_DEVPORT_SUPPORT_PCS(dev, _hwPort)            \
+    (!((dev->devName & DEV_GIGABIT_SWITCH)||(dev->devName1 & G1_DEV_GIGABIT_SWITCH)) || \
+     ((dev->devName & DEV_INTERNAL_GPHY)||(dev->devName1 & G1_DEV_INTERNAL_GPHY)) ||   \
+    (!((dev->devName & DEV_EXTERNAL_PHY_ONLY)||(dev->devName1 & G1_DEV_EXTERNAL_PHY_ONLY)) && (((_hwPort) < 8) || ((_hwPort) > 10)))    \
+    ? 0 : 1)
 
-#define IS_CONFIGURABLE_PHY(dev,_hwPort)	driverIsPhyAttached(dev,_hwPort)
-#define GT_GET_PHY_ID(dev,_hwPort)			driverGetPhyID(dev,_hwPort)
+#define IS_CONFIGURABLE_PHY(dev,_hwPort)    driverIsPhyAttached(dev,_hwPort)
+#define GT_GET_PHY_ID(dev,_hwPort)            driverGetPhyID(dev,_hwPort)
 
-#define GT_GET_SERDES_PORT(dev,_hwPort)		driverGetSerdesPort(dev,_hwPort)
+#define GT_GET_SERDES_PORT(dev,_hwPort)        driverGetSerdesPort(dev,_hwPort)
 
 #define GT_GIG_PHY_INT_MASK(dev,_portVct)    ((_portVct) = (_portVct) & 0xF7)
 
 
-#define RECOMMENDED_ESB_LIMIT(dev, _bps)					\
-		((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?16777200:0xFFFFFF)
+#define RECOMMENDED_ESB_LIMIT(dev, _bps)                    \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?16777200:0xFFFFFF)
 
-#define RECOMMENDED_CBS_LIMIT(dev, _bps)					\
-		((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?393216:0x200000)
+#define RECOMMENDED_CBS_LIMIT(dev, _bps)                    \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?393216:0x200000)
 
-#define RECOMMENDED_BUCKET_INCREMENT(dev, _bps)				\
-		((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?174:		\
-		((_bps) < 1000)?0x3d:							\
-		((_bps) < 10000)?0x1f:0x4)
+#define RECOMMENDED_BUCKET_INCREMENT(dev, _bps)                \
+        ((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))?174:        \
+        ((_bps) < 1000)?0x3d:                            \
+        ((_bps) < 10000)?0x1f:0x4)
 
-#define FACTOR_FROM_BUCKET_INCREMENT(dev, _bInc, _f)		\
-	{														\
-		if(IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))			\
-		{													\
-			if((_bInc) == 174) {(_f) = 64;}					\
-			else {(_f) = 0;}								\
-		}													\
-		else												\
-		{													\
-			if((_bInc) == 0x3d) {(_f) = 64;}				\
-			else if((_bInc) == 0x1f) {(_f) = 128;}			\
-			else if((_bInc) == 0x4) {(_f) = 1000;}			\
-			else {(_f) = 0;}								\
-		}													\
-	}
+#define FACTOR_FROM_BUCKET_INCREMENT(dev, _bInc, _f)        \
+    {                                                        \
+        if(IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))            \
+        {                                                    \
+            if((_bInc) == 174) {(_f) = 64;}                    \
+            else {(_f) = 0;}                                \
+        }                                                    \
+        else                                                \
+        {                                                    \
+            if((_bInc) == 0x3d) {(_f) = 64;}                \
+            else if((_bInc) == 0x1f) {(_f) = 128;}            \
+            else if((_bInc) == 0x4) {(_f) = 1000;}            \
+            else {(_f) = 0;}                                \
+        }                                                    \
+    }
 
 
-#define TSM_GET_CBS(_rate,_cts)	((_rate)/((_cts)*8))
-#define TSM_GET_RATE(_cbs,_cts)	((_cbs)*8*(_cts))
+#define TSM_GET_CBS(_rate,_cts)    ((_rate)/((_cts)*8))
+#define TSM_GET_RATE(_cbs,_cts)    ((_cbs)*8*(_cts))
 
 
 #define GT_PTP_BUILD_TIME(_time1, _time2)       (((_time1) << 16) | (_time2))
@@ -799,7 +1094,7 @@ typedef enum
     GT_ATU_STATS_ALL = 0,
     GT_ATU_STATS_NON_STATIC,
     GT_ATU_STATS_ALL_FID,
-	GT_ATU_STATS_NON_STATIC_FID
+    GT_ATU_STATS_NON_STATIC_FID
 }GT_ATU_STATS_OP;
 
 
@@ -807,26 +1102,26 @@ typedef enum
  *  typedef: struct GT_ATU_STAT
  *
  *  Description: 
- *		This structure is used to count ATU entries.
+ *        This structure is used to count ATU entries.
  *
  *  Fields:
- *      op 	  - counter type
- *		DBNum - required only if op is either GT_ATU_STATS_FID or 
- *				GT_ATU_STATS_NON_STATIC_FID
+ *      op       - counter type
+ *        DBNum - required only if op is either GT_ATU_STATS_FID or 
+ *                GT_ATU_STATS_NON_STATIC_FID
  */
 typedef struct
 {
-	GT_ATU_STATS_OP	op;
-	GT_U32 			DBNum;
+    GT_ATU_STATS_OP    op;
+    GT_U32             DBNum;
 } GT_ATU_STAT;
 
 
 typedef struct _EXTRA_OP_DATA
 {
-	GT_U32 moveFrom;
-	GT_U32 moveTo;
-	GT_U32 intCause;
-	GT_U32 reserved;
+    GT_U32 moveFrom;
+    GT_U32 moveTo;
+    GT_U32 intCause;
+    GT_U32 reserved;
 } GT_EXTRA_OP_DATA;
 
 /*******************************************************************************
@@ -847,7 +1142,7 @@ typedef struct _EXTRA_OP_DATA
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -876,7 +1171,7 @@ GT_STATUS gvtuGetViolation
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -905,7 +1200,7 @@ GT_STATUS gvtuGetViolation2
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -934,7 +1229,7 @@ GT_STATUS gvtuGetViolation3
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -1138,7 +1433,7 @@ GT_STATUS gsysGetRsvReqPri
 *       GT_FAIL         - on error
 *
 * COMMENTS:
-* 		This feature is for both clippership and fullsail
+*         This feature is for both clippership and fullsail
 *
 * GalTis:
 *
@@ -1168,7 +1463,7 @@ GT_STATUS gsysGetPtrCollision
 *       GT_FAIL         - on error
 *
 * COMMENTS:
-* 	This feature is on clippership, but not on fullsail
+*     This feature is on clippership, but not on fullsail
 *
 * GalTis:
 *
@@ -1197,7 +1492,7 @@ GT_STATUS gsysGetDpvCorrupt
 *       GT_FAIL         - on error
 *
 * COMMENTS:
-* 	This feature is on clippership, but not on fullsail
+*     This feature is on clippership, but not on fullsail
 *
 * GalTis:
 *
@@ -1234,10 +1529,10 @@ void gtDbgPrint(char* format, ...);
 *
 * DESCRIPTION:
 *       Assign QuarterDeck Semaphore functions to the given semaphore set.
-*		QuarterDeck maintains its own memory for the structure.
+*        QuarterDeck maintains its own memory for the structure.
 *
 * INPUTS:
-*		semFunctions - point to the GT_SEM_ROUTINES
+*        semFunctions - point to the GT_SEM_ROUTINES
 *
 * OUTPUTS:
 *       None
@@ -1277,7 +1572,7 @@ GT_STATUS gtSemRegister
 *******************************************************************************/
 GT_STATUS gpirlInitialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 );
 
 /*******************************************************************************
@@ -1301,7 +1596,7 @@ GT_STATUS gpirlInitialize
 *******************************************************************************/
 GT_STATUS gpirl2Initialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 );
 
 
@@ -1313,10 +1608,10 @@ GT_STATUS gpirl2Initialize
 *       This function converts logical port number to physical port number
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -1326,7 +1621,7 @@ GT_STATUS gpirl2Initialize
 GT_U8 lport2port
 (
     IN GT_U16    portVec,
-	IN GT_LPORT	 port
+    IN GT_LPORT     port
 );
 
 /*******************************************************************************
@@ -1336,10 +1631,10 @@ GT_U8 lport2port
 *       This function converts physical port number to logical port number
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -1349,7 +1644,7 @@ GT_U8 lport2port
 GT_LPORT port2lport
 (
     IN GT_U16    portVec,
-	IN GT_U8	 hwPort
+    IN GT_U8     hwPort
 );
 
 /*******************************************************************************
@@ -1359,10 +1654,10 @@ GT_LPORT port2lport
 *       This function converts logical port vector to physical port vector
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		lVec 	- logical port vector
+*        portVec - physical port list in vector
+*        lVec     - logical port vector
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port vector
 *
@@ -1372,7 +1667,7 @@ GT_LPORT port2lport
 GT_U32 lportvec2portvec
 (
     IN GT_U16    portVec,
-	IN GT_U32	 lVec
+    IN GT_U32     lVec
 );
 
 /*******************************************************************************
@@ -1382,10 +1677,10 @@ GT_U32 lportvec2portvec
 *       This function converts physical port vector to logical port vector
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		pVec 	- physical port vector
+*        portVec - physical port list in vector
+*        pVec     - physical port vector
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       logical port vector
 *
@@ -1395,10 +1690,9 @@ GT_U32 lportvec2portvec
 GT_U32 portvec2lportvec
 (
     IN GT_U16    portVec,
-	IN GT_U32	 pVec
+    IN GT_U32     pVec
 );
 
-
 /*******************************************************************************
 * lport2phy
 *
@@ -1406,10 +1700,10 @@ GT_U32 portvec2lportvec
 *       This function converts logical port number to physical phy number.
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -1419,9 +1713,10 @@ GT_U32 portvec2lportvec
 GT_U8 lport2phy
 (
     IN GT_QD_DEV    *dev,
-	IN GT_LPORT	 port
+    IN GT_LPORT     port
 );
 
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h
old mode 100644
new mode 100755
index 74fd0f8..1ba289f
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtMiiSmiIf.h
@@ -65,10 +65,10 @@ GT_U16 miiSmiIfInit
 *
 * INPUTS:
 *       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
-*					register address or high device register address.
-*					The device register range is from 0x0 to 0xF or from 0x10 
-*					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
-*					switchs.
+*                    register address or high device register address.
+*                    The device register range is from 0x0 to 0xF or from 0x10 
+*                    to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+*                    switchs.
 *
 * OUTPUTS:
 *       None.
@@ -83,8 +83,8 @@ GT_U16 miiSmiIfInit
 *******************************************************************************/
 GT_U16 miiSmiManualIfInit
 (
-	IN  GT_QD_DEV   *dev,
-	IN  GT_U32		baseAddr
+    IN  GT_QD_DEV   *dev,
+    IN  GT_U32        baseAddr
 );
 
 /*******************************************************************************
@@ -149,6 +149,88 @@ GT_STATUS miiSmiIfWriteRegister
     IN  GT_U16    data
 );
 
+/*****************************************************************************
+* qdMultiAddrRead
+*
+* DESCRIPTION:
+*       This function reads data from a device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The storage where register date to be saved.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value);
+
+/*****************************************************************************
+* qdMultiAddrWrite
+*
+* DESCRIPTION:
+*       This function writes data to the device in the secondary MII bus.
+*
+* INPUTS:
+*       phyAddr     - The PHY address to be read.
+*       regAddr     - The register address to read.
+*       value       - The data to be written into the register.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value);
+
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* qdAccessRegs 
+*
+* DESCRIPTION:
+*       This function access registers through device interface by user, to be
+*       used by upper layers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS qdAccessRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtSem.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/gtSem.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/platformDeps.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/h/platform/platformDeps.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApi.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApi.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h
old mode 100644
new mode 100755
index 44fb19d..48afdd8
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiDefs.h
@@ -1,4 +1,4 @@
-#include <Copyright.h>
+ #include <Copyright.h>
 
 /********************************************************************************
 * msApiDefs.h
@@ -18,8 +18,21 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
+/* Micro definitions */ 
+#undef GT_USE_MAD 
+#undef GT_RMGMT_ACCESS 
+#undef CONFIG_AVB_FPGA 
+#undef CONFIG_AVB_FPGA_2
+#undef GT_PORT_MAP_IN_DEV
+#ifdef CHECK_API_SELECT
+#include "msApiSelect.h"
+#endif
+
 #include <msApiTypes.h>
-/* Debug function   */
+#ifdef GT_USE_MAD 
+#include "madApiDefs.h"
+#endif
+
 #ifdef DEBUG_QD
 #define DBG_INFO(x) gtDbgPrint x
 #else
@@ -28,15 +41,15 @@ extern "C" {
 
 typedef GT_U32 GT_SEM;
 
-#define ETHERNET_HEADER_SIZE	GT_ETHERNET_HEADER_SIZE
-#define IS_MULTICAST_MAC		GT_IS_MULTICAST_MAC
-#define IS_BROADCAST_MAC		GT_IS_BROADCAST_MAC
+#define ETHERNET_HEADER_SIZE    GT_ETHERNET_HEADER_SIZE
+#define IS_MULTICAST_MAC        GT_IS_MULTICAST_MAC
+#define IS_BROADCAST_MAC        GT_IS_BROADCAST_MAC
 
-#define GT_INVALID_PHY			0xFF
-#define GT_INVALID_PORT			0xFF
-#define GT_INVALID_PORT_VEC		0xFFFFFFFF
+#define GT_INVALID_PHY            0xFF
+#define GT_INVALID_PORT            0xFF
+#define GT_INVALID_PORT_VEC        0xFFFFFFFF
 
-#define GT_UNUSED_PARAM(_a)		(_a)=(_a)
+#define GT_UNUSED_PARAM(_a)        (_a)=(_a)
 
 /*
  *   Logical Port value based on a Port
@@ -57,60 +70,61 @@ typedef GT_U32 GT_ETYPE;
 /* Define the different device type that may exist in system        */
 typedef enum
 {
-	GT_88E6021  = 0x021,
-	GT_88E6051  = 0x051,
-	GT_88E6052  = 0x052,
-	GT_88E6060  = 0x060,
-	GT_88E6063	= 0x153,
-	GT_FH_VPN	= 0xF53,
-	GT_FF_EG	= 0xF91,
-	GT_FF_HG	= 0xF93,
-	
-	GT_88E6083	= 0x083,
-
-	GT_88E6181	= 0x1A0,
-
-	GT_88E6153	= 0x1A1,
-	GT_88E6183	= 0x1A3,
-
-	GT_88E6093	= 0x093,
-	GT_88E6092	= 0x097,
-	GT_88E6045	= 0x094,
-	GT_88E6095	= 0x095,
-
-	GT_88E6152	= 0x1A4,
-	GT_88E6155	= 0x1A5,
-	GT_88E6182	= 0x1A6,
-	GT_88E6185	= 0x1A7,
-
-	GT_88E6121	= 0x104,
-	GT_88E6122	= 0x105,
-	GT_88E6131	= 0x106,
-	GT_88E6108	= 0x107,
-
-	GT_88E6031	= 0x031,
-	GT_88E6035	= 0x035,
-	GT_88E6055	= 0x055,
-	GT_88E6061	= 0x061,
-	GT_88E6065	= 0x065,
-
-	GT_88E6046	= 0x048,
-	GT_88E6047	= 0x049,
-	GT_88E6085	= 0x04A,
-	GT_88E6096	= 0x098,
-	GT_88E6097	= 0x099,
-
-	GT_88E6123	= 0x121,
-	GT_88E6140	= 0x141,
-	GT_88E6161	= 0x161,
-	GT_88E6165	= 0x165,
-
-	GT_88E6351	= 0x375,
-	GT_88E6175	= 0x175,
-	GT_88E6125	= 0x124,	/* was 88E6124 */
-	GT_88E6171	= 0x171,
-	GT_88E6321	= 0x324,	/* was 88E6325 */
-	GT_88E6350	= 0x371,	/* was 88E6371 */
+    GT_88E6021  = 0x021,
+    GT_88E6031  = 0x031,
+    GT_88E6035  = 0x035,
+    GT_88E6046  = 0x048,
+    GT_88E6047  = 0x049,
+    GT_88E6085  = 0x04A,
+    GT_88E6051  = 0x051,
+    GT_88E6052  = 0x052,
+    GT_88E6055  = 0x055,
+    GT_88E6060  = 0x060,
+    GT_88E6061  = 0x061,
+    GT_88E6065  = 0x065,
+    GT_88E6083  = 0x083,
+    GT_88E6093  = 0x093,
+    GT_88E6045  = 0x094,
+    GT_88E6095  = 0x095,
+    GT_88E6092  = 0x097,
+    GT_88E6096  = 0x098,
+    GT_88E6097  = 0x099,
+    GT_88E6063    = 0x153,
+    GT_88E6121    = 0x104,
+    GT_88E6122    = 0x105,
+    GT_88E6131    = 0x106,
+    GT_88E6108    = 0x107,
+    GT_88E6123    = 0x121,
+    GT_88E6125    = 0x124,    /* was 88E6124 */
+    GT_88E6140    = 0x141, /* Emerald */
+    GT_88E6161    = 0x161, /* Emerald */
+    GT_88E6165    = 0x165, /* Emerald */
+    GT_88E6171    = 0x171, /* Amber */
+    GT_88E6175    = 0x175, /* Amber */
+    GT_88E6181    = 0x1A0,
+    GT_88E6153    = 0x1A1,
+    GT_88E6183    = 0x1A3,
+    GT_88E6152    = 0x1A4,
+    GT_88E6155    = 0x1A5,
+    GT_88E6182    = 0x1A6,
+    GT_88E6185    = 0x1A7,
+    GT_88E6321    = 0x324,    /* was 88E6325 */ /* Amber */
+    GT_88E6350    = 0x371,    /* was 88E6371 */ /* Amber */
+    GT_88E6351    = 0x375, /* Amber */
+    GT_88EC000    = 0xC00,    /* Melody 0xc00-0xc07 */
+    GT_88E3020    = 0x000,    /* Spinnaker 0x000 */
+    GT_88E6020    = 0x020,    /* Spinnaker 0x020 */
+    GT_88E6070    = 0x070,    /* Spinnaker 0x070 */
+    GT_88E6071    = 0x071,    /* Spinnaker 0x071 */
+    GT_88E6220    = 0x220,    /* Spinnaker 0x220 */
+    GT_88E6250    = 0x250,    /* Spinnaker 0x250 */
+    GT_FH_VPN   = 0xF53,
+    GT_FF_EG    = 0xF91,
+    GT_FF_HG    = 0xF93,
+    GT_88E6172    = 0x172, /* Agate */
+    GT_88E6176    = 0x176, /* Agate */
+    GT_88E6240    = 0x240, /* Agate */
+    GT_88E6352    = 0x352, /* Agate */
 	GT_KW2_INT	= 0x044		/* Internal Swiych in KW2 */
 
 }GT_DEVICE;
@@ -119,71 +133,71 @@ typedef enum
 /* Definition for the revision number of the device        */
 typedef enum
 {
-	GT_REV_0 = 0,
-	GT_REV_1,
-	GT_REV_2,
-	GT_REV_3
+    GT_REV_0 = 0,
+    GT_REV_1,
+    GT_REV_2,
+    GT_REV_3
 }GT_DEVICE_REV;
 
 
 /* ToDo: No Used */
 typedef enum
 {
-	INTR_MODE_DISABLE =0,
-	INTR_MODE_ENABLE
+    INTR_MODE_DISABLE =0,
+    INTR_MODE_ENABLE
 }INTERRUPT_MODE;
 
 /* Definition for the Port Speed */
 typedef enum
 {
-	PORT_SPEED_10_MBPS = 0,
-	PORT_SPEED_100_MBPS = 1,
-	PORT_SPEED_200_MBPS = 2,	/* valid only if device support */
-	PORT_SPEED_1000_MBPS = 2 ,	/* valid only if device support */
-	PORT_SPEED_UNKNOWN = 3
+    PORT_SPEED_10_MBPS = 0,
+    PORT_SPEED_100_MBPS = 1,
+    PORT_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_SPEED_1000_MBPS = 2 ,    /* valid only if device support */
+    PORT_SPEED_UNKNOWN = 3
 } GT_PORT_SPEED_MODE;
 
 /* Definition for the forced Port Speed */
 typedef enum
 {
-	PORT_FORCE_SPEED_10_MBPS = 0,
-	PORT_FORCE_SPEED_100_MBPS = 1,
-	PORT_FORCE_SPEED_200_MBPS = 2,	/* valid only if device support */
-	PORT_FORCE_SPEED_1000_MBPS = 2,	/* valid only if device support */
-	PORT_DO_NOT_FORCE_SPEED =3
+    PORT_FORCE_SPEED_10_MBPS = 0,
+    PORT_FORCE_SPEED_100_MBPS = 1,
+    PORT_FORCE_SPEED_200_MBPS = 2,    /* valid only if device support */
+    PORT_FORCE_SPEED_1000_MBPS = 2,    /* valid only if device support */
+    PORT_DO_NOT_FORCE_SPEED =3
 } GT_PORT_FORCED_SPEED_MODE;
 
 /* Definition for the forced Port Duplex mode */
 typedef enum
 {
-	PORT_DO_NOT_FORCE_DUPLEX,
-	PORT_FORCE_FULL_DUPLEX,
-	PORT_FORCE_HALF_DUPLEX
+    PORT_DO_NOT_FORCE_DUPLEX,
+    PORT_FORCE_FULL_DUPLEX,
+    PORT_FORCE_HALF_DUPLEX
 } GT_PORT_FORCED_DUPLEX_MODE;
 
 /* Definition for the forced Port Link */
 typedef enum
 {
-	PORT_DO_NOT_FORCE_LINK,
-	PORT_FORCE_LINK_UP,
-	PORT_FORCE_LINK_DOWN
+    PORT_DO_NOT_FORCE_LINK,
+    PORT_FORCE_LINK_UP,
+    PORT_FORCE_LINK_DOWN
 } GT_PORT_FORCED_LINK_MODE;
 
 /* Definition for the forced flow control mode */
 typedef enum
 {
-	PORT_DO_NOT_FORCE_FC,
-	PORT_FORCE_FC_ENABLED,
-	PORT_FORCE_FC_DISABLED
+    PORT_DO_NOT_FORCE_FC,
+    PORT_FORCE_FC_ENABLED,
+    PORT_FORCE_FC_DISABLED
 } GT_PORT_FORCED_FC_MODE;
 
 /* Definition for the PPU state */
 typedef enum
 {
-	PPU_STATE_DISABLED_AT_RESET,
-	PPU_STATE_ACTIVE,
-	PPU_STATE_DISABLED_AFTER_RESET,
-	PPU_STATE_POLLING
+    PPU_STATE_DISABLED_AT_RESET,
+    PPU_STATE_ACTIVE,
+    PPU_STATE_DISABLED_AFTER_RESET,
+    PPU_STATE_POLLING
 } GT_PPU_STATE;
 
 
@@ -191,39 +205,39 @@ typedef enum
  * Typedef: enum GT_PORT_CONFIG_MODE
  *
  * Description: Defines port's interface type configuration mode determined at 
- *				reset. This definition may not represent the device under use.
- *				Please refer to the device datasheet for detailed information.
+ *                reset. This definition may not represent the device under use.
+ *                Please refer to the device datasheet for detailed information.
  *
  */
 typedef enum
 {
-	PORTCFG_GMII_125MHZ = 0,		/* Px_GTXCLK = 125MHz, 1000BASE */
-	PORTCFG_FD_MII_0MHZ = 1,		/* Px_GTXCLK = 0 MHz, Power Save */
-	PORTCFG_FDHD_MII_25MHZ = 2,		/* Px_GTXCLK = 25MHz, 100BASE */ 
-	PORTCFG_FDHD_MII_2_5MHZ = 3,	/* Px_GTXCLK = 2.5MHz, 10BASE */
-	PORTCFG_FD_SERDES = 4,			/* Default value */
-	PORTCFG_FD_1000BASE_X = 5,		
-	PORTCFG_MGMII = 6,				/* duplex, speed determined by the PPU */
-	PORTCFG_DISABLED = 7			
+    PORTCFG_GMII_125MHZ = 0,        /* Px_GTXCLK = 125MHz, 1000BASE */
+    PORTCFG_FD_MII_0MHZ = 1,        /* Px_GTXCLK = 0 MHz, Power Save */
+    PORTCFG_FDHD_MII_25MHZ = 2,        /* Px_GTXCLK = 25MHz, 100BASE */ 
+    PORTCFG_FDHD_MII_2_5MHZ = 3,    /* Px_GTXCLK = 2.5MHz, 10BASE */
+    PORTCFG_FD_SERDES = 4,            /* Default value */
+    PORTCFG_FD_1000BASE_X = 5,        
+    PORTCFG_MGMII = 6,                /* duplex, speed determined by the PPU */
+    PORTCFG_DISABLED = 7            
 } GT_PORT_CONFIG_MODE;
 
 
 typedef enum
 {
-	GT_SA_FILTERING_DISABLE = 0,
-	GT_SA_DROP_ON_LOCK,
-	GT_SA_DROP_ON_UNLOCK,
-	GT_SA_DROP_TO_CPU
+    GT_SA_FILTERING_DISABLE = 0,
+    GT_SA_DROP_ON_LOCK,
+    GT_SA_DROP_ON_UNLOCK,
+    GT_SA_DROP_TO_CPU
 } GT_SA_FILTERING;
 
 
 /* Definition for the Ingree/Egress Frame Mode */
 typedef enum
 {
-	GT_FRAME_MODE_NORMAL = 0,	/* Normal Network */
-	GT_FRAME_MODE_DSA,			/* Distributed Switch Architecture */
-	GT_FRAME_MODE_PROVIDER,		/* Provider */
-	GT_FRAME_MODE_ETHER_TYPE_DSA	/* Ether Type DSA */
+    GT_FRAME_MODE_NORMAL = 0,    /* Normal Network */
+    GT_FRAME_MODE_DSA,            /* Distributed Switch Architecture */
+    GT_FRAME_MODE_PROVIDER,        /* Provider */
+    GT_FRAME_MODE_ETHER_TYPE_DSA    /* Ether Type DSA */
 } GT_FRAME_MODE;
 
 /*
@@ -235,13 +249,13 @@ typedef enum
  *      GT_JUMBO_MODE_1522 - Rx and Tx frames with max byte of 1522.
  *      GT_JUMBO_MODE_2048 - Rx and Tx frames with max byte of 2048.
  *      GT_JUMBO_MODE_10240 - Rx and Tx frames with max byte of 10240.
- *				 
+ *                 
  */
 typedef enum
 {
-	GT_JUMBO_MODE_1522 = 0,
-	GT_JUMBO_MODE_2048,
-	GT_JUMBO_MODE_10240
+    GT_JUMBO_MODE_1522 = 0,
+    GT_JUMBO_MODE_2048,
+    GT_JUMBO_MODE_10240
 } GT_JUMBO_MODE;
 
 
@@ -252,24 +266,24 @@ typedef enum
  *
  * Fields:
  *      PRI_OVERRIDE_NONE - Normal frame priority processing occurs.
- *		PRI_OVERRIDE_FRAME_QUEUE -
- *			Both frame and queue overrides take place on the frame.
+ *        PRI_OVERRIDE_FRAME_QUEUE -
+ *            Both frame and queue overrides take place on the frame.
  *      PRI_OVERRIDE_FRAME - 
- *			Overwite the frame's FPri (frame priority).
- *			If the frame egresses tagged, the priority in the frame will be
- *			the overwritten priority value.
- *		PRI_OVERRIDE_QUEUE -
- *			Overwite the frame's QPri (queue priority).
- *			QPri is used internally to map the frame to one of the egress
- *			queues inside the switch.
+ *            Overwite the frame's FPri (frame priority).
+ *            If the frame egresses tagged, the priority in the frame will be
+ *            the overwritten priority value.
+ *        PRI_OVERRIDE_QUEUE -
+ *            Overwite the frame's QPri (queue priority).
+ *            QPri is used internally to map the frame to one of the egress
+ *            queues inside the switch.
  *
  */
 typedef enum
 {
-	PRI_OVERRIDE_NONE = 0,
-	PRI_OVERRIDE_FRAME_QUEUE,
-	PRI_OVERRIDE_FRAME,
-	PRI_OVERRIDE_QUEUE
+    PRI_OVERRIDE_NONE = 0,
+    PRI_OVERRIDE_FRAME_QUEUE,
+    PRI_OVERRIDE_FRAME,
+    PRI_OVERRIDE_QUEUE
 } GT_PRI_OVERRIDE;
 
 
@@ -287,10 +301,10 @@ typedef enum
  */
 typedef enum
 {
-	FRAME_POLICY_NONE = 0,
-	FRAME_POLICY_MIRROR,
-	FRAME_POLICY_TRAP,
-	FRAME_POLICY_DISCARD
+    FRAME_POLICY_NONE = 0,
+    FRAME_POLICY_MIRROR,
+    FRAME_POLICY_TRAP,
+    FRAME_POLICY_DISCARD
 } GT_FRAME_POLICY;
 
 
@@ -300,26 +314,26 @@ typedef enum
  * Description: Defines the policy type
  *
  * Fields:
- *      POLICY_TYPE_DA 	- Policy based on Destination Address
- *      POLICY_TYPE_SA 	- Policy based on Source Address
- *      POLICY_TYPE_VTU 	- Policy based on VID
- *		POLICY_TYPE_ETYPE	- based on Ether Type of a frame
- *		POLICY_TYPE_PPPoE	- Policy for the frame with Ether Type of 0x8863
- *		POLICY_TYPE_VBAS	- Policy for the frame with Ether Type of 0x8200
- *		POLICY_TYPE_OPT82	- Policy for the frame with DHCP Option 82
- *		POLICY_TYPE_UDP	- Policy for the frame with Broadcast IPv4 UDP or
- *						Multicast IPv6 UDP
- */
-typedef enum
-{
-	POLICY_TYPE_DA,
-	POLICY_TYPE_SA,
-	POLICY_TYPE_VTU,
-	POLICY_TYPE_ETYPE,
-	POLICY_TYPE_PPPoE,
-	POLICY_TYPE_VBAS,
-	POLICY_TYPE_OPT82,
-	POLICY_TYPE_UDP
+ *      POLICY_TYPE_DA     - Policy based on Destination Address
+ *      POLICY_TYPE_SA     - Policy based on Source Address
+ *      POLICY_TYPE_VTU     - Policy based on VID
+ *        POLICY_TYPE_ETYPE    - based on Ether Type of a frame
+ *        POLICY_TYPE_PPPoE    - Policy for the frame with Ether Type of 0x8863
+ *        POLICY_TYPE_VBAS    - Policy for the frame with Ether Type of 0x8200
+ *        POLICY_TYPE_OPT82    - Policy for the frame with DHCP Option 82
+ *        POLICY_TYPE_UDP    - Policy for the frame with Broadcast IPv4 UDP or
+ *                        Multicast IPv6 UDP
+ */
+typedef enum
+{
+    POLICY_TYPE_DA,
+    POLICY_TYPE_SA,
+    POLICY_TYPE_VTU,
+    POLICY_TYPE_ETYPE,
+    POLICY_TYPE_PPPoE,
+    POLICY_TYPE_VBAS,
+    POLICY_TYPE_OPT82,
+    POLICY_TYPE_UDP
 } GT_POLICY_TYPE;
 
 
@@ -329,73 +343,73 @@ typedef enum
  * Description: Definition of the frame type for priority override
  *
  * Fields:
- *		FTYPE_DSA_TO_CPU_BPDU -
- *			Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
- *			Not used on non-DSA Control frames.
- *		FTYPE_DSA_TO_CPU_F2R -
- *			Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
- *			Reply). Not used on non-DSA Control frames.
- *		FTYPE_DSA_TO_CPU_IGMP -
- *			Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
- *			and on non-DSA Control frames that are IGMP or MLD trapped
- *		FTYPE_DSA_TO_CPU_TRAP -
- *			Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
- *			on non-DSA Control frames that are Policy Trapped
- *		FTYPE_DSA_TO_CPU_ARP -
- *			Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
- *			on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
- *		FTYPE_DSA_TO_CPU_MIRROR -
- *			Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
- *			on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
- *		FTYPE_DSA_TO_CPU_RESERVED -
- *			Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
- *			used on non-DSA Control frames.
- *		FTYPE_DSA_TO_CPU_UCAST_MGMT -
- *			Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
- *			MGMT). Not used on non-DSA Control frames.
- *		FTYPE_DSA_FROM_CPU -
- *			Used on DSA From_CPU frames. Not used on non-DSA Control frame
- *		FTYPE_DSA_CROSS_CHIP_FC -
- *			Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
- *			Control). Not used on non-DSA Control frames.
- *		FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
- *			Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
- *			Not used on non-DSA Control frames.
- *		FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
- *			Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
- *			Not used on non-DSA Control frames.
- *		FTYPE_PORT_ETYPE_MATCH -
- *			Used on normal network ports (see gprtSetFrameMode API)
- *			on frames whose Ethertype matches the port's PortEType register.
- *			Not used on non-DSA Control frames.
- *		FTYPE_BCAST_NON_DSA_CONTROL -
- *			Used on Non-DSA Control frames that contain a Broadcast
- *			destination address. Not used on DSA Control frames.
- *		FTYPE_PPPoE_NON_DSA_CONTROL -
- *			Used on Non-DSA Control frames that contain an Ether Type 0x8863
- *			(i.e., PPPoE frames). Not used on DSA Control frames.
- *		FTYPE_IP_NON_DSA_CONTROL -
- *			Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
- *			Type. Not used on DSA Control frames.
- */
-typedef enum
-{
-	FTYPE_DSA_TO_CPU_BPDU = 0,
-	FTYPE_DSA_TO_CPU_F2R,
-	FTYPE_DSA_TO_CPU_IGMP,
-	FTYPE_DSA_TO_CPU_TRAP,
-	FTYPE_DSA_TO_CPU_ARP,
-	FTYPE_DSA_TO_CPU_MIRROR,
-	FTYPE_DSA_TO_CPU_RESERVED,
-	FTYPE_DSA_TO_CPU_UCAST_MGMT,
-	FTYPE_DSA_FROM_CPU,
-	FTYPE_DSA_CROSS_CHIP_FC,
-	FTYPE_DSA_CROSS_CHIP_EGRESS_MON,
-	FTYPE_DSA_CROSS_CHIP_INGRESS_MON,
-	FTYPE_PORT_ETYPE_MATCH,
-	FTYPE_BCAST_NON_DSA_CONTROL,
-	FTYPE_PPPoE_NON_DSA_CONTROL,
-	FTYPE_IP_NON_DSA_CONTROL
+ *        FTYPE_DSA_TO_CPU_BPDU -
+ *            Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_F2R -
+ *            Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+ *            Reply). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_IGMP -
+ *            Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+ *            and on non-DSA Control frames that are IGMP or MLD trapped
+ *        FTYPE_DSA_TO_CPU_TRAP -
+ *            Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+ *            on non-DSA Control frames that are Policy Trapped
+ *        FTYPE_DSA_TO_CPU_ARP -
+ *            Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+ *            on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+ *        FTYPE_DSA_TO_CPU_MIRROR -
+ *            Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+ *            on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+ *        FTYPE_DSA_TO_CPU_RESERVED -
+ *            Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+ *            used on non-DSA Control frames.
+ *        FTYPE_DSA_TO_CPU_UCAST_MGMT -
+ *            Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+ *            MGMT). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_FROM_CPU -
+ *            Used on DSA From_CPU frames. Not used on non-DSA Control frame
+ *        FTYPE_DSA_CROSS_CHIP_FC -
+ *            Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+ *            Control). Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+ *            Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+ *            Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_PORT_ETYPE_MATCH -
+ *            Used on normal network ports (see gprtSetFrameMode API)
+ *            on frames whose Ethertype matches the port's PortEType register.
+ *            Not used on non-DSA Control frames.
+ *        FTYPE_BCAST_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain a Broadcast
+ *            destination address. Not used on DSA Control frames.
+ *        FTYPE_PPPoE_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an Ether Type 0x8863
+ *            (i.e., PPPoE frames). Not used on DSA Control frames.
+ *        FTYPE_IP_NON_DSA_CONTROL -
+ *            Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+ *            Type. Not used on DSA Control frames.
+ */
+typedef enum
+{
+    FTYPE_DSA_TO_CPU_BPDU = 0,
+    FTYPE_DSA_TO_CPU_F2R,
+    FTYPE_DSA_TO_CPU_IGMP,
+    FTYPE_DSA_TO_CPU_TRAP,
+    FTYPE_DSA_TO_CPU_ARP,
+    FTYPE_DSA_TO_CPU_MIRROR,
+    FTYPE_DSA_TO_CPU_RESERVED,
+    FTYPE_DSA_TO_CPU_UCAST_MGMT,
+    FTYPE_DSA_FROM_CPU,
+    FTYPE_DSA_CROSS_CHIP_FC,
+    FTYPE_DSA_CROSS_CHIP_EGRESS_MON,
+    FTYPE_DSA_CROSS_CHIP_INGRESS_MON,
+    FTYPE_PORT_ETYPE_MATCH,
+    FTYPE_BCAST_NON_DSA_CONTROL,
+    FTYPE_PPPoE_NON_DSA_CONTROL,
+    FTYPE_IP_NON_DSA_CONTROL
 } GT_PRI_OVERRIDE_FTYPE;
 
 
@@ -403,20 +417,20 @@ typedef enum
  * Typedef: struct GT_QPRI_TBL_ENTRY
  *
  * Description: This structure is used for the entry of Queue Priority Override
- *				Table.
+ *                Table.
  *
  * Fields:
- *		qPriEn    - GT_TRUE to enable Queue Priority, GT_FALSE otherwise
- *		qPriority - priority to be overridden ( 0 ~ 3 ) only if qPriEn is GT_TRUE
- *					When qPriEn is GT_FALSE, qPriority should be ignored.
+ *        qPriEn    - GT_TRUE to enable Queue Priority, GT_FALSE otherwise
+ *        qPriority - priority to be overridden ( 0 ~ 3 ) only if qPriEn is GT_TRUE
+ *                    When qPriEn is GT_FALSE, qPriority should be ignored.
  *
  * Notes: If device does not support qPriAvbEn, qPriAvbEn and qAvbPriority fields
- *		will be ignored.
+ *        will be ignored.
  */
 typedef struct
 {
-	GT_BOOL		qPriEn;
-	GT_U32		qPriority;
+    GT_BOOL        qPriEn;
+    GT_U32        qPriority;
 }GT_QPRI_TBL_ENTRY;
 
 
@@ -424,24 +438,24 @@ typedef struct
  * Typedef: struct GT_FPRI_TBL_ENTRY
  *
  * Description: This structure is used for the entry of Frame Priority Override
- *				Table.
+ *                Table.
  *
  * Fields:
- *		fPriEn    - GT_TRUE to enable Frame Priority, GT_FALSE otherwise
- *		fPriority - priority to be overridden ( 0 ~ 7 ) only if fPriEn is GT_TRUE
- *					When fPriEn is GT_FALSE, fPriority should be ignored.
+ *        fPriEn    - GT_TRUE to enable Frame Priority, GT_FALSE otherwise
+ *        fPriority - priority to be overridden ( 0 ~ 7 ) only if fPriEn is GT_TRUE
+ *                    When fPriEn is GT_FALSE, fPriority should be ignored.
  */
 typedef struct
 {
-	GT_BOOL		fPriEn;
-	GT_U32		fPriority;
+    GT_BOOL        fPriEn;
+    GT_U32        fPriority;
 }GT_FPRI_TBL_ENTRY;
 
 
 /* Maximam number of ports a switch may have. */
 #define MAX_SWITCH_PORTS    11
-#define VERSION_MAX_LEN 	30
-#define MAX_QOS_WEIGHTS		128
+#define VERSION_MAX_LEN     30
+#define MAX_QOS_WEIGHTS        128
 
 /*
  * Typedef: struct GT_QoS_WEIGHT
@@ -450,12 +464,12 @@ typedef struct
  *
  * Fields:
  *      len    - length of the valid queue data
- *		queue  - upto 128 queue data
+ *        queue  - upto 128 queue data
  */
 typedef struct
 {
-	GT_U32		len;
-	GT_U8		queue[MAX_QOS_WEIGHTS];
+    GT_U32        len;
+    GT_U8        queue[MAX_QOS_WEIGHTS];
 }GT_QoS_WEIGHT;
 
 
@@ -471,7 +485,7 @@ typedef struct
  */
 typedef struct
 {
-	GT_U8   version[VERSION_MAX_LEN];
+    GT_U8   version[VERSION_MAX_LEN];
 }GT_VERSION;
 
 
@@ -481,13 +495,13 @@ typedef struct
  * Description: This struct holds the Remote Management Unit mode.
  *
  * Fields:
- *		rmuEn	- enable or disable RMU
- *		port	- logical port where RMU is enabled
+ *        rmuEn    - enable or disable RMU
+ *        port    - logical port where RMU is enabled
  */
 typedef struct
 {
-	GT_BOOL		rmuEn;
-	GT_LPORT	port;
+    GT_BOOL        rmuEn;
+    GT_LPORT    port;
 } GT_RMU;
 
 
@@ -508,12 +522,12 @@ typedef struct
  */
 typedef enum
 {
-	ATU_SIZE_256,
-	ATU_SIZE_512,
-	ATU_SIZE_1024,
-	ATU_SIZE_2048,
-	ATU_SIZE_4096,
-	ATU_SIZE_8192
+    ATU_SIZE_256,
+    ATU_SIZE_512,
+    ATU_SIZE_1024,
+    ATU_SIZE_2048,
+    ATU_SIZE_4096,
+    ATU_SIZE_8192
 }ATU_SIZE;
 
 
@@ -530,10 +544,10 @@ typedef enum
  */
 typedef enum
 {
-	GT_PORT_DISABLE = 0,
-	GT_PORT_BLOCKING,
-	GT_PORT_LEARNING,
-	GT_PORT_FORWARDING
+    GT_PORT_DISABLE = 0,
+    GT_PORT_BLOCKING,
+    GT_PORT_LEARNING,
+    GT_PORT_FORWARDING
 } GT_PORT_STP_STATE;
 
 
@@ -550,20 +564,20 @@ typedef enum
  */
 typedef enum
 {
-	GT_UNMODIFY_EGRESS = 0,
-	GT_UNTAGGED_EGRESS,
-	GT_TAGGED_EGRESS,
-	GT_ADD_TAG
+    GT_UNMODIFY_EGRESS = 0,
+    GT_UNTAGGED_EGRESS,
+    GT_TAGGED_EGRESS,
+    GT_ADD_TAG
 } GT_EGRESS_MODE;
 
 /*  typedef: enum GT_DOT1Q_MODE */
 
 typedef enum
 {
-	GT_DISABLE = 0,
-	GT_FALLBACK,
-	GT_CHECK,
-	GT_SECURE
+    GT_DISABLE = 0,
+    GT_FALLBACK,
+    GT_CHECK,
+    GT_SECURE
 } GT_DOT1Q_MODE;
 
 
@@ -571,10 +585,10 @@ typedef enum
 
 typedef enum
 {
-	GT_CPU_ATTATCHED = 0, /* ports come up disabled */
-	GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
-	GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
-	GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
+    GT_CPU_ATTATCHED = 0, /* ports come up disabled */
+    GT_BACKOFF,           /* EEPROM attac mode with old half duplex backoff mode */
+    GT_STAND_ALONE,       /* ports come up enabled, ignore EEPROM */
+    GT_EEPROM_ATTATCHED   /* EEPROM defined prot states */
 } GT_SW_MODE;
 
 
@@ -595,13 +609,13 @@ typedef enum
  */
 typedef enum
 {
-	FLUSH_ALL = 1,		/* for both atu and vtu */
-	FLUSH_UNLOCKED,		/* for atu only */
-	LOAD_PURGE_ENTRY,	/* for both atu and vtu */
-	GET_NEXT_ENTRY,		/* for both atu and vtu */
-	FLUSH_ALL_IN_DB,	/* for atu only */
-	FLUSH_UNLOCKED_IN_DB,	/* for atu only */
-	SERVICE_VIOLATIONS 	/* for vtu only */
+    FLUSH_ALL = 1,        /* for both atu and vtu */
+    FLUSH_UNLOCKED,        /* for atu only */
+    LOAD_PURGE_ENTRY,    /* for both atu and vtu */
+    GET_NEXT_ENTRY,        /* for both atu and vtu */
+    FLUSH_ALL_IN_DB,    /* for atu only */
+    FLUSH_UNLOCKED_IN_DB,    /* for atu only */
+    SERVICE_VIOLATIONS     /* for vtu only */
 } GT_ATU_OPERATION, GT_VTU_OPERATION;
 
 
@@ -626,7 +640,7 @@ typedef enum
  * typedef: enum GT_MOVE_CMD
  *
  * Description: Enumeration of the address translation unit move or remove operation.
- *	 When destination port is set to 0xF, Remove operation occurs.
+ *     When destination port is set to 0xF, Remove operation occurs.
  *
  * Enumerations:
  *   GT_MOVE_ALL       - move all entries.
@@ -635,9 +649,9 @@ typedef enum
  */
 typedef enum
 {
-	GT_MOVE_ALL       = 1,
-	GT_MOVE_ALL_UNBLK = 2,
-	GT_MOVE_ALL_UNLOCKED = 2
+    GT_MOVE_ALL       = 1,
+    GT_MOVE_ALL_UNBLK = 2,
+    GT_MOVE_ALL_UNLOCKED = 2
 }GT_MOVE_CMD;
 
 
@@ -649,47 +663,47 @@ typedef enum
  *      entris.
  *
  * Enumerations:
- *		GT_UC_INVALID   - invalid entry.
- *		GT_UC_DYNAMIC   - unicast dynamic entry.
- *		GT_UC_NO_PRI_TO_CPU_STATIC_NRL 
- *				- static unicast entry that will be forwarded to CPU without 
- *					forcing priority and without rate limiting.
- *		GT_UC_TO_CPU_STATIC_NRL 
- *				- static unicast entry that will be forwarded to CPU without
- *					rate limiting.
- *		GT_UC_NO_PRI_STATIC_NRL 
- *				- static unicast entry without forcing priority and without.
- *					rate limiting.
- *		GT_UC_NO_PRI_STATIC_AVB_ENTRY 
- *				- static unicast AVB entry without forcing priority if MacAvb is enabled.
- *		GT_UC_STATIC_NRL    - static unicast entry without rate limiting.
- *		GT_UC_STATIC_AVB_ENTRY - static unicast AVB entry if MacAvb is enabled .
- *		GT_UC_NO_PRI_TO_CPU_STATIC
- *				- static unicast entry that will be forwarded to CPU without 
- *					forcing priority.
- *		GT_UC_TO_CPU_STATIC - static unicast entry that will be forwarded to CPU.
- *		GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
- *		GT_UC_STATIC    - static unicast entry.
+ *        GT_UC_INVALID   - invalid entry.
+ *        GT_UC_DYNAMIC   - unicast dynamic entry.
+ *        GT_UC_NO_PRI_TO_CPU_STATIC_NRL 
+ *                - static unicast entry that will be forwarded to CPU without 
+ *                    forcing priority and without rate limiting.
+ *        GT_UC_TO_CPU_STATIC_NRL 
+ *                - static unicast entry that will be forwarded to CPU without
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_NRL 
+ *                - static unicast entry without forcing priority and without.
+ *                    rate limiting.
+ *        GT_UC_NO_PRI_STATIC_AVB_ENTRY 
+ *                - static unicast AVB entry without forcing priority if MacAvb is enabled.
+ *        GT_UC_STATIC_NRL    - static unicast entry without rate limiting.
+ *        GT_UC_STATIC_AVB_ENTRY - static unicast AVB entry if MacAvb is enabled .
+ *        GT_UC_NO_PRI_TO_CPU_STATIC
+ *                - static unicast entry that will be forwarded to CPU without 
+ *                    forcing priority.
+ *        GT_UC_TO_CPU_STATIC - static unicast entry that will be forwarded to CPU.
+ *        GT_UC_NO_PRI_STATIC - static unicast entry without forcing priority.
+ *        GT_UC_STATIC    - static unicast entry.
  *
  * Note: Please refer to the device datasheet for detailed unicast entry states
- *		that are supported by the device.
+ *        that are supported by the device.
  */
 typedef enum
 {
-	GT_UC_INVALID      = 0,
-	GT_UC_DYNAMIC      = 0x1,
+    GT_UC_INVALID      = 0,
+    GT_UC_DYNAMIC      = 0x1,
 
-	GT_UC_NO_PRI_TO_CPU_STATIC_NRL	= 0x8,
-	GT_UC_TO_CPU_STATIC_NRL			= 0x9,
-	GT_UC_NO_PRI_STATIC_NRL			= 0xA,
-	GT_UC_NO_PRI_STATIC_AVB_ENTRY	= 0xA,
-	GT_UC_STATIC_NRL 				= 0xB,
-	GT_UC_STATIC_AVB_ENTRY			= 0xB,
+    GT_UC_NO_PRI_TO_CPU_STATIC_NRL    = 0x8,
+    GT_UC_TO_CPU_STATIC_NRL            = 0x9,
+    GT_UC_NO_PRI_STATIC_NRL            = 0xA,
+    GT_UC_NO_PRI_STATIC_AVB_ENTRY    = 0xA,
+    GT_UC_STATIC_NRL                 = 0xB,
+    GT_UC_STATIC_AVB_ENTRY            = 0xB,
 
-	GT_UC_NO_PRI_TO_CPU_STATIC	= 0xC,
-	GT_UC_TO_CPU_STATIC 		= 0xD,
-	GT_UC_NO_PRI_STATIC 		= 0xE,
-	GT_UC_STATIC  				= 0xF
+    GT_UC_NO_PRI_TO_CPU_STATIC    = 0xC,
+    GT_UC_TO_CPU_STATIC         = 0xD,
+    GT_UC_NO_PRI_STATIC         = 0xE,
+    GT_UC_STATIC                  = 0xF
 } GT_ATU_UC_STATE;
 
 
@@ -710,30 +724,30 @@ typedef enum
  *      GT_MC_PRIO_STATIC     - static multicast regular entris with priority.
  *      GT_MC_PRIO_STATIC_AVB_ENTRY      - static multicast AVB Entry with priority if MacAvb is enabled
  *      GT_MC_PRIO_STATIC_UNLIMITED_RATE - static multicast regular entris with priority
- *											and without rate limiting.
- *      GT_MC_MGM_STATIC_UNLIMITED_RATE	 - static multicast management entries without
- *											rate limiting.
+ *                                            and without rate limiting.
+ *      GT_MC_MGM_STATIC_UNLIMITED_RATE     - static multicast management entries without
+ *                                            rate limiting.
  *      GT_MC_STATIC_UNLIMITED_RATE      - static multicast regular entris without
- *											rate limiting.
+ *                                            rate limiting.
  *      GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE - static multicast management entries with
  *                              priority and without rate limiting.
  *
  * Note: Please refer to the device datasheet for detailed multicast entry states
- *		that are supported by the device.
+ *        that are supported by the device.
  */
 typedef enum
 {
-	GT_MC_INVALID         = 0,
-	GT_MC_MGM_STATIC_UNLIMITED_RATE = 0x4,
-	GT_MC_STATIC_UNLIMITED_RATE	= 0x5,
-	GT_MC_STATIC_AVB_ENTRY	= 0x5,
-	GT_MC_MGM_STATIC      = 0x6,
-	GT_MC_STATIC          = 0x7,
-	GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE = 0xC,
-	GT_MC_PRIO_STATIC_UNLIMITED_RATE	= 0xD,
-	GT_MC_PRIO_STATIC_AVB_ENTRY	= 0xD,
-	GT_MC_PRIO_MGM_STATIC = 0xE,
-	GT_MC_PRIO_STATIC     = 0xF
+    GT_MC_INVALID         = 0,
+    GT_MC_MGM_STATIC_UNLIMITED_RATE = 0x4,
+    GT_MC_STATIC_UNLIMITED_RATE    = 0x5,
+    GT_MC_STATIC_AVB_ENTRY    = 0x5,
+    GT_MC_MGM_STATIC      = 0x6,
+    GT_MC_STATIC          = 0x7,
+    GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE = 0xC,
+    GT_MC_PRIO_STATIC_UNLIMITED_RATE    = 0xD,
+    GT_MC_PRIO_STATIC_AVB_ENTRY    = 0xD,
+    GT_MC_PRIO_MGM_STATIC = 0xE,
+    GT_MC_PRIO_STATIC     = 0xF
 } GT_ATU_MC_STATE;
 
 
@@ -741,37 +755,38 @@ typedef enum
  *  typedef: struct GT_ATU_EXT_PRI
  *
  *  Description: 
- *		Extanded priority information for the address tarnslaton unit entry.
+ *        Extanded priority information for the address tarnslaton unit entry.
  *
- *		macFPri data is used to override the frame priority on any frame associated
- *		with this MAC, if the useMacFPri is GT_TRUE and the port's SA and/or 
- *		DA FPriOverride are enabled. SA Frame Priority Overrides can only occur on 
- *		MAC addresses that are Static or where the Port is Locked, and where the port 
- *		is mapped source port for the MAC address.
+ *        macFPri data is used to override the frame priority on any frame associated
+ *        with this MAC, if the useMacFPri is GT_TRUE and the port's SA and/or 
+ *        DA FPriOverride are enabled. SA Frame Priority Overrides can only occur on 
+ *        MAC addresses that are Static or where the Port is Locked, and where the port 
+ *        is mapped source port for the MAC address.
  *
- *		macQPri data is used to override the queue priority on any frame associated
- *		with this MAC, if the EntryState indicates Queue Priority Override and the 
- *		port's SA and/or DA QPriOverride are enabled. 
+ *        macQPri data is used to override the queue priority on any frame associated
+ *        with this MAC, if the EntryState indicates Queue Priority Override and the 
+ *        port's SA and/or DA QPriOverride are enabled. 
  *
  *  Fields:
  *      useMacFPri - Use MAC frame priority override. When this is GT_TRUE,
- *					 MacFPri data can be used to override the frame priority on
- *					 any frame associated with this MAC.
+ *                     MacFPri data can be used to override the frame priority on
+ *                     any frame associated with this MAC.
  *      macFPri    - MAC frame priority data (0 ~ 7).
  *      macQPri    - MAC queue priority data (0 ~ 3).
  *
  *  Comment:
  *      Please refer to the device datasheet to find out if this feature is supported.
- *		When this structure is implemented, the followings are the devices supporting 
- *		this feature:
- *			88E6065, 88E6035, and 88E6055 support all extanded priority data.
- *			88E6061 and 88E6031 support only macQPri data
+ *        When this structure is implemented, the followings are the devices supporting 
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all extanded priority data.
+ *            88E6061 and 88E6031 support only macQPri data
+ *            88EC000 and 88E3020 family use only macFPri data
  */
 typedef struct
 {
-	GT_BOOL			useMacFPri;
-	GT_U8 			macFPri;
-	GT_U8 			macQPri;
+    GT_BOOL            useMacFPri;
+    GT_U8             macFPri;
+    GT_U8             macQPri;
 } GT_ATU_EXT_PRI;
 
 
@@ -783,35 +798,35 @@ typedef struct
  *  Fields:
  *      macAddr    - mac address
  *      trunkMember- GT_TRUE if entry belongs to a Trunk. This field will be
- *					 ignored if device does not support Trunk.
+ *                     ignored if device does not support Trunk.
  *      portVec    - port Vector. 
- *					 If trunkMember field is GT_TRUE, this value represents trunk ID.
+ *                     If trunkMember field is GT_TRUE, this value represents trunk ID.
  *      prio       - entry priority.
  *      entryState - the entry state.
- *		DBNum	   - ATU MAC Address Database number. If multiple address 
- *					 databases are not being used, DBNum should be zero.
- *					 If multiple address databases are being used, this value
- *					 should be set to the desired address database number.
- *		exPrio     - extanded priority information. If device support extanded 
- *					 priority, prio field should be ignored.
+ *        DBNum       - ATU MAC Address Database number. If multiple address 
+ *                     databases are not being used, DBNum should be zero.
+ *                     If multiple address databases are being used, this value
+ *                     should be set to the desired address database number.
+ *        exPrio     - extanded priority information. If device support extanded 
+ *                     priority, prio field should be ignored.
  *
  *  Comment:
  *      The entryState union Type is determine according to the Mac Type.
  */
 typedef struct
 {
-	GT_ETHERADDR 	macAddr;
-	GT_BOOL			trunkMember;
-	GT_U32			portVec;
-	GT_U8			prio;
-	GT_U8			reserved;
-	GT_U16			DBNum;
-	union
-	{
-		GT_ATU_UC_STATE ucEntryState;
-		GT_ATU_MC_STATE mcEntryState;
-	} entryState;
-	GT_ATU_EXT_PRI	exPrio;
+    GT_ETHERADDR     macAddr;
+    GT_BOOL            trunkMember;
+    GT_U32            portVec;
+    GT_U8            prio;
+    GT_U8            reserved;
+    GT_U16            DBNum;
+    union
+    {
+        GT_ATU_UC_STATE ucEntryState;
+        GT_ATU_MC_STATE mcEntryState;
+    } entryState;
+    GT_ATU_EXT_PRI    exPrio;
 } GT_ATU_ENTRY;
 
 
@@ -825,65 +840,65 @@ typedef struct
  *                   memberTagP[0] is for Port 0, MemberTagP[1] is for port 1, and so on 
  *
  *  Comment:
- * 	MAX_SWITCH_PORTS is 10 for Octane.
- * 	In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
+ *     MAX_SWITCH_PORTS is 10 for Octane.
+ *     In the case of FullSail, there are 3 ports. So, the rest 7 is ignored in memeberTagP
  */
 typedef struct
 {
-	GT_U8     memberTagP[MAX_SWITCH_PORTS];
-	GT_U8     portStateP[MAX_SWITCH_PORTS];
+    GT_U8     memberTagP[MAX_SWITCH_PORTS];
+    GT_U8     portStateP[MAX_SWITCH_PORTS];
 } GT_VTU_DATA;
 
 /*
  *  definition for MEMBER_TAG
  */
-#define MEMBER_EGRESS_UNMODIFIED	0
-#define NOT_A_MEMBER				1
-#define MEMBER_EGRESS_UNTAGGED		2
-#define MEMBER_EGRESS_TAGGED		3
+#define MEMBER_EGRESS_UNMODIFIED    0
+#define NOT_A_MEMBER                1
+#define MEMBER_EGRESS_UNTAGGED        2
+#define MEMBER_EGRESS_TAGGED        3
 
 /*
  *  typedef: struct GT_VTU_EXT_INFO
  *
  *  Description: 
- *		Extanded VTU Entry information for Priority Override and Non Rate Limit.
- *		Frame Priority is used to as the tag's PRI bits if the frame egresses
- *		the switch tagged. The egresss queue the frame is switch into is not
- *		modified by the Frame Priority Override.
- *		Queue Priority is used to determine the egress queue the frame is
- *		switched into. If the frame egresses tagged, the priority in the frame 
- *		will not be modified by a Queue Priority Override.
- *		NonRateLimit for VID is used to indicate any frames associated with this 
- *		VID are to bypass ingress and egress rate limiting, if the ingress 
- *		port's VID NRateLimit is also enabled.
+ *        Extanded VTU Entry information for Priority Override and Non Rate Limit.
+ *        Frame Priority is used to as the tag's PRI bits if the frame egresses
+ *        the switch tagged. The egresss queue the frame is switch into is not
+ *        modified by the Frame Priority Override.
+ *        Queue Priority is used to determine the egress queue the frame is
+ *        switched into. If the frame egresses tagged, the priority in the frame 
+ *        will not be modified by a Queue Priority Override.
+ *        NonRateLimit for VID is used to indicate any frames associated with this 
+ *        VID are to bypass ingress and egress rate limiting, if the ingress 
+ *        port's VID NRateLimit is also enabled.
  *
  *  Fields:
  *      useVIDFPri - Use VID frame priority override. When this is GT_TRUE and 
- *					 VIDFPriOverride of the ingress port of the frame is enabled,
- *					 vidFPri data is used to override the frame priority on
- *					 any frame associated with this VID.
+ *                     VIDFPriOverride of the ingress port of the frame is enabled,
+ *                     vidFPri data is used to override the frame priority on
+ *                     any frame associated with this VID.
  *      vidFPri    - VID frame priority data (0 ~ 7).
  *      useVIDQPri - Use VID queue priority override. When this is GT_TRUE and
- *					 VIDQPriOverride of the ingress port of the frame is enabled,
- *					 vidQPri data can be used to override the queue priority on
- *					 any frame associated with this VID.
+ *                     VIDQPriOverride of the ingress port of the frame is enabled,
+ *                     vidQPri data can be used to override the queue priority on
+ *                     any frame associated with this VID.
  *      vidQPri    - VID queue priority data (0 ~ 3).
  *      vidNRateLimit - bypass rate ingress and egress limiting
  *
  *  Comment:
  *      Please refer to the device datasheet to find out if this feature is supported.
- *		When this structure is implemented, the followings are the devices supporting 
- *		this feature:
- *			88E6065, 88E6035, and 88E6055 support all data.
- *			88E6061 and 88E6031 support only vidNRateLimit.
+ *        When this structure is implemented, the followings are the devices supporting 
+ *        this feature:
+ *            88E6065, 88E6035, and 88E6055 support all data.
+ *            88E6061 and 88E6031 support only vidNRateLimit.
  */
 typedef struct
 {
-	GT_BOOL			useVIDFPri;
-	GT_U8 			vidFPri;
-	GT_BOOL			useVIDQPri;
-	GT_U8 			vidQPri;
-	GT_BOOL			vidNRateLimit;
+    GT_BOOL            useVIDFPri;
+    GT_U8             vidFPri;
+    GT_BOOL            useVIDQPri;
+    GT_U8             vidQPri;
+    GT_BOOL            vidNRateLimit;
 } GT_VTU_EXT_INFO;
 
  
@@ -891,34 +906,34 @@ typedef struct
  *  typedef: struct GT_VTU_ENTRY
  *
  *  Description: VLAN tarnslaton unit Entry
- *		Each field in the structure is device specific, i.e., some fields may not
- *		be supported by the used switch device. In such case, those fields are
- *		ignored by the DSDT driver. Please refer to the datasheet for the list of
- *		supported fields.
+ *        Each field in the structure is device specific, i.e., some fields may not
+ *        be supported by the used switch device. In such case, those fields are
+ *        ignored by the DSDT driver. Please refer to the datasheet for the list of
+ *        supported fields.
  *
  *  Fields:
  *      DBNum      - database number or FID (forwarding information database)
  *      vid        - VLAN ID 
  *      vtuData    - VTU data
- *		vidPriOverride - override the priority on any frame associated with this VID
- *		vidPriority - VID Priority bits (0 ~ 7)
- *		sid	       - 802.1s Port State Database ID
- *		vidPolicy  - indicate that the frame with this VID uses VID Policy
- *		             (see gprtSetPolicy API).
- *		vidExInfo  - extanded information for VTU entry. If the device supports extanded 
- *					 information, vidPriorityOverride and vidPriority values are 
- *					 ignored.
+ *        vidPriOverride - override the priority on any frame associated with this VID
+ *        vidPriority - VID Priority bits (0 ~ 7)
+ *        sid           - 802.1s Port State Database ID
+ *        vidPolicy  - indicate that the frame with this VID uses VID Policy
+ *                     (see gprtSetPolicy API).
+ *        vidExInfo  - extanded information for VTU entry. If the device supports extanded 
+ *                     information, vidPriorityOverride and vidPriority values are 
+ *                     ignored.
  */
 typedef struct
 {
-	GT_U16        DBNum;
-	GT_U16        vid;
-	GT_VTU_DATA   vtuData;
-	GT_BOOL		  vidPriOverride;
-	GT_U8		  vidPriority;
-	GT_U8		  sid;
-	GT_BOOL		  vidPolicy;
-	GT_VTU_EXT_INFO	vidExInfo;
+    GT_U16        DBNum;
+    GT_U16        vid;
+    GT_VTU_DATA   vtuData;
+    GT_BOOL          vidPriOverride;
+    GT_U8          vidPriority;
+    GT_U8          sid;
+    GT_BOOL          vidPolicy;
+    GT_VTU_EXT_INFO    vidExInfo;
 } GT_VTU_ENTRY;
 
 
@@ -934,8 +949,8 @@ typedef struct
  */
 typedef enum
 {
-	LOAD_PURGE_STU_ENTRY = 5,
-	GET_NEXT_STU_ENTRY =6 
+    LOAD_PURGE_STU_ENTRY = 5,
+    GET_NEXT_STU_ENTRY =6 
 } GT_STU_OPERATION;
 
 
@@ -946,12 +961,12 @@ typedef enum
  *
  *  Fields:
  *      sid       - STU ID 
- *		portState - Per VLAN Port States for each port.
+ *        portState - Per VLAN Port States for each port.
  */
 typedef struct
 {
-	GT_U16				sid;
-	GT_PORT_STP_STATE	portState[MAX_SWITCH_PORTS];
+    GT_U16                sid;
+    GT_PORT_STP_STATE    portState[MAX_SWITCH_PORTS];
 } GT_STU_ENTRY;
 
 
@@ -962,18 +977,18 @@ typedef struct
  *
  *  Fields:
  *      intCause  - VTU Interrupt Cause
- *					GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
- *					GT_MISS_VIOLATION
+ *                    GT_VTU_FULL_VIOLATION,GT_MEMEBER_VIOLATION,or
+ *                    GT_MISS_VIOLATION
  *      SPID      - source port number
- * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
  *      vid       - VLAN ID 
- * 					if intCause is GT_VTU_FULL_VIOLATION, it means nothing
+ *                     if intCause is GT_VTU_FULL_VIOLATION, it means nothing
  */
 typedef struct
 {
-	GT_U16   vtuIntCause;
-	GT_U8    spid;
-	GT_U16   vid;
+    GT_U16   vtuIntCause;
+    GT_U8    spid;
+    GT_U16   vid;
 } GT_VTU_INT_STATUS;
 
 /*
@@ -983,42 +998,43 @@ typedef struct
  *
  *  Fields:
  *      intCause  - ATU Interrupt Cause
- *					GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,
- *					GT_MISS_VIOLATION, GT_AGE_VIOLATION, or 
- *					GT_AGE_OUT_VIOLATION
+ *                    GT_FULL_VIOLATION,GT_MEMEBER_VIOLATION,
+ *                    GT_MISS_VIOLATION, GT_AGE_VIOLATION, or 
+ *                    GT_AGE_OUT_VIOLATION
  *      SPID      - source port number
- * 					if intCause is GT_FULL_VIOLATION, it means nothing
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
  *      DBNum     - DB Num (or FID)
- * 					if intCause is GT_FULL_VIOLATION, it means nothing
- *		macAddr	  - MAC Address
+ *                     if intCause is GT_FULL_VIOLATION, it means nothing
+ *        macAddr      - MAC Address
  */
 typedef struct
 {
-	GT_U16   atuIntCause;
-	GT_U8    spid;
-	GT_U8    dbNum;
-	GT_ETHERADDR  macAddr;
+    GT_U16   atuIntCause;
+    GT_U8    spid;
+    GT_U8    dbNum;
+    GT_ETHERADDR  macAddr;
 } GT_ATU_INT_STATUS;
 
 /*
 * Definition for VTU interrupt
 */
-#define GT_MEMBER_VIOLATION		0x4
-#define GT_MISS_VIOLATION		0x2
-#define GT_VTU_FULL_VIOLATION	0x1
+#define GT_MEMBER_VIOLATION        0x4
+#define GT_MISS_VIOLATION        0x2
+#define GT_VTU_FULL_VIOLATION    0x1
 /*
 * Definitions for ATU interrupt in Gigabit switch are the same as 
 * the ones for VTU interrupt. Here we just redefine the FULL_VIOLATION for
 * both VTU and ATU.
 */
-#define GT_FULL_VIOLATION		0x1
+#define GT_FULL_VIOLATION        0x1
 
-#define GT_AGE_VIOLATION		0x8
-#define GT_AGE_OUT_VIOLATION	0x10
+#define GT_AGE_VIOLATION        0x8
+#define GT_AGE_OUT_VIOLATION    0x10
 
 
 /*
- * Typedef: enum GT_PVT_OPERATION
+
+  * Typedef: enum GT_PVT_OPERATION
  *
  * Description: Defines the PVT (Cross Chip Port VLAN Table) Operation type
  *
@@ -1029,9 +1045,9 @@ typedef struct
  */
 typedef enum
 {
-	PVT_INITIALIZE 	= 0x1,
-	PVT_WRITE		= 0x3,
-	PVT_READ		= 0x4
+    PVT_INITIALIZE     = 0x1,
+    PVT_WRITE        = 0x3,
+    PVT_READ        = 0x4
 } GT_PVT_OPERATION;
 
 
@@ -1046,8 +1062,8 @@ typedef enum
  */
 typedef struct
 {
-	GT_U32	pvtAddr;
-	GT_U32	pvtData;
+    GT_U32    pvtAddr;
+    GT_U32    pvtData;
 } GT_PVT_OP_DATA;
 
 
@@ -1058,15 +1074,15 @@ typedef struct
  *
  *  Enumerations:
  *      GT_PIRL_FC_DEASSERT_EMPTY -
- *				De-assert when the ingress rate resource has become empty
- *		GT_PIRL_FC_DEASSERT_CBS_LIMIT -
- *				De-assert when the ingress rate resource has enough room as
- *				specified by the CBSLimit.
+ *                De-assert when the ingress rate resource has become empty
+ *        GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                De-assert when the ingress rate resource has enough room as
+ *                specified by the CBSLimit.
  */
 typedef enum
 {
-	GT_PIRL_FC_DEASSERT_EMPTY = 0,
-	GT_PIRL_FC_DEASSERT_CBS_LIMIT
+    GT_PIRL_FC_DEASSERT_EMPTY = 0,
+    GT_PIRL_FC_DEASSERT_CBS_LIMIT
 } GT_PIRL_FC_DEASSERT;
 
 
@@ -1077,22 +1093,22 @@ typedef enum
  *
  *  Enumerations:
  *      GT_PIRL_ELIMIT_FRAME -
- *				Count the number of frames
+ *                Count the number of frames
  *      GT_PIRL_ELIMIT_LAYER1 -
- *				Count all Layer 1 bytes: 
- *				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *                Count all Layer 1 bytes: 
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
  *      GT_PIRL_ELIMIT_LAYER2 -
- *				Count all Layer 2 bytes: Frame's DA to CRC
+ *                Count all Layer 2 bytes: Frame's DA to CRC
  *      GT_PIRL_ELIMIT_LAYER3 -
- *				Count all Layer 3 bytes: 
- *				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ *                Count all Layer 3 bytes: 
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
  */
 typedef enum
 {
-	GT_PIRL_ELIMIT_FRAME = 0,
-	GT_PIRL_ELIMIT_LAYER1,
-	GT_PIRL_ELIMIT_LAYER2,
-	GT_PIRL_ELIMIT_LAYER3
+    GT_PIRL_ELIMIT_FRAME = 0,
+    GT_PIRL_ELIMIT_LAYER1,
+    GT_PIRL_ELIMIT_LAYER2,
+    GT_PIRL_ELIMIT_LAYER3
 } GT_PIRL_ELIMIT_MODE;
 
 
@@ -1102,10 +1118,10 @@ typedef enum
 
 typedef enum
 {
-	GT_LIMT_ALL = 0, 		/* limit and count all frames */
-	GT_LIMIT_FLOOD,      	/* limit and count Broadcast, Multicast and flooded unicast frames */
-	GT_LIMIT_BRDCST_MLTCST,	/* limit and count Broadcast and Multicast frames */
-	GT_LIMIT_BRDCST   		/* limit and count Broadcast frames */
+    GT_LIMT_ALL = 0,         /* limit and count all frames */
+    GT_LIMIT_FLOOD,          /* limit and count Broadcast, Multicast and flooded unicast frames */
+    GT_LIMIT_BRDCST_MLTCST,    /* limit and count Broadcast and Multicast frames */
+    GT_LIMIT_BRDCST           /* limit and count Broadcast frames */
 } GT_RATE_LIMIT_MODE;
 
 /* typedef: enum GT_PRI0_RATE
@@ -1114,19 +1130,19 @@ typedef enum
 
 typedef enum
 {
-	GT_NO_LIMIT = 0, 	/* Not limited   */
-	GT_128K,      		/* 128K bits/sec */
-	GT_256K,      		/* 256K bits/sec */
-	GT_512K,      		/* 512 bits/sec */
-	GT_1M,      		/* 1M  bits/sec */
-	GT_2M,      		/* 2M  bits/sec */
-	GT_4M,      		/* 4M  bits/sec */
-	GT_8M,      		/* 8M  bits/sec */
-	GT_16M,      		/* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
-	GT_32M,      		/* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
-	GT_64M,      		/* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
-	GT_128M,      		/* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
-	GT_256M      		/* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_NO_LIMIT = 0,     /* Not limited   */
+    GT_128K,              /* 128K bits/sec */
+    GT_256K,              /* 256K bits/sec */
+    GT_512K,              /* 512 bits/sec */
+    GT_1M,              /* 1M  bits/sec */
+    GT_2M,              /* 2M  bits/sec */
+    GT_4M,              /* 4M  bits/sec */
+    GT_8M,              /* 8M  bits/sec */
+    GT_16M,              /* 16M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_32M,              /* 32M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_64M,              /* 64M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_128M,              /* 128M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
+    GT_256M              /* 256M  bits/sec, Note: supported only by Gigabit Ethernet Switch */
 } GT_PRI0_RATE,GT_EGRESS_RATE;
 
 
@@ -1137,47 +1153,47 @@ typedef enum
  *
  * Fields:
  *      definedRate - GT_EGRESS_RATE enum type should be used on the following devices:
- *						88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183, 88E6093
- *						88E6095, 88E6185, 88E6108, 88E6065, 88E6061, and their variations.
+ *                        88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183, 88E6093
+ *                        88E6095, 88E6185, 88E6108, 88E6065, 88E6061, and their variations.
  *      kbRate      - rate in kbps that should be used on the following devices:
- *						88E6097, 88E6096 with count mode of non frame, such as
- *									ALL_LAYER1, ALL_LAYER2, and ALL_LAYER3
- *						64kbps ~ 1Mbps    : increments of 64kbps,
- *						1Mbps ~ 100Mbps   : increments of 1Mbps, and
- *						100Mbps ~ 1000Mbps: increments of 10Mbps
- *						Therefore, the valid values are:
- *							64, 128, 192, 256, 320, 384,..., 960,
- *							1000, 2000, 3000, 4000, ..., 100000,
- *							110000, 120000, 130000, ..., 1000000.
- *      fRate 		- frame per second that should be used on the following devices:
- *						88E6097, 88E6096 with count mode of frame (GT_PIRL_COUNT_FRAME)
+ *                        88E6097, 88E6096 with count mode of non frame, such as
+ *                                    ALL_LAYER1, ALL_LAYER2, and ALL_LAYER3
+ *                        64kbps ~ 1Mbps    : increments of 64kbps,
+ *                        1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                        100Mbps ~ 1000Mbps: increments of 10Mbps
+ *                        Therefore, the valid values are:
+ *                            64, 128, 192, 256, 320, 384,..., 960,
+ *                            1000, 2000, 3000, 4000, ..., 100000,
+ *                            110000, 120000, 130000, ..., 1000000.
+ *      fRate         - frame per second that should be used on the following devices:
+ *                        88E6097, 88E6096 with count mode of frame (GT_PIRL_COUNT_FRAME)
  */
 typedef union
 {
-	GT_EGRESS_RATE	definedRate;
-	GT_U32			kbRate;
-	GT_U32			fRate;
+    GT_EGRESS_RATE    definedRate;
+    GT_U32            kbRate;
+    GT_U32            fRate;
 } GT_ERATE_TYPE;
 
 /*
  * Formula for Rate Limit of Gigabit Switch family and Enhanced FastEthernet Switch
  */
-#define GT_GET_RATE_LIMIT(_kbps)	\
-		((_kbps)?(8000000 / (28 * (_kbps))):0)
-#define GT_GET_RATE_LIMIT2(_kbps)	\
-		((_kbps)?(8000000 / (32 * (_kbps)) + (8000000 % (32 * (_kbps))?1:0)):0)
-#define GT_GET_RATE_LIMIT3(_kbps)	\
-		((_kbps)?(8000000 / (40 * (_kbps)) + (8000000 % (40 * (_kbps))?1:0)):0)
+#define GT_GET_RATE_LIMIT(_kbps)    \
+        ((_kbps)?(8000000 / (28 * (_kbps))):0)
+#define GT_GET_RATE_LIMIT2(_kbps)    \
+        ((_kbps)?(8000000 / (32 * (_kbps)) + (8000000 % (32 * (_kbps))?1:0)):0)
+#define GT_GET_RATE_LIMIT3(_kbps)    \
+        ((_kbps)?(8000000 / (40 * (_kbps)) + (8000000 % (40 * (_kbps))?1:0)):0)
 
-#define MAX_RATE_LIMIT		256000	/* unit of Kbps */
-#define MIN_RATE_LIMIT		65		/* unit of Kbps */
+#define MAX_RATE_LIMIT        256000    /* unit of Kbps */
+#define MIN_RATE_LIMIT        65        /* unit of Kbps */
 
 
-#define GT_GET_RATE_LIMIT_PER_FRAME(_frames, _dec)	\
-		((_frames)?(1000000000 / (32 * (_frames)) + (1000000000 % (32 * (_frames))?1:0)):0)
+#define GT_GET_RATE_LIMIT_PER_FRAME(_frames, _dec)    \
+        ((_frames)?(1000000000 / (32 * (_frames)) + (1000000000 % (32 * (_frames))?1:0)):0)
 
-#define GT_GET_RATE_LIMIT_PER_BYTE(_kbps, _dec)	\
-		((_kbps)?((8000000*(_dec)) / (32 * (_kbps)) + ((8000000*(_dec)) % (32 * (_kbps))?1:0)):0)
+#define GT_GET_RATE_LIMIT_PER_BYTE(_kbps, _dec)    \
+        ((_kbps)?((8000000*(_dec)) / (32 * (_kbps)) + ((8000000*(_dec)) % (32 * (_kbps))?1:0)):0)
 
 /* 
  * typedef: enum GT_BURST_SIZE
@@ -1186,10 +1202,10 @@ typedef union
 
 typedef enum
 {
-	GT_BURST_SIZE_12K = 0, 	/* 12K byte burst size */
-	GT_BURST_SIZE_24K,		/* 24K byte burst size */
-	GT_BURST_SIZE_48K,		/* 48K byte burst size */
-	GT_BURST_SIZE_96K 	 	/* 96K byte burst size */
+    GT_BURST_SIZE_12K = 0,     /* 12K byte burst size */
+    GT_BURST_SIZE_24K,        /* 24K byte burst size */
+    GT_BURST_SIZE_48K,        /* 48K byte burst size */
+    GT_BURST_SIZE_96K          /* 96K byte burst size */
 } GT_BURST_SIZE;
 
 /* 
@@ -1199,34 +1215,34 @@ typedef enum
 
 typedef enum
 {
-	GT_BURST_NO_LIMIT = 0, 	/* Not limited   */
-	GT_BURST_64K,  		/* 64K bits/sec */
-	GT_BURST_128K,  	/* 128K bits/sec */
-	GT_BURST_256K,  	/* 256K bits/sec */
-	GT_BURST_384K,  	/* 384K bits/sec */
-	GT_BURST_512K,  	/* 512 bits/sec */
-	GT_BURST_640K,  	/* 640K bits/sec */
-	GT_BURST_768K,  	/* 768K bits/sec */
-	GT_BURST_896K,  	/* 896K bits/sec */
-	GT_BURST_1M,    	/* 1M  bits/sec */
-	GT_BURST_1500K,  	/* 1.5M bits/sec */
-	GT_BURST_2M,    	/* 2M  bits/sec */
-	GT_BURST_4M,    	/* 4M  bits/sec */
-	GT_BURST_8M,   		/* 8M  bits/sec */
-	GT_BURST_16M,  		/* 16M  bits/sec */
-	GT_BURST_32M,  		/* 32M  bits/sec */
-	GT_BURST_64M,  		/* 64M  bits/sec */
-	GT_BURST_128M, 		/* 128M  bits/sec */
-	GT_BURST_256M  		/* 256M  bits/sec */
+    GT_BURST_NO_LIMIT = 0,     /* Not limited   */
+    GT_BURST_64K,          /* 64K bits/sec */
+    GT_BURST_128K,      /* 128K bits/sec */
+    GT_BURST_256K,      /* 256K bits/sec */
+    GT_BURST_384K,      /* 384K bits/sec */
+    GT_BURST_512K,      /* 512 bits/sec */
+    GT_BURST_640K,      /* 640K bits/sec */
+    GT_BURST_768K,      /* 768K bits/sec */
+    GT_BURST_896K,      /* 896K bits/sec */
+    GT_BURST_1M,        /* 1M  bits/sec */
+    GT_BURST_1500K,      /* 1.5M bits/sec */
+    GT_BURST_2M,        /* 2M  bits/sec */
+    GT_BURST_4M,        /* 4M  bits/sec */
+    GT_BURST_8M,           /* 8M  bits/sec */
+    GT_BURST_16M,          /* 16M  bits/sec */
+    GT_BURST_32M,          /* 32M  bits/sec */
+    GT_BURST_64M,          /* 64M  bits/sec */
+    GT_BURST_128M,         /* 128M  bits/sec */
+    GT_BURST_256M          /* 256M  bits/sec */
 } GT_BURST_RATE;
 
 /*
  * Formula for burst based Rate Limit
  */
-#define GT_GET_BURST_RATE_LIMIT(_bsize,_kbps)	\
-		((_kbps)?(((_bsize)+1)*8000000 / (32 * (_kbps)) + 		\
-				(((_bsize)+1)*8000000 % (32 * (_kbps))?1:0))	\
-				:0)
+#define GT_GET_BURST_RATE_LIMIT(_bsize,_kbps)    \
+        ((_kbps)?(((_bsize)+1)*8000000 / (32 * (_kbps)) +         \
+                (((_bsize)+1)*8000000 % (32 * (_kbps))?1:0))    \
+                :0)
 
 /*
  * Typedef: enum GT_PIRL_OPERATION
@@ -1241,10 +1257,10 @@ typedef enum
  */
 typedef enum
 {
-	PIRL_INIT_ALL_RESOURCE 	= 0x1,
-	PIRL_INIT_RESOURCE		= 0x2,
-	PIRL_WRITE_RESOURCE		= 0x3,
-	PIRL_READ_RESOURCE		= 0x4
+    PIRL_INIT_ALL_RESOURCE     = 0x1,
+    PIRL_INIT_RESOURCE        = 0x2,
+    PIRL_WRITE_RESOURCE        = 0x3,
+    PIRL_READ_RESOURCE        = 0x4
 } GT_PIRL_OPERATION, GT_PIRL2_OPERATION;
 
 
@@ -1260,9 +1276,9 @@ typedef enum
  */
 typedef struct
 {
-	GT_U32	irlUnit;
-	GT_U32	irlReg;
-	GT_U32	irlData;
+    GT_U32    irlUnit;
+    GT_U32    irlReg;
+    GT_U32    irlData;
 } GT_PIRL_OP_DATA;
 
 /*
@@ -1278,42 +1294,42 @@ typedef struct
  */
 typedef struct
 {
-	GT_U32	irlPort;
-	GT_U32	irlRes;
-	GT_U32	irlReg;
-	GT_U32	irlData;
+    GT_U32    irlPort;
+    GT_U32    irlRes;
+    GT_U32    irlReg;
+    GT_U32    irlData;
 } GT_PIRL2_OP_DATA;
 
 /*
  * Typedef: enum GT_PIRL_ACTION
  *
  * Description: Defines the Action that should be taken when
- *		there there are not enough tokens to accept the entire incoming frame
+ *        there there are not enough tokens to accept the entire incoming frame
  *
  * Fields:
- *		PIRL_ACTION_ACCEPT - accept the frame
- *		PIRL_ACTION_USE_LIMIT_ACTION - use ESB Limit Action
+ *        PIRL_ACTION_ACCEPT - accept the frame
+ *        PIRL_ACTION_USE_LIMIT_ACTION - use ESB Limit Action
  */
 typedef enum
 {
-	PIRL_ACTION_USE_LIMIT_ACTION = 0x0,
-	PIRL_ACTION_ACCEPT 	= 0x1
+    PIRL_ACTION_USE_LIMIT_ACTION = 0x0,
+    PIRL_ACTION_ACCEPT     = 0x1
 } GT_PIRL_ACTION;
 
 /*
  * Typedef: enum GT_ESB_LIMIT_ACTION
  *
  * Description: Defines the ESB Limit Action that should be taken when
- *		the incoming port information rate exceeds the EBS_Limit.
+ *        the incoming port information rate exceeds the EBS_Limit.
  *
  * Fields:
- *		ESB_LIMIT_ACTION_DROP - drop packets
- *		ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ESB_LIMIT_ACTION_DROP - drop packets
+ *        ESB_LIMIT_ACTION_FC   - send flow control packet
  */
 typedef enum
 {
-	ESB_LIMIT_ACTION_DROP 	= 0x0,
-	ESB_LIMIT_ACTION_FC		= 0x1
+    ESB_LIMIT_ACTION_DROP     = 0x0,
+    ESB_LIMIT_ACTION_FC        = 0x1
 } GT_ESB_LIMIT_ACTION;
 
 
@@ -1323,53 +1339,53 @@ typedef enum
  * Description: Defines the Bucket Rate Type
  *
  * Fields:
- *		BUCKET_TYPE_TRAFFIC_BASED	- bucket is traffic type based
- *		BUCKET_TYPE_RATE_BASED		- bucket is rate based
+ *        BUCKET_TYPE_TRAFFIC_BASED    - bucket is traffic type based
+ *        BUCKET_TYPE_RATE_BASED        - bucket is rate based
  */
 typedef enum
 {
-	BUCKET_TYPE_TRAFFIC_BASED	= 0x0,
-	BUCKET_TYPE_RATE_BASED		= 0x1
+    BUCKET_TYPE_TRAFFIC_BASED    = 0x0,
+    BUCKET_TYPE_RATE_BASED        = 0x1
 } GT_BUCKET_RATE_TYPE;
 
 /*
  * Definition for GT_BUCKET_TYPE_TRAFFIC_BASED
  *
  * Description: Defines the Traffic Type that is used when Bucket Rate Type
- *		is traffic type based (BUCKET_TYPE_TRAFFIC_BASED).
- *		Please refer to the device datasheet in order to check which traffic
- *		types are supported.
+ *        is traffic type based (BUCKET_TYPE_TRAFFIC_BASED).
+ *        Please refer to the device datasheet in order to check which traffic
+ *        types are supported.
  *
  * Definition:
- *		BUCKET_TRAFFIC_UNKNOWN_UNICAST	- unknown unicast frame
- *		BUCKET_TRAFFIC_UNKNOWN_MULTICAST- unknown multicast frame
- *		BUCKET_TRAFFIC_BROADCAST		- broadcast frame
- *		BUCKET_TRAFFIC_MULTICAST		- multicast frame
- *		BUCKET_TRAFFIC_UNICAST			- unicast frame
- *		BUCKET_TRAFFIC_MGMT_FRAME		- management frame
- *		BUCKET_TRAFFIC_ARP				- arp frame
- *		BUCKET_TRAFFIC_TCP_DATA			- TCP Data
- *		BUCKET_TRAFFIC_TCP_CTRL			- TCP Ctrl (if any of the TCP Flags[5:0] are set)
- *		BUCKET_TRAFFIC_UDP				- UDP
- *		BUCKET_TRAFFIC_NON_TCPUDP		- covers IGMP,ICMP,GRE,IGRP,L2TP
- *		BUCKET_TRAFFIC_IMS				- Ingress Monitor Source
- *		BUCKET_TRAFFIC_POLICY_MIRROR	- Policy Mirror
- *		BUCKET_TRAFFIC_PLICY_TRAP		- Policy Trap
- */
-#define BUCKET_TRAFFIC_UNKNOWN_UNICAST  	0x01
-#define BUCKET_TRAFFIC_UNKNOWN_MULTICAST	0x02
-#define BUCKET_TRAFFIC_BROADCAST			0x04
-#define BUCKET_TRAFFIC_MULTICAST			0x08
-#define BUCKET_TRAFFIC_UNICAST				0x10
-#define BUCKET_TRAFFIC_MGMT_FRAME			0x20
-#define BUCKET_TRAFFIC_ARP					0x40
-#define BUCKET_TRAFFIC_TCP_DATA				0x100
-#define BUCKET_TRAFFIC_TCP_CTRL				0x200
-#define BUCKET_TRAFFIC_UDP					0x400
-#define BUCKET_TRAFFIC_NON_TCPUDP			0x800
-#define BUCKET_TRAFFIC_IMS					0x1000
-#define BUCKET_TRAFFIC_POLICY_MIRROR		0x2000
-#define BUCKET_TRAFFIC_PLICY_TRAP			0x4000
+ *        BUCKET_TRAFFIC_UNKNOWN_UNICAST    - unknown unicast frame
+ *        BUCKET_TRAFFIC_UNKNOWN_MULTICAST- unknown multicast frame
+ *        BUCKET_TRAFFIC_BROADCAST        - broadcast frame
+ *        BUCKET_TRAFFIC_MULTICAST        - multicast frame
+ *        BUCKET_TRAFFIC_UNICAST            - unicast frame
+ *        BUCKET_TRAFFIC_MGMT_FRAME        - management frame
+ *        BUCKET_TRAFFIC_ARP                - arp frame
+ *        BUCKET_TRAFFIC_TCP_DATA            - TCP Data
+ *        BUCKET_TRAFFIC_TCP_CTRL            - TCP Ctrl (if any of the TCP Flags[5:0] are set)
+ *        BUCKET_TRAFFIC_UDP                - UDP
+ *        BUCKET_TRAFFIC_NON_TCPUDP        - covers IGMP,ICMP,GRE,IGRP,L2TP
+ *        BUCKET_TRAFFIC_IMS                - Ingress Monitor Source
+ *        BUCKET_TRAFFIC_POLICY_MIRROR    - Policy Mirror
+ *        BUCKET_TRAFFIC_PLICY_TRAP        - Policy Trap
+ */
+#define BUCKET_TRAFFIC_UNKNOWN_UNICAST      0x01
+#define BUCKET_TRAFFIC_UNKNOWN_MULTICAST    0x02
+#define BUCKET_TRAFFIC_BROADCAST            0x04
+#define BUCKET_TRAFFIC_MULTICAST            0x08
+#define BUCKET_TRAFFIC_UNICAST                0x10
+#define BUCKET_TRAFFIC_MGMT_FRAME            0x20
+#define BUCKET_TRAFFIC_ARP                    0x40
+#define BUCKET_TRAFFIC_TCP_DATA                0x100
+#define BUCKET_TRAFFIC_TCP_CTRL                0x200
+#define BUCKET_TRAFFIC_UDP                    0x400
+#define BUCKET_TRAFFIC_NON_TCPUDP            0x800
+#define BUCKET_TRAFFIC_IMS                    0x1000
+#define BUCKET_TRAFFIC_POLICY_MIRROR        0x2000
+#define BUCKET_TRAFFIC_PLICY_TRAP            0x4000
 
 /*
  *  typedef: enum GT_PIRL_COUNT_MODE
@@ -1378,19 +1394,19 @@ typedef enum
  *
  *  Enumerations:
  *      GT_PIRL_COUNT_ALL_LAYER1 -
- *				Count all Layer 1 bytes: 
- *				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *                Count all Layer 1 bytes: 
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
  *      GT_PIRL_COUNT_ALL_LAYER2 -
- *				Count all Layer 2 bytes: Frame's DA to CRC
+ *                Count all Layer 2 bytes: Frame's DA to CRC
  *      GT_PIRL_COUNT_ALL_LAYER3 -
- *				Count all Layer 3 bytes: 
- *				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ *                Count all Layer 3 bytes: 
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
  */
 typedef enum
 {
-	GT_PIRL_COUNT_ALL_LAYER1 = 0,
-	GT_PIRL_COUNT_ALL_LAYER2,
-	GT_PIRL_COUNT_ALL_LAYER3
+    GT_PIRL_COUNT_ALL_LAYER1 = 0,
+    GT_PIRL_COUNT_ALL_LAYER2,
+    GT_PIRL_COUNT_ALL_LAYER3
 } GT_PIRL_COUNT_MODE;
 
 /*
@@ -1400,22 +1416,22 @@ typedef enum
  *
  *  Enumerations:
  *      GT_PIRL2_COUNT_FRAME -
- *				Count the number of frames
+ *                Count the number of frames
  *      GT_PIRL2_COUNT_ALL_LAYER1 -
- *				Count all Layer 1 bytes: 
- *				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+ *                Count all Layer 1 bytes: 
+ *                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
  *      GT_PIRL2_COUNT_ALL_LAYER2 -
- *				Count all Layer 2 bytes: Frame's DA to CRC
+ *                Count all Layer 2 bytes: Frame's DA to CRC
  *      GT_PIRL2_COUNT_ALL_LAYER3 -
- *				Count all Layer 3 bytes: 
- *				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+ *                Count all Layer 3 bytes: 
+ *                Frame's DA to CRC - 18 - 4 (if frame is tagged)
  */
 typedef enum
 {
-	GT_PIRL2_COUNT_FRAME = 0,
-	GT_PIRL2_COUNT_ALL_LAYER1,
-	GT_PIRL2_COUNT_ALL_LAYER2,
-	GT_PIRL2_COUNT_ALL_LAYER3
+    GT_PIRL2_COUNT_FRAME = 0,
+    GT_PIRL2_COUNT_ALL_LAYER1,
+    GT_PIRL2_COUNT_ALL_LAYER2,
+    GT_PIRL2_COUNT_ALL_LAYER3
 } GT_PIRL2_COUNT_MODE;
 
 
@@ -1428,87 +1444,87 @@ typedef enum
  *  Fields:
  *      accountQConf    - account discarded frames due to queue congestion
  *      accountFiltered - account filtered frames
- *		ebsLimitAction  - action should be taken when the incoming rate exceeds
- *						  the ebsLimit.
- *								ESB_LIMIT_ACTION_DROP - drop packets
- *								ESB_LIMIT_ACTION_FC   - send flow control packet
- *		ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
- *		cbsLimit		- Committed BUrst Size limit (expected to be 2kBytes)
- *		bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
- *						  where updateInterval indicates the rate at which the 
- *						  bucket needs to be updated with tokens, or 1/CIR, 
- *						  where CIR is the committed information rate in kbps.
- *						  bucketDecrement indicates the amount of tokens that 
- *						  need to be removed per each bucket decrement.
- *		bktIncrement    - the amount of tokens that need to be added for each 
- *						  byte of packet information.
- *		bktRateType		- bucket is either rate based or traffic type based.
- *								BUCKET_TYPE_RATE_BASED, or
- *								BUCKET_TYPE_TRAFFIC_BASED
- *		bktTypeMask		- used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
- *						  any combination of the following definitions:
- *								BUCKET_TRAFFIC_UNKNOWN_UNICAST,
- *								BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
- *								BUCKET_TRAFFIC_BROADCAST,
- *								BUCKET_TRAFFIC_MULTICAST,
- *								BUCKET_TRAFFIC_UNICAST,
- *								BUCKET_TRAFFIC_MGMT_FRAME, and
- *								BUCKET_TRAFFIC_ARP
- *		byteTobeCounted	- bytes to be counted for accounting
- *								GT_PIRL_COUNT_ALL_LAYER1,
- *								GT_PIRL_COUNT_ALL_LAYER2, or
- *								GT_PIRL_COUNT_ALL_LAYER3
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the 
+ *                          bucket needs to be updated with tokens, or 1/CIR, 
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that 
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each 
+ *                          byte of packet information.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
  *
  */
 typedef struct
 {
-	GT_BOOL		accountQConf;
-	GT_BOOL		accountFiltered;
-	GT_ESB_LIMIT_ACTION ebsLimitAction;
-	GT_U32		ebsLimit;
-	GT_U32		cbsLimit;
-	GT_U32		bktRateFactor;
-	GT_U32		bktIncrement;
-	GT_BUCKET_RATE_TYPE	bktRateType;
-	GT_U32		bktTypeMask;
-	GT_PIRL_COUNT_MODE	byteTobeCounted;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktRateFactor;
+    GT_U32        bktIncrement;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
 } GT_PIRL_RESOURCE;
 
 /*
  *  typedef: struct GT_PIRL_CUSTOM_RATE_LIMIT
  *
  *  Description: The parameters that decides Ingress Rate Limit vary depending on
- *				the application. Since DSDT driver cannot cover all the cases,
- *				this structure is provided for the custom parameter setting.
- *				However, in most cases, user may ingore this structure by setting
- *				isValid to GT_FALSE. If Ingress Rate Limit is too much off from
- *				the expected rate, please contact FAE and gets the correct ebsLimit,
- *				cbsLimit,bktIncrement, and bktRateFactor value and use this structure 
- *				to do custom parameter setting.
- *
- *		isValid         - If GT_TRUE, the paramers in this structure are used 
- *						  to program PIRL Resource's Rate Limit. And ingressRate
- *						  in GT_PIRL_BUCKET_DATA structure are ignored.
- *						  If GT_FALSE, ingressRate in GT_PIRL_BUCKET_DATA structure 
- *						  is used for Resource's Rate Limit.
- *		ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
- *		cbsLimit		- Committed Burst Size limit (expected to be 2kBytes)
- *		bktIncrement    - the amount of tokens that need to be added for each 
- *						  byte of packet information.
- *		bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
- *						  where updateInterval indicates the rate at which the 
- *						  bucket needs to be updated with tokens, or 1/CIR, 
- *						  where CIR is the committed information rate in kbps.
- *						  bucketDecrement indicates the amount of tokens that 
- *						  need to be removed per each bucket decrement.
+ *                the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit,bktIncrement, and bktRateFactor value and use this structure 
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used 
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_BUCKET_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_BUCKET_DATA structure 
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed Burst Size limit (expected to be 2kBytes)
+ *        bktIncrement    - the amount of tokens that need to be added for each 
+ *                          byte of packet information.
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the 
+ *                          bucket needs to be updated with tokens, or 1/CIR, 
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that 
+ *                          need to be removed per each bucket decrement.
 */
 typedef struct
 {
-	GT_BOOL		isValid;
-	GT_U32		ebsLimit;
-	GT_U32		cbsLimit;
-	GT_U32		bktIncrement;
-	GT_U32		bktRateFactor;
+    GT_BOOL        isValid;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktIncrement;
+    GT_U32        bktRateFactor;
 } GT_PIRL_CUSTOM_RATE_LIMIT;
 
 /*
@@ -1517,62 +1533,62 @@ typedef struct
  *  Description: data structure for PIRL Bucket programing that is resource based
  *
  *  Fields:
- *		ingressRate   	- commited ingress rate in kbps.
- *						  64kbps ~ 1Mbps    : increments of 64kbps,
- *						  1Mbps ~ 100Mbps   : increments of 1Mbps, and
- *						  100Mbps ~ 200Mbps : increments of 10Mbps
- *						  Therefore, the valid values are:
- *								64, 128, 192, 256, 320, 384,..., 960,
- *								1000, 2000, 3000, 4000, ..., 100000,
- *								110000, 120000, 130000, ..., 200000.
- *		customSetup   	- custom ingress rate parameter setup. please refer to
- *						  GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
  *      accountQConf    - account discarded frames due to queue congestion
  *      accountFiltered - account filtered frames
- *		esbLimitAction 	- action should be taken when the incoming rate exceeds
- *						  the limit.
- *								ESB_LIMIT_ACTION_DROP - drop packets
- *								ESB_LIMIT_ACTION_FC   - send flow control packet
- *		fcDeassertMode	- port flow control de-assertion mode when limitAction is
- *						  set to ESB_LIMIT_ACTION_FC.
- *						  fcDeassertMode[0] for port 0, fcDeassertMode[1] for 
- *						  port 1, etc. If port x does not share the bucket,
- *						  fcDeassertMode[x] data will be ignored.
- *								GT_PIRL_FC_DEASSERT_EMPTY -
- *									De-assert when the ingress rate resource has 
- *									become empty.
- *								GT_PIRL_FC_DEASSERT_CBS_LIMIT -
- *									De-assert when the ingress rate resource has 
- *									enough room as specified by the CBSLimit.
- *		bktRateType		- bucket is either rate based or traffic type based.
- *								BUCKET_TYPE_RATE_BASED, or
- *								BUCKET_TYPE_TRAFFIC_BASED
- *		bktTypeMask		- used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
- *						  any combination of the following definitions:
- *								BUCKET_TRAFFIC_UNKNOWN_UNICAST,
- *								BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
- *								BUCKET_TRAFFIC_BROADCAST,
- *								BUCKET_TRAFFIC_MULTICAST,
- *								BUCKET_TRAFFIC_UNICAST,
- *								BUCKET_TRAFFIC_MGMT_FRAME, and
- *								BUCKET_TRAFFIC_ARP
- *		byteTobeCounted	- bytes to be counted for accounting
- *								GT_PIRL_COUNT_ALL_LAYER1,
- *								GT_PIRL_COUNT_ALL_LAYER2, or
- *								GT_PIRL_COUNT_ALL_LAYER3
+ *        esbLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - port flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                          fcDeassertMode[0] for port 0, fcDeassertMode[1] for 
+ *                          port 1, etc. If port x does not share the bucket,
+ *                          fcDeassertMode[x] data will be ignored.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME, and
+ *                                BUCKET_TRAFFIC_ARP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL_COUNT_ALL_LAYER1,
+ *                                GT_PIRL_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL_COUNT_ALL_LAYER3
  *
  */
 typedef struct
 {
-	GT_U32		ingressRate;
-	GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
-	GT_BOOL		accountQConf;
-	GT_BOOL		accountFiltered;
-	GT_ESB_LIMIT_ACTION ebsLimitAction;
-	GT_PIRL_FC_DEASSERT fcDeassertMode[MAX_SWITCH_PORTS];
-	GT_BUCKET_RATE_TYPE	bktRateType;
-	GT_U32		bktTypeMask;
-	GT_PIRL_COUNT_MODE	byteTobeCounted;
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode[MAX_SWITCH_PORTS];
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_U32        bktTypeMask;
+    GT_PIRL_COUNT_MODE    byteTobeCounted;
 } GT_PIRL_DATA;
 
 
@@ -1584,92 +1600,92 @@ typedef struct
  *  Fields:
  *      accountQConf    - account discarded frames due to queue congestion
  *      accountFiltered - account filtered frames
- *      mgmtNrlEn 		- exclude management frame from ingress rate limiting calculation
- *      saNrlEn 		- exclude from ingress rate limiting calculation if the SA of the
- *						  frame is in ATU with EntryState that indicates Non Rate Limited.
- *      daNrlEn 		- exclude from ingress rate limiting calculation if the DA of the
- *						  frame is in ATU with EntryState that indicates Non Rate Limited.
- *		samplingMode	- sample one out of so many frames/bytes for a stream of frames
- *		actionMode		- action should be taken when there are not enough tokens
- *						  to accept the entire incoming frame
- *								PIRL_ACTION_ACCEPT - accept the frame
- *								PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
- *		ebsLimitAction  - action should be taken when the incoming rate exceeds
- *						  the ebsLimit.
- *								ESB_LIMIT_ACTION_DROP - drop packets
- *								ESB_LIMIT_ACTION_FC   - send flow control packet
- *		ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
- *		cbsLimit		- Committed BUrst Size limit (expected to be 2kBytes)
- *		bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
- *						  where updateInterval indicates the rate at which the 
- *						  bucket needs to be updated with tokens, or 1/CIR, 
- *						  where CIR is the committed information rate in kbps.
- *						  bucketDecrement indicates the amount of tokens that 
- *						  need to be removed per each bucket decrement.
- *		bktIncrement    - the amount of tokens that need to be added for each 
- *						  byte of packet information.
- *		fcDeassertMode	- flow control de-assertion mode when limitAction is
- *						  set to ESB_LIMIT_ACTION_FC.
- *								GT_PIRL_FC_DEASSERT_EMPTY -
- *									De-assert when the ingress rate resource has 
- *									become empty.
- *								GT_PIRL_FC_DEASSERT_CBS_LIMIT -
- *									De-assert when the ingress rate resource has 
- *									enough room as specified by the CBSLimit.
- *		bktRateType		- bucket is either rate based or traffic type based.
- *								BUCKET_TYPE_RATE_BASED, or
- *								BUCKET_TYPE_TRAFFIC_BASED
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction  - action should be taken when the incoming rate exceeds
+ *                          the ebsLimit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        ebsLimit        - Excess Burst Size limit ( 0 ~ 0xFFFFFF)
+ *        cbsLimit        - Committed BUrst Size limit (expected to be 2kBytes)
+ *        bktRateFactor   - bucket rate factor = bucketDecrement/updateInterval,
+ *                          where updateInterval indicates the rate at which the 
+ *                          bucket needs to be updated with tokens, or 1/CIR, 
+ *                          where CIR is the committed information rate in kbps.
+ *                          bucketDecrement indicates the amount of tokens that 
+ *                          need to be removed per each bucket decrement.
+ *        bktIncrement    - the amount of tokens that need to be added for each 
+ *                          byte of packet information.
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
  *      priORpt         - determine the incoming frames that get rate limited using
- *						  this ingress rate resource.
- *						  		GT_TRUE - typeMask OR priMask
- *						  		GT_FALSE - typeMask AND priMask
- *		priMask         - priority bit mask that each bit indicates one of the four
- *						  queue priorities. Setting each one of these bits indicates
- *						  that this particular rate resource is slated to account for
- *						  incoming frames with the enabled bits' priority.
- *		bktTypeMask		- used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
- *						  any combination of the following definitions:
- *								BUCKET_TRAFFIC_UNKNOWN_UNICAST,
- *								BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
- *								BUCKET_TRAFFIC_BROADCAST,
- *								BUCKET_TRAFFIC_MULTICAST,
- *								BUCKET_TRAFFIC_UNICAST,
- *								BUCKET_TRAFFIC_MGMT_FRAME,
- *								BUCKET_TRAFFIC_ARP,
- *								BUCKET_TRAFFIC_TCP_DATA,
- *								BUCKET_TRAFFIC_TCP_CTRL,
- *								BUCKET_TRAFFIC_UDP,
- *								BUCKET_TRAFFIC_NON_TCPUDP,
- *								BUCKET_TRAFFIC_IMS,
- *								BUCKET_TRAFFIC_POLICY_MIRROR, and
- *								BUCKET_TRAFFIC_PLICY_TRAP
- *		byteTobeCounted	- bytes to be counted for accounting
- *								GT_PIRL2_COUNT_FRAME,
- *								GT_PIRL2_COUNT_ALL_LAYER1,
- *								GT_PIRL2_COUNT_ALL_LAYER2, or
- *								GT_PIRL2_COUNT_ALL_LAYER3
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
  *
  */
 typedef struct
 {
-	GT_BOOL		accountQConf;
-	GT_BOOL		accountFiltered;
-	GT_BOOL		mgmtNrlEn;
-	GT_BOOL		saNrlEn;
-	GT_BOOL		daNrlEn;
-	GT_BOOL		samplingMode;
-	GT_PIRL_ACTION	actionMode;
-	GT_ESB_LIMIT_ACTION ebsLimitAction;
-	GT_U32		ebsLimit;
-	GT_U32		cbsLimit;
-	GT_U32		bktRateFactor;
-	GT_U32		bktIncrement;
-	GT_PIRL_FC_DEASSERT fcDeassertMode;
-	GT_BUCKET_RATE_TYPE	bktRateType;
-	GT_BOOL		priORpt;
-	GT_U32		priMask;
-	GT_U32		bktTypeMask;
-	GT_PIRL2_COUNT_MODE	byteTobeCounted;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_BOOL        mgmtNrlEn;
+    GT_BOOL        saNrlEn;
+    GT_BOOL        daNrlEn;
+    GT_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        bktRateFactor;
+    GT_U32        bktIncrement;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_BOOL        priORpt;
+    GT_U32        priMask;
+    GT_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
 } GT_PIRL2_RESOURCE;
 
 
@@ -1679,92 +1695,92 @@ typedef struct
  *  Description: data structure for PIRL2 Bucket programing that is port based.
  *
  *  Fields:
- *		ingressRate   	- commited ingress rate in kbps.
- *						  64kbps ~ 1Mbps    : increments of 64kbps,
- *						  1Mbps ~ 100Mbps   : increments of 1Mbps, and
- *						  100Mbps ~ 200Mbps : increments of 10Mbps
- *						  Therefore, the valid values are:
- *								64, 128, 192, 256, 320, 384,..., 960,
- *								1000, 2000, 3000, 4000, ..., 100000,
- *								110000, 120000, 130000, ..., 200000.
- *		customSetup   	- custom ingress rate parameter setup. please refer to
- *						  GT_PIRL_CUSTOM_RATE_LIMIT structure.
+ *        ingressRate       - commited ingress rate in kbps.
+ *                          64kbps ~ 1Mbps    : increments of 64kbps,
+ *                          1Mbps ~ 100Mbps   : increments of 1Mbps, and
+ *                          100Mbps ~ 200Mbps : increments of 10Mbps
+ *                          Therefore, the valid values are:
+ *                                64, 128, 192, 256, 320, 384,..., 960,
+ *                                1000, 2000, 3000, 4000, ..., 100000,
+ *                                110000, 120000, 130000, ..., 200000.
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_RATE_LIMIT structure.
  *      accountQConf    - account discarded frames due to queue congestion
  *      accountFiltered - account filtered frames
- *      mgmtNrlEn 		- exclude management frame from ingress rate limiting calculation
- *      saNrlEn 		- exclude from ingress rate limiting calculation if the SA of the
- *						  frame is in ATU with EntryState that indicates Non Rate Limited.
- *      daNrlEn 		- exclude from ingress rate limiting calculation if the DA of the
- *						  frame is in ATU with EntryState that indicates Non Rate Limited.
- *		samplingMode	- sample one out of so many frames/bytes for a stream of frames
- *		actionMode		- action should be taken when there are not enough tokens
- *						  to accept the entire incoming frame
- *								PIRL_ACTION_ACCEPT - accept the frame
- *								PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
- *		ebsLimitAction 	- action should be taken when the incoming rate exceeds
- *						  the limit.
- *								ESB_LIMIT_ACTION_DROP - drop packets
- *								ESB_LIMIT_ACTION_FC   - send flow control packet
- *		fcDeassertMode	- flow control de-assertion mode when limitAction is
- *						  set to ESB_LIMIT_ACTION_FC.
- *								GT_PIRL_FC_DEASSERT_EMPTY -
- *									De-assert when the ingress rate resource has 
- *									become empty.
- *								GT_PIRL_FC_DEASSERT_CBS_LIMIT -
- *									De-assert when the ingress rate resource has 
- *									enough room as specified by the CBSLimit.
- *		bktRateType		- bucket is either rate based or traffic type based.
- *								BUCKET_TYPE_RATE_BASED, or
- *								BUCKET_TYPE_TRAFFIC_BASED
+ *      mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *      saNrlEn         - exclude from ingress rate limiting calculation if the SA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *      daNrlEn         - exclude from ingress rate limiting calculation if the DA of the
+ *                          frame is in ATU with EntryState that indicates Non Rate Limited.
+ *        samplingMode    - sample one out of so many frames/bytes for a stream of frames
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *        ebsLimitAction     - action should be taken when the incoming rate exceeds
+ *                          the limit.
+ *                                ESB_LIMIT_ACTION_DROP - drop packets
+ *                                ESB_LIMIT_ACTION_FC   - send flow control packet
+ *        fcDeassertMode    - flow control de-assertion mode when limitAction is
+ *                          set to ESB_LIMIT_ACTION_FC.
+ *                                GT_PIRL_FC_DEASSERT_EMPTY -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    become empty.
+ *                                GT_PIRL_FC_DEASSERT_CBS_LIMIT -
+ *                                    De-assert when the ingress rate resource has 
+ *                                    enough room as specified by the CBSLimit.
+ *        bktRateType        - bucket is either rate based or traffic type based.
+ *                                BUCKET_TYPE_RATE_BASED, or
+ *                                BUCKET_TYPE_TRAFFIC_BASED
  *      priORpt         - determine the incoming frames that get rate limited using
- *						  this ingress rate resource.
- *						  		GT_TRUE - typeMask OR priMask
- *						  		GT_FALSE - typeMask AND priMask
- *		priMask         - priority bit mask that each bit indicates one of the four
- *						  queue priorities. Setting each one of these bits indicates
- *						  that this particular rate resource is slated to account for
- *						  incoming frames with the enabled bits' priority.
- *		bktTypeMask		- used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
- *						  any combination of the following definitions:
- *								BUCKET_TRAFFIC_UNKNOWN_UNICAST,
- *								BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
- *								BUCKET_TRAFFIC_BROADCAST,
- *								BUCKET_TRAFFIC_MULTICAST,
- *								BUCKET_TRAFFIC_UNICAST,
- *								BUCKET_TRAFFIC_MGMT_FRAME,
- *								BUCKET_TRAFFIC_ARP,
- *								BUCKET_TRAFFIC_TCP_DATA,
- *								BUCKET_TRAFFIC_TCP_CTRL,
- *								BUCKET_TRAFFIC_UDP,
- *								BUCKET_TRAFFIC_NON_TCPUDP,
- *								BUCKET_TRAFFIC_IMS,
- *								BUCKET_TRAFFIC_POLICY_MIRROR, and
- *								BUCKET_TRAFFIC_PLICY_TRAP
- *		byteTobeCounted	- bytes to be counted for accounting
- *								GT_PIRL2_COUNT_FRAME,
- *								GT_PIRL2_COUNT_ALL_LAYER1,
- *								GT_PIRL2_COUNT_ALL_LAYER2, or
- *								GT_PIRL2_COUNT_ALL_LAYER3
+ *                          this ingress rate resource.
+ *                                  GT_TRUE - typeMask OR priMask
+ *                                  GT_FALSE - typeMask AND priMask
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
+ *        bktTypeMask        - used if bktRateType is BUCKET_TYPE_TRAFFIC_BASED. 
+ *                          any combination of the following definitions:
+ *                                BUCKET_TRAFFIC_UNKNOWN_UNICAST,
+ *                                BUCKET_TRAFFIC_UNKNOWN_MULTICAST,
+ *                                BUCKET_TRAFFIC_BROADCAST,
+ *                                BUCKET_TRAFFIC_MULTICAST,
+ *                                BUCKET_TRAFFIC_UNICAST,
+ *                                BUCKET_TRAFFIC_MGMT_FRAME,
+ *                                BUCKET_TRAFFIC_ARP,
+ *                                BUCKET_TRAFFIC_TCP_DATA,
+ *                                BUCKET_TRAFFIC_TCP_CTRL,
+ *                                BUCKET_TRAFFIC_UDP,
+ *                                BUCKET_TRAFFIC_NON_TCPUDP,
+ *                                BUCKET_TRAFFIC_IMS,
+ *                                BUCKET_TRAFFIC_POLICY_MIRROR, and
+ *                                BUCKET_TRAFFIC_PLICY_TRAP
+ *        byteTobeCounted    - bytes to be counted for accounting
+ *                                GT_PIRL2_COUNT_FRAME,
+ *                                GT_PIRL2_COUNT_ALL_LAYER1,
+ *                                GT_PIRL2_COUNT_ALL_LAYER2, or
+ *                                GT_PIRL2_COUNT_ALL_LAYER3
  *
  */
 typedef struct
 {
-	GT_U32		ingressRate;
-	GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
-	GT_BOOL		accountQConf;
-	GT_BOOL		accountFiltered;
-	GT_BOOL		mgmtNrlEn;
-	GT_BOOL		saNrlEn;
-	GT_BOOL		daNrlEn;
-	GT_BOOL		samplingMode;
-	GT_PIRL_ACTION	actionMode;
-	GT_ESB_LIMIT_ACTION ebsLimitAction;
-	GT_PIRL_FC_DEASSERT fcDeassertMode;
-	GT_BUCKET_RATE_TYPE	bktRateType;
-	GT_BOOL		priORpt;
-	GT_U32		priMask;
-	GT_U32		bktTypeMask;
-	GT_PIRL2_COUNT_MODE	byteTobeCounted;
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_RATE_LIMIT customSetup;
+    GT_BOOL        accountQConf;
+    GT_BOOL        accountFiltered;
+    GT_BOOL        mgmtNrlEn;
+    GT_BOOL        saNrlEn;
+    GT_BOOL        daNrlEn;
+    GT_BOOL        samplingMode;
+    GT_PIRL_ACTION    actionMode;
+    GT_ESB_LIMIT_ACTION ebsLimitAction;
+    GT_PIRL_FC_DEASSERT fcDeassertMode;
+    GT_BUCKET_RATE_TYPE    bktRateType;
+    GT_BOOL        priORpt;
+    GT_U32        priMask;
+    GT_U32        bktTypeMask;
+    GT_PIRL2_COUNT_MODE    byteTobeCounted;
 } GT_PIRL2_DATA;
 
 
@@ -1773,38 +1789,38 @@ typedef struct
  *  typedef: struct GT_PIRL_CUSTOM_TSM_CFG
  *
  *  Description: The parameters that decides Ingress Rate Limit for AVB frames vary 
- * 				depending on the application. Since DSDT driver cannot cover all the cases,
- *				this structure is provided for the custom parameter setting.
- *				However, in most cases, user may ingore this structure by setting
- *				isValid to GT_FALSE. If Ingress Rate Limit is too much off from
- *				the expected rate, please contact FAE and gets the correct ebsLimit,
- *				cbsLimit, CTS interval, and action mode value and use this structure 
- *				to do custom parameter setting.
- *
- *		isValid         - If GT_TRUE, the paramers in this structure are used 
- *						  to program PIRL Resource's Rate Limit. And ingressRate
- *						  in GT_PIRL_TSM_DATA structure are ignored.
- *						  If GT_FALSE, ingressRate in GT_PIRL_TSM_DATA structure 
- *						  is used for Resource's Rate Limit.
- *		ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
- *		cbsLimit		- Committed Burst Size limit (0 ~ 0xFFFF)
- *		ctsIntv         - Class Time Slot Interval
- *						  0 - interval is 62.5us
- *						  1 - interval is 125us
- *						  2 - interval is 250us
- *						  3 - interval is 1000us
- *		actionMode		- action should be taken when there are not enough tokens
- *						  to accept the entire incoming frame
- *								PIRL_ACTION_ACCEPT - accept the frame
- *								PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *                 depending on the application. Since DSDT driver cannot cover all the cases,
+ *                this structure is provided for the custom parameter setting.
+ *                However, in most cases, user may ingore this structure by setting
+ *                isValid to GT_FALSE. If Ingress Rate Limit is too much off from
+ *                the expected rate, please contact FAE and gets the correct ebsLimit,
+ *                cbsLimit, CTS interval, and action mode value and use this structure 
+ *                to do custom parameter setting.
+ *
+ *        isValid         - If GT_TRUE, the paramers in this structure are used 
+ *                          to program PIRL Resource's Rate Limit. And ingressRate
+ *                          in GT_PIRL_TSM_DATA structure are ignored.
+ *                          If GT_FALSE, ingressRate in GT_PIRL_TSM_DATA structure 
+ *                          is used for Resource's Rate Limit.
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
 */
 typedef struct
 {
-	GT_BOOL		isValid;
-	GT_U32		ebsLimit;
-	GT_U32		cbsLimit;
-	GT_U32		ctsIntv;
-	GT_PIRL_ACTION		actionMode;
+    GT_BOOL        isValid;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
 } GT_PIRL_CUSTOM_TSM_CFG;
 
 
@@ -1814,33 +1830,33 @@ typedef struct
  *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
  *
  *  Fields:
- *		ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
- *		cbsLimit		- Committed Burst Size limit (0 ~ 0xFFFF)
- *		ctsIntv         - Class Time Slot Interval
- *						  0 - interval is 62.5us
- *						  1 - interval is 125us
- *						  2 - interval is 250us
- *						  3 - interval is 1000us
- *		actionMode		- action should be taken when there are not enough tokens
- *						  to accept the entire incoming frame
- *								PIRL_ACTION_ACCEPT - accept the frame
- *								PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
- * 		mgmtNrlEn 		- exclude management frame from ingress rate limiting calculation
- *		priMask         - priority bit mask that each bit indicates one of the four
- *						  queue priorities. Setting each one of these bits indicates
- *						  that this particular rate resource is slated to account for
- *						  incoming frames with the enabled bits' priority.
+ *        ebsLimit        - Excess Burst Size limit (0 ~ 0xFFFF)
+ *        cbsLimit        - Committed Burst Size limit (0 ~ 0xFFFF)
+ *        ctsIntv         - Class Time Slot Interval
+ *                          0 - interval is 62.5us
+ *                          1 - interval is 125us
+ *                          2 - interval is 250us
+ *                          3 - interval is 1000us
+ *        actionMode        - action should be taken when there are not enough tokens
+ *                          to accept the entire incoming frame
+ *                                PIRL_ACTION_ACCEPT - accept the frame
+ *                                PIRL_ACTION_USE_LIMIT_ACTION - use limitAction
+ *         mgmtNrlEn         - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
  *
  */
 typedef struct
 {
-	GT_BOOL		tsmMode;
-	GT_U32		ebsLimit;
-	GT_U32		cbsLimit;
-	GT_U32		ctsIntv;
-	GT_PIRL_ACTION		actionMode;
-	GT_BOOL		mgmtNrlEn;
-	GT_U32		priMask;
+    GT_BOOL        tsmMode;
+    GT_U32        ebsLimit;
+    GT_U32        cbsLimit;
+    GT_U32        ctsIntv;
+    GT_PIRL_ACTION        actionMode;
+    GT_BOOL        mgmtNrlEn;
+    GT_U32        priMask;
 } GT_PIRL2_TSM_RESOURCE;
 
 
@@ -1851,30 +1867,31 @@ typedef struct
  *  Description: data structure for PIRL2 TSM Ingress Rate Limit.
  *
  *  Fields:
- *		tsmMode			- enable/disable TSM mode. 
- *						  The following fields are ignored if diable
- *		ingressRate   	- commited ingress rate in kbps.(min 64 for 64kbps)
- *		customSetup   	- custom ingress rate parameter setup. please refer to
- *						  GT_PIRL_CUSTOM_TSM_CFG structure.
- *		mgmtNrlEn		- exclude management frame from ingress rate limiting calculation
- *		priMask         - priority bit mask that each bit indicates one of the four
- *						  queue priorities. Setting each one of these bits indicates
- *						  that this particular rate resource is slated to account for
- *						  incoming frames with the enabled bits' priority.
+ *        tsmMode            - enable/disable TSM mode. 
+ *                          The following fields are ignored if diable
+ *        ingressRate       - commited ingress rate in kbps.(min 64 for 64kbps)
+ *        customSetup       - custom ingress rate parameter setup. please refer to
+ *                          GT_PIRL_CUSTOM_TSM_CFG structure.
+ *        mgmtNrlEn        - exclude management frame from ingress rate limiting calculation
+ *        priMask         - priority bit mask that each bit indicates one of the four
+ *                          queue priorities. Setting each one of these bits indicates
+ *                          that this particular rate resource is slated to account for
+ *                          incoming frames with the enabled bits' priority.
  *
  */
 typedef struct
 {
-	GT_BOOL		tsmMode;
-	GT_U32		ingressRate;
-	GT_PIRL_CUSTOM_TSM_CFG customSetup;
-	GT_BOOL		mgmtNrlEn;
-	GT_U32		priMask;
+    GT_BOOL        tsmMode;
+    GT_U32        ingressRate;
+    GT_PIRL_CUSTOM_TSM_CFG customSetup;
+    GT_BOOL        mgmtNrlEn;
+    GT_U32        priMask;
 } GT_PIRL2_TSM_DATA;
 
 
 
-#define MAX_PTP_CONSECUTIVE_READ	4
+#define MAX_PTP_CONSECUTIVE_READ    4
+
 
 /*
  * Typedef: enum GT_PTP_OPERATION
@@ -1882,18 +1899,18 @@ typedef struct
  * Description: Defines the PTP (Precise Time Protocol) Operation type
  *
  * Fields:
- *      PTP_WRITE_DATA 			- Write data to the PTP register
- *      PTP_READ_DATA			- Read data from PTP register
- *      PTP_READ_MULTIPLE_DATA	- Read multiple data from PTP register
- *      PTP_READ_TIMESTAMP_DATA	- Read timestamp data from PTP register
- *					valid bit will be reset after read
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
+ *      PTP_READ_TIMESTAMP_DATA    - Read timestamp data from PTP register
+ *                    valid bit will be reset after read
  */
 typedef enum
 {
-	PTP_WRITE_DATA 			= 0x3,
-	PTP_READ_DATA  			= 0x4,
-	PTP_READ_MULTIPLE_DATA	= 0x6,
-	PTP_READ_TIMESTAMP_DATA	= 0x8,
+    PTP_WRITE_DATA             = 0x3,
+    PTP_READ_DATA              = 0x4,
+    PTP_READ_MULTIPLE_DATA    = 0x6,
+    PTP_READ_TIMESTAMP_DATA    = 0x8,
 } GT_PTP_OPERATION;
 
 
@@ -1903,13 +1920,13 @@ typedef enum
  * Description: Defines the PTP (Precise Time Protocol) SPEC type
  *
  * Fields:
- *      PTP_IEEE_1588 		- IEEE 1588
- *      PTP_IEEE_802_1AS	- IEEE 802.1as
+ *      PTP_IEEE_1588         - IEEE 1588
+ *      PTP_IEEE_802_1AS    - IEEE 802.1as
  */
 typedef enum
 {
-	PTP_IEEE_1588		= 0x0,
-	PTP_IEEE_802_1AS	= 0x1
+    PTP_IEEE_1588        = 0x0,
+    PTP_IEEE_802_1AS    = 0x1
 } GT_PTP_SPEC;
 
 
@@ -1919,95 +1936,100 @@ typedef enum
  *  Description: data required by PTP Operation
  *
  *  Fields:
- *      ptpPort		- physical port of the device
- *      ptpAddr 	- register address
- *      ptpData 	- data for ptp register.
+ *      ptpPort        - physical port of the device
+ *      ptpAddr     - register address
+ *      ptpData     - data for ptp register.
  *      ptpMultiData- used for multiple read operation.
- *      nData 		- number of data to be read on multiple read operation.
+ *      nData         - number of data to be read on multiple read operation.
  */
 typedef struct
 {
-	GT_U32	ptpPort;
-	GT_U32	ptpBlock;
-	GT_U32	ptpAddr;
-	GT_U32	ptpData;
-	GT_U32	ptpMultiData[MAX_PTP_CONSECUTIVE_READ];
-	GT_U32	nData;
+    GT_U32    ptpPort;
+    GT_U32    ptpBlock;
+    GT_U32    ptpAddr;
+    GT_U32    ptpData;
+    GT_U32    ptpMultiData[MAX_PTP_CONSECUTIVE_READ];
+    GT_U32    nData;
 } GT_PTP_OP_DATA;
 
 
+
 /*
- *  typedef: struct GT_PTP_CONFIG
+ *  typedef: struct GT_PTP_GLOBAL_CONFIG
  *
- *  Description: PTP configuration parameters
+ *  Description: PTP global configuration parameters
  *
  *  Fields:
- *      ptpEType	- PTP Ether Type
- *      msgIdTSEn 	- Message IDs that needs time stamp
- *      tsArrPtr 	- Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
- *      ptpArrIntEn	- PTP port arrival interrupt enable
- *      ptpDepIntEn	- PTP port departure interrupt enable
- *      transSpec	- This is to differentiate between various timing protocols.
- *      msgIdStartBit 	- Message ID starting bit in the PTP common header
- *      disTSOverwrite 	- disable time stamp counter overwriting until the corresponding
- *						  timer valid bit is cleared.
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
  */
 typedef struct
 {
-	GT_U32	ptpEType;
-	GT_U32	msgIdTSEn;
-	GT_U32	tsArrPtr;
-	GT_U32	ptpArrIntEn;
-	GT_U32	ptpDepIntEn;
-	GT_PTP_SPEC	transSpec;
-	GT_U32	msgIdStartBit;
-	GT_BOOL	disTSOverwrite;
-} GT_PTP_CONFIG;
+    GT_U32    ptpEType;
+    GT_U32    msgIdTSEn;
+    GT_U32    tsArrPtr;
+} GT_PTP_GLOBAL_CONFIG;
 
 
 /*
- *  typedef: struct GT_PTP_GLOBAL_CONFIG
+ *  typedef: struct GT_PTP_PORT_CONFIG
  *
- *  Description: PTP global configuration parameters
+ *  Description: PTP configuration parameters for each port
  *
  *  Fields:
- *      ptpEType	- PTP Ether Type
- *      msgIdTSEn 	- Message IDs that needs time stamp
- *      tsArrPtr 	- Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      disTSpec     - Disable Transport specific check
+ *      etJump         - offset to Ether type start address in bytes
+ *      ipJump         - offset to IP header start address counting from Ether type offset
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      disTSOverwrite - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      arrTSMode      - PTP arrival TS mode.
  */
 typedef struct
 {
-	GT_U32	ptpEType;
-	GT_U32	msgIdTSEn;
-	GT_U32	tsArrPtr;
-} GT_PTP_GLOBAL_CONFIG;
-
+    GT_PTP_SPEC    transSpec;
+    GT_BOOL        disTSpec;
+    GT_U32         etJump;
+    GT_U32         ipJump;
+    GT_BOOL        ptpArrIntEn;
+    GT_BOOL        ptpDepIntEn;
+    GT_BOOL        disTSOverwrite;
+	GT_U32         arrTSMode;
+} GT_PTP_PORT_CONFIG;
 
 /*
- *  typedef: struct GT_PTP_PORT_CONFIG
+ *  typedef: struct GT_PTP_CONFIG
  *
- *  Description: PTP configuration parameters for each port
+ *  Description: PTP configuration parameters
  *
  *  Fields:
- *      transSpec	- This is to differentiate between various timing protocols.
- *      disTSpec 	- Disable Transport specific check
- *      etJump 		- offset to Ether type start address in bytes
- *      ipJump 		- offset to IP header start address counting from Ether type offset
- *      ptpArrIntEn	- PTP port arrival interrupt enable
- *      ptpDepIntEn	- PTP port departure interrupt enable
- *      disTSOverwrite 	- disable time stamp counter overwriting until the corresponding
- *						  timer valid bit is cleared.
+ *      ptpEType    - PTP Ether Type
+ *      msgIdTSEn     - Message IDs that needs time stamp
+ *      tsArrPtr     - Time stamp arrival time counter pointer (either Arr0Time or Arr1Time)
+ *      ptpArrIntEn    - PTP port arrival interrupt enable
+ *      ptpDepIntEn    - PTP port departure interrupt enable
+ *      transSpec    - This is to differentiate between various timing protocols.
+ *      msgIdStartBit     - Message ID starting bit in the PTP common header
+ *      disTSOverwrite     - disable time stamp counter overwriting until the corresponding
+ *                          timer valid bit is cleared.
+ *      ptpPortConfig      - PTP port configuration array.
  */
 typedef struct
 {
-	GT_PTP_SPEC	transSpec;
-	GT_BOOL	disTSpec;
-	GT_U32	etJump;
-	GT_U32	ipJump;
-	GT_BOOL	ptpArrIntEn;
-	GT_BOOL	ptpDepIntEn;
-	GT_BOOL	disTSOverwrite;
-} GT_PTP_PORT_CONFIG;
+    GT_U32    ptpEType;
+    GT_U32    msgIdTSEn;
+    GT_U32    tsArrPtr;
+
+    GT_U32    ptpArrIntEn;
+    GT_U32    ptpDepIntEn;
+    GT_PTP_SPEC    transSpec;
+    GT_U32    msgIdStartBit;
+    GT_BOOL    disTSOverwrite;
+	GT_PTP_PORT_CONFIG      ptpPortConfig[MAX_SWITCH_PORTS];
+} GT_PTP_CONFIG;
 
 
 /*
@@ -2016,15 +2038,15 @@ typedef struct
  * Description: Defines the PTP Time to be read
  *
  * Fields:
- *      PTP_WRITE_DATA 			- Write data to the PTP register
- *      PTP_READ_DATA			- Read data from PTP register
- *      PTP_READ_MULTIPLE_DATA	- Read multiple data from PTP register
+ *      PTP_WRITE_DATA             - Write data to the PTP register
+ *      PTP_READ_DATA            - Read data from PTP register
+ *      PTP_READ_MULTIPLE_DATA    - Read multiple data from PTP register
  */
 typedef enum
 {
-	PTP_ARR0_TIME = 0x0,
-	PTP_ARR1_TIME = 0x1,
-	PTP_DEP_TIME = 0x2
+    PTP_ARR0_TIME = 0x0,
+    PTP_ARR1_TIME = 0x1,
+    PTP_DEP_TIME = 0x2
 } GT_PTP_TIME;
 
 
@@ -2034,20 +2056,20 @@ typedef enum
  * Description: Defines the PTP Port interrupt status for time stamp
  *
  * Fields:
- *      PTP_INT_NORMAL		- No error condition occurred
- *      PTP_INT_OVERWRITE 	- PTP logic has to process more than one PTP frame
- *						  		that needs time stamping before the current read.
- *								Only the latest one is saved.
- *      PTP_INT_DROP	  	- PTP logic has to process more than one PTP frame
- *						  		that needs time stamping before the current read.
- *								Only the oldest one is saved.
+ *      PTP_INT_NORMAL        - No error condition occurred
+ *      PTP_INT_OVERWRITE     - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the latest one is saved.
+ *      PTP_INT_DROP          - PTP logic has to process more than one PTP frame
+ *                                  that needs time stamping before the current read.
+ *                                Only the oldest one is saved.
  *
  */
 typedef enum
 {
-	PTP_INT_NORMAL 		= 0x0,
-	PTP_INT_OVERWRITE 	= 0x1,
-	PTP_INT_DROP 		= 0x2
+    PTP_INT_NORMAL         = 0x0,
+    PTP_INT_OVERWRITE     = 0x1,
+    PTP_INT_DROP         = 0x2
 } GT_PTP_INT_STATUS;
 
 
@@ -2057,17 +2079,17 @@ typedef enum
  *  Description: PTP port status of time stamp
  *
  *  Fields:
- *      isValid		- time stamp is valid
- *      status		- time stamp error status
- *      timeStamped	- time stamp value of a PTP frame that needs to be time stamped
- *      ptpSeqId	- sequence ID of the frame whose time stamp information has been captured
+ *      isValid        - time stamp is valid
+ *      status        - time stamp error status
+ *      timeStamped    - time stamp value of a PTP frame that needs to be time stamped
+ *      ptpSeqId    - sequence ID of the frame whose time stamp information has been captured
  */
 typedef struct
 {
-	GT_BOOL	isValid;
-	GT_U32	timeStamped;
-	GT_U32	ptpSeqId;
-	GT_PTP_INT_STATUS	status;
+    GT_BOOL    isValid;
+    GT_U32    timeStamped;
+    GT_U32    ptpSeqId;
+    GT_PTP_INT_STATUS    status;
 } GT_PTP_TS_STATUS;
 
 
@@ -2077,52 +2099,64 @@ typedef struct
  *  Description: PTP port discard statistics. The counter (4 bit wide) wraps around after 15. 
  *
  *  Fields:
- *      tsDepDisCtr	- PTP departure frame discard counter for PTP frames that need time stamping.
- *      ntsDepDisCtr	- PTP departure frame discard counter for PTP frames that do not need time stamping.
- *      tsArrDisCtr	- PTP arrival frame discard counter for PTP frames that need time stamping.
- *      ntsArrDisCtr	- PTP arrival frame discard counter for PTP frames that do not need time stamping.
+ *      tsDepDisCtr    - PTP departure frame discard counter for PTP frames that need time stamping.
+ *      ntsDepDisCtr    - PTP departure frame discard counter for PTP frames that do not need time stamping.
+ *      tsArrDisCtr    - PTP arrival frame discard counter for PTP frames that need time stamping.
+ *      ntsArrDisCtr    - PTP arrival frame discard counter for PTP frames that do not need time stamping.
  */
 typedef struct
 {
-	GT_U32	tsDepDisCtr;
-	GT_U32	ntsDepDisCtr;
-	GT_U32	tsArrDisCtr;
-	GT_U32	ntsArrDisCtr;
+    GT_U32    tsDepDisCtr;
+    GT_U32    ntsDepDisCtr;
+    GT_U32    tsArrDisCtr;
+    GT_U32    ntsArrDisCtr;
 } GT_PTP_PORT_DISCARD_STATS;
 
+/* From Agate, to add arrival TS mode, to insert TS into frame */
+typedef enum
+{
+    PTP_ARR_TS_MODE_DIABLE  = 0,   /* PTP Arrival mode: disable TS mode modification */
+    PTP_ARR_TS_MODE_FRM_END = 1,   /* PTP Arrival mode: TS at end of frame */
+    PTP_ARR_TS_MODE_LOC_5   = 4,   /* PTP Arrival mode: TS at offset 5 in common header */
+    PTP_ARR_TS_MODE_LOC_17  = 16,  /* PTP Arrival mode: TS at offset 17 in common header */
+    PTP_ARR_TS_MODE_LOC_35  = 34,  /* PTP Arrival mode: TS at offset 35 in common header */
+    PTP_ARR_TS_MODE_LOC_ff         /* PTP Arrival mode: TS at the end of the frame */
+} GT_PTP_ARR_TS_MODE;
+
+
 
 #ifdef CONFIG_AVB_FPGA
 
 typedef enum
 {
-	PTP_CLOCK_SRC_AD_DEVICE = 0,	/* PTP Clock source is from A/D device */
-	PTP_CLOCK_SRC_FPGA				/* PTP Clock source is from Cesium FPGA */
+    PTP_CLOCK_SRC_AD_DEVICE = 0,    /* PTP Clock source is from A/D device */
+    PTP_CLOCK_SRC_FPGA                /* PTP Clock source is from Cesium FPGA */
 } GT_PTP_CLOCK_SRC;
 
 typedef enum
 {
-	PTP_P9_MODE_GMII = 0, 	/* Port 9 uses GMII connect to 88E1111 */
-	PTP_P9_MODE_MII,		/* Port 9 uses MII connect to 88E1111 */
-	PTP_P9_MODE_MII_CONNECTOR,		/* Port 9 connect to MII connector */
-	PTP_P9_MODE_JUMPER		/* Use Jumper setup */
+    PTP_P9_MODE_GMII = 0,     /* Port 9 uses GMII connect to 88E1111 */
+    PTP_P9_MODE_MII,        /* Port 9 uses MII connect to 88E1111 */
+    PTP_P9_MODE_MII_CONNECTOR,        /* Port 9 connect to MII connector */
+    PTP_P9_MODE_JUMPER        /* Use Jumper setup */
 } GT_PTP_P9_MODE;
 
 typedef enum
 {
-	GT_PTP_SIGN_NEGATIVE = 0,	/* apply Minus sign to the Duty Cycle */
-	GT_PTP_SIGN_PLUS			/* apply Plus sign to the Duty Cycle */
+    GT_PTP_SIGN_NEGATIVE = 0,    /* apply Minus sign to the Duty Cycle */
+    GT_PTP_SIGN_PLUS            /* apply Plus sign to the Duty Cycle */
 } GT_PTP_SIGN;
 
 typedef struct
 {
-	GT_PTP_SIGN	adjSign;	/* determine the plus/minus sign of the duty cycle adj */
-	GT_U32	cycleStep;		/* number of steps which will be applied in adjusting the duty cycle high time 
-								of the 8KHz clock cycle. 
-								valid values are 0 ~ 7 */
-	GT_U32	cycleInterval;	/* define the interval of clock cycles for which a duty cycle adj will occur */
-	GT_U32	cycleAdjust;	/* define the number of 8KHz clock cycles for which duty cycle adj will occur
-								within each PTP clock clycle interval.
-								Note that (cycleAdjust <= cycleInterval) for proper operation */
+    GT_PTP_SIGN    adjSign;    /* determine the plus/minus sign of the duty cycle adj */
+    GT_U32    cycleStep;        /* number of steps which will be applied in adjusting the duty cycle high time 
+                                of the 8KHz clock cycle. 
+                                valid values are 0 ~ 7 */
+    GT_U32    cycleInterval;    /* define the interval of clock cycles for which a duty cycle adj will occur */
+    GT_U32    cycleAdjust;    /* define the number of 8KHz clock cycles for which duty cycle adj will occur
+                                within each PTP clock clycle interval.
+                                Note that (cycleAdjust <= cycleInterval) for proper operation */
 } GT_PTP_CLOCK_ADJUSTMENT;
 
 #endif
@@ -2133,15 +2167,19 @@ typedef struct
  *  Description: TAI event capture configuration parameters
  *
  *  Fields:
- *      eventOverwrite	- event capture overwrite
- *      eventCtrStart	 	- event counter start
- *      intEn 			- event capture interrupt enable
+ *      eventOverwrite    - event capture overwrite
+ *      eventCtrStart     - event counter start
+ *      eventPhase        - event phase, When 0x1 the active phase of the PTP_EVREQ input 
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_EVREQ input 
+ *        is normal activehigh
+ *      intEn             - event capture interrupt enable
  */
 typedef struct
 {
-	GT_BOOL	eventOverwrite;
-	GT_BOOL	eventCtrStart;
-	GT_BOOL	intEn;
+    GT_BOOL    eventOverwrite;
+    GT_BOOL    eventCtrStart;
+    GT_BOOL    eventPhase;
+    GT_BOOL    intEn;
 } GT_TAI_EVENT_CONFIG;
 
 
@@ -2151,27 +2189,58 @@ typedef struct
  *  Description: TAI event capture status
  *
  *  Fields:
- *      isValid		- eventTime is valid
- *      eventTime 	- PTP global time when event is registered.
- *      eventCtr	- event capture counter. increamented only if eventCtrStart is set.
- *      eventErr	- isValid is already set when a new event is observed.
+ *      isValid        - eventTime is valid
+ *      eventTime     - PTP global time when event is registered.
+ *      eventCtr    - event capture counter. increamented only if eventCtrStart is set.
+ *      eventErr    - isValid is already set when a new event is observed.
  */
 typedef struct
 {
-	GT_BOOL	isValid;
-	GT_U32	eventTime;
-	GT_U32	eventCtr;
-	GT_BOOL	eventErr;
+    GT_BOOL    isValid;
+    GT_U32    eventTime;
+    GT_U32    eventCtr;
+    GT_BOOL    eventErr;
 } GT_TAI_EVENT_STATUS;
 
 
 typedef enum
 {
-	GT_TAI_TRIG_PERIODIC_PURSE = 0,	/* generate periodic purse */
-	GT_TAI_TRIG_ON_GIVEN_TIME		/* generate purse when 
-									PTP global time matches with given time */
+    GT_TAI_TRIG_PERIODIC_PURSE = 0,    /* generate periodic purse */
+    GT_TAI_TRIG_ON_GIVEN_TIME        /* generate purse when 
+                                    PTP global time matches with given time */
 } GT_TAI_TRIG_MODE;
 
+typedef enum
+{
+    GT_TAI_MULTI_PTP_SYNC_DISABLE = 0,  /* the EventRequest and TriggerGen interfaces operate normally. */
+    GT_TAI_MULTI_PTP_SYNC_ENABLE        /* the logic detects a low to high transition on 
+										the EventRequest (GPIO) and transfers the value 
+										in TrigGenAmt[31:0] (TAI Global Config 0x2, 0x3) into 
+										the PTP Global Time register[31:0]. The EventCapTime[31:0]
+										(TAI global Status 0xA, 0xB) is also updated at that 
+										instant. */
+} GT_TAI_MULTI_PTP_SYNC_MODE;
+
+
+/*
+ *  typedef: struct GT_TAI_CLOCK_SELECT
+ *
+ *  Description: TAI Clock select
+ *
+ *  Fields:
+ *      priRecClkSel      - Synchronous Ethernet Primary Recovered Clock Select.
+ *        This field indicates the internal PHY number whose recovered clock will be
+ *        presented on the SE_RCLK0 pin. The reset value of 0x7 selects no clock and
+ *        the pin is tri-stated.
+ *      syncRecClkSel     - Synchronous Ethernet Secondary Recovered Clock Select.
+ *      ptpExtClk         - PTP external Clock select
+ */
+typedef struct
+{
+    GT_U8    priRecClkSel;
+    GT_U8    syncRecClkSel;
+    GT_BOOL  ptpExtClk;
+} GT_TAI_CLOCK_SELECT;
 
 /*
  *  typedef: struct GT_TAI_TRIGGER_CONFIG
@@ -2179,55 +2248,61 @@ typedef enum
  *  Description: TAI trigger generator configuration parameters
  *
  *  Fields:
- *      intEn 		- trigger generator interrupt enable
- *      mode		- trigger mode, either GT_TAI_TRIG_PERIODIC_PURSE or 
- *					  GT_TAI_TRIG_ON_GIVEN_TIME
- *      trigGenAmt 	- if mode is GT_TAI_TRIG_PERIODIC_PURSE,
- *					  this value is used as a clock period in TSClkPer increments
- *					  If mode is GT_TAI_TRIG_ON_GIVEN_TIME,
- *					  this value is used to compare with PTP global time.
- *      pulseWidth		- pulse width in units of TSClkPer.
- *					  this value should be 1 ~ 0xF. If it's 0, no changes made.
- *					  this value is valid only in GT_TAI_TRIG_ON_GIVEN_TIME mode.
- *      trigClkComp	- trigger mode clock compensation amount in pico sec.
- *					  this value is valid only in GT_TAI_TRIG_PERIODIC_PURSE mode.
+ *      intEn         - trigger generator interrupt enable
+ *      trigPhase     - trigger phase, When 0x1 the active phase of the PTP_TRIG output 
+ *        is inverted to be active low. When 0x0 the active phase of the PTP_TRIG output 
+ *        is normal active high.
+ *      mode        - trigger mode, either GT_TAI_TRIG_PERIODIC_PURSE or 
+ *                      GT_TAI_TRIG_ON_GIVEN_TIME
+ *      trigGenAmt     - if mode is GT_TAI_TRIG_PERIODIC_PURSE,
+ *                      this value is used as a clock period in TSClkPer increments
+ *                      If mode is GT_TAI_TRIG_ON_GIVEN_TIME,
+ *                      this value is used to compare with PTP global time.
+ *      pulseWidth        - pulse width in units of TSClkPer.
+ *                      this value should be 1 ~ 0xF. If it's 0, no changes made.
+ *                      this value is valid only in GT_TAI_TRIG_ON_GIVEN_TIME mode.
+ *      trigClkComp    - trigger mode clock compensation amount in pico sec.
+ *                      this value is valid only in GT_TAI_TRIG_PERIODIC_PURSE mode.
  */
 typedef struct
 {
-	GT_BOOL	intEn;
-	GT_TAI_TRIG_MODE 	mode;
-	GT_U32	trigGenAmt;
-	GT_U32	pulseWidth;
-	GT_U32	trigClkComp;
+    GT_BOOL    intEn;
+    GT_BOOL    trigPhase;
+    GT_TAI_TRIG_MODE     mode;
+    GT_U32    trigGenAmt;
+    GT_U32    pulseWidth;
+    GT_U32    trigClkComp;
 } GT_TAI_TRIGGER_CONFIG;
 
 
+
+/* AVB functions */
 typedef enum
 {
-	GT_AVB_HI_FPRI,		/* AVB Hi Frame Priority */
-	GT_AVB_HI_QPRI,		/* AVB Hi Queue Priority */
-	GT_AVB_LO_FPRI,		/* AVB Lo Frame Priority */
-	GT_AVB_LO_QPRI,		/* AVB Lo Queue Priority */
-	GT_LEGACY_HI_FPRI,	/* Legacy Hi Frame Priority */
-	GT_LEGACY_HI_QPRI,	/* Legacy Hi Queue Priority */
-	GT_LEGACY_LO_FPRI,	/* Legacy Lo Frame Priority */
-	GT_LEGACY_LO_QPRI	/* Legacy Lo Queue Priority */
+    GT_AVB_HI_FPRI,        /* AVB Hi Frame Priority */
+    GT_AVB_HI_QPRI,        /* AVB Hi Queue Priority */
+    GT_AVB_LO_FPRI,        /* AVB Lo Frame Priority */
+    GT_AVB_LO_QPRI,        /* AVB Lo Queue Priority */
+    GT_LEGACY_HI_FPRI,    /* Legacy Hi Frame Priority */
+    GT_LEGACY_HI_QPRI,    /* Legacy Hi Queue Priority */
+    GT_LEGACY_LO_FPRI,    /* Legacy Lo Frame Priority */
+    GT_LEGACY_LO_QPRI    /* Legacy Lo Queue Priority */
 } GT_AVB_PRI_TYPE;
 
 
 typedef enum
 {
-	GT_AVB_LEGACY_MODE,			/* all frames entering the port are considered 
-									legacy */
-	GT_AVB_STANDARD_AVB_MODE,	/* any tagged frame that ends up with an AVB frame 
-									priority is considered AVB */
-	GT_AVB_ENHANCED_AVB_MODE,	/* any frame that ends up with an AVB frame priority 
-									whose DA is contained in the ATU with an AVB Entry 
-									state is considered AVB */
-	GT_AVB_SECURE_AVB_MODE		/* any frame that ends up with an AVB frame priority 
-									whose DA is contained in the ATU with an AVB 
-									entry state and whose DPV has this source port's 
-									bit set to a one is considered AVB. */
+    GT_AVB_LEGACY_MODE,            /* all frames entering the port are considered 
+                                    legacy */
+    GT_AVB_STANDARD_AVB_MODE,    /* any tagged frame that ends up with an AVB frame 
+                                    priority is considered AVB */
+    GT_AVB_ENHANCED_AVB_MODE,    /* any frame that ends up with an AVB frame priority 
+                                    whose DA is contained in the ATU with an AVB Entry 
+                                    state is considered AVB */
+    GT_AVB_SECURE_AVB_MODE        /* any frame that ends up with an AVB frame priority 
+                                    whose DA is contained in the ATU with an AVB 
+                                    entry state and whose DPV has this source port's 
+                                    bit set to a one is considered AVB. */
 } GT_AVB_MODE;
 
 
@@ -2244,9 +2319,9 @@ typedef enum
  */
 typedef enum
 {
-	AVB_FRAME_POLICY_NONE = 0,
-	AVB_FRAME_POLICY_MIRROR,
-	AVB_FRAME_POLICY_TRAP
+    AVB_FRAME_POLICY_NONE = 0,
+    AVB_FRAME_POLICY_MIRROR,
+    AVB_FRAME_POLICY_TRAP
 } GT_AVB_FRAME_POLICY;
 
 
@@ -2254,28 +2329,202 @@ typedef enum
  * Typedef: enum GT_AVB_FRAME_TYPE
  *
  * Description: 
- *		Defines the AVB frame type.
- *		AVB Hi Frame is one that DA of the frame is contained in the ATU with an 
- *		Entry State that indicates AVB with priority override where the overridden 
- *		priority equals the Hi AVB frame priority(refer to gavbGetPriority API) and 
- *		when the port's DA AvbOverride is enabled.
- *		AVB Lo Frame is one that DA of the frame is contained in the ATU with an 
- *		Entry State that indicates AVB with priority override where the overridden 
- *		priority equals the Lo AVB frame priority(refer to gavbGetPriority API) and 
- *		when the port's DA AvbOverride is enabled.
+ *        Defines the AVB frame type.
+ *        AVB Hi Frame is one that DA of the frame is contained in the ATU with an 
+ *        Entry State that indicates AVB with priority override where the overridden 
+ *        priority equals the Hi AVB frame priority(refer to gavbGetPriority API) and 
+ *        when the port's DA AvbOverride is enabled.
+ *        AVB Lo Frame is one that DA of the frame is contained in the ATU with an 
+ *        Entry State that indicates AVB with priority override where the overridden 
+ *        priority equals the Lo AVB frame priority(refer to gavbGetPriority API) and 
+ *        when the port's DA AvbOverride is enabled.
  *
  * Fields:
- *      AVB_HI_FRAME	- AVB Hi Frame
- *      AVB_LO_FRAME	- AVB Lo Frame
+ *      AVB_HI_FRAME    - AVB Hi Frame
+ *      AVB_LO_FRAME    - AVB Lo Frame
  */
 typedef enum
 {
-	AVB_HI_FRAME,
-	AVB_LO_FRAME
+    AVB_HI_FRAME,
+    AVB_LO_FRAME
 } GT_AVB_FRAME_TYPE;
 
 
 /*
+ * Typedef: enum GT_TCAM_OPERATION
+ *
+ * Description: Defines the TCAM (Ternary Content Addressable Memory) Operation type
+ *
+ * Fields:
+ *   TCAM_FLUSH_ALL       - Flush all entries
+ *   TCAM_FLUSH_ENTRY     - Flush or invalidate a single TCAM entry
+ *   TCAM_LOAD_ENTRY      - Load qn entry's page - or Purge an entry
+ *   TCAM_GET_NEXT_ENTRY  - Get Next (read next valid entry - all pages)
+ *   TCAM_READ_ENTRY      - Read an entry's page (perform a direct read of an entry)
+ */
+typedef enum
+{
+    TCAM_FLUSH_ALL       = 0x1,
+    TCAM_FLUSH_ENTRY     = 0x2,
+    TCAM_LOAD_ENTRY      = 0x3,
+    TCAM_PURGE_ENTRY     = 0x6,
+    TCAM_GET_NEXT_ENTRY  = 0x4,
+    TCAM_READ_ENTRY      = 0x5
+} GT_TCAM_OPERATION;
+
+typedef enum
+{
+    FRAME_TYPE_NORMAL  = 0,
+    FRAME_TYPE_DSA     = 1,
+    FRAME_TYPE_PROVIDE = 2,
+    FRAME_TYPE_RES = 3,
+} GT_FRAME_TYPE;
+
+/* The P3 register 31 work as follows in the following example sequence:
+o 0x00FF = Reset state, no hits yet
+o 0x0000 = 48-byte TCAM hit on Entry 0x00
+o 0x0201 = 96-byte TCAM hit on Entries 0x01 (low) and 0x02 (high)
+o 0x0003 = 48-byte TCAM hit on Entry 0x03
+o 0x0809 = 96-byte TCAM hit on Entries 0x09 (low) and 0x08 (high)
+o 0x0009 = 48-byte TCAM hit on Entry 0x09 with a TCAM miss on the high 48-bytes
+o 0x00FF = Miss on 1st 48 byte lookup
+*/
+typedef enum
+{
+    TCAM_HIT_RESET  = 0xFF,
+    TCAM_HIT_48_E0  = 0x00,
+    TCAM_HIT_96_E1  = 0x201,
+    TCAM_HIT_48_E3  = 0x03,
+    TCAM_HIT_96_E9  = 0x809,
+    TCAM_HIT_48_MISS  = 0x0FF,
+} GT_TCAM_HIT_STATUS;
+
+
+
+/*
+ *  typedef: struct GT_TCAM_DATA
+ *
+ *  Description: TCAM Key Data and Frame Match Data. 
+ *  The bytes are in the lower 8 bits of each 16-bit register. The upper 8 bits of
+ *  each register are the Mask bits for the lower 8 bits where bit 15 is the mask 
+ *  for bit 7, bit 14 is the mask for bit 6, etc. The individual pairs of data bits 
+ *  and mask bits work together as follows:
+ *    Mask Data Meaning
+ *      0 0 Dont Care. The data bit can be a one or a zero for a TCAM hit to occur.
+ *      1 0 Hit on 0. The data bit must be a zero for a TCAM hit to occur.
+ *      1 1 Hit on 1. The data bit must be a one for a TCAM hit to occur.
+ *      0 1 Never Hit. Used to prevent a TCAM hit from occurring from this entry.
+ *    The Never Hit value is used to Flush the TCAM or Purge a TCAM entry. 
+ *    On a TCAM Flush or Purge, this value it written to the 1st TCAM byte only 
+ *    (offset 0x02 on TCAM page 1). On a TCAM Flush All or on a TCAM Flush
+ *    an entry, all other TCAM data and mask bytes are written to a value of 0x0000 
+ *    and so are the Action bytes.
+ *
+ *  Fields:
+ *      frameType      - Frame Type. These bits are used to define the Frame type or mode 
+ *      frameTypeMask  - Frame Type Mask.  
+ *      spv      - Source Port Vector. These bits are used to define which switch ports 
+ *                 can use this TCAM entry. 
+ *      spvMask  - Source Port Vector Mask.  
+ *      ppri      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider Priority bits. 
+ *      ppriMask  - Provider Priority Mask.  
+ *      pvid      - When the TCAM entrys FrameMode bits are Provider Tagged, these bits are
+ *                  Provider VID bits.. 
+ *      pvidMask  - Provider VID Mask.  
+ *      frameOctet      - Frame Octet 1-48 or 49-96. These are the match data for octet 
+ *                        1-48 of the frame if the TCAM entry is for the first 48 bytes 
+ *                        of a frame. If this TCAM entry is for the second 48 bytes of 
+ *                        a frame this is the match data for octet 49 (or 97).
+ *      frameOctetMask  - Frame Octet Mask.  
+ *      continu  - Continue this TCAM entry. This bit should only be a 1 on TCAM entries 
+ *                that cover the first 48 bytes of a frame that needs to be extended to
+ *                also match bytes 49 to 96 of the frame or on any subsequent continuation
+ *                beyond byte 96 of the frame.
+ *      interrupt  - Interrupt on a TCAM hit. When this bit is set to a one on a TCAM entry 
+ *                   (where the Continue bit is a zero), a TCAM hit interrupt will be 
+ *                   generated whenever a match occurs to this entry.
+ *      IncTcamCtr   - Increment the ports TCAM Counter on a TCAM hit.
+ *      vidOverride  - VID Override Enable.
+ *      vidData    - VID Override Data.
+ *      nextId     - Next Index or Flow ID.
+ *      qpriOverride  - QPRI Override Enable.
+ *      qpriData      - QPRI Override Data.
+ *      fpriOverride  - FPRI Override Enable.
+ *      fpriData      - FPRI Override Data.
+ *      qpriAvbOverride  - QPRI_AVB Override Enable.
+ *      qpriAvbData      - QPRI_AVB Override Data.
+ *      dpvOverride  - DPV Override Enable.
+ *      dpvData      - DPV Override Data.
+ *      factionOverride  - Frame Action Override Enable.
+ *      factionData      - Frame Action Override Data.
+ *      ldBalanceOverride  - Load Balance Override Enable.
+ *      ldBalanceData      - Load Balance Override Data.
+ *      debugPort    - Debug Port Number.
+ *      highHit      - TCAM Entry for High 48-byte Hit..
+ *      lowHit       - TCAM Entry for High 48-byte Hit..
+*/
+
+
+typedef union
+/*typedef struct */
+{
+	GT_U8  frame[248];
+	struct _PARA {
+    GT_U8        frameType;
+    GT_U8        frameTypeMask;
+    GT_U8        spv;
+    GT_U8        spvMask;
+    GT_U8        ppri;
+    GT_U8        ppriMask;
+    GT_U16       pvid;
+    GT_U16       pvidMask;
+    GT_U8        frameOctet[48];
+    GT_U8        frameOctetMask[48];
+    GT_U8        continu;
+    GT_U8        interrupt;
+    GT_U8        IncTcamCtr;
+    GT_U8        vidOverride;
+    GT_U16       vidData;
+    GT_U8        nextId;
+    GT_U8        qpriOverride;
+    GT_U8        qpriData;
+    GT_U8        fpriOverride;
+    GT_U8        fpriData;
+    GT_U8        qpriAvbOverride;
+    GT_U8        qpriAvbData;
+    GT_U8        dpvOverride;
+    GT_U8        dpvData;
+    GT_U8        factionOverride;
+    GT_U16       factionData;
+    GT_U8        ldBalanceOverride;
+    GT_U8        ldBalanceData;
+    GT_U8        debugPort;
+    GT_U8        highHit;
+    GT_U8        lowHit;
+	}  paraFrm;
+} GT_TCAM_DATA;
+
+/*
+ *  typedef: struct GT_TCAM_OP_DATA
+ *
+ *  Description: data required by TCAM (Ternary Content Addressable Memory) Operation
+ *
+ *  Fields:
+ *      tcamPage - page  of TCAM
+ *      tcamEntry - pointer to the desired entry of TCAM
+ *      tcamData - TCAM data for the entry pointed by tcamEntry
+ */
+
+typedef struct
+{
+    GT_U32    tcamPage;
+    GT_U32    tcamEntry;
+    GT_TCAM_DATA    *tcamDataP; 
+} GT_TCAM_OP_DATA;
+
+
+/*
  * typedef: enum GT_EVENT_TYPE
  *
  * Description: Enumeration of the available hardware driven events.
@@ -2292,23 +2541,23 @@ typedef enum
  *   GT_PHY_INT  - PHY interrupt enable, for Fast Ethernet Switch
  *   GT_EE_INT   - EEPROM Done interrupt enable.
  */
-#define GT_AVB_INT           	0x100
+#define GT_AVB_INT               0x100
 #define GT_DEVICE_INT           0x80
 #define GT_STATS_DONE           0x40
 #define GT_VTU_PROB             0x20
 #define GT_VTU_DONE             0x10
-#define GT_ATU_PROB 		0x8
-#define GT_ATU_FULL 		0x8
-#define GT_ATU_DONE		0x4
-#define GT_PHY_INTERRUPT	0x2		/* Device may not support PHY Int. Please refer to datasheet. */
-#define GT_EE_INTERRUPT		0x1
+#define GT_ATU_PROB         0x8
+#define GT_ATU_FULL         0x8
+#define GT_ATU_DONE            0x4
+#define GT_PHY_INTERRUPT    0x2        /* Device may not support PHY Int. Please refer to datasheet. */
+#define GT_EE_INTERRUPT        0x1
 
-#define GT_INT_MASK			\
-		(GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL | 	\
-		GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
-#define GT_NO_INTERNAL_PHY_INT_MASK		\
-		(GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB | 	\
-		GT_ATU_DONE | GT_EE_INTERRUPT)
+#define GT_INT_MASK            \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_FULL |     \
+        GT_ATU_DONE | GT_PHY_INTERRUPT | GT_EE_INTERRUPT)
+#define GT_NO_INTERNAL_PHY_INT_MASK        \
+        (GT_AVB_INT | GT_DEVICE_INT | GT_STATS_DONE | GT_VTU_PROB | GT_VTU_DONE | GT_ATU_PROB |     \
+        GT_ATU_DONE | GT_EE_INTERRUPT)
 
 
 /*
@@ -2318,22 +2567,22 @@ typedef enum
  *
  *  Fields:
  *      event     - Device Interrupts to be enabled
- *					GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
- *					GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
  *      portList  - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt needs
- *					to be asserted. It's in vector format, Bit 10 is for port 10, 
- *					Bit 9 is for port 9, etc.
- *					valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *                    to be asserted. It's in vector format, Bit 10 is for port 10, 
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
  *      phyList   - Phy list where GT_DEV_INT_PHY interrupt needs to be asserted.
- *					It's in vector format, Bit 0 is for port 0, 
- *					Bit 1 is for port 1, etc.
- *					valid only if GT_DEV_INT_PHY bit is set.
+ *                    It's in vector format, Bit 0 is for port 0, 
+ *                    Bit 1 is for port 1, etc.
+ *                    valid only if GT_DEV_INT_PHY bit is set.
  */
 typedef struct
 {
-	GT_U32		event;
-	GT_U32		portList;
-	GT_U32		phyList;
+    GT_U32        event;
+    GT_U32        portList;
+    GT_U32        phyList;
 } GT_DEV_EVENT;
 
 
@@ -2344,22 +2593,22 @@ typedef struct
  *
  *  Fields:
  *      intCause  - Device Interrupt Cause
- *					GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
- *					GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
- *		port	  - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
- *					valid only if GT_DEV_INT_DUPLEX_MISMATCH is set.
+ *                    GT_DEV_INT_WATCHDOG, GT_DEV_INT_JAMLIMIT,
+ *                    GT_DEV_INT_DUPLEX_MISMATCH, and/or GT_DEV_INT_SERDES_LINK
+ *        port      - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+ *                    valid only if GT_DEV_INT_DUPLEX_MISMATCH is set.
  *      linkInt   - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
- *					asserted. It's in vector format, Bit 10 is for port 10, 
- *					Bit 9 is for port 9, etc.
- *					valid only if GT_DEV_INT_SERDES_LINK bit is set.
- *					These bits are only valid of the port that is in 1000Base-X mode.
+ *                    asserted. It's in vector format, Bit 10 is for port 10, 
+ *                    Bit 9 is for port 9, etc.
+ *                    valid only if GT_DEV_INT_SERDES_LINK bit is set.
+ *                    These bits are only valid of the port that is in 1000Base-X mode.
  */
 typedef struct
 {
-	GT_U32		devIntCause;
-	GT_LPORT	port;
-	GT_U32		linkInt;
-	GT_U32		phyInt;
+    GT_U32        devIntCause;
+    GT_LPORT    port;
+    GT_U32        linkInt;
+    GT_U32        phyInt;
 } GT_DEV_INT_STATUS;
 
 
@@ -2367,59 +2616,60 @@ typedef struct
 * GT_DEVICE_INT
 *
 * Description: Enumeration of Device interrupt
-*	GT_DEV_INT_WATCHDOG		- WatchDog event interrupt (WatchDog event can be
-*							  configured with gwdSetEvent API)
-*	GT_DEV_INT_JAMLIMIT		- any of the ports detect an Ingress Jam Limit violation
-*							  (gprtSetPauseLimitIn API)
-*	GT_DEV_INT_DUPLEX_MISMATCH	- any of the ports detect a duplex mismatch 
-*							  (i.e., the local port is in half duplex mode while 
-*							  the link partner is in full duplex mode)
-*	GT_DEV_INT_SERDES_LINK	- SERDES link chage interrupt.
-*							  An interrupt occurs when a SERDES port changes link 
-*							  status (link up or link down)
+*    GT_DEV_INT_WATCHDOG        - WatchDog event interrupt (WatchDog event can be
+*                              configured with gwdSetEvent API)
+*    GT_DEV_INT_JAMLIMIT        - any of the ports detect an Ingress Jam Limit violation
+*                              (gprtSetPauseLimitIn API)
+*    GT_DEV_INT_DUPLEX_MISMATCH    - any of the ports detect a duplex mismatch 
+*                              (i.e., the local port is in half duplex mode while 
+*                              the link partner is in full duplex mode)
+*    GT_DEV_INT_SERDES_LINK    - SERDES link chage interrupt.
+*                              An interrupt occurs when a SERDES port changes link 
+*                              status (link up or link down)
 */
 
-#define GT_DEV_INT_WATCHDOG			0x8
-#define GT_DEV_INT_JAMLIMIT			0x4
-#define GT_DEV_INT_DUPLEX_MISMATCH	0x2
-#define GT_DEV_INT_SERDES_LINK		0x1
-#define GT_DEV_INT_PHY				0x10
+#define GT_DEV_INT_WATCHDOG            0x8
+#define GT_DEV_INT_JAMLIMIT            0x4
+#define GT_DEV_INT_DUPLEX_MISMATCH    0x2
+#define GT_DEV_INT_SERDES_LINK        0x1
+#define GT_DEV_INT_WAKE_EVENT         0x1
+#define GT_DEV_INT_PHY                0x10
 
 /*
 * GT_WATCHDOG_EVENT
 *
 * Description: Enumeration of WatchDog event
-*		GT_WD_QC  - Queue Controller Watch Dog enable.
-*					When enabled, the QC's watch dog circuit checks for link
-*					list errors and any errors found in the QC.
-*		GT_WD_EGRESS - Egress Watch Dog enable.
-*					When enabled, each port's egress circuit checks for problems
-*					between the port and the Queue Controller.
-*		GT_WD_FORCE - Force a Watch Dog event.
+*        GT_WD_QC  - Queue Controller Watch Dog enable.
+*                    When enabled, the QC's watch dog circuit checks for link
+*                    list errors and any errors found in the QC.
+*        GT_WD_EGRESS - Egress Watch Dog enable.
+*                    When enabled, each port's egress circuit checks for problems
+*                    between the port and the Queue Controller.
+*        GT_WD_FORCE - Force a Watch Dog event.
 */
 
-#define GT_WD_QC		0x1
-#define GT_WD_EGRESS	0x2
-#define GT_WD_FORCE		0x4
+#define GT_WD_QC        0x1
+#define GT_WD_EGRESS    0x2
+#define GT_WD_FORCE        0x4
 
 
 /*
 * typedef: struct GT_WD_EVENT_HISTORY
 *
 * Description: WatchDog Event History (cleared only by a hardware reset)
-*		wdEvent   - When it's set to GT_TRUE, some enabled Watch Dog event occurred.
-*					The following events are possible:
-*						QC WatchDog Event (GT_WD_QC)
-*						Egress WatchDog Event (GT_WD_EGRESS)
-*						Forced WatchDog Event (GT_WD_FORCE)
-*		egressEvent-If any port's egress logic detects an egress watch dog issue,
-*					this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
-*					event.
+*        wdEvent   - When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*                    The following events are possible:
+*                        QC WatchDog Event (GT_WD_QC)
+*                        Egress WatchDog Event (GT_WD_EGRESS)
+*                        Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent-If any port's egress logic detects an egress watch dog issue,
+*                    this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*                    event.
 */
 typedef struct
 {
-	GT_BOOL	wdEvent;
-	GT_BOOL egressEvent;
+    GT_BOOL    wdEvent;
+    GT_BOOL egressEvent;
 } GT_WD_EVENT_HISTORY;
 
 
@@ -2429,53 +2679,53 @@ typedef struct
 * Description: Enumeration of PHY interrupt
 */
 
-#define GT_SPEED_CHANGED 		0x4000
-#define GT_DUPLEX_CHANGED		0x2000
-#define GT_PAGE_RECEIVED		0x1000
-#define GT_AUTO_NEG_COMPLETED	0x800
-#define GT_LINK_STATUS_CHANGED	0x400
-#define GT_SYMBOL_ERROR			0x200
-#define GT_FALSE_CARRIER		0x100
-#define GT_FIFO_FLOW			0x80
-#define GT_CROSSOVER_CHANGED	0x40
-#define GT_POLARITY_CHANGED		0x2
-#define GT_JABBER				0x1
-
-#define GT_AUTO_NEG_ERROR		0x8000
-#define GT_DOWNSHIFT_DETECT		0x20
-#define GT_ENERGY_DETECT		0x10
+#define GT_SPEED_CHANGED         0x4000
+#define GT_DUPLEX_CHANGED        0x2000
+#define GT_PAGE_RECEIVED        0x1000
+#define GT_AUTO_NEG_COMPLETED    0x800
+#define GT_LINK_STATUS_CHANGED    0x400
+#define GT_SYMBOL_ERROR            0x200
+#define GT_FALSE_CARRIER        0x100
+#define GT_FIFO_FLOW            0x80
+#define GT_CROSSOVER_CHANGED    0x40
+#define GT_POLARITY_CHANGED        0x2
+#define GT_JABBER                0x1
+
+#define GT_AUTO_NEG_ERROR        0x8000
+#define GT_DOWNSHIFT_DETECT        0x20
+#define GT_ENERGY_DETECT        0x10
 
 /*
 * typedef: enum GT_PHY_AUTO_MODE
 *
 * Description: Enumeration of Autonegotiation mode.
-*	Auto for both speed and duplex.
-*	Auto for speed only and Full duplex.
-*	Auto for speed only and Half duplex. (1000Mbps is not supported)
-*	Auto for duplex only and speed 1000Mbps.
-*	Auto for duplex only and speed 100Mbps.
-*	Auto for duplex only and speed 10Mbps.
-*	1000Mbps Full duplex.
-*	100Mbps Full duplex.
-*	100Mbps Half duplex.
-*	10Mbps Full duplex.
-*	10Mbps Half duplex.
+*    Auto for both speed and duplex.
+*    Auto for speed only and Full duplex.
+*    Auto for speed only and Half duplex. (1000Mbps is not supported)
+*    Auto for duplex only and speed 1000Mbps.
+*    Auto for duplex only and speed 100Mbps.
+*    Auto for duplex only and speed 10Mbps.
+*    1000Mbps Full duplex.
+*    100Mbps Full duplex.
+*    100Mbps Half duplex.
+*    10Mbps Full duplex.
+*    10Mbps Half duplex.
 */
 
 typedef enum
 {
-	SPEED_AUTO_DUPLEX_AUTO,
-	SPEED_1000_DUPLEX_AUTO,
-	SPEED_100_DUPLEX_AUTO,
-	SPEED_10_DUPLEX_AUTO,
-	SPEED_AUTO_DUPLEX_FULL,
-	SPEED_AUTO_DUPLEX_HALF,
-	SPEED_1000_DUPLEX_FULL,
-	SPEED_1000_DUPLEX_HALF,
-	SPEED_100_DUPLEX_FULL,
-	SPEED_100_DUPLEX_HALF,
-	SPEED_10_DUPLEX_FULL,
-	SPEED_10_DUPLEX_HALF
+    SPEED_AUTO_DUPLEX_AUTO,
+    SPEED_1000_DUPLEX_AUTO,
+    SPEED_100_DUPLEX_AUTO,
+    SPEED_10_DUPLEX_AUTO,
+    SPEED_AUTO_DUPLEX_FULL,
+    SPEED_AUTO_DUPLEX_HALF,
+    SPEED_1000_DUPLEX_FULL,
+    SPEED_1000_DUPLEX_HALF,
+    SPEED_100_DUPLEX_FULL,
+    SPEED_100_DUPLEX_HALF,
+    SPEED_10_DUPLEX_FULL,
+    SPEED_10_DUPLEX_HALF
 }GT_PHY_AUTO_MODE;
 
 
@@ -2485,17 +2735,17 @@ typedef enum
 * Description: Enumeration of Pause Mode in the Phy.
 *
 * Enumerations:
-*	GT_PHY_NO_PAUSE		- disable pause
-*	GT_PHY_PAUSE		- support pause
-*	GT_PHY_ASYMMETRIC_PAUSE	- support asymmetric pause
-*	GT_PHY_BOTH_PAUSE	- support both pause and asymmetric pause
+*    GT_PHY_NO_PAUSE        - disable pause
+*    GT_PHY_PAUSE        - support pause
+*    GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*    GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
 */
 typedef enum
 {
-	GT_PHY_NO_PAUSE = 0,
-	GT_PHY_PAUSE,
-	GT_PHY_ASYMMETRIC_PAUSE,
-	GT_PHY_BOTH_PAUSE
+    GT_PHY_NO_PAUSE = 0,
+    GT_PHY_PAUSE,
+    GT_PHY_ASYMMETRIC_PAUSE,
+    GT_PHY_BOTH_PAUSE
 } GT_PHY_PAUSE_MODE;
 
 
@@ -2505,15 +2755,15 @@ typedef enum
 * Description: Enumeration of Phy Speed
 *
 * Enumerations:
-*	PHY_SPEED_10_MBPS   - 10Mbps
-*	PHY_SPEED_100_MBPS	- 100Mbps
-*	PHY_SPEED_1000_MBPS - 1000Mbps
+*    PHY_SPEED_10_MBPS   - 10Mbps
+*    PHY_SPEED_100_MBPS    - 100Mbps
+*    PHY_SPEED_1000_MBPS - 1000Mbps
 */
 typedef enum
 {
-	PHY_SPEED_10_MBPS,
-	PHY_SPEED_100_MBPS,
-	PHY_SPEED_1000_MBPS
+    PHY_SPEED_10_MBPS,
+    PHY_SPEED_100_MBPS,
+    PHY_SPEED_1000_MBPS
 } GT_PHY_SPEED;
 
 
@@ -2523,17 +2773,17 @@ typedef enum
 * Description: Enumeration of Serdes mode
 *
 * Enumerations:
-*	PHY_SERDES_100FX	 - 100 FX
-*	PHY_SERDES_1000X	 - 1000 X
-*	PHY_SERDES_SGMII_PHY - SGMII PHY
-*	PHY_SERDES_SGMII_MAC - SGMII MAC
+*    PHY_SERDES_100FX     - 100 FX
+*    PHY_SERDES_1000X     - 1000 X
+*    PHY_SERDES_SGMII_PHY - SGMII PHY
+*    PHY_SERDES_SGMII_MAC - SGMII MAC
 */
 typedef enum
 {
-	PHY_SERDES_100FX = 0,
-	PHY_SERDES_1000X,	
-	PHY_SERDES_SGMII_PHY,
-	PHY_SERDES_SGMII_MAC
+    PHY_SERDES_100FX = 0,
+    PHY_SERDES_1000X,    
+    PHY_SERDES_SGMII_PHY,
+    PHY_SERDES_SGMII_MAC
 } GT_SERDES_MODE;
 
 
@@ -2543,15 +2793,15 @@ typedef enum
 * Description: Enumeration of Energy Detect mode
 *
 * Enumerations:
-*	GT_EDETECT_OFF		- Energy Detect disabled
-*	GT_EDETECT_SENSE_PULSE	- Energy Detect enabled with sense and pulse
-*	GT_EDETECT_SENSE	- Energy Detect enabled only with sense
+*    GT_EDETECT_OFF        - Energy Detect disabled
+*    GT_EDETECT_SENSE_PULSE    - Energy Detect enabled with sense and pulse
+*    GT_EDETECT_SENSE    - Energy Detect enabled only with sense
 */
 typedef enum
 {
-	GT_EDETECT_OFF = 0,
-	GT_EDETECT_SENSE_PULSE,
-	GT_EDETECT_SENSE
+    GT_EDETECT_OFF = 0,
+    GT_EDETECT_SENSE_PULSE,
+    GT_EDETECT_SENSE
 } GT_EDETECT_MODE;
 
 /*
@@ -2567,10 +2817,10 @@ typedef enum
  */
 typedef enum
 {
-	GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
-	GT_TRAILER_INGRESS,       /* 0x01 */
-	GT_UNTAGGED_INGRESS,      /* 0x10 */
-	GT_CPUPORT_INGRESS        /* 0x11 */
+    GT_UNMODIFY_INGRESS = 0,  /* 0x00 */
+    GT_TRAILER_INGRESS,       /* 0x01 */
+    GT_UNTAGGED_INGRESS,      /* 0x10 */
+    GT_CPUPORT_INGRESS        /* 0x11 */
 } GT_INGRESS_MODE;
 
 
@@ -2587,10 +2837,10 @@ typedef enum
  */
 typedef enum
 {
-	GT_BLOCK_EGRESS_UNKNOWN = 0,
-	GT_BLOCK_EGRESS_UNKNOWN_MULTICAST,
-	GT_BLOCK_EGRESS_UNKNOWN_UNICAST,
-	GT_BLOCK_EGRESS_NONE
+    GT_BLOCK_EGRESS_UNKNOWN = 0,
+    GT_BLOCK_EGRESS_UNKNOWN_MULTICAST,
+    GT_BLOCK_EGRESS_UNKNOWN_UNICAST,
+    GT_BLOCK_EGRESS_NONE
 } GT_EGRESS_FLOOD;
 
 
@@ -2607,10 +2857,10 @@ typedef enum
  */
 typedef enum
 {
-	GT_MC_3_PERCENT_RL = 0,
-	GT_MC_6_PERCENT_RL,
-	GT_MC_12_PERCENT_RL,
-	GT_MC_100_PERCENT_RL,
+    GT_MC_3_PERCENT_RL = 0,
+    GT_MC_6_PERCENT_RL,
+    GT_MC_12_PERCENT_RL,
+    GT_MC_100_PERCENT_RL,
 } GT_MC_RATE;
 
 
@@ -2621,12 +2871,12 @@ typedef enum
  *
  *  Enumerations:
  *      GT_RATE_PRI_BASE   - Priority based rate limiting
- *		GT_RATE_BURST_BASE - Burst Size based rate limiting
+ *        GT_RATE_BURST_BASE - Burst Size based rate limiting
  */
 typedef enum
 {
-	GT_RATE_PRI_BASE = 0,
-	GT_RATE_BURST_BASE
+    GT_RATE_PRI_BASE = 0,
+    GT_RATE_BURST_BASE
 } GT_INGRESS_RATE_MODE;
 
 
@@ -2636,21 +2886,21 @@ typedef enum
  *  Description: Enumeration of port scheduling mode
  *
  *  Fields:
- *	 	GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
- *	 	GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
- *	 	GT_PORT_SCHED_STRICT_PRI3 - use a strict for priority 3 and weighted 
- *									round robin for the priority 2,1,and 0
- *	 	GT_PORT_SCHED_STRICT_PRI2_3 - use a strict for priority 2,3 and weighted 
- *									round robin for the priority 1,and 0
+ *         GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+ *         GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+ *         GT_PORT_SCHED_STRICT_PRI3 - use a strict for priority 3 and weighted 
+ *                                    round robin for the priority 2,1,and 0
+ *         GT_PORT_SCHED_STRICT_PRI2_3 - use a strict for priority 2,3 and weighted 
+ *                                    round robin for the priority 1,and 0
  *
  *  Comment:
  */
 typedef enum
 {
-	GT_PORT_SCHED_WEIGHTED_RRB = 0,
-	GT_PORT_SCHED_STRICT_PRI,
-	GT_PORT_SCHED_STRICT_PRI3,
-	GT_PORT_SCHED_STRICT_PRI2_3
+    GT_PORT_SCHED_WEIGHTED_RRB = 0,
+    GT_PORT_SCHED_STRICT_PRI,
+    GT_PORT_SCHED_STRICT_PRI3,
+    GT_PORT_SCHED_STRICT_PRI2_3
 } GT_PORT_SCHED_MODE;
 
 
@@ -2665,15 +2915,15 @@ typedef enum
  *      dropped - dropped frame counter.
  *
  *  Comment:
- *		dropped frame counter is supported by only limited devices.
- *		At this moment, 88E6061/88E6065 are the devices supporting
- *		dropped frame counter.
+ *        dropped frame counter is supported by only limited devices.
+ *        At this moment, 88E6061/88E6065 are the devices supporting
+ *        dropped frame counter.
  */
 typedef struct
 {
-	GT_U16  rxCtr;
-	GT_U16  txCtr;
-	GT_U16  dropped;
+    GT_U16  rxCtr;
+    GT_U16  txCtr;
+    GT_U16  dropped;
 } GT_PORT_STAT;
 
 /*
@@ -2691,10 +2941,10 @@ typedef struct
  */
 typedef struct
 {
-	GT_U16  inDiscardLo;
-	GT_U16  inDiscardHi;
-	GT_U16  inFiltered;
-	GT_U16  outFiltered;
+    GT_U16  inDiscardLo;
+    GT_U16  inDiscardHi;
+    GT_U16  inFiltered;
+    GT_U16  outFiltered;
 } GT_PORT_STAT2;
 
 
@@ -2710,8 +2960,8 @@ typedef struct
  **/
 typedef struct
 {
-	GT_U16  OutQ_Size;
-	GT_U16  Rsv_Size;
+    GT_U16  OutQ_Size;
+    GT_U16  Rsv_Size;
 } GT_PORT_Q_STAT;
 
 /*
@@ -2726,8 +2976,8 @@ typedef struct
  */
 typedef enum
 {
-	GT_CTR_ALL = 0,
-	GT_CTR_ERRORS,
+    GT_CTR_ALL = 0,
+    GT_CTR_ERRORS,
 } GT_CTR_MODE;
 
 typedef struct _GT_QD_DEV GT_QD_DEV;
@@ -2738,155 +2988,194 @@ typedef struct _GT_QD_DEV GT_QD_DEV;
  */
 typedef enum
 {
-	GT_SEM_EMPTY,
-	GT_SEM_FULL
+    GT_SEM_EMPTY,
+    GT_SEM_FULL
 } GT_SEM_BEGIN_STATE;
 
 typedef GT_SEM (*FGT_SEM_CREATE)(
-						GT_SEM_BEGIN_STATE state);
+                        GT_SEM_BEGIN_STATE state);
 typedef GT_STATUS (*FGT_SEM_DELETE)(
-						GT_SEM semId);
+                        GT_SEM semId);
 typedef GT_STATUS (*FGT_SEM_TAKE)(
-						GT_SEM semId, GT_U32 timOut);
+                        GT_SEM semId, GT_U32 timOut);
 typedef GT_STATUS (*FGT_SEM_GIVE)(
-						GT_SEM semId);
+                        GT_SEM semId);
 
 typedef struct
 {
-	FGT_SEM_CREATE	semCreate; 	/* create semapore */
-	FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
-	FGT_SEM_TAKE	semTake;	/* try to get a semapore */
-	FGT_SEM_GIVE	semGive;	/* return semaphore */
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
 }GT_SEM_ROUTINES;
 
 /*
+ * definitions for registering Hardware access function.
+ *
+*/
+/*#ifdef GT_RMGMT_ACCESS */
+#if 1
+/*
+ *  * Definition for the direction in HW_DEV_RW_REG structure.
+ *  */
+#define HW_REG_READ                     0
+#define HW_REG_WRITE            1
+#define HW_REG_WAIT_TILL_0      2
+#define HW_REG_WAIT_TILL_1      3       
+
+/* HW_ACCESS_READ_REG and HW_ACCESS_WRITE_REG */
+typedef struct _HW_DEV_RW_REG
+{
+  unsigned long cmd;  /*INPUT:HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 */
+  unsigned long addr; /*INPUT:SMI Address */
+  unsigned long reg;  /*INPUT:Register offset */
+  unsigned long data; /*INPUT,OUTPUT:Value in the Register or Bit number */
+} HW_DEV_RW_REG;
+
+#define  MAX_ACCESS_REG_NUM  12
+
+typedef struct _HW_DEV_REG_ACCESS
+{
+        unsigned long   entries;   
+        HW_DEV_RW_REG   rw_reg_list[MAX_ACCESS_REG_NUM]; /* INPUT,OUTPUT: Reg Access information */
+} HW_DEV_REG_ACCESS;
+
+
+typedef GT_BOOL (*FGT_HW_ACCESS)(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+#endif
+
+/*
  * definitions for registering MII access functions.
  *
 */
 typedef GT_BOOL (*FGT_READ_MII)(
-						GT_QD_DEV*   dev,
-						unsigned int phyAddr, 
-						unsigned int miiReg, 
-						unsigned int* value);
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr, 
+                        unsigned int miiReg, 
+                        unsigned int* value);
 typedef GT_BOOL (*FGT_WRITE_MII)(
-						GT_QD_DEV*   dev,
-						unsigned int phyAddr, 
-						unsigned int miiReg, 
-						unsigned int value);
+                        GT_QD_DEV*   dev,
+                        unsigned int phyAddr, 
+                        unsigned int miiReg, 
+                        unsigned int value);
 typedef GT_BOOL (*FGT_INT_HANDLER)(
-						GT_QD_DEV*   dev,
-						GT_U16*);
+                        GT_QD_DEV*   dev,
+                        GT_U16*);
 
 typedef struct _BSP_FUNCTIONS
 {
-	FGT_READ_MII 	readMii;	/* read MII Registers */
-	FGT_WRITE_MII 	writeMii;	/* write MII Registers */
-	FGT_SEM_CREATE	semCreate; 	/* create semapore */
-	FGT_SEM_DELETE	semDelete; 	/* delete the semapore */
-	FGT_SEM_TAKE	semTake;	/* try to get a semapore */
-	FGT_SEM_GIVE	semGive;	/* return semaphore */
+    GT_U32        hwAccessMod;    /* Hardware access mode */
+    FGT_READ_MII     readMii;    /* read MII Registers */
+    FGT_WRITE_MII     writeMii;    /* write MII Registers */
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS   hwAccess;    /* Hardware access function */
+#endif
+    FGT_SEM_CREATE    semCreate;     /* create semapore */
+    FGT_SEM_DELETE    semDelete;     /* delete the semapore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semapore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
 }BSP_FUNCTIONS;
 
 
 /*
- *	Type definition for MIB counter operation
+ *    Type definition for MIB counter operation
 */
 typedef enum 
 {
-	STATS_FLUSH_ALL,		/* Flush all counters for all ports */
-	STATS_FLUSH_PORT,		/* Flush all counters for a port */
-	STATS_READ_COUNTER,		/* Read a specific counter from a port */
-	STATS_READ_REALTIME_COUNTER,	/* Read a realtime counter from a port */
-	STATS_READ_ALL			/* Read all counters from a port */
+    STATS_FLUSH_ALL,        /* Flush all counters for all ports */
+    STATS_FLUSH_PORT,        /* Flush all counters for a port */
+    STATS_READ_COUNTER,        /* Read a specific counter from a port */
+    STATS_READ_REALTIME_COUNTER,    /* Read a realtime counter from a port */
+    STATS_READ_ALL            /* Read all counters from a port */
 
 } GT_STATS_OPERATION;
 
 typedef struct _GT_STATS_COUNTER_SET
 {
-	GT_U32	InUnicasts;
-	GT_U32	InBroadcasts;
-	GT_U32	InPause;
-	GT_U32	InMulticasts;
-	GT_U32	InFCSErr;
-	GT_U32	AlignErr;
-	GT_U32	InGoodOctets;
-	GT_U32	InBadOctets;
-	GT_U32	Undersize;
-	GT_U32	Fragments;
-	GT_U32	In64Octets;		/* 64 Octets */
-	GT_U32	In127Octets;	/* 65 to 127 Octets */
-	GT_U32	In255Octets;	/* 128 to 255 Octets */
-	GT_U32	In511Octets;	/* 256 to 511 Octets */
-	GT_U32	In1023Octets;	/* 512 to 1023 Octets */
-	GT_U32	InMaxOctets;	/* 1024 to Max Octets */
-	GT_U32	Jabber;
-	GT_U32	Oversize;
-	GT_U32	InDiscards;
-	GT_U32	Filtered;
-	GT_U32	OutUnicasts;
-	GT_U32	OutBroadcasts;
-	GT_U32	OutPause;
-	GT_U32	OutMulticasts;
-	GT_U32	OutFCSErr;
-	GT_U32	OutGoodOctets;
-	GT_U32	Out64Octets;	/* 64 Octets */
-	GT_U32	Out127Octets;	/* 65 to 127 Octets */
-	GT_U32	Out255Octets;	/* 128 to 255 Octets */
-	GT_U32	Out511Octets;	/* 256 to 511 Octets */
-	GT_U32	Out1023Octets;	/* 512 to 1023 Octets */
-	GT_U32	OutMaxOctets;	/* 1024 to Max Octets */
-	GT_U32	Collisions;
-	GT_U32	Late;
-	GT_U32	Excessive;
-	GT_U32	Multiple;
-	GT_U32	Single;
-	GT_U32	Deferred;
-	GT_U32	OutDiscards;
+    GT_U32    InUnicasts;
+    GT_U32    InBroadcasts;
+    GT_U32    InPause;
+    GT_U32    InMulticasts;
+    GT_U32    InFCSErr;
+    GT_U32    AlignErr;
+    GT_U32    InGoodOctets;
+    GT_U32    InBadOctets;
+    GT_U32    Undersize;
+    GT_U32    Fragments;
+    GT_U32    In64Octets;        /* 64 Octets */
+    GT_U32    In127Octets;    /* 65 to 127 Octets */
+    GT_U32    In255Octets;    /* 128 to 255 Octets */
+    GT_U32    In511Octets;    /* 256 to 511 Octets */
+    GT_U32    In1023Octets;    /* 512 to 1023 Octets */
+    GT_U32    InMaxOctets;    /* 1024 to Max Octets */
+    GT_U32    Jabber;
+    GT_U32    Oversize;
+    GT_U32    InDiscards;
+    GT_U32    Filtered;
+    GT_U32    OutUnicasts;
+    GT_U32    OutBroadcasts;
+    GT_U32    OutPause;
+    GT_U32    OutMulticasts;
+    GT_U32    OutFCSErr;
+    GT_U32    OutGoodOctets;
+    GT_U32    Out64Octets;    /* 64 Octets */
+    GT_U32    Out127Octets;    /* 65 to 127 Octets */
+    GT_U32    Out255Octets;    /* 128 to 255 Octets */
+    GT_U32    Out511Octets;    /* 256 to 511 Octets */
+    GT_U32    Out1023Octets;    /* 512 to 1023 Octets */
+    GT_U32    OutMaxOctets;    /* 1024 to Max Octets */
+    GT_U32    Collisions;
+    GT_U32    Late;
+    GT_U32    Excessive;
+    GT_U32    Multiple;
+    GT_U32    Single;
+    GT_U32    Deferred;
+    GT_U32    OutDiscards;
 
 } GT_STATS_COUNTER_SET;
 
 
 typedef enum
 {
-	STATS_InUnicasts = 0,
-	STATS_InBroadcasts,
-	STATS_InPause,
-	STATS_InMulticasts,
-	STATS_InFCSErr,
-	STATS_AlignErr,
-	STATS_InGoodOctets,
-	STATS_InBadOctets,
-	STATS_Undersize,
-	STATS_Fragments,
-	STATS_In64Octets,
-	STATS_In127Octets,
-	STATS_In255Octets,
-	STATS_In511Octets,
-	STATS_In1023Octets,
-	STATS_InMaxOctets,
-	STATS_Jabber,
-	STATS_Oversize,
-	STATS_InDiscards,
-	STATS_Filtered,
-	STATS_OutUnicasts,
-	STATS_OutBroadcasts,
-	STATS_OutPause,
-	STATS_OutMulticasts,
-	STATS_OutFCSErr,
-	STATS_OutGoodOctets,
-	STATS_Out64Octets,
-	STATS_Out127Octets,
-	STATS_Out255Octets,
-	STATS_Out511Octets,
-	STATS_Out1023Octets,
-	STATS_OutMaxOctets,
-	STATS_Collisions,
-	STATS_Late,
-	STATS_Excessive,
-	STATS_Multiple,
-	STATS_Single,
-	STATS_Deferred,
-	STATS_OutDiscards
+    STATS_InUnicasts = 0,
+    STATS_InBroadcasts,
+    STATS_InPause,
+    STATS_InMulticasts,
+    STATS_InFCSErr,
+    STATS_AlignErr,
+    STATS_InGoodOctets,
+    STATS_InBadOctets,
+    STATS_Undersize,
+    STATS_Fragments,
+    STATS_In64Octets,
+    STATS_In127Octets,
+    STATS_In255Octets,
+    STATS_In511Octets,
+    STATS_In1023Octets,
+    STATS_InMaxOctets,
+    STATS_Jabber,
+    STATS_Oversize,
+    STATS_InDiscards,
+    STATS_Filtered,
+    STATS_OutUnicasts,
+    STATS_OutBroadcasts,
+    STATS_OutPause,
+    STATS_OutMulticasts,
+    STATS_OutFCSErr,
+    STATS_OutGoodOctets,
+    STATS_Out64Octets,
+    STATS_Out127Octets,
+    STATS_Out255Octets,
+    STATS_Out511Octets,
+    STATS_Out1023Octets,
+    STATS_OutMaxOctets,
+    STATS_Collisions,
+    STATS_Late,
+    STATS_Excessive,
+    STATS_Multiple,
+    STATS_Single,
+    STATS_Deferred,
+    STATS_OutDiscards
 
 } GT_STATS_COUNTERS;
 /*
@@ -2901,180 +3190,180 @@ typedef enum
  */
 typedef enum
 {
-	GT_COUNT_RX_ONLY = 0,
-	GT_COUNT_TX_ONLY,
-	GT_COUNT_RX_TX
+    GT_COUNT_RX_ONLY = 0,
+    GT_COUNT_TX_ONLY,
+    GT_COUNT_RX_TX
 } GT_HISTOGRAM_MODE;
 
 /*
-	Counter set 2 is used by 88E6183
+    Counter set 2 is used by 88E6183
 */
 typedef struct _GT_STATS_COUNTER_SET2
 {
-	GT_U32	InGoodOctetsHi;
-	GT_U32	InGoodOctetsLo;
-	GT_U32	InBadOctets;
-	GT_U32	OutDiscards;
-	GT_U32	InGoodFrames;
-	GT_U32	InBadFrames;
-	GT_U32	InBroadcasts;
-	GT_U32	InMulticasts;
-	/* 
-		Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
-		(refer to Histogram Mode) 
-	*/
-	GT_U32	Octets64;		/* 64 Octets */
-	GT_U32	Octets127;		/* 65 to 127 Octets */
-	GT_U32	Octets255;		/* 128 to 255 Octets */
-	GT_U32	Octets511;		/* 256 to 511 Octets */
-	GT_U32	Octets1023;		/* 512 to 1023 Octets */
-	GT_U32	OctetsMax;		/* 1024 to Max Octets */
-	GT_U32	OutOctetsHi;
-	GT_U32	OutOctetsLo;
-	GT_U32	OutFrames;
-	GT_U32	Excessive;
-	GT_U32	OutMulticasts;
-	GT_U32	OutBroadcasts;
-	GT_U32	InBadMACCtrl;
-
-	GT_U32	OutPause;
-	GT_U32	InPause;
-	GT_U32	InDiscards;
-	GT_U32	Undersize;
-	GT_U32	Fragments;
-	GT_U32	Oversize;
-	GT_U32	Jabber;
-	GT_U32	MACRcvErr;
-	GT_U32	InFCSErr;
-	GT_U32	Collisions;
-	GT_U32	Late;
+    GT_U32    InGoodOctetsHi;
+    GT_U32    InGoodOctetsLo;
+    GT_U32    InBadOctets;
+    GT_U32    OutDiscards;
+    GT_U32    InGoodFrames;
+    GT_U32    InBadFrames;
+    GT_U32    InBroadcasts;
+    GT_U32    InMulticasts;
+    /* 
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+        (refer to Histogram Mode) 
+    */
+    GT_U32    Octets64;        /* 64 Octets */
+    GT_U32    Octets127;        /* 65 to 127 Octets */
+    GT_U32    Octets255;        /* 128 to 255 Octets */
+    GT_U32    Octets511;        /* 256 to 511 Octets */
+    GT_U32    Octets1023;        /* 512 to 1023 Octets */
+    GT_U32    OctetsMax;        /* 1024 to Max Octets */
+    GT_U32    OutOctetsHi;
+    GT_U32    OutOctetsLo;
+    GT_U32    OutFrames;
+    GT_U32    Excessive;
+    GT_U32    OutMulticasts;
+    GT_U32    OutBroadcasts;
+    GT_U32    InBadMACCtrl;
+
+    GT_U32    OutPause;
+    GT_U32    InPause;
+    GT_U32    InDiscards;
+    GT_U32    Undersize;
+    GT_U32    Fragments;
+    GT_U32    Oversize;
+    GT_U32    Jabber;
+    GT_U32    MACRcvErr;
+    GT_U32    InFCSErr;
+    GT_U32    Collisions;
+    GT_U32    Late;
 
 } GT_STATS_COUNTER_SET2;
 
 
 typedef enum
 {
-	STATS2_InGoodOctetsHi = 0,
-	STATS2_InGoodOctetsLo,
-	STATS2_InBadOctets,
-	
-	STATS2_OutDiscards,
-	STATS2_InGoodFrames,
-	STATS2_InBadFrames,
-	STATS2_InBroadcasts,
-	STATS2_InMulticasts,
-	STATS2_64Octets,
-	STATS2_127Octets,
-	STATS2_255Octets,
-	STATS2_511Octets,
-	STATS2_1023Octets,
-	STATS2_MaxOctets,
-	STATS2_OutOctetsHi,
-	STATS2_OutOctetsLo,
-	STATS2_OutFrames,
-	STATS2_Excessive,
-	STATS2_OutMulticasts,
-	STATS2_OutBroadcasts,
-	STATS2_InBadMACCtrl,
-	STATS2_OutPause,
-	STATS2_InPause,
-	STATS2_InDiscards,
-	STATS2_Undersize,
-	STATS2_Fragments,
-	STATS2_Oversize,
-	STATS2_Jabber,
-	STATS2_MACRcvErr,
-	STATS2_InFCSErr,
-	STATS2_Collisions,
-	STATS2_Late
+    STATS2_InGoodOctetsHi = 0,
+    STATS2_InGoodOctetsLo,
+    STATS2_InBadOctets,
+    
+    STATS2_OutDiscards,
+    STATS2_InGoodFrames,
+    STATS2_InBadFrames,
+    STATS2_InBroadcasts,
+    STATS2_InMulticasts,
+    STATS2_64Octets,
+    STATS2_127Octets,
+    STATS2_255Octets,
+    STATS2_511Octets,
+    STATS2_1023Octets,
+    STATS2_MaxOctets,
+    STATS2_OutOctetsHi,
+    STATS2_OutOctetsLo,
+    STATS2_OutFrames,
+    STATS2_Excessive,
+    STATS2_OutMulticasts,
+    STATS2_OutBroadcasts,
+    STATS2_InBadMACCtrl,
+    STATS2_OutPause,
+    STATS2_InPause,
+    STATS2_InDiscards,
+    STATS2_Undersize,
+    STATS2_Fragments,
+    STATS2_Oversize,
+    STATS2_Jabber,
+    STATS2_MACRcvErr,
+    STATS2_InFCSErr,
+    STATS2_Collisions,
+    STATS2_Late
 
 } GT_STATS_COUNTERS2;
 
 /*
-	Counter set 3 is used by 88E6093 and 88E6065
+    Counter set 3 is used by 88E6093 and 88E6065
 */
 typedef struct _GT_STATS_COUNTER_SET3
 {
-	GT_U32	InGoodOctetsLo;	/* offset 0 */
-	GT_U32	InGoodOctetsHi;	/* offset 1, not supported by 88E6065 */
-	GT_U32	InBadOctets;		/* offset 2 */
-	GT_U32	OutFCSErr;			/* offset 3 */
-	GT_U32	InUnicasts;			/* offset 4 */
-	GT_U32	Deferred;			/* offset 5 */
-	GT_U32	InBroadcasts;		/* offset 6 */
-	GT_U32	InMulticasts;		/* offset 7 */
-	/* 
-		Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
-		(refer to Histogram Mode) 
-	*/
-	GT_U32	Octets64;		/* 64 Octets, offset 8 */
-	GT_U32	Octets127;		/* 65 to 127 Octets, offset 9 */
-	GT_U32	Octets255;		/* 128 to 255 Octets, offset 10 */
-	GT_U32	Octets511;		/* 256 to 511 Octets, offset 11 */
-	GT_U32	Octets1023;		/* 512 to 1023 Octets, offset 12 */
-	GT_U32	OctetsMax;		/* 1024 to Max Octets, offset 13 */
-	GT_U32	OutOctetsLo;	/* offset 14 */
-	GT_U32	OutOctetsHi;	/* offset 15, not supported by 88E6065 */
-	GT_U32	OutUnicasts;	/* offset 16 */
-	GT_U32	Excessive;		/* offset 17 */
-	GT_U32	OutMulticasts;	/* offset 18 */
-	GT_U32	OutBroadcasts;	/* offset 19 */
-	GT_U32	Single;			/* offset 20 */
-
-	GT_U32	OutPause;		/* offset 21 */
-	GT_U32	InPause;			/* offset 22 */
-	GT_U32	Multiple;		/* offset 23 */
-	GT_U32	Undersize;		/* offset 24 */
-	GT_U32	Fragments;		/* offset 25 */
-	GT_U32	Oversize;		/* offset 26 */
-	GT_U32	Jabber;			/* offset 27 */
-	GT_U32	InMACRcvErr;	/* offset 28 */
-	GT_U32	InFCSErr;		/* offset 29 */
-	GT_U32	Collisions;		/* offset 30 */
-	GT_U32	Late;				/* offset 31 */
+    GT_U32    InGoodOctetsLo;    /* offset 0 */
+    GT_U32    InGoodOctetsHi;    /* offset 1, not supported by 88E6065 */
+    GT_U32    InBadOctets;        /* offset 2 */
+    GT_U32    OutFCSErr;            /* offset 3 */
+    GT_U32    InUnicasts;            /* offset 4 */
+    GT_U32    Deferred;            /* offset 5 */
+    GT_U32    InBroadcasts;        /* offset 6 */
+    GT_U32    InMulticasts;        /* offset 7 */
+    /* 
+        Histogram Counters : Rx Only, Tx Only, or both Rx and Tx 
+        (refer to Histogram Mode) 
+    */
+    GT_U32    Octets64;        /* 64 Octets, offset 8 */
+    GT_U32    Octets127;        /* 65 to 127 Octets, offset 9 */
+    GT_U32    Octets255;        /* 128 to 255 Octets, offset 10 */
+    GT_U32    Octets511;        /* 256 to 511 Octets, offset 11 */
+    GT_U32    Octets1023;        /* 512 to 1023 Octets, offset 12 */
+    GT_U32    OctetsMax;        /* 1024 to Max Octets, offset 13 */
+    GT_U32    OutOctetsLo;    /* offset 14 */
+    GT_U32    OutOctetsHi;    /* offset 15, not supported by 88E6065 */
+    GT_U32    OutUnicasts;    /* offset 16 */
+    GT_U32    Excessive;        /* offset 17 */
+    GT_U32    OutMulticasts;    /* offset 18 */
+    GT_U32    OutBroadcasts;    /* offset 19 */
+    GT_U32    Single;            /* offset 20 */
+
+    GT_U32    OutPause;        /* offset 21 */
+    GT_U32    InPause;            /* offset 22 */
+    GT_U32    Multiple;        /* offset 23 */
+    GT_U32    Undersize;        /* offset 24 */
+    GT_U32    Fragments;        /* offset 25 */
+    GT_U32    Oversize;        /* offset 26 */
+    GT_U32    Jabber;            /* offset 27 */
+    GT_U32    InMACRcvErr;    /* offset 28 */
+    GT_U32    InFCSErr;        /* offset 29 */
+    GT_U32    Collisions;        /* offset 30 */
+    GT_U32    Late;                /* offset 31 */
 
 } GT_STATS_COUNTER_SET3;
 
 
 typedef enum
 {
-	STATS3_InGoodOctetsLo = 0,
-	STATS3_InGoodOctetsHi,
-	STATS3_InBadOctets,
-	
-	STATS3_OutFCSErr,
-	STATS3_InUnicasts,
-	STATS3_Deferred,			/* offset 5 */
-	STATS3_InBroadcasts,
-	STATS3_InMulticasts,
-	STATS3_64Octets,
-	STATS3_127Octets,
-	STATS3_255Octets,			/* offset 10 */
-	STATS3_511Octets,
-	STATS3_1023Octets,
-	STATS3_MaxOctets,
-	STATS3_OutOctetsLo,
-	STATS3_OutOctetsHi,
-	STATS3_OutUnicasts,		/* offset 16 */
-	STATS3_Excessive,
-	STATS3_OutMulticasts,
-	STATS3_OutBroadcasts,
-	STATS3_Single,
-	STATS3_OutPause,
-	STATS3_InPause,
-	STATS3_Multiple,
-	STATS3_Undersize,			/* offset 24 */
-	STATS3_Fragments,
-	STATS3_Oversize,
-	STATS3_Jabber,
-	STATS3_InMACRcvErr,
-	STATS3_InFCSErr,
-	STATS3_Collisions,
-	STATS3_Late					/* offset 31 */
+    STATS3_InGoodOctetsLo = 0,
+    STATS3_InGoodOctetsHi,
+    STATS3_InBadOctets,
+    
+    STATS3_OutFCSErr,
+    STATS3_InUnicasts,
+    STATS3_Deferred,            /* offset 5 */
+    STATS3_InBroadcasts,
+    STATS3_InMulticasts,
+    STATS3_64Octets,
+    STATS3_127Octets,
+    STATS3_255Octets,            /* offset 10 */
+    STATS3_511Octets,
+    STATS3_1023Octets,
+    STATS3_MaxOctets,
+    STATS3_OutOctetsLo,
+    STATS3_OutOctetsHi,
+    STATS3_OutUnicasts,        /* offset 16 */
+    STATS3_Excessive,
+    STATS3_OutMulticasts,
+    STATS3_OutBroadcasts,
+    STATS3_Single,
+    STATS3_OutPause,
+    STATS3_InPause,
+    STATS3_Multiple,
+    STATS3_Undersize,            /* offset 24 */
+    STATS3_Fragments,
+    STATS3_Oversize,
+    STATS3_Jabber,
+    STATS3_InMACRcvErr,
+    STATS3_InFCSErr,
+    STATS3_Collisions,
+    STATS3_Late                    /* offset 31 */
 
 } GT_STATS_COUNTERS3;
 
-
+/* Switch Mac/Wol/Wof definitions */
 
 /*
  * typedef: struct GT_1000T_MASTER_SLAVE
@@ -3088,13 +3377,13 @@ typedef enum
  */
 typedef struct _GT_1000T_MASTER_SLAVE
 {
-	GT_BOOL	autoConfig;
-	GT_BOOL masterPrefer;
+    GT_BOOL    autoConfig;
+    GT_BOOL masterPrefer;
 } GT_1000T_MASTER_SLAVE;
 
 
-#define GT_MDI_PAIR_NUM     	4	/* (1,2),(3,6),(4,5),(7,8) */
-#define GT_CHANNEL_PAIR_NUM     2	/* (channel A,B),(channel C,D) */
+#define GT_MDI_PAIR_NUM         4    /* (1,2),(3,6),(4,5),(7,8) */
+#define GT_CHANNEL_PAIR_NUM     2    /* (channel A,B),(channel C,D) */
 
 
 /*
@@ -3103,15 +3392,15 @@ typedef struct _GT_1000T_MASTER_SLAVE
  * Description: Enumeration of Link Status
  *
  * Enumerations:
- *		GT_PHY_LINK_OFF		- No Link
- *		GT_PHY_LINK_COPPER	- Link on Copper
- *		GT_PHY_LINK_FIBER	- Link on Fiber
+ *        GT_PHY_LINK_OFF        - No Link
+ *        GT_PHY_LINK_COPPER    - Link on Copper
+ *        GT_PHY_LINK_FIBER    - Link on Fiber
  */
 typedef enum
 {
-	GT_PHY_LINK_OFF = 0,
-	GT_PHY_LINK_COPPER = 1,
-	GT_PHY_LINK_FIBER = 2
+    GT_PHY_LINK_OFF = 0,
+    GT_PHY_LINK_COPPER = 1,
+    GT_PHY_LINK_FIBER = 2
 } GT_PHY_LINK_STATUS;
 
 
@@ -3120,30 +3409,30 @@ typedef enum
 /* Payload */
 typedef enum
 {
-	GT_PG_PAYLOAD_RANDOM = 0,	/* Pseudo-random */
-	GT_PG_PAYLOAD_5AA5		/* 5A,A5,5A,A5,... */
+    GT_PG_PAYLOAD_RANDOM = 0,    /* Pseudo-random */
+    GT_PG_PAYLOAD_5AA5        /* 5A,A5,5A,A5,... */
 } GT_PG_PAYLOAD;
 
 /* Length */
 typedef enum
 {
-	GT_PG_LENGTH_64 = 0,		/* 64 bytes */
-	GT_PG_LENGTH_1514
+    GT_PG_LENGTH_64 = 0,        /* 64 bytes */
+    GT_PG_LENGTH_1514
 } GT_PG_LENGTH;
 
 /* Error */
 typedef enum
 {
-	GT_PG_TX_NORMAL = 0,		/* No Error */
-	GT_PG_TX_ERROR			/* Tx packets with CRC error and Symbol error */
+    GT_PG_TX_NORMAL = 0,        /* No Error */
+    GT_PG_TX_ERROR            /* Tx packets with CRC error and Symbol error */
 } GT_PG_TX;
 
 /* Structure for packet generator */
 typedef struct
 {
-	GT_PG_PAYLOAD  payload;
-	GT_PG_LENGTH   length;
-	GT_PG_TX       tx;
+    GT_PG_PAYLOAD  payload;
+    GT_PG_LENGTH   length;
+    GT_PG_TX       tx;
 } GT_PG;
 
 
@@ -3162,11 +3451,11 @@ typedef struct
  */
 typedef enum
 {
-	GT_TEST_FAIL,
-	GT_NORMAL_CABLE,
-	GT_IMPEDANCE_MISMATCH,
-	GT_OPEN_CABLE,
-	GT_SHORT_CABLE,
+    GT_TEST_FAIL,
+    GT_NORMAL_CABLE,
+    GT_IMPEDANCE_MISMATCH,
+    GT_OPEN_CABLE,
+    GT_SHORT_CABLE,
 } GT_TEST_STATUS;
 
 
@@ -3186,12 +3475,12 @@ typedef enum
  */
 typedef enum
 {
-	GT_LESS_THAN_50M,
-	GT_50M_80M,
-	GT_80M_110M,
-	GT_110M_140M,
-	GT_MORE_THAN_140,
-	GT_UNKNOWN_LEN,
+    GT_LESS_THAN_50M,
+    GT_50M_80M,
+    GT_80M_110M,
+    GT_110M_140M,
+    GT_MORE_THAN_140,
+    GT_UNKNOWN_LEN,
 
 } GT_NORMAL_CABLE_LEN;
 
@@ -3208,8 +3497,8 @@ typedef enum
  */
 typedef union
 {
-	GT_NORMAL_CABLE_LEN normCableLen;
-	GT_U8               errCableLen;
+    GT_NORMAL_CABLE_LEN normCableLen;
+    GT_U8               errCableLen;
 
 } GT_CABLE_LEN;
 
@@ -3221,13 +3510,13 @@ typedef union
  * Fields:
  *      cableStatus - VCT cable status.
  *      cableLen    - VCT cable length.
- *	phyType	    - type of phy (100M phy or Gigabit phy)
+ *    phyType        - type of phy (100M phy or Gigabit phy)
  */
 typedef struct
 {
-	GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
-	GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
-	GT_U16	    phyType;
+    GT_TEST_STATUS  cableStatus[GT_MDI_PAIR_NUM];
+    GT_CABLE_LEN    cableLen[GT_MDI_PAIR_NUM];
+    GT_U16        phyType;
 
 } GT_CABLE_STATUS;
 
@@ -3238,13 +3527,13 @@ typedef struct
  * Description: Enumeration of Cable Type
  *
  * Enumerations:
- *		GT_STRAIGHT_CABLE	_ straight cable
- *      GT_CROSSOVER_CABLE 	- crossover cable
+ *        GT_STRAIGHT_CABLE    _ straight cable
+ *      GT_CROSSOVER_CABLE     - crossover cable
  */
 typedef enum
 {
-	GT_STRAIGHT_CABLE,
-	GT_CROSSOVER_CABLE
+    GT_STRAIGHT_CABLE,
+    GT_CROSSOVER_CABLE
 
 } GT_CABLE_TYPE;
 
@@ -3255,10 +3544,10 @@ typedef enum
  * Description: Enumeration of Receiver Channel Assignment
  *
  * Enumerations:
- *		GT_CHANNEL_A   - Channel A
- *		GT_CHANNEL_B   - Channel B
- *		GT_CHANNEL_C   - Channel C
- *		GT_CHANNEL_D   - Channel D
+ *        GT_CHANNEL_A   - Channel A
+ *        GT_CHANNEL_B   - Channel B
+ *        GT_CHANNEL_C   - Channel C
+ *        GT_CHANNEL_D   - Channel D
  */
 typedef enum
 {
@@ -3268,20 +3557,19 @@ typedef enum
     GT_CHANNEL_D
 } GT_RX_CHANNEL;
 
-
 /*
  * typedef: enum GT_POLARITY_STATUS
  *
  * Description: Enumeration of polarity status
  *
  * Enumerations:
- *		GT_POSITIVE	- positive polarity
- *      GT_NEGATIVE	- negative polarity
+ *        GT_POSITIVE    - positive polarity
+ *      GT_NEGATIVE    - negative polarity
  */
 typedef enum
 {
-	GT_POSITIVE,
-	GT_NEGATIVE
+    GT_POSITIVE,
+    GT_NEGATIVE
 
 } GT_POLARITY_STATUS;
 
@@ -3290,45 +3578,44 @@ typedef enum
  * typedef: struct GT_1000BT_EXTENDED_STATUS
  *
  * Description: Currently the 1000Base-T PCS can determine the cable polarity
- * 		on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
- *		the pares. These status enhance the capability of the virtual cable tester
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
+ *        the pares. These status enhance the capability of the virtual cable tester
  *
  * Fields:
- *      isValid		- GT_TRUE if this structure have valid information, 
- * 					  GT_FALSE otherwise.
- *					  It is valid only if 1000BASE-T Link is up.
+ *      isValid        - GT_TRUE if this structure have valid information, 
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
  *      pairSwap    - GT_CROSSOVER_CABLE, if the cable is crossover,
- *					  GT_STRAIGHT_CABLE, otherwise
- *		pairPolarity- GT_POSITIVE, if polarity is positive,
- *					  GT_NEGATIVE, otherwise
- *		pairSkew	- pair skew in units of ns
+ *                      GT_STRAIGHT_CABLE, otherwise
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
  */
 typedef struct
 {
-	GT_BOOL				isValid;
-	GT_CABLE_TYPE		pairSwap[GT_CHANNEL_PAIR_NUM];
-	GT_POLARITY_STATUS	pairPolarity[GT_MDI_PAIR_NUM];
-	GT_U32			    pairSkew[GT_MDI_PAIR_NUM];
+    GT_BOOL                isValid;
+    GT_CABLE_TYPE        pairSwap[GT_CHANNEL_PAIR_NUM];
+    GT_POLARITY_STATUS    pairPolarity[GT_MDI_PAIR_NUM];
+    GT_U32                pairSkew[GT_MDI_PAIR_NUM];
 
 } GT_1000BT_EXTENDED_STATUS;
 
-
 /*
  * typedef: struct GT_ADV_EXTENDED_STATUS
  *
  * Description: Currently the 1000Base-T PCS can determine the cable polarity
- * 		on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
- *		the pares. These status enhance the capability of the virtual cable tester
+ *         on pairs A,B,C,D; crossover on pairs A,B and C,D; and skew among 
+ *        the pares. These status enhance the capability of the virtual cable tester
  *
  * Fields:
- *      isValid		- GT_TRUE if this structure have valid information, 
- * 					  GT_FALSE otherwise.
- *					  It is valid only if 1000BASE-T Link is up.
+ *      isValid        - GT_TRUE if this structure have valid information, 
+ *                       GT_FALSE otherwise.
+ *                      It is valid only if 1000BASE-T Link is up.
  *      pairSwap    - Receive channel assignement
- *		pairPolarity- GT_POSITIVE, if polarity is positive,
- *					  GT_NEGATIVE, otherwise
- *		pairSkew	- pair skew in units of ns
- *		cableLen	- cable length based on DSP
+ *        pairPolarity- GT_POSITIVE, if polarity is positive,
+ *                      GT_NEGATIVE, otherwise
+ *        pairSkew    - pair skew in units of ns
+ *        cableLen    - cable length based on DSP
  */
 typedef struct
 {
@@ -3336,7 +3623,7 @@ typedef struct
     GT_RX_CHANNEL      pairSwap[GT_MDI_PAIR_NUM];
     GT_POLARITY_STATUS pairPolarity[GT_MDI_PAIR_NUM];
     GT_U32             pairSkew[GT_MDI_PAIR_NUM];
-	GT_U32				cableLen[GT_MDI_PAIR_NUM];
+    GT_U32                cableLen[GT_MDI_PAIR_NUM];
 } GT_ADV_EXTENDED_STATUS;
 
 
@@ -3345,15 +3632,15 @@ typedef struct
  * will have only 2 pairs available.
  * One is RX Pair and the other is TX Pair.
  */
-#define MDI_RX_PAIR		0	/* cableStatus[0] or cableLen[0] */
-#define MDI_TX_PAIR		1	/* cableStatus[1] or cableLen[1] */
+#define MDI_RX_PAIR        0    /* cableStatus[0] or cableLen[0] */
+#define MDI_TX_PAIR        1    /* cableStatus[1] or cableLen[1] */
 
 /* definition for Phy Type */
-#define PHY_100M		0 /* 10/100M phy, E3082 or E3083 */
-#define PHY_1000M		1 /* Gigabit phy, the rest phys */
-#define PHY_10000M		2 /* 10 Gigabit phy, unused */
-#define PHY_1000M_B		3 /* Gigabit phy which needs work-around */
-#define PHY_1000M_MP	4 /* Gigabit phy with multiple page mode */
+#define PHY_100M        0 /* 10/100M phy, E3082 or E3083 */
+#define PHY_1000M        1 /* Gigabit phy, the rest phys */
+#define PHY_10000M        2 /* 10 Gigabit phy, unused */
+#define PHY_1000M_B        3 /* Gigabit phy which needs work-around */
+#define PHY_1000M_MP    4 /* Gigabit phy with multiple page mode */
 
 
 /* Definition for Advance Virtual Cable Test */
@@ -3364,38 +3651,38 @@ typedef struct
  * Description: Enumeration of Advanced VCT Transmitter channel select
  *
  * Enumerations:
- *		GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
- *		GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
  */
 typedef enum
 {
-	/* Advanced VCT Mode */
-    GT_ADV_VCT_TCS_NO_CROSSPAIR		= 0,
-    GT_ADV_VCT_TCS_CROSSPAIR_0		    = 0x4,
-    GT_ADV_VCT_TCS_CROSSPAIR_1		    = 0x5,
-    GT_ADV_VCT_TCS_CROSSPAIR_2		    = 0x6,
-    GT_ADV_VCT_TCS_CROSSPAIR_3		    = 0x7
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_TCS_NO_CROSSPAIR        = 0,
+    GT_ADV_VCT_TCS_CROSSPAIR_0            = 0x4,
+    GT_ADV_VCT_TCS_CROSSPAIR_1            = 0x5,
+    GT_ADV_VCT_TCS_CROSSPAIR_2            = 0x6,
+    GT_ADV_VCT_TCS_CROSSPAIR_3            = 0x7
 } GT_ADV_VCT_TRANS_CHAN_SEL;
 
 
 typedef enum
 {
-	/* Advanced VCT Mode */
-    GT_ADV_VCT_SAVG_2		= 0,
-    GT_ADV_VCT_SAVG_4		= 1,
-    GT_ADV_VCT_SAVG_8		= 2,
-    GT_ADV_VCT_SAVG_16		= 3,
-    GT_ADV_VCT_SAVG_32		= 4,
-    GT_ADV_VCT_SAVG_64		= 5,
-    GT_ADV_VCT_SAVG_128	= 6,
-    GT_ADV_VCT_SAVG_256	= 7
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_SAVG_2        = 0,
+    GT_ADV_VCT_SAVG_4        = 1,
+    GT_ADV_VCT_SAVG_8        = 2,
+    GT_ADV_VCT_SAVG_16        = 3,
+    GT_ADV_VCT_SAVG_32        = 4,
+    GT_ADV_VCT_SAVG_64        = 5,
+    GT_ADV_VCT_SAVG_128    = 6,
+    GT_ADV_VCT_SAVG_256    = 7
 } GT_ADV_VCT_SAMPLE_AVG;
 
 typedef enum
 {
-	/* Advanced VCT Mode */
-    GT_ADV_VCT_MAX_PEAK		=0x00,
-    GT_ADV_VCT_FIRST_PEAK		=0x01,
+    /* Advanced VCT Mode */
+    GT_ADV_VCT_MAX_PEAK        =0x00,
+    GT_ADV_VCT_FIRST_PEAK        =0x01,
 } GT_ADV_VCT_MOD;
 
 
@@ -3409,19 +3696,19 @@ typedef unsigned int GT_ADV_VCT_PEAKDET_HYST;
  * Enumerations:
  *      GT_ADV_VCT_FIRST_PEAK   - first peak above a certain threshold is reported.
  *      GT_ADV_VCT_MAX_PEAK     - maximum peak above a certain threshold is reported.
- *		GT_ADV_VCT_OFFSE	     - offset
- *		GT_ADV_VCT_SAMPLE_POINT - sample point
+ *        GT_ADV_VCT_OFFSE         - offset
+ *        GT_ADV_VCT_SAMPLE_POINT - sample point
  *
- *		GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
- *		GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
+ *        GT_ADV_VCT_NO_CROSSPAIR - Transmitter channel select is 000
+ *        GT_ADV_VCT_CROSSPAIR    - Transmitter channelselect is 100/101/110/111
  *   Example: mode = GT_ADV_VCT_FIRST_PEAK | GT_ADV_VCT_CROSSPAIR.
  */
 typedef struct
 {
-    GT_ADV_VCT_MOD					mode;
+    GT_ADV_VCT_MOD                    mode;
     GT_ADV_VCT_TRANS_CHAN_SEL      transChanSel;
-    GT_ADV_VCT_SAMPLE_AVG			sampleAvg;
-	GT_ADV_VCT_PEAKDET_HYST		peakDetHyst;
+    GT_ADV_VCT_SAMPLE_AVG            sampleAvg;
+    GT_ADV_VCT_PEAKDET_HYST        peakDetHyst;
 } GT_ADV_VCT_MODE;
 
 
@@ -3439,9 +3726,9 @@ typedef struct
  *                             cable lengh is valid.
  *      GT_ADV_VCT_IMP_LESS_THAN_85 - impedance mismatch < 85 ohms
  *                             cable lengh is valid.
- *      GT_ADV_VCT_OPEN 	 - cable open
+ *      GT_ADV_VCT_OPEN      - cable open
  *                             cable lengh is valid.
- *      GT_ADV_VCT_SHORT 	 - cable shorted
+ *      GT_ADV_VCT_SHORT      - cable shorted
  *                             cable lengh is valid.
  *      GT_ADV_VCT_CROSS_PAIR_SHORT - cross pair short.
  *                             cable lengh for each channel is valid.
@@ -3492,7 +3779,7 @@ typedef struct _GT_CROSS_SHORT_LIST
  *                      GT_ADV_VCT_IMP_GREATER_THAN_115
  *                      GT_ADV_VCT_IMP_LESS_THAN_85,
  *                      GT_ADV_VCT_OPEN, or
- *						GT_ADV_VCT_SHORT
+ *                        GT_ADV_VCT_SHORT
   */
 typedef struct
 {
@@ -3506,52 +3793,52 @@ typedef struct
 
 /*
  * Definition:
- *		GT_LED_LINK_ACT_SPEED 	- off = no link, on = link, blink = activity, blink speed = link speed
- *		GT_LED_LINK_ACT	 		- off = no link, on = link, blink = activity
- *		GT_LED_LINK		 		- off = no link, on = link
- *		GT_LED_10_LINK_ACT		- off = no link, on = 10, blink = activity
- *		GT_LED_10_LINK			- off = no link, on = 10
- *		GT_LED_100_LINK_ACT		- off = no link, on = 100 link, blink = activity
- *		GT_LED_100_LINK			- off = no link, on = 100 link
- *		GT_LED_1000_LINK_ACT	- off = no link, on = 1000 link, blink = activity
- *		GT_LED_1000_LINK		- off = no link, on = 1000 link
- *		GT_LED_10_100_LINK_ACT	- off = no link, on = 10 or 100 link, blink = activity
- *		GT_LED_10_100_LINK		- off = no link, on = 10 or 100 link
- *		GT_LED_10_1000_LINK_ACT	- off = no link, on = 10 or 1000 link, blink = activity
- *		GT_LED_10_1000_LINK		- off = no link, on = 10 or 1000 link
- *		GT_LED_100_1000_LINK_ACT- off = no link, on = 100 or 1000 link, blink = activity
- *		GT_LED_100_1000_LINK	- off = no link, on = 100 or 1000 link
- *		GT_LED_SPECIAL			- special leds
- *		GT_LED_DUPLEX_COL		- off = half duplx, on = full duplex, blink = collision
- *		GT_LED_ACTIVITY			- off = no link, blink on = activity
- *		GT_LED_PTP_ACT			- blink on = PTP activity
- *		GT_LED_FORCE_BLINK		- force blink
- *		GT_LED_FORCE_OFF		- force off
- *		GT_LED_FORCE_ON			- force on
+ *        GT_LED_LINK_ACT_SPEED     - off = no link, on = link, blink = activity, blink speed = link speed
+ *        GT_LED_LINK_ACT             - off = no link, on = link, blink = activity
+ *        GT_LED_LINK                 - off = no link, on = link
+ *        GT_LED_10_LINK_ACT        - off = no link, on = 10, blink = activity
+ *        GT_LED_10_LINK            - off = no link, on = 10
+ *        GT_LED_100_LINK_ACT        - off = no link, on = 100 link, blink = activity
+ *        GT_LED_100_LINK            - off = no link, on = 100 link
+ *        GT_LED_1000_LINK_ACT    - off = no link, on = 1000 link, blink = activity
+ *        GT_LED_1000_LINK        - off = no link, on = 1000 link
+ *        GT_LED_10_100_LINK_ACT    - off = no link, on = 10 or 100 link, blink = activity
+ *        GT_LED_10_100_LINK        - off = no link, on = 10 or 100 link
+ *        GT_LED_10_1000_LINK_ACT    - off = no link, on = 10 or 1000 link, blink = activity
+ *        GT_LED_10_1000_LINK        - off = no link, on = 10 or 1000 link
+ *        GT_LED_100_1000_LINK_ACT- off = no link, on = 100 or 1000 link, blink = activity
+ *        GT_LED_100_1000_LINK    - off = no link, on = 100 or 1000 link
+ *        GT_LED_SPECIAL            - special leds
+ *        GT_LED_DUPLEX_COL        - off = half duplx, on = full duplex, blink = collision
+ *        GT_LED_ACTIVITY            - off = no link, blink on = activity
+ *        GT_LED_PTP_ACT            - blink on = PTP activity
+ *        GT_LED_FORCE_BLINK        - force blink
+ *        GT_LED_FORCE_OFF        - force off
+ *        GT_LED_FORCE_ON            - force on
 */
-#define GT_LED_LINK_ACT_SPEED		1
-#define GT_LED_LINK_ACT			2
-#define GT_LED_LINK				3
-#define GT_LED_10_LINK_ACT			4
-#define GT_LED_10_LINK				5
-#define GT_LED_100_LINK_ACT		6
-#define GT_LED_100_LINK			7
-#define GT_LED_1000_LINK_ACT		8
-#define GT_LED_1000_LINK			9
-#define GT_LED_10_100_LINK_ACT		10
-#define GT_LED_10_100_LINK			11
-#define GT_LED_10_1000_LINK_ACT	12
-#define GT_LED_10_1000_LINK		13
-#define GT_LED_100_1000_LINK_ACT	14
-#define GT_LED_100_1000_LINK		15
-#define GT_LED_SPECIAL				16
-#define GT_LED_DUPLEX_COL			17
-#define GT_LED_ACTIVITY			18
-#define GT_LED_PTP_ACT				19
-#define GT_LED_FORCE_BLINK			20
-#define GT_LED_FORCE_OFF			21
-#define GT_LED_FORCE_ON			22
-#define GT_LED_RESERVE				23
+#define GT_LED_LINK_ACT_SPEED        1
+#define GT_LED_LINK_ACT            2
+#define GT_LED_LINK                3
+#define GT_LED_10_LINK_ACT            4
+#define GT_LED_10_LINK                5
+#define GT_LED_100_LINK_ACT        6
+#define GT_LED_100_LINK            7
+#define GT_LED_1000_LINK_ACT        8
+#define GT_LED_1000_LINK            9
+#define GT_LED_10_100_LINK_ACT        10
+#define GT_LED_10_100_LINK            11
+#define GT_LED_10_1000_LINK_ACT    12
+#define GT_LED_10_1000_LINK        13
+#define GT_LED_100_1000_LINK_ACT    14
+#define GT_LED_100_1000_LINK        15
+#define GT_LED_SPECIAL                16
+#define GT_LED_DUPLEX_COL            17
+#define GT_LED_ACTIVITY            18
+#define GT_LED_PTP_ACT                19
+#define GT_LED_FORCE_BLINK            20
+#define GT_LED_FORCE_OFF            21
+#define GT_LED_FORCE_ON            22
+#define GT_LED_RESERVE                23
 
 
 /*
@@ -3560,23 +3847,23 @@ typedef struct
  * Description: Enumeration for LED configuration type
  *
  * Enumerations:
- *		GT_LED_CFG_LED0		- read/write led0 value (GT_LED_xxx definition)
- *		GT_LED_CFG_LED1		- read/write led1 value
- *		GT_LED_CFG_LED2		- read/write led2 value
- *		GT_LED_CFG_LED3		- read/write led3 value
- *		GT_LED_CFG_PULSE_STRETCH	- read/write pulse stretch (0 ~ 4)
- *		GT_LED_CFG_BLINK_RATE		- read/write blink rate	(0 ~ 5)
- *		GT_LED_CFG_SPECIAL_CONTROL	- read/write special control (port vector)
- */
-typedef enum
-{
-	GT_LED_CFG_LED0,
-	GT_LED_CFG_LED1,
-	GT_LED_CFG_LED2,
-	GT_LED_CFG_LED3,
-	GT_LED_CFG_PULSE_STRETCH,
-	GT_LED_CFG_BLINK_RATE,
-	GT_LED_CFG_SPECIAL_CONTROL
+ *        GT_LED_CFG_LED0        - read/write led0 value (GT_LED_xxx definition)
+ *        GT_LED_CFG_LED1        - read/write led1 value
+ *        GT_LED_CFG_LED2        - read/write led2 value
+ *        GT_LED_CFG_LED3        - read/write led3 value
+ *        GT_LED_CFG_PULSE_STRETCH    - read/write pulse stretch (0 ~ 4)
+ *        GT_LED_CFG_BLINK_RATE        - read/write blink rate    (0 ~ 5)
+ *        GT_LED_CFG_SPECIAL_CONTROL    - read/write special control (port vector)
+ */
+typedef enum
+{
+    GT_LED_CFG_LED0,
+    GT_LED_CFG_LED1,
+    GT_LED_CFG_LED2,
+    GT_LED_CFG_LED3,
+    GT_LED_CFG_PULSE_STRETCH,
+    GT_LED_CFG_BLINK_RATE,
+    GT_LED_CFG_SPECIAL_CONTROL
 } GT_LED_CFG;
 
 
@@ -3586,27 +3873,27 @@ typedef enum
  * Description: Enumeration for recovered clock type
  *
  * Enumerations:
- *		GT_PRIMARY_RECOVERED_CLOCK 		- primary recovered clock
- *		GT_SECONDARY_RECOVERED_CLOCK 	- secondary recovered clock
+ *        GT_PRIMARY_RECOVERED_CLOCK         - primary recovered clock
+ *        GT_SECONDARY_RECOVERED_CLOCK     - secondary recovered clock
  */
 typedef enum
 {
-	GT_PRIMARY_RECOVERED_CLOCK,
-	GT_SECONDARY_RECOVERED_CLOCK
+    GT_PRIMARY_RECOVERED_CLOCK,
+    GT_SECONDARY_RECOVERED_CLOCK
 } GT_AVB_RECOVERED_CLOCK;
 
 
 /* Define QAV interrupt bits */
 
-#define GT_QAV_INT_STATUS_ENQ_LMT_BIT			0x8000	/* EnQ Limit Interrupt Enable */
-#define GT_QAV_INT_STATUS_ISO_DEL_BIT			0x0400	/* Iso Delay Interrupt Enable */
-#define GT_QAV_INT_STATUS_ISO_DIS_BIT			0x0200  /* Iso Discard Interrupt Enable */
-#define GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT		0x0100  /* Iso Packet Memory Exceeded Interrupt Enable */
+#define GT_QAV_INT_STATUS_ENQ_LMT_BIT            0x8000    /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DEL_BIT            0x0400    /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_DIS_BIT            0x0200  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT        0x0100  /* Iso Packet Memory Exceeded Interrupt Enable */
 
-#define GT_QAV_INT_ENABLE_ENQ_LMT_BIT			0x80  /* EnQ Limit Interrupt Enable */
-#define GT_QAV_INT_ENABLE_ISO_DEL_BIT			0x04  /* Iso Delay Interrupt Enable */
-#define GT_QAV_INT_ENABLE_ISO_DIS_BIT			0x02  /* Iso Discard Interrupt Enable */
-#define GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT		0x01  /* Iso Packet Memory Exceeded Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ENQ_LMT_BIT            0x80  /* EnQ Limit Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DEL_BIT            0x04  /* Iso Delay Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_DIS_BIT            0x02  /* Iso Discard Interrupt Enable */
+#define GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT        0x01  /* Iso Packet Memory Exceeded Interrupt Enable */
 
 
 /*
@@ -3615,17 +3902,17 @@ typedef enum
  * Description: Defines the EEPROM Operation type
  *
  * Fields:
- *      PTP_WRITE_DATA 			- Write data to the EEPROM register
- *      PTP_READ_DATA			- Read data from EEPROM register
- *      PTP_RESTART				- Restart EEPROM oprition
+ *      PTP_WRITE_DATA             - Write data to the EEPROM register
+ *      PTP_READ_DATA            - Read data from EEPROM register
+ *      PTP_RESTART                - Restart EEPROM oprition
  */
 typedef enum
 {
-	GT_EEPROM_NO_OP		 			= 0x0,
-	GT_EEPROM_WRITE_DATA 			= 0x3,
-	GT_EEPROM_READ_DATA  			= 0x4,
-	GT_EEPROM_RESTART				= 0x6,
-	GT_EEPROM_HALT					= 0x7,
+    GT_EEPROM_NO_OP                     = 0x0,
+    GT_EEPROM_WRITE_DATA             = 0x3,
+    GT_EEPROM_READ_DATA              = 0x4,
+    GT_EEPROM_RESTART                = 0x6,
+    GT_EEPROM_HALT                    = 0x7,
 } GT_EEPROM_OPERATION;
 
 
@@ -3635,111 +3922,111 @@ typedef enum
  *  Description: data required by EEPROM Operation
  *
  *  Fields:
- *      eepromPort		- physical port of the device
- *      eepromAddr 	- register address
- *      eepromData 	- data for ptp register.
+ *      eepromPort        - physical port of the device
+ *      eepromAddr     - register address
+ *      eepromData     - data for ptp register.
  */
 typedef struct
 {
-	GT_U32	eepromPort;
-	GT_U32	eepromBlock;
-	GT_U32	eepromAddr;
-	GT_U32	eepromData;
+    GT_U32    eepromPort;
+    GT_U32    eepromBlock;
+    GT_U32    eepromAddr;
+    GT_U32    eepromData;
 } GT_EEPROM_OP_DATA;
 
-#define GT_EEPROM_OP_ST_RUNNING_MASK		0x800
-#define GT_EEPROM_OP_ST_WRITE_EN_MASK		0x400
-
-#define GT_SCRAT_MISC_REG_SCRAT_0	0x00 /* Scratch Byte 0 */
-#define GT_SCRAT_MISC_REG_SCRAT_1	0x01 /* Scratch Byte 1 */
-#define GT_SCRAT_MISC_REG_GPIO_CFG	0x60 /* GPIO Configuration */
-										 /* 0x61 = Reserved for future use */
-#define GT_SCRAT_MISC_REG_GPIO_DIR	0x62 /* GPIO Direction */
-#define GT_SCRAT_MISC_REG_GPIO_DAT	0x63 /* GPIO Data */
-#define GT_SCRAT_MISC_REG_CFG_DAT0	0x70 /* CONFIG Data 0 */
-#define GT_SCRAT_MISC_REG_CFG_DAT1	0x71 /* CONFIG Data 1 */
-#define GT_SCRAT_MISC_REG_CFG_DAT2	0x72 /* CONFIG Data 2 */
-#define GT_SCRAT_MISC_REG_CFG_DAT3	0x73 /* CONFIG Data 3 */
-#define GT_SCRAT_MISC_REG_SYNCE		0x7C /* SyncE & TAICLK125s Drive */
-#define GT_SCRAT_MISC_REG_P5_CLK	0x7D /* P5s & CLK125s Clock Drive */
-#define GT_SCRAT_MISC_REG_P6_CLK	0x7E /* P6s Clock Drive */
-#define GT_SCRAT_MISC_REG_EEPROM	0x7F /* EEPROM Pad drive */
-#define GT_SCRAT_MISC_REG_MAX		0x80 /* Maximun register pointer */
-
-#define GT_GPIO_BIT_0	0x1
-#define GT_GPIO_BIT_1	0x2
-#define GT_GPIO_BIT_2	0x4
-#define GT_GPIO_BIT_3	0x8
-#define GT_GPIO_BIT_4	0x10
-#define GT_GPIO_BIT_5	0x20
-#define GT_GPIO_BIT_6	0x40
+#define GT_EEPROM_OP_ST_RUNNING_MASK        0x800
+#define GT_EEPROM_OP_ST_WRITE_EN_MASK        0x400
+
+#define GT_SCRAT_MISC_REG_SCRAT_0    0x00 /* Scratch Byte 0 */
+#define GT_SCRAT_MISC_REG_SCRAT_1    0x01 /* Scratch Byte 1 */
+#define GT_SCRAT_MISC_REG_GPIO_CFG    0x60 /* GPIO Configuration */
+                                         /* 0x61 = Reserved for future use */
+#define GT_SCRAT_MISC_REG_GPIO_DIR    0x62 /* GPIO Direction */
+#define GT_SCRAT_MISC_REG_GPIO_DAT    0x63 /* GPIO Data */
+#define GT_SCRAT_MISC_REG_CFG_DAT0    0x70 /* CONFIG Data 0 */
+#define GT_SCRAT_MISC_REG_CFG_DAT1    0x71 /* CONFIG Data 1 */
+#define GT_SCRAT_MISC_REG_CFG_DAT2    0x72 /* CONFIG Data 2 */
+#define GT_SCRAT_MISC_REG_CFG_DAT3    0x73 /* CONFIG Data 3 */
+#define GT_SCRAT_MISC_REG_SYNCE        0x7C /* SyncE & TAICLK125s Drive */
+#define GT_SCRAT_MISC_REG_P5_CLK    0x7D /* P5s & CLK125s Clock Drive */
+#define GT_SCRAT_MISC_REG_P6_CLK    0x7E /* P6s Clock Drive */
+#define GT_SCRAT_MISC_REG_EEPROM    0x7F /* EEPROM Pad drive */
+#define GT_SCRAT_MISC_REG_MAX        0x80 /* Maximun register pointer */
+
+#define GT_GPIO_BIT_0    0x1
+#define GT_GPIO_BIT_1    0x2
+#define GT_GPIO_BIT_2    0x4
+#define GT_GPIO_BIT_3    0x8
+#define GT_GPIO_BIT_4    0x10
+#define GT_GPIO_BIT_5    0x20
+#define GT_GPIO_BIT_6    0x40
 
 typedef struct
 {
-	GT_U8         user : 3;
-	GT_U8         addr : 5;
+    GT_U8         user : 3;
+    GT_U8         addr : 5;
 }GT_CONFIG_DATA_0;
 
 typedef struct
 {
-	GT_U8         led  : 2;
-	GT_U8         fourcol : 1;
-	GT_U8         normCx : 1;
-	GT_U8         jumbo : 1;
-	GT_U8         ee_we : 1;
-	GT_U8         fd_flow : 1;
-	GT_U8         hd_flow : 1;
+    GT_U8         led  : 2;
+    GT_U8         fourcol : 1;
+    GT_U8         normCx : 1;
+    GT_U8         jumbo : 1;
+    GT_U8         ee_we : 1;
+    GT_U8         fd_flow : 1;
+    GT_U8         hd_flow : 1;
 }GT_CONFIG_DATA_1;
 
 typedef struct
 {
-	GT_U8         p5_mod : 3;
-	GT_U8         bit4	 : 1;
-	GT_U8         p6_mod : 3;
+    GT_U8         p5_mod : 3;
+    GT_U8         bit4     : 1;
+    GT_U8         p6_mod : 3;
 }GT_CONFIG_DATA_2;
 
 typedef struct
 {
-	GT_U8         rmu_mod : 2;
+    GT_U8         rmu_mod : 2;
 }GT_CONFIG_DATA_3;
 
 typedef struct
 {
-	union {
-		GT_U8				Byte;
-		GT_CONFIG_DATA_0	Data;
-	} cfgData0;
-	union {
-		GT_U8				Byte;
-		GT_CONFIG_DATA_0	Data;
-	} cfgData1;
-	union {
-		GT_U8				Byte;
-		GT_CONFIG_DATA_0	Data;
-	} cfgData2;
-	union {
-		GT_U8				Byte;
-		GT_CONFIG_DATA_0	Data;
-	} cfgData3;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData0;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData1;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData2;
+    union {
+        GT_U8                Byte;
+        GT_CONFIG_DATA_0    Data;
+    } cfgData3;
 }GT_CONFIG_DATA;
 
 
 /* definition for Trunking */
-#define IS_TRUNK_ID_VALID(_dev, _id)	(((_id) < 16) ? 1 : 0)
+#define IS_TRUNK_ID_VALID(_dev, _id)    (((_id) < 16) ? 1 : 0)
 
 
 /* definition for device scan mode */
-#define SMI_AUTO_SCAN_MODE		0	/* Scan 0 or 0x10 base address to find the QD */
-#define SMI_MANUAL_MODE			1	/* Use QD located at manually defined base addr */
-#define SMI_MULTI_ADDR_MODE		2	/* Use QD at base addr and use indirect access */
+#define SMI_AUTO_SCAN_MODE        0    /* Scan 0 or 0x10 base address to find the QD */
+#define SMI_MANUAL_MODE            1    /* Use QD located at manually defined base addr */
+#define SMI_MULTI_ADDR_MODE        2    /* Use QD at base addr and use indirect access */
 typedef struct
 {
-	GT_U32	scanMode;	/* check definition for device scan mode */
-	GT_U32	baseAddr;	/* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
+    GT_U32    scanMode;    /* check definition for device scan mode */
+    GT_U32    baseAddr;    /* meaningful if scanMode is not SMI_AUTO_SCAN_MODE */
 } GT_SCAN_MODE;
 
 
-#define GT_SKIP_INIT_SETUP	0x736b6970
+#define GT_SKIP_INIT_SETUP    0x736b6970
 
 /*
  * Typedef: struct GT_SYS_CONFIG
@@ -3747,7 +4034,7 @@ typedef struct
  * Description: System configuration Parameters struct.
  *
  * Fields:
- *	devNum		- Switch Device Number 
+ *    devNum        - Switch Device Number 
  *  cpuPortNum  - The physical port used to connect the device to CPU.
  *                This is the port to which packets destined to CPU are
  *                forwarded.
@@ -3756,21 +4043,27 @@ typedef struct
  *                GT_TRUE     - Initialize to Forwarding state.
  *  skipInitSetup - skip init setup, if value is GT_SKIP_INIT_SETUP
  *                  perform init setup, otherwise
- *	                Initializing port state is not affected by this variable.
- *	BSPFunctions	- Group of BSP specific functions.
- *				SMI Read/Write and Semaphore Related functions.
+ *                    Initializing port state is not affected by this variable.
+ *    BSPFunctions    - Group of BSP specific functions.
+ *                SMI Read/Write and Semaphore Related functions.
  */
 typedef struct
 {
-	GT_U8         devNum;
-	GT_U8         cpuPortNum;
-	GT_BOOL       initPorts;
-	BSP_FUNCTIONS BSPFunctions;
-	GT_SCAN_MODE  mode;
-	GT_U32        skipInitSetup;
+    GT_U8         devNum;
+    GT_U8         cpuPortNum;
+    GT_BOOL       initPorts;
+    BSP_FUNCTIONS BSPFunctions;
+    GT_SCAN_MODE  mode;
+    GT_U32        skipInitSetup;
 }GT_SYS_CONFIG;
 
-
+#ifdef GT_RMGMT_ACCESS
+typedef enum
+{
+ HW_ACCESS_MODE_SMI = 0,    /* Use SMI */
+ HW_ACCESS_MODE_F2R = 1,    /* Use Marvell RMGMT(F2R) function */
+} FGT_HW_ACCESS_MOD;    /* Hardware access mode */
+#endif
 
 /*
  * Typedef: struct GT_QD_DEV
@@ -3786,14 +4079,15 @@ typedef struct
  *   cpuPortNum     - Logical port number whose physical port is connected to the CPU.
  *   maxPhyNum      - max configurable Phy address.
  *   stpMode        - current switch STP mode (0 none, 1 en, 2 dis)
- *   accessMode	    - shows how to find and access the device.
+ *   accessMode        - shows how to find and access the device.
  *   phyAddr        - SMI address used to access Switch registers(only for SMI_MULTI_ADDR_MODE).
  *   validPortVec   - valid port list in vector format
- *   validPhyVec	- valid phy list in vector format
- *   validSerdesVec	- valid serdes list in vector format
- *   devGroup	    - the device group
- *   devName	    - name of the device
- *   devStorage	    - driver internal use (hold various temp information)
+ *   validPhyVec    - valid phy list in vector format
+ *   validSerdesVec    - valid serdes list in vector format
+ *   devGroup        - the device group
+ *   devName        - name of the device in group 0
+ *   devName1        - name of the device in group 1
+ *   devStorage        - driver internal use (hold various temp information)
  *   multiAddrSem   - Semaphore for Accessing SMI Device
  *   atuRegsSem     - Semaphore for ATU access
  *   vtuRegsSem     - Semaphore for VTU access
@@ -3804,8 +4098,11 @@ typedef struct
  *                    such as Trunk Tables and Device Table
  *   eepromRegsSem  - Semaphore for eeprom control access
  *   phyRegsSem     - Semaphore for PHY Device access
+ *   hwAccessRegsSem - Semaphore for Remote management access
+ *   fgtHwAccessMod - Select register access mode: Read/Write or Hardware access function
  *   fgtReadMii     - platform specific SMI register Read function
  *   fgtWriteMii    - platform specific SMI register Write function
+ *   fgtHwAccess    - platform specific register access function
  *   semCreate      - function to create semapore
  *   semDelete      - function to delete the semapore
  *   semTake        - function to get a semapore
@@ -3814,47 +4111,67 @@ typedef struct
  */
 struct _GT_QD_DEV
 {
-	GT_DEVICE   deviceId;
-	GT_LPORT    cpuPortNum;
-	GT_U8       revision;
-	GT_U8		devNum;
-	GT_U8		devEnabled;
-	GT_U8       baseRegAddr;
-	GT_U8       numOfPorts;
-	GT_U8		maxPorts;
-	GT_U8       maxPhyNum;
-	GT_U8		stpMode;
-	GT_U8		accessMode;
-	GT_U8		phyAddr;
-	GT_U16		reserved;
-	GT_U16		validPortVec;
-	GT_U16		validPhyVec;
-	GT_U16		validSerdesVec;
-	GT_U16		devGroup;
-	GT_U32		devName;
-	GT_U32		devStorage;
-	GT_SEM		multiAddrSem;
-	GT_SEM		atuRegsSem;
-	GT_SEM		vtuRegsSem;
-	GT_SEM		statsRegsSem;
-	GT_SEM		pirlRegsSem;
-	GT_SEM		ptpRegsSem;
-	GT_SEM		tblRegsSem;
-	GT_SEM		eepromRegsSem;
-	GT_SEM		phyRegsSem;
-
-	FGT_READ_MII 	fgtReadMii;
-	FGT_WRITE_MII 	fgtWriteMii;
-
-	FGT_SEM_CREATE	semCreate; 	/* create semaphore */
-	FGT_SEM_DELETE	semDelete; 	/* delete the semaphore */
-	FGT_SEM_TAKE	semTake;	/* try to get a semaphore */
-	FGT_SEM_GIVE	semGive;	/* return semaphore */
-	void*		appData;
+    GT_DEVICE   deviceId;
+    GT_LPORT    cpuPortNum;
+    GT_U8       revision;
+    GT_U8        devNum;
+    GT_U8        devEnabled;
+    GT_U8       baseRegAddr;
+    GT_U8       numOfPorts;
+    GT_U8        maxPorts;
+    GT_U8       maxPhyNum;
+    GT_U8        stpMode;
+    GT_U8        accessMode;
+    GT_U8        phyAddr;
+    GT_U16        reserved;
+    GT_U16        validPortVec;
+    GT_U16        validPhyVec;
+    GT_U16        validSerdesVec;
+    GT_U16        devGroup;
+    GT_U32        devName;
+    GT_U32        devName1;
+    GT_U32        devStorage;
+    GT_SEM        multiAddrSem;
+    GT_SEM        atuRegsSem;
+    GT_SEM        vtuRegsSem;
+    GT_SEM        statsRegsSem;
+    GT_SEM        pirlRegsSem;
+    GT_SEM        ptpRegsSem;
+    GT_SEM        tblRegsSem;
+    GT_SEM        eepromRegsSem;
+    GT_SEM        phyRegsSem;
+    GT_SEM        hwAccessRegsSem;
+
+    FGT_READ_MII  fgtReadMii;
+    FGT_WRITE_MII fgtWriteMii;
+#ifdef GT_RMGMT_ACCESS
+    FGT_HW_ACCESS_MOD fgtHwAccessMod;    /* Hardware access mode */
+    FGT_HW_ACCESS fgtHwAccess;    /* Hardware access  */
+#endif
+
+    FGT_SEM_CREATE  semCreate;     /* create semaphore */
+    FGT_SEM_DELETE  semDelete;     /* delete the semaphore */
+    FGT_SEM_TAKE    semTake;    /* try to get a semaphore */
+    FGT_SEM_GIVE    semGive;    /* return semaphore */
+    void*           appData;
+
+    /* Modified to add port mapping functions into device ssystem configuration. */
+#ifdef GT_PORT_MAP_IN_DEV
+    GT_U8           (*lport2port)   (GT_U16 portVec, GT_LPORT port);
+    GT_LPORT        (*port2lport)   (GT_U16 portVec, GT_U8 hwPort);
+    GT_U32          (*lportvec2portvec) (GT_U16 portVec, GT_U32 lVec);
+    GT_U32          (*portvec2lportvec) (GT_U16 portVec, GT_U32 pVec);
+#endif
 
+    GT_BOOL       use_mad;     /* use MAD driver to process Phy */
+#ifdef GT_USE_MAD 
+	MAD_DEV	mad_dev;
+#endif
 };
 
 
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiMadConfig.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiMadConfig.h
deleted file mode 100644
index 5d8f451..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiMadConfig.h
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <Copyright.h>
-
-/********************************************************************************
-* msApiMadConfig.h
-*
-* DESCRIPTION:
-*       Marvell Alaska Device (MAD) Configuration header file
-*       If DSDT does not need to load MAD driver for internal Gigabit Phy,
-*       MAD_INCLUDE should be undefined.
-*
-* DEPENDENCIES:
-*
-* FILE REVISION NUMBER:
-*
-*******************************************************************************/
-
-#ifndef __msApiMadConfig_h
-#define __msApiMadConfig_h
-
-#define MAD_INCLUDE
-
-/*
- * uncomment the following #undef for DSDT not to include MAD
-*/
-/* #undef MAD_INCLUDE */
-
-#ifdef MAD_INCLUDE
-#include <madApi.h>
-#endif
-
-#endif /* __msApiMadConfig_h */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiPrototype.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiPrototype.h
old mode 100644
new mode 100755
index 1fa3e14..a44e407
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiPrototype.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiPrototype.h
@@ -32,7 +32,7 @@ extern "C" {
 *       size    - Mac address table size.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -88,8 +88,8 @@ GT_STATUS gfdbGetAgingTimeRange
 * DESCRIPTION:
 *       Gets the timeout period in seconds for aging out dynamically learned
 *       forwarding information. The returned value may not be the same as the value
-*		programmed with <gfdbSetAgingTimeout>. Please refer to the description of
-*		<gfdbSetAgingTimeout>.
+*        programmed with <gfdbSetAgingTimeout>. Please refer to the description of
+*        <gfdbSetAgingTimeout>.
 *
 * INPUTS:
 *       None.
@@ -119,14 +119,14 @@ GT_STATUS gfdbGetAgingTimeout
 * DESCRIPTION:
 *       Sets the timeout period in seconds for aging out dynamically learned
 *       forwarding information. The standard recommends 300 sec.
-*		Supported aging timeout values are multiple of time-base, where time-base
-*		is either 15 or 16 seconds, depending on the Switch device. For example,
-*		88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
-*		48,..., and 4080. If unsupported timeout value (bigger than 16) is used, 
-*		the value will be rounded to the nearest supported value smaller than the 
-*		given timeout. If the given timeout is less than 16, minimum timeout value
-*		16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
-*		<gfdbGetAgingTimeRange> function can be used to find the time-base.
+*        Supported aging timeout values are multiple of time-base, where time-base
+*        is either 15 or 16 seconds, depending on the Switch device. For example,
+*        88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
+*        48,..., and 4080. If unsupported timeout value (bigger than 16) is used, 
+*        the value will be rounded to the nearest supported value smaller than the 
+*        given timeout. If the given timeout is less than 16, minimum timeout value
+*        16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
+*        <gfdbGetAgingTimeRange> function can be used to find the time-base.
 *
 * INPUTS:
 *       timeout - aging time in seconds.
@@ -204,11 +204,11 @@ GT_STATUS gfdbGetAtuDynamicCount
 * COMMENTS:
 *       Search starts from Mac[00:00:00:00:00:00]
 *
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbGetAtuEntryFirst
@@ -240,11 +240,11 @@ GT_STATUS gfdbGetAtuEntryFirst
 *       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
 *       user.
 *
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbGetAtuEntryNext
@@ -274,11 +274,11 @@ GT_STATUS gfdbGetAtuEntryNext
 *       GT_NO_SUCH - no more entries.
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbFindAtuMacEntry
@@ -325,11 +325,11 @@ GT_STATUS gfdbFlush
 * DESCRIPTION:
 *       This routine flush all or unblocked addresses from the particular
 *       ATU Database (DBNum). If multiple address databases are being used, this
-*		API can be used to flush entries in a particular DBNum database.
+*        API can be used to flush entries in a particular DBNum database.
 *
 * INPUTS:
 *       flushCmd - the flush operation type.
-*		DBNum	 - ATU MAC Address Database Number. 
+*        DBNum     - ATU MAC Address Database Number. 
 *
 * OUTPUTS:
 *       None
@@ -348,7 +348,7 @@ GT_STATUS gfdbFlushInDB
 (
     IN GT_QD_DEV *dev,
     IN GT_FLUSH_CMD flushCmd,
-	IN GT_U32 DBNum
+    IN GT_U32 DBNum
 );
 
 /*******************************************************************************
@@ -370,11 +370,11 @@ GT_STATUS gfdbFlushInDB
 *       GT_OUT_OF_CPU_MEM - oaMalloc failed
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 * GalTis:
 *
@@ -436,11 +436,11 @@ GT_STATUS gfdbDelMacEntry
 *       GT_NO_SUCH      - if specified address entry does not exist
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbDelAtuEntry
@@ -493,7 +493,7 @@ GT_STATUS gfdbLearnEnable
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -729,23 +729,23 @@ GT_STATUS gprtGetVlanTunnel
 * gprtSetIGMPSnoop
 *
 * DESCRIPTION:
-* 		This routine set the IGMP Snoop. When set to one and this port receives
-*		IGMP frame, the frame is switched to the CPU port, overriding all other 
-*		switching decisions, with exception for CPU's Trailer.
-*		CPU port is determined by the Ingress Mode bits. A port is considered 
-*		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
-*		GT_CPUPORT_INGRESS.
+*         This routine set the IGMP Snoop. When set to one and this port receives
+*        IGMP frame, the frame is switched to the CPU port, overriding all other 
+*        switching decisions, with exception for CPU's Trailer.
+*        CPU port is determined by the Ingress Mode bits. A port is considered 
+*        the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+*        GT_CPUPORT_INGRESS.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS: 
 *
@@ -763,18 +763,18 @@ GT_STATUS gprtSetIGMPSnoop
 * gprtGetIGMPSnoop
 *
 * DESCRIPTION:
-*		This routine get the IGMP Snoop mode.
+*        This routine get the IGMP Snoop mode.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: IGMP Snoop enabled
-*  			GT_FALSE otherwise
+*        mode - GT_TRUE: IGMP Snoop enabled
+*              GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -794,18 +794,18 @@ GT_STATUS gprtGetIGMPSnoop
 * gprtSetHeaderMode
 *
 * DESCRIPTION:
-*		This routine set ingress and egress header mode of a switch port. 
+*        This routine set ingress and egress header mode of a switch port. 
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for header mode  or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for header mode  or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS: 
 *
@@ -823,18 +823,18 @@ GT_STATUS gprtSetHeaderMode
 * gprtGetHeaderMode
 *
 * DESCRIPTION:
-*		This routine gets ingress and egress header mode of a switch port. 
+*        This routine gets ingress and egress header mode of a switch port. 
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: header mode enabled
-*  			GT_FALSE otherwise
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -853,22 +853,22 @@ GT_STATUS gprtGetHeaderMode
 * gprtSetProtectedMode
 *
 * DESCRIPTION:
-*		This routine set protected mode of a switch port. 
-*		When this mode is set to GT_TRUE, frames are allowed to egress port
-*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
-*		allow the frame to Egress.
+*        This routine set protected mode of a switch port. 
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS: 
 *
@@ -886,22 +886,22 @@ GT_STATUS gprtSetProtectedMode
 * gprtGetProtectedMode
 *
 * DESCRIPTION:
-*		This routine gets protected mode of a switch port. 
-*		When this mode is set to GT_TRUE, frames are allowed to egress port
-*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
-*		allow the frame to Egress.
+*        This routine gets protected mode of a switch port. 
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: header mode enabled
-*  			GT_FALSE otherwise
+*        mode - GT_TRUE: header mode enabled
+*              GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -910,30 +910,30 @@ GT_STATUS gprtSetProtectedMode
 *******************************************************************************/
 GT_STATUS gprtGetProtectedMode
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_LPORT		port,
-    OUT GT_BOOL		*mode
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
 * gprtSetForwardUnknown
 *
 * DESCRIPTION:
-*		This routine set Forward Unknown mode of a switch port. 
-*		When this mode is set to GT_TRUE, normal switch operation occurs.
-*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
-*		will not egress out this port.
+*        This routine set Forward Unknown mode of a switch port. 
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for protected mode or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for protected mode or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS: 
 *
@@ -942,30 +942,30 @@ GT_STATUS gprtGetProtectedMode
 *******************************************************************************/
 GT_STATUS gprtSetForwardUnknown
 (
-    IN GT_QD_DEV	*dev,
-    IN GT_LPORT	port,
-    IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT    port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
 * gprtGetForwardUnknown
 *
 * DESCRIPTION:
-*		This routine gets Forward Unknown mode of a switch port. 
-*		When this mode is set to GT_TRUE, normal switch operation occurs.
-*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
-*		will not egress out this port.
+*        This routine gets Forward Unknown mode of a switch port. 
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: header mode enabled
-*				GT_FALSE otherwise
+*        mode - GT_TRUE: header mode enabled
+*                GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -974,9 +974,9 @@ GT_STATUS gprtSetForwardUnknown
 *******************************************************************************/
 GT_STATUS gprtGetForwardUnknown
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_LPORT		port,
-    OUT GT_BOOL		*mode
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
@@ -1006,8 +1006,8 @@ GT_STATUS gprtGetSwitchReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 );
 
 /*******************************************************************************
@@ -1037,8 +1037,8 @@ GT_STATUS gprtSetSwitchReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    IN  GT_U16	     data
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
 );
 
 
@@ -1067,8 +1067,8 @@ GT_STATUS gprtSetSwitchReg
 GT_STATUS gprtGetGlobalReg
 (
     IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 );
 
 /*******************************************************************************
@@ -1096,8 +1096,8 @@ GT_STATUS gprtGetGlobalReg
 GT_STATUS gprtSetGlobalReg
 (
     IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     regAddr,
-    IN  GT_U16	     data
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
 );
 
 
@@ -1300,8 +1300,8 @@ GT_STATUS gvlnGetPortVid
 *       This routine sets the port VLAN database number (DBNum).
 *
 * INPUTS:
-*       port	- logical port number to set.
-*       DBNum 	- database number for this port 
+*       port    - logical port number to set.
+*       DBNum     - database number for this port 
 *
 * OUTPUTS:
 *       None.
@@ -1331,10 +1331,10 @@ GT_STATUS gvlnSetPortVlanDBNum
 *       This routine gets the port VLAN database number (DBNum).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       DBNum 	- database number for this port 
+*       DBNum     - database number for this port 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1358,8 +1358,8 @@ GT_STATUS gvlnGetPortVlanDBNum
 *       This routine sets the port 802.1q mode (11:10) 
 *
 * INPUTS:
-*       port	- logical port number to set.
-*       mode 	- 802.1q mode for this port 
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port 
 *
 * OUTPUTS:
 *       None.
@@ -1377,8 +1377,8 @@ GT_STATUS gvlnGetPortVlanDBNum
 GT_STATUS gvlnSetPortVlanDot1qMode
 (
     IN GT_QD_DEV *dev,
-    IN GT_LPORT 	port,
-    IN GT_DOT1Q_MODE	mode
+    IN GT_LPORT     port,
+    IN GT_DOT1Q_MODE    mode
 );
 
 /*******************************************************************************
@@ -1388,10 +1388,10 @@ GT_STATUS gvlnSetPortVlanDot1qMode
 *       This routine gets the port 802.1q mode (bit 11:10).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       mode 	- 802.1q mode for this port 
+*       mode     - 802.1q mode for this port 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1417,7 +1417,7 @@ GT_STATUS gvlnGetPortVlanDot1qMode
 *       This routine sets the port 802.1q mode (11:10) 
 *
 * INPUTS:
-*       port	- logical port number to set.
+*       port    - logical port number to set.
 *       mode    - GT_TRUE, force to use default VID
 *                 GT_FAULSE, otherwise 
 *
@@ -1437,8 +1437,8 @@ GT_STATUS gvlnGetPortVlanDot1qMode
 GT_STATUS gvlnSetPortVlanForceDefaultVID
 (
     IN GT_QD_DEV *dev,
-    IN GT_LPORT 	port,
-    IN GT_BOOL  	mode
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
 );
 
 /*******************************************************************************
@@ -1448,10 +1448,10 @@ GT_STATUS gvlnSetPortVlanForceDefaultVID
 *       This routine gets the port mode for ForceDefaultVID (bit 12).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       mode 	- ForceDefaultVID mode for this port 
+*       mode     - ForceDefaultVID mode for this port 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1466,8 +1466,8 @@ GT_STATUS gvlnSetPortVlanForceDefaultVID
 GT_STATUS gvlnGetPortVlanForceDefaultVID
 (
     IN GT_QD_DEV *dev,
-    IN  GT_LPORT 	 port,
-    OUT GT_BOOL    	*mode
+    IN  GT_LPORT      port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
@@ -1478,8 +1478,8 @@ GT_STATUS gvlnGetPortVlanForceDefaultVID
 *
 * INPUTS:
 *       eventType - the event type. any combination of the folowing: 
-*       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
-*       	GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, and GT_DEVICE_INT
+*           GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*           GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, and GT_DEVICE_INT
 *
 * OUTPUTS:
 *       None.
@@ -1490,13 +1490,13 @@ GT_STATUS gvlnGetPortVlanForceDefaultVID
 *
 * COMMENTS:
 *       Each switch device has its own set of event Types. Please refer to the
-*		device datasheet for the list of event types that the device supports.
+*        device datasheet for the list of event types that the device supports.
 *
 *******************************************************************************/
 GT_STATUS eventSetActive
 (
-    IN GT_QD_DEV 	*dev,
-    IN GT_U32 		eventType
+    IN GT_QD_DEV     *dev,
+    IN GT_U32         eventType
 );
 
 /*******************************************************************************
@@ -1510,12 +1510,12 @@ GT_STATUS eventSetActive
 *
 * OUTPUTS:
 *       intCause -  It provides the source of interrupt of the following:
-*				GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
-*				GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
-*				For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and 
-*				GT_PHY_INTERRUPT is not supported.
-*				GT_DEVICE_INT may not be available on the devices, so please refer
-*				to the datasheet for details.
+*                GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*                GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT.
+*                For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_FULL and 
+*                GT_PHY_INTERRUPT is not supported.
+*                GT_DEVICE_INT may not be available on the devices, so please refer
+*                to the datasheet for details.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1527,39 +1527,39 @@ GT_STATUS eventSetActive
 *******************************************************************************/
 GT_STATUS eventGetIntStatus
 (
-    IN  GT_QD_DEV 	*dev,
-    OUT GT_U16		*intCause
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intCause
 );
 
 /*******************************************************************************
 * gvtuGetIntStatus
 *
 * DESCRIPTION:
-* 		Check to see if a specific type of VTU interrupt occured
+*         Check to see if a specific type of VTU interrupt occured
 *
 * INPUTS:
 *       intType - the type of interrupt which causes an interrupt.
-*			any combination of 
-*			GT_MEMEBER_VIOLATION,
-*			GT_MISS_VIOLATION,
-*			GT_FULL_VIOLATION
+*            any combination of 
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK   - on success
-* 		GT_FAIL - on error
+*         GT_OK   - on success
+*         GT_FAIL - on error
 *
 * COMMENTS:
-* 		FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
+*         FULL_VIOLATION is only for Fast Ethernet Switch (not for Gigabit Switch).
 *
 *******************************************************************************/
 
 GT_STATUS gvtuGetIntStatus
 (
-    IN  GT_QD_DEV 			*dev,
-    OUT GT_VTU_INT_STATUS 	*vtuIntStatus
+    IN  GT_QD_DEV             *dev,
+    OUT GT_VTU_INT_STATUS     *vtuIntStatus
 );
 
 /*******************************************************************************
@@ -1587,8 +1587,8 @@ GT_STATUS gvtuGetIntStatus
 *******************************************************************************/
 GT_STATUS gvtuGetEntryCount
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U32 		*numEntries
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32         *numEntries
 );
 
 /*******************************************************************************
@@ -1616,8 +1616,8 @@ GT_STATUS gvtuGetEntryCount
 *******************************************************************************/
 GT_STATUS gvtuGetEntryFirst
 (
-	IN  GT_QD_DEV 		*dev,
-	OUT GT_VTU_ENTRY	*vtuEntry
+    IN  GT_QD_DEV         *dev,
+    OUT GT_VTU_ENTRY    *vtuEntry
 );
 
 /*******************************************************************************
@@ -1645,8 +1645,8 @@ GT_STATUS gvtuGetEntryFirst
 *******************************************************************************/
 GT_STATUS gvtuGetEntryNext
 (
-	IN  GT_QD_DEV 		*dev,
-	INOUT GT_VTU_ENTRY  *vtuEntry
+    IN  GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry
 );
 
 /*******************************************************************************
@@ -1675,9 +1675,9 @@ GT_STATUS gvtuGetEntryNext
 *******************************************************************************/
 GT_STATUS gvtuFindVidEntry
 (
-	IN GT_QD_DEV 		*dev,
-	INOUT GT_VTU_ENTRY  *vtuEntry,
-	OUT GT_BOOL         *found
+    IN GT_QD_DEV         *dev,
+    INOUT GT_VTU_ENTRY  *vtuEntry,
+    OUT GT_BOOL         *found
 );
 
 /*******************************************************************************
@@ -1721,7 +1721,7 @@ GT_STATUS gvtuFlush
 * RETURNS:
 *       GT_OK             - on success
 *       GT_FAIL           - on error
-*       GT_FULL			  - vtu table is full
+*       GT_FULL              - vtu table is full
 *
 * COMMENTS:
 *       None.
@@ -1731,7 +1731,7 @@ GT_STATUS gvtuFlush
 *******************************************************************************/
 GT_STATUS gvtuAddEntry
 (
-    IN GT_QD_DEV 	*dev,
+    IN GT_QD_DEV     *dev,
     IN GT_VTU_ENTRY *vtuEntry
 );
 
@@ -1759,7 +1759,7 @@ GT_STATUS gvtuAddEntry
 *******************************************************************************/
 GT_STATUS gvtuDelEntry
 (
-    IN GT_QD_DEV 	*dev,
+    IN GT_QD_DEV     *dev,
     IN GT_VTU_ENTRY *vtuEntry
 );
 
@@ -1769,30 +1769,30 @@ GT_STATUS gvtuDelEntry
 * gprtPhyReset
 *
 * DESCRIPTION:
-*		This routine preforms PHY reset.
-*		After reset, phy will be in Autonegotiation mode.
+*        This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
 *
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 * COMMENTS:
-* 		data sheet register 0.15 - Reset
-* 		data sheet register 0.13 - Speed
-* 		data sheet register 0.12 - Autonegotiation
-* 		data sheet register 0.8  - Duplex Mode
+*         data sheet register 0.15 - Reset
+*         data sheet register 0.13 - Speed
+*         data sheet register 0.12 - Autonegotiation
+*         data sheet register 0.8  - Duplex Mode
 *
 *******************************************************************************/
 
 GT_STATUS gprtPhyReset
 (
-    IN GT_QD_DEV 	*dev,
-    IN GT_LPORT 	port
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port
 );
 
 
@@ -1815,27 +1815,27 @@ GT_STATUS gprtPhyReset
 *   sheet for the information of the default MAC Interface speed.
 *
 * INPUTS:
-* 		port - logical port number
-* 		enable - If GT_TRUE, enable loopback mode
-* 					If GT_FALSE, disable loopback mode
+*         port - logical port number
+*         enable - If GT_TRUE, enable loopback mode
+*                     If GT_FALSE, disable loopback mode
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.14 - Loop_back
+*         data sheet register 0.14 - Loop_back
 *
 *******************************************************************************/
 
 GT_STATUS gprtSetPortLoopback
 (
-	IN GT_QD_DEV 	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL 		enable
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         enable
 );
 
 
@@ -1843,16 +1843,16 @@ GT_STATUS gprtSetPortLoopback
 * gprtSetPortSpeed
 *
 * DESCRIPTION:
-* 		Sets speed for a specific logical port. This function will keep the duplex 
-*		mode and loopback mode to the previous value, but disable others, such as 
-*		Autonegotiation.
+*         Sets speed for a specific logical port. This function will keep the duplex 
+*        mode and loopback mode to the previous value, but disable others, such as 
+*        Autonegotiation.
 *
 * INPUTS:
-* 		port  - logical port number
-* 		speed - port speed.
-*				PHY_SPEED_10_MBPS for 10Mbps
-*				PHY_SPEED_100_MBPS for 100Mbps
-*				PHY_SPEED_1000_MBPS for 1000Mbps
+*         port  - logical port number
+*         speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
 *
 * OUTPUTS:
 * None.
@@ -1869,9 +1869,9 @@ GT_STATUS gprtSetPortLoopback
 
 GT_STATUS gprtSetPortSpeed
 (
-	IN GT_QD_DEV 	*dev,
-	IN GT_LPORT 	port,
-	IN GT_PHY_SPEED	speed
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_SPEED    speed
 );
 
 
@@ -1879,35 +1879,35 @@ GT_STATUS gprtSetPortSpeed
 * gprtPortAutoNegEnable
 *
 * DESCRIPTION:
-* 		Enable/disable an Auto-Negotiation for duplex mode on specific
-* 		logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
-*		Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
-*		100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
-*		in AutoNegotiation Advertisement register.
+*         Enable/disable an Auto-Negotiation for duplex mode on specific
+*         logical port. When Autonegotiation is disabled, phy will be in 10Mbps Half 
+*        Duplex mode. Enabling Autonegotiation will set 100BASE-TX Full Duplex, 
+*        100BASE-TX Full Duplex, 100BASE-TX Full Duplex, and 100BASE-TX Full Duplex
+*        in AutoNegotiation Advertisement register.
 *
 * INPUTS:
-* 		port - logical port number
-* 		state - GT_TRUE for enable Auto-Negotiation for duplex mode,
-* 					GT_FALSE otherwise
+*         port - logical port number
+*         state - GT_TRUE for enable Auto-Negotiation for duplex mode,
+*                     GT_FALSE otherwise
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.12 - Auto-Negotiation Enable
-* 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
 *
 *******************************************************************************/
 
 GT_STATUS gprtPortAutoNegEnable
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL 		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         state
 );
 
 
@@ -1915,32 +1915,32 @@ GT_STATUS gprtPortAutoNegEnable
 * gprtPortPowerDown
 *
 * DESCRIPTION:
-* 		Enable/disable (power down) on specific logical port. When this function 
-*		is called with normal operation request, phy will set to Autonegotiation 
-*		mode.
+*         Enable/disable (power down) on specific logical port. When this function 
+*        is called with normal operation request, phy will set to Autonegotiation 
+*        mode.
 *
 * INPUTS:
-* 		port	- logical port number
-* 		state	-  GT_TRUE: power down
-* 					GT_FALSE: normal operation
+*         port    - logical port number
+*         state    -  GT_TRUE: power down
+*                     GT_FALSE: normal operation
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.11 - Power Down
+*         data sheet register 0.11 - Power Down
 *
 *******************************************************************************/
 
 GT_STATUS gprtPortPowerDown
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        state
 );
 
 
@@ -1948,28 +1948,28 @@ GT_STATUS gprtPortPowerDown
 * gprtPortRestartAutoNeg
 *
 * DESCRIPTION:
-* 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
-*		it. Loopback and Power Down will be disabled by this routine.
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+*        it. Loopback and Power Down will be disabled by this routine.
 *
 * INPUTS:
-* 		port - logical port number
+*         port - logical port number
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.9 - Restart Auto-Negotiation
+*         data sheet register 0.9 - Restart Auto-Negotiation
 *
 *******************************************************************************/
 
 GT_STATUS gprtPortRestartAutoNeg
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 
@@ -1977,31 +1977,31 @@ GT_STATUS gprtPortRestartAutoNeg
 * gprtSetPortDuplexMode
 *
 * DESCRIPTION:
-* 		Sets duplex mode for a specific logical port. This function will keep 
-*		the speed and loopback mode to the previous value, but disable others,
-*		such as Autonegotiation.
+*         Sets duplex mode for a specific logical port. This function will keep 
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
 *
 * INPUTS:
-* 		port 	- logical port number
-* 		dMode	- dulpex mode
+*         port     - logical port number
+*         dMode    - dulpex mode
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.8 - Duplex Mode
+*         data sheet register 0.8 - Duplex Mode
 *
 *******************************************************************************/
 
 GT_STATUS gprtSetPortDuplexMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		dMode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        dMode
 );
 
 
@@ -2009,43 +2009,43 @@ GT_STATUS gprtSetPortDuplexMode
 * gprtSetPortAutoMode
 *
 * DESCRIPTION:
-* 		This routine sets up the port with given Auto Mode.
-*		Supported mode is as follows:
-*		- Auto for both speed and duplex.
-*		- Auto for speed only and Full duplex.
-*		- Auto for speed only and Half duplex.
-*		- Auto for duplex only and speed 1000Mbps.
-*		- Auto for duplex only and speed 100Mbps.
-*		- Auto for duplex only and speed 10Mbps.
-*		- Speed 1000Mbps and Full duplex.
-*		- Speed 1000Mbps and Half duplex.
-*		- Speed 100Mbps and Full duplex.
-*		- Speed 100Mbps and Half duplex.
-*		- Speed 10Mbps and Full duplex.
-*		- Speed 10Mbps and Half duplex.
-*		
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*        
 *
 * INPUTS:
-* 		port - The logical port number
-* 		mode - Auto Mode to be written
+*         port - The logical port number
+*         mode - Auto Mode to be written
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 * COMMENTS:
-* 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
-* 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
-* 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
 *******************************************************************************/
 
 GT_STATUS gprtSetPortAutoMode
 (
-	IN GT_QD_DEV 	*dev,
-	IN GT_LPORT 	port,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV     *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_AUTO_MODE mode
 );
 
 /*******************************************************************************
@@ -2053,15 +2053,15 @@ GT_STATUS gprtSetPortAutoMode
 *
 * DESCRIPTION:
 *       This routine will set the pause bit in Autonegotiation Advertisement
-*		Register. And restart the autonegotiation.
+*        Register. And restart the autonegotiation.
 *
 * INPUTS:
 * port - The logical port number
 * state - GT_PHY_PAUSE_MODE enum value.
-*			GT_PHY_NO_PAUSE		- disable pause
-* 			GT_PHY_PAUSE		- support pause
-*			GT_PHY_ASYMMETRIC_PAUSE	- support asymmetric pause
-*			GT_PHY_BOTH_PAUSE	- support both pause and asymmetric pause
+*            GT_PHY_NO_PAUSE        - disable pause
+*             GT_PHY_PAUSE        - support pause
+*            GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*            GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
 *
 * OUTPUTS:
 *       None.
@@ -2075,9 +2075,9 @@ GT_STATUS gprtSetPortAutoMode
 
 GT_STATUS gprtSetPause
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_PHY_PAUSE_MODE state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PHY_PAUSE_MODE state
 );
 
 /*******************************************************************************
@@ -2107,8 +2107,8 @@ GT_STATUS gprtGetPhyReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 );
 
 /*******************************************************************************
@@ -2138,8 +2138,8 @@ GT_STATUS gprtSetPhyReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    IN  GT_U16	     data
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
 );
 
 
@@ -2158,17 +2158,17 @@ GT_STATUS gprtSetPhyReg
 * INPUTS:
 * port    - logical port number
 * intType - the type of interrupt to enable/disable. any combination of 
-*			GT_SPEED_CHANGED,
-*			GT_DUPLEX_CHANGED,
-*			GT_PAGE_RECEIVED,
-*			GT_AUTO_NEG_COMPLETED,
-*			GT_LINK_STATUS_CHANGED,
-*			GT_SYMBOL_ERROR,
-*			GT_FALSE_CARRIER,
-*			GT_FIFO_FLOW,
-*			GT_CROSSOVER_CHANGED,
-*			GT_POLARITY_CHANGED, and
-*			GT_JABBER
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
 *
 * OUTPUTS:
 * None.
@@ -2186,7 +2186,7 @@ GT_STATUS gprtPhyIntEnable
 (
 IN GT_QD_DEV *dev,
 IN GT_LPORT   port,
-IN GT_U16	intType
+IN GT_U16    intType
 );
 
 
@@ -2199,18 +2199,18 @@ IN GT_U16	intType
 * INPUTS:
 * port - logical port number
 * intType - the type of interrupt which causes an interrupt.
-*			any combination of 
-*			GT_SPEED_CHANGED,
-*			GT_DUPLEX_CHANGED,
-*			GT_PAGE_RECEIVED,
-*			GT_AUTO_NEG_COMPLETED,
-*			GT_LINK_STATUS_CHANGED,
-*			GT_SYMBOL_ERROR,
-*			GT_FALSE_CARRIER,
-*			GT_FIFO_FLOW,
-*			GT_CROSSOVER_CHANGED,
-*			GT_POLARITY_CHANGED, and
-*			GT_JABBER
+*            any combination of 
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,
+*            GT_POLARITY_CHANGED, and
+*            GT_JABBER
 *
 * OUTPUTS:
 * None.
@@ -2862,11 +2862,11 @@ GT_STATUS gprtGetSpeed
 *       This routine sets the duplex mode of MII/SNI/RMII ports.
 *
 * INPUTS:
-*       port - 	the logical port number.
-*				(for FullSail, it will be port 2, and for ClipperShip, 
-*				it could be either port 5 or port 6.)
+*       port -     the logical port number.
+*                (for FullSail, it will be port 2, and for ClipperShip, 
+*                it could be either port 5 or port 6.)
 *       mode -  GT_TRUE for Full Duplex,
-*				GT_FALSE for Half Duplex.
+*                GT_FALSE for Half Duplex.
 *
 * OUTPUTS: None
 *
@@ -3289,13 +3289,13 @@ GT_STATUS gcosSetDscp2Tc
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS:
-* 	qdUnloadDriver is provided when the driver is not to be used anymore.
+*     qdUnloadDriver is provided when the driver is not to be used anymore.
 *
 *******************************************************************************/
 GT_STATUS qdLoadDriver
 (
     IN  GT_SYS_CONFIG   *sysCfg,
-    OUT GT_QD_DEV	*dev
+    OUT GT_QD_DEV    *dev
 );
 
 
@@ -3772,25 +3772,22 @@ GT_STATUS gsysGetPerPortDuplexPauseMac
     IN GT_BOOL *en
 );
 
-
 /*******************************************************************************
-* gsysReadMiiRegister
+* gsysSetPortWakeonFrameEn
 *
 * DESCRIPTION:
-*       This routine reads QuarterDeck Registers. Since this routine is only for
-*		Diagnostic Purpose, no error checking will be performed.
-*		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*       This routine sets port interrupt for wake on frame.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
-*       regAddr - The register's address.
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*       None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
 *       None.
@@ -3798,33 +3795,28 @@ GT_STATUS gsysGetPerPortDuplexPauseMac
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysReadMiiReg
+GT_STATUS gsysSetPortWakeonFrameEn
 (
-    IN GT_QD_DEV* dev,
-    IN  GT_U32	phyAddr,
-    IN  GT_U32	regAddr,
-    OUT GT_U32	*data
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        portVec
 );
 
 /*******************************************************************************
-* gsysWriteMiiRegister
+* gsysGetPortWakeonFrameEnSt
 *
 * DESCRIPTION:
-*       This routine writes QuarterDeck Registers. Since this routine is only for
-*		Diagnostic Purpose, no error checking will be performed.
-*		User has to know exactly which phy address(0 ~ 0x1F) will be read.
+*       This routine gets port interrupt status for wake on frame.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
-*       regAddr - The register's address.
-*       data    - data to be written.
+*       None.
 *
 * OUTPUTS:
-*		None
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
 *       None.
@@ -3832,57 +3824,55 @@ GT_STATUS gsysReadMiiReg
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysWriteMiiReg
+GT_STATUS gsysGetPortWakeonFrameEnSt
 (
-    IN GT_QD_DEV* dev,
-    IN  GT_U32	phyAddr,
-    IN  GT_U32	regAddr,
-    IN  GT_U16	data
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
 );
 
 /*******************************************************************************
-* gsysGetSW_Mode
+* gsysGetPortWakeonFrameEn
 *
 * DESCRIPTION:
-*       This routine get the Switch mode. These two bits returen 
-*       the current value of the SW_MODE[1:0] pins.
+*       This routine gets port interrupt status for wake on frame.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_BAD_PARAM    - on bad parameter
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-* 		This feature is for both clippership and fullsail
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetSW_Mode
+GT_STATUS gsysGetPortWakeonFrameEn
 (
-    IN GT_QD_DEV* dev,
-    IN GT_SW_MODE *mode
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
 );
 
 /*******************************************************************************
-* gsysGetInitReady
+* gsysSetWoLMac
 *
 * DESCRIPTION:
-*       This routine get the InitReady bit. This bit is set to a one when the ATU,
-*       the Queue Controller and the Statistics Controller are done with their 
-*       initialization and are ready to accept frames.
+*       This routine sets the Wake on Lan Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation, 
+*        use gsysSetPerPortDuplexPauseMac API.
 *
 * INPUTS:
-*       None.
+*       mac - The Mac address to be set.
 *
 * OUTPUTS:
-*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
 *       GT_OK           - on success
@@ -3890,370 +3880,447 @@ GT_STATUS gsysGetSW_Mode
 *       GT_FAIL         - on error
 *
 * COMMENTS:
-* 		This feature is for both clippership and fullsail
-*
-* GalTis:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetInitReady
+GT_STATUS gsysSetWoLMac
 (
-    IN GT_QD_DEV* dev,
-    IN GT_BOOL *mode
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
 );
 
-
 /*******************************************************************************
-* gstatsFlushAll
+* gsysGetWoLMac
 *
 * DESCRIPTION:
-*       Flush All RMON counters for all ports.
+*       This routine Gets the Wake on Lan Mac Address.
+*        For different MAC Addresses per port operation, 
+*        use gsysGetPerPortDuplexPauseMac API.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*       None.
+*       mac - the Mac address.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*       None
-*
-* GalTis:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gstatsFlushAll
+GT_STATUS gsysGetWoLMac
 (
-    IN GT_QD_DEV* dev
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
 );
 
 /*******************************************************************************
-* gstatsFlushPort
+* gsysSetPerPortWoLMac
 *
 * DESCRIPTION:
-*       Flush All RMON counters for a given port.
+*       This routine sets whether the Wake on Lan Mac Address is per
+*       port or per device.
 *
 * INPUTS:
-*       port - the logical port number.
+*       en - GT_TURE per port mac, GT_FALSE global mac.
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*
-*       None
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsFlushPort
+GT_STATUS gsysSetPerPortWoLMac
 (
-    IN GT_QD_DEV* dev,
-    IN GT_LPORT	port
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
 );
 
 /*******************************************************************************
-* gstatsGetPortCounter
+* gsysGetPerPortWoLMac
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*       This routine Gets whether the Wake on Lanc Mac Address is per
+*       port or per device.
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*       en - GT_TURE per port mac, GT_FALSE global mac.
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortCounter
+GT_STATUS gsysGetPerPortWoLMac
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gstatsGetPortAllCounters
+* gsysSetWoLPass
 *
 * DESCRIPTION:
-*       This routine gets all RMON counters of the given port
+*       This routine sets the Wake on Lan Password Mac Address.
 *
 * INPUTS:
-*       port - the logical port number.
+*       mac - The Mac address to be set.
 *
 * OUTPUTS:
-*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*       None
-*
-* GalTis:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortAllCounters
+GT_STATUS gsysSetWoLPass
 (
-	IN  GT_QD_DEV* dev,
-	IN  GT_LPORT		port,
-	OUT GT_STATS_COUNTER_SET	*statsCounterSet
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
 );
 
-
 /*******************************************************************************
-* grcSetLimitMode
+* gsysGetWoLPass
 *
 * DESCRIPTION:
-*       This routine sets the port's rate control ingress limit mode.
+*       This routine Gets the Wake on Lan password Mac Address.
 *
 * INPUTS:
-*       port	- logical port number.
-*       mode 	- rate control ingress limit mode. 
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       mac - the Mac address.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
 *******************************************************************************/
-GT_STATUS grcSetLimitMode
+GT_STATUS gsysGetWoLPass
 (
-    IN GT_QD_DEV*            dev,
-    IN GT_LPORT 	     port,
-    IN GT_RATE_LIMIT_MODE    mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
 );
 
 /*******************************************************************************
-* grcGetLimitMode
+* gsysReadMiiRegister
 *
 * DESCRIPTION:
-*       This routine gets the port's rate control ingress limit mode.
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
 *
 * INPUTS:
-*       port	- logical port number.
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
 *
 * OUTPUTS:
-*       mode 	- rate control ingress limit mode. 
+*       data    - The read register's data.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcGetLimitMode
+GT_STATUS gsysReadMiiReg
 (
     IN GT_QD_DEV* dev,
-    IN  GT_LPORT port,
-    OUT GT_RATE_LIMIT_MODE    *mode
+    IN  GT_U32    phyAddr,
+    IN  GT_U32    regAddr,
+    OUT GT_U32    *data
 );
 
 /*******************************************************************************
-* grcSetPri3Rate
+* gsysWriteMiiRegister
 *
 * DESCRIPTION:
-*       This routine sets the ingress data rate limit for priority 3 frames.
-*       Priority 3 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know exactly which phy address(0 ~ 0x1F) will be read.
 *
 * INPUTS:
-*       port - the logical port number.
-*       mode - the priority 3 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri2Rate
-*              GT_TRUE:  use twice the rate as Pri2Rate
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*       data    - data to be written.
 *
 * OUTPUTS:
-*       None.
+*        None
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcSetPri3Rate
+GT_STATUS gsysWriteMiiReg
 (
-    IN GT_QD_DEV*            dev,
-    IN GT_LPORT port,
-    IN GT_BOOL  mode
+    IN GT_QD_DEV* dev,
+    IN  GT_U32    phyAddr,
+    IN  GT_U32    regAddr,
+    IN  GT_U16    data
 );
 
+#ifdef GT_RMGMT_ACCESS
 /*******************************************************************************
-* grcGetPri3Rate
+* gsysAccessMultiRegs
 *
 * DESCRIPTION:
-*       This routine gets the ingress data rate limit for priority 3 frames.
-*       Priority 3 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*       This function accesses switch's registers.
 *
 * INPUTS:
-*       port - the logical port number.
-*       
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
 * OUTPUTS:
-*       mode - the priority 3 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri2Rate
-*              GT_TRUE:  use twice the rate as Pri2Rate
+*   regList
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcGetPri3Rate
+GT_STATUS gsysAccessMultiRegs
 (
-    IN GT_QD_DEV* dev,
-    IN  GT_LPORT port,
-    OUT GT_BOOL  *mode
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
 );
+#endif
 
 /*******************************************************************************
-* grcSetPri2Rate
+* gsysGetSW_Mode
 *
 * DESCRIPTION:
-*       This routine sets the ingress data rate limit for priority 2 frames.
-*       Priority 2 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*       This routine get the Switch mode. These two bits returen 
+*       the current value of the SW_MODE[1:0] pins.
 *
 * INPUTS:
-*       port - the logical port number.
-*       mode - the priority 2 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri1Rate
-*              GT_TRUE:  use twice the rate as Pri1Rate
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       mode - GT_TRUE Discard is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*
-*******************************************************************************/
-GT_STATUS grcSetPri2Rate
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetSW_Mode
 (
-    IN GT_QD_DEV*            dev,
-    IN GT_LPORT port,
-    IN GT_BOOL  mode
+    IN GT_QD_DEV* dev,
+    IN GT_SW_MODE *mode
 );
 
 /*******************************************************************************
-* grcGetPri2Rate
+* gsysGetInitReady
 *
 * DESCRIPTION:
-*       This routine gets the ingress data rate limit for priority 2 frames.
-*       Priority 2 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*       This routine get the InitReady bit. This bit is set to a one when the ATU,
+*       the Queue Controller and the Statistics Controller are done with their 
+*       initialization and are ready to accept frames.
 *
 * INPUTS:
-*       port - the logical port number.
-*       
+*       None.
+*
 * OUTPUTS:
-*       mode - the priority 2 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri1Rate
-*              GT_TRUE:  use twice the rate as Pri1Rate
+*       mode - GT_TRUE: switch is ready, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*         This feature is for both clippership and fullsail
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcGetPri2Rate
+GT_STATUS gsysGetInitReady
 (
-    IN GT_QD_DEV*            dev,
-    IN  GT_LPORT port,
-    OUT GT_BOOL  *mode
+    IN GT_QD_DEV* dev,
+    IN GT_BOOL *mode
 );
 
+
 /*******************************************************************************
-* grcSetPri1Rate
+* gstatsFlushAll
 *
 * DESCRIPTION:
-*       This routine sets the ingress data rate limit for priority 1 frames.
-*       Priority 1 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*       Flush All RMON counters for all ports.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsFlushAll
+(
+    IN GT_QD_DEV* dev
+);
+
+/*******************************************************************************
+* gstatsFlushPort
+*
+* DESCRIPTION:
+*       Flush All RMON counters for a given port.
 *
 * INPUTS:
 *       port - the logical port number.
-*       mode - the priority 1 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri0Rate
-*              GT_TRUE:  use twice the rate as Pri0Rate
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*
+*       None
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcSetPri1Rate
+GT_STATUS gstatsFlushPort
 (
-    IN GT_QD_DEV*            dev,
-    IN GT_LPORT port,
-    IN GT_BOOL  mode
+    IN GT_QD_DEV* dev,
+    IN GT_LPORT    port
 );
 
 /*******************************************************************************
-* grcGetPri1Rate
+* gstatsGetPortCounter
 *
 * DESCRIPTION:
-*       This routine gets the ingress data rate limit for priority 1 frames.
-*       Priority 1 frames will be discarded after the ingress rate selection
-*       is reached or exceeded.
+*        This routine gets a specific counter of the given port
+*
+* INPUTS:
+*        port - the logical port number.
+*        counter - the counter which will be read
+*
+* OUTPUTS:
+*        statsData - points to 32bit data storage for the MIB counter
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
+* COMMENTS:
+*        None
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gstatsGetPortCounter
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS    counter,
+    OUT GT_U32            *statsData
+);
+
+/*******************************************************************************
+* gstatsGetPortAllCounters
+*
+* DESCRIPTION:
+*       This routine gets all RMON counters of the given port
 *
 * INPUTS:
 *       port - the logical port number.
-*       
+*
 * OUTPUTS:
-*       mode - the priority 1 frame rate limit mode
-*              GT_FALSE: use the same rate as Pri0Rate
-*              GT_TRUE:  use twice the rate as Pri0Rate
+*       statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*
+* COMMENTS:
+*       None
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcGetPri1Rate
+GT_STATUS gstatsGetPortAllCounters
 (
-    IN GT_QD_DEV*            dev,
-    IN  GT_LPORT port,
-    OUT GT_BOOL  *mode
+    IN  GT_QD_DEV* dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET    *statsCounterSet
 );
 
+
 /*******************************************************************************
-* grcSetPri0Rate
+* grcSetLimitMode
 *
 * DESCRIPTION:
-*       This routine sets the port's ingress data limit for priority 0 frames.
+*       This routine sets the port's rate control ingress limit mode.
 *
 * INPUTS:
-*       port	- logical port number.
-*       rate    - ingress data rate limit for priority 0 frames. These frames
-*       	  will be discarded after the ingress rate selected is reached 
-*       	  or exceeded. 
+*       port    - logical port number.
+*       mode     - rate control ingress limit mode. 
 *
 * OUTPUTS:
 *       None.
@@ -4262,28 +4329,25 @@ GT_STATUS grcGetPri1Rate
 *       GT_OK               - on success
 *       GT_FAIL             - on error
 *       GT_BAD_PARAM        - on bad parameters
-*
 *******************************************************************************/
-GT_STATUS grcSetPri0Rate
+GT_STATUS grcSetLimitMode
 (
     IN GT_QD_DEV*            dev,
-    IN GT_LPORT        port,
-    IN GT_PRI0_RATE    rate
+    IN GT_LPORT          port,
+    IN GT_RATE_LIMIT_MODE    mode
 );
 
 /*******************************************************************************
-* grcGetPri0Rate
+* grcGetLimitMode
 *
 * DESCRIPTION:
-*       This routine gets the port's ingress data limit for priority 0 frames.
+*       This routine gets the port's rate control ingress limit mode.
 *
 * INPUTS:
-*       port	- logical port number to set.
+*       port    - logical port number.
 *
 * OUTPUTS:
-*       rate    - ingress data rate limit for priority 0 frames. These frames
-*       	  will be discarded after the ingress rate selected is reached 
-*       	  or exceeded. 
+*       mode     - rate control ingress limit mode. 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -4291,62 +4355,57 @@ GT_STATUS grcSetPri0Rate
 *       GT_BAD_PARAM        - on bad parameters
 *
 *******************************************************************************/
-GT_STATUS grcGetPri0Rate
+GT_STATUS grcGetLimitMode
 (
-    IN GT_QD_DEV*            dev,
+    IN GT_QD_DEV* dev,
     IN  GT_LPORT port,
-    OUT GT_PRI0_RATE    *rate
+    OUT GT_RATE_LIMIT_MODE    *mode
 );
 
 /*******************************************************************************
-* grcSetBytesCount
+* grcSetPri3Rate
 *
 * DESCRIPTION:
-*       This routine sets the byets to count for limiting needs to be determined
+*       This routine sets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
 *
 * INPUTS:
-*       port	  - logical port number to set.
-*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
-*    		    GT_FALSE: otherwise
-*    	countIFG  - GT_TRUE: To count IFG bytes
-*    		    GT_FALSE: otherwise
-*    	countPre  - GT_TRUE: To count Preamble bytes
-*    		    GT_FALSE: otherwise
+*       port - the logical port number.
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 *******************************************************************************/
-GT_STATUS grcSetBytesCount
+GT_STATUS grcSetPri3Rate
 (
-    IN GT_QD_DEV*       dev,
-    IN GT_LPORT        	port,
-    IN GT_BOOL 		limitMGMT,
-    IN GT_BOOL 		countIFG,
-    IN GT_BOOL 		countPre
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
 );
 
 /*******************************************************************************
-* grcGetBytesCount
+* grcGetPri3Rate
 *
 * DESCRIPTION:
-*       This routine gets the byets to count for limiting needs to be determined
+*       This routine gets the ingress data rate limit for priority 3 frames.
+*       Priority 3 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
 *
 * INPUTS:
-*       port	- logical port number 
-*
+*       port - the logical port number.
+*       
 * OUTPUTS:
-*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
-*    		    GT_FALSE: otherwise
-*    	countIFG  - GT_TRUE: To count IFG bytes
-*    		    GT_FALSE: otherwise
-*    	countPre  - GT_TRUE: To count Preamble bytes
-*    		    GT_FALSE: otherwise
+*       mode - the priority 3 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri2Rate
+*              GT_TRUE:  use twice the rate as Pri2Rate
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -4354,4134 +4413,5361 @@ GT_STATUS grcSetBytesCount
 *       GT_BAD_PARAM        - on bad parameters
 *
 *******************************************************************************/
-GT_STATUS grcGetBytesCount
+GT_STATUS grcGetPri3Rate
 (
-    IN GT_QD_DEV*       dev,
-    IN GT_LPORT        	port,
-    IN GT_BOOL 		*limitMGMT,
-    IN GT_BOOL 		*countIFG,
-    IN GT_BOOL 		*countPre
+    IN GT_QD_DEV* dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
 );
 
 /*******************************************************************************
-* grcSetEgressRate
+* grcSetPri2Rate
 *
 * DESCRIPTION:
-*       This routine sets the port's egress data limit.
-*		
+*       This routine sets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
 *
 * INPUTS:
-*       port      - logical port number.
-*       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
-*					union type is used to support multiple devices with the
-*					different formats of egress rate.
-*					GT_ERATE_TYPE has the following fields:
-*						definedRate - GT_EGRESS_RATE enum type should used for the 
-*							following devices:
-*							88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
-*							88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
-*							and their variations
-*						kbRate - rate in kbps that should used for the following 
-*							devices:
-*							88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_LAYER1,
-*								GT_PIRL_ELIMIT_LAYER2, or 
-*								GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
-*							64kbps ~ 1Mbps    : increments of 64kbps,
-*							1Mbps ~ 100Mbps   : increments of 1Mbps, and
-*							100Mbps ~ 1000Mbps: increments of 10Mbps
-*							Therefore, the valid values are:
-*								64, 128, 192, 256, 320, 384,..., 960,
-*								1000, 2000, 3000, 4000, ..., 100000,
-*								110000, 120000, 130000, ..., 1000000.
-*						fRate - frame per second that should used for the following
-*							devices:
-*							88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_FRAME
-*							Valid values are between 7600 and 1488000
+*       port - the logical port number.
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
-*
-* COMMENTS: 
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 *******************************************************************************/
-GT_STATUS grcSetEgressRate
+GT_STATUS grcSetPri2Rate
 (
-    IN GT_QD_DEV       *dev,
-    IN GT_LPORT        port,
-    IN GT_ERATE_TYPE   *rateType
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
 );
 
 /*******************************************************************************
-* grcGetEgressRate
+* grcGetPri2Rate
 *
 * DESCRIPTION:
-*       This routine gets the port's egress data limit.
+*       This routine gets the ingress data rate limit for priority 2 frames.
+*       Priority 2 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 2 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri1Rate
+*              GT_TRUE:  use twice the rate as Pri1Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri2Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri1Rate
+*
+* DESCRIPTION:
+*       This routine sets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+*******************************************************************************/
+GT_STATUS grcSetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* grcGetPri1Rate
+*
+* DESCRIPTION:
+*       This routine gets the ingress data rate limit for priority 1 frames.
+*       Priority 1 frames will be discarded after the ingress rate selection
+*       is reached or exceeded.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the priority 1 frame rate limit mode
+*              GT_FALSE: use the same rate as Pri0Rate
+*              GT_TRUE:  use twice the rate as Pri0Rate
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri1Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* grcSetPri0Rate
+*
+* DESCRIPTION:
+*       This routine sets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number.
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached 
+*             or exceeded. 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN GT_LPORT        port,
+    IN GT_PRI0_RATE    rate
+);
+
+/*******************************************************************************
+* grcGetPri0Rate
+*
+* DESCRIPTION:
+*       This routine gets the port's ingress data limit for priority 0 frames.
+*
+* INPUTS:
+*       port    - logical port number to set.
+*
+* OUTPUTS:
+*       rate    - ingress data rate limit for priority 0 frames. These frames
+*             will be discarded after the ingress rate selected is reached 
+*             or exceeded. 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetPri0Rate
+(
+    IN GT_QD_DEV*            dev,
+    IN  GT_LPORT port,
+    OUT GT_PRI0_RATE    *rate
+);
+
+/*******************************************************************************
+* grcSetBytesCount
+*
+* DESCRIPTION:
+*       This routine sets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port      - logical port number to set.
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcSetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN GT_BOOL         limitMGMT,
+    IN GT_BOOL         countIFG,
+    IN GT_BOOL         countPre
+);
+
+/*******************************************************************************
+* grcGetBytesCount
+*
+* DESCRIPTION:
+*       This routine gets the byets to count for limiting needs to be determined
+*
+* INPUTS:
+*       port    - logical port number 
+*
+* OUTPUTS:
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS grcGetBytesCount
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT            port,
+    IN GT_BOOL         *limitMGMT,
+    IN GT_BOOL         *countIFG,
+    IN GT_BOOL         *countPre
+);
+
+/*******************************************************************************
+* grcSetEgressRate
+*
+* DESCRIPTION:
+*       This routine sets the port's egress data limit.
+*        
+*
+* INPUTS:
+*       port      - logical port number.
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the 
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following 
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or 
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS: 
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcSetEgressRate
+(
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_ERATE_TYPE   *rateType
+);
+
+/*******************************************************************************
+* grcGetEgressRate
+*
+* DESCRIPTION:
+*       This routine gets the port's egress data limit.
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the 
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following 
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or 
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+* COMMENTS:
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
+*
+*******************************************************************************/
+GT_STATUS grcGetEgressRate
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_ERATE_TYPE  *rateType
+);
+
+
+/*******************************************************************************
+* gpavSetPAV
+*
+* DESCRIPTION:
+*       This routine sets the Port Association Vector 
+*
+* INPUTS:
+*       port    - logical port number.
+*       pav     - Port Association Vector 
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavSetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT    port,
+    IN GT_U16    pav
+);
+
+/*******************************************************************************
+* gpavGetPAV
+*
+* DESCRIPTION:
+*       This routine gets the Port Association Vector 
+*
+* INPUTS:
+*       port    - logical port number.
+*
+* OUTPUTS:
+*       pav     - Port Association Vector 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetPAV
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_U16    *pav
+);
+
+/*******************************************************************************
+* gpavSetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine sets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*******************************************************************************/
+GT_STATUS gpavSetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN GT_LPORT port,
+    IN GT_BOOL  mode
+);
+
+/*******************************************************************************
+* gpavGetIngressMonitor
+*
+* DESCRIPTION:
+*       This routine gets the Ingress Monitor bit in the PAV.
+*
+* INPUTS:
+*       port - the logical port number.
+*       
+* OUTPUTS:
+*       mode - the ingress monitor bit in the PAV
+*              GT_FALSE: Ingress Monitor enabled 
+*              GT_TRUE:  Ingress Monitor disabled 
+*
+* RETURNS:
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*
+*******************************************************************************/
+GT_STATUS gpavGetIngressMonitor
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT port,
+    OUT GT_BOOL  *mode
+);
+
+/*******************************************************************************
+* gvctGetCableStatus
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag 
+*        API can be used, instead.
+*
+
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag
+(
+    IN GT_QD_DEV*       dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+);
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus 
+*        API can be used, instead.
+*
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+);
+
+
+/*******************************************************************************
+* gtMemSet
+*
+* DESCRIPTION:
+*       Set a block of memory
+*
+* INPUTS:
+*       start  - start address of memory block for setting
+*       simbol - character to store, converted to an unsigned char
+*       size   - size of block to be set
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to set memory block
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemSet
+(
+    IN void * start,
+    IN int    symbol,
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtMemCpy
+*
+* DESCRIPTION:
+*       Copies 'size' characters from the object pointed to by 'source' into
+*       the object pointed to by 'destination'. If copying takes place between
+*       objects that overlap, the behavior is undefined.
+*
+* INPUTS:
+*       destination - destination of copy
+*       source      - source of copy
+*       size        - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Pointer to destination
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void * gtMemCpy
+(
+    IN void *       destination,
+    IN const void * source,
+    IN GT_U32       size
+);
+
+
+/*******************************************************************************
+* gtMemCmp
+*
+* DESCRIPTION:
+*       Compares given memories.
+*
+* INPUTS:
+*       src1 - source 1
+*       src2 - source 2
+*       size - size of memory to copy
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0, if equal.
+*        negative number, if src1 < src2.
+*        positive number, if src1 > src2.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int gtMemCmp
+(
+    IN char src1[],
+    IN char src2[],
+    IN GT_U32 size
+);
+
+/*******************************************************************************
+* gtStrlen
+*
+* DESCRIPTION:
+*       Determine the length of a string
+* INPUTS:
+*       source  - string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       size    - number of characters in string, not including EOS.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_U32 gtStrlen
+(
+    IN const void * source
+);
+
+/*******************************************************************************
+* gtDelay
+*
+* DESCRIPTION:
+*       Wait for the given uSec and return.
+*        Current Switch devices with Gigabit Ethernet Support require 250 uSec
+*        of delay time for PPU to be disabled.
+*        Since this function is System and/or OS dependent, it should be provided
+*        by each DSDT user.
+*
+* INPUTS:
+*       delayTime - delay in uSec.
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void gtDelay
+(
+    IN const unsigned int delayTime
+);
+
+
+/*******************************************************************************
+* gtVersion
+*
+* DESCRIPTION:
+*       This function returns the version of the QuarterDeck SW suite.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       version     - QuarterDeck software version.
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_BAD_PARAM on bad parameters,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gtVersion
+(
+    OUT GT_VERSION   *version
+);
+
+
+/* Prototypes added for Gigabit Ethernet Switch Support */
+
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbMove
+*
+* DESCRIPTION:
+*        This routine moves all or unblocked addresses from a port to another.
+*
+* INPUTS:
+*        moveCmd  - the move operation type.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMove
+(
+    IN GT_QD_DEV     *dev,
+    IN GT_MOVE_CMD    moveCmd,
+    IN GT_U32        moveFrom,
+    IN GT_U32        moveTo
+);
+
+/*******************************************************************************
+* gfdbMoveInDB
+*
+* DESCRIPTION:
+*         This routine move all or unblocked addresses which are in the particular
+*         ATU Database (DBNum) from a port to another.
+*
+* INPUTS:
+*         moveCmd  - the move operation type.
+*        DBNum         - ATU MAC Address Database Number.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
+*
+* OUTPUTS:
+*     None
+*
+* RETURNS:
+*         GT_OK           - on success
+*         GT_FAIL         - on error
+*         GT_NOT_SUPPORTED- if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gfdbMoveInDB
+(
+    IN GT_QD_DEV   *dev,
+    IN GT_MOVE_CMD moveCmd,
+    IN GT_U32         DBNum,
+    IN GT_U32        moveFrom,
+    IN GT_U32        moveTo
+);
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/*******************************************************************************
+* gatuGetIntStatus
+*
+* DESCRIPTION:
+*        Check to see if a specific type of ATU interrupt occured
+*
+* INPUTS:
+*     intType - the type of interrupt which causes an interrupt.
+*                    GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION 
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gatuGetIntStatus
+(
+    IN  GT_QD_DEV                *dev,
+    OUT GT_ATU_INT_STATUS    *atuIntStatus
+);
+
+
+/* gtPhyCtrl.c */
+
+/*******************************************************************************
+* gprtSet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_1000T_MASTER_SLAVE    *mode
+);
+
+/*******************************************************************************
+* gprtGet1000TMasterMode
+*
+* DESCRIPTION:
+*        This routine set the port multicast rate limit.
+*
+* INPUTS:
+*        port - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_1000T_MASTER_SLAVE    *mode
+);
+
+/*******************************************************************************
+* gprtGetPhyReg
+*
+* DESCRIPTION:
+*        This routine reads Phy Registers.
+*
+* INPUTS:
+*        port    - logical port number
+*        regAddr - The register's address.
+*
+* OUTPUTS:
+*        data    - The read register's data.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+);
+
+/*******************************************************************************
+* gprtSetPhyReg
+*
+* DESCRIPTION:
+*        This routine writes Phy Registers.
+*        
+* INPUTS:
+*        port    - logical port number
+*        regAddr - The register's address.
+*
+* OUTPUTS:
+*        data    - The read register's data.
+*
+* RETURNS:
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
+);
+
+
+/* gtPortCtrl.c */
+
+/*******************************************************************************
+* gprtSetDropOnLock
+*
+* DESCRIPTION:
+*        This routine set the Drop on Lock. When set to one, Ingress frames will
+*        be discarded if their SA field is not in the ATU's address database.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDropOnLock
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDropOnLock
+*
+* DESCRIPTION:
+*        This routine gets DropOnLock mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DropOnLock enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDropOnLock
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetDoubleTag
+*
+* DESCRIPTION:
+*        This routine set the Ingress Double Tag Mode. When set to one, 
+*        ingressing frames are examined to see if they contain an 802.3ac tag.
+*        If they do, the tag is removed and then the frame is processed from
+*        there (i.e., removed tag is ignored). Essentially, untagged frames
+*        remain untagged, single tagged frames become untagged and double tagged
+*        frames become single tagged.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetDoubleTag
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetDoubleTag
+*
+* DESCRIPTION:
+*        This routine gets DoubleTag mode.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: DoubleTag enabled,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetDoubleTag
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetInterswitchPort
+*
+* DESCRIPTION:
+*        This routine set Interswitch Port. When set to one, 
+*        it indicates this port is a interswitch port used to communicated with
+*        CPU or to cascade with another switch device.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetInterswitchPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+/*******************************************************************************
+* gprtGetInterswithPort
+*
+* DESCRIPTION:
+*        This routine gets InterswitchPort.
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: This port is interswitch port,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetInterswitchPort
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetLearnDisable
+*
+* DESCRIPTION:
+*        This routine enables/disables automatic learning of new source MAC
+*        addresses on the given port ingress
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for disable or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetLearnDisable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
+);
+
+
+/*******************************************************************************
+* gprtGetLearnDisable
+*
+* DESCRIPTION:
+*        This routine gets LearnDisable setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetLearnDisable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine sets FCS Ignore mode. When this bit is set to a one,
+*        the last four bytes of frames received on this port are overwritten with
+*        a good CRC and the frames will be accepted by the switch.
+*
+* INPUTS:
+*        port - the logical port number.
+*        mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetIgnoreFCS
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL         mode
+);
+
+/*******************************************************************************
+* gprtGetIgnoreFCS
+*
+* DESCRIPTION:
+*        This routine gets Ignore FCS setup
+*
+* INPUTS:
+*        port  - the logical port number.
+*
+* OUTPUTS:
+*        mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*                 GT_FALSE otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetIgnoreFCS
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
+);
+
+/*******************************************************************************
+* gprtSetVTUPriOverride
+*
+* DESCRIPTION:
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*       port	- logical port number.
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
 *
 * OUTPUTS:
-*       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
-*					union type is used to support multiple devices with the
-*					different formats of egress rate.
-*					GT_ERATE_TYPE has the following fields:
-*						definedRate - GT_EGRESS_RATE enum type should used for the 
-*							following devices:
-*							88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
-*							88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
-*							and their variations
-*						kbRate - rate in kbps that should used for the following 
-*							devices:
-*							88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_LAYER1,
-*								GT_PIRL_ELIMIT_LAYER2, or 
-*								GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
-*							64kbps ~ 1Mbps    : increments of 64kbps,
-*							1Mbps ~ 100Mbps   : increments of 1Mbps, and
-*							100Mbps ~ 1000Mbps: increments of 10Mbps
-*							Therefore, the valid values are:
-*								64, 128, 192, 256, 320, 384,..., 960,
-*								1000, 2000, 3000, 4000, ..., 100000,
-*								110000, 120000, 130000, ..., 1000000.
-*						fRate - frame per second that should used for the following
-*							devices:
-*							88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_FRAME
-*							Valid values are between 7600 and 1488000
+*        None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+* COMMENTS: 
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
-GT_STATUS grcGetEgressRate
+GT_STATUS gprtSetVTUPriOverride
 (
-    IN GT_QD_DEV *dev,
-    IN  GT_LPORT port,
-    OUT GT_ERATE_TYPE  *rateType
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI_OVERRIDE        mode
 );
 
-
 /*******************************************************************************
-* gpavSetPAV
+* gprtGetVTUPriOverride
 *
 * DESCRIPTION:
-*       This routine sets the Port Association Vector 
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*       port	- logical port number.
-*       pav 	- Port Association Vector 
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
-GT_STATUS gpavSetPAV
+GT_STATUS gprtGetVTUPriOverride
 (
-    IN GT_QD_DEV*       dev,
-    IN GT_LPORT	port,
-    IN GT_U16	pav
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PRI_OVERRIDE        *mode
 );
 
 /*******************************************************************************
-* gpavGetPAV
+* gprtSetSAPriOverride
 *
 * DESCRIPTION:
-*       This routine gets the Port Association Vector 
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*       port	- logical port number.
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
 *
 * OUTPUTS:
-*       pav 	- Port Association Vector 
+*        None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
-GT_STATUS gpavGetPAV
+GT_STATUS gprtSetSAPriOverride
 (
-    IN GT_QD_DEV*       dev,
-    IN  GT_LPORT port,
-    OUT GT_U16    *pav
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpavSetIngressMonitor
+* gprtGetSAPriOverride
 *
 * DESCRIPTION:
-*       This routine sets the Ingress Monitor bit in the PAV.
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*       port - the logical port number.
-*       mode - the ingress monitor bit in the PAV
-*              GT_FALSE: Ingress Monitor enabled 
-*              GT_TRUE:  Ingress Monitor disabled 
+*        port  - the logical port number.
+*
 * OUTPUTS:
-*       None.
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
+*
 *******************************************************************************/
-GT_STATUS gpavSetIngressMonitor
+GT_STATUS gprtGetSAPriOverride
 (
-    IN GT_QD_DEV*       dev,
-    IN GT_LPORT port,
-    IN GT_BOOL  mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
 );
 
 /*******************************************************************************
-* gpavGetIngressMonitor
+* gprtSetDAPriOverride
 *
 * DESCRIPTION:
-*       This routine gets the Ingress Monitor bit in the PAV.
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
 *
 * INPUTS:
-*       port - the logical port number.
-*       
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
+*
 * OUTPUTS:
-*       mode - the ingress monitor bit in the PAV
-*              GT_FALSE: Ingress Monitor enabled 
-*              GT_TRUE:  Ingress Monitor disabled 
+*        None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
-GT_STATUS gpavGetIngressMonitor
+GT_STATUS gprtSetDAPriOverride
 (
-    IN GT_QD_DEV*       dev,
-    IN  GT_LPORT port,
-    OUT GT_BOOL  *mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PRI_OVERRIDE        mode
 );
 
 /*******************************************************************************
-* gvctGetCableStatus
+* gprtGetDAPriOverride
 *
 * DESCRIPTION:
-*       This routine perform the virtual cable test for the requested port,
-*       and returns the the status per MDI pair.
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
 *
 * INPUTS:
-*       port - logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       cableStatus - the port copper cable status.
-*       cableLen    - the port copper cable length.
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are not supported by this API. For those devices, gvctGetAdvCableDiag 
-*		API can be used, instead.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
-GT_STATUS gvctGetCableDiag
+GT_STATUS gprtGetDAPriOverride
 (
-    IN GT_QD_DEV*       dev,
-    IN  GT_LPORT        port,
-    OUT GT_CABLE_STATUS *cableStatus
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
 );
 
-
 /*******************************************************************************
-* gvctGet1000BTExtendedStatus
+* gprtSetCPUPort
 *
 * DESCRIPTION:
-*       This routine retrieves extended cable status, such as Pair Poloarity,
-*		Pair Swap, and Pair Skew. Note that this routine will be success only
-*		if 1000Base-T Link is up.
+*        This routine sets CPU Port number. When Snooping is enabled on this port
+*        or when this port is configured as an Interswitch Port and it receives a 
+*        To_CPU frame, the switch needs to know what port on this device the frame 
+*        should egress.
 *
 * INPUTS:
-*       port - logical port number.
+*        port - the logical port number.
+*        cpuPort - CPU Port number or interswitch port where CPU Port is connected
 *
 * OUTPUTS:
-*       extendedStatus - the extended cable status.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are not supported by this API. For those devices, gvctGetAdvExtendedStatus 
-*		API can be used, instead.
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gvctGet1000BTExtendedStatus
+GT_STATUS gprtSetCPUPort
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_LPORT        port,
-    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_LPORT     cpuPort
 );
 
-
 /*******************************************************************************
-* gtMemSet
+* gprtGetCPUPort
 *
 * DESCRIPTION:
-*       Set a block of memory
+*        This routine gets CPU Logical Port
 *
 * INPUTS:
-*       start  - start address of memory block for setting
-*       simbol - character to store, converted to an unsigned char
-*       size   - size of block to be set
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       None
+*        cpuPort - CPU Port's logical number
 *
 * RETURNS:
-*       Pointer to set memory block
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*
+* GalTis:
 *
 *******************************************************************************/
-void * gtMemSet
+GT_STATUS gprtGetCPUPort
 (
-    IN void * start,
-    IN int    symbol,
-    IN GT_U32 size
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_LPORT     *cpuLPort
 );
 
 /*******************************************************************************
-* gtMemCpy
+* gprtSetLockedPort
 *
 * DESCRIPTION:
-*       Copies 'size' characters from the object pointed to by 'source' into
-*       the object pointed to by 'destination'. If copying takes place between
-*       objects that overlap, the behavior is undefined.
+*        This routine sets LockedPort. When it's set to one, CPU directed 
+*        learning for 802.1x MAC authentication is enabled on this port. In this
+*        mode, an ATU Miss Violation interrupt will occur when a new SA address
+*        is received in a frame on this port. Automatically SA learning and 
+*        refreshing is disabled in this mode.
 *
 * INPUTS:
-*       destination - destination of copy
-*       source      - source of copy
-*       size        - size of memory to copy
+*        port - the logical port number.
+*        mode - GT_TRUE for Locked Port, GT_FALSE otherwise
 *
 * OUTPUTS:
-*       None
+*        None.
 *
 * RETURNS:
-*       Pointer to destination
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-void * gtMemCpy
+GT_STATUS gprtSetLockedPort
 (
-    IN void *       destination,
-    IN const void * source,
-    IN GT_U32       size
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
-
 /*******************************************************************************
-* gtMemCmp
+* gprtGetLockedPort
 *
 * DESCRIPTION:
-*       Compares given memories.
+*        This routine gets Locked Port mode for the given port
 *
 * INPUTS:
-*       src1 - source 1
-*       src2 - source 2
-*       size - size of memory to copy
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       None
+*        mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
 *
 * RETURNS:
-*       0, if equal.
-*		negative number, if src1 < src2.
-*		positive number, if src1 > src2.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*
+* GalTis:
 *
 *******************************************************************************/
-int gtMemCmp
+GT_STATUS gprtGetLockedPort
 (
-    IN char src1[],
-    IN char src2[],
-    IN GT_U32 size
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 );
 
 /*******************************************************************************
-* gtStrlen
+* gprtSetIgnoreWrongData
 *
 * DESCRIPTION:
-*       Determine the length of a string
+*        This routine sets Ignore Wrong Data. If the frame's SA address is found 
+*        in the database and if the entry is 'static' or if the port is 'locked'
+*        the source port's bit is checked to insure the SA has been assigned to 
+*        this port. If the SA is NOT assigned to this port, it is considered an 
+*        ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*        Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*        the ATU Member Violation error will be masked and ignored.
+*
 * INPUTS:
-*       source  - string
+*        port - the logical port number.
+*        mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
 *
 * OUTPUTS:
-*       None
+*        None.
 *
 * RETURNS:
-*       size    - number of characters in string, not including EOS.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_U32 gtStrlen
+GT_STATUS gprtSetIgnoreWrongData
 (
-    IN const void * source
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 );
 
+
 /*******************************************************************************
-* gtDelay
+* gprtGetIgnoreWrongData
 *
 * DESCRIPTION:
-*       Wait for the given uSec and return.
-*		Current Switch devices with Gigabit Ethernet Support require 250 uSec
-*		of delay time for PPU to be disabled.
-*		Since this function is System and/or OS dependent, it should be provided
-*		by each DSDT user.
+*        This routine gets Ignore Wrong Data mode for the given port
 *
 * INPUTS:
-*       delayTime - delay in uSec.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       None
+*        mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
 *
 * RETURNS:
-*       None
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*
+* GalTis:
 *
 *******************************************************************************/
-void gtDelay
+GT_STATUS gprtGetIgnoreWrongData
 (
-    IN const unsigned int delayTime
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
 /*******************************************************************************
-* gtVersion
+* gstatsGetPortCounter2
 *
 * DESCRIPTION:
-*       This function returns the version of the QuarterDeck SW suite.
+*        This routine gets a specific counter of the given port
 *
 * INPUTS:
-*       None.
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*       version     - QuarterDeck software version.
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*       GT_OK on success,
-*       GT_BAD_PARAM on bad parameters,
-*       GT_FAIL otherwise.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
+*        This function supports Gigabit Switch only
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gtVersion
+GT_STATUS gstatsGetPortCounter2
 (
-    OUT GT_VERSION   *version
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS2    counter,
+    OUT GT_U32            *statsData
 );
 
 
-/* Prototypes added for Gigabit Ethernet Switch Support */
-
-
-/* gtBrgFdb.c */
-
 /*******************************************************************************
-* gfdbMove
+* gstatsGetPortAllCounters2
 *
 * DESCRIPTION:
-*		This routine moves all or unblocked addresses from a port to another.
+*        This routine gets all counters of the given port
 *
 * INPUTS:
-*		moveCmd  - the move operation type.
-*		moveFrom - port where moving from
-*		moveTo   - port where moving to
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
+*        This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbMove
+GT_STATUS gstatsGetPortAllCounters2
 (
-	IN GT_QD_DEV 	*dev,
-	IN GT_MOVE_CMD	moveCmd,
-	IN GT_U32		moveFrom,
-	IN GT_U32		moveTo
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET2    *statsCounterSet
 );
 
 /*******************************************************************************
-* gfdbMoveInDB
+* gstatsGetHistogramMode
 *
 * DESCRIPTION:
-* 		This routine move all or unblocked addresses which are in the particular
-* 		ATU Database (DBNum) from a port to another.
+*        This routine gets the Histogram Counters Mode.
 *
 * INPUTS:
-* 		moveCmd  - the move operation type.
-*		DBNum	 	- ATU MAC Address Database Number.
-*		moveFrom - port where moving from
-*		moveTo   - port where moving to
+*        None.
 *
 * OUTPUTS:
-*     None
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*                    and GT_COUNT_RX_TX)
 *
 * RETURNS:
-* 		GT_OK           - on success
-* 		GT_FAIL         - on error
-* 		GT_NOT_SUPPORTED- if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbMoveInDB
+GT_STATUS gstatsGetHistogramMode
 (
-	IN GT_QD_DEV   *dev,
-	IN GT_MOVE_CMD moveCmd,
-	IN GT_U32 		DBNum,
-	IN GT_U32		moveFrom,
-	IN GT_U32		moveTo
+    IN  GT_QD_DEV                *dev,
+    OUT GT_HISTOGRAM_MODE    *mode
 );
 
-/* gtBrgStp.c */
-
-/* gtBrgVlan.c */
-
-/* gtBrgVtu.c */
-
-/* gtEvents.c */
-
 /*******************************************************************************
-* gatuGetIntStatus
+* gstatsSetHistogramMode
 *
 * DESCRIPTION:
-*		Check to see if a specific type of ATU interrupt occured
+*        This routine sets the Histogram Counters Mode.
 *
 * INPUTS:
-*     intType - the type of interrupt which causes an interrupt.
-*					GT_MEMEBER_VIOLATION, GT_MISS_VIOLATION, or GT_FULL_VIOLATION 
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*                    and GT_COUNT_RX_TX)
 *
 * OUTPUTS:
-* 		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gatuGetIntStatus
+GT_STATUS gstatsSetHistogramMode
 (
-	IN  GT_QD_DEV				*dev,
-	OUT GT_ATU_INT_STATUS	*atuIntStatus
+    IN GT_QD_DEV                 *dev,
+    IN GT_HISTOGRAM_MODE        mode
 );
 
 
-/* gtPhyCtrl.c */
+/* gtPortStatus.c */
 
 /*******************************************************************************
-* gprtSet1000TMasterMode
+* gprtGetPauseEn
 *
 * DESCRIPTION:
-*		This routine set the port multicast rate limit.
+*        This routine retrives the link pause state.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_1000T_MASTER_SLAVE structure
-*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
-*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE for enable or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        If set MAC Pause (for Full Duplex flow control) is implemented in the
+*        link partner and in MyPause
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSet1000TMasterMode
+GT_STATUS gprtGetPauseEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_1000T_MASTER_SLAVE	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *state
 );
 
 /*******************************************************************************
-* gprtGet1000TMasterMode
+* gprtGetHdFlow
 *
 * DESCRIPTION:
-*		This routine set the port multicast rate limit.
+*        This routine retrives the half duplex flow control value.
+*        If set, Half Duplex back pressure will be used on this port if this port
+*        is in a half duplex mode.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_1000T_MASTER_SLAVE structure
-*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
-*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*        state - GT_TRUE for enable or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGet1000TMasterMode
+GT_STATUS gprtGetHdFlow
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_1000T_MASTER_SLAVE	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
 );
 
 /*******************************************************************************
-* gprtGetPhyReg
+* gprtGetPHYDetect
 *
 * DESCRIPTION:
-*		This routine reads Phy Registers.
+*        This routine retrives the information regarding PHY detection.
+*        If set, An 802.3 PHY is attached to this port.
 *
 * INPUTS:
-*		port    - logical port number
-*		regAddr - The register's address.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		data    - The read register's data.
+*        state - GT_TRUE if connected or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
+*        
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPhyReg
+GT_STATUS gprtGetPHYDetect
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U32	 	regAddr,
-	OUT GT_U16	 	*data
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL     *state
 );
 
 /*******************************************************************************
-* gprtSetPhyReg
+* gprtSetPHYDetect
 *
 * DESCRIPTION:
-*		This routine writes Phy Registers.
-*		
+*        This routine sets PHYDetect bit which make PPU change its polling.
+*        PPU's pool routine uses these bits to determine which port's to poll
+*        PHYs on for Link, Duplex, Speed, and Flow Control.
+*
 * INPUTS:
-*		port    - logical port number
-*		regAddr - The register's address.
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
 *
 * OUTPUTS:
-*		data    - The read register's data.
+*        None.
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        This function should not be called if gsysGetPPUState returns 
+*        PPU_STATE_ACTIVE.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetPhyReg
+GT_STATUS gprtSetPHYDetect
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U32	 	regAddr,
-	IN  GT_U16	 	data
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
 );
 
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtSetDropOnLock
+* gprtGetSpeedMode
 *
 * DESCRIPTION:
-*		This routine set the Drop on Lock. When set to one, Ingress frames will
-*		be discarded if their SA field is not in the ATU's address database.
+*       This routine retrives the port speed.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*       port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*       mode - GT_PORT_SPEED_MODE type.
+*                    (PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
 *
-* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDropOnLock
+GT_STATUS gprtGetSpeedMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_PORT_SPEED_MODE   *speed
 );
 
 /*******************************************************************************
-* gprtGetDropOnLock
+* gprtGetHighErrorRate
 *
 * DESCRIPTION:
-*		This routine gets DropOnLock mode.
+*        This routine retrives the PCS High Error Rate.
+*        This routine returns GT_TRUE if the rate of invalid code groups seen by
+*        PCS has exceeded 10 to the power of -11.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: DropOnLock enabled,
-*				 GT_FALSE otherwise
+*        state - GT_TRUE or GT_FALSE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetDropOnLock
+GT_STATUS gprtGetHighErrorRate
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtSetDoubleTag
+* gprtGetTxPaused
 *
 * DESCRIPTION:
-*		This routine set the Ingress Double Tag Mode. When set to one, 
-*		ingressing frames are examined to see if they contain an 802.3ac tag.
-*		If they do, the tag is removed and then the frame is processed from
-*		there (i.e., removed tag is ignored). Essentially, untagged frames
-*		remain untagged, single tagged frames become untagged and double tagged
-*		frames become single tagged.
+*        This routine retrives Transmit Pause state.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
+*                  GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDoubleTag
+GT_STATUS gprtGetTxPaused
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
+
 /*******************************************************************************
-* gprtGetDoubleTag
+* gprtGetFlowCtrl
 *
 * DESCRIPTION:
-*		This routine gets DoubleTag mode.
+*        This routine retrives Flow control state.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: DoubleTag enabled,
-*				 GT_FALSE otherwise
+*        state - GT_TRUE if Rx MAC determines that no more data should be 
+*                    entering this port.
+*                  GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetDoubleTag
+GT_STATUS gprtGetFlowCtrl
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtSetInterswitchPort
+* gprtGetC_Duplex
 *
 * DESCRIPTION:
-*		This routine set Interswitch Port. When set to one, 
-*		it indicates this port is a interswitch port used to communicated with
-*		CPU or to cascade with another switch device.
+*        This routine retrives Port 9's duplex configuration mode determined
+*        at reset.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if configured as Full duplex operation
+*                  GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        Return value is valid only if the given port is 9.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetInterswitchPort
+GT_STATUS gprtGetC_Duplex
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtGetInterswithPort
+* gprtGetC_Mode
 *
 * DESCRIPTION:
-*		This routine gets InterswitchPort.
+*        This routine retrives port's interface type configuration mode 
+*        determined at reset.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: This port is interswitch port,
-*				 GT_FALSE otherwise
+*        state - one of value in GT_PORT_CONFIG_MODE enum type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        Return value is valid only if the given port is 9.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetInterswitchPort
+GT_STATUS gprtGetC_Mode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_CONFIG_MODE   *state
 );
 
+
+/* gtSysCtrl.c */
+
 /*******************************************************************************
-* gprtSetLearnDisable
+* gsysSetPPUEn
 *
 * DESCRIPTION:
-*		This routine enables/disables automatic learning of new source MAC
-*		addresses on the given port ingress
+*        This routine enables/disables Phy Polling Unit.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for disable or GT_FALSE otherwise
+*        en - GT_TRUE to enable PPU, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetLearnDisable
+GT_STATUS gsysSetPPUEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
 );
 
-
 /*******************************************************************************
-* gprtGetLearnDisable
+* gsysGetPPUEn
 *
 * DESCRIPTION:
-*		This routine gets LearnDisable setup
+*        This routine get the PPU state.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: Learning disabled on the given port ingress frames,
-*				 GT_FALSE otherwise
+*        en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetLearnDisable
+GT_STATUS gsysGetPPUEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtSetIgnoreFCS
+* gsysSetCascadePort
 *
 * DESCRIPTION:
-*		This routine sets FCS Ignore mode. When this bit is set to a one,
-*		the last four bytes of frames received on this port are overwritten with
-*		a good CRC and the frames will be accepted by the switch.
+*        This routine sets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*        port - Cascade Port
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetIgnoreFCS
+GT_STATUS gsysSetCascadePort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL 		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
 );
 
 /*******************************************************************************
-* gprtGetIgnoreFCS
+* gsysGetCascadePort
 *
 * DESCRIPTION:
-*		This routine gets Ignore FCS setup
+*        This routine gets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
-*				 GT_FALSE otherwise
+*        port - Cascade Port
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetIgnoreFCS
+GT_STATUS gsysGetCascadePort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
 );
 
 /*******************************************************************************
-* gprtSetVTUPriOverride
+* gsysSetDeviceNumber
 *
 * DESCRIPTION:
-*		VTU Priority Override. The following modes are supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        This routine sets Device Number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip. From CPU frames whose Dev_Num
+*        fieldmatches these bits have reachedtheir destination chip and are sent
+*        out this chip using the port number indicated in the frame's Trg_Port 
+*        field.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        devNum - Device Number (0 ~ 31)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+* COMMENTS:
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetVTUPriOverride
+GT_STATUS gsysSetDeviceNumber
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_PRI_OVERRIDE		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum
 );
 
 /*******************************************************************************
-* gprtGetVTUPriOverride
+* gsysGetDeviceNumber
 *
 * DESCRIPTION:
-*		VTU Priority Override. The following modes are supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        This routine gets Device Number.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        devNum - Device Number (0 ~ 31)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetVTUPriOverride
+GT_STATUS gsysGetDeviceNumber
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *devNum
 );
 
+
+/* gtPCSCtrl.c */
+
+
 /*******************************************************************************
-* gprtSetSAPriOverride
+* gpcsGetCommaDet
 *
 * DESCRIPTION:
-*		SA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        This routine retrieves Comma Detection status in PCS
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
+* COMMENTS:
 *
-* COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetSAPriOverride
+GT_STATUS gpcsGetCommaDet
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtGetSAPriOverride
+* gpcsGetSyncOK
 *
 * DESCRIPTION:
-*		SA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        This routine retrieves SynOK bit. It is set to a one when the PCS has
+*        detected a few comma patterns and is synchronized with its peer PCS 
+*        layer.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        state - GT_TRUE if synchronized or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetSAPriOverride
+GT_STATUS gpcsGetSyncOK
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtSetDAPriOverride
+* gpcsGetSyncFail
 *
 * DESCRIPTION:
-*		DA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
+*        This routine retrieves SynFail bit.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
+* COMMENTS:
 *
-* COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDAPriOverride
+GT_STATUS gpcsGetSyncFail
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_PRI_OVERRIDE		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtGetDAPriOverride
+* gpcsGetAnBypassed
 *
 * DESCRIPTION:
-*		DA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
+*        This routine retrieves Inband Auto-Negotiation bypass status.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetDAPriOverride
+GT_STATUS gpcsGetAnBypassed
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtSetCPUPort
+* gpcsGetAnBypassMode
 *
 * DESCRIPTION:
-*		This routine sets CPU Port number. When Snooping is enabled on this port
-*		or when this port is configured as an Interswitch Port and it receives a 
-*		To_CPU frame, the switch needs to know what port on this device the frame 
-*		should egress.
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
 *
 * INPUTS:
-*		port - the logical port number.
-*		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
+* COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetCPUPort
+GT_STATUS gpcsGetAnBypassMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_LPORT 	cpuPort
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
 );
 
 /*******************************************************************************
-* gprtGetCPUPort
+* gpcsSetAnBypassMode
 *
 * DESCRIPTION:
-*		This routine gets CPU Logical Port
+*        This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		cpuPort - CPU Port's logical number
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetCPUPort
+GT_STATUS gpcsSetAnBypassMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_LPORT 	*cpuLPort
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
 );
 
 /*******************************************************************************
-* gprtSetLockedPort
+* gpcsGetPCSAnEn
 *
 * DESCRIPTION:
-*		This routine sets LockedPort. When it's set to one, CPU directed 
-*		learning for 802.1x MAC authentication is enabled on this port. In this
-*		mode, an ATU Miss Violation interrupt will occur when a new SA address
-*		is received in a frame on this port. Automatically SA learning and 
-*		refreshing is disabled in this mode.
+*        This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
+* COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetLockedPort
+GT_STATUS gpcsGetPCSAnEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
 );
 
 /*******************************************************************************
-* gprtGetLockedPort
+* gpcsSetPCSAnEn
 *
 * DESCRIPTION:
-*		This routine gets Locked Port mode for the given port
+*        This routine sets Enable mode of PCS Inband Auto-Negotiation.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetLockedPort
+GT_STATUS gpcsSetPCSAnEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
 );
 
 /*******************************************************************************
-* gprtSetIgnoreWrongData
+* gpcsSetRestartPCSAn
 *
 * DESCRIPTION:
-*		This routine sets Ignore Wrong Data. If the frame's SA address is found 
-*		in the database and if the entry is 'static' or if the port is 'locked'
-*		the source port's bit is checked to insure the SA has been assigned to 
-*		this port. If the SA is NOT assigned to this port, it is considered an 
-*		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
-*		Member Violation interrupt will be generated. If it's set to GT_TRUE,
-*		the ATU Member Violation error will be masked and ignored.
+*        This routine restarts PCS Inband Auto-Negotiation.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
+* COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetIgnoreWrongData
+GT_STATUS gpcsSetRestartPCSAn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
 );
 
-
 /*******************************************************************************
-* gprtGetIgnoreWrongData
+* gpcsGetPCSAnDone
 *
 * DESCRIPTION:
-*		This routine gets Ignore Wrong Data mode for the given port
+*        This routine retrieves completion information of PCS Auto-Negotiation.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*        mode - GT_TRUE if PCS AN is done or never done
+*                GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetIgnoreWrongData
+GT_STATUS gpcsGetPCSAnDone
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
 );
 
-
-/* gtPortRateCtrl.c */
-
-/* gtPortRmon.c */
-
 /*******************************************************************************
-* gstatsGetPortCounter2
+* gpcsSetLinkValue
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*        This routine sets Link's force value
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        port - the logical port number.
+*        state - GT_TRUE to force link up, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        None
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortCounter2
+GT_STATUS gpcsSetLinkValue
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS2	counter,
-	OUT GT_U32			*statsData
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
-
 /*******************************************************************************
-* gstatsGetPortAllCounters2
+* gpcsGetLinkValue
 *
 * DESCRIPTION:
-*		This routine gets all counters of the given port
+*        This routine retrieves Link Value which will be used for Forcing Link 
+*        up or down.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*        state - GT_TRUE if Link Force value is one (link up)
+*                 GT_FALSE otherwise (link down)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortAllCounters2
+GT_STATUS gpcsGetLinkValue
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gstatsGetHistogramMode
+* gpcsSetForcedLink
 *
 * DESCRIPTION:
-*		This routine gets the Histogram Counters Mode.
+*        This routine forces Link. If LinkValue is set to one, calling this 
+*        routine with GT_TRUE will force Link to be up.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number.
+*        state - GT_TRUE to force link (up or down), GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
-*					and GT_COUNT_RX_TX)
+*        None
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsGetHistogramMode
+GT_STATUS gpcsSetForcedLink
 (
-	IN  GT_QD_DEV				*dev,
-	OUT GT_HISTOGRAM_MODE	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
 /*******************************************************************************
-* gstatsSetHistogramMode
+* gpcsGetForcedLink
 *
 * DESCRIPTION:
-*		This routine sets the Histogram Counters Mode.
+*        This routine retrieves Forced Link bit
 *
 * INPUTS:
-*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
-*					and GT_COUNT_RX_TX)
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if ForcedLink bit is one,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsSetHistogramMode
+GT_STATUS gpcsGetForcedLink
 (
-	IN GT_QD_DEV 				*dev,
-	IN GT_HISTOGRAM_MODE		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
-
-/* gtPortStatus.c */
-
 /*******************************************************************************
-* gprtGetPauseEn
+* gpcsSetDpxValue
 *
 * DESCRIPTION:
-*		This routine retrives the link pause state.
+*        This routine sets Duplex's Forced value. This function needs to be
+*        called prior to gpcsSetForcedDpx.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        state - GT_TRUE to force full duplex, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		state - GT_TRUE for enable or GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		If set MAC Pause (for Full Duplex flow control) is implemented in the
-*		link partner and in MyPause
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPauseEn
+GT_STATUS gpcsSetDpxValue
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
 /*******************************************************************************
-* gprtGetHdFlow
+* gpcsGetDpxValue
 *
 * DESCRIPTION:
-*		This routine retrives the half duplex flow control value.
-*		If set, Half Duplex back pressure will be used on this port if this port
-*		is in a half duplex mode.
+*        This routine retrieves Duplex's Forced value
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE for enable or GT_FALSE otherwise
+*        state - GT_TRUE if Duplex's Forced value is set to Full duplex,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetHdFlow
+GT_STATUS gpcsGetDpxValue
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL 	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtGetPHYDetect
+* gpcsSetForcedDpx
 *
 * DESCRIPTION:
-*		This routine retrives the information regarding PHY detection.
-*		If set, An 802.3 PHY is attached to this port.
+*        This routine forces duplex mode. If DpxValue is set to one, calling this 
+*        routine with GT_TRUE will force duplex mode to be full duplex.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        state - GT_TRUE to force duplex mode, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		state - GT_TRUE if connected or GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		
+*
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPHYDetect
+GT_STATUS gpcsSetForcedDpx
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL 	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
 /*******************************************************************************
-* gprtSetPHYDetect
+* gpcsGetForcedDpx
 *
 * DESCRIPTION:
-*		This routine sets PHYDetect bit which make PPU change its polling.
-*		PPU's pool routine uses these bits to determine which port's to poll
-*		PHYs on for Link, Duplex, Speed, and Flow Control.
+*        This routine retrieves Forced Duplex.
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE or GT_FALSE
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if ForcedDpx bit is one,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		This function should not be called if gsysGetPPUState returns 
-*		PPU_STATE_ACTIVE.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetPHYDetect
+GT_STATUS gpcsGetForcedDpx
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_BOOL  	state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gprtGetSpeedMode
+* gpcsSetForceSpeed
 *
 * DESCRIPTION:
-*       This routine retrives the port speed.
+*        This routine forces speed. 
 *
 * INPUTS:
-*       port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
 *
 * OUTPUTS:
-*       mode - GT_PORT_SPEED_MODE type.
-*					(PORT_SPEED_1000_MBPS,PORT_SPEED_100_MBPS, or PORT_SPEED_10_MBPS)
+*        None
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
-*
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetSpeedMode
+GT_STATUS gpcsSetForceSpeed
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_LPORT  port,
-    OUT GT_PORT_SPEED_MODE   *speed
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_PORT_FORCED_SPEED_MODE  mode
 );
 
 /*******************************************************************************
-* gprtGetHighErrorRate
+* gpcsGetForceSpeed
 *
 * DESCRIPTION:
-*		This routine retrives the PCS High Error Rate.
-*		This routine returns GT_TRUE if the rate of invalid code groups seen by
-*		PCS has exceeded 10 to the power of -11.
+*        This routine retrieves Force Speed value
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE or GT_FALSE
+*        state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetHighErrorRate
+GT_STATUS gpcsGetForceSpeed
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PORT_FORCED_SPEED_MODE   *mode
 );
 
+
+
+/* gtQosMap.c */
+
 /*******************************************************************************
-* gprtGetTxPaused
+* gqosGetTagRemap
 *
 * DESCRIPTION:
-*		This routine retrives Transmit Pause state.
+*        Gets the remapped priority value for a specific 802.1p priority on a
+*        given port.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
+*        pri   - 802.1p priority
 *
 * OUTPUTS:
-*		state - GT_TRUE if Rx MAC receives a PAUSE frame with none-zero Puase Time
-*				  GT_FALSE otherwise.
+*        remappedPri - remapped Priority
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetTxPaused
+GT_STATUS gqosGetTagRemap
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U8        pri,
+    OUT GT_U8       *remappedPri
 );
 
-
 /*******************************************************************************
-* gprtGetFlowCtrl
+* gqosSetTagRemap
 *
 * DESCRIPTION:
-*		This routine retrives Flow control state.
+*        Sets the remapped priority value for a specific 802.1p priority on a
+*        given port.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*        remappedPri - remapped Priority
 *
 * OUTPUTS:
-*		state - GT_TRUE if Rx MAC determines that no more data should be 
-*					entering this port.
-*				  GT_FALSE otherwise.
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetFlowCtrl
+GT_STATUS gqosSetTagRemap
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U8        pri,
+    IN GT_U8        remappedPri
 );
 
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
 /*******************************************************************************
-* gprtGetC_Duplex
+* gsysGetPPUState
 *
 * DESCRIPTION:
-*		This routine retrives Port 9's duplex configuration mode determined
-*		at reset.
+*        This routine get the PPU State. These two bits return 
+*        the current value of the PPU.
 *
 * INPUTS:
-*		port - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		state - GT_TRUE if configured as Full duplex operation
-*				  GT_FALSE otherwise.
+*        mode - GT_PPU_STATE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Return value is valid only if the given port is 9.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetC_Duplex
+GT_STATUS gsysGetPPUState
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV       *dev,
+    OUT GT_PPU_STATE    *mode
 );
 
+
+/* Prototypes added for 88E6093 */
+
+
+/* gtBrgFdb.c */
+
 /*******************************************************************************
-* gprtGetC_Mode
+* gfdbGetLearn2All
 *
 * DESCRIPTION:
-*		This routine retrives port's interface type configuration mode 
-*		determined at reset.
+*        When more than one Marvell device is used to form a single 'switch', it
+*        may be desirable for all devices in the 'switch' to learn any address this 
+*        device learns. When this bit is set to a one all other devices in the 
+*        'switch' learn the same addresses this device learns. When this bit is 
+*        cleared to a zero, only the devices that actually receive frames will learn
+*        from those frames. This mode typically supports more active MAC addresses 
+*        at one time as each device in the switch does not need to learn addresses 
+*        it may nerver use.
 *
 * INPUTS:
-*		port - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		state - one of value in GT_PORT_CONFIG_MODE enum type
+*        mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Return value is valid only if the given port is 9.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetC_Mode
+GT_STATUS gfdbGetLearn2All
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PORT_CONFIG_MODE   *state
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
 );
 
-
-/* gtSysCtrl.c */
-
 /*******************************************************************************
-* gsysSetPPUEn
+* gfdbSetLearn2All
 *
 * DESCRIPTION:
-*		This routine enables/disables Phy Polling Unit.
+*        Enable or disable Learn2All mode.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*        mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetPPUEn
+GT_STATUS gfdbSetLearn2All
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gsysGetPPUEn
+* gfdbRemovePort
 *
 * DESCRIPTION:
-*		This routine get the PPU state.
+*       This routine deassociages all or unblocked addresses from a port.
 *
 * INPUTS:
-*		None.
+*       moveCmd - the move operation type.
+*       port - the logical port number.
 *
 * OUTPUTS:
-*		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*       None
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetPPUEn
+GT_STATUS gfdbRemovePort
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* gsysSetCascadePort
+* gfdbRemovePortInDB
 *
 * DESCRIPTION:
-*		This routine sets Cascade Port number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip.
+*       This routine deassociages all or unblocked addresses from a port in the
+*       particular ATU Database (DBNum).
 *
 * INPUTS:
-*		port - Cascade Port
+*       moveCmd  - the move operation type.
+*       port - the logical port number.
+*        DBNum     - ATU MAC Address Database Number.
 *
 * OUTPUTS:
-*		None.
+*       None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*       GT_NOT_SUPPORTED- if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetCascadePort
+GT_STATUS gfdbRemovePortInDB
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port,
+    IN GT_U32         DBNum
 );
 
+
+
+/* gtBrgStp.c */
+
+/* gtBrgVlan.c */
+
+/* gtBrgVtu.c */
+
+/* gtEvents.c */
+
+/* gtPCSCtrl.c */
+
 /*******************************************************************************
-* gsysGetCascadePort
+* gpcsGetPCSLink
 *
 * DESCRIPTION:
-*		This routine gets Cascade Port number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip.
+*        This routine retrieves Link up status in PCS
 *
 * INPUTS:
-*		None.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		port - Cascade Port
+*        state - GT_TRUE for Comma Detected or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetCascadePort
+GT_STATUS gpcsGetPCSLink
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gsysSetDeviceNumber
+* gpcsSetFCValue
 *
 * DESCRIPTION:
-*		This routine sets Device Number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip. From CPU frames whose Dev_Num
-*		fieldmatches these bits have reachedtheir destination chip and are sent
-*		out this chip using the port number indicated in the frame's Trg_Port 
-*		field.
+*        This routine sets Flow Control's force value
 *
 * INPUTS:
-*		devNum - Device Number (0 ~ 31)
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetDeviceNumber
+GT_STATUS gpcsSetFCValue
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		devNum
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
 /*******************************************************************************
-* gsysGetDeviceNumber
+* gpcsGetFCValue
 *
 * DESCRIPTION:
-*		This routine gets Device Number.
+*        This routine retrieves Flow Control Value which will be used for Forcing 
+*        Flow Control enabled or disabled.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		devNum - Device Number (0 ~ 31)
+*        state - GT_TRUE if FC Force value is one (flow control enabled)
+*                 GT_FALSE otherwise (flow control disabled)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetDeviceNumber
+GT_STATUS gpcsGetFCValue
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U32  	*devNum
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
-
-/* gtPCSCtrl.c */
-
-
 /*******************************************************************************
-* gpcsGetCommaDet
+* gpcsSetForcedFC
 *
 * DESCRIPTION:
-*		This routine retrieves Comma Detection status in PCS
+*        This routine forces Flow Control. If FCValue is set to one, calling this 
+*        routine with GT_TRUE will force Flow Control to be enabled.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
 *
 * OUTPUTS:
-*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetCommaDet
+GT_STATUS gpcsSetForcedFC
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN    GT_BOOL        state
 );
 
 /*******************************************************************************
-* gpcsGetSyncOK
+* gpcsGetForcedFC
 *
 * DESCRIPTION:
-*		This routine retrieves SynOK bit. It is set to a one when the PCS has
-*		detected a few comma patterns and is synchronized with its peer PCS 
-*		layer.
+*        This routine retrieves Forced Flow Control bit
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if synchronized or GT_FALSE otherwise
+*        state - GT_TRUE if ForcedFC bit is one,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*        
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetSyncOK
+GT_STATUS gpcsGetForcedFC
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
+
+
+/* gtPhyCtrl.c */
+
 /*******************************************************************************
-* gpcsGetSyncFail
+* gprtGetPagedPhyReg
 *
 * DESCRIPTION:
-*		This routine retrieves SynFail bit.
+*       This routine reads phy register of the given page
 *
 * INPUTS:
-*		port - the logical port number.
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
 *
 * OUTPUTS:
-*		state - GT_TRUE if synchronizaion failed or GT_FALSE otherwise
+*        data    - value of the read register
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
 *
-* GalTis:
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gpcsGetSyncFail
+GT_STATUS gprtGetPagedPhyReg
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
 );
 
 /*******************************************************************************
-* gpcsGetAnBypassed
+* gprtSetPagedPhyReg
 *
 * DESCRIPTION:
-*		This routine retrieves Inband Auto-Negotiation bypass status.
+*       This routine writes a value to phy register of the given page
 *
 * INPUTS:
-*		port - the logical port number.
+*        port     - port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
 *
 * OUTPUTS:
-*		state - GT_TRUE if AN is bypassed or GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
 *
-* GalTis:
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gpcsGetAnBypassed
+GT_STATUS gprtSetPagedPhyReg
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 data
 );
 
+
+/* gtPortCtrl.c */
+
 /*******************************************************************************
-* gpcsGetAnBypassMode
+* gprtSetUseCoreTag
 *
 * DESCRIPTION:
-*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*       This routine set the UseCoreTag bit in Port Control Register.
+*            When this bit is cleared to a zero, ingressing frames are considered
+*            Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*            When this bit is set to a one, ingressing frames are considered Tagged
+*            if the 16-bits following the frame's Source Address is equal to the 
+*            CoreTag register value.
 *
 * INPUTS:
-*		port - the logical port number.
+*       port  - the logical port number.
+*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode - GT_TRUE if AN bypass is enabled or GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
 * COMMENTS:
 *
+*
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetAnBypassMode
+GT_STATUS gprtSetUseCoreTag
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*mode
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    force
 );
 
 /*******************************************************************************
-* gpcsSetAnBypassMode
+* gprtGetUseCoreTag
 *
 * DESCRIPTION:
-*		This routine retrieves Enable mode of Inband Auto-Negotiation bypass.
+*       This routine get the Use Core Tag state.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to enable AN bypass mode or GT_FALSE otherwise
+*       port  - the logical port number.
 *
 * OUTPUTS:
-*		None
+*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
 * COMMENTS:
 *
+*
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetAnBypassMode
+GT_STATUS gprtGetUseCoreTag
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL  	mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *force
 );
 
 /*******************************************************************************
-* gpcsGetPCSAnEn
+* gprtSetDiscardTagged
 *
 * DESCRIPTION:
-*		This routine retrieves Enable mode of PCS Inband Auto-Negotiation.
+*        When this bit is set to a one, all non-MGMT frames that are processed as 
+*        Tagged will be discarded as they enter this switch port. Priority only 
+*        tagged frames (with a VID of 0x000) are considered tagged.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode - GT_TRUE if PCS AN is enabled or GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetPCSAnEn
+GT_STATUS gprtSetDiscardTagged
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsSetPCSAnEn
+* gprtGetDiscardTagged
 *
 * DESCRIPTION:
-*		This routine sets Enable mode of PCS Inband Auto-Negotiation.
+*        This routine gets DiscardTagged bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to enable PCS AN mode or GT_FALSE otherwise
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None
+*        mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetPCSAnEn
+GT_STATUS gprtGetDiscardTagged
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL  	mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gpcsSetRestartPCSAn
+* gprtSetDiscardUntagged
 *
 * DESCRIPTION:
-*		This routine restarts PCS Inband Auto-Negotiation.
+*        When this bit is set to a one, all non-MGMT frames that are processed as 
+*        Untagged will be discarded as they enter this switch port. Priority only 
+*        tagged frames (with a VID of 0x000) are considered tagged.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetRestartPCSAn
+GT_STATUS gprtSetDiscardUntagged
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsGetPCSAnDone
+* gprtGetDiscardUntagged
 *
 * DESCRIPTION:
-*		This routine retrieves completion information of PCS Auto-Negotiation.
+*        This routine gets DiscardUntagged bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE if PCS AN is done or never done
-*			    GT_FALSE otherwise
+*        mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetPCSAnDone
+GT_STATUS gprtGetDiscardUntagged
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gpcsSetLinkValue
+* gprtSetMapDA
 *
 * DESCRIPTION:
-*		This routine sets Link's force value
+*        When this bit is set to a one, normal switch operation will occur where a 
+*        frame's DA address is used to direct the frame out the correct port.
+*        When this be is cleared to a zero, the frame will be sent out the port(s) 
+*        defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+*        is ound in the address database.
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force link up, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to use MapDA, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetLinkValue
+GT_STATUS gprtSetMapDA
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsGetLinkValue
+* gprtGetMapDA
 *
 * DESCRIPTION:
-*		This routine retrieves Link Value which will be used for Forcing Link 
-*		up or down.
+*        This routine gets MapDA bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if Link Force value is one (link up)
-*			     GT_FALSE otherwise (link down)
+*        mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetLinkValue
+GT_STATUS gprtGetMapDA
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gpcsSetForcedLink
+* gprtSetDefaultForward
 *
 * DESCRIPTION:
-*		This routine forces Link. If LinkValue is set to one, calling this 
-*		routine with GT_TRUE will force Link to be up.
+*        When this bit is set to a one, normal switch operation will occurs and 
+*        multicast frames with unknown DA addresses are allowed to egress out this 
+*        port (assuming the VLAN settings allow the frame to egress this port too).
+*        When this be is cleared to a zero, multicast frames with unknown DA 
+*        addresses will not egress out this port.
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force link (up or down), GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetForcedLink
+GT_STATUS gprtSetDefaultForward
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsGetForcedLink
+* gprtGetDefaultForward
 *
 * DESCRIPTION:
-*		This routine retrieves Forced Link bit
+*        This routine gets DefaultForward bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if ForcedLink bit is one,
-*			     GT_FALSE otherwise
+*        mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetForcedLink
+GT_STATUS gprtGetDefaultForward
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gpcsSetDpxValue
+* gprtSetEgressMonitorSource
 *
 * DESCRIPTION:
-*		This routine sets Duplex's Forced value. This function needs to be
-*		called prior to gpcsSetForcedDpx.
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force full duplex, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetDpxValue
+GT_STATUS gprtSetEgressMonitorSource
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsGetDpxValue
+* gprtGetEgressMonitorSource
 *
 * DESCRIPTION:
-*		This routine retrieves Duplex's Forced value
+*        This routine gets EgressMonitorSource bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if Duplex's Forced value is set to Full duplex,
-*			     GT_FALSE otherwise
+*        mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetDpxValue
+GT_STATUS gprtGetEgressMonitorSource
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gpcsSetForcedDpx
+* gprtSetIngressMonitorSource
 *
 * DESCRIPTION:
-*		This routine forces duplex mode. If DpxValue is set to one, calling this 
-*		routine with GT_TRUE will force duplex mode to be full duplex.
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force duplex mode, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetForcedDpx
+GT_STATUS gprtSetIngressMonitorSource
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsGetForcedDpx
+* gprtGetIngressMonitorSource
 *
 * DESCRIPTION:
-*		This routine retrieves Forced Duplex.
+*        This routine gets IngressMonitorSource bit for the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if ForcedDpx bit is one,
-*			     GT_FALSE otherwise
+*        mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetForcedDpx
+GT_STATUS gprtGetIngressMonitorSource
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
+
+/* gtPortPAV.c */
+
+/* gtPortRateCtrl.c */
+
+/* gtPortRmon.c */
+
 /*******************************************************************************
-* gpcsSetForceSpeed
+* gstatsGetPortCounter3
 *
 * DESCRIPTION:
-*		This routine forces speed. 
+*        This routine gets a specific counter of the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or No Speed Force)
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		None
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
 * COMMENTS:
+*        This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetForceSpeed
+GT_STATUS gstatsGetPortCounter3
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_PORT_FORCED_SPEED_MODE  mode
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
 );
 
 /*******************************************************************************
-* gpcsGetForceSpeed
+* gstatsGetPortAllCounters3
 *
 * DESCRIPTION:
-*		This routine retrieves Force Speed value
+*        This routine gets all counters of the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_PORT_FORCED_SPEED_MODE (10, 100, 1000, or no force speed)
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*
 * COMMENTS:
+*        This function supports Gigabit Switch only
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetForceSpeed
+GT_STATUS gstatsGetPortAllCounters3
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PORT_FORCED_SPEED_MODE   *mode
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET3    *statsCounterSet
 );
 
 
-
-/* gtQosMap.c */
+/* gtPortStat.c */
 
 /*******************************************************************************
-* gqosGetTagRemap
+* gprtGetPortCtr2
 *
 * DESCRIPTION:
-*		Gets the remapped priority value for a specific 802.1p priority on a
-*		given port.
+*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
 *
 * INPUTS:
-*		port  - the logical port number.
-*		pri   - 802.1p priority
+*       port  - the logical port number.
 *
 * OUTPUTS:
-*		remappedPri - remapped Priority
+*       ctr - the counters value.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gqosGetTagRemap
+GT_STATUS gprtGetPortCtr2
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U8    	pri,
-	OUT GT_U8   	*remappedPri
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_PORT_STAT2   *ctr
 );
 
+/* gtPortStatus.c */
+
 /*******************************************************************************
-* gqosSetTagRemap
+* gprtGetMGMII
 *
 * DESCRIPTION:
-*		Sets the remapped priority value for a specific 802.1p priority on a
-*		given port.
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port 
+*        and the PHY will be MGMII. When no PHY is detected on this port and the 
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
 *
 * INPUTS:
-*		port  - the logical port number.
-*		pri   - 802.1p priority
-*		remappedPri - remapped Priority
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None
+*        state - GT_TRUE or GT_FALSE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gqosSetTagRemap
+GT_STATUS gprtGetMGMII
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_U8    	pri,
-	IN GT_U8    	remappedPri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
-
-/* gtSysConfig.c */
-
-/* gtSysStatus.c */
-
 /*******************************************************************************
-* gsysGetPPUState
+* gprtSetMGMII
 *
 * DESCRIPTION:
-*		This routine get the PPU State. These two bits return 
-*		the current value of the PPU.
+*        SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
+*        detected connected to this port, the SERDES interface between this port
+*        and the PHY will be SGMII.  When this bit is set toa one and a PHY is
+*        detected connected to this port, the SERDES interface between this port 
+*        and the PHY will be MGMII. When no PHY is detected on this port and the 
+*        SERDES interface is being used, it will be configured in 1000Base-X mode.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number.
+*        state - GT_TRUE or GT_FALSE
 *
 * OUTPUTS:
-*		mode - GT_PPU_STATE
+*        None
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetPPUState
+GT_STATUS gprtSetMGMII
 (
-	IN  GT_QD_DEV   	*dev,
-	OUT GT_PPU_STATE	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      state
 );
 
 
-/* Prototypes added for 88E6093 */
-
+/* gtQosMap.c */
 
-/* gtBrgFdb.c */
+/* gtSysCtrl.c */
 
 /*******************************************************************************
-* gfdbGetLearn2All
+* gsysSetCoreTagType
 *
 * DESCRIPTION:
-*		When more than one Marvell device is used to form a single 'switch', it
-*		may be desirable for all devices in the 'switch' to learn any address this 
-*		device learns. When this bit is set to a one all other devices in the 
-*		'switch' learn the same addresses this device learns. When this bit is 
-*		cleared to a zero, only the devices that actually receive frames will learn
-*		from those frames. This mode typically supports more active MAC addresses 
-*		at one time as each device in the switch does not need to learn addresses 
-*		it may nerver use.
+*        This routine sets Ether Core Tag Type.
+*        This Ether Type is added to frames that egress the switch as Double Tagged 
+*        frames. It is also the Ether Type expected during Ingress to determine if 
+*        a frame is Tagged or not on ports configured as UseCoreTag mode.
 *
 * INPUTS:
-*		None.
+*        etherType - Core Tag Type (2 bytes)
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbGetLearn2All
+GT_STATUS gsysSetCoreTagType
 (
-	IN  GT_QD_DEV    *dev,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_U16          etherType
 );
 
 /*******************************************************************************
-* gfdbSetLearn2All
+* gsysGetCoreTagType
 *
 * DESCRIPTION:
-*		Enable or disable Learn2All mode.
+*        This routine gets CoreTagType
 *
 * INPUTS:
-*		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        etherType - Core Tag Type (2 bytes)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbSetLearn2All
+GT_STATUS gsysGetCoreTagType
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *etherType
 );
 
 /*******************************************************************************
-* gfdbRemovePort
+* gsysSetIngressMonitorDest
 *
 * DESCRIPTION:
-*       This routine deassociages all or unblocked addresses from a port.
+*        This routine sets Ingress Monitor Destination Port. Frames that are 
+*        targeted toward an Ingress Monitor Destination go out the port number 
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Ingress Monitor type, and frames received on a Network port that 
+*        is enabled to be the Ingress Monitor Source Port.
+*        If the Ingress Monitor Destination Port resides in this device these bits 
+*        should point to the Network port where these frames are to egress. If the 
+*        Ingress Monitor Destination Port resides in another device these bits 
+*        should point to the Marvell Tag port in this device that is used to get 
+*        to the device that contains the Ingress Monitor Destination Port.
 *
 * INPUTS:
-*       moveCmd - the move operation type.
-*       port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       None
+*        None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbRemovePort
+GT_STATUS gsysSetIngressMonitorDest
 (
-	IN GT_QD_DEV    *dev,
-    IN GT_MOVE_CMD 	moveCmd,
-    IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* gfdbRemovePortInDB
+* gsysGetIngressMonitorDest
 *
 * DESCRIPTION:
-*       This routine deassociages all or unblocked addresses from a port in the
-*       particular ATU Database (DBNum).
+*        This routine gets Ingress Monitor Destination Port.
 *
 * INPUTS:
-*       moveCmd  - the move operation type.
-*       port - the logical port number.
-*		DBNum	 - ATU MAC Address Database Number.
+*        None.
 *
 * OUTPUTS:
-*       None
+*        port  - the logical port number.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*       GT_NOT_SUPPORTED- if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gfdbRemovePortInDB
+GT_STATUS gsysGetIngressMonitorDest
 (
-	IN GT_QD_DEV    *dev,
-    IN GT_MOVE_CMD 	moveCmd,
-    IN GT_LPORT		port,
-	IN GT_U32 		DBNum
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 );
 
-
-
-/* gtBrgStp.c */
-
-/* gtBrgVlan.c */
-
-/* gtBrgVtu.c */
-
-/* gtEvents.c */
-
-/* gtPCSCtrl.c */
-
 /*******************************************************************************
-* gpcsGetPCSLink
+* gsysSetEgressMonitorDest
 *
 * DESCRIPTION:
-*		This routine retrieves Link up status in PCS
+*        This routine sets Egress Monitor Destination Port. Frames that are 
+*        targeted toward an Egress Monitor Destination go out the port number 
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Egress Monitor type, and frames transmitted on a Network port that 
+*        is enabled to be the Egress Monitor Source Port.
+*        If the Egress Monitor Destination Port resides in this device these bits 
+*        should point to the Network port where these frames are to egress. If the 
+*        Egress Monitor Destination Port resides in another device these bits 
+*        should point to the Marvell Tag port in this device that is used to get 
+*        to the device that contains the Egress Monitor Destination Port.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE for Comma Detected or GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsGetPCSLink
+GT_STATUS gsysSetEgressMonitorDest
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* gpcsSetFCValue
+* gsysGetEgressMonitorDest
 *
 * DESCRIPTION:
-*		This routine sets Flow Control's force value
+*        This routine gets Egress Monitor Destination Port.
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force flow control enabled, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetFCValue
+GT_STATUS gsysGetEgressMonitorDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 );
 
+
+/* gtSysConfig.c */
+
+/* gtSysStatus.c */
+
+
+/* functions added on rev 2.2 */
+
+/* gtPortCtrl.c */
+
 /*******************************************************************************
-* gpcsGetFCValue
+* gprtSetMessagePort
 *
 * DESCRIPTION:
-*		This routine retrieves Flow Control Value which will be used for Forcing 
-*		Flow Control enabled or disabled.
+*        When the Learn2All bit is set to one, learning message frames are 
+*        generated. These frames will be sent out all ports whose Message Port is 
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports, 
+*        except for the CPU's port, have their MessagePort bit set to one. 
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*        
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		state - GT_TRUE if FC Force value is one (flow control enabled)
-*			     GT_FALSE otherwise (flow control disabled)
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gpcsGetFCValue
+GT_STATUS gprtSetMessagePort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpcsSetForcedFC
+* gprtGetMessagePort
 *
 * DESCRIPTION:
-*		This routine forces Flow Control. If FCValue is set to one, calling this 
-*		routine with GT_TRUE will force Flow Control to be enabled.
+*        When the Learn2All bit is set to one, learning message frames are 
+*        generated. These frames will be sent out all ports whose Message Port is 
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports, 
+*        except for the CPU's port, have their MessagePort bit set to one. 
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
 *
+*        
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE to force flow control (enable or disable), GT_FALSE otherwise
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gpcsSetForcedFC
+GT_STATUS gprtGetMessagePort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN	GT_BOOL		state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 );
 
+
 /*******************************************************************************
-* gpcsGetForcedFC
+* gprtSetTrunkPort
 *
 * DESCRIPTION:
-*		This routine retrieves Forced Flow Control bit
-*
+*        This function enables/disables and sets the trunk ID.
+*        
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*             GT_FALSE, otherwise.
+*        trunkId - valid ID is 0 ~ 15.
 *
 * OUTPUTS:
-*		state - GT_TRUE if ForcedFC bit is one,
-*			     GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*		
-* COMMENTS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gpcsGetForcedFC
+GT_STATUS gprtSetTrunkPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         en,
+    IN GT_U32        trunkId
 );
 
 
-
-/* gtPhyCtrl.c */
-
 /*******************************************************************************
-* gprtGetPagedPhyReg
+* gprtGetTrunkPort
 *
 * DESCRIPTION:
-*       This routine reads phy register of the given page
-*
+*        This function returns trunk state of the port.
+*        When trunk is disabled, trunkId field won't have valid value.
+*        
 * INPUTS:
-*		port 	- port to be read
-*		regAddr	- register offset to be read
-*		page	- page number to be read
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		data	- value of the read register
+*        en - GT_TRUE, if the port is a member of a trunk,
+*             GT_FALSE, otherwise.
+*        trunkId - 0 ~ 15, valid only if en is GT_TRUE
 *
 * RETURNS:
-*       GT_OK   			- if read successed
-*       GT_FAIL   			- if read failed
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gprtGetPagedPhyReg
+GT_STATUS gprtGetTrunkPort
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_U32  port,
-	IN	GT_U32  regAddr,
-	IN	GT_U32  page,
-    OUT GT_U16* data
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    OUT GT_BOOL     *en,
+    OUT GT_U32        *trunkId
 );
 
+
+
+
 /*******************************************************************************
-* gprtSetPagedPhyReg
+* gprtGetGlobal2Reg
 *
 * DESCRIPTION:
-*       This routine writes a value to phy register of the given page
+*       This routine reads Switch Global 2 Registers.
 *
 * INPUTS:
-*		port 	- port to be read
-*		regAddr	- register offset to be read
-*		page	- page number to be read
-*		data	- value of the read register
+*       regAddr - The register's address.
 *
 * OUTPUTS:
-*		None
+*       data    - The read register's data.
 *
 * RETURNS:
-*       GT_OK   			- if read successed
-*       GT_FAIL   			- if read failed
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
 *       None.
 *
+* GalTis:
+*
 *******************************************************************************/
-GT_STATUS gprtSetPagedPhyReg
+GT_STATUS gprtGetGlobal2Reg
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_U32 port,
-	IN	GT_U32 regAddr,
-	IN	GT_U32 page,
-    IN  GT_U16 data
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 );
 
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtSetUseCoreTag
+* gprtSetGlobal2Reg
 *
 * DESCRIPTION:
-*       This routine set the UseCoreTag bit in Port Control Register.
-*			When this bit is cleared to a zero, ingressing frames are considered
-*			Tagged if the 16-bits following the frame's Source Address is 0x8100.
-*			When this bit is set to a one, ingressing frames are considered Tagged
-*			if the 16-bits following the frame's Source Address is equal to the 
-*			CoreTag register value.
+*       This routine writes Switch Global2 Registers.
 *
 * INPUTS:
-*       port  - the logical port number.
-*       force - GT_TRUE for force flow control  or GT_FALSE otherwise
+*       regAddr - The register's address.
 *
 * OUTPUTS:
-*       None.
+*       data    - The read register's data.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetUseCoreTag
+GT_STATUS gprtSetGlobal2Reg
 (
-    IN GT_QD_DEV  *dev,
-    IN GT_LPORT   port,
-    IN GT_BOOL    force
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
 );
 
+/* gtSysCtrl.c */
 /*******************************************************************************
-* gprtGetUseCoreTag
+* gsysSetARPDest
 *
 * DESCRIPTION:
-*       This routine get the Use Core Tag state.
+*        This routine sets ARP Monitor Destination Port. Tagged or untagged 
+*        frames that ingress Network ports with the Broadcast Destination Address 
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*        should point to the port that directs these frames to the switch's CPU 
+*        that will process ARPs. This target port should be a Marvell Tag port so 
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+*        frames will be discarded.
 *
 * INPUTS:
-*       port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       force - GT_TRUE for using core tag register  or GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetUseCoreTag
+GT_STATUS gsysSetARPDest
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_BOOL    *force
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* gprtSetDiscardTagged
+* gsysGetARPDest
 *
 * DESCRIPTION:
-*		When this bit is set to a one, all non-MGMT frames that are processed as 
-*		Tagged will be discarded as they enter this switch port. Priority only 
-*		tagged frames (with a VID of 0x000) are considered tagged.
+*        This routine gets ARP Monitor Destination Port. Tagged or untagged 
+*        frames that ingress Network ports with the Broadcast Destination Address 
+*        and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*        should point to the port that directs these frames to the switch's CPU 
+*        that will process ARPs. This target port should be a Marvell Tag port so 
+*        that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
+*        To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*        Tag port will be sent to the port number definded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
+*        frames will be discarded.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDiscardTagged
+GT_STATUS gsysGetARPDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 );
 
 /*******************************************************************************
-* gprtGetDiscardTagged
+* gsysSetRsvd2CpuEnables
 *
 * DESCRIPTION:
-*		This routine gets DiscardTagged bit for the given port
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+*        enBits(or register) are also set to a one, are treated as MGMT frames. 
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetDiscardTagged
+GT_STATUS gsysSetRsvd2CpuEnables
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
 );
 
 /*******************************************************************************
-* gprtSetDiscardUntagged
+* gsysGetRsvd2CpuEnables
 *
 * DESCRIPTION:
-*		When this bit is set to a one, all non-MGMT frames that are processed as 
-*		Untagged will be discarded as they enter this switch port. Priority only 
-*		tagged frames (with a VID of 0x000) are considered tagged.
+*        Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
+*        en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
+*        enBits(or register) are also set to a one, are treated as MGMT frames. 
+*        All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
+*        bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
+*        tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDiscardUntagged
+GT_STATUS gsysGetRsvd2CpuEnables
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
 );
 
 /*******************************************************************************
-* gprtGetDiscardUntagged
+* gsysSetRsvd2Cpu
 *
 * DESCRIPTION:
-*		This routine gets DiscardUntagged bit for the given port
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*        membership, will be considered MGMT frames and sent to the port's CPU 
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*        function) for the frames's DA is also set to a one.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetDiscardUntagged
+GT_STATUS gsysSetRsvd2Cpu
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetMapDA
+* gsysGetRsvd2Cpu
 *
 * DESCRIPTION:
-*		When this bit is set to a one, normal switch operation will occur where a 
-*		frame's DA address is used to direct the frame out the correct port.
-*		When this be is cleared to a zero, the frame will be sent out the port(s) 
-*		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
-*		is ound in the address database.
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*        membership, will be considered MGMT frames and sent to the port's CPU 
+*        Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
+*        function) for the frames's DA is also set to a one.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetMapDA
+GT_STATUS gsysGetRsvd2Cpu
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetMapDA
+* gsysSetMGMTPri
 *
 * DESCRIPTION:
-*		This routine gets MapDA bit for the given port
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetMapDA
+GT_STATUS gsysSetMGMTPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 );
 
 /*******************************************************************************
-* gprtSetDefaultForward
+* gsysGetMGMTPri
 *
 * DESCRIPTION:
-*		When this bit is set to a one, normal switch operation will occurs and 
-*		multicast frames with unknown DA addresses are allowed to egress out this 
-*		port (assuming the VLAN settings allow the frame to egress this port too).
-*		When this be is cleared to a zero, multicast frames with unknown DA 
-*		addresses will not egress out this port.
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetDefaultForward
+GT_STATUS gsysGetMGMTPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 );
 
 /*******************************************************************************
-* gprtGetDefaultForward
+* gsysSetUseDoubleTagData
 *
 * DESCRIPTION:
-*		This routine gets DefaultForward bit for the given port
+*        This bit is used to determine if Double Tag data that is removed from a 
+*        Double Tag frame is used or ignored when making switching decisions on 
+*        the frame.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetDefaultForward
+GT_STATUS gsysSetUseDoubleTagData
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetEgressMonitorSource
+* gsysGetUseDoubleTagData
 *
 * DESCRIPTION:
-*		When this be is cleared to a zero, normal network switching occurs.
-*		When this bit is set to a one, any frame that egresses out this port will
-*		also be sent to the EgressMonitorDest Port
+*        This bit is used to determine if Double Tag data that is removed from a 
+*        Double Tag frame is used or ignored when making switching decisions on 
+*        the frame.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetEgressMonitorSource
+GT_STATUS gsysGetUseDoubleTagData
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetEgressMonitorSource
+* gsysSetPreventLoops
 *
 * DESCRIPTION:
-*		This routine gets EgressMonitorSource bit for the given port
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*        field equals this device's Device Number, the following action will be 
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original 
+*                        source port as defined by the frame's Src_Port field.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetEgressMonitorSource
+GT_STATUS gsysSetPreventLoops
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetIngressMonitorSource
+* gsysGetPreventLoops
 *
 * DESCRIPTION:
-*		When this be is cleared to a zero, normal network switching occurs.
-*		When this bit is set to a one, any frame that egresses out this port will
-*		also be sent to the EgressMonitorDest Port
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*        field equals this device's Device Number, the following action will be 
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original 
+*                        source port as defined by the frame's Src_Port field.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetIngressMonitorSource
+GT_STATUS gsysGetPreventLoops
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetIngressMonitorSource
+* gsysSetFlowControlMessage
 *
 * DESCRIPTION:
-*		This routine gets IngressMonitorSource bit for the given port
+*        When this bit is set to one, Marvell Tag Flow Control messages will be 
+*        generated when an output queue becomes congested and received Marvell Tag 
+*        Flow Control messages will pause MACs inside this device. When this bit 
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be 
+*        generated and any received will be ignored at the target MAC.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetIngressMonitorSource
+GT_STATUS gsysSetFlowControlMessage
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
-
-/* gtPortPAV.c */
-
-/* gtPortRateCtrl.c */
-
-/* gtPortRmon.c */
-
 /*******************************************************************************
-* gstatsGetPortCounter3
+* gsysGetFlowControlMessage
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*        When this bit is set to one, Marvell Tag Flow Control messages will be 
+*        generated when an output queue becomes congested and received Marvell Tag 
+*        Flow Control messages will pause MACs inside this device. When this bit 
+*        is cleared to a zero, Marvell Tag Flow Control messages will not be 
+*        generated and any received will be ignored at the target MAC.
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        None.
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		This function supports Gigabit Switch only
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortCounter3
+GT_STATUS gsysGetFlowControlMessage
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS3	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gstatsGetPortAllCounters3
+* gsysSetForceFlowControlPri
 *
 * DESCRIPTION:
-*		This routine gets all counters of the given port
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*        Flow Control frames will be set to the value of the FC Pri bits (set by 
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*        frames that caused the congestion. This bit will have no effect if the 
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*        cleared to a zero.
 *
 * INPUTS:
-*		port - the logical port number.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		This function supports Gigabit Switch only
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gstatsGetPortAllCounters3
+GT_STATUS gsysSetForceFlowControlPri
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
-
-/* gtPortStat.c */
-
 /*******************************************************************************
-* gprtGetPortCtr2
+* gsysGetForceFlowControlPri
 *
 * DESCRIPTION:
-*       This routine gets the port InDiscards, InFiltered, and OutFiltered counters.
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*        Flow Control frames will be set to the value of the FC Pri bits (set by 
+*        gsysSetFCPri function call). When this bit is cleared to a zero, generated 
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*        frames that caused the congestion. This bit will have no effect if the 
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*        cleared to a zero.
 *
 * INPUTS:
-*       port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*       ctr - the counters value.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPortCtr2
+GT_STATUS gsysGetForceFlowControlPri
 (
-    IN  GT_QD_DEV       *dev,
-    IN  GT_LPORT        port,
-    OUT GT_PORT_STAT2   *ctr
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
-/* gtPortStatus.c */
-
 /*******************************************************************************
-* gprtGetMGMII
+* gsysSetFCPri
 *
 * DESCRIPTION:
-*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
-*		detected connected to this port, the SERDES interface between this port
-*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
-*		detected connected to this port, the SERDES interface between this port 
-*		and the PHY will be MGMII. When no PHY is detected on this port and the 
-*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
 *
 * INPUTS:
-*		port - the logical port number.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		state - GT_TRUE or GT_FALSE
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetMGMII
+GT_STATUS gsysSetFCPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 );
 
 /*******************************************************************************
-* gprtSetMGMII
+* gsysGetFCPri
 *
 * DESCRIPTION:
-*		SERDES Interface mode. When this bit is cleared to a zero and a PHY is 
-*		detected connected to this port, the SERDES interface between this port
-*		and the PHY will be SGMII.  When this bit is set toa one and a PHY is
-*		detected connected to this port, the SERDES interface between this port 
-*		and the PHY will be MGMII. When no PHY is detected on this port and the 
-*		SERDES interface is being used, it will be configured in 1000Base-X mode.
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
 *
 * INPUTS:
-*		port - the logical port number.
-*		state - GT_TRUE or GT_FALSE
+*        None.
 *
 * OUTPUTS:
-*		None
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetMGMII
+GT_STATUS gsysGetFCPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_BOOL  	state
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 );
 
-
-/* gtQosMap.c */
-
-/* gtSysCtrl.c */
-
 /*******************************************************************************
-* gsysSetCoreTagType
+* gsysSetFlowCtrlDelay
 *
 * DESCRIPTION:
-*		This routine sets Ether Core Tag Type.
-*		This Ether Type is added to frames that egress the switch as Double Tagged 
-*		frames. It is also the Ether Type expected during Ingress to determine if 
-*		a frame is Tagged or not on ports configured as UseCoreTag mode.
+*        This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+*        1000Mbps. 
 *
 * INPUTS:
-*		etherType - Core Tag Type (2 bytes)
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        delayTime - actual delay time will be (this value x 2.048uS).
+*                    the value cannot exceed 0x1FFF (or 8191 in decimal).
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetCoreTagType
+GT_STATUS gsysSetFlowCtrlDelay
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16  		etherType
+    IN GT_QD_DEV            *dev,
+    IN GT_PORT_SPEED_MODE    sp,
+    IN GT_U32                delayTime
 );
 
 /*******************************************************************************
-* gsysGetCoreTagType
+* gsysGetFlowCtrlDelay
 *
 * DESCRIPTION:
-*		This routine gets CoreTagType
+*        This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps. 
 *
 * INPUTS:
-*		None.
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
 *
 * OUTPUTS:
-*		etherType - Core Tag Type (2 bytes)
+*        delayTime - actual delay time will be (this value x 2.048uS).
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetCoreTagType
+GT_STATUS gsysGetFlowCtrlDelay
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*etherType
+    IN  GT_QD_DEV    *dev,
+    IN  GT_PORT_SPEED_MODE    sp,
+    OUT GT_U32        *delayTime
 );
 
 /*******************************************************************************
-* gsysSetIngressMonitorDest
+* gsysSetDevRoutingTable
 *
 * DESCRIPTION:
-*		This routine sets Ingress Monitor Destination Port. Frames that are 
-*		targeted toward an Ingress Monitor Destination go out the port number 
-*		indicated in these bits. This includes frames received on a Marvell Tag port
-*		with the Ingress Monitor type, and frames received on a Network port that 
-*		is enabled to be the Ingress Monitor Source Port.
-*		If the Ingress Monitor Destination Port resides in this device these bits 
-*		should point to the Network port where these frames are to egress. If the 
-*		Ingress Monitor Destination Port resides in another device these bits 
-*		should point to the Marvell Tag port in this device that is used to get 
-*		to the device that contains the Ingress Monitor Destination Port.
+*        This function sets Device to Port mapping (which device is connected to 
+*        which port of this device). 
 *
 * INPUTS:
-*		port  - the logical port number.
+*        devNum - target device number.
+*        portNum - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetIngressMonitorDest
+GT_STATUS gsysSetDevRoutingTable
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum,
+    IN GT_LPORT     port
 );
 
 /*******************************************************************************
-* gsysGetIngressMonitorDest
+* gsysGetDevRoutingTable
 *
 * DESCRIPTION:
-*		This routine gets Ingress Monitor Destination Port.
+*        This function gets Device to Port mapping (which device is connected to 
+*        which port of this device). 
 *
 * INPUTS:
-*		None.
+*        devNum - target device number.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        portNum - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if devNum >= 32
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetIngressMonitorDest
+GT_STATUS gsysGetDevRoutingTable
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         devNum,
+    OUT GT_LPORT     *port
 );
 
 /*******************************************************************************
-* gsysSetEgressMonitorDest
+* gsysSetTrunkMaskTable
 *
 * DESCRIPTION:
-*		This routine sets Egress Monitor Destination Port. Frames that are 
-*		targeted toward an Egress Monitor Destination go out the port number 
-*		indicated in these bits. This includes frames received on a Marvell Tag port
-*		with the Egress Monitor type, and frames transmitted on a Network port that 
-*		is enabled to be the Egress Monitor Source Port.
-*		If the Egress Monitor Destination Port resides in this device these bits 
-*		should point to the Network port where these frames are to egress. If the 
-*		Egress Monitor Destination Port resides in another device these bits 
-*		should point to the Marvell Tag port in this device that is used to get 
-*		to the device that contains the Egress Monitor Destination Port.
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        trunkNum - one of the eight Trunk mask vectors.
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetEgressMonitorDest
+GT_STATUS gsysSetTrunkMaskTable
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkNum,
+    IN GT_U32        trunkMask
 );
 
 /*******************************************************************************
-* gsysGetEgressMonitorDest
+* gsysGetTrunkMaskTable
 *
 * DESCRIPTION:
-*		This routine gets Egress Monitor Destination Port.
+*        This function sets Trunk mask vector table for load balancing.
+*        This vector will be AND'ed with where the frame was originally egressed to.
+*        To insure all trunks are load balanced correctly, the data in this table
+*        needs to be correctly configured.
 *
 * INPUTS:
-*		None.
+*        trunkNum - one of the eight Trunk mask vectors.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetEgressMonitorDest
+GT_STATUS gsysGetTrunkMaskTable
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkNum,
+    OUT GT_U32        *trunkMask
 );
 
-
-/* gtSysConfig.c */
-
-/* gtSysStatus.c */
-
-
-/* functions added on rev 2.2 */
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtSetMessagePort
+* gsysSetHashTrunk
 *
 * DESCRIPTION:
-*		When the Learn2All bit is set to one, learning message frames are 
-*		generated. These frames will be sent out all ports whose Message Port is 
-*		set to one.
-* 		If this feature is used, it is recommended that all Marvell Tag ports, 
-*		except for the CPU's port, have their MessagePort bit set to one. 
-*		Ports that are not Marvell Tag ports should not have their Message Port
-*		bit set to one.
-*		
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*        When this bit is set to a one, the hashed computed for address table 
+*        lookups is used for the TrunkMask selection. When this bit is cleared to 
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*        select the TrunkMask to use.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetMessagePort
+GT_STATUS gsysSetHashTrunk
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtGetMessagePort
+* gsysGetHashTrunk
 *
 * DESCRIPTION:
-*		When the Learn2All bit is set to one, learning message frames are 
-*		generated. These frames will be sent out all ports whose Message Port is 
-*		set to one.
-* 		If this feature is used, it is recommended that all Marvell Tag ports, 
-*		except for the CPU's port, have their MessagePort bit set to one. 
-*		Ports that are not Marvell Tag ports should not have their Message Port
-*		bit set to one.
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*        When this bit is set to a one, the hashed computed for address table 
+*        lookups is used for the TrunkMask selection. When this bit is cleared to 
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*        select the TrunkMask to use.
 *
-*		
 * INPUTS:
-*		port - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetMessagePort
+GT_STATUS gsysGetHashTrunk
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
-
 /*******************************************************************************
-* gprtSetTrunkPort
+* gsysSetTrunkRouting
 *
 * DESCRIPTION:
-*		This function enables/disables and sets the trunk ID.
-*		
+*        This function sets routing information for the given Trunk ID.
+*
 * INPUTS:
-*		port - the logical port number.
-*		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
-*			 GT_FALSE, otherwise.
-*		trunkId - valid ID is 0 ~ 15.
+*        trunkId - Trunk ID.
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetTrunkPort
+GT_STATUS gsysSetTrunkRouting
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL 		en,
-	IN GT_U32		trunkId
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkId,
+    IN GT_U32        trunkRoute
 );
 
-
 /*******************************************************************************
-* gprtGetTrunkPort
+* gsysGetTrunkRouting
 *
 * DESCRIPTION:
-*		This function returns trunk state of the port.
-*		When trunk is disabled, trunkId field won't have valid value.
-*		
+*        This function retrieves routing information for the given Trunk ID.
+*
 * INPUTS:
-*		port - the logical port number.
+*        trunkId - Trunk ID.
 *
 * OUTPUTS:
-*		en - GT_TRUE, if the port is a member of a trunk,
-*			 GT_FALSE, otherwise.
-*		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetTrunkPort
+GT_STATUS gsysGetTrunkRouting
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	OUT GT_BOOL 	*en,
-	OUT GT_U32		*trunkId
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkId,
+    OUT GT_U32        *trunkRoute
 );
 
 
 
+/* Prototype added for 88E6095 Rev 1 or Rev 2 */
 
+/* gtPortCtrl.c */
 /*******************************************************************************
-* gprtGetGlobal2Reg
+* gprtGetDiscardBCastMode
 *
 * DESCRIPTION:
-*       This routine reads Switch Global 2 Registers.
+*       This routine gets the Discard Broadcast Mode. If the mode is enabled,
+*        all the broadcast frames to the given port will be discarded.
 *
 * INPUTS:
-*       regAddr - The register's address.
+*       port - logical port number
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -8489,28 +9775,33 @@ GT_STATUS gprtGetTrunkPort
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetGlobal2Reg
+GT_STATUS gprtGetDiscardBCastMode
 (
     IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtSetGlobal2Reg
+* gprtSetDiscardBCastMode
 *
 * DESCRIPTION:
-*       This routine writes Switch Global2 Registers.
+*       This routine sets the Discard Broadcast mode.
+*        If the mode is enabled, all the broadcast frames to the given port will 
+*        be discarded.
 *
 * INPUTS:
-*       regAddr - The register's address.
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*        None
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -8518,1416 +9809,1394 @@ GT_STATUS gprtGetGlobal2Reg
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetGlobal2Reg
+GT_STATUS gprtSetDiscardBCastMode
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_U32			regAddr,
-    IN  GT_U16			data
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
 );
 
-/* gtSysCtrl.c */
 /*******************************************************************************
-* gsysSetARPDest
+* gprtGetFCOnRateLimitMode
 *
 * DESCRIPTION:
-*		This routine sets ARP Monitor Destination Port. Tagged or untagged 
-*		frames that ingress Network ports with the Broadcast Destination Address 
-*		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
-*		should point to the port that directs these frames to the switch's CPU 
-*		that will process ARPs. This target port should be a Marvell Tag port so 
-*		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
-*		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
-*		Tag port will be sent to the port number definded in ARPDest.
-*
-*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
-*		frames will be discarded.
+*       This routine returns mode that tells if ingress rate limiting uses Flow 
+*        Control. When this mode is enabled and the port receives frames over the 
+*        limit, Ingress Rate Limiting will be performed by stalling the 
+*        link partner using flow control, instead of discarding frames.
 *
 * INPUTS:
-*		port  - the logical port number.
+*       port - logical port number
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE, if the mode is enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetARPDest
+GT_STATUS gprtGetFCOnRateLimitMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gsysGetARPDest
+* gprtSetFCOnRateLimitMode
 *
 * DESCRIPTION:
-*		This routine gets ARP Monitor Destination Port. Tagged or untagged 
-*		frames that ingress Network ports with the Broadcast Destination Address 
-*		and with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
-*		should point to the port that directs these frames to the switch's CPU 
-*		that will process ARPs. This target port should be a Marvell Tag port so 
-*		that frames will egress with a To_CPU Marvell Tag with a CPU Code of ARP.
-*		To_CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
-*		Tag port will be sent to the port number definded in ARPDest.
-*
-*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To_CPU ARP 
-*		frames will be discarded.
+*       This routine sets the mode that tells if ingress rate limiting uses Flow 
+*        Control. When this mode is enabled and the port receives frames over the 
+*        limit, Ingress Rate Limiting will be performed by stalling the 
+*        link partner using flow control, instead of discarding frames.
 *
 * INPUTS:
-*		None.
+*       port - logical port number
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetARPDest
+GT_STATUS gprtSetFCOnRateLimitMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
 );
 
+
+/* gtPortRateCtrl.c */
+
 /*******************************************************************************
-* gsysSetRsvd2CpuEnables
+* grcSetBurstRate
 *
 * DESCRIPTION:
-*		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
-*		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
-*		enBits(or register) are also set to a one, are treated as MGMT frames. 
-*		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
-*		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
-*		tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*       This routine sets the port's ingress data limit based on burst size.
 *
 * INPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*       port    - logical port number.
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after 
+*                the ingress rate selected is reached or exceeded. 
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters 
+*                                Minimum rate for Burst Size 24K byte is 128Kbps
+*                                Minimum rate for Burst Size 48K byte is 256Kbps
+*                                Minimum rate for Burst Size 96K byte is 512Kbps
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetRsvd2CpuEnables
+GT_STATUS grcSetBurstRate
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		enBits
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_SIZE   bsize,
+    IN GT_BURST_RATE   rate
 );
 
 /*******************************************************************************
-* gsysGetRsvd2CpuEnables
+* grcGetBurstRate
 *
 * DESCRIPTION:
-*		Reserved DA Enables. When the function, gsysSetRsvd2Cpu, is called with 
-*		en = GT_TRUE, the 16 reserved multicast DA addresses, whose bit in this 
-*		enBits(or register) are also set to a one, are treated as MGMT frames. 
-*		All the reserved DA's take the form 01:80:C2:00:00:0x. When x = 0x0, 
-*		bit 0 of this register is tested. When x = 0x2, bit 2 of this field is 
-*		tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*       This routine retrieves the port's ingress data limit based on burst size.
 *
 * INPUTS:
-*		None.
+*       port    - logical port number.
 *
 * OUTPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*       bsize    - burst size.
+*       rate    - ingress data rate limit. These frames will be discarded after 
+*                the ingress rate selected is reached or exceeded. 
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetRsvd2CpuEnables
+GT_STATUS grcGetBurstRate
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*enBits
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_SIZE   *bsize,
+    OUT GT_BURST_RATE   *rate
 );
 
+
 /*******************************************************************************
-* gsysSetRsvd2Cpu
+* grcSetTCPBurstRate
 *
 * DESCRIPTION:
-*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
-*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
-*		membership, will be considered MGMT frames and sent to the port's CPU 
-*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
-*		function) for the frames's DA is also set to a one.
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
 *
 * INPUTS:
-*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*       port    - logical port number.
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will 
+*                be discarded after the ingress rate selected is reached or exceeded. 
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters 
+*                                Valid rate is GT_BURST_NO_LIMIT, or between
+*                                64Kbps and 1500Kbps.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetRsvd2Cpu
+GT_STATUS grcSetTCPBurstRate
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV       *dev,
+    IN GT_LPORT        port,
+    IN GT_BURST_RATE   rate
 );
 
+
 /*******************************************************************************
-* gsysGetRsvd2Cpu
+* grcGetTCPBurstRate
 *
 * DESCRIPTION:
-*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
-*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
-*		membership, will be considered MGMT frames and sent to the port's CPU 
-*		Port as long as the associated Rsvd2CpuEnable bit (gsysSetRsvd2CpuEnable 
-*		function) for the frames's DA is also set to a one.
+*       This routine sets the port's TCP/IP ingress data limit based on burst size.
 *
 * INPUTS:
-*		None.
+*       port    - logical port number.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*       rate    - ingress data rate limit for TCP/IP packets. These frames will 
+*                be discarded after the ingress rate selected is reached or exceeded. 
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_VALUE        - register value is not known
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetRsvd2Cpu
+GT_STATUS grcGetTCPBurstRate
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV       *dev,
+    IN  GT_LPORT        port,
+    OUT GT_BURST_RATE   *rate
 );
 
+
+/* gtSysCtrl.c */
 /*******************************************************************************
-* gsysSetMGMTPri
+* gsysSetRateLimitMode
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine sets which mode to use.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid mode is used.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetMGMTPri
+GT_STATUS gsysSetRateLimitMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN GT_QD_DEV    *dev,
+    IN GT_INGRESS_RATE_MODE mode
 );
 
 /*******************************************************************************
-* gsysGetMGMTPri
+* gsysGetRateLimitMode
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on Rsvd2CPU MGMT frames.
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine gets which mode is being used.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetMGMTPri
+GT_STATUS gsysGetRateLimitMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_INGRESS_RATE_MODE *mode
 );
 
 /*******************************************************************************
-* gsysSetUseDoubleTagData
+* gsysSetAgeInt
 *
 * DESCRIPTION:
-*		This bit is used to determine if Double Tag data that is removed from a 
-*		Double Tag frame is used or ignored when making switching decisions on 
-*		the frame.
+*        Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be 
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU 
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version 
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState 
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*        
 *
 * INPUTS:
-*		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*        en - GT_TRUE, to enable,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetUseDoubleTagData
+GT_STATUS gsysSetAgeInt
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysGetUseDoubleTagData
+* gsysGetAgeInt
 *
 * DESCRIPTION:
-*		This bit is used to determine if Double Tag data that is removed from a 
-*		Double Tag frame is used or ignored when making switching decisions on 
-*		the frame.
+*        Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be 
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU 
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version 
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState 
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetUseDoubleTagData
+GT_STATUS gsysGetAgeInt
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 );
 
+
+/* For Zephyr */
+
+/* gtPhyCtrl.c */
 /*******************************************************************************
-* gsysSetPreventLoops
+* gprtGetPhyLinkStatus
 *
 * DESCRIPTION:
-*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
-*		field equals this device's Device Number, the following action will be 
-*		taken depending upon the value of this bit.
-*		GT_TRUE (1) - The frame will be discarded.
-*		GT_FALSE(0) - The frame will be prevented from going out its original 
-*						source port as defined by the frame's Src_Port field.
+*       This routine retrieves the Link status.
 *
 * INPUTS:
-*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*         port     - The logical port number
 *
 * OUTPUTS:
-*		None.
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetPreventLoops
+GT_STATUS gprtGetPhyLinkStatus
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
 );
 
+
 /*******************************************************************************
-* gsysGetPreventLoops
+* gprtSetPktGenEnable
 *
 * DESCRIPTION:
-*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
-*		field equals this device's Device Number, the following action will be 
-*		taken depending upon the value of this bit.
-*		GT_TRUE (1) - The frame will be discarded.
-*		GT_FALSE(0) - The frame will be prevented from going out its original 
-*						source port as defined by the frame's Src_Port field.
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be 
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
 *
 * INPUTS:
-*		None.
+*         port     - The logical port number
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
 *
 * OUTPUTS:
-*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetPreventLoops
+GT_STATUS gprtSetPktGenEnable
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
 );
 
 /*******************************************************************************
-* gsysSetFlowControlMessage
+* gprtGetSerdesMode
 *
 * DESCRIPTION:
-*		When this bit is set to one, Marvell Tag Flow Control messages will be 
-*		generated when an output queue becomes congested and received Marvell Tag 
-*		Flow Control messages will pause MACs inside this device. When this bit 
-*		is cleared to a zero, Marvell Tag Flow Control messages will not be 
-*		generated and any received will be ignored at the target MAC.
+*       This routine reads Serdes Interface Mode.
 *
 * INPUTS:
-*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*       port    - logical port number
 *
 * OUTPUTS:
-*		None.
+*       mode    - Serdes Interface Mode
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetFlowControlMessage
+GT_STATUS gprtGetSerdesMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
 );
 
 /*******************************************************************************
-* gsysGetFlowControlMessage
+* gprtSetSerdesMode
 *
 * DESCRIPTION:
-*		When this bit is set to one, Marvell Tag Flow Control messages will be 
-*		generated when an output queue becomes congested and received Marvell Tag 
-*		Flow Control messages will pause MACs inside this device. When this bit 
-*		is cleared to a zero, Marvell Tag Flow Control messages will not be 
-*		generated and any received will be ignored at the target MAC.
+*       This routine sets Serdes Interface Mode.
 *
 * INPUTS:
-*		None.
+*       port    - logical port number
+*       mode    - Serdes Interface Mode
 *
 * OUTPUTS:
-*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFlowControlMessage
+GT_STATUS gprtSetSerdesMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
 );
 
+
+/* gtSysCtrl.c */
+
 /*******************************************************************************
-* gsysSetForceFlowControlPri
+* gsysSetForceSnoopPri
 *
 * DESCRIPTION:
-*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
-*		Flow Control frames will be set to the value of the FC Pri bits (set by 
-*		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
-*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
-*		frames that caused the congestion. This bit will have no effect if the 
-*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
-*		cleared to a zero.
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetForceFlowControlPri
+GT_STATUS gsysSetForceSnoopPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysGetForceFlowControlPri
+* gsysGetForceSnoopPri
 *
 * DESCRIPTION:
-*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
-*		Flow Control frames will be set to the value of the FC Pri bits (set by 
-*		gsysSetFCPri function call). When this bit is cleared to a zero, generated 
-*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
-*		frames that caused the congestion. This bit will have no effect if the 
-*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
-*		cleared to a zero.
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*       Priority is enabled. When it's disabled, the priority on these frames
+*        is not modified.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetForceFlowControlPri
+GT_STATUS gsysGetForceSnoopPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
+
 /*******************************************************************************
-* gsysSetFCPri
+* gsysSetSnoopPri
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
-*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
-*		is set to a one.
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetFCPri
+GT_STATUS gsysSetSnoopPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 );
 
+
 /*******************************************************************************
-* gsysGetFCPri
+* gsysGetSnoopPri
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
-*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
-*		is set to a one.
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFCPri
+GT_STATUS gsysGetSnoopPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 );
 
+
 /*******************************************************************************
-* gsysSetFlowCtrlDelay
+* gsysSetForceARPPri
 *
 * DESCRIPTION:
-*		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
-*		1000Mbps. 
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri 
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
+*       disabled, the priority on these frames is not modified.
 *
 * INPUTS:
-*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
-*		delayTime - actual delay time will be (this value x 2.048uS).
-*					the value cannot exceed 0x1FFF (or 8191 in decimal).
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetFlowCtrlDelay
+GT_STATUS gsysSetForceARPPri
 (
-	IN GT_QD_DEV			*dev,
-	IN GT_PORT_SPEED_MODE	sp,
-	IN GT_U32				delayTime
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysGetFlowCtrlDelay
+* gsysGetForceARPPri
 *
 * DESCRIPTION:
-*		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
-*		1000Mbps. 
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri 
+*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
+*       disabled, the priority on these frames is not modified.
 *
 * INPUTS:
-*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        None.
 *
 * OUTPUTS:
-*		delayTime - actual delay time will be (this value x 2.048uS).
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFlowCtrlDelay
+GT_STATUS gsysGetForceARPPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_PORT_SPEED_MODE	sp,
-	OUT GT_U32		*delayTime
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
+
 /*******************************************************************************
-* gsysSetDevRoutingTable
+* gsysSetARPPri
 *
 * DESCRIPTION:
-*		This function sets Device to Port mapping (which device is connected to 
-*		which port of this device). 
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
 *
 * INPUTS:
-*		devNum - target device number.
-*		portNum - the logical port number.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if devNum >= 32 or port >= total number of ports.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetDevRoutingTable
+GT_STATUS gsysSetARPPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		devNum,
-	IN GT_LPORT 	port
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 );
 
+
 /*******************************************************************************
-* gsysGetDevRoutingTable
+* gsysGetARPPri
 *
 * DESCRIPTION:
-*		This function gets Device to Port mapping (which device is connected to 
-*		which port of this device). 
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*       this priority is used as the egressing frame's PRI[2:0] bits on generated
+*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
+*       used as the internal Queue Priority to use on ARP frames.
 *
 * INPUTS:
-*		devNum - target device number.
+*        None.
 *
 * OUTPUTS:
-*		portNum - the logical port number.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if devNum >= 32
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetDevRoutingTable
+GT_STATUS gsysGetARPPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		devNum,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 );
 
-/*******************************************************************************
-* gsysSetTrunkMaskTable
+
+/* added for 88E6065 */
+
+/* gtBrgVlan.c */
+
+/********************************************************************
+* gvlnSetForceMap
 *
 * DESCRIPTION:
-*		This function sets Trunk mask vector table for load balancing.
-*		This vector will be AND'ed with where the frame was originally egressed to.
-*		To insure all trunks are load balanced correctly, the data in this table
-*		needs to be correctly configured.
+*       This routine enables/disables Force Map feature.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
 *
 * INPUTS:
-*		trunkNum - one of the eight Trunk mask vectors.
-*		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
-*					bit 1 for port 1 , etc.
+*       port    - logical port number to set.
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise 
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkNum > 0x7 or trunMask > 0x7FF (or port vector).
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetTrunkMaskTable
+GT_STATUS gvlnSetForceMap
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		trunkNum,
-	IN GT_U32		trunkMask
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      mode
 );
 
-/*******************************************************************************
-* gsysGetTrunkMaskTable
+
+/********************************************************************
+* gvlnGetForceMap
 *
 * DESCRIPTION:
-*		This function sets Trunk mask vector table for load balancing.
-*		This vector will be AND'ed with where the frame was originally egressed to.
-*		To insure all trunks are load balanced correctly, the data in this table
-*		needs to be correctly configured.
+*       This routine checks if Force Map feature is enabled.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
 *
 * INPUTS:
-*		trunkNum - one of the eight Trunk mask vectors.
+*       port    - logical port number to set.
 *
 * OUTPUTS:
-*		trunkMask - Trunk Mask bits. Bit 0 controls trunk masking for port 0,
-*					bit 1 for port 1 , etc.
+*       mode    - GT_TRUE, to enable force map feature
+*                 GT_FAULSE, otherwise 
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkNum > 0x7.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetTrunkMaskTable
+GT_STATUS gvlnGetForceMap
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		trunkNum,
-	OUT GT_U32		*trunkMask
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
 );
 
+/* gtEvents.c */
+
 /*******************************************************************************
-* gsysSetHashTrunk
+* geventSetAgeIntEn
 *
 * DESCRIPTION:
-*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
-*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
-*		When this bit is set to a one, the hashed computed for address table 
-*		lookups is used for the TrunkMask selection. When this bit is cleared to 
-*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
-*		select the TrunkMask to use.
+*        This routine enables/disables Age Interrupt for a port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
+*        and the ingressing frame's SA is contained in the ATU as a non-Static 
+*        entry with a EntryState less than 0x4.
 *
 * INPUTS:
-*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetHashTrunk
+GT_STATUS geventSetAgeIntEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gsysGetHashTrunk
+* geventGetAgeIntEn
 *
 * DESCRIPTION:
-*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
-*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
-*		When this bit is set to a one, the hashed computed for address table 
-*		lookups is used for the TrunkMask selection. When this bit is cleared to 
-*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
-*		select the TrunkMask to use.
+*        This routine gets Age Interrupt Enable for the port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
+*        and the ingressing frame's SA is contained in the ATU as a non-Static 
+*        entry with a EntryState less than 0x4.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetHashTrunk
+GT_STATUS geventGetAgeIntEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
+
+/* gtPIRL.c */
+
 /*******************************************************************************
-* gsysSetTrunkRouting
+* gpirlActivate
 *
 * DESCRIPTION:
-*		This function sets routing information for the given Trunk ID.
+*       This routine activates Ingress Rate Limiting for the given ports by 
+*        initializing a resource bucket, assigning ports, and configuring
+*        Bucket Parameters.
 *
 * INPUTS:
-*		trunkId - Trunk ID.
-*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
-*					bit 1 for port 1 , etc.
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
+*        pirlData - PIRL resource parameters.
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId > 0xF or trunkRoute > 0x7FF(or port vector).
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetTrunkRouting
+GT_STATUS gpirlActivate
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		trunkId,
-	IN GT_U32		trunkRoute
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec,
+    IN  GT_PIRL_DATA    *pirlData
 );
 
 /*******************************************************************************
-* gsysGetTrunkRouting
+* gpirlDeactivate
 *
 * DESCRIPTION:
-*		This function retrieves routing information for the given Trunk ID.
+*       This routine deactivates Ingress Rate Limiting for the given bucket.
+*        It simply removes every ports from the Ingress Rate Resource.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the irlUnit before this function is called.
 *
 * INPUTS:
-*		trunkId - Trunk ID.
+*        irlUnit  - bucket to be deactivated
 *
 * OUTPUTS:
-*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
-*					bit 1 for port 1 , etc.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId > 0xF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetTrunkRouting
+GT_STATUS gpirlDeactivate
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		trunkId,
-	OUT GT_U32		*trunkRoute
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit
 );
 
-
-
-/* Prototype added for 88E6095 Rev 1 or Rev 2 */
-
-/* gtPortCtrl.c */
 /*******************************************************************************
-* gprtGetDiscardBCastMode
+* gpirlUpdateParam
 *
 * DESCRIPTION:
-*       This routine gets the Discard Broadcast Mode. If the mode is enabled,
-*		all the broadcast frames to the given port will be discarded.
+*       This routine updates IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*       port - logical port number
+*        irlUnit  - bucket to be used (0 ~ 11)
+*        pirlData - PIRL resource parameters
 *
 * OUTPUTS:
-*		en - GT_TRUE, if enabled,
-*			 GT_FALSE, otherwise.
+*       None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gprtGetDiscardBCastMode
+GT_STATUS gpirlUpdateParam
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	OUT GT_BOOL 	 *en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_PIRL_DATA    *pirlData
 );
 
 /*******************************************************************************
-* gprtSetDiscardBCastMode
+* gpirlReadParam
 *
 * DESCRIPTION:
-*       This routine sets the Discard Broadcast mode.
-*		If the mode is enabled, all the broadcast frames to the given port will 
-*		be discarded.
+*       This routine retrieves IRL Parameter.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*       port - logical port number
-*		en - GT_TRUE, to enable the mode,
-*			 GT_FALSE, otherwise.
+*        irlUnit  - bucket to be used (0 ~ 11).
 *
 * OUTPUTS:
-*		None
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gprtSetDiscardBCastMode
+GT_STATUS gpirlReadParam
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	IN  GT_BOOL 	 en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_PIRL_DATA    *pirlData
 );
 
 /*******************************************************************************
-* gprtGetFCOnRateLimitMode
+* gpirlUpdatePortVec
 *
 * DESCRIPTION:
-*       This routine returns mode that tells if ingress rate limiting uses Flow 
-*		Control. When this mode is enabled and the port receives frames over the 
-*		limit, Ingress Rate Limiting will be performed by stalling the 
-*		link partner using flow control, instead of discarding frames.
+*       This routine updates port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*       port - logical port number
+*        irlUnit  - bucket to be used (0 ~ 11).
+*       portVec  - the list of ports that share the bucket.
 *
 * OUTPUTS:
-*		en - GT_TRUE, if the mode is enabled,
-*			 GT_FALSE, otherwise.
+*       None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gprtGetFCOnRateLimitMode
+GT_STATUS gpirlUpdatePortVec
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	OUT GT_BOOL 	 *en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
 );
 
 /*******************************************************************************
-* gprtSetFCOnRateLimitMode
+* gpirlReadPortVec
 *
 * DESCRIPTION:
-*       This routine sets the mode that tells if ingress rate limiting uses Flow 
-*		Control. When this mode is enabled and the port receives frames over the 
-*		limit, Ingress Rate Limiting will be performed by stalling the 
-*		link partner using flow control, instead of discarding frames.
+*       This routine retrieves port list that share the bucket.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*       port - logical port number
-*		en - GT_TRUE, to enable the mode,
-*			 GT_FALSE, otherwise.
+*        irlUnit  - bucket to be used (0 ~ 11).
 *
 * OUTPUTS:
-*		None
+*       portVec  - the list of ports that share the bucket.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
-*
-* GalTis:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gprtSetFCOnRateLimitMode
+GT_STATUS gpirlReadPortVec
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	IN  GT_BOOL 	 en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
 );
 
-
-/* gtPortRateCtrl.c */
-
 /*******************************************************************************
-* grcSetBurstRate
+* grcGetPirlFcMode
 *
 * DESCRIPTION:
-*       This routine sets the port's ingress data limit based on burst size.
+*       This routine gets Port Ingress Rate Limit Flow Control mode.
+*        When EBSLimitAction is programmed to generate a flow control message, 
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
 *
 * INPUTS:
-*       port	- logical port number.
-*       bsize	- burst size.
-*       rate    - ingress data rate limit. These frames will be discarded after 
-*				the ingress rate selected is reached or exceeded. 
+*       port - logical port number
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_PIRL_FC_DEASSERT enum type
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters 
-*								Minimum rate for Burst Size 24K byte is 128Kbps
-*								Minimum rate for Burst Size 48K byte is 256Kbps
-*								Minimum rate for Burst Size 96K byte is 512Kbps
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
-*
-* GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcSetBurstRate
+GT_STATUS grcGetPirlFcMode
 (
-    IN GT_QD_DEV       *dev,
-    IN GT_LPORT        port,
-    IN GT_BURST_SIZE   bsize,
-    IN GT_BURST_RATE   rate
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_FC_DEASSERT        *mode
 );
 
 /*******************************************************************************
-* grcGetBurstRate
+* gpirlGetIngressRateResource
 *
 * DESCRIPTION:
-*       This routine retrieves the port's ingress data limit based on burst size.
+*       This routine gets Ingress Rate Limiting Resources assigned to the port.
+*        This vector is used to attach specific counter resources to the physical
+*        port. And the same counter resource can be attached to more than one port.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port   - logical port number
 *
 * OUTPUTS:
-*       bsize	- burst size.
-*       rate    - ingress data rate limit. These frames will be discarded after 
-*				the ingress rate selected is reached or exceeded. 
+*        resVec - resource vector (bit 0 for irl unit 0, bit 1 for irl unit 1, etc.)
 *
 * RETURNS:
-*       GT_OK            - on success
-*       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
-* GalTis:
-*
 *******************************************************************************/
-GT_STATUS grcGetBurstRate
+GT_STATUS gpirlGetIngressRateResource
 (
-    IN  GT_QD_DEV       *dev,
-    IN  GT_LPORT        port,
-    OUT GT_BURST_SIZE   *bsize,
-    OUT GT_BURST_RATE   *rate
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U32        *resVec
 );
 
 
+
+/* gtPortStatus.c */
+
 /*******************************************************************************
-* grcSetTCPBurstRate
+* gprtGetPxMode
 *
 * DESCRIPTION:
-*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*        This routine retrives 4 bits of Px_MODE Configuration value.
+*        If speed and duplex modes are forced, the returned mode value would be
+*        different from the configuration pin values.
 *
 * INPUTS:
-*       port	- logical port number.
-*       rate    - ingress data rate limit for TCP/IP packets. These frames will 
-*				be discarded after the ingress rate selected is reached or exceeded. 
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - Px_MODE configuration value
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters 
-*								Valid rate is GT_BURST_NO_LIMIT, or between
-*								64Kbps and 1500Kbps.
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
+* COMMENTS:
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS grcSetTCPBurstRate
+GT_STATUS gprtGetPxMode
 (
-    IN GT_QD_DEV       *dev,
-    IN GT_LPORT        port,
-    IN GT_BURST_RATE   rate
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
 );
 
-
 /*******************************************************************************
-* grcGetTCPBurstRate
+* gprtGetMiiInterface
 *
 * DESCRIPTION:
-*       This routine sets the port's TCP/IP ingress data limit based on burst size.
+*        This routine retrives Mii Interface Mode.
 *
 * INPUTS:
-*       port	- logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       rate    - ingress data rate limit for TCP/IP packets. These frames will 
-*				be discarded after the ingress rate selected is reached or exceeded. 
+*        state - GT_TRUE if Mii Interface is enabled,
+*                  GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_VALUE        - register value is not known
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
-*
-* COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS grcGetTCPBurstRate
+GT_STATUS gprtGetMiiInterface
 (
-    IN  GT_QD_DEV       *dev,
-    IN  GT_LPORT        port,
-    OUT GT_BURST_RATE   *rate
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
-
-/* gtSysCtrl.c */
 /*******************************************************************************
-* gsysSetRateLimitMode
+* gprtGetFdFlowDis
 *
 * DESCRIPTION:
-*		Ingress Rate Limiting can be either Priority based or Burst Size based.
-*		This routine sets which mode to use.
+*        This routine retrives the read time value of the Full Duplex Flow Disable.
 *
 * INPUTS:
-*		mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        state - GT_TRUE if Full Duplex Flow Disable.
+*                   GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if invalid mode is used.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRateLimitMode
+GT_STATUS gprtGetFdFlowDis
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_INGRESS_RATE_MODE mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gsysGetRateLimitMode
+* gprtGetHdFlowDis
 *
 * DESCRIPTION:
-*		Ingress Rate Limiting can be either Priority based or Burst Size based.
-*		This routine gets which mode is being used.
+*        This routine retrives the read time value of the Half Duplex Flow Disable.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*        state - GT_TRUE if Half Duplex Flow Disable.
+*                   GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRateLimitMode
+GT_STATUS gprtGetHdFlowDis
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_INGRESS_RATE_MODE *mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *state
 );
 
 /*******************************************************************************
-* gsysSetAgeInt
+* gprtGetOutQSize
 *
 * DESCRIPTION:
-*		Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
-*		used (gprtSetLockedPort), it may be desirable to know when an address is
-*		still being used before it totally ages out of the switch. This can be 
-*		accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
-*		An ATU Age Violation looks identical to and reported the same as an ATU 
-*		Miss Violation. The only difference is when this reported. Normal ATU Miss
-*		Violation only occur if a new SA arrives at a LockedPort. The Age version 
-*		of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
-*		the address is contained in the ATU's database, but where its EntryState 
-*		is less than 0x4 (i.e., it has aged more than 1/2 way).
-*		GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
-*		Refer to eventSetActive routine to enable GT_ATU_PROB.
-*		
+*        This routine gets egress queue size counter value.
+*        This counter reflects the current number of Egress buffers switched to 
+*        this port. This is the total number of buffers across all four priority 
+*        queues.
 *
 * INPUTS:
-*		en - GT_TRUE, to enable,
-*			 GT_FALSE, otherwise.
+*        port - the logical port number
 *
 * OUTPUTS:
-*		None.
+*        count - egress queue size counter value
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetAgeInt
+GT_STATUS gprtGetOutQSize
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
 );
 
+
+/* gtPortCtrl.c */
+
 /*******************************************************************************
-* gsysGetAgeInt
+* gprtSetSAFiltering
 *
 * DESCRIPTION:
-*		Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
-*		used (gprtSetLockedPort), it may be desirable to know when an address is
-*		still being used before it totally ages out of the switch. This can be 
-*		accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
-*		An ATU Age Violation looks identical to and reported the same as an ATU 
-*		Miss Violation. The only difference is when this reported. Normal ATU Miss
-*		Violation only occur if a new SA arrives at a LockedPort. The Age version 
-*		of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
-*		the address is contained in the ATU's database, but where its EntryState 
-*		is less than 0x4 (i.e., it has aged more than 1/2 way).
-*		GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
-*		Refer to eventSetActive routine to enable GT_ATU_PROB.
-*
+*        This routine set the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC : 
+*                discard if SA field is in the ATU's address database as Static 
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU : 
+*                Ingressing frames will be mapped to the CPU Port if their SA 
+*                field is in the ATU's address database as Static entry with a 
+*                PortVec of all zeros. Otherwise, the frames will be discarded 
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*        
 * INPUTS:
-*		None.
+*       port - the logical port number.
+*       mode - GT_SA_FILTERING structure
 *
 * OUTPUTS:
-*		en - GT_TRUE, if enabled,
-*			 GT_FALSE, otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*
 *
 *******************************************************************************/
-GT_STATUS gsysGetAgeInt
+GT_STATUS gprtSetSAFiltering
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*en
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_SA_FILTERING    mode
 );
 
-
-/* For Zephyr */
-
-/* gtPhyCtrl.c */
 /*******************************************************************************
-* gprtGetPhyLinkStatus
+* gprtGetSAFiltering
 *
 * DESCRIPTION:
-*       This routine retrieves the Link status.
-*
+*        This routine gets the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOC : 
+*                discard if SA field is in the ATU's address database as Static 
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU : 
+*                Ingressing frames will be mapped to the CPU Port if their SA 
+*                field is in the ATU's address database as Static entry with a 
+*                PortVec of all zeros. Otherwise, the frames will be discarded 
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*        
 * INPUTS:
-* 		port 	- The logical port number
+*       port - the logical port number.
 *
 * OUTPUTS:
-*       linkStatus - GT_FALSE if link is not established,
-*				     GT_TRUE if link is established.
+*       mode - GT_SA_FILTERING structure
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		
 *
 * COMMENTS:
 *
+*
 *******************************************************************************/
-GT_STATUS gprtGetPhyLinkStatus
+GT_STATUS gprtGetSAFiltering
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-    IN GT_BOOL 	 *linkStatus
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_SA_FILTERING    *mode
 );
 
 
 /*******************************************************************************
-* gprtSetPktGenEnable
+* gprtSetARPtoCPU
 *
 * DESCRIPTION:
-*       This routine enables or disables Packet Generator.
-*       Link should be established first prior to enabling the packet generator,
-*       and generator will generate packets at the speed of the established link.
-*		When enables packet generator, the following information should be 
-*       provided:
-*           Payload Type:  either Random or 5AA55AA5
-*           Packet Length: either 64 or 1514 bytes
-*           Error Packet:  either Error packet or normal packet
-*
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*        
 * INPUTS:
-* 		port 	- The logical port number
-*       en      - GT_TRUE to enable, GT_FALSE to disable
-*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
-*                 ignored, if en is GT_FALSE
+*       port - the logical port number.
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
 *
 * OUTPUTS:
 *       None.
@@ -9935,1539 +11204,1616 @@ GT_STATUS gprtGetPhyLinkStatus
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		
 *
 * COMMENTS:
 *
+*
 *******************************************************************************/
-GT_STATUS gprtSetPktGenEnable
+GT_STATUS gprtSetARPtoCPU
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-    IN GT_BOOL   en,
-    IN GT_PG     *pktInfo
+    IN GT_QD_DEV  *dev,
+    IN GT_LPORT   port,
+    IN GT_BOOL    mode
 );
 
+
 /*******************************************************************************
-* gprtGetSerdesMode
+* gprtGetARPtoCPU
 *
 * DESCRIPTION:
-*       This routine reads Serdes Interface Mode.
-*
+*        When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
+*        
 * INPUTS:
-*       port    - logical port number
+*       port - the logical port number.
 *
 * OUTPUTS:
-*       mode    - Serdes Interface Mode
+*       mode - GT_TRUE, to map ARP frames to CPU Port,
+*               GT_FALSE, otherwise.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*       None.
 *
-* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetSerdesMode
+GT_STATUS gprtGetARPtoCPU
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_LPORT     port,
-	IN  GT_SERDES_MODE *mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *mode
 );
 
 /*******************************************************************************
-* gprtSetSerdesMode
+* gprtSetEgressFlood
 *
 * DESCRIPTION:
-*       This routine sets Serdes Interface Mode.
+*       This routine set Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
 *
 * INPUTS:
-*       port    - logical port number
-*       mode    - Serdes Interface Mode
+*       port - the logical port number.
+*       mode - GT_EGRESS_FLOOD structure
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*
-* COMMENTS:
-*       None.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gprtSetSerdesMode
+GT_STATUS gprtSetEgressFlood
 (
-    IN  GT_QD_DEV    *dev,
+    IN  GT_QD_DEV   *dev,
     IN  GT_LPORT     port,
-	IN  GT_SERDES_MODE mode
+    IN  GT_EGRESS_FLOOD      mode
 );
 
-
-/* gtSysCtrl.c */
-
 /*******************************************************************************
-* gsysSetForceSnoopPri
+* gprtGetEgressFlood
 *
 * DESCRIPTION:
-*		Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
-*		set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
-*       Priority is enabled. When it's disabled, the priority on these frames
-*		is not modified.
+*       This routine gets Egress Flooding Mode.
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*       port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*       mode - GT_EGRESS_FLOOD structure
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetForceSnoopPri
+GT_STATUS gprtGetEgressFlood
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_EGRESS_FLOOD      *mode
 );
 
 /*******************************************************************************
-* gsysGetForceSnoopPri
+* gprtSetPortSched
 *
 * DESCRIPTION:
-*		Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
-*		set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
-*       Priority is enabled. When it's disabled, the priority on these frames
-*		is not modified.
+*        This routine sets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
 *
 * INPUTS:
-*		None.
+*        port - the logical port number
+*        mode - GT_PORT_SCHED_MODE enum type
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetForceSnoopPri
+GT_STATUS gprtSetPortSched
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PORT_SCHED_MODE        mode
 );
 
-
 /*******************************************************************************
-* gsysSetSnoopPri
+* gprtGetPortSched
 *
 * DESCRIPTION:
-*		Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
-*       this priority is used as the egressing frame's PRI[2:0] bits on generated
-*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
-*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*        This routine gets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        port - the logical port number
 *
 * OUTPUTS:
-*		None.
+*        mode - GT_PORT_SCHED_MODE enum type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetSnoopPri
+GT_STATUS gprtGetPortSched
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PORT_SCHED_MODE        *mode
 );
 
 
 /*******************************************************************************
-* gsysGetSnoopPri
+* gprtSetProviderTag
 *
 * DESCRIPTION:
-*		Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
-*       this priority is used as the egressing frame's PRI[2:0] bits on generated
-*       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
-*       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
+*        This routine sets Provider Tag which indicates the provider tag (Ether 
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number
+*        tag  - Provider Tag (Ether Type)
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetSnoopPri
+GT_STATUS gprtSetProviderTag
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        tag
 );
 
-
 /*******************************************************************************
-* gsysSetForceARPPri
+* gprtGetProviderTag
 *
 * DESCRIPTION:
-*		Force ARP Priority. The priority on ARP frames are set to the ARPPri 
-*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
-*       disabled, the priority on these frames is not modified.
+*        This routine gets Provider Tag which indicates the provider tag (Ether 
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        port - the logical port number
 *
 * OUTPUTS:
-*		None.
+*        tag  - Provider Tag (Ether Type)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetForceARPPri
+GT_STATUS gprtGetProviderTag
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *tag
 );
 
+
+
+/* gtPortRateCtrl.c */
+
 /*******************************************************************************
-* gsysGetForceARPPri
+* grcSetVidNrlEn
 *
 * DESCRIPTION:
-*		Force ARP Priority. The priority on ARP frames are set to the ARPPri 
-*       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
-*       disabled, the priority on these frames is not modified.
+*       This routine enables/disables VID None Rate Limit (NRL).
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
 *
 * INPUTS:
-*		None.
+*       port - logical port number.
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetForceARPPri
+GT_STATUS grcSetVidNrlEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
-
 /*******************************************************************************
-* gsysSetARPPri
+* grcGetVidNrlEn
 *
 * DESCRIPTION:
-*		ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
-*       this priority is used as the egressing frame's PRI[2:0] bits on generated
-*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
-*       used as the internal Queue Priority to use on ARP frames.
+*       This routine gets VID None Rate Limit (NRL) mode.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*       port - logical port number.
 *
 * OUTPUTS:
-*		None.
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetARPPri
+GT_STATUS grcGetVidNrlEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
-
 /*******************************************************************************
-* gsysGetARPPri
+* grcSetSaNrlEn
 *
 * DESCRIPTION:
-*		ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
-*       this priority is used as the egressing frame's PRI[2:0] bits on generated
-*       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
-*       used as the internal Queue Priority to use on ARP frames.
+*       This routine enables/disables SA None Rate Limit (NRL).
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
 *
 * INPUTS:
-*		None.
+*       port - logical port number.
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetARPPri
+GT_STATUS grcSetSaNrlEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
-
-/* added for 88E6065 */
-
-/* gtBrgVlan.c */
-
-/********************************************************************
-* gvlnSetForceMap
+/*******************************************************************************
+* grcGetSaNrlEn
 *
 * DESCRIPTION:
-*       This routine enables/disables Force Map feature.
-*		When Force Map feature is enabled, all received frames will be
-*		considered MGMT and they are mapped to the port or ports defined
-*		in the VLAN Table overriding the mapping from the address database.
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
 *
 * INPUTS:
-*       port    - logical port number to set.
-*       mode    - GT_TRUE, to enable force map feature
-*                 GT_FAULSE, otherwise 
+*       port - logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gvlnSetForceMap
+GT_STATUS grcGetSaNrlEn
 (
-    IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT 	port,
-    IN  GT_BOOL  	mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
-
-/********************************************************************
-* gvlnGetForceMap
+/*******************************************************************************
+* grcSetDaNrlEn
 *
 * DESCRIPTION:
-*       This routine checks if Force Map feature is enabled.
-*		When Force Map feature is enabled, all received frames will be
-*		considered MGMT and they are mapped to the port or ports defined
-*		in the VLAN Table overriding the mapping from the address database.
+*       This routine enables/disables DA None Rate Limit (NRL).
+*        When DA NRL is enabled and the destination address of a frame results in 
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates 
+*        Non Rate Limited, then the frame will not be ingress nor egress rate 
+*        limited.
 *
 * INPUTS:
-*       port    - logical port number to set.
+*       port - logical port number.
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       mode    - GT_TRUE, to enable force map feature
-*                 GT_FAULSE, otherwise 
+*       None.
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gvlnGetForceMap
+GT_STATUS grcSetDaNrlEn
 (
-    IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT 	port,
-    OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
-/* gtEvents.c */
-
 /*******************************************************************************
-* geventSetAgeIntEn
+* grcGetDaNrlEn
 *
 * DESCRIPTION:
-*		This routine enables/disables Age Interrupt for a port.
-*		When it's enabled, ATU Age Violation interrupts from this port are enabled.
-*		An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
-*		and the ingressing frame's SA is contained in the ATU as a non-Static 
-*		entry with a EntryState less than 0x4.
+*       This routine gets SA None Rate Limit (NRL) mode.
+*        When DA NRL is enabled and the destination address of a frame results in 
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates 
+*        Non Rate Limited, then the frame will not be ingress nor egress rate 
+*        limited.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Interrupt,
-*			   GT_FALUSE to disable
+*       port - logical port number.
 *
 * OUTPUTS:
-*		None.
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS geventSetAgeIntEn
+GT_STATUS grcGetDaNrlEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* geventGetAgeIntEn
+* grcSetELimitMode
 *
 * DESCRIPTION:
-*		This routine gets Age Interrupt Enable for the port.
-*		When it's enabled, ATU Age Violation interrupts from this port are enabled.
-*		An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
-*		and the ingressing frame's SA is contained in the ATU as a non-Static 
-*		entry with a EntryState less than 0x4.
+*       This routine sets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Interrupt,
-*			   GT_FALUSE to disable
+*       port - logical port number
+*        mode - GT_PIRL_ELIMIT_MODE enum type
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
 *
 *******************************************************************************/
-GT_STATUS geventGetAgeIntEn
+GT_STATUS grcSetELimitMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_ELIMIT_MODE        mode
 );
 
-
-/* gtPIRL.c */
-
 /*******************************************************************************
-* gpirlActivate
+* grcGetELimitMode
 *
 * DESCRIPTION:
-*       This routine activates Ingress Rate Limiting for the given ports by 
-*		initializing a resource bucket, assigning ports, and configuring
-*		Bucket Parameters.
+*       This routine gets Egress Rate Limit counting mode.
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
-*       portVec  - the list of ports that share the bucket.
-*		pirlData - PIRL resource parameters.
+*       port - logical port number
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_PIRL_ELIMIT_MODE enum type
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
+*        GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
+*        Please refer to the device datasheet for details.
 *
 *******************************************************************************/
-GT_STATUS gpirlActivate
+GT_STATUS grcGetELimitMode
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec,
-	IN  GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_ELIMIT_MODE        *mode
 );
 
 /*******************************************************************************
-* gpirlDeactivate
+* grcSetRsvdNrlEn
 *
 * DESCRIPTION:
-*       This routine deactivates Ingress Rate Limiting for the given bucket.
-*		It simply removes every ports from the Ingress Rate Resource.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the irlUnit before this function is called.
+*       This routine sets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the 
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non 
+*        rate limited.
 *
 * INPUTS:
-*		irlUnit  - bucket to be deactivated
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gpirlDeactivate
+GT_STATUS grcSetRsvdNrlEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
 );
 
 /*******************************************************************************
-* gpirlUpdateParam
+* grcGetRsvdNrlEn
 *
 * DESCRIPTION:
-*       This routine updates IRL Parameter.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*       This routine gets Reserved Non Rate Limit.
+*        When this feature is enabled, frames that match the requirements of the 
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non 
+*        rate limited.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11)
-*		pirlData - PIRL resource parameters
+*       en - GT_TRUE to enable Reserved Non Rate Limit,
+*             GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gpirlUpdateParam
+GT_STATUS grcGetRsvdNrlEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
 );
 
+
+/* gtPortRmon.c */
+
 /*******************************************************************************
-* gpirlReadParam
+* gstatsGetRealtimePortCounter
 *
 * DESCRIPTION:
-*       This routine retrieves IRL Parameter.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        This routine gets a specific realtime counter of the given port
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
-*       None
 *
 *******************************************************************************/
-GT_STATUS gpirlReadParam
+GT_STATUS gstatsGetRealtimePortCounter
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
 );
 
+
+/* gtQosMap.c */
+
 /*******************************************************************************
-* gpirlUpdatePortVec
+* gqosSetVIDFPriOverride
 *
 * DESCRIPTION:
-*       This routine updates port list that share the bucket.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        This routine sets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
-*       portVec  - the list of ports that share the bucket.
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpirlUpdatePortVec
+GT_STATUS gqosSetVIDFPriOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpirlReadPortVec
+* gqosGetVIDFPriOverride
 *
 * DESCRIPTION:
-*       This routine retrieves port list that share the bucket.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        This routine gets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       portVec  - the list of ports that share the bucket.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gpirlReadPortVec
+GT_STATUS gqosGetVIDFPriOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_U32		*portVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* grcGetPirlFcMode
+* gqosSetSAFPriOverride
 *
 * DESCRIPTION:
-*       This routine gets Port Ingress Rate Limit Flow Control mode.
-*		When EBSLimitAction is programmed to generate a flow control message, 
-*		the deassertion of flow control is controlled by this mode.
-*			GT_PIRL_FC_DEASSERT_EMPTY:
-*				De-assert when the ingress rate resource has become empty
-*			GT_PIRL_FC_DEASSERT_CBS_LIMIT
-*				De-assert when the ingress rate resource has enough room as
-*				specified by the CBSLimit.
-*		Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
-*		CBSLimit.
+*        This routine sets Source Address(SA) Frame Priority Override. 
+*        When this feature is enabled, SA Frame priority overrides can occur on 
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*       port - logical port number
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode - GT_PIRL_FC_DEASSERT enum type
+*        None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
+* GalTis:
+*
 *******************************************************************************/
-GT_STATUS grcGetPirlFcMode
+GT_STATUS gqosSetSAFPriOverride
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_PIRL_FC_DEASSERT		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gpirlGetIngressRateResource
+* gqosGetSAFPriOverride
 *
 * DESCRIPTION:
-*       This routine gets Ingress Rate Limiting Resources assigned to the port.
-*		This vector is used to attach specific counter resources to the physical
-*		port. And the same counter resource can be attached to more than one port.
+*        This routine gets Source Address(SA) Frame Priority Override. 
+*        When this feature is enabled, SA Frame priority overrides can occur on 
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*       port   - logical port number
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		resVec - resource vector (bit 0 for irl unit 0, bit 1 for irl unit 1, etc.)
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
+* GalTis:
+*
 *******************************************************************************/
-GT_STATUS gpirlGetIngressRateResource
+GT_STATUS gqosGetSAFPriOverride
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_U32		*resVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
-
-
-/* gtPortStatus.c */
-
 /*******************************************************************************
-* gprtGetPxMode
+* gqosSetDAFPriOverride
 *
 * DESCRIPTION:
-*		This routine retrives 4 bits of Px_MODE Configuration value.
-*		If speed and duplex modes are forced, the returned mode value would be
-*		different from the configuration pin values.
+*        This routine sets Destination Address(DA) Frame Priority Override. 
+*        When this feature is enabled, DA Frame priority overrides can occur on 
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		mode - Px_MODE configuration value
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPxMode
+GT_STATUS gqosSetDAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_U32  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gprtGetMiiInterface
+* gqosGetDAFPriOverride
 *
 * DESCRIPTION:
-*		This routine retrives Mii Interface Mode.
+*        This routine gets Destination Address(DA) Frame Priority Override. 
+*        When this feature is enabled, DA Frame priority overrides can occur on 
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if Mii Interface is enabled,
-*				  GT_FALSE otherwise.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetMiiInterface
+GT_STATUS gqosGetDAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* gprtGetFdFlowDis
+* gqosSetVIDQPriOverride
 *
 * DESCRIPTION:
-*		This routine retrives the read time value of the Full Duplex Flow Disable.
+*        This routine sets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		state - GT_TRUE if Full Duplex Flow Disable.
-*	   		    GT_FALSE otherwise.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetFdFlowDis
+GT_STATUS gqosSetVIDQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gprtGetHdFlowDis
+* gqosGetVIDQPriOverride
 *
 * DESCRIPTION:
-*		This routine retrives the read time value of the Half Duplex Flow Disable.
+*        This routine gets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		state - GT_TRUE if Half Duplex Flow Disable.
-*	   		    GT_FALSE otherwise.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetHdFlowDis
+GT_STATUS gqosGetVIDQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*state
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* gprtGetOutQSize
+* gqosSetSAQPriOverride
 *
 * DESCRIPTION:
-*		This routine gets egress queue size counter value.
-*		This counter reflects the current number of Egress buffers switched to 
-*		this port. This is the total number of buffers across all four priority 
-*		queues.
+*        This routine sets Source Address(SA) Queue Priority Override. 
+*        When this feature is enabled, SA Queue priority overrides can occur on 
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		count - egress queue size counter value
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
+* GalTis:
+*
 *******************************************************************************/
-GT_STATUS gprtGetOutQSize
+GT_STATUS gqosSetSAQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtSetSAFiltering
+* gqosGetSAQPriOverride
 *
 * DESCRIPTION:
-*		This routine set the Source Address(SA) fitering method.
-*			GT_SA_FILTERING_DISABLE :
-*				no frame will be filtered.
-*			GT_SA_DROP_ON_LOCK :
-*				discard if SA field is not in the ATU's address database.
-*			GT_SA_DROP_ON_UNLOC : 
-*				discard if SA field is in the ATU's address database as Static 
-*				entry with a PortVec of all zeros.
-*			GT_SA_DROP_TO_CPU : 
-*				Ingressing frames will be mapped to the CPU Port if their SA 
-*				field is in the ATU's address database as Static entry with a 
-*				PortVec of all zeros. Otherwise, the frames will be discarded 
-*				if their SA field is not in the ATU's address database or if this
-*				port's bit is not set in the PortVec bits for the frame's SA.
-*		
+*        This routine gets Source Address(SA) Queue Priority Override. 
+*        When this feature is enabled, SA Queue priority overrides can occur on 
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
 * INPUTS:
-*       port - the logical port number.
-*       mode - GT_SA_FILTERING structure
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetSAFiltering
+GT_STATUS gqosGetSAQPriOverride
 (
-    IN GT_QD_DEV  *dev,
-    IN GT_LPORT   port,
-    IN GT_SA_FILTERING    mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* gprtGetSAFiltering
+* gqosSetDAQPriOverride
 *
 * DESCRIPTION:
-*		This routine gets the Source Address(SA) fitering method.
-*			GT_SA_FILTERING_DISABLE :
-*				no frame will be filtered.
-*			GT_SA_DROP_ON_LOCK :
-*				discard if SA field is not in the ATU's address database.
-*			GT_SA_DROP_ON_UNLOC : 
-*				discard if SA field is in the ATU's address database as Static 
-*				entry with a PortVec of all zeros.
-*			GT_SA_DROP_TO_CPU : 
-*				Ingressing frames will be mapped to the CPU Port if their SA 
-*				field is in the ATU's address database as Static entry with a 
-*				PortVec of all zeros. Otherwise, the frames will be discarded 
-*				if their SA field is not in the ATU's address database or if this
-*				port's bit is not set in the PortVec bits for the frame's SA.
-*		
+*        This routine sets Destination Address(DA) Queue Priority Override. 
+*        When this feature is enabled, DA Queue priority overrides can occur on 
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
 * INPUTS:
-*       port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       mode - GT_SA_FILTERING structure
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetSAFiltering
+GT_STATUS gqosSetDAQPriOverride
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_SA_FILTERING    *mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
-
 /*******************************************************************************
-* gprtSetARPtoCPU
+* gqosGetDAQPriOverride
 *
 * DESCRIPTION:
-*		When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
-*		
+*        This routine sets Destination Address(DA) Queue Priority Override. 
+*        When this feature is enabled, DA Queue priority overrides can occur on 
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
+*
 * INPUTS:
-*       port - the logical port number.
-*       mode - GT_TRUE, to map ARP frames to CPU Port,
-*			   GT_FALSE, otherwise.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtSetARPtoCPU
+GT_STATUS gqosGetDAQPriOverride
 (
-    IN GT_QD_DEV  *dev,
-    IN GT_LPORT   port,
-    IN GT_BOOL    mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
-
 /*******************************************************************************
-* gprtGetARPtoCPU
+* gqosSetARPQPriOverride
 *
 * DESCRIPTION:
-*		When ARPtoCPU is set to GT_TRUE, ARP frames are mapped to the CPU port.
-*		
+*        This routine sets ARP Queue Priority Override. 
+*        When this feature is enabled, ARP Queue priority overrides can occur on 
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
+*
 * INPUTS:
-*       port - the logical port number.
+*        port - the logical port number.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       mode - GT_TRUE, to map ARP frames to CPU Port,
-*			   GT_FALSE, otherwise.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gprtGetARPtoCPU
+GT_STATUS gqosSetARPQPriOverride
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_BOOL    *mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gprtSetEgressFlood
+* gqosGetARPQPriOverride
 *
 * DESCRIPTION:
-*       This routine set Egress Flooding Mode.
-*		Frames with unknown DA (Destination Address that is not in ATU database)
-*		generally flood out all the ports. This mode can be used to prevent
-*		those frames from egressing this port as follows:
-*			GT_BLOCK_EGRESS_UNKNOWN
-*				do not egress frame with unknown DA (both unicast and multicast)
-*			GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
-*				do not egress frame with unknown multicast DA
-*			GT_BLOCK_EGRESS_UNKNOWN_UNICAST
-*				do not egress frame with unknown unicast DA
-*			GT_BLOCK_EGRESS_NONE
-*				egress all frames with unknown DA
+*        This routine sets ARP Queue Priority Override. 
+*        When this feature is enabled, ARP Queue priority overrides can occur on 
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
 *
 * INPUTS:
-*       port - the logical port number.
-*       mode - GT_EGRESS_FLOOD structure
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
+* GalTis:
+*
 *******************************************************************************/
-GT_STATUS gprtSetEgressFlood
+GT_STATUS gqosGetARPQPriOverride
 (
-    IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT     port,
-    IN  GT_EGRESS_FLOOD      mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
+
 /*******************************************************************************
-* gprtGetEgressFlood
+* gqosSetQPriValue
 *
 * DESCRIPTION:
-*       This routine gets Egress Flooding Mode.
-*		Frames with unknown DA (Destination Address that is not in ATU database)
-*		generally flood out all the ports. This mode can be used to prevent
-*		those frames from egressing this port as follows:
-*			GT_BLOCK_EGRESS_UNKNOWN
-*				do not egress frame with unknown DA (both unicast and multicast)
-*			GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
-*				do not egress frame with unknown multicast DA
-*			GT_BLOCK_EGRESS_UNKNOWN_UNICAST
-*				do not egress frame with unknown unicast DA
-*			GT_BLOCK_EGRESS_NONE
-*				egress all frames with unknown DA
+*       This routine sets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
 *
 * INPUTS:
 *       port - the logical port number.
+*       pri  - Queue priority value
 *
 * OUTPUTS:
-*       mode - GT_EGRESS_FLOOD structure
+*       None.
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gprtGetEgressFlood
+GT_STATUS gqosSetQPriValue
 (
-    IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT     port,
-    OUT GT_EGRESS_FLOOD      *mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
 );
 
 /*******************************************************************************
-* gprtSetPortSched
+* gqosGetQPriValue
 *
 * DESCRIPTION:
-*		This routine sets Port Scheduling Mode.
-*		When usePortSched is enablied, this mode is used to select the Queue
-*		controller's scheduling on the port as follows:
-*			GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
-*			GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*       This routine gets Queue priority value to used when forced.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_PORT_SCHED_MODE enum type
+*       port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*       pri  - Queue priority value
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gprtSetPortSched
+GT_STATUS gqosGetQPriValue
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_PORT_SCHED_MODE		mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
 );
 
 /*******************************************************************************
-* gprtGetPortSched
+* gqosSetForceQPri
 *
 * DESCRIPTION:
-*		This routine gets Port Scheduling Mode.
-*		When usePortSched is enablied, this mode is used to select the Queue
-*		controller's scheduling on the port as follows:
-*			GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
-*			GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*       This routine enables/disables forcing Queue priority.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all 
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
 *
 * INPUTS:
-*		port - the logical port number
+*       port - the logical port number.
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		mode - GT_PORT_SCHED_MODE enum type
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gprtGetPortSched
+GT_STATUS gqosSetForceQPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_PORT_SCHED_MODE		*mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_BOOL    en
 );
 
-
 /*******************************************************************************
-* gprtSetProviderTag
+* gqosGetForceQPri
 *
 * DESCRIPTION:
-*		This routine sets Provider Tag which indicates the provider tag (Ether 
-*		Type) value that needs to be matched to in ingress to determine if a
-*		frame is Provider tagged or not.
+*       This routine checks if forcing Queue priority is enabled.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all 
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
 *
 * INPUTS:
-*		port - the logical port number
-*		tag  - Provider Tag (Ether Type)
+*       port - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*       en   - GT_TRUE, to force Queue Priority,
+*               GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gprtSetProviderTag
+GT_STATUS gqosGetForceQPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		tag
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_BOOL    *en
 );
 
 /*******************************************************************************
-* gprtGetProviderTag
+* gqosSetDefFPri
 *
 * DESCRIPTION:
-*		This routine gets Provider Tag which indicates the provider tag (Ether 
-*		Type) value that needs to be matched to in ingress to determine if a
-*		frame is Provider tagged or not.
+*       This routine sets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when 
+*        no other priority information is available.
 *
 * INPUTS:
-*		port - the logical port number
+*       port - the logical port number
+*       pri  - default frame priority
 *
 * OUTPUTS:
-*		tag  - Provider Tag (Ether Type)
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 7
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gprtGetProviderTag
+GT_STATUS gqosSetDefFPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*tag
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    IN  GT_U8      pri
 );
 
-
-
-/* gtPortRateCtrl.c */
-
 /*******************************************************************************
-* grcSetVidNrlEn
+* gqosGetDefFPri
 *
 * DESCRIPTION:
-*       This routine enables/disables VID None Rate Limit (NRL).
-*		When VID NRL is enabled and the determined VID of a frame results in a VID
-*		whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
-*		will not be ingress nor egress rate limited.
+*       This routine gets the default frame priority (0 ~ 7).
+*        This priority is used as the default frame priority (FPri) to use when 
+*        no other priority information is available.
 *
 * INPUTS:
-*       port - logical port number.
-*		mode - GT_TRUE to enable VID None Rate Limit
-*			   GT_FALSE otherwise
+*       port - the logical port number
 *
 * OUTPUTS:
-*       None.
+*       pri  - default frame priority
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS grcSetVidNrlEn
+GT_STATUS gqosGetDefFPri
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV  *dev,
+    IN  GT_LPORT   port,
+    OUT GT_U8      *pri
 );
 
+
 /*******************************************************************************
-* grcGetVidNrlEn
+* gqosSetArpQPri
 *
 * DESCRIPTION:
-*       This routine gets VID None Rate Limit (NRL) mode.
-*		When VID NRL is enabled and the determined VID of a frame results in a VID
-*		whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
-*		will not be ingress nor egress rate limited.
+*       This routine sets ARP queue Priority to use for ARP QPri Overridden 
+*        frames. When a ARP frame is received on a por tthat has its ARP 
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
 *
 * INPUTS:
-*       port - logical port number.
+*       pri - ARP Queue Priority (0 ~ 3)
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable VID None Rate Limit
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if pri > 3
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcGetVidNrlEn
+GT_STATUS gqosSetArpQPri
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     pri
 );
 
+
 /*******************************************************************************
-* grcSetSaNrlEn
+* gqosGetArpQPri
 *
 * DESCRIPTION:
-*       This routine enables/disables SA None Rate Limit (NRL).
-*		When SA NRL is enabled and the source address of a frame results in a ATU
-*		hit where the SA's MAC address returns an EntryState that indicates Non
-*		Rate Limited, then the frame will not be ingress nor egress rate limited.
+*       This routine gets ARP queue Priority to use for ARP QPri Overridden 
+*        frames. When a ARP frame is received on a por tthat has its ARP 
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
 *
 * INPUTS:
-*       port - logical port number.
-*		mode - GT_TRUE to enable SA None Rate Limit
-*			   GT_FALSE otherwise
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       pri - ARP Queue Priority (0 ~ 3)
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcSetSaNrlEn
+GT_STATUS gqosGetArpQPri
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV *dev,
+    OUT GT_U8     *pri
 );
 
+
+/* gtSysCtrl.c */
+
 /*******************************************************************************
-* grcGetSaNrlEn
+* gsysSetUsePortSchedule
 *
 * DESCRIPTION:
-*       This routine gets SA None Rate Limit (NRL) mode.
-*		When SA NRL is enabled and the source address of a frame results in a ATU
-*		hit where the SA's MAC address returns an EntryState that indicates Non
-*		Rate Limited, then the frame will not be ingress nor egress rate limited.
+*       This routine sets per port scheduling mode
 *
 * INPUTS:
-*       port - logical port number.
+*       en - GT_TRUE enables per port scheduling, 
+*             GT_FALSE disable.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable SA None Rate Limit
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcGetSaNrlEn
+GT_STATUS gsysSetUsePortSchedule
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
 );
 
 /*******************************************************************************
-* grcSetDaNrlEn
+* gsysGetUsePortSchedule
 *
 * DESCRIPTION:
-*       This routine enables/disables DA None Rate Limit (NRL).
-*		When DA NRL is enabled and the destination address of a frame results in 
-*		a ATU hit where the DA's MAC address returns an EntryState that indicates 
-*		Non Rate Limited, then the frame will not be ingress nor egress rate 
-*		limited.
+*       This routine gets per port scheduling mode
 *
 * INPUTS:
-*       port - logical port number.
-*		mode - GT_TRUE to enable DA None Rate Limit
-*			   GT_FALSE otherwise
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       en - GT_TRUE enables per port scheduling, 
+*             GT_FALSE disable.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcSetDaNrlEn
+GT_STATUS gsysGetUsePortSchedule
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
 );
 
 /*******************************************************************************
-* grcGetDaNrlEn
+* gsysSetOldHader
 *
 * DESCRIPTION:
-*       This routine gets SA None Rate Limit (NRL) mode.
-*		When DA NRL is enabled and the destination address of a frame results in 
-*		a ATU hit where the DA's MAC address returns an EntryState that indicates 
-*		Non Rate Limited, then the frame will not be ingress nor egress rate 
-*		limited.
+*       This routine sets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header, 
+*        the format of the Header is slightly modified to be backwards compatible 
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
 *
 * INPUTS:
-*       port - logical port number.
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable DA None Rate Limit
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcGetDaNrlEn
+GT_STATUS gsysSetOldHader
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
 );
 
 /*******************************************************************************
-* grcSetELimitMode
+* gsysGetOldHader
 *
 * DESCRIPTION:
-*       This routine sets Egress Rate Limit counting mode.
-*		The supported modes are as follows:
-*			GT_PIRL_ELIMIT_FRAME -
-*				Count the number of frames
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
-*			GT_PIRL_ELIMIT_LAYER2 -
-*				Count all Layer 2 bytes: Frame's DA to CRC
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*       This routine gets Egress Old Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header, 
+*        the format of the Header is slightly modified to be backwards compatible 
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
 *
 * INPUTS:
-*       port - logical port number
-*		mode - GT_PIRL_ELIMIT_MODE enum type
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       en - GT_TRUE to enable Old Header Mode,
+*             GT_FALSE to disable
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
-*		GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
-*		Please refer to the device datasheet for details.
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcSetELimitMode
+GT_STATUS gsysGetOldHader
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_PIRL_ELIMIT_MODE		mode
+    IN  GT_QD_DEV *dev,
+    OUT GT_BOOL   *en
 );
 
 /*******************************************************************************
-* grcGetELimitMode
+* gsysSetRecursiveStrippingDisable
 *
 * DESCRIPTION:
-*       This routine gets Egress Rate Limit counting mode.
-*		The supported modes are as follows:
-*			GT_PIRL_ELIMIT_FRAME -
-*				Count the number of frames
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
-*			GT_PIRL_ELIMIT_LAYER2 -
-*				Count all Layer 2 bytes: Frame's DA to CRC
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*       This routine determines if recursive tag stripping feature needs to be
+*        disabled.
 *
 * INPUTS:
-*       port - logical port number
+*       en - GT_TRUE to disable Recursive Tag Stripping,
+*             GT_FALSE to enable
 *
 * OUTPUTS:
-*		mode - GT_PIRL_ELIMIT_MODE enum type
+*       None.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
-*		GT_PIRL_ELIMIT_FRAME mode is supported by only a few devices.
-*		Please refer to the device datasheet for details.
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS grcGetELimitMode
+GT_STATUS gsysSetRecursiveStrippingDisable
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_PIRL_ELIMIT_MODE		*mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_BOOL   en
 );
 
 /*******************************************************************************
-* grcSetRsvdNrlEn
+* gsysGetRecursiveStrippingDisable
 *
 * DESCRIPTION:
-*       This routine sets Reserved Non Rate Limit.
-*		When this feature is enabled, frames that match the requirements of the 
-*		Rsvd2Cpu bit below will also be considered to be ingress and egress non 
-*		rate limited.
+*       This routine checks if recursive tag stripping feature is disabled.
 *
 * INPUTS:
-*       en - GT_TRUE to enable Reserved Non Rate Limit,
-*			 GT_FALSE to disable
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       en - GT_TRUE, if Recursive Tag Stripping is disabled,
+*             GT_FALSE, otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
 *
 *******************************************************************************/
-GT_STATUS grcSetRsvdNrlEn
+GT_STATUS gsysGetRecursiveStrippingDisable
 (
     IN  GT_QD_DEV *dev,
-    IN  GT_BOOL   en
+    OUT GT_BOOL   *en
 );
 
 /*******************************************************************************
-* grcGetRsvdNrlEn
+* gsysSetCPUPort
 *
 * DESCRIPTION:
-*       This routine gets Reserved Non Rate Limit.
-*		When this feature is enabled, frames that match the requirements of the 
-*		Rsvd2Cpu bit below will also be considered to be ingress and egress non 
-*		rate limited.
+*       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
+*        frames are destined.
 *
 * INPUTS:
-*       en - GT_TRUE to enable Reserved Non Rate Limit,
-*			 GT_FALSE to disable
+*       cpuPort - CPU Port
 *
 * OUTPUTS:
 *       None.
@@ -11475,4484 +12821,4337 @@ GT_STATUS grcSetRsvdNrlEn
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
 *
 *******************************************************************************/
-GT_STATUS grcGetRsvdNrlEn
+GT_STATUS gsysSetCPUPort
 (
     IN  GT_QD_DEV *dev,
-    OUT GT_BOOL   *en
+    IN  GT_LPORT  cpuPort
 );
 
-
-/* gtPortRmon.c */
-
 /*******************************************************************************
-* gstatsGetRealtimePortCounter
+* gsysGetCPUPort
 *
 * DESCRIPTION:
-*		This routine gets a specific realtime counter of the given port
+*       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
+*        frames are destined.
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*       cpuPort - CPU Port
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gstatsGetRealtimePortCounter
+GT_STATUS gsysGetCPUPort
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS3	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV *dev,
+    OUT GT_LPORT  *cpuPort
 );
 
 
-/* gtQosMap.c */
+
+/* gtSysStatus.c */
 
 /*******************************************************************************
-* gqosSetVIDFPriOverride
+* gsysGetFreeQSize
 *
 * DESCRIPTION:
-*		This routine sets VID Frame Priority Override. When this feature is enabled,
-*		VID Frame priority overrides can occur on this port.
-*		VID Frame priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
-*		When this occurs the VIDFPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new VIDFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       This routine gets Free Queue Counter. This counter reflects the 
+*        current number of unalllocated buffers available for all the ports.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for VID Frame Priority Override,
-*			   GT_FALSE otherwise
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       count - Free Queue Counter
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gqosSetVIDFPriOverride
+GT_STATUS gsysGetFreeQSize
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16         *count
 );
 
 /*******************************************************************************
-* gqosGetVIDFPriOverride
+                New APIs in DSDT 2.6
+*******************************************************************************/
+
+/* gtBrgFdb.c */
+
+/*******************************************************************************
+* gfdbSetPortAtuLearnLimit
 *
 * DESCRIPTION:
-*		This routine gets VID Frame Priority Override. When this feature is enabled,
-*		VID Frame priority overrides can occur on this port.
-*		VID Frame priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
-*		When this occurs the VIDFPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new VIDFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame 
+*        that ingresses this port with a source MAC address not already in the 
+*        address database that is associated with this port will be discarded. 
+*        Normal auto-learning will resume on the port as soon as the number of 
+*        active unicast MAC addresses associated to this port is less than the 
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the 
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) disable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
 *
 * INPUTS:
-*		port - the logical port number.
-*
+*       port  - logical port number
+*       limit - auto learning limit ( 0 ~ 255 )
+*                                              
 * OUTPUTS:
-*		mode - GT_TRUE for VID Frame Priority Override,
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gqosGetVIDFPriOverride
+GT_STATUS gfdbSetPortAtuLearnLimit
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       limit
 );
 
+
 /*******************************************************************************
-* gqosSetSAFPriOverride
+* gfdbGetPortAtuLearnCnt
 *
 * DESCRIPTION:
-*		This routine sets Source Address(SA) Frame Priority Override. 
-*		When this feature is enabled, SA Frame priority overrides can occur on 
-*		this port.
-*		SA ATU Frame priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       Read the current number of active unicast MAC addresses associated with 
+*        the given port. This counter (LearnCnt) is held at zero if learn limit
+*        (gfdbSetPortAtuLearnLimit API) is set to zero.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for SA Frame Priority Override,
-*			   GT_FALSE otherwise
-*
+*       port  - logical port number
+*                                              
 * OUTPUTS:
-*		None.
+*       count - current auto learning count
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gqosSetSAFPriOverride
+GT_STATUS gfdbGetPortAtuLearnCnt
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       *count
 );
 
 /*******************************************************************************
-* gqosGetSAFPriOverride
+* gfdbGetAtuAllCount
 *
 * DESCRIPTION:
-*		This routine gets Source Address(SA) Frame Priority Override. 
-*		When this feature is enabled, SA Frame priority overrides can occur on 
-*		this port.
-*		SA ATU Frame priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       Counts all entries in the Address Translation Unit.
 *
 * INPUTS:
-*		port - the logical port number.
+*       None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for SA Frame Priority Override,
-*			   GT_FALSE otherwise
+*       count - number of valid entries.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosGetSAFPriOverride
+GT_STATUS gfdbGetAtuAllCount
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *count
 );
 
 /*******************************************************************************
-* gqosSetDAFPriOverride
+* gfdbGetAtuAllCountInDBNum
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Frame Priority Override. 
-*		When this feature is enabled, DA Frame priority overrides can occur on 
-*		this port.
-*		DA ATU Frame priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       Counts all entries in the defined FID (or DBNum).
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DA Frame Priority Override,
-*			   GT_FALSE otherwise
+*       dbNum - DBNum of FID
 *
 * OUTPUTS:
-*		None.
+*       count - number of valid entries in FID (or DBNum).
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosSetDAFPriOverride
+GT_STATUS gfdbGetAtuAllCountInDBNum
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
 );
 
 /*******************************************************************************
-* gqosGetDAFPriOverride
+* gfdbGetAtuDynamicCountInDBNum
 *
 * DESCRIPTION:
-*		This routine gets Destination Address(DA) Frame Priority Override. 
-*		When this feature is enabled, DA Frame priority overrides can occur on 
-*		this port.
-*		DA ATU Frame priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*       Counts all non-static entries in the defined FID (or DBNum).
 *
 * INPUTS:
-*		port - the logical port number.
+*       dbNum - DBNum or FID
 *
 * OUTPUTS:
-*		mode - GT_TRUE for DA Frame Priority Override,
-*			   GT_FALSE otherwise
+*       count - number of valid non-static entries in FID (or DBNum).
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosGetDAFPriOverride
+GT_STATUS gfdbGetAtuDynamicCountInDBNum
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
 );
 
+
+/* gtBrgStu.c */
+
 /*******************************************************************************
-* gqosSetVIDQPriOverride
+* gstuGetEntryCount
 *
 * DESCRIPTION:
-*		This routine sets VID Queue Priority Override. When this feature is enabled,
-*		VID Queue priority overrides can occur on this port.
-*		VID Queue priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
-*		When this occurs the VIDQPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new VIDQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Gets the current number of valid entries in the STU table
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for VID Queue Priority Override,
-*			   GT_FALSE otherwise
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       numEntries - number of STU entries.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosSetVIDQPriOverride
+GT_STATUS gstuGetEntryCount
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV *dev,
+    OUT GT_U32    *numEntries
 );
 
 /*******************************************************************************
-* gqosGetVIDQPriOverride
+* gstuGetEntryFirst
 *
 * DESCRIPTION:
-*		This routine gets VID Queue Priority Override. When this feature is enabled,
-*		VID Queue priority overrides can occur on this port.
-*		VID Queue priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
-*		When this occurs the VIDQPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new VIDQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Gets first lexicographic entry from the STU.
 *
 * INPUTS:
-*		port - the logical port number.
+*       None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for VID Queue Priority Override,
-*			   GT_FALSE otherwise
+*       stuEntry - find the first valid STU entry.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NO_SUCH - table is empty.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gqosGetVIDQPriOverride
+GT_STATUS gstuGetEntryFirst
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV       *dev,
+    OUT GT_STU_ENTRY    *stuEntry
 );
 
 /*******************************************************************************
-* gqosSetSAQPriOverride
+* gstuGetEntryNext
 *
 * DESCRIPTION:
-*		This routine sets Source Address(SA) Queue Priority Override. 
-*		When this feature is enabled, SA Queue priority overrides can occur on 
-*		this port.
-*		SA ATU Queue priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Gets next lexicographic STU entry from the specified SID.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for SA Queue Priority Override,
-*			   GT_FALSE otherwise
+*       stuEntry - the SID to start the search.
 *
 * OUTPUTS:
-*		None.
+*       stuEntry - next STU entry.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no more entries.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gqosSetSAQPriOverride
+GT_STATUS gstuGetEntryNext
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry
 );
 
 /*******************************************************************************
-* gqosGetSAQPriOverride
+* gstuFindSidEntry
 *
 * DESCRIPTION:
-*		This routine gets Source Address(SA) Queue Priority Override. 
-*		When this feature is enabled, SA Queue priority overrides can occur on 
-*		this port.
-*		SA ATU Queue priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Find STU entry for a specific SID, it will return the entry, if found, 
+*       along with its associated data 
 *
 * INPUTS:
-*		port - the logical port number.
+*       stuEntry - contains the SID to searche for 
 *
 * OUTPUTS:
-*		mode - GT_TRUE for SA Queue Priority Override,
-*			   GT_FALSE otherwise
+*       found    - GT_TRUE, if the appropriate entry exists.
+*       stuEntry - the entry parameters.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success.
+*       GT_FAIL    - on error or entry does not exist.
+*       GT_NO_SUCH - no such entry.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gqosGetSAQPriOverride
+GT_STATUS gstuFindSidEntry
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV       *dev,
+    INOUT GT_STU_ENTRY  *stuEntry,
+    OUT GT_BOOL         *found
 );
 
 /*******************************************************************************
-* gqosSetDAQPriOverride
+* gstuAddEntry
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Queue Priority Override. 
-*		When this feature is enabled, DA Queue priority overrides can occur on 
-*		this port.
-*		DA ATU Queue priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Creates or update the entry in STU table based on user input.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DA Queue Priority Override,
-*			   GT_FALSE otherwise
+*       stuEntry    - stu entry to insert to the STU.
 *
 * OUTPUTS:
-*		None.
+*       None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK             - on success
+*       GT_FAIL           - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gqosSetDAQPriOverride
+GT_STATUS gstuAddEntry
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY    *stuEntry
 );
 
 /*******************************************************************************
-* gqosGetDAQPriOverride
+* gstuDelEntry
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Queue Priority Override. 
-*		When this feature is enabled, DA Queue priority overrides can occur on 
-*		this port.
-*		DA ATU Queue priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*       Deletes STU entry specified by user.
 *
 * INPUTS:
-*		port - the logical port number.
+*       stuEntry - the STU entry to be deleted 
 *
 * OUTPUTS:
-*		mode - GT_TRUE for DA Queue Priority Override,
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gqosGetDAQPriOverride
+GT_STATUS gstuDelEntry
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV       *dev,
+    IN  GT_STU_ENTRY     *stuEntry
 );
 
+
+/* gtCCPVT.c */
+
 /*******************************************************************************
-* gqosSetARPQPriOverride
+* gpvtInitialize
 *
 * DESCRIPTION:
-*		This routine sets ARP Queue Priority Override. 
-*		When this feature is enabled, ARP Queue priority overrides can occur on 
-*		this port.
-*		ARP Queue priority override occurs for all ARP frames.
-*		When this occurs, the frame's previously determined egress queue priority
-*		will be overwritten with ArpQPri.
-*		If the frame egresses tagged the priority in the frame will not
-*		be modified. When used, the two bits of the ArpQPri priority determine the
-*		egress queue the frame is switched into.
+*       This routine initializes the PVT Table to all one's (initial state)
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for ARP Queue Priority Override,
-*			   GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosSetARPQPriOverride
+GT_STATUS gpvtInitialize
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV     *dev
 );
 
 /*******************************************************************************
-* gqosGetARPQPriOverride
+* gpvtWritePVTData
 *
 * DESCRIPTION:
-*		This routine sets ARP Queue Priority Override. 
-*		When this feature is enabled, ARP Queue priority overrides can occur on 
-*		this port.
-*		ARP Queue priority override occurs for all ARP frames.
-*		When this occurs, the frame's previously determined egress queue priority
-*		will be overwritten with ArpQPri.
-*		If the frame egresses tagged the priority in the frame will not
-*		be modified. When used, the two bits of the ArpQPri priority determine the
-*		egress queue the frame is switched into.
+*       This routine write Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether 
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
 *
 * INPUTS:
-*		port - the logical port number.
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtData    - Cross Chip Port Vlan Data
 *
 * OUTPUTS:
-*		mode - GT_TRUE for ARP Queue Priority Override,
-*			   GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS: 
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosGetARPQPriOverride
+GT_STATUS gpvtWritePVTData
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    IN  GT_U32        pvtData
 );
 
-
 /*******************************************************************************
-* gqosSetQPriValue
+* gpvtReadPVTData
 *
 * DESCRIPTION:
-*       This routine sets Queue priority value to used when forced.
-*		When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
-*		are mapped to the priority queue defined in this value, unless a VTU, SA,
-*		DA or ARP priority override occurs. The Frame's priority (FPri) is not
-*		effected by this value.
+*       This routine reads Cross Chip Port Vlan Data.
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether 
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
+*
 *
 * INPUTS:
-*       port - the logical port number.
-*       pri  - Queue priority value
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
 *
 * OUTPUTS:
-*       None.
+*        pvtData    - Cross Chip Port Vlan Data
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 3
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gqosSetQPriValue
+GT_STATUS gpvtReadPVTData
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    IN  GT_U8      pri
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    OUT GT_U32        *pvtData
 );
 
+
+/* gtEvents.c */
+
 /*******************************************************************************
-* gqosGetQPriValue
+* geventGetDevIntStatus
 *
 * DESCRIPTION:
-*       This routine gets Queue priority value to used when forced.
-*		When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
-*		are mapped to the priority queue defined in this value, unless a VTU, SA,
-*		DA or ARP priority override occurs. The Frame's priority (FPri) is not
-*		effected by this value.
+*         Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch, and
+*        SERDES Link Int) have occurred.
 *
 * INPUTS:
-*       port - the logical port number.
+*       intType - the type of interrupt which causes an interrupt.
+*                  any combination of 
+*                    GT_DEV_INT_WATCHDOG,
+*                    GT_DEV_INT_JAMLIMIT,
+*                    GT_DEV_INT_DUPLEX_MISMATCH,
+*                    GT_DEV_INT_SERDES_LINK
+*        port    - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+*                  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
+*        linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+*                  asserted. It's in vector format, Bit 10 is for port 10, 
+*                  Bit 9 is for port 9, etc.
+*                  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
+*                  These bits are only valid of the port that is in 1000Base-X mode.
 *
 * OUTPUTS:
-*       pri  - Queue priority value
+*         None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK - on success
+*         GT_FAIL - on error
 *
 * COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gqosGetQPriValue
+GT_STATUS geventGetDevIntStatus
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_U8      *pri
+    IN  GT_QD_DEV             *dev,
+    OUT GT_DEV_INT_STATUS    *devIntStatus
 );
 
 /*******************************************************************************
-* gqosSetForceQPri
+* geventSetAgeOutIntEn
 *
 * DESCRIPTION:
-*       This routine enables/disables forcing Queue priority.
-*		When ForceQPri is disabled, normal priority queue mapping is used on all 
-*		ingressing frames entering this port. When it's enabled, all frames
-*		entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
-*		a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
-*		is not effected by this feature.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*       port - the logical port number.
-*       en   - GT_TRUE, to force Queue Priority,
-*			   GT_FALSE, otherwise.
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Out Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gqosSetForceQPri
+GT_STATUS geventSetAgeOutIntEn
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    IN  GT_BOOL    en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gqosGetForceQPri
+* geventGetAgeOutIntEn
 *
 * DESCRIPTION:
-*       This routine checks if forcing Queue priority is enabled.
-*		When ForceQPri is disabled, normal priority queue mapping is used on all 
-*		ingressing frames entering this port. When it's enabled, all frames
-*		entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
-*		a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
-*		is not effected by this feature.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*       port - the logical port number.
+*        port - the logical port number
 *
 * OUTPUTS:
-*       en   - GT_TRUE, to force Queue Priority,
-*			   GT_FALSE, otherwise.
+*        mode - GT_TRUE, if Age Out Interrupt is enabled
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gqosGetForceQPri
+GT_STATUS geventGetAgeOutIntEn
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_BOOL    *en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
 /*******************************************************************************
-* gqosSetDefFPri
+* geventSetOverLimitInt
 *
 * DESCRIPTION:
-*       This routine sets the default frame priority (0 ~ 7).
-*		This priority is used as the default frame priority (FPri) to use when 
-*		no other priority information is available.
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
 *
 * INPUTS:
-*       port - the logical port number
-*       pri  - default frame priority
+*        port - the logical port number
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 7
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gqosSetDefFPri
+GT_STATUS geventSetOverLimitInt
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    IN  GT_U8      pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gqosGetDefFPri
+* geventGetOverLimitInt
 *
 * DESCRIPTION:
-*       This routine gets the default frame priority (0 ~ 7).
-*		This priority is used as the default frame priority (FPri) to use when 
-*		no other priority information is available.
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
 *
 * INPUTS:
-*       port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*       pri  - default frame priority
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gqosGetDefFPri
+GT_STATUS geventGetOverLimitInt
 (
-    IN  GT_QD_DEV  *dev,
-    IN  GT_LPORT   port,
-    OUT GT_U8      *pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 );
 
-
 /*******************************************************************************
-* gqosSetArpQPri
+* geventGetPortAtuLimitReached
 *
 * DESCRIPTION:
-*       This routine sets ARP queue Priority to use for ARP QPri Overridden 
-*		frames. When a ARP frame is received on a por tthat has its ARP 
-*		QPriOVerride is enabled, the QPri assigned to the frame comes from
-*		this value
+*       This routine checks if learn limit has been reached.
+*        When it reached, the port can no longer auto learn any more MAC addresses
+*        because the address learn limit set on this port has been reached.
 *
 * INPUTS:
-*       pri - ARP Queue Priority (0 ~ 3)
-*
+*       port  - logical port number
+*                                              
 * OUTPUTS:
-*       None.
+*       limit - GT_TRUE, if limit has been reached
+*                GT_FALSE, otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 3
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
 *
+*
 *******************************************************************************/
-GT_STATUS gqosSetArpQPri
+GT_STATUS geventGetPortAtuLimitReached
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_U8     pri
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_BOOL       *limit
 );
 
-
 /*******************************************************************************
-* gqosGetArpQPri
+* eventSetDevInt
 *
 * DESCRIPTION:
-*       This routine gets ARP queue Priority to use for ARP QPri Overridden 
-*		frames. When a ARP frame is received on a por tthat has its ARP 
-*		QPriOVerride is enabled, the QPri assigned to the frame comes from
-*		this value
-*
+*        Device Interrupt.
+*        The following device interrupts are supported:
+*            GT_DEV_INT_WATCHDOG    - 
+*                WatchDog event interrupt (WatchDog event can be configured with 
+*                gwdSetEvent API)
+*            GT_DEV_INT_JAMLIMIT    -
+*                any of the ports detect an Ingress Jam Limit violation
+*                (see gprtSetPauseLimitIn API)
+*            GT_DEV_INT_DUPLEX_MISMATCH - 
+*                any of the ports detect a duplex mismatch (i.e., the local port is 
+*                in half duplex mode while the link partner is in full duplex mode)
+*            GT_DEV_INT_SERDES_LINK - 
+*                SERDES link chage interrupt.
+*                An interrupt occurs when a SERDES port changes link status
+*                (link up or link down)
+*            
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled event when GT_DEV_INT is enabled with 
+*        eventSetActive API.
+*        
 * INPUTS:
-*       None.
+*        devInt - GT_DEV_INT
 *
 * OUTPUTS:
-*       pri - ARP Queue Priority (0 ~ 3)
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gqosGetArpQPri
+GT_STATUS eventSetDevInt
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_U8     *pri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_DEV_EVENT    *devInt
 );
 
-
-/* gtSysCtrl.c */
-
 /*******************************************************************************
-* gsysSetUsePortSchedule
+* gwdSetEvent
 *
 * DESCRIPTION:
-*       This routine sets per port scheduling mode
-*
+*        Watch Dog Event.
+*        The following Watch Dog events are supported:
+*            GT_WD_QC  - Queue Controller Watch Dog enable.
+*                        When enabled, the QC's watch dog circuit checks for link
+*                        list errors and any errors found in the QC.
+*            GT_WD_EGRESS - Egress Watch Dog enable.
+*                        When enabled, each port's egress circuit checks for problems
+*                        between the port and the Queue Controller.
+*            GT_WD_FORCE - Force a Watch Dog event.
+*            
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
+*        enabled with eventSetDevActive API and GT_DEV_INT is enabled with 
+*        eventSetActive API.
+*        
 * INPUTS:
-*       en - GT_TRUE enables per port scheduling, 
-*			 GT_FALSE disable.
+*        wdEvent - Watch Dog Events
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetUsePortSchedule
+GT_STATUS gwdSetEvent
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_BOOL   en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        wdEvent
 );
 
 /*******************************************************************************
-* gsysGetUsePortSchedule
+* gwdSetSWResetOnWD
 *
 * DESCRIPTION:
-*       This routine gets per port scheduling mode
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this 
+*        automatic SWReset. This allows the user to know if any watch dog event 
+*        ever occurred even if the swich is configured to automatically recover 
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
 *
 * INPUTS:
-*       None.
+*        en   - GT_TRUE to enable SWReset on WD
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*       en - GT_TRUE enables per port scheduling, 
-*			 GT_FALSE disable.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetUsePortSchedule
+GT_STATUS gwdSetSWResetOnWD
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_BOOL   *en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysSetOldHader
+* gwdGetSWResetOnWD
 *
 * DESCRIPTION:
-*       This routine sets Egress Old Header.
-*		When this feature is enabled and frames are egressed with a Marvell Header, 
-*		the format of the Header is slightly modified to be backwards compatible 
-*		with previous devices that used the original Header. Specifically, bit 3
-*		of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
-*		is available in the Header.
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
+*
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this 
+*        automatic SWReset. This allows the user to know if any watch dog event 
+*        ever occurred even if the swich is configured to automatically recover 
+*        from a watch dog.
+*
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
 *
 * INPUTS:
-*       en - GT_TRUE to enable Old Header Mode,
-*			 GT_FALSE to disable
+*        None.
 *
 * OUTPUTS:
-*       None.
+*        en   - GT_TRUE, if SWReset on WD is enabled
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetOldHader
+GT_STATUS gwdGetSWResetOnWD
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_BOOL   en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gsysGetOldHader
+* gwdGetHistory
 *
 * DESCRIPTION:
-*       This routine gets Egress Old Header.
-*		When this feature is enabled and frames are egressed with a Marvell Header, 
-*		the format of the Header is slightly modified to be backwards compatible 
-*		with previous devices that used the original Header. Specifically, bit 3
-*		of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
-*		is available in the Header.
+*        This routine retrieves Watch Dog history. They are
+*
+*        wdEvent - 
+*            When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*            The following events are possible:
+*                QC WatchDog Event (GT_WD_QC)
+*                Egress WatchDog Event (GT_WD_EGRESS)
+*                Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent -
+*            If any port's egress logic detects an egress watch dog issue,
+*            this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*            event.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       en - GT_TRUE to enable Old Header Mode,
-*			 GT_FALSE to disable
+*        history - GT_WD_EVENT_HISTORY structure
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetOldHader
+GT_STATUS gwdGetHistory
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_BOOL   *en
+    IN  GT_QD_DEV            *dev,
+    OUT GT_WD_EVENT_HISTORY    *history
 );
 
+
+/* gtPIRL2.c */
+
 /*******************************************************************************
-* gsysSetRecursiveStrippingDisable
+* gpirl2WriteResource
 *
 * DESCRIPTION:
-*       This routine determines if recursive tag stripping feature needs to be
-*		disabled.
+*       This routine writes resource bucket parameters to the given resource
+*        of the port.
 *
 * INPUTS:
-*       en - GT_TRUE to disable Recursive Tag Stripping,
-*			 GT_FALSE to enable
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        pirlData - PIRL resource parameters.
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetRecursiveStrippingDisable
+GT_STATUS gpirl2WriteResource
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_BOOL   en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_DATA    *pirlData
 );
 
 /*******************************************************************************
-* gsysGetRecursiveStrippingDisable
+* gpirl2ReadResource
 *
 * DESCRIPTION:
-*       This routine checks if recursive tag stripping feature is disabled.
+*       This routine retrieves IRL Parameter.
 *
 * INPUTS:
-*       None.
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
 *
 * OUTPUTS:
-*       en - GT_TRUE, if Recursive Tag Stripping is disabled,
-*			 GT_FALSE, otherwise
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetRecursiveStrippingDisable
+GT_STATUS gpirl2ReadResource
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_BOOL   *en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_DATA    *pirlData
 );
 
 /*******************************************************************************
-* gsysSetCPUPort
+* gpirl2DisableResource
 *
 * DESCRIPTION:
-*       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
-*		frames are destined.
+*       This routine disables Ingress Rate Limiting for the given bucket.
 *
 * INPUTS:
-*       cpuPort - CPU Port
+*       port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetCPUPort
+GT_STATUS gpirl2DisableResource
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_LPORT  cpuPort
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes
 );
 
+
+/* gtPolicy.c */
+
 /*******************************************************************************
-* gsysGetCPUPort
+* gprtSetPolicy
 *
 * DESCRIPTION:
-*       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
-*		frames are destined.
-*
-* INPUTS:
-*       cpuPort - CPU Port
+*       This routine sets the Policy for ports.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*       policy     - policy (GT_FRAME_POLICY)
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetCPUPort
+GT_STATUS gprtSetPolicy
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_LPORT  *cpuPort
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    IN    GT_FRAME_POLICY    policy
 );
 
-
-
-/* gtSysStatus.c */
-
 /*******************************************************************************
-* gsysGetFreeQSize
+* gprtGetPolicy
 *
 * DESCRIPTION:
-*       This routine gets Free Queue Counter. This counter reflects the 
-*		current number of unalllocated buffers available for all the ports.
-*
-* INPUTS:
-*       None.
-*
-* OUTPUTS:
-*       count - Free Queue Counter
+*       This routine gets the Policy of the given policy type.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*
+* INPUTS:
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*
+* OUTPUTS:
+*       policy     - policy (GT_FRAME_POLICY)
 *
 * RETURNS:
 *       GT_OK            - on success
 *       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_BAD_PARAM     - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFreeQSize
+GT_STATUS gprtGetPolicy
 (
-    IN  GT_QD_DEV	*dev,
-    OUT GT_U16 		*count
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    OUT GT_FRAME_POLICY    *policy
 );
 
-/*******************************************************************************
-				New APIs in DSDT 2.6
-*******************************************************************************/
 
-/* gtBrgFdb.c */
+/* gtPortCtrl.c */
 
 /*******************************************************************************
-* gfdbSetPortAtuLearnLimit
+* gprtSetPauseLimitOut
 *
 * DESCRIPTION:
-*       Port's auto learning limit. When the limit is non-zero value, the number
-*		of MAC addresses that can be learned on this port are limited to the value
-*		specified in this API. When the learn limit has been reached any frame 
-*		that ingresses this port with a source MAC address not already in the 
-*		address database that is associated with this port will be discarded. 
-*		Normal auto-learning will resume on the port as soon as the number of 
-*		active unicast MAC addresses associated to this port is less than the 
-*		learn limit.
-*		CPU directed ATU Load, Purge, or Move will not have any effect on the 
-*		learn limit.
-*		This feature is disabled when the limit is zero.
-*		The following care is needed when enabling this feature:
-*			1) disable learning on the ports
-*			2) flush all non-static addresses in the ATU
-*			3) define the desired limit for the ports
-*			4) re-enable learing on the ports
-*
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can 
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to 
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*        
 * INPUTS:
-*       port  - logical port number
-*       limit - auto learning limit ( 0 ~ 255 )
-*											  
+*        port - the logical port number
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
+*
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*       None.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gfdbSetPortAtuLearnLimit
+GT_STATUS gprtSetPauseLimitOut
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT  	port,
-    IN  GT_U32   	limit
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
 );
 
-
 /*******************************************************************************
-* gfdbGetPortAtuLearnCnt
+* gprtGetPauseLimitOut
 *
 * DESCRIPTION:
-*       Read the current number of active unicast MAC addresses associated with 
-*		the given port. This counter (LearnCnt) is held at zero if learn limit
-*		(gfdbSetPortAtuLearnLimit API) is set to zero.
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can 
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to 
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
 *
 * INPUTS:
-*       port  - logical port number
-*											  
+*        port - the logical port number
+*
 * OUTPUTS:
-*       count - current auto learning count
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*       None.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gfdbGetPortAtuLearnCnt
+GT_STATUS gprtGetPauseLimitOut
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT  	port,
-    IN  GT_U32   	*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
 );
 
 /*******************************************************************************
-* gfdbGetAtuAllCount
+* gprtSetPauseLimitIn
 *
 * DESCRIPTION:
-*       Counts all entries in the Address Translation Unit.
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be 
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts 
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer 
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on 
+*        this port without the Port's ForceFC and FCValue getting modified.
 *
+*        The modification of Port's ForceFC and FCValue is the only indication that 
+*        the limit was reached on this port.
+*        
 * INPUTS:
-*       None.
+*        port - the logical port number
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
 *
 * OUTPUTS:
-*       count - number of valid entries.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gfdbGetAtuAllCount
+GT_STATUS gprtSetPauseLimitIn
 (
-    IN  GT_QD_DEV 	*dev,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
 );
 
 /*******************************************************************************
-* gfdbGetAtuAllCountInDBNum
+* gprtGetPauseLimitIn
 *
 * DESCRIPTION:
-*       Counts all entries in the defined FID (or DBNum).
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be 
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts 
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer 
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on 
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that 
+*        the limit was reached on this port.
 *
 * INPUTS:
-*       dbNum - DBNum of FID
+*        port - the logical port number
 *
 * OUTPUTS:
-*       count - number of valid entries in FID (or DBNum).
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gfdbGetAtuAllCountInDBNum
+GT_STATUS gprtGetPauseLimitIn
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_U32 		dbNum,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
 );
 
 /*******************************************************************************
-* gfdbGetAtuDynamicCountInDBNum
+* gprtSetFrameMode
 *
 * DESCRIPTION:
-*       Counts all non-static entries in the defined FID (or DBNum).
-*
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for 
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port 
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to 
+*                be used on ports that connect to a CPU.
+*        
 * INPUTS:
-*       dbNum - DBNum or FID
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
 *
 * OUTPUTS:
-*       count - number of valid non-static entries in FID (or DBNum).
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is unknown
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gfdbGetAtuDynamicCountInDBNum
+GT_STATUS gprtSetFrameMode
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_U32 		dbNum,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
 );
 
-
-/* gtBrgStu.c */
+/*******************************************************************************
+* gprtGetFrameMode
+*
+* DESCRIPTION:
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for 
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port 
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to 
+*                be used on ports that connect to a CPU.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        mode - GT_FRAME_MODE type
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS: 
+*
+*******************************************************************************/
+GT_STATUS gprtGetFrameMode
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_FRAME_MODE    *mode
+);
 
 /*******************************************************************************
-* gstuGetEntryCount
+* gprtSetHoldAt1
 *
 * DESCRIPTION:
-*       Gets the current number of valid entries in the STU table
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down 
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
 *
 * INPUTS:
-*       None.
+*        port - the logical port number.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       numEntries - number of STU entries.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gstuGetEntryCount
+GT_STATUS gprtSetHoldAt1
 (
-    IN  GT_QD_DEV *dev,
-    OUT GT_U32    *numEntries
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gstuGetEntryFirst
+* gprtGetHoldAt1
 *
 * DESCRIPTION:
-*       Gets first lexicographic entry from the STU.
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down 
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
 *
 * INPUTS:
-*       None.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       stuEntry - find the first valid STU entry.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NO_SUCH - table is empty.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gstuGetEntryFirst
+GT_STATUS gprtGetHoldAt1
 (
-    IN  GT_QD_DEV       *dev,
-    OUT GT_STU_ENTRY    *stuEntry
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 );
 
 /*******************************************************************************
-* gstuGetEntryNext
+* gprtSetRefreshLocked
 *
 * DESCRIPTION:
-*       Gets next lexicographic STU entry from the specified SID.
+*        Auto Refresh known addresses when port is Locked. Already known addresses 
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
 *
 * INPUTS:
-*       stuEntry - the SID to start the search.
+*        port - the logical port number.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*       stuEntry - next STU entry.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success.
-*       GT_FAIL    - on error or entry does not exist.
-*       GT_NO_SUCH - no more entries.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gstuGetEntryNext
+GT_STATUS gprtSetRefreshLocked
 (
-    IN  GT_QD_DEV       *dev,
-    INOUT GT_STU_ENTRY  *stuEntry
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gstuFindSidEntry
+* gprtGetRefreshLocked
 *
 * DESCRIPTION:
-*       Find STU entry for a specific SID, it will return the entry, if found, 
-*       along with its associated data 
+*        Auto Refresh known addresses when port is Locked. Already known addresses 
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
 *
 * INPUTS:
-*       stuEntry - contains the SID to searche for 
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*       found    - GT_TRUE, if the appropriate entry exists.
-*       stuEntry - the entry parameters.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success.
-*       GT_FAIL    - on error or entry does not exist.
-*       GT_NO_SUCH - no such entry.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
-GT_STATUS gstuFindSidEntry
+GT_STATUS gprtGetRefreshLocked
 (
-    IN  GT_QD_DEV       *dev,
-    INOUT GT_STU_ENTRY  *stuEntry,
-    OUT GT_BOOL         *found
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 );
 
 /*******************************************************************************
-* gstuAddEntry
+* gprtSetPortEType
 *
 * DESCRIPTION:
-*       Creates or update the entry in STU table based on user input.
+*        This routine sets the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
 *
 * INPUTS:
-*       stuEntry    - stu entry to insert to the STU.
+*        port  - the logical port number
+*        etype - port's special ether type
 *
 * OUTPUTS:
-*       None
+*        None.
 *
 * RETURNS:
-*       GT_OK             - on success
-*       GT_FAIL           - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gstuAddEntry
+GT_STATUS gprtSetPortEType
 (
-    IN  GT_QD_DEV   	*dev,
-    IN  GT_STU_ENTRY	*stuEntry
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_ETYPE        etype
 );
 
 /*******************************************************************************
-* gstuDelEntry
+* gprtGetPortEType
 *
 * DESCRIPTION:
-*       Deletes STU entry specified by user.
+*        This routine retrieves the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
 *
 * INPUTS:
-*       stuEntry - the STU entry to be deleted 
+*        port  - the logical port number
 *
 * OUTPUTS:
-*       None.
+*        etype - port's special ether type
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gstuDelEntry
+GT_STATUS gprtGetPortEType
 (
-    IN  GT_QD_DEV   	*dev,
-    IN  GT_STU_ENTRY 	*stuEntry
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_ETYPE    *etype
 );
 
 
-/* gtCCPVT.c */
+/* gtPortRateCtr.c */
 
 /*******************************************************************************
-* gpvtInitialize
+* grcSetFrameOverhead
 *
 * DESCRIPTION:
-*       This routine initializes the PVT Table to all one's (initial state)
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
+*
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
+*
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
+*
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
 *
 * INPUTS:
-*		None.
+*       port     - logical port number.
+*       overhead - Frame overhead (0 ~ 15)
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK               - on success
+*       GT_FAIL             - on error
+*       GT_BAD_PARAM        - on bad parameters
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gpvtInitialize
+GT_STATUS grcSetFrameOverhead
 (
-	IN  GT_QD_DEV 	*dev
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT            port,
+    IN GT_32            overhead
 );
 
 /*******************************************************************************
-* gpvtWritePVTData
+* grcGetFrameOverhead
 *
 * DESCRIPTION:
-*       This routine write Cross Chip Port Vlan Data.
-*		Cross chip Port VLAN Data used as a bit mask to limit where cross chip
-*		frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
-*		API). Cross chip frames are Forward frames that ingress a DSA or Ether 
-*		Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
-*		bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
-*		to egress that port on this device. When a port's mask bit is zero,
-*		frames are not allowed to egress that port on this device.
+*       Egress rate frame overhead adjustment.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
+*
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
 *
-*		The Cross Chip Port VLAN Table is accessed by ingressing frames based
-*		upon the original source port of the frame using the Forward frame's DSA tag
-*		fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
-*		that is accessed by the frame is:
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 0:
-*				If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
-*				If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 1:
-*				If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
-*				If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
 *
-*		Cross chip port VLANs with Trunks are supported in the table where this
-*		device's entries would be stored (defined by this device's Device Number).
-*		This portion of the table is available for Trunk entries because this device's
-*		port VLAN mappings to ports inside this device are masked by the port's
-*		VLAN Table (see gvlnSetPortVlanPorts API).
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
 *
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
 *
 * INPUTS:
-*		pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
-*		pvtData    - Cross Chip Port Vlan Data
+*       port    - logical port number.
 *
 * OUTPUTS:
-*       None.
+*       overhead - Frame overhead (0 ~ 15)
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*       None
+*       GT_OK            - on success
+*       GT_FAIL          - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 *******************************************************************************/
-GT_STATUS gpvtWritePVTData
+GT_STATUS grcGetFrameOverhead
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		pvtPointer,
-	IN  GT_U32		pvtData
+    IN GT_QD_DEV *dev,
+    IN  GT_LPORT port,
+    OUT GT_32    *overhead
 );
 
+
+/* gtPortStatus.c */
+
 /*******************************************************************************
-* gpvtReadPVTData
+* gprtGetBufHigh
 *
 * DESCRIPTION:
-*       This routine reads Cross Chip Port Vlan Data.
-*		Cross chip Port VLAN Data used as a bit mask to limit where cross chip
-*		frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
-*		API). Cross chip frames are Forward frames that ingress a DSA or Ether 
-*		Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
-*		bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
-*		to egress that port on this device. When a port's mask bit is zero,
-*		frames are not allowed to egress that port on this device.
+*        Output from QC telling the MAC that it should perform Flow Control.
+*
+* INPUTS:
+*        port - the logical port number
+*
+* OUTPUTS:
+*        bufHigh - GT_TRUE, if Flow control required
+*                  GT_FALSE, otherwise
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-*		The Cross Chip Port VLAN Table is accessed by ingressing frames based
-*		upon the original source port of the frame using the Forward frame's DSA tag
-*		fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
-*		that is accessed by the frame is:
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 0:
-*				If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
-*				If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 1:
-*				If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
-*				If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+* COMMENTS: 
 *
-*		Cross chip port VLANs with Trunks are supported in the table where this
-*		device's entries would be stored (defined by this device's Device Number).
-*		This portion of the table is available for Trunk entries because this device's
-*		port VLAN mappings to ports inside this device are masked by the port's
-*		VLAN Table (see gvlnSetPortVlanPorts API).
+*******************************************************************************/
+GT_STATUS gprtGetBufHigh
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *bufHigh
+);
+
+/*******************************************************************************
+* gprtGetFcEn
 *
+* DESCRIPTION:
+*        Input into the QC telling it that Flow Control is enabled on this port.
 *
 * INPUTS:
-*		pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        port - the logical port number
 *
 * OUTPUTS:
-*		pvtData    - Cross Chip Port Vlan Data
+*        fcEn - GT_TRUE, if Flow control is enabled
+*               GT_FALSE, otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gpvtReadPVTData
+GT_STATUS gprtGetFcEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		pvtPointer,
-	OUT GT_U32		*pvtData
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *fcEn
 );
 
-
-/* gtEvents.c */
-
 /*******************************************************************************
-* geventGetDevIntStatus
+* gprtGetRsvSize
 *
 * DESCRIPTION:
-* 		Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch, and
-*		SERDES Link Int) have occurred.
+*        This routine gets Ingress reserved queue size counter.
+*        This counter reflects the current number of reserved ingress buffers 
+*        assigned to this port.
 *
 * INPUTS:
-*       intType - the type of interrupt which causes an interrupt.
-*				  any combination of 
-*					GT_DEV_INT_WATCHDOG,
-*					GT_DEV_INT_JAMLIMIT,
-*					GT_DEV_INT_DUPLEX_MISMATCH,
-*					GT_DEV_INT_SERDES_LINK
-*		port	- logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
-*				  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
-*		linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
-*				  asserted. It's in vector format, Bit 10 is for port 10, 
-*				  Bit 9 is for port 9, etc.
-*				  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
-*				  These bits are only valid of the port that is in 1000Base-X mode.
+*        port - the logical port number
 *
 * OUTPUTS:
-* 		None.
+*        count - reserved ingress queue size counter value
 *
 * RETURNS:
-* 		GT_OK - on success
-* 		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS geventGetDevIntStatus
+GT_STATUS gprtGetRsvSize
 (
-    IN  GT_QD_DEV 			*dev,
-    OUT GT_DEV_INT_STATUS	*devIntStatus
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *count
 );
 
+
+/* gtPriTable.c */
+
 /*******************************************************************************
-* geventSetAgeOutIntEn
+* gsysSetQPriOverrideTable
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Out Interrupt,
-*			   GT_FALUSE to disable
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS geventSetAgeOutIntEn
+GT_STATUS gsysSetQPriOverrideTable
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
 );
 
 /*******************************************************************************
-* geventGetAgeOutIntEn
+* gsysGetQPriOverrideTable
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*       Queue Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
 *
 * INPUTS:
-*		port - the logical port number
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
 *
 * OUTPUTS:
-*		mode - GT_TRUE, if Age Out Interrupt is enabled
-*			   GT_FALUSE, otherwise
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS geventGetAgeOutIntEn
+GT_STATUS gsysGetQPriOverrideTable
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
 );
 
+
+/* gtSysCtrl.c */
+
 /*******************************************************************************
-* geventSetOverLimitInt
+* gsysSetCPUDest
 *
 * DESCRIPTION:
-*		This routine enables/disables Over Limit Interrupt for a port.
-*		If it's enabled, an ATU Miss violation will be generated when port auto
-*		learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
+*        This routine sets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria 
+*        are mapped to the CPU Destination port, overriding where the frame would 
+*        normally go. In the case of ARP, the frame will be mapped normally and it 
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination 
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
+*        will occur and ingressing To_CPU frames will be discarded.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Over Limit Interrupt,
-*			   GT_FALUSE to disable
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS geventSetOverLimitInt
+GT_STATUS gsysSetCPUDest
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* geventGetOverLimitInt
+* gsysGetCPUDest
 *
 * DESCRIPTION:
-*		This routine enables/disables Over Limit Interrupt for a port.
-*		If it's enabled, an ATU Miss violation will be generated when port auto
-*		learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
+*        This routine gets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria 
+*        are mapped to the CPU Destination port, overriding where the frame would 
+*        normally go. In the case of ARP, the frame will be mapped normally and it 
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination 
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
+*        will occur and ingressing To_CPU frames will be discarded.
 *
 * INPUTS:
-*		port - the logical port number
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable Over Limit Interrupt,
-*			   GT_FALUSE to disable
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS geventGetOverLimitInt
+GT_STATUS gsysGetCPUDest
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 );
 
 /*******************************************************************************
-* geventGetPortAtuLimitReached
+* gsysSetMirrorDest
 *
 * DESCRIPTION:
-*       This routine checks if learn limit has been reached.
-*		When it reached, the port can no longer auto learn any more MAC addresses
-*		because the address learn limit set on this port has been reached.
+*        This routine sets Mirror Destination Port. Frames that ingress a port 
+*        that trigger a policy mirror are mapped (copied) to this port as long as 
+*        the frame is not filtered or discarded. 
+*        The Mirror Destination port should point to the port that directs these 
+*        frames to the CPU that will process these frames. This target port should 
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
+*        Policy Mirror frames will be discarded.
 *
 * INPUTS:
-*       port  - logical port number
-*											  
+*        port  - the logical port number.
+*
 * OUTPUTS:
-*       limit - GT_TRUE, if limit has been reached
-*			    GT_FALSE, otherwise
+*        None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
-*
+*        None.
 *
 *******************************************************************************/
-GT_STATUS geventGetPortAtuLimitReached
+GT_STATUS gsysSetMirrorDest
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT  	port,
-    IN  GT_BOOL   	*limit
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 );
 
 /*******************************************************************************
-* eventSetDevInt
+* gsysGetMirrorDest
 *
 * DESCRIPTION:
-*		Device Interrupt.
-*		The following device interrupts are supported:
-*			GT_DEV_INT_WATCHDOG	- 
-*				WatchDog event interrupt (WatchDog event can be configured with 
-*				gwdSetEvent API)
-*			GT_DEV_INT_JAMLIMIT	-
-*				any of the ports detect an Ingress Jam Limit violation
-*				(see gprtSetPauseLimitIn API)
-*			GT_DEV_INT_DUPLEX_MISMATCH - 
-*				any of the ports detect a duplex mismatch (i.e., the local port is 
-*				in half duplex mode while the link partner is in full duplex mode)
-*			GT_DEV_INT_SERDES_LINK - 
-*				SERDES link chage interrupt.
-*				An interrupt occurs when a SERDES port changes link status
-*				(link up or link down)
-*			
-*		If any of the above events is enabled, GT_DEVICE_INT interrupt will
-*		be asserted by the enabled event when GT_DEV_INT is enabled with 
-*		eventSetActive API.
-*		
+*        This routine gets Mirror Destination Port. Frames that ingress a port 
+*        that trigger a policy mirror are mapped (copied) to this port as long as 
+*        the frame is not filtered or discarded. 
+*        The Mirror Destination port should point to the port that directs these 
+*        frames to the CPU that will process these frames. This target port should 
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
+*        Policy Mirror frames will be discarded.
+*
 * INPUTS:
-*		devInt - GT_DEV_INT
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS eventSetDevInt
+GT_STATUS gsysGetMirrorDest
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_DEV_EVENT    *devInt
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 );
 
 /*******************************************************************************
-* gwdSetEvent
+* gsysSetRMPort
 *
 * DESCRIPTION:
-*		Watch Dog Event.
-*		The following Watch Dog events are supported:
-*			GT_WD_QC  - Queue Controller Watch Dog enable.
-*						When enabled, the QC's watch dog circuit checks for link
-*						list errors and any errors found in the QC.
-*			GT_WD_EGRESS - Egress Watch Dog enable.
-*						When enabled, each port's egress circuit checks for problems
-*						between the port and the Queue Controller.
-*			GT_WD_FORCE - Force a Watch Dog event.
-*			
-*		If any of the above events is enabled, GT_DEVICE_INT interrupt will
-*		be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
-*		enabled with eventSetDevActive API and GT_DEV_INT is enabled with 
-*		eventSetActive API.
-*		
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
+*        device allows logical port 4 and 5.
+*        
 * INPUTS:
-*		wdEvent - Watch Dog Events
+*        port - Remote Management Port
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on unallowable port
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gwdSetEvent
+GT_STATUS gsysSetRMPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32	    wdEvent
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
 );
 
 /*******************************************************************************
-* gwdSetSWResetOnWD
+* gsysGetRMPort
 *
 * DESCRIPTION:
-*		SWReset on Watch Dog Event.
-*		When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
-*		will automatically reset the switch core's datapath just as if gsysSwReset
-*		API is called.
-*
-*		The Watch Dog History (gwdGetHistory API) won't be cleared by this 
-*		automatic SWReset. This allows the user to know if any watch dog event 
-*		ever occurred even if the swich is configured to automatically recover 
-*		from a watch dog.
-*
-*		When this feature is disabled, enabled watch dog events will not cause a
-*		SWReset.
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
+*        device allows logical port 4 and 5.
 *
 * INPUTS:
-*		en   - GT_TRUE to enable SWReset on WD
-*			   GT_FALUSE to disable
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        port - Remote Management Port
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gwdSetSWResetOnWD
+GT_STATUS gsysGetRMPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL	    en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
 );
 
 /*******************************************************************************
-* gwdGetSWResetOnWD
+* gsysSetRMDACheck
 *
 * DESCRIPTION:
-*		SWReset on Watch Dog Event.
-*		When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
-*		will automatically reset the switch core's datapath just as if gsysSwReset
-*		API is called.
-*
-*		The Watch Dog History (gwdGetHistory API) won't be cleared by this 
-*		automatic SWReset. This allows the user to know if any watch dog event 
-*		ever occurred even if the swich is configured to automatically recover 
-*		from a watch dog.
-*
-*		When this feature is disabled, enabled watch dog events will not cause a
-*		SWReset.
-*
+*        Check the DA on Remote Management frames. 
+*        When DA Check is enabled, the DA of Remote Management frames must be 
+*        contained in this device's address database (ATU) as a Static entry 
+*        (either unicast or multicast). If the DA of the frame is not contained 
+*        in this device's address database, the frame will be not be processed as 
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not 
+*        validated before processing the frame.
+*        
 * INPUTS:
-*		None.
+*        en - GT_TRUE to enable DA Check, 
+*             GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		en   - GT_TRUE, if SWReset on WD is enabled
-*			   GT_FALUSE, otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gwdGetSWResetOnWD
+GT_STATUS gsysSetRMDACheck
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL	    *en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
 );
 
 /*******************************************************************************
-* gwdGetHistory
+* gsysGetRMDACheck
 *
 * DESCRIPTION:
-*		This routine retrieves Watch Dog history. They are
-*
-*		wdEvent - 
-*			When it's set to GT_TRUE, some enabled Watch Dog event occurred.
-*			The following events are possible:
-*				QC WatchDog Event (GT_WD_QC)
-*				Egress WatchDog Event (GT_WD_EGRESS)
-*				Forced WatchDog Event (GT_WD_FORCE)
-*		egressEvent -
-*			If any port's egress logic detects an egress watch dog issue,
-*			this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
-*			event.
+*        Check the DA on Remote Management frames. 
+*        When DA Check is enabled, the DA of Remote Management frames must be 
+*        contained in this device's address database (ATU) as a Static entry 
+*        (either unicast or multicast). If the DA of the frame is not contained 
+*        in this device's address database, the frame will be not be processed as 
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not 
+*        validated before processing the frame.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		history - GT_WD_EVENT_HISTORY structure
+*        en - GT_TRUE if DA Check is enabled, 
+*             GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gwdGetHistory
+GT_STATUS gsysGetRMDACheck
 (
-	IN  GT_QD_DEV			*dev,
-	OUT GT_WD_EVENT_HISTORY	*history
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
 );
 
-
-/* gtPIRL2.c */
-
 /*******************************************************************************
-* gpirl2WriteResource
+* gsysSetHeaderType
 *
 * DESCRIPTION:
-*       This routine writes resource bucket parameters to the given resource
-*		of the port.
-*
+*   To set Header Type. These bits are used to configure the bits that are placed 
+*   into the Egress Header when it is enabled on a port (Port offset 0x04) 
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*        
 * INPUTS:
-*       port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
-*		pirlData - PIRL resource parameters.
+*        hdType 
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gpirl2WriteResource
+GT_STATUS gsysSetHeaderType
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	IN  GT_PIRL2_DATA	*pirlData
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       hdType
 );
 
 /*******************************************************************************
-* gpirl2ReadResource
+* gsysGetHeaderType
 *
 * DESCRIPTION:
-*       This routine retrieves IRL Parameter.
-*
+*   To get Header Type. These bits are used to configure the bits that are placed 
+*   into the Egress Header when it is enabled on a port (Port offset 0x04) 
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*        
 * INPUTS:
-*       port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
+*        None.
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        hdType 
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gpirl2ReadResource
+GT_STATUS gsysGetHeaderType
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	OUT GT_PIRL2_DATA	*pirlData
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16     *hdType
 );
 
 /*******************************************************************************
-* gpirl2DisableResource
+* gsysSetRMEnable
 *
 * DESCRIPTION:
-*       This routine disables Ingress Rate Limiting for the given bucket.
-*
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*        
 * INPUTS:
-*       port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
+*        en - GT_TRUE to enable Remote Management feature, 
+*             GT_FALSE otherwise.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gpirl2DisableResource
+GT_STATUS gsysSetRMEnable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
 );
 
-
-/* gtPolicy.c */
-
 /*******************************************************************************
-* gprtSetPolicy
+* gsysGetRMEnable
 *
 * DESCRIPTION:
-*       This routine sets the Policy for ports.
-*		Supported Policies are defined as GT_FRAME_POLICY as follows:
-*			FRAME_POLICY_NONE    - normal frame switching
-*			FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
-*			FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
-*			FRAME_POLICY_DISCARD - discard(filter) the frame
-*		Supported Policy types are defined as GT_POLICY_TYPE:
-*			POLICY_TYPE_DA - DA Policy Mapping
-*				DA Policy Mapping occurs when the DA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_SA - SA Policy Mapping
-*				SA Policy Mapping occurs when the SA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_VTU - VTU Policy Mapping
-*				VTU Policy Mapping occurs when the VID of a frame is contained in
-*				the VTU database with the VidPolicy is enabled.
-*			POLICY_TYPE_ETYPE - EtherType Policy Mapping
-*				EType Policy Mapping occurs when the EtherType of a frame matches
-*				the PortEType (see gprtSetPortEType API)
-*			POLICY_TYPE_PPPoE - PPPoE Policy Mapping
-*				PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
-*			POLICY_TYPE_VBAS - VBAS Policy Mapping
-*				VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
-*			POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
-*				DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
-*				IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
-*				IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
-*			POLICY_TYPE_UDP - UDP Policy Mapping
-*				UDP Policy Mapping occurs when the ingressing frame is
-*				a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
-*
-* INPUTS:
-*       port	- logical port number.
-*       type 	- policy type (GT_POLICY_TYPE)
-*       policy 	- policy (GT_FRAME_POLICY)
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*
+* INPUTS:
+*        None.
 *
 * OUTPUTS:
-*       None.
+*        en - GT_TRUE if Remote Management feature is enabled, 
+*             GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK            - on success
-*       GT_FAIL          - on error
-*       GT_BAD_PARAM     - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
-*
-* GalTis:
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gprtSetPolicy
+GT_STATUS gsysGetRMEnable
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT 	port,
-    IN  GT_POLICY_TYPE	type,
-	IN	GT_FRAME_POLICY	policy
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
 );
 
 /*******************************************************************************
-* gprtGetPolicy
+* gsysSetCtrMode
 *
 * DESCRIPTION:
-*       This routine gets the Policy of the given policy type.
-*		Supported Policies are defined as GT_FRAME_POLICY as follows:
-*			FRAME_POLICY_NONE    - normal frame switching
-*			FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
-*			FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
-*			FRAME_POLICY_DISCARD - discard(filter) the frame
-*		Supported Policy types are defined as GT_POLICY_TYPE:
-*			POLICY_TYPE_DA - DA Policy Mapping
-*				DA Policy Mapping occurs when the DA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_SA - SA Policy Mapping
-*				SA Policy Mapping occurs when the SA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_VTU - VTU Policy Mapping
-*				VTU Policy Mapping occurs when the VID of a frame is contained in
-*				the VTU database with the VidPolicy is enabled.
-*			POLICY_TYPE_ETYPE - EtherType Policy Mapping
-*				EType Policy Mapping occurs when the EtherType of a frame matches
-*				the PortEType (see gprtSetPortEType API)
-*			POLICY_TYPE_PPPoE - PPPoE Policy Mapping
-*				PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
-*			POLICY_TYPE_VBAS - VBAS Policy Mapping
-*				VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
-*			POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
-*				DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
-*				IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
-*				IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
-*			POLICY_TYPE_UDP - UDP Policy Mapping
-*				UDP Policy Mapping occurs when the ingressing frame is
-*				a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
-*
-* INPUTS:
-*       port	- logical port number.
-*       type 	- policy type (GT_POLICY_TYPE)
-*
-* OUTPUTS:
-*       policy 	- policy (GT_FRAME_POLICY)
+*        Set Counter Modes. These bits control the operating modes of the two of 
+*        the Ports MIB counters.
+*        
+* INPUTS:
+*        ctrMode - Counter mode
 *
-* RETURNS:
-*       GT_OK            - on success
-*       GT_FAIL          - on error
-*       GT_BAD_PARAM     - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+* OUTPUTS:
+*        None.
 *
-* COMMENTS: 
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* GalTis:
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetPolicy
+GT_STATUS gsysSetCtrMode
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT 	port,
-    IN  GT_POLICY_TYPE	type,
-	OUT GT_FRAME_POLICY	*policy
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       ctrMode
 );
 
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtSetPauseLimitOut
+* gsysGetCtrMode
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be transmitted
-*		from this port. When full duplex Flow Control is enabled on this port,
-*		these bits are used to limit the number of Pause refresh frames that can 
-*		be generated from this port to keep this port's link partner from sending
-*		any data.
-*		Setting this value to 0 will allow continuous Pause frame refreshes to 
-*		egress this port as long as this port remains congested.
-*		Setting this value to 1 will allow 1 Pause frame to egress from this port
-*		for each congestion situation.
-*		Setting this value to 2 will allow 2 Pause frames to egress from this port
-*		for each congestion situation, etc.
-*		
+*        Get Counter Modes. These bits control the operating modes of the two of 
+*        the Ports MIB counters.
+*        
 * INPUTS:
-*		port - the logical port number
-*		limit - the max number of Pause refresh frames for each congestion situation
-*				( 0 ~ 0xFF)
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        ctrMode - Counter mode
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetPauseLimitOut
+GT_STATUS gsysGetCtrMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		limit
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16       *ctrMode
 );
 
 /*******************************************************************************
-* gprtGetPauseLimitOut
+* gsysSetRsvd2CpuEnables2X
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be transmitted
-*		from this port. When full duplex Flow Control is enabled on this port,
-*		these bits are used to limit the number of Pause refresh frames that can 
-*		be generated from this port to keep this port's link partner from sending
-*		any data.
-*		Setting this value to 0 will allow continuous Pause frame refreshes to 
-*		egress this port as long as this port remains congested.
-*		Setting this value to 1 will allow 1 Pause frame to egress from this port
-*		for each congestion situation.
-*		Setting this value to 2 will allow 2 Pause frames to egress from this port
-*		for each congestion situation, etc.
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
+*        multicast DA addresses, whose bit in this register are also set to a one, 
+*        are treadted as MGMT frames. All the reserved DA's take the form 
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		port - the logical port number
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * OUTPUTS:
-*		limit - the max number of Pause refresh frames for each congestion situation
-*				( 0 ~ 0xFF)
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetPauseLimitOut
+GT_STATUS gsysSetRsvd2CpuEnables2X
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*limit
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
 );
 
 /*******************************************************************************
-* gprtSetPauseLimitIn
+* gsysGetRsvd2CpuEnables2X
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be received
-*		on this port. When a port has flow Control enabled, this value can be 
-*		used to limit how long this port can be Paused off to prevent a port stall
-*		through jamming.
-*		When this value is in the range of 0x01 to 0xFF, and a frame is ready to
-*		be transmitted out this port, but it cannot be transmitted due to the port
-*		being jammed, this limit mechanism starts. The limit mechanism starts 
-*		counting new Pause refresh frames or counts of 16 consecutive collisions.
-*		If the counter reaches the value set through this API, the following event
-*		will occur:
-*			1) Port's ForceFC is enabled,
-*			2) Port's FCValue is cleared to a zero, and
-*			3) Jam Limit Interrupt is asserted.
-*		This effectively disables Flow Control on the port once the Pause timer 
-*		expires. If a frame gets transmitted out this port before the counter
-*		reaches this limit, then this limit mechanism counter resets back to zero.
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
+*        multicast DA addresses, whose bit in this register are also set to a one, 
+*        are treadted as MGMT frames. All the reserved DA's take the form 
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
-*		Setting this value to 0 will allow continuous jamming to be received on 
-*		this port without the Port's ForceFC and FCValue getting modified.
-*
-*		The modification of Port's ForceFC and FCValue is the only indication that 
-*		the limit was reached on this port.
-*		
 * INPUTS:
-*		port - the logical port number
-*		limit - the max number of continuous Pause refresh frames for each trasmition
-*				( 0 ~ 0xFF)
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetPauseLimitIn
+GT_STATUS gsysGetRsvd2CpuEnables2X
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		limit
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
 );
 
 /*******************************************************************************
-* gprtGetPauseLimitIn
+* gsysSetFloodBC
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be received
-*		on this port. When a port has flow Control enabled, this value can be 
-*		used to limit how long this port can be Paused off to prevent a port stall
-*		through jamming.
-*		When this value is in the range of 0x01 to 0xFF, and a frame is ready to
-*		be transmitted out this port, but it cannot be transmitted due to the port
-*		being jammed, this limit mechanism starts. The limit mechanism starts 
-*		counting new Pause refresh frames or counts of 16 consecutive collisions.
-*		If the counter reaches the value set through this API, the following event
-*		will occur:
-*			1) Port's ForceFC is enabled,
-*			2) Port's FCValue is cleared to a zero, and
-*			3) Jam Limit Interrupt is asserted.
-*		This effectively disables Flow Control on the port once the Pause timer 
-*		expires. If a frame gets transmitted out this port before the counter
-*		reaches this limit, then this limit mechanism counter resets back to zero.
-*
-*		Setting this value to 0 will allow continuous jamming to be received on 
-*		this port without the Port's ForceFC and FCValue getting modified.
-*
-*		The modification of Port's ForceFC and FCValue is the only indication that 
-*		the limit was reached on this port.
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination 
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
+*        other switch policy still applies to these Broadcast frames. 
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's 
+*        Egress Floods mode.
 *
 * INPUTS:
-*		port - the logical port number
+*        en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		limit - the max number of continuous Pause refresh frames for each trasmition
-*				( 0 ~ 0xFF)
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetPauseLimitIn
+GT_STATUS gsysSetFloodBC
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*limit
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetFrameMode
+* gsysGetFloodBC
 *
 * DESCRIPTION:
-*		Frmae Mode is used to define the expected Ingress and the generated Egress
-*		tagging frame format for this port as follows:
-*			GT_FRAME_MODE_NORMAL -
-*				Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
-*				Untagged frames. Tagged frames use an Ether Type of 0x8100.
-*			GT_FRAME_MODE_DSA -
-*				DSA mode uses a Marvell defined tagged frame format for 
-*				Chip-to-Chip and Chip-to-CPU connections.
-*			GT_FRAME_MODE_PROVIDER -
-*				Provider mode uses user definable Ether Types per port 
-*				(see gprtSetPortEType/gprtGetPortEType API).
-*			GT_FRAME_MODE_ETHER_TYPE_DSA -
-*				Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
-*				flowing a user definable Ether Type. This mode allows the mixture
-*				of Normal Network frames with DSA Tagged frames and is useful to 
-*				be used on ports that connect to a CPU.
-*		
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination 
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
+*        other switch policy still applies to these Broadcast frames. 
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's 
+*        Egress Floods mode.
+*
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_FRAME_MODE type
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is unknown
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetFrameMode
+GT_STATUS gsysGetFloodBC
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_FRAME_MODE	mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetFrameMode
+* gsysSetRemove1PTag
 *
 * DESCRIPTION:
-*		Frmae Mode is used to define the expected Ingress and the generated Egress
-*		tagging frame format for this port as follows:
-*			GT_FRAME_MODE_NORMAL -
-*				Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
-*				Untagged frames. Tagged frames use an Ether Type of 0x8100.
-*			GT_FRAME_MODE_DSA -
-*				DSA mode uses a Marvell defined tagged frame format for 
-*				Chip-to-Chip and Chip-to-CPU connections.
-*			GT_FRAME_MODE_PROVIDER -
-*				Provider mode uses user definable Ether Types per port 
-*				(see gprtSetPortEType/gprtGetPortEType API).
-*			GT_FRAME_MODE_ETHER_TYPE_DSA -
-*				Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
-*				flowing a user definable Ether Type. This mode allows the mixture
-*				of Normal Network frames with DSA Tagged frames and is useful to 
-*				be used on ports that connect to a CPU.
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
+*        performed. Only the first Provider Tag found on the frame will be 
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive 
+*        Provider Tag stripping will be performed. The first Provider Tag's data 
+*        will be extracted and used for switching, and then all subsequent Provider 
+*        Tags found in the frame will also be removed. This will only occur if the 
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
 *
 * INPUTS:
-*		port - the logical port number
+*        en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode - GT_FRAME_MODE type
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetFrameMode
+GT_STATUS gsysSetRemove1PTag
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_FRAME_MODE	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetHoldAt1
+* gsysGetRemove1PTag
 *
 * DESCRIPTION:
-*		Hold Aging ATU Entries at an Entry State value of 1. When this feature
-*		is set to GT_TRUE, ATU entries associated with this port will age down 
-*		to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
-*		entry)
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
+*        performed. Only the first Provider Tag found on the frame will be 
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive 
+*        Provider Tag stripping will be performed. The first Provider Tag's data 
+*        will be extracted and used for switching, and then all subsequent Provider 
+*        Tags found in the frame will also be removed. This will only occur if the 
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
-*			   GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetHoldAt1
+GT_STATUS gsysGetRemove1PTag
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gprtGetHoldAt1
+* gsysSetTagFlowControl
 *
 * DESCRIPTION:
-*		Hold Aging ATU Entries at an Entry State value of 1. When this feature
-*		is set to GT_TRUE, ATU entries associated with this port will age down 
-*		to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
-*		entry)
+*        Use and generate source port Flow Control status for Cross-Chip Flow 
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
+*        defined to be Src_FC and it is added to these frames when generated and 
+*        it is inspected on these frames when received. The QC will use the Src_FC 
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
+*        be Reserved and it will be zero on these frames when generated and it 
+*        will not be used on these frames when received (this is a backwards 
+*        compatibility mode).
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
-*			   GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetHoldAt1
+GT_STATUS gsysSetTagFlowControl
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetRefreshLocked
+* gsysGetTagFlowControl
 *
 * DESCRIPTION:
-*		Auto Refresh known addresses when port is Locked. Already known addresses 
-*		will be auto refreshed when this feature is enabled. When this feature
-*		is disabled, auto refreshing will not occur on Locked ports.
+*        Use and generate source port Flow Control status for Cross-Chip Flow 
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
+*        defined to be Src_FC and it is added to these frames when generated and 
+*        it is inspected on these frames when received. The QC will use the Src_FC 
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
+*        be Reserved and it will be zero on these frames when generated and it 
+*        will not be used on these frames when received (this is a backwards 
+*        compatibility mode).
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to enable Auto Refresh known addresses on locked port
-*			   GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetRefreshLocked
+GT_STATUS gsysGetTagFlowControl
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetRefreshLocked
+* gsysSetAlwaysUseVTU
 *
 * DESCRIPTION:
-*		Auto Refresh known addresses when port is Locked. Already known addresses 
-*		will be auto refreshed when this feature is enabled. When this feature
-*		is disabled, auto refreshing will not occur on Locked ports.
+*        Always use VTU. 
+*        When this feature is enabled, VTU hit data will be used to map frames 
+*        even if 802.1Q is Disabled on the port. 
+*        When it's disabled, data will be ignored when mapping frames on ports 
+*        where 802.1Q is Disabled.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE to use VTU always, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable Auto Refresh known addresses on locked port
-*			   GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetRefreshLocked
+GT_STATUS gsysSetAlwaysUseVTU
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
 /*******************************************************************************
-* gprtSetPortEType
+* gsysGetAlwaysUseVTU
 *
 * DESCRIPTION:
-*		This routine sets the port's special Ether Type. This Ether Type is used
-*		for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*        Always use VTU. 
+*        When this feature is enabled, VTU hit data will be used to map frames 
+*        even if 802.1Q is Disabled on the port. 
+*        When it's disabled, data will be ignored when mapping frames on ports 
+*        where 802.1Q is Disabled.
 *
 * INPUTS:
-*		port  - the logical port number
-*		etype - port's special ether type
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtSetPortEType
+GT_STATUS gsysGetAlwaysUseVTU
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_ETYPE		etype
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetPortEType
+* gsysSetQVlansOnly
 *
 * DESCRIPTION:
-*		This routine retrieves the port's special Ether Type. This Ether Type is used
-*		for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is 
+*        limited by the frame's VID (using the MemberTag data found in the VTU) 
+*        together with the port based VLANs (using the source port's PortVLANTable, 
+*        gvlnSetPortVlanPorts API). The two methods are always used together in 
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
 *
 * INPUTS:
-*		port  - the logical port number
+*        en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		etype - port's special ether type
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetPortEType
+GT_STATUS gsysSetQVlansOnly
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_ETYPE	*etype
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
-
-/* gtPortRateCtr.c */
-
 /*******************************************************************************
-* grcSetFrameOverhead
+* gsysGetQVlansOnly
 *
 * DESCRIPTION:
-*       Egress rate frame overhead adjustment.
-*		This field is used to adjust the number of bytes that need to be added to a
-*		frame's IFG on a per frame basis.
-*
-*		The egress rate limiter multiplies the value programmed in this field by four
-*		for computing the frame byte offset adjustment value (i.e., the amount the
-*		IPG is increased for every frame). This adjustment, if enabled, is made to
-*		every egressing frame's IPG and it is made in addition to any other IPG
-*		adjustments due to other Egress Rate Control settings.
-*
-*		The egress overhead adjustment can add the following number of byte times
-*		to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
-*		56 and 60.
-*
-*		Example:
-*		If FrameOverhead = 11, the egress rate limiter would increase the IPG
-*		between every frame by an additional 44 bytes.
-*
-*		Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
-*		shaping mode, these Frame Overhead bits must be 0x0.
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is 
+*        limited by the frame's VID (using the MemberTag data found in the VTU) 
+*        together with the port based VLANs (using the source port's PortVLANTable, 
+*        gvlnSetPortVlanPorts API). The two methods are always used together in 
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
 *
 * INPUTS:
-*       port	 - logical port number.
-*       overhead - Frame overhead (0 ~ 15)
+*        None.
 *
 * OUTPUTS:
-*       None.
+*        en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK               - on success
-*       GT_FAIL             - on error
-*       GT_BAD_PARAM        - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS grcSetFrameOverhead
+GT_STATUS gsysGetQVlansOnly
 (
-    IN GT_QD_DEV		*dev,
-    IN GT_LPORT			port,
-    IN GT_32			overhead
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* grcGetFrameOverhead
+* gsysSet5BitPort
 *
 * DESCRIPTION:
-*       Egress rate frame overhead adjustment.
-*		This field is used to adjust the number of bytes that need to be added to a
-*		frame's IFG on a per frame basis.
-*
-*		The egress rate limiter multiplies the value programmed in this field by four
-*		for computing the frame byte offset adjustment value (i.e., the amount the
-*		IPG is increased for every frame). This adjustment, if enabled, is made to
-*		every egressing frame's IPG and it is made in addition to any other IPG
-*		adjustments due to other Egress Rate Control settings.
-*
-*		The egress overhead adjustment can add the following number of byte times
-*		to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
-*		56 and 60.
-*
-*		Example:
-*		If FrameOverhead = 11, the egress rate limiter would increase the IPG
-*		between every frame by an additional 44 bytes.
-*
-*		Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
-*		shaping mode, these Frame Overhead bits must be 0x0.
+*        Use 5 bits for Port data in the Port VLAN Table (PVT). 
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
 *
 * INPUTS:
-*       port	- logical port number.
+*        en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*       overhead - Frame overhead (0 ~ 15)
+*        None.
 *
 * RETURNS:
-*       GT_OK            - on success
-*       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS grcGetFrameOverhead
+GT_STATUS gsysSet5BitPort
 (
-    IN GT_QD_DEV *dev,
-    IN  GT_LPORT port,
-    OUT GT_32    *overhead
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
-
-/* gtPortStatus.c */
-
 /*******************************************************************************
-* gprtGetBufHigh
+* gsysGet5BitPort
 *
 * DESCRIPTION:
-*		Output from QC telling the MAC that it should perform Flow Control.
+*        Use 5 bits for Port data in the Port VLAN Table (PVT). 
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
 *
 * INPUTS:
-*		port - the logical port number
+*        None.
 *
 * OUTPUTS:
-*		bufHigh - GT_TRUE, if Flow control required
-*				  GT_FALSE, otherwise
+*        en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetBufHigh
+GT_STATUS gsysGet5BitPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*bufHigh
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
 /*******************************************************************************
-* gprtGetFcEn
+* gsysSetSDETPolarity
 *
 * DESCRIPTION:
-*		Input into the QC telling it that Flow Control is enabled on this port.
+*        SDET (Signal Detect) Polarity select bits for each port. 
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
+*        determine link on fiber ports. This bit affects the active level of a 
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is 
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is 
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other 
+*        port modes the SDET pins are ignored and these bits have no effect.
 *
 * INPUTS:
-*		port - the logical port number
+*        sdetVec - SDET Polarity for each port in Vector format
 *
 * OUTPUTS:
-*		fcEn - GT_TRUE, if Flow control is enabled
-*			   GT_FALSE, otherwise
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sdetVec is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetFcEn
+GT_STATUS gsysSetSDETPolarity
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*fcEn
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          sdetVec
 );
 
 /*******************************************************************************
-* gprtGetRsvSize
+* gsysSetSDETPolarity
 *
 * DESCRIPTION:
-*		This routine gets Ingress reserved queue size counter.
-*		This counter reflects the current number of reserved ingress buffers 
-*		assigned to this port.
+*        SDET (Signal Detect) Polarity select bits for each port. 
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
+*        determine link on fiber ports. This bit affects the active level of a 
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is 
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is 
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other 
+*        port modes the SDET pins are ignored and these bits have no effect.
 *
 * INPUTS:
-*		port - the logical port number
+*        None.
 *
 * OUTPUTS:
-*		count - reserved ingress queue size counter value
+*        sdetVec - SDET Polarity for each port in Vector format
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gprtGetRsvSize
+GT_STATUS gsysGetSDETPolarity
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*count
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *sdetVec
 );
 
 
-/* gtPriTable.c */
+/* gtBrgVlan.c for 2.6 release */
 
 /*******************************************************************************
-* gsysSetQPriOverrideTable
+* gvlnSetNoEgrPolicy
 *
 * DESCRIPTION:
-*       Queue Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled 
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress 
+*        even if the VID assigned to the frame is not found in the VTU.
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
-*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*        mode - no egress policy mode
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetQPriOverrideTable
+GT_STATUS gvlnSetNoEgrPolicy
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_PRI_OVERRIDE_FTYPE	fType,
-    IN  GT_QPRI_TBL_ENTRY	*entry
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 );
 
+
 /*******************************************************************************
-* gsysGetQPriOverrideTable
+* gvlnGetNoEgrPolicy
 *
 * DESCRIPTION:
-*       Queue Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled 
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress 
+*        even if the VID assigned to the frame is not found in the VTU.
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*        None.
 *
 * OUTPUTS:
-*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*        mode - no egress policy mode
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetQPriOverrideTable
+GT_STATUS gvlnGetNoEgrPolicy
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_PRI_OVERRIDE_FTYPE	fType,
-    OUT GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *mode
 );
 
-
-/* gtSysCtrl.c */
-
 /*******************************************************************************
-* gsysSetCPUDest
+* gwdSetRMUTimeOut
 *
 * DESCRIPTION:
-*		This routine sets CPU Destination Port. CPU Destination port indicates the
-*		port number on this device where the CPU is connected (either directly or
-*		indirectly through another Marvell switch device).
-*
-*		Many modes of frame processing need to know where the CPU is located.
-*		These modes are:
-*		1. When IGMP/MLD frame is received and Snooping is enabled
-*		2. When the port is configured as a DSA port and it receives a To_CPU frame
-*		3. When a Rsvd2CPU frame enters the port
-*		4. When the port's SA Filtering mode is Drop to CPU
-*		5. When any of the port's Policy Options trap the frame to the CPU
-*		6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
-*		   device
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
 *
-*		In all cases, except for ARP, the frames that meet the enabled criteria 
-*		are mapped to the CPU Destination port, overriding where the frame would 
-*		normally go. In the case of ARP, the frame will be mapped normally and it 
-*		will also get copied to this port.
-*		Frames that filtered or discarded will not be mapped to the CPU Destination 
-*		port with the exception of the Rsvd2CPU and DSA Tag cases.
-*
-*		If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
-*		will occur and ingressing To_CPU frames will be discarded.
+*        When this bit is cleared to a zero the Wait on Bit command will wait 
+*        until the bit that is being tested has changed to the specified value.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetCPUDest
+GT_STATUS gwdSetRMUTimeOut
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysGetCPUDest
+* gwdGetRMUTimeOut
 *
 * DESCRIPTION:
-*		This routine gets CPU Destination Port. CPU Destination port indicates the
-*		port number on this device where the CPU is connected (either directly or
-*		indirectly through another Marvell switch device).
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
 *
-*		Many modes of frame processing need to know where the CPU is located.
-*		These modes are:
-*		1. When IGMP/MLD frame is received and Snooping is enabled
-*		2. When the port is configured as a DSA port and it receives a To_CPU frame
-*		3. When a Rsvd2CPU frame enters the port
-*		4. When the port's SA Filtering mode is Drop to CPU
-*		5. When any of the port's Policy Options trap the frame to the CPU
-*		6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
-*		   device
-*
-*		In all cases, except for ARP, the frames that meet the enabled criteria 
-*		are mapped to the CPU Destination port, overriding where the frame would 
-*		normally go. In the case of ARP, the frame will be mapped normally and it 
-*		will also get copied to this port.
-*		Frames that filtered or discarded will not be mapped to the CPU Destination 
-*		port with the exception of the Rsvd2CPU and DSA Tag cases.
-*
-*		If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
-*		will occur and ingressing To_CPU frames will be discarded.
+*        When this bit is cleared to a zero the Wait on Bit command will wait 
+*        until the bit that is being tested has changed to the specified value.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysGetCPUDest
+GT_STATUS gwdGetRMUTimeOut
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gsysSetMirrorDest
+* gwdGetEgressWDEvent
 *
 * DESCRIPTION:
-*		This routine sets Mirror Destination Port. Frames that ingress a port 
-*		that trigger a policy mirror are mapped (copied) to this port as long as 
-*		the frame is not filtered or discarded. 
-*		The Mirror Destination port should point to the port that directs these 
-*		frames to the CPU that will process these frames. This target port should 
-*		be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
-*		CPU Code of Policy Mirror.
-*		To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
-*		Tag port will be sent to the port number defined in MirrorDest.
-*
-*		If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
-*		Policy Mirror frames will be discarded.
-*
+*        If any port's egress logic detects an egress watch dog issue, this bit
+*        will be set to a one, regardless of the setting of the GT_WD_EGRESS in
+*        gwdSetEvent function.
+*        
 * INPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        event - GT_TRUE, if egress logic has detected any egress watch dog issue
+*                GT_FALUSE, otherwise
+*
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*		None.
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gsysSetMirrorDest
+GT_STATUS gwdGetEgressWDEvent
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV        *dev,
+    OUT GT_BOOL            *event
 );
 
+
 /*******************************************************************************
-* gsysGetMirrorDest
+* gsysSetQoSWeight
 *
 * DESCRIPTION:
-*		This routine gets Mirror Destination Port. Frames that ingress a port 
-*		that trigger a policy mirror are mapped (copied) to this port as long as 
-*		the frame is not filtered or discarded. 
-*		The Mirror Destination port should point to the port that directs these 
-*		frames to the CPU that will process these frames. This target port should 
-*		be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
-*		CPU Code of Policy Mirror.
-*		To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
-*		Tag port will be sent to the port number defined in MirrorDest.
-*
-*		If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
-*		Policy Mirror frames will be discarded.
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and 
+*        Queue 0 has the lowest priority. When a scheduling mode of port is 
+*        configured as Weighted Round Robin queuing mode, the access sequece of the 
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This sequence can be configured with this API.
 *
 * INPUTS:
-*		None.
+*       weight - access sequence of the queue
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetMirrorDest
+GT_STATUS gsysSetQoSWeight
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV         *dev,
+    IN  GT_QoS_WEIGHT    *weight
 );
 
 /*******************************************************************************
-* gsysSetRMPort
+* gsysGetQoSWeight
 *
 * DESCRIPTION:
-*		Remote Management feature is enabled only on one port. Since not all ports
-*		can be enabled for Remote Management feature, please refer to the device
-*		datasheet for detailed information.
-*		For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
-*		device allows logical port 4 and 5.
-*		
+*       Programmable Round Robin Weights.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and 
+*        Queue 0 has the lowest priority. When a scheduling mode of port is 
+*        configured as Weighted Round Robin queuing mode, the access sequece of the 
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This routine retrieves the access sequence of the Queue.
+*
 * INPUTS:
-*		port - Remote Management Port
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       weight - access sequence of the queue
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM     - on unallowable port
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMPort
+GT_STATUS gsysGetQoSWeight
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port
+    IN  GT_QD_DEV         *dev,
+    OUT GT_QoS_WEIGHT    *weight
 );
 
+
+/*
+ *    gtPortCtrl.c
+*/
+
 /*******************************************************************************
-* gsysGetRMPort
+* gsysSetJumboMode
 *
 * DESCRIPTION:
-*		Remote Management feature is enabled only on one port. Since not all ports
-*		can be enabled for Remote Management feature, please refer to the device
-*		datasheet for detailed information.
-*		For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
-*		device allows logical port 4 and 5.
+*       This routine Set the max frame size allowed to be received and transmitted
+*        from or to a given port.
 *
 * INPUTS:
-*		None.
+*        port - the logical port number
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
 *
 * OUTPUTS:
-*		port - Remote Management Port
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMPort
+GT_STATUS gsysSetJumboMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
 );
 
 /*******************************************************************************
-* gsysSetRMDACheck
+* gsysGetJumboMode
 *
 * DESCRIPTION:
-*		Check the DA on Remote Management frames. 
-*		When DA Check is enabled, the DA of Remote Management frames must be 
-*		contained in this device's address database (ATU) as a Static entry 
-*		(either unicast or multicast). If the DA of the frame is not contained 
-*		in this device's address database, the frame will be not be processed as 
-*		a Frame-to-Regter frame.
-*		When DA Check is disabled, the DA of Remote Management frames is not 
-*		validated before processing the frame.
-*		
+*       This routine gets the max frame size allowed to be received and transmitted
+*        from or to a given port.
+*
 * INPUTS:
-*		en - GT_TRUE to enable DA Check, 
-*			 GT_FALSE otherwise.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMDACheck
+GT_STATUS gsysGetJumboMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_JUMBO_MODE   *mode
 );
 
+/*
+ *  gtPhyCtrl.c
+*/
 /*******************************************************************************
-* gsysGetRMDACheck
+* gprtGetEnergyDetect
 *
 * DESCRIPTION:
-*		Check the DA on Remote Management frames. 
-*		When DA Check is enabled, the DA of Remote Management frames must be 
-*		contained in this device's address database (ATU) as a Static entry 
-*		(either unicast or multicast). If the DA of the frame is not contained 
-*		in this device's address database, the frame will be not be processed as 
-*		a Frame-to-Regter frame.
-*		When DA Check is disabled, the DA of Remote Management frames is not 
-*		validated before processing the frame.
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable. 
 *
 * INPUTS:
-*		None.
+*         port - The logical port number
 *
 * OUTPUTS:
-*		en - GT_TRUE if DA Check is enabled, 
-*			 GT_FALSE otherwise.
+*       mode - GT_EDETECT_MODE type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMDACheck
+GT_STATUS gprtGetEnergyDetect
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL 	*en
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
 );
 
 /*******************************************************************************
-* gsysSetRMEnable
+* gprtSetEnergyDetect
 *
 * DESCRIPTION:
-*		Enable or disable Remote Management feature. This feature can be enabled
-*		only on one port (see gsysSetRMPort API).
-*		
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable. 
+*
 * INPUTS:
-*		en - GT_TRUE to enable Remote Management feature, 
-*			 GT_FALSE otherwise.
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMEnable
+
+GT_STATUS gprtSetEnergyDetect
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
 );
 
+
+/*
+ *    gtSysCtrl.c
+*/
+
 /*******************************************************************************
-* gsysGetRMEnable
+* gsysSetRMUMode
 *
 * DESCRIPTION:
-*		Enable or disable Remote Management feature. This feature can be enabled
-*		only on one port (see gsysSetRMPort API).
-*
+*        Set Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote 
+*        Management Response frame will be generated and sent out.
+*        
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*        
 * INPUTS:
-*		None.
+*        rmu - GT_RMU structure
 *
 * OUTPUTS:
-*		en - GT_TRUE if Remote Management feature is enabled, 
-*			 GT_FALSE otherwise.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMEnable
+GT_STATUS gsysSetRMUMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL 	*en
+    IN GT_QD_DEV    *dev,
+    IN GT_RMU        *rmu
 );
 
 /*******************************************************************************
-* gsysSetRsvd2CpuEnables2X
+* gsysGetRMUMode
 *
 * DESCRIPTION:
-*		Reserved DA Enables for the form of 01:80:C2:00:00:2x.
-*		When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
-*		multicast DA addresses, whose bit in this register are also set to a one, 
-*		are treadted as MGMT frames. All the reserved DA's take the form 
-*		01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
-*		When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
-*
+*        Get Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote 
+*        Management Response frame will be generated and sent out.
+*        
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*        
 * INPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        rmu - GT_RMU structure
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRsvd2CpuEnables2X
+GT_STATUS gsysGetRMUMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		enBits
+    IN  GT_QD_DEV    *dev,
+    OUT GT_RMU        *rmu
 );
 
 /*******************************************************************************
-* gsysGetRsvd2CpuEnables2X
+* gsysPort2Lport
 *
 * DESCRIPTION:
-*		Reserved DA Enables for the form of 01:80:C2:00:00:2x.
-*		When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
-*		multicast DA addresses, whose bit in this register are also set to a one, 
-*		are treadted as MGMT frames. All the reserved DA's take the form 
-*		01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
-*		When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*        This routine converts physical port number to logical port number.
 *
 * INPUTS:
-*		None.
+*        port - physical port number
 *
 * OUTPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        lport - logical port number
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRsvd2CpuEnables2X
+GT_STATUS gsysPort2Lport
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*enBits
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         port,
+    OUT GT_LPORT    *lport
 );
 
 /*******************************************************************************
-* gsysSetFloodBC
+* gsysLport2Port
 *
 * DESCRIPTION:
-*		Flood Broadcast.
-*		When Flood Broadcast is enabled, frames with the Broadcast destination 
-*		address will flood out all the ports regardless of the setting of the
-*		port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
-*		other switch policy still applies to these Broadcast frames. 
-*		When this feature is disabled, frames with the Broadcast destination
-*		address are considered Multicast frames and will be affected by port's 
-*		Egress Floods mode.
+*        This routine converts logical port number to physical port number.
 *
 * INPUTS:
-*		en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
+*        lport - logical port number
 *
 * OUTPUTS:
-*		None.
+*        port - physical port number
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetFloodBC
+GT_STATUS gsysLport2Port
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    lport,
+    OUT GT_U32         *port
 );
 
 /*******************************************************************************
-* gsysGetFloodBC
+* gsysPortvec2Lportvec
 *
 * DESCRIPTION:
-*		Flood Broadcast.
-*		When Flood Broadcast is enabled, frames with the Broadcast destination 
-*		address will flood out all the ports regardless of the setting of the
-*		port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
-*		other switch policy still applies to these Broadcast frames. 
-*		When this feature is disabled, frames with the Broadcast destination
-*		address are considered Multicast frames and will be affected by port's 
-*		Egress Floods mode.
+*        This routine converts physical port vector to logical port vector.
 *
 * INPUTS:
-*		None.
+*        portvec - physical port vector
 *
 * OUTPUTS:
-*		en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
+*        lportvec - logical port vector
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetFloodBC
+GT_STATUS gsysPortvec2Lportvec
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        portvec,
+    OUT GT_U32         *lportvec
 );
 
 /*******************************************************************************
-* gsysSetRemove1PTag
+* gsysLportvec2Portvec
 *
 * DESCRIPTION:
-*		Remove One Provider Tag.
-*		When this feature is enabled and a port is configured as a Provider Port
-*		(see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
-*		performed. Only the first Provider Tag found on the frame will be 
-*		extracted and removed. Its extracted data will be used for switching.
-*		When it's disabled and a port is configured as a Provider Port, recursive 
-*		Provider Tag stripping will be performed. The first Provider Tag's data 
-*		will be extracted and used for switching, and then all subsequent Provider 
-*		Tags found in the frame will also be removed. This will only occur if the 
-*		port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*        This routine converts logical port vector to physical port vector.
 *
 * INPUTS:
-*		en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
+*        lportvec - logical port vector
 *
 * OUTPUTS:
-*		None.
+*        portvec - physical port vector
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRemove1PTag
+GT_STATUS gsysLportvec2Portvec
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        lportvec,
+    OUT GT_U32         *portvec
 );
 
+
+/*
+ * gtPIRL.c
+ */
+
 /*******************************************************************************
-* gsysGetRemove1PTag
+* gpirlSetCurTimeUpInt
 *
 * DESCRIPTION:
-*		Remove One Provider Tag.
-*		When this feature is enabled and a port is configured as a Provider Port
-*		(see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
-*		performed. Only the first Provider Tag found on the frame will be 
-*		extracted and removed. Its extracted data will be used for switching.
-*		When it's disabled and a port is configured as a Provider Port, recursive 
-*		Provider Tag stripping will be performed. The first Provider Tag's data 
-*		will be extracted and used for switching, and then all subsequent Provider 
-*		Tags found in the frame will also be removed. This will only occur if the 
-*		port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
 *
 * INPUTS:
-*		None.
+*       upInt - updata interval (0 ~ 7)
 *
 * OUTPUTS:
-*		en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRemove1PTag
+GT_STATUS gpirlSetCurTimeUpInt
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
 );
 
+
+/*
+ * gtPIRL2.c
+ */
+
 /*******************************************************************************
-* gsysSetTagFlowControl
+* gpirl2SetCurTimeUpInt
 *
 * DESCRIPTION:
-*		Use and generate source port Flow Control status for Cross-Chip Flow 
-*		Control.
-*		When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
-*		defined to be Src_FC and it is added to these frames when generated and 
-*		it is inspected on these frames when received. The QC will use the Src_FC 
-*		bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
-*		QC Flow Control algorithm.
-*		When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
-*		be Reserved and it will be zero on these frames when generated and it 
-*		will not be used on these frames when received (this is a backwards 
-*		compatibility mode).
+*       This function sets the current time update interval.
+*        Please contact FAE for detailed information.
 *
 * INPUTS:
-*		en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
+*       upInt - updata interval (0 ~ 7)
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetTagFlowControl
+GT_STATUS gpirl2SetCurTimeUpInt
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
 );
 
+
+/*
+ * gtPTP.c
+ */
+
 /*******************************************************************************
-* gsysGetTagFlowControl
+* gptpSetConfig
 *
 * DESCRIPTION:
-*		Use and generate source port Flow Control status for Cross-Chip Flow 
-*		Control.
-*		When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
-*		defined to be Src_FC and it is added to these frames when generated and 
-*		it is inspected on these frames when received. The QC will use the Src_FC 
-*		bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
-*		QC Flow Control algorithm.
-*		When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
-*		be Reserved and it will be zero on these frames when generated and it 
-*		will not be used on these frames when received (this is a backwards 
-*		compatibility mode).
+*       This routine writes PTP configuration parameters.
 *
 * INPUTS:
-*		None.
+*        ptpData  - PTP configuration parameters.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetTagFlowControl
+GT_STATUS gptpSetConfig
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysSetAlwaysUseVTU
+* gptpGetConfig
 *
 * DESCRIPTION:
-*		Always use VTU. 
-*		When this feature is enabled, VTU hit data will be used to map frames 
-*		even if 802.1Q is Disabled on the port. 
-*		When it's disabled, data will be ignored when mapping frames on ports 
-*		where 802.1Q is Disabled.
+*       This routine reads PTP configuration parameters.
 *
 * INPUTS:
-*		en - GT_TRUE to use VTU always, GT_FALSE otherwise.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        ptpData  - PTP configuration parameters.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetAlwaysUseVTU
+GT_STATUS gptpGetConfig
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysGetAlwaysUseVTU
+* gptpSetGlobalConfig
 *
 * DESCRIPTION:
-*		Always use VTU. 
-*		When this feature is enabled, VTU hit data will be used to map frames 
-*		even if 802.1Q is Disabled on the port. 
-*		When it's disabled, data will be ignored when mapping frames on ports 
-*		where 802.1Q is Disabled.
+*       This routine writes PTP global configuration parameters.
 *
 * INPUTS:
-*		None.
+*        ptpData  - PTP global configuration parameters.
 *
 * OUTPUTS:
-*		en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetAlwaysUseVTU
+GT_STATUS gptpSetGlobalConfig
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysSetQVlansOnly
+* gptpGetGlobalConfig
 *
 * DESCRIPTION:
-*		802.1Q VLANs Only.
-*		When this feature is disabled, the egress mapping of the frame is 
-*		limited by the frame's VID (using the MemberTag data found in the VTU) 
-*		together with the port based VLANs (using the source port's PortVLANTable, 
-*		gvlnSetPortVlanPorts API). The two methods are always used together in 
-*		this mode.
-*		When this feature is enabled, the egress mapping of the frame is limitied
-*		by the frame's VID only, if the VID was found in the VTU. If the frame's
-*		VID was not found in the VTU the egress mapping of the frame is limited
-*		by the source port's PortVLANTable only. The two methods are never
-*		used together in this mode.
+*       This routine reads PTP global configuration parameters.
 *
 * INPUTS:
-*		en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        ptpData  - PTP global configuration parameters.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetQVlansOnly
+GT_STATUS gptpGetGlobalConfig
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysGetQVlansOnly
+* gptpSetPortConfig
 *
 * DESCRIPTION:
-*		802.1Q VLANs Only.
-*		When this feature is disabled, the egress mapping of the frame is 
-*		limited by the frame's VID (using the MemberTag data found in the VTU) 
-*		together with the port based VLANs (using the source port's PortVLANTable, 
-*		gvlnSetPortVlanPorts API). The two methods are always used together in 
-*		this mode.
-*		When this feature is enabled, the egress mapping of the frame is limitied
-*		by the frame's VID only, if the VID was found in the VTU. If the frame's
-*		VID was not found in the VTU the egress mapping of the frame is limited
-*		by the source port's PortVLANTable only. The two methods are never
-*		used together in this mode.
+*       This routine writes PTP port configuration parameters.
 *
 * INPUTS:
-*		None.
+*        ptpData  - PTP port configuration parameters.
 *
 * OUTPUTS:
-*		en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetQVlansOnly
+GT_STATUS gptpSetPortConfig
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysSet5BitPort
+* gptpGetPortConfig
 *
 * DESCRIPTION:
-*		Use 5 bits for Port data in the Port VLAN Table (PVT). 
-*		When this feature is enabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:5] = Source Device[3:0] or Device Number[3:0]
-*			Addr[4:0] = Source Port/Trunk[4:0]
-*		When it's disabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:4] = Source Device[4:0] or Device Number[4:0]
-*			Addr[3:0] = Source Port/Trunk[3:0]
+*       This routine reads PTP configuration parameters for a port.
 *
 * INPUTS:
-*		en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        ptpData  - PTP port configuration parameters.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSet5BitPort
+GT_STATUS gptpGetPortConfig
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
 );
 
 /*******************************************************************************
-* gsysGet5BitPort
+* gptpSetPTPEn
 *
 * DESCRIPTION:
-*		Use 5 bits for Port data in the Port VLAN Table (PVT). 
-*		When this feature is enabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:5] = Source Device[3:0] or Device Number[3:0]
-*			Addr[4:0] = Source Port/Trunk[4:0]
-*		When it's disabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:4] = Source Device[4:0] or Device Number[4:0]
-*			Addr[3:0] = Source Port/Trunk[3:0]
+*       This routine enables or disables PTP.
 *
 * INPUTS:
-*		None.
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
 *
 * OUTPUTS:
-*		en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGet5BitPort
+GT_STATUS gptpSetPTPEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 );
 
 /*******************************************************************************
-* gsysSetSDETPolarity
+* gptpGetPTPEn
 *
 * DESCRIPTION:
-*		SDET (Signal Detect) Polarity select bits for each port. 
-*		Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
-*		determine link on fiber ports. This bit affects the active level of a 
-*		port's SDET pins as follows:
-*			0 = SDET is active low. A low level on the port's SDET pin is 
-*				required for link to occur.
-*			1 = SDET is active high. A high level on the ports SDET pin is 
-*				required for link to occur.
-*		SDET is used when the port is configured as a fiber port. In all other 
-*		port modes the SDET pins are ignored and these bits have no effect.
+*       This routine checks if PTP is enabled.
 *
 * INPUTS:
-*		sdetVec - SDET Polarity for each port in Vector format
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sdetVec is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetSDETPolarity
+GT_STATUS gptpGetPTPEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		sdetVec
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gsysSetSDETPolarity
+* gptpSetPortPTPEn
 *
 * DESCRIPTION:
-*		SDET (Signal Detect) Polarity select bits for each port. 
-*		Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
-*		determine link on fiber ports. This bit affects the active level of a 
-*		port's SDET pins as follows:
-*			0 = SDET is active low. A low level on the port's SDET pin is 
-*				required for link to occur.
-*			1 = SDET is active high. A high level on the ports SDET pin is 
-*				required for link to occur.
-*		SDET is used when the port is configured as a fiber port. In all other 
-*		port modes the SDET pins are ignored and these bits have no effect.
+*       This routine enables or disables PTP on a port.
 *
 * INPUTS:
-*		None.
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
 *
 * OUTPUTS:
-*		sdetVec - SDET Polarity for each port in Vector format
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetSDETPolarity
+GT_STATUS gptpSetPortPTPEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U32  	*sdetVec
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 );
 
-
-/* gtBrgVlan.c for 2.6 release */
-
 /*******************************************************************************
-* gvlnSetNoEgrPolicy
+* gptpGetPortPTPEn
 *
 * DESCRIPTION:
-*		No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
-*		Check discards are not performed. This mode allowsa non-802.1Q enabled 
-*		port to send a frame to an 802.1Q enabled port that is configured in the
-*		Secure or Check 802.1Q mode. In this situation the frames will egress 
-*		even if the VID assigned to the frame is not found in the VTU.
+*       This routine checks if PTP is enabled on a port.
 *
 * INPUTS:
-*		mode - no egress policy mode
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gvlnSetNoEgrPolicy
+GT_STATUS gptpGetPortPTPEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 );
 
 
 /*******************************************************************************
-* gvlnGetNoEgrPolicy
+* gptpGetPTPInt
 *
 * DESCRIPTION:
-*		No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
-*		Check discards are not performed. This mode allowsa non-802.1Q enabled 
-*		port to send a frame to an 802.1Q enabled port that is configured in the
-*		Secure or Check 802.1Q mode. In this situation the frames will egress 
-*		even if the VID assigned to the frame is not found in the VTU.
+*       This routine gets PTP interrupt status for each port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP 
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
 *
 * INPUTS:
-*		None.
+*       None.
 *
 * OUTPUTS:
-*		mode - no egress policy mode
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gvlnGetNoEgrPolicy
+GT_STATUS gptpGetPTPInt
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
 );
 
 /*******************************************************************************
-* gwdSetRMUTimeOut
+* gptpGetPTPGlobalTime
 *
 * DESCRIPTION:
-*		Remote Management Timeout. When this bit is set to a one the Remote
-*		Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
-*		is being tested has not gone to the specified value after 1 sec. has elapsed
-*		the Wait on Bit command will be terminated and the Response frame will be
-*		sent without any further processing.
-*
-*		When this bit is cleared to a zero the Wait on Bit command will wait 
-*		until the bit that is being tested has changed to the specified value.
+*       This routine gets the global timer value that is running off of the free
+*        running switch core clock.
 *
 * INPUTS:
-*		en   - GT_TRUE to enable RMU Timeout
-*			   GT_FALUSE to disable
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        ptpTime    - PTP global time
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gwdSetRMUTimeOut
+GT_STATUS gptpGetPTPGlobalTime
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL	    en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpTime
 );
 
 /*******************************************************************************
-* gwdGetRMUTimeOut
+* gptpGetTimeStamped
 *
 * DESCRIPTION:
-*		Remote Management Timeout. When this bit is set to a one the Remote
-*		Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
-*		is being tested has not gone to the specified value after 1 sec. has elapsed
-*		the Wait on Bit command will be terminated and the Response frame will be
-*		sent without any further processing.
-*
-*		When this bit is cleared to a zero the Wait on Bit command will wait 
-*		until the bit that is being tested has changed to the specified value.
+*        This routine retrieves the PTP port status that includes time stamp value 
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs 
+*        to be time stamped.
 *
 * INPUTS:
-*		None.
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
 *
 * OUTPUTS:
-*		en   - GT_TRUE to enable RMU Timeout
-*			   GT_FALUSE, otherwise
+*        ptpStatus    - PTP port status
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gwdGetRMUTimeOut
+GT_STATUS gptpGetTimeStamped
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL	    *en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
 );
 
 /*******************************************************************************
-* gwdGetEgressWDEvent
+* gptpResetTimeStamp
 *
 * DESCRIPTION:
-*		If any port's egress logic detects an egress watch dog issue, this bit
-*		will be set to a one, regardless of the setting of the GT_WD_EGRESS in
-*		gwdSetEvent function.
-*		
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
+*
 * INPUTS:
-*		None.
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
 *
 * OUTPUTS:
-*		event - GT_TRUE, if egress logic has detected any egress watch dog issue
-*			    GT_FALUSE, otherwise
-*
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gwdGetEgressWDEvent
+GT_STATUS gptpResetTimeStamp
 (
-	IN  GT_QD_DEV		*dev,
-	OUT GT_BOOL			*event
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
 );
 
-
 /*******************************************************************************
-* gsysSetQoSWeight
+* gptpGetReg
 *
 * DESCRIPTION:
-*       Programmable Round Robin Weights.
-*		Each port has 4 output Queues. Queue 3 has the highest priority and 
-*		Queue 0 has the lowest priority. When a scheduling mode of port is 
-*		configured as Weighted Round Robin queuing mode, the access sequece of the 
-*		Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
-*		This sequence can be configured with this API.
+*       This routine reads PTP register.
 *
 * INPUTS:
-*       weight - access sequence of the queue
+*       port         - logical port number.
+*       regOffset    - register to read
 *
 * OUTPUTS:
-*       None.
+*        data        - register data
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetQoSWeight
+GT_STATUS gptpGetReg
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_QoS_WEIGHT	*weight
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    OUT GT_U32        *data
 );
 
 /*******************************************************************************
-* gsysGetQoSWeight
+* gptpSetReg
 *
 * DESCRIPTION:
-*       Programmable Round Robin Weights.
-*		Each port has 4 output Queues. Queue 3 has the highest priority and 
-*		Queue 0 has the lowest priority. When a scheduling mode of port is 
-*		configured as Weighted Round Robin queuing mode, the access sequece of the 
-*		Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
-*		This routine retrieves the access sequence of the Queue.
+*       This routine writes data to PTP register.
 *
 * INPUTS:
-*       None.
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
 *
 * OUTPUTS:
-*       weight - access sequence of the queue
+*        None.
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetQoSWeight
+GT_STATUS gptpSetReg
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT GT_QoS_WEIGHT	*weight
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    IN  GT_U32        data
 );
 
 
-/*
- *	gtPortCtrl.c
-*/
+#ifdef CONFIG_AVB_FPGA
 
 /*******************************************************************************
-* gsysSetJumboMode
+* gptpSetFPGAIntStatus
 *
 * DESCRIPTION:
-*       This routine Set the max frame size allowed to be received and transmitted
-*		from or to a given port.
+*       This routine sets interrupt status of PTP logic.
 *
 * INPUTS:
-*		port - the logical port number
-*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*        intStatus    - PTP Int Status
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetJumboMode
+GT_STATUS gptpSetFPGAIntStatus
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_JUMBO_MODE   mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    intStatus
 );
 
+
 /*******************************************************************************
-* gsysGetJumboMode
+* gptpGetFPGAIntStatus
 *
 * DESCRIPTION:
-*       This routine gets the max frame size allowed to be received and transmitted
-*		from or to a given port.
+*       This routine gets interrupt status of PTP logic.
 *
 * INPUTS:
-*		port  - the logical port number.
+*       None.
 *
 * OUTPUTS:
-*       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
+*        intStatus    - PTP Int Status
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetJumboMode
+GT_STATUS gptpGetFPGAIntStatus
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_JUMBO_MODE   *mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    *intStatus
 );
 
-/*
- *  gtPhyCtrl.c
-*/
+
 /*******************************************************************************
-* gprtGetEnergyDetect
+* gptpSetFPGAIntEn
 *
 * DESCRIPTION:
-*       Energy Detect power down mode enables or disables the PHY to wake up on
-*		its own by detecting activity on the CAT 5 cable. 
+*       This routine enables PTP interrupt.
 *
 * INPUTS:
-* 		port - The logical port number
+*        intEn    - enable/disable PTP interrupt (1 to enable, 0 to disable)
 *
 * OUTPUTS:
-*       mode - GT_EDETECT_MODE type
+*       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gprtGetEnergyDetect
+GT_STATUS gptpSetFPGAIntEn
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	OUT GT_EDETECT_MODE   *mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    intEn
 );
 
 /*******************************************************************************
-* gprtSetEnergyDetect
+* gptpGetClockSource
 *
 * DESCRIPTION:
-*       Energy Detect power down mode enables or disables the PHY to wake up on
-*		its own by detecting activity on the CAT 5 cable. 
+*       This routine gets PTP Clock source mode.
 *
 * INPUTS:
-* 		port - The logical port number
-*       mode - GT_EDETECT_MODE type
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*       GT_OK      - on success
+*       GT_FAIL    - on error
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-
-GT_STATUS gprtSetEnergyDetect
+GT_STATUS gptpGetClockSource
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	IN  GT_EDETECT_MODE   mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
 );
 
-
-/*
- *	gtSysCtrl.c
-*/
-
 /*******************************************************************************
-* gsysSetRMUMode
+* gptpSetClockSource
 *
 * DESCRIPTION:
-*		Set Rmote Management Unit Mode: disable, enable on port 4 or 5, or enable
-*		on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
-*		while other devices, such as 88E6165, support RMU on port 4 and 5. So,
-*		please refer to the device datasheet for detail.
-*		When RMU is enabled and this device receives a Remote Management Request
-*		frame directed to this device, the frame will be processed and a Remote 
-*		Management Response frame will be generated and sent out.
-*		
-*		Note: enabling RMU has no effect if the Remote Management port is in half
-*		duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
-*		
-* INPUTS:
-*		rmu - GT_RMU structure
-*
-* OUTPUTS:
-*		None.
-*
-* RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM     - on bad parameter
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
-*
-*******************************************************************************/
-GT_STATUS gsysSetRMUMode
-(
-	IN GT_QD_DEV	*dev,
-	IN GT_RMU		*rmu
-);
-
-/*******************************************************************************
-* gsysGetRMUMode
+*       This routine sets PTP Clock source mode.
 *
-* DESCRIPTION:
-*		Get Rmote Management Unit Mode: disable, enable on port 4 or 5, or enable
-*		on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
-*		while other devices, such as 88E6165, support RMU on port 4 and 5. So,
-*		please refer to the device datasheet for detail.
-*		When RMU is enabled and this device receives a Remote Management Request
-*		frame directed to this device, the frame will be processed and a Remote 
-*		Management Response frame will be generated and sent out.
-*		
-*		Note: enabling RMU has no effect if the Remote Management port is in half
-*		duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
-*		
 * INPUTS:
-*		None.
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * OUTPUTS:
-*		rmu - GT_RMU structure
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMUMode
+GT_STATUS gptpSetClockSource
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_RMU		*rmu
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
 );
 
 /*******************************************************************************
-* gsysPort2Lport
+* gptpGetP9Mode
 *
 * DESCRIPTION:
-*		This routine converts physical port number to logical port number.
+*       This routine gets Port 9 Mode.
 *
 * INPUTS:
-*		port - physical port number
+*       None.
 *
 * OUTPUTS:
-*		lport - logical port number
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysPort2Lport
+GT_STATUS gptpGetP9Mode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		port,
-	OUT GT_LPORT	*lport
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
 );
 
 /*******************************************************************************
-* gsysLport2Port
+* gptpSetP9Mode
 *
 * DESCRIPTION:
-*		This routine converts logical port number to physical port number.
+*       This routine sets Port 9 Mode.
 *
 * INPUTS:
-*		lport - logical port number
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * OUTPUTS:
-*		port - physical port number
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysLport2Port
+GT_STATUS gptpSetP9Mode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	lport,
-	OUT GT_U32 		*port
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
 );
 
 /*******************************************************************************
-* gsysPortvec2Lportvec
+* gptpReset
 *
 * DESCRIPTION:
-*		This routine converts physical port vector to logical port vector.
+*       This routine performs software reset for PTP logic.
 *
 * INPUTS:
-*		portvec - physical port vector
+*        None.
 *
 * OUTPUTS:
-*		lportvec - logical port vector
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysPortvec2Lportvec
+GT_STATUS gptpReset
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32		portvec,
-	OUT GT_U32 		*lportvec
+    IN  GT_QD_DEV     *dev
 );
 
+
 /*******************************************************************************
-* gsysLportvec2Portvec
+* gptpGetCycleAdjustEn
 *
 * DESCRIPTION:
-*		This routine converts logical port vector to physical port vector.
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
 *
 * INPUTS:
-*		lportvec - logical port vector
+*       None.
 *
 * OUTPUTS:
-*		portvec - physical port vector
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysLportvec2Portvec
+GT_STATUS gptpGetCycleAdjustEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32		lportvec,
-	OUT GT_U32 		*portvec
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
 );
 
 
-/*
- * gtPIRL.c
- */
-
 /*******************************************************************************
-* gpirlSetCurTimeUpInt
+* gptpSetCycleAdjustEn
 *
 * DESCRIPTION:
-*       This function sets the current time update interval.
-*		Please contact FAE for detailed information.
+*       This routine enables/disables PTP Duty Cycle Adjustment.
 *
 * INPUTS:
-*       upInt - updata interval (0 ~ 7)
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
@@ -15960,64 +17159,54 @@ GT_STATUS gsysLportvec2Portvec
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gpirlSetCurTimeUpInt
+GT_STATUS gptpSetCycleAdjustEn
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				upInt
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
 );
 
 
-/*
- * gtPIRL2.c
- */
-
 /*******************************************************************************
-* gpirl2SetCurTimeUpInt
+* gptpGetCycleAdjust
 *
 * DESCRIPTION:
-*       This function sets the current time update interval.
-*		Please contact FAE for detailed information.
+*       This routine gets clock duty cycle adjustment value.
 *
 * INPUTS:
-*       upInt - updata interval (0 ~ 7)
+*       None.
 *
 * OUTPUTS:
-*       None.
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gpirl2SetCurTimeUpInt
+GT_STATUS gptpGetCycleAdjust
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				upInt
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT        *adj
 );
 
-
-/*
- * gtPTP.c
- */
-
 /*******************************************************************************
-* gptpSetConfig
+* gptpSetCycleAdjust
 *
 * DESCRIPTION:
-*       This routine writes PTP configuration parameters.
+*       This routine sets clock duty cycle adjustment value.
 *
 * INPUTS:
-*		ptpData  - PTP configuration parameters.
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * OUTPUTS:
 *       None.
@@ -16025,30 +17214,30 @@ GT_STATUS gpirl2SetCurTimeUpInt
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetConfig
+GT_STATUS gptpSetCycleAdjust
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT        *adj
 );
 
 /*******************************************************************************
-* gptpGetConfig
+* gptpGetPLLEn
 *
 * DESCRIPTION:
-*       This routine reads PTP configuration parameters.
+*       This routine checks if PLL is enabled.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		ptpData  - PTP configuration parameters.
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -16056,23 +17245,27 @@ GT_STATUS gptpSetConfig
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
-GT_STATUS gptpGetConfig
+GT_STATUS gptpGetPLLEn
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
 );
 
 /*******************************************************************************
-* gptpSetGlobalConfig
+* gptpSetPLLEn
 *
 * DESCRIPTION:
-*       This routine writes PTP global configuration parameters.
+*       This routine enables/disables PLL device.
 *
 * INPUTS:
-*		ptpData  - PTP global configuration parameters.
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
 *
 * OUTPUTS:
 *       None.
@@ -16080,602 +17273,935 @@ GT_STATUS gptpGetConfig
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
-GT_STATUS gptpSetGlobalConfig
+GT_STATUS gptpSetPLLEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_GLOBAL_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
 );
+#endif
+
+/* Amber APIs */
+
+/* gtBrgFdb.c */
 
 /*******************************************************************************
-* gptpGetGlobalConfig
+* gfdbGetMacAvb
 *
 * DESCRIPTION:
-*       This routine reads PTP global configuration parameters.
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and 
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		ptpData  - PTP global configuration parameters.
+*        mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
+*
 *
 *******************************************************************************/
-GT_STATUS gptpGetGlobalConfig
+GT_STATUS gfdbGetMacAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_GLOBAL_CONFIG	*ptpData
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
 );
 
 /*******************************************************************************
-* gptpSetPortConfig
+* gfdbSetMacAvb
 *
 * DESCRIPTION:
-*       This routine writes PTP port configuration parameters.
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
+*            GT_UC_STATIC_AVB_ENTRY
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
+*
+*        When disabled, ATU entries operate in non-AVB mode:
+*
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and 
+*            GT_UC_STATIC_NRL
+*
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
 *
 * INPUTS:
-*		ptpData  - PTP port configuration parameters.
+*        mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gptpSetPortConfig
+GT_STATUS gfdbSetMacAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_PTP_PORT_CONFIG	*ptpData
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 );
 
 /*******************************************************************************
-* gptpGetPortConfig
+* gfdbGetPortAtuLearnLimit
 *
 * DESCRIPTION:
-*       This routine reads PTP configuration parameters for a port.
+*      Port's auto learning limit. When the limit is non-zero value, the number
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame 
+*        that ingresses this port with a source MAC address not already in the 
+*        address database that is associated with this port will be discarded. 
+*        Normal auto-learning will resume on the port as soon as the number of 
+*        active unicast MAC addresses associated to this port is less than the 
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the 
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
 *
 * INPUTS:
-*       None.
-*
+*        port  - logical port number
+*                                              
 * OUTPUTS:
-*		ptpData  - PTP port configuration parameters.
+*        limit - auto learning limit ( 0 ~ 255 )
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gptpGetPortConfig
+GT_STATUS gfdbGetPortAtuLearnLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_PTP_PORT_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    OUT GT_U32       *limit
 );
 
+/* gtPCSCtrl.c */
+
 /*******************************************************************************
-* gptpSetPTPEn
+* gpcsGetRGMIITimingDelay
 *
 * DESCRIPTION:
-*       This routine enables or disables PTP.
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*        port - the logical port number.
 *
 * OUTPUTS:
-*       None.
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetPTPEn
+GT_STATUS gpcsGetRGMIITimingDelay
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *rxmode,
+    OUT GT_BOOL      *txmode
 );
 
 /*******************************************************************************
-* gptpGetPTPEn
+* gpcsSetRGMIITimingDelay
 *
 * DESCRIPTION:
-*       This routine checks if PTP is enabled.
+*        RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
+*        IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
+*        Change to this bit are disruptive to normal operation. Hence any changes
+*        to this register must be done only while the port's link is down.
 *
 * INPUTS:
-*       None.
+*        port - the logical port number.
+*        rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
+*        txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
 *
 * OUTPUTS:
-*		en - GT_TRUE if enabled, GT_FALSE otherwise
+*        None
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
 *
 *******************************************************************************/
-GT_STATUS gptpGetPTPEn
+GT_STATUS gpcsSetRGMIITimingDelay
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      rxmode,
+    IN  GT_BOOL      txmode
 );
 
+
+/* gtPortLed.c */
+
 /*******************************************************************************
-* gptpSetPortPTPEn
+* gprtSetLED
 *
 * DESCRIPTION:
-*       This routine enables or disables PTP on a port.
+*        This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*        value     - value to be configured
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gptpSetPortPTPEn
+GT_STATUS gprtSetLED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value
 );
 
+
 /*******************************************************************************
-* gptpGetPortPTPEn
+* gprtGetLED
 *
 * DESCRIPTION:
-*       This routine checks if PTP is enabled on a port.
+*        This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
 *
 * OUTPUTS:
-*		en - GT_TRUE if enabled, GT_FALSE otherwise
+*        value     - configured value
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gptpGetPortPTPEn
+GT_STATUS gprtGetLED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    OUT GT_U32        *value
 );
 
 
+
+
+
+/* gtPortStatus.c */
+
 /*******************************************************************************
-* gptpGetPTPInt
+* gprtGetQSizePerQPri
 *
 * DESCRIPTION:
-*       This routine gets PTP interrupt status for each port.
-*		The PTP Interrupt bit gets set for a given port when an incoming PTP 
-*		frame is time stamped and PTPArrIntEn for that port is set to 0x1.
-*		Similary PTP Interrupt bit gets set for a given port when an outgoing
-*		PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
-*		This bit gets cleared upon software reading and clearing the corresponding
-*		time counter valid bits that are valid for that port.
+*        This routine gets egress queue size for port's each QPri (0 ~ 3).
 *
 * INPUTS:
-*       None.
+*        port - the logical port number
 *
 * OUTPUTS:
-*		ptpInt 	- interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*        counts - egress queue size per QPri (should be 4 * 16bytes)
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS:
-*       None
+* COMMENTS: 
 *
 *******************************************************************************/
-GT_STATUS gptpGetPTPInt
+GT_STATUS gprtGetQSizePerQPri
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*ptpInt
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *counts
 );
 
+
+/* gtSysCtrl.c */
+
+
 /*******************************************************************************
-* gptpGetPTPGlobalTime
+* gsysGetARPwoBC
 *
 * DESCRIPTION:
-*       This routine gets the global timer value that is running off of the free
-*		running switch core clock.
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		ptpTime	- PTP global time
+*       en - GT_TRUE if enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*       None
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gptpGetPTPGlobalTime
+GT_STATUS gsysGetARPwoBC
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*ptpTime
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gptpGetTimeStamped
+* gsysSetARPwoBC
 *
 * DESCRIPTION:
-*		This routine retrieves the PTP port status that includes time stamp value 
-*		and sequce Id that are captured by PTP logic for a PTP frame that needs 
-*		to be time stamped.
+*       ARP detection without Broadcast checking. When enabled the switch core
+*       does not check for a Btoadcast MAC address as part of the ARP frame
+*       detection. It only checkes the Ether Type (0x0806).
 *
 * INPUTS:
-*       port 		- logical port number.
-*       timeToRead	- Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*       en - GT_TRUE to enable, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		ptpStatus	- PTP port status
+*       None.
 *
 * RETURNS:
-*       GT_OK 		- on success
-*       GT_FAIL 	- on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*       None
+*       None.
 *
 *******************************************************************************/
-GT_STATUS gptpGetTimeStamped
+GT_STATUS gsysSetARPwoBC
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN	GT_PTP_TIME	timeToRead,
-	OUT GT_PTP_TS_STATUS	*ptpStatus
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL     en
 );
 
+
 /*******************************************************************************
-* gptpResetTimeStamp
+* gsysGetCLK125En
 *
 * DESCRIPTION:
-*		This routine resets PTP Time valid bit so that PTP logic can time stamp
-*		a next PTP frame that needs to be time stamped.
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
 *
 * INPUTS:
-*       port 		- logical port number.
-*       timeToReset	- Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*       GT_OK 		- on success
-*       GT_FAIL 	- on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gptpResetTimeStamp
+GT_STATUS gsysGetCLK125En
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN	GT_PTP_TIME	timeToReset
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 );
 
+
 /*******************************************************************************
-* gptpGetReg
+* gsysSetCLK125En
 *
 * DESCRIPTION:
-*       This routine reads PTP register.
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
 *
 * INPUTS:
-*       port 		- logical port number.
-*       regOffset	- register to read
+*        en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		data		- register data
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gptpGetReg
+GT_STATUS gsysSetCLK125En
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		regOffset,
-	OUT GT_U32		*data
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 );
 
+
+/* gtPriTable.c */
+
 /*******************************************************************************
-* gptpSetReg
+* gsysSetFPriOverrideTable
 *
 * DESCRIPTION:
-*       This routine writes data to PTP register.
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
-*       port 		- logical port number
-*       regOffset	- register to be written
-*		data		- data to be written
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetReg
+GT_STATUS gsysSetFPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		regOffset,
-	IN  GT_U32		data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_FPRI_TBL_ENTRY    *entry
 );
 
 
-#ifdef CONFIG_AVB_FPGA
-
 /*******************************************************************************
-* gptpSetFPGAIntStatus
+* gsysGetFPriOverrideTable
 *
 * DESCRIPTION:
-*       This routine sets interrupt status of PTP logic.
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
-*		intStatus	- PTP Int Status
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
 *
 * OUTPUTS:
-*       None.
+*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
+*       GT_BAD_PARAM     - on unknown frame type
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetFPGAIntStatus
+GT_STATUS gsysGetFPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	intStatus
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_FPRI_TBL_ENTRY    *entry
 );
 
 
 /*******************************************************************************
-* gptpGetFPGAIntStatus
+* gsysSetQPriAvbOverrideTable
 *
 * DESCRIPTION:
-*       This routine gets interrupt status of PTP logic.
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
-*       None.
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
 *
 * OUTPUTS:
-*		intStatus	- PTP Int Status
+*       None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpGetFPGAIntStatus
+GT_STATUS gsysSetQPriAvbOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	*intStatus
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
 );
 
 
 /*******************************************************************************
-* gptpSetFPGAIntEn
+* gsysGetQPriAvbOverrideTable
 *
 * DESCRIPTION:
-*       This routine enables PTP interrupt.
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
-*		intEn	- enable/disable PTP interrupt (1 to enable, 0 to disable)
+*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
 *
 * OUTPUTS:
-*       None.
+*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetFPGAIntEn
+GT_STATUS gsysGetQPriAvbOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	intEn
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
 );
 
+
+/* gtPortCtrl.c */
+
 /*******************************************************************************
-* gptpGetClockSource
+* gprtGet200Base
 *
 * DESCRIPTION:
-*       This routine gets PTP Clock source mode.
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
 *
 * INPUTS:
-*       None.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		clkSrc	- PTP clock source (A/D Device or FPGA)
+*        mode - 0 for 100Mbps, 1 for 200Mbps
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        C_Mode should be set to 0x2 in order for this API to work
 *
 *******************************************************************************/
-GT_STATUS gptpGetClockSource
+GT_STATUS gprtGet200Base
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CLOCK_SRC 	*clkSrc
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
 );
 
+
 /*******************************************************************************
-* gptpSetClockSource
+* gprtSet200Base
 *
 * DESCRIPTION:
-*       This routine sets PTP Clock source mode.
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*            0 = 25MHz Px_GTXCLK
+*            1 = 50MHz Px_GTXCLK
 *
 * INPUTS:
-*		clkSrc	- PTP clock source (A/D Device or FPGA)
+*        port - the logical port number.
+*        mode - 0 for 100Mbps, 1 for 200Mbps
 *
 * OUTPUTS:
-*       None.
+*        None
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        C_Mode should be set to 0x2 in order for this API to work
 *
 *******************************************************************************/
-GT_STATUS gptpSetClockSource
+GT_STATUS gprtSet200Base
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CLOCK_SRC 	clkSrc
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32      mode
 );
 
+
+/* gtPIRL2.c */
+
 /*******************************************************************************
-* gptpGetP9Mode
+* gpirl2WriteTSMResource
 *
 * DESCRIPTION:
-*       This routine gets Port 9 Mode.
+*        This routine writes rate resource bucket parameters in Time Slot Metering
+*        mode to the given resource of the port.
 *
 * INPUTS:
-*       None.
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*        pirlData - PIRL TSM resource parameters.
 *
 * OUTPUTS:
-*		mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        Only Resource 0 and 1 can be supported for TSM Mode.
 *
 *******************************************************************************/
-GT_STATUS gptpGetP9Mode
+GT_STATUS gpirl2WriteTSMResource
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_P9_MODE 	*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_TSM_DATA    *pirlData
 );
 
+
 /*******************************************************************************
-* gptpSetP9Mode
+* gpirl2ReadTSMResource
 *
 * DESCRIPTION:
-*       This routine sets Port 9 Mode.
+*        This routine retrieves IRL Parameter.
+*        Returned ingressRate would be rough number. Instead, customSetup will
+*        have the exact configured value.
 *
 * INPUTS:
-*		mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
 *
 * OUTPUTS:
-*       None.
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        Only Resource 0 and 1 can be supported for TSM Mode.
 *
 *******************************************************************************/
-GT_STATUS gptpSetP9Mode
+GT_STATUS gpirl2ReadTSMResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_P9_MODE 	mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_TSM_DATA    *pirlData
 );
 
+
+/* gtPTP.c */
+
 /*******************************************************************************
-* gptpReset
+* gtaiSetEventConfig
 *
 * DESCRIPTION:
-*       This routine performs software reset for PTP logic.
+*       This routine sets TAI Event Capture configuration parameters.
 *
 * INPUTS:
-*		None.
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -16683,29 +18209,31 @@ GT_STATUS gptpSetP9Mode
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpReset
+GT_STATUS gtaiSetEventConfig
 (
-	IN  GT_QD_DEV 	*dev
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
 );
 
 
 /*******************************************************************************
-* gptpGetCycleAdjustEn
+* gtaiGetEventConfig
 *
 * DESCRIPTION:
-*       This routine checks if PTP Duty Cycle Adjustment is enabled.
+*       This routine gets TAI Event Capture configuration parameters.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		adjEn	- GT_TRUE if enabled, GT_FALSE otherwise
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -16716,24 +18244,23 @@ GT_STATUS gptpReset
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpGetCycleAdjustEn
+GT_STATUS gtaiGetEventConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*adjEn
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
 );
 
-
 /*******************************************************************************
-* gptpSetCycleAdjustEn
+* gtaiGetEventStatus
 *
 * DESCRIPTION:
-*       This routine enables/disables PTP Duty Cycle Adjustment.
+*       This routine gets TAI Event Capture status.
 *
 * INPUTS:
-*		adjEn	- GT_TRUE to enable, GT_FALSE to disable
+*       None.
 *
 * OUTPUTS:
-*       None.
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -16744,24 +18271,23 @@ GT_STATUS gptpGetCycleAdjustEn
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetCycleAdjustEn
+GT_STATUS gtaiGetEventStatus
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		adjEn
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
 );
 
-
 /*******************************************************************************
-* gptpGetCycleAdjust
+* gtaiGetEventInt
 *
 * DESCRIPTION:
-*       This routine gets clock duty cycle adjustment value.
+*       This routine gets TAI Event Capture Interrupt status.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		adj	- adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*        intStatus     - interrupt status for TAI Event capture
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -16772,20 +18298,20 @@ GT_STATUS gptpSetCycleAdjustEn
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpGetCycleAdjust
+GT_STATUS gtaiGetEventInt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CLOCK_ADJUSTMENT		*adj
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
 );
 
 /*******************************************************************************
-* gptpSetCycleAdjust
+* gtaiSetClockSelect
 *
 * DESCRIPTION:
-*       This routine sets clock duty cycle adjustment value.
+*       This routine sets several clock select in TAI.
 *
 * INPUTS:
-*		adj	- adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*        clkSelect  - TAI clock select configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -16793,61 +18319,58 @@ GT_STATUS gptpGetCycleAdjust
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetCycleAdjust
+GT_STATUS gtaiSetClockSelect
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CLOCK_ADJUSTMENT		*adj
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
 );
 
 /*******************************************************************************
-* gptpGetPLLEn
+* gtaiGetClockSelect
 *
 * DESCRIPTION:
-*       This routine checks if PLL is enabled.
+*       This routine gets several clock select in TAI.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
-*		freqSel	- PLL Frequency Selection (default 0x3 - 22.368MHz)
+*       clkSelect  - TAI clock select configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       PLL Frequence selection is based on the Clock Recovery PLL device.
-*		IDT MK1575-01 is the default PLL device.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gptpGetPLLEn
+GT_STATUS gtaiGetClockSelect
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en,
-	OUT GT_U32		*freqSel
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
 );
 
 /*******************************************************************************
-* gptpSetPLLEn
+* gtaiGetTrigInt
 *
 * DESCRIPTION:
-*       This routine enables/disables PLL device.
+*       This routine gets TAI Trigger Interrupt status.
 *
 * INPUTS:
-*		en		- GT_TRUE to enable, GT_FALSE to disable
-*		freqSel	- PLL Frequency Selection (default 0x3 - 22.368MHz)
-*				  Meaningful only when enabling PLL device
+*       None.
 *
 * OUTPUTS:
-*       None.
+*        intStatus     - interrupt status for TAI Trigger
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -16855,3905 +18378,3580 @@ GT_STATUS gptpGetPLLEn
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       PLL Frequence selection is based on the Clock Recovery PLL device.
-*		IDT MK1575-01 is the default PLL device.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gptpSetPLLEn
+GT_STATUS gtaiGetTrigInt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en,
-	IN  GT_U32		freqSel
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
 );
-#endif
-
-/* Amber APIs */
-
-/* gtBrgFdb.c */
 
 /*******************************************************************************
-* gfdbGetMacAvb
+* gtaiClearTrigInt
 *
 * DESCRIPTION:
-*		ATU MAC entry in AVB mode.
-*		When enabled, ATU entries operate in AVB mode:
-*
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
-*			GT_UC_STATIC_AVB_ENTRY
-*
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_AVB_ENTRY, and
-*			GT_MC_PRIO_STATIC_AVB_ENTRY
-*
-*		When disabled, ATU entries operate in non-AVB mode:
-*
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_NRL, and 
-*			GT_UC_STATIC_NRL
-*
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_UNLIMITED_RATE, and
-*			GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*       This routine clear TAI Trigger Interrupt status.
 *
 * INPUTS:
-*		None.
+*       None.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
+*       None.
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
+*       None
 *
 *******************************************************************************/
-GT_STATUS gfdbGetMacAvb
+GT_STATUS gtaiClearTrigInt
 (
-	IN  GT_QD_DEV    *dev,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV     *dev
 );
 
 /*******************************************************************************
-* gfdbSetMacAvb
+* gtaiSetTrigConfig
 *
 * DESCRIPTION:
-*		ATU MAC entry in AVB mode.
-*		When enabled, ATU entries operate in AVB mode:
-*
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
-*			GT_UC_STATIC_AVB_ENTRY
-*
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_AVB_ENTRY, and
-*			GT_MC_PRIO_STATIC_AVB_ENTRY
-*
-*		When disabled, ATU entries operate in non-AVB mode:
-*
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_NRL, and 
-*			GT_UC_STATIC_NRL
-*
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_UNLIMITED_RATE, and
-*			GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*       This routine sets TAI Trigger configuration parameters.
 *
 * INPUTS:
-*		mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*       None
 *
 *******************************************************************************/
-GT_STATUS gfdbSetMacAvb
+GT_STATUS gtaiSetTrigConfig
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
 );
 
 /*******************************************************************************
-* gfdbGetPortAtuLearnLimit
+* gtaiGetTrigConfig
 *
 * DESCRIPTION:
-*      Port's auto learning limit. When the limit is non-zero value, the number
-*		of MAC addresses that can be learned on this port are limited to the value
-*		specified in this API. When the learn limit has been reached any frame 
-*		that ingresses this port with a source MAC address not already in the 
-*		address database that is associated with this port will be discarded. 
-*		Normal auto-learning will resume on the port as soon as the number of 
-*		active unicast MAC addresses associated to this port is less than the 
-*		learn limit.
-*		CPU directed ATU Load, Purge, or Move will not have any effect on the 
-*		learn limit.
-*		This feature is disabled when the limit is zero.
-*		The following care is needed when enabling this feature:
-*			1) dsable learning on the ports
-*			2) flush all non-static addresses in the ATU
-*			3) define the desired limit for the ports
-*			4) re-enable learing on the ports
+*       This routine gets TAI Trigger configuration parameters.
 *
 * INPUTS:
-*		port  - logical port number
-*											  
+*       None.
+*
 * OUTPUTS:
-*		limit - auto learning limit ( 0 ~ 255 )
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gfdbGetPortAtuLearnLimit
+GT_STATUS gtaiGetTrigConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT  	port,
-	OUT GT_U32   	*limit
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
 );
 
-/* gtPCSCtrl.c */
-
 /*******************************************************************************
-* gpcsGetRGMIITimingDelay
+* gtaiGetTSClkPer
 *
 * DESCRIPTION:
-*		RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
-*		IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
-*		Change to this bit are disruptive to normal operation. Hence any changes
-*		to this register must be done only while the port's link is down.
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied 
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP 
+*        Global Time Counter.
 *
 * INPUTS:
-*		port - the logical port number.
+*         None.
 *
 * OUTPUTS:
-*		rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
-*		txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*        clk        - time stamping clock period
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*         None
 *
 *******************************************************************************/
-GT_STATUS gpcsGetRGMIITimingDelay
+GT_STATUS gtaiGetTSClkPer
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_BOOL  	*rxmode,
-	OUT GT_BOOL  	*txmode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clk
 );
 
+
 /*******************************************************************************
-* gpcsSetRGMIITimingDelay
+* gtaiSetTSClkPer
 *
 * DESCRIPTION:
-*		RGMII receive/transmit Timing Control. This api adds delay to RXCLK for
-*		IND inputs and GTXCLK for OUTD outputs when port is in RGMII mode.
-*		Change to this bit are disruptive to normal operation. Hence any changes
-*		to this register must be done only while the port's link is down.
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied 
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP 
+*        Global Time Counter.
 *
 * INPUTS:
-*		port - the logical port number.
-*		rxmode - GT_FALSE for default setup, GT_TRUE for adding delay to rxclk
-*		txmode - GT_FALSE for default setup, GT_TRUE for adding delay to txclk
+*        clk        - time stamping clock period
 *
 * OUTPUTS:
-*		None
+*         None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
+*         None
 *
 *******************************************************************************/
-GT_STATUS gpcsSetRGMIITimingDelay
+GT_STATUS gtaiSetTSClkPer
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_BOOL  	rxmode,
-	IN  GT_BOOL  	txmode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clk
 );
 
-
-/* gtPortLed.c */
-
 /*******************************************************************************
-* gprtSetLED
+* gtaiSetMultiPTPSync
 *
 * DESCRIPTION:
-*		This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
-*		and special controls.
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the 
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
 *
 * INPUTS:
-*		port	- the logical port number
-*		cfg 	- GT_LED_CFG value
-*		value 	- value to be configured
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
 *
 *******************************************************************************/
-GT_STATUS gprtSetLED
+GT_STATUS gtaiSetMultiPTPSync
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     multiEn,
+    IN  GT_32        syncTime
 );
 
-
 /*******************************************************************************
-* gprtGetLED
+* gtaiGetMultiPTPSync
 *
 * DESCRIPTION:
-*		This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
-*		and special controls.
+*         This routine gets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the 
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
 *
 * INPUTS:
-*		port	- the logical port number
-*		cfg 	- GT_LED_CFG value
+*        None.
 *
 * OUTPUTS:
-*		value 	- configured value
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
 *
 *******************************************************************************/
-GT_STATUS gprtGetLED
+GT_STATUS gtaiGetMultiPTPSync
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	OUT GT_U32		*value
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *multiEn,
+    OUT GT_32        *syncTime
 );
 
-
-
-
-
-/* gtPortStatus.c */
-
 /*******************************************************************************
-* gprtGetQSizePerQPri
+* gtaiGetTimeIncDec
 *
 * DESCRIPTION:
-*		This routine gets egress queue size for port's each QPri (0 ~ 3).
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be 
+*        incremented or decremented. This is used for adjusting the PTP Global Time 
+*        counter value by a certain amount.
 *
 * INPUTS:
-*		port - the logical port number
+*         None.
 *
 * OUTPUTS:
-*		counts - egress queue size per QPri (should be 4 * 16bytes)
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
-* COMMENTS: 
+* COMMENTS:
+*         None
 *
 *******************************************************************************/
-GT_STATUS gprtGetQSizePerQPri
+GT_STATUS gtaiGetTimeIncDec
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*counts
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_BOOL        *inc,
+    OUT GT_U32        *amount
 );
 
-
-/* gtSysCtrl.c */
-
-
 /*******************************************************************************
-* gsysGetARPwoBC
+* gtaiSetTimeInc
 *
 * DESCRIPTION:
-*       ARP detection without Broadcast checking. When enabled the switch core
-*       does not check for a Btoadcast MAC address as part of the ARP frame
-*       detection. It only checkes the Ether Type (0x0806).
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be 
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
 *
 * INPUTS:
-*       None.
+*        amount    - time increment amount (0 ~ 0xFF)
 *
 * OUTPUTS:
-*       en - GT_TRUE if enabled, GT_FALSE otherwise.
+*         None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_BAD_PARAM    - on bad parameter
-*       GT_FAIL         - on error
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysGetARPwoBC
+GT_STATUS gtaiSetTimeInc
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
 );
 
 /*******************************************************************************
-* gsysSetARPwoBC
+* gtaiSetTimeDec
 *
 * DESCRIPTION:
-*       ARP detection without Broadcast checking. When enabled the switch core
-*       does not check for a Btoadcast MAC address as part of the ARP frame
-*       detection. It only checkes the Ether Type (0x0806).
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be 
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
 *
 * INPUTS:
-*       en - GT_TRUE to enable, GT_FALSE otherwise.
+*        amount    - time decrement amount (0 ~ 0x7FF)
 *
 * OUTPUTS:
-*       None.
+*         None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysSetARPwoBC
+GT_STATUS gtaiSetTimeDec
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL 	en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
 );
 
 
 /*******************************************************************************
-* gsysGetCLK125En
+* gavbGetPriority
 *
 * DESCRIPTION:
-*		Clock 125MHz Enable.
-*		When this feature is enabled, the CLK125 pin has a free running 125 MHz
-*		clock output.
-*		When it's disabled, the CLK125 pin will be in tri-state.
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
 *
 * INPUTS:
-*		None.
+*         priType    - GT_AVB_PRI_TYPE
 *
 * OUTPUTS:
-*		en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
+*        pri    - priority
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysGetCLK125En
+GT_STATUS gavbGetPriority
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    OUT GT_U32        *pri
 );
 
-
 /*******************************************************************************
-* gsysSetCLK125En
+* gavbSetPriority
 *
 * DESCRIPTION:
-*		Clock 125MHz Enable.
-*		When this feature is enabled, the CLK125 pin has a free running 125 MHz
-*		clock output.
-*		When it's disabled, the CLK125 pin will be in tri-state.
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
 *
 * INPUTS:
-*		en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
+*         priType    - GT_AVB_PRI_TYPE
+*        pri    - priority
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysSetCLK125En
+GT_STATUS gavbSetPriority
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    IN  GT_U32        pri
 );
 
-
-/* gtPriTable.c */
-
 /*******************************************************************************
-* gsysSetFPriOverrideTable
+* gavbGetAVBHiLimit
 *
 * DESCRIPTION:
-* 		Frame Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Frame Priority will be overridden
-*		with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs. 
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this 
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override 
+*        Table
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
-*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*        None.
 *
 * OUTPUTS:
-*       None.
+*        limit    - Hi Frame Limit
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysSetFPriOverrideTable
+GT_STATUS gavbGetAVBHiLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	IN  GT_FPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *limit
 );
 
-
 /*******************************************************************************
-* gsysGetFPriOverrideTable
+* gavbSetAVBHiLimit
 *
 * DESCRIPTION:
-* 		Frame Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Frame Priority will be overridden
-*		with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs. 
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this 
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override 
+*        Table
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*        limit    - Hi Frame Limit
 *
 * OUTPUTS:
-*       entry - Frame Priority Override Table entry (GT_FPRI_TBL_ENTRY)
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM     - on unknown frame type
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysGetFPriOverrideTable
+GT_STATUS gavbSetAVBHiLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	OUT GT_FPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        limit
 );
 
-
 /*******************************************************************************
-* gsysSetQPriAvbOverrideTable
+* gavbGetPtpExtClk
 *
 * DESCRIPTION:
-* 		Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
-*		When a frame enters a AVB port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from 
+*        an internal 125MHz clock based on the device's XTAL_IN input. 
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
-*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*        None.
 *
 * OUTPUTS:
-*       None.
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysSetQPriAvbOverrideTable
+GT_STATUS gavbGetPtpExtClk
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	IN  GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *extClk
 );
 
-
 /*******************************************************************************
-* gsysGetQPriAvbOverrideTable
+* gavbSetPtpExtClk
 *
 * DESCRIPTION:
-* 		Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
-*		When a frame enters a AVB port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from 
+*        an internal 125MHz clock based on the device's XTAL_IN input. 
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
 *
 * INPUTS:
-*       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
 *
 * OUTPUTS:
-*       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gsysGetQPriAvbOverrideTable
+GT_STATUS gavbSetPtpExtClk
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	OUT GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        extClk
 );
 
-
-/* gtPortCtrl.c */
-
 /*******************************************************************************
-* gprtGet200Base
+* gavbGetRecClkSel
 *
 * DESCRIPTION:
-*		200 Base mode. This bit can be used to change the port's Px_GTXCLK
-*		frequency to 50MHz to support 200 BASE mode as follows:
-*		0 = 25MHz Px_GTXCLK
-*		1 = 50MHz Px_GTXCLK
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
 *
 * INPUTS:
-*		port - the logical port number.
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
 *
 * OUTPUTS:
-*		mode - 0 for 100Mbps, 1 for 200Mbps
+*        clkSel    - recovered clock selection
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		C_Mode should be set to 0x2 in order for this API to work
+*         None
 *
 *******************************************************************************/
-GT_STATUS gprtGet200Base
+GT_STATUS gavbGetRecClkSel
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_U32  	*mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    OUT GT_U32        *clkSel
 );
 
 
 /*******************************************************************************
-* gprtSet200Base
+* gavbSetRecClkSel
 *
 * DESCRIPTION:
-*		200 Base mode. This bit can be used to change the port's Px_GTXCLK
-*		frequency to 50MHz to support 200 BASE mode as follows:
-*			0 = 25MHz Px_GTXCLK
-*			1 = 50MHz Px_GTXCLK
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - 0 for 100Mbps, 1 for 200Mbps
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*        clkSel    - recovered clock selection (should be less than 8)
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		C_Mode should be set to 0x2 in order for this API to work
+*         None
 *
 *******************************************************************************/
-GT_STATUS gprtSet200Base
+GT_STATUS gavbSetRecClkSel
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U32  	mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    IN  GT_U32        clkSel
 );
 
-
-/* gtPIRL2.c */
-
 /*******************************************************************************
-* gpirl2WriteTSMResource
+* gavbGetAvbOuiBytes
 *
 * DESCRIPTION:
-*		This routine writes rate resource bucket parameters in Time Slot Metering
-*		mode to the given resource of the port.
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three 
+*        AvbOui Bytes or the frame will be filtered.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 1).
-*		pirlData - PIRL TSM resource parameters.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Only Resource 0 and 1 can be supported for TSM Mode.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gpirl2WriteTSMResource
+GT_STATUS gavbGetAvbOuiBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	IN  GT_PIRL2_TSM_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *obiBytes
 );
 
-
 /*******************************************************************************
-* gpirl2ReadTSMResource
+* gavbSetAvbOuiBytes
 *
 * DESCRIPTION:
-*		This routine retrieves IRL Parameter.
-*		Returned ingressRate would be rough number. Instead, customSetup will
-*		have the exact configured value.
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three 
+*        AvbOui Bytes or the frame will be filtered.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 1).
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Only Resource 0 and 1 can be supported for TSM Mode.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gpirl2ReadTSMResource
+GT_STATUS gavbSetAvbOuiBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	OUT GT_PIRL2_TSM_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        *obiBytes
 );
 
-
-/* gtPTP.c */
-
 /*******************************************************************************
-* gtaiSetEventConfig
+* gavbGetAvbMode
 *
 * DESCRIPTION:
-*       This routine sets TAI Event Capture configuration parameters.
+*        Port's AVB Mode.
 *
 * INPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        port    - the logical port number
 *
 * OUTPUTS:
-*       None.
+*        mode    - GT_AVB_MODE type
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetEventConfig
+GT_STATUS gavbGetAvbMode
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_TAI_EVENT_CONFIG	*eventData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_AVB_MODE    *mode
 );
 
-
 /*******************************************************************************
-* gtaiGetEventConfig
+* gavbSetAvbMode
 *
 * DESCRIPTION:
-*       This routine gets TAI Event Capture configuration parameters.
+*        Port's AVB Mode.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
+*        mode    - GT_AVB_MODE type
 *
 * OUTPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetEventConfig
+GT_STATUS gavbSetAvbMode
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_TAI_EVENT_CONFIG	*eventData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_AVB_MODE    mode
 );
 
 /*******************************************************************************
-* gtaiGetEventStatus
+* gavbGetAvbOverride
 *
 * DESCRIPTION:
-*       This routine gets TAI Event Capture status.
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if 
+*        the ingress portion is not.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetEventStatus
+GT_STATUS gavbGetAvbOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_TAI_EVENT_STATUS	*status
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gtaiGetEventInt
+* gavbSetAvbOverride
 *
 * DESCRIPTION:
-*       This routine gets TAI Event Capture Interrupt status.
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if 
+*        the ingress portion is not.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		intStatus 	- interrupt status for TAI Event capture
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetEventInt
+GT_STATUS gavbSetAvbOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*intStatus
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 );
 
 
 /*******************************************************************************
-* gtaiGetTrigInt
+* gavbGetFilterBadAvb
 *
 * DESCRIPTION:
-*       This routine gets TAI Trigger Interrupt status.
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		intStatus 	- interrupt status for TAI Trigger
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetTrigInt
+GT_STATUS gavbGetFilterBadAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*intStatus
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gtaiSetTrigConfig
+* gavbSetFilterBadAvb
 *
 * DESCRIPTION:
-*       This routine sets TAI Trigger configuration parameters.
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
 *
 * INPUTS:
-*		trigEn    - enable/disable TAI Trigger.
-*		trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetTrigConfig
+GT_STATUS gavbSetFilterBadAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL 	trigEn,
-	IN  GT_TAI_TRIGGER_CONFIG	*trigData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 );
 
+
 /*******************************************************************************
-* gtaiGetTrigConfig
+* gavbGetAvbTunnel
 *
 * DESCRIPTION:
-*       This routine gets TAI Trigger configuration parameters.
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		trigEn    - enable/disable TAI Trigger.
-*		trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetTrigConfig
+GT_STATUS gavbGetAvbTunnel
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL 	*trigEn,
-	OUT GT_TAI_TRIGGER_CONFIG	*trigData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 );
 
+
 /*******************************************************************************
-* gtaiGetTSClkPer
+* gavbSetAvbTunnel
 *
 * DESCRIPTION:
-* 		Time Stamping Clock Period in pico seconds.
-*		This routine specifies the clock period for the time stamping clock supplied 
-*		to the PTP hardware logic.
-*		This is the clock that is used by the hardware logic to update the PTP 
-*		Global Time Counter.
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
 *
 * INPUTS:
-* 		None.
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		clk		- time stamping clock period
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiGetTSClkPer
+GT_STATUS gavbSetAvbTunnel
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*clk
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 );
 
 
 /*******************************************************************************
-* gtaiSetTSClkPer
+* gavbGetAvbFramePolicy
 *
 * DESCRIPTION:
-* 		Time Stamping Clock Period in pico seconds.
-*		This routine specifies the clock period for the time stamping clock supplied 
-*		to the PTP hardware logic.
-*		This is the clock that is used by the hardware logic to update the PTP 
-*		Global Time Counter.
-*
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*            
 * INPUTS:
-*		clk		- time stamping clock period
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE 
 *
 * OUTPUTS:
-* 		None.
+*        policy    - GT_AVB_FRAME_POLICY
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetTSClkPer
+GT_STATUS gavbGetAvbFramePolicy
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		clk
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    OUT GT_AVB_FRAME_POLICY        *policy
 );
 
+
 /*******************************************************************************
-* gtaiSetMultiPTPSync
+* gavbSetAvbFramePolicy
 *
 * DESCRIPTION:
-* 		This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
-*		When enabled, the hardware logic detects a low to high transition on the 
-*		EventRequest(GPIO) and transfers the sync time into the PTP Global Time
-*		register. The EventCapTime is also updated at that instant.
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
 *
 * INPUTS:
-*		multiEn		- enable/disable Multiple PTP device sync mode
-*		syncTime	- sync time (valid only if multiEn is GT_TRUE)
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE 
+*        policy    - GT_AVB_FRAME_POLICY
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
-*		and gtaiSetTimeDec APIs are not operational.
+*         None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetMultiPTPSync
+GT_STATUS gavbSetAvbFramePolicy
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL 	multiEn,
-	IN  GT_32		syncTime
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    IN  GT_AVB_FRAME_POLICY        policy
 );
 
+/* Amber QAV API */
+/*******************************************************************************/
+/* Amber QAV API */
 /*******************************************************************************
-* gtaiGetMultiPTPSync
+* gqavSetPortQpriXQTSToken
 *
 * DESCRIPTION:
-* 		This routine gets Multiple PTP device sync mode and sync time (TrigGenAmt).
-*		When enabled, the hardware logic detects a low to high transition on the 
-*		EventRequest(GPIO) and transfers the sync time into the PTP Global Time
-*		register. The EventCapTime is also updated at that instant.
+*        This routine set Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each 
+*        QTS interval boundary.
 *
 * INPUTS:
-*		None.
+*        port    - the logical port number
+*        queue     - 0 - 3
+*        qtsToken - number of tokens.
 *
 * OUTPUTS:
-*		multiEn		- enable/disable Multiple PTP device sync mode
-*		syncTime	- sync time (valid only if multiEn is GT_TRUE)
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
-*		and gtaiSetTimeDec APIs are not operational.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gtaiGetMultiPTPSync
+GT_STATUS gqavSetPortQpriXQTSToken
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL 	*multiEn,
-	OUT GT_32		*syncTime
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        qtsToken
 );
 
 /*******************************************************************************
-* gtaiGetTimeIncDec
+* gqavGetPortQpriXQTSToken
 *
 * DESCRIPTION:
-* 		This routine retrieves Time increment/decrement setup.
-*		This amount specifies the number of units of PTP Global Time that need to be 
-*		incremented or decremented. This is used for adjusting the PTP Global Time 
-*		counter value by a certain amount.
+*        This routine get Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each 
+*        QTS interval boundary.
 *
 * INPUTS:
-* 		None.
+*        port    - the logical port number
+*        queue - 0 - 3
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
-*		inc		- GT_TRUE if increment, GT_FALSE if decrement
-*		amount	- increment/decrement amount
+*        qtsToken - number of tokens
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gtaiGetTimeIncDec
+GT_STATUS gqavGetPortQpriXQTSToken
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en,
-	OUT GT_BOOL		*inc,
-	OUT GT_U32		*amount
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *qtsToken
 );
 
 /*******************************************************************************
-* gtaiSetTimeInc
+* gqavSetPortQpriXBurstBytes
 *
 * DESCRIPTION:
-* 		This routine enables time increment by the specifed time increment amount.
-*		The amount specifies the number of units of PTP Global Time that need to be 
-*		incremented. This is used for adjusting the PTP Global Time counter value by
-*		a certain amount.
-*		Increment occurs just once.
+*        This routine set Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be 
+*        accumulated when the queue is blocked from sending out a frame due to 
+*        higher priority queue frames being sent out.
 *
 * INPUTS:
-*		amount	- time increment amount (0 ~ 0xFF)
+*        port    - the logical port number
+*        queue - 0 - 3
+*        burst - number of credits in bytes .
 *
 * OUTPUTS:
-* 		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetTimeInc
+GT_STATUS gqavSetPortQpriXBurstBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		amount
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        burst
 );
 
 /*******************************************************************************
-* gtaiSetTimeDec
+* gqavGetPortQpriXBurstBytes
 *
 * DESCRIPTION:
-* 		This routine enables time decrement by the specifed time decrement amount.
-*		The amount specifies the number of units of PTP Global Time that need to be 
-*		decremented. This is used for adjusting the PTP Global Time counter value by
-*		a certain amount.
-*		Decrement occurs just once.
+*        This routine get Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be 
+*        accumulated when the queue is blocked from sending out a frame due to 
+*        higher priority queue frames being sent out.
 *
 * INPUTS:
-*		amount	- time decrement amount (0 ~ 0x7FF)
+*        port    - the logical port number
+*        queue    - 0 - 3
 *
 * OUTPUTS:
-* 		None.
+*        burst - number of credits in bytes .
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gtaiSetTimeDec
+GT_STATUS gqavGetPortQpriXBurstBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		amount
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *burst
 );
 
-
 /*******************************************************************************
-* gavbGetPriority
+* gqavSetPortQavEnable
 *
 * DESCRIPTION:
-*		Priority overwrite.
-*		Supported priority type is defined as GT_AVB_PRI_TYPE.
-*		Priority is either 3 bits or 2 bits depending on priority type.
-*			GT_AVB_HI_FPRI		- priority is 0 ~ 7
-*			GT_AVB_HI_QPRI		- priority is 0 ~ 3
-*			GT_AVB_LO_FPRI		- priority is 0 ~ 7
-*			GT_AVB_LO_QPRI		- priority is 0 ~ 3
-*			GT_LEGACY_HI_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_HI_QPRI	- priority is 0 ~ 3
-*			GT_LEGACY_LO_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_LO_QPRI	- priority is 0 ~ 3
+*        This routine set QAV enable status on a port.
 *
 * INPUTS:
-* 		priType	- GT_AVB_PRI_TYPE
+*        port    - the logical port number
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
 *
 * OUTPUTS:
-*		pri	- priority
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetPriority
+GT_STATUS gqavSetPortQavEnable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_PRI_TYPE		priType,
-	OUT GT_U32		*pri
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 );
 
 /*******************************************************************************
-* gavbSetPriority
+* gqavGetPortQavEnable
 *
 * DESCRIPTION:
-*		Priority overwrite.
-*		Supported priority type is defined as GT_AVB_PRI_TYPE.
-*		Priority is either 3 bits or 2 bits depending on priority type.
-*			GT_AVB_HI_FPRI		- priority is 0 ~ 7
-*			GT_AVB_HI_QPRI		- priority is 0 ~ 3
-*			GT_AVB_LO_FPRI		- priority is 0 ~ 7
-*			GT_AVB_LO_QPRI		- priority is 0 ~ 3
-*			GT_LEGACY_HI_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_HI_QPRI	- priority is 0 ~ 3
-*			GT_LEGACY_LO_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_LO_QPRI	- priority is 0 ~ 3
+*        This routine get QAV enable status on a port.
 *
 * INPUTS:
-* 		priType	- GT_AVB_PRI_TYPE
-*		pri	- priority
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		None.
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetPriority
+GT_STATUS gqavGetPortQavEnable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_PRI_TYPE		priType,
-	IN  GT_U32		pri
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 );
 
+/*******************************************************************************/
+/* QAV Global registers processing */
 /*******************************************************************************
-* gavbGetAVBHiLimit
+* gqavSetGlobalAdminMGMT
 *
 * DESCRIPTION:
-*		AVB Hi Frame Limit.
-*		When these bits are zero, normal frame processing occurs. 
-*		When it's non-zero, they are used to define the maximum frame size allowed
-*		for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
-*		that are over this size limit are filtered. The only exception to this 
-*		is non-AVB frames that get their QPriAvb assigned by the Priority Override 
-*		Table
+*        This routine set to accept Admit Management Frames always.
 *
 * INPUTS:
-*		None.
+*        en - GT_TRUE to set MGMT frame accepted always, 
+*             GT_FALSE do not set MGMT frame accepted always
 *
 * OUTPUTS:
-*		limit	- Hi Frame Limit
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAVBHiLimit
+GT_STATUS gqavSetGlobalAdminMGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 );
 
 /*******************************************************************************
-* gavbSetAVBHiLimit
+* gqavGetGlobalAdminMGMT
 *
 * DESCRIPTION:
-*		AVB Hi Frame Limit.
-*		When these bits are zero, normal frame processing occurs. 
-*		When it's non-zero, they are used to define the maximum frame size allowed
-*		for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
-*		that are over this size limit are filtered. The only exception to this 
-*		is non-AVB frames that get their QPriAvb assigned by the Priority Override 
-*		Table
+*        This routine get setting of Admit Management Frames always.
 *
 * INPUTS:
-*		limit	- Hi Frame Limit
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE to set MGMT frame accepted always, 
+*             GT_FALSE do not set MGMT frame accepted always
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAVBHiLimit
+GT_STATUS gqavGetGlobalAdminMGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		limit
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gavbGetPtpExtClk
+* gqavSetGlobalIsoPtrThreshold
 *
 * DESCRIPTION:
-*		PTP external clock select.
-*		When this bit is cleared to a zero, the PTP core gets its clock from 
-*		an internal 125MHz clock based on the device's XTAL_IN input. 
-*		When this bit is set to a one, the PTP core gets its clock from the device's
-*		PTP_EXTCLK pin.
+*        This routine set Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers 
+*        that are reserved for isochronous streams. The value is expected to be 
+*        computed in SRP software and programmed into hardware based on the total 
+*        aggregate isochronous streams configured to go through this device..
 *
 * INPUTS:
-*		None.
+*        isoPtrs -  total number of isochronous pointers 
 *
 * OUTPUTS:
-*		extClk	- GT_TRUE if external clock is selected, GT_FALSE otherwise
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetPtpExtClk
+GT_STATUS gqavSetGlobalIsoPtrThreshold
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*extClk
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        isoPtrs
 );
 
 /*******************************************************************************
-* gavbSetPtpExtClk
+* gqavGetGlobalIsoPtrThreshold
 *
 * DESCRIPTION:
-*		PTP external clock select.
-*		When this bit is cleared to a zero, the PTP core gets its clock from 
-*		an internal 125MHz clock based on the device's XTAL_IN input. 
-*		When this bit is set to a one, the PTP core gets its clock from the device's
-*		PTP_EXTCLK pin.
+*        This routine get Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers 
+*        that are reserved for isochronous streams. The value is expected to be 
+*        computed in SRP software and programmed into hardware based on the total 
+*        aggregate isochronous streams configured to go through this device..
 *
 * INPUTS:
-*		extClk	- GT_TRUE if external clock is selected, GT_FALSE otherwise
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        isoPtrs -  total number of isochronous pointers 
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetPtpExtClk
+GT_STATUS gqavGetGlobalIsoPtrThreshold
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		extClk
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *isoPtrs
 );
 
 /*******************************************************************************
-* gavbGetRecClkSel
+* gqavSetGlobalDisQSD4MGMT
 *
 * DESCRIPTION:
-*		Synchronous Ethernet Recovered Clock Select.
-*		This field indicate the internal PHY number whose recovered clock will
-*		be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*        This routine set Disable Queue Scheduler Delays for Management frames..
 *
 * INPUTS:
-*		recClk	- GT_AVB_RECOVERED_CLOCK type
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
 *
 * OUTPUTS:
-*		clkSel	- recovered clock selection
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetRecClkSel
+GT_STATUS gqavSetGlobalDisQSD4MGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_RECOVERED_CLOCK	recClk,
-	OUT GT_U32		*clkSel
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 );
 
-
 /*******************************************************************************
-* gavbSetRecClkSel
+* gqavGetGlobalDisQSD4MGMT
 *
 * DESCRIPTION:
-*		Synchronous Ethernet Recovered Clock Select.
-*		This field indicate the internal PHY number whose recovered clock will
-*		be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*        This routine Get Disable Queue Scheduler Delays for Management frames..
 *
 * INPUTS:
-*		recClk	- GT_AVB_RECOVERED_CLOCK type
-*		clkSel	- recovered clock selection (should be less than 8)
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetRecClkSel
+GT_STATUS gqavGetGlobalDisQSD4MGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_RECOVERED_CLOCK	recClk,
-	IN  GT_U32		clkSel
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gavbGetAvbOuiBytes
+* gqavSetGlobalInterrupt
 *
 * DESCRIPTION:
-*		AVB OUI Limit Filter bytes(0 ~ 2).
-*		When all three of the AvbOui Bytes are zero, normal frame processing occurs.
-*		When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
-*		destination address whose 1st three bytes of the DA match these three 
-*		AvbOui Bytes or the frame will be filtered.
+*        This routine set QAV interrupt enable, 
+*        The QAV interrypts include:
+*        [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
+*        [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
+*        [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
+*        [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                              Interrupt Enable 
 *
 * INPUTS:
-*		None.
+*        intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
 *
 * OUTPUTS:
-*		ouiBytes	- 3 bytes of OUI field in Ethernet address format
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAvbOuiBytes
+GT_STATUS gqavSetGlobalInterrupt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*obiBytes
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        intEn
 );
 
 /*******************************************************************************
-* gavbSetAvbOuiBytes
+* gqavGetGlobalInterrupt
 *
 * DESCRIPTION:
-*		AVB OUI Limit Filter bytes(0 ~ 2).
-*		When all three of the AvbOui Bytes are zero, normal frame processing occurs.
-*		When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
-*		destination address whose 1st three bytes of the DA match these three 
-*		AvbOui Bytes or the frame will be filtered.
+*       This routine get QAV interrupt status and enable status, 
+*        The QAV interrypt status include:
+*         [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded  
+*         [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status   
+*         [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status 
+*         [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                                Interrupt Status 
+*        The QAV interrypt enable status include:
+*         [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
+*         [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
+*         [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
+*         [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                                  Interrupt Enable 
 *
 * INPUTS:
-*		ouiBytes	- 3 bytes of OUI field in Ethernet address format
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR     
+*                [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR   
+*                [GT_QAV_INT_STATUS_ISO_DIS_BIT] OR   
+*                [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
+*                [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAvbOuiBytes
+GT_STATUS gqavGetGlobalInterrupt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		*obiBytes
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intEnSt
 );
 
 /*******************************************************************************
-* gavbGetAvbMode
+* gqavGetGlobalIsoInterruptPort
 *
 * DESCRIPTION:
-*		Port's AVB Mode.
+*        This routine get Isochronous interrupt port.
+*        This field indicates the port number for IsoDisInt or IsoLimitExInt 
+*        bits. Only one such interrupt condition can be detected by hardware at one 
+*        time. Once an interrupt bit has been set along with the IsoIntPort, the 
+*        software would have to come and clear the bits before hardware records 
+*        another interrupt event.
 *
 * INPUTS:
-*		port	- the logical port number
+*        None.
 *
 * OUTPUTS:
-*		mode	- GT_AVB_MODE type
+*        port - port number for IsoDisInt or IsoLimitExInt bits.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAvbMode
+GT_STATUS gqavGetGlobalIsoInterruptPort
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_AVB_MODE	*mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *port
 );
 
 /*******************************************************************************
-* gavbSetAvbMode
+* gqavSetGlobalIsoDelayLmt
 *
 * DESCRIPTION:
-*		Port's AVB Mode.
+*        This routine set Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that 
+*        will be checked by the queue controller logic to ensure no isochronous 
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS 
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
 *
 * INPUTS:
-*		port	- the logical port number
-*		mode	- GT_AVB_MODE type
+*        limit - per-port isochronous delay limit.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAvbMode
+GT_STATUS gqavSetGlobalIsoDelayLmt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_AVB_MODE	mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        limit
 );
 
 /*******************************************************************************
-* gavbGetAvbOverride
+* gqavGetGlobalIsoDelayLmt
 *
 * DESCRIPTION:
-*		AVB Override.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the egress portion of this port is considered AVB even if 
-*		the ingress portion is not.
+*        This routine get Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that 
+*        will be checked by the queue controller logic to ensure no isochronous 
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS 
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
 *
 * INPUTS:
-*		port	- the logical port number
+*        None.
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        limit - per-port isochronous delay limit.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAvbOverride
+GT_STATUS gqavGetGlobalIsoDelayLmt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *limit
 );
 
 /*******************************************************************************
-* gavbSetAvbOverride
+* gqavSetGlobalIsoMonEn
 *
 * DESCRIPTION:
-*		AVB Override.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the egress portion of this port is considered AVB even if 
-*		the ingress portion is not.
+*       This routine set Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        en - GT_TRUE / GT_FALSE.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAvbOverride
+GT_STATUS gqavSetGlobalIsoMonEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 );
 
-
 /*******************************************************************************
-* gavbGetFilterBadAvb
+* gqavGetGlobalIsoMonEn
 *
 * DESCRIPTION:
-*		Filter Bad AVB frames.
-*		When disabled, normal frame processing occurs.
-*		When enabled, frames that are considered Bad AVB frames are filtered.
+*        This routine get Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
 *
 * INPUTS:
-*		port	- the logical port number
+*        None.
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        en - GT_TRUE / GT_FALSE.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetFilterBadAvb
+GT_STATUS gqavGetGlobalIsoMonEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 );
 
 /*******************************************************************************
-* gavbSetFilterBadAvb
+* gqavSetGlobalIsoMonPort
 *
 * DESCRIPTION:
-*		Filter Bad AVB frames.
-*		When disabled, normal frame processing occurs.
-*		When enabled, frames that are considered Bad AVB frames are filtered.
+*        This routine set Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit 
+*        (Qav Global Status, offset 0xD) and it indicates the port number that 
+*        the software wants the hardware to start monitoring i.e., start updating 
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
+*        the above stats when IsoMonPort is changed..
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        port -  port number .
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetFilterBadAvb
+GT_STATUS gqavSetGlobalIsoMonPort
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        port
 );
 
-
 /*******************************************************************************
-* gavbGetAvbTunnel
+* gqavGetGlobalIsoMonPort
 *
 * DESCRIPTION:
-*		AVB Tunnel.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
-*		masking and the Trunk Masking is bypassed for any frame entering this port
-*		that is considered AVB by DA. This includes unicast as well as multicast
-*		frame
+*        This routine get Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit 
+*        (Qav Global Status, offset 0xD) and it indicates the port number that 
+*        the software wants the hardware to start monitoring i.e., start updating 
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
+*        the above stats when IsoMonPort is changed..
 *
 * INPUTS:
-*		port	- the logical port number
+*        None.
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        port -  port number.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAvbTunnel
+GT_STATUS gqavGetGlobalIsoMonPort
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *port
 );
 
-
 /*******************************************************************************
-* gavbSetAvbTunnel
+* gqavSetGlobalIsoHiDisCtr
 *
 * DESCRIPTION:
-*		AVB Tunnel.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
-*		masking and the Trunk Masking is bypassed for any frame entering this port
-*		that is considered AVB by DA. This includes unicast as well as multicast
-*		frame
+*        This routine set Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous hi packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        disCtr - upcounter of number of isochronous hi packets discarded 
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAvbTunnel
+GT_STATUS gqavSetGlobalIsoHiDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
 );
 
-
 /*******************************************************************************
-* gavbGetAvbFramePolicy
+* gqavGetGlobalIsoHiDisCtr
 *
 * DESCRIPTION:
-*		AVB Hi or Lo frame policy mapping.
-*		Supported policies are defined in GT_AVB_FRAME_POLICY.
-*			
+*        This routine get Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous hi packets discarded 
+*        by Queue Controller.
+*
 * INPUTS:
-*		port	- the logical port number
-*		fType	- GT_AVB_FRAME_TYPE 
+*        None.
 *
 * OUTPUTS:
-*		policy	- GT_AVB_FRAME_POLICY
+*        disCtr - upcounter of number of isochronous hi packets discarded 
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbGetAvbFramePolicy
+GT_STATUS gqavGetGlobalIsoHiDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN	GT_AVB_FRAME_TYPE	fType,
-	OUT GT_AVB_FRAME_POLICY		*policy
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
 );
 
-
 /*******************************************************************************
-* gavbSetAvbFramePolicy
+* gqavSetGlobalIsoLoDisCtr
 *
 * DESCRIPTION:
-*		AVB Hi or Lo frame policy mapping.
-*		Supported policies are defined in GT_AVB_FRAME_POLICY.
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous lo packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		port	- the logical port number
-*		fType	- GT_AVB_FRAME_TYPE 
-*		policy	- GT_AVB_FRAME_POLICY
+*        disCtr - upcounter of number of isochronous lo packets discarded 
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gavbSetAvbFramePolicy
+GT_STATUS gqavSetGlobalIsoLoDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN	GT_AVB_FRAME_TYPE	fType,
-	IN  GT_AVB_FRAME_POLICY		policy
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
 );
 
-/* Amber QAV API */
-/*******************************************************************************/
-/* Amber QAV API */
 /*******************************************************************************
-* gqavSetPortQpriXQTSToken
+* gqavGetGlobalIsoLoDisCtr
 *
 * DESCRIPTION:
-*		This routine set Priority Queue 0-3 time slot tokens on a port.
-*		The setting value is number of tokens that need to be subtracted at each 
-*		QTS interval boundary.
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous lo packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		port	- the logical port number
-*		queue	 - 0 - 3
-*		qtsToken - number of tokens.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        disCtr - upcounter of number of isochronous lo packets discarded 
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetPortQpriXQTSToken
+GT_STATUS gqavGetGlobalIsoLoDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	IN  GT_U16		qtsToken
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
 );
 
 /*******************************************************************************
-* gqavGetPortQpriXQTSToken
+* gsysSetUseIpMappingTable
 *
 * DESCRIPTION:
-*		This routine get Priority Queue 0-3 time slot tokens on a port.
-*		The setting value is number of tokens that need to be subtracted at each 
-*		QTS interval boundary.
+*        This API set to use IP Frame Priorities from this table. 
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
 *
 * INPUTS:
-*		port	- the logical port number
-*		queue - 0 - 3
+*        en    - [GT_TRUE] / [GT_FALSE]
 *
 * OUTPUTS:
-*		qtsToken - number of tokens
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetPortQpriXQTSToken
+GT_STATUS gsysSetUseIpMappingTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	OUT GT_U16		*qtsToken
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            en
 );
 
 /*******************************************************************************
-* gqavSetPortQpriXBurstBytes
+* gsysGetUseIpMappingTable
 *
 * DESCRIPTION:
-*		This routine set Priority Queue 0-3 Burst Bytes on a port.
-*		This value specifies the number of credits in bytes that can be 
-*		accumulated when the queue is blocked from sending out a frame due to 
-*		higher priority queue frames being sent out.
+*        This API get to use IP Frame Priorities from this table. 
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
 *
 * INPUTS:
-*		port	- the logical port number
-*		queue - 0 - 3
-*		burst - number of credits in bytes .
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        en    - [GT_TRUE] / [GT_FALSE]
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetPortQpriXBurstBytes
+GT_STATUS gsysGetUseIpMappingTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	IN  GT_U16		burst
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            *en
 );
 
 /*******************************************************************************
-* gqavGetPortQpriXBurstBytes
+* gsysSetIpMappingPrio
 *
 * DESCRIPTION:
-*		This routine get Priority Queue 0-3 Burst Bytes on a port.
-*		This value specifies the number of credits in bytes that can be 
-*		accumulated when the queue is blocked from sending out a frame due to 
-*		higher priority queue frames being sent out.
+*        Set IPv4 and IPv6 Frame Priority Mapping, and 
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
+*        is configured to use IP FPris.
+*       The ipQpri value is used as the frames initial QPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
+*        registers (Port offset 0x04) are configured to use IP QPris.
 *
 * INPUTS:
-*		port	- the logical port number
-*		queue	- 0 - 3
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
 *
 * OUTPUTS:
-*		burst - number of credits in bytes .
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetPortQpriXBurstBytes
+GT_STATUS gsysSetIpMappingPrio
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	OUT GT_U16		*burst
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            ipFpri,
+    IN  GT_U8            ipQpri
 );
 
 /*******************************************************************************
-* gqavSetPortQavEnable
+* gsysGetIpMappingPrio
 *
 * DESCRIPTION:
-*		This routine set QAV enable status on a port.
+*        Get IPv4 and IPv6 Frame Priority Mapping, and 
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frames initial FPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
+*        is configured to use IP FPris.
+*        The ipQpri value is used as the frames initial QPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
+*        registers (Port offset 0x04) are configured to use IP QPris.
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
 *
 * OUTPUTS:
-*		None.
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gqavSetPortQavEnable
+GT_STATUS gsysGetIpMappingPrio
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *ipFpri,
+    OUT  GT_U8            *ipQpri
 );
 
 /*******************************************************************************
-* gqavGetPortQavEnable
+* gsysReadEeprom
 *
 * DESCRIPTION:
-*		This routine get QAV enable status on a port.
+*        Read EEPROM from EEPROMs address where the EEOp is performed.
 *
 * INPUTS:
-*		port	- the logical port number
+*        addr - EEPROM Address. 
 *
 * OUTPUTS:
-*		en		- GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*        data -  Data that was read back from the EEPROM.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetPortQavEnable
+GT_STATUS gsysReadEeprom
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    OUT  GT_U8            *data
 );
 
-/*******************************************************************************/
-/* QAV Global registers processing */
 /*******************************************************************************
-* gqavSetGlobalAdminMGMT
+* gsysWriteEeprom
 *
 * DESCRIPTION:
-*		This routine set to accept Admit Management Frames always.
+*        Write EEPROM at the EEPROMs address where the EEOp is performed.
 *
 * INPUTS:
-*		en - GT_TRUE to set MGMT frame accepted always, 
-*			 GT_FALSE do not set MGMT frame accepted always
+*        addr - EEPROM Address. 
+*        data - Data to be written to the EEPROM
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalAdminMGMT
+GT_STATUS gsysWriteEeprom
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    IN  GT_U8            data
 );
 
 /*******************************************************************************
-* gqavGetGlobalAdminMGMT
+* gsysRestartEeprom
 *
 * DESCRIPTION:
-*		This routine get setting of Admit Management Frames always.
+*        Restart Register Loader execution at the EEPROMs address where the EEOp 
+*        is performed
 *
 * INPUTS:
-*		None.
+*        addr - EEPROM Address. .
 *
 * OUTPUTS:
-*		en - GT_TRUE to set MGMT frame accepted always, 
-*			 GT_FALSE do not set MGMT frame accepted always
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalAdminMGMT
+GT_STATUS gsysRestartEeprom
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoPtrThreshold
+* gsysHaltEeprom
 *
 * DESCRIPTION:
-*		This routine set Global Isochronous Queue Pointer Threshold.
-*		This field indicates the total number of isochronous pointers 
-*		that are reserved for isochronous streams. The value is expected to be 
-*		computed in SRP software and programmed into hardware based on the total 
-*		aggregate isochronous streams configured to go through this device..
+*        Halt (stop executing the EEPROM if its not already stopped)
 *
 * INPUTS:
-*		isoPtrs -  total number of isochronous pointers 
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoPtrThreshold
+GT_STATUS gsysHaltEeprom
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		isoPtrs
+    IN  GT_QD_DEV         *dev
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoPtrThreshold
+* gsysGetStEeprom
 *
 * DESCRIPTION:
-*		This routine get Global Isochronous Queue Pointer Threshold.
-*		This field indicates the total number of isochronous pointers 
-*		that are reserved for isochronous streams. The value is expected to be 
-*		computed in SRP software and programmed into hardware based on the total 
-*		aggregate isochronous streams configured to go through this device..
+*        Get EEPROM status. They are Register Loader Running status and EEPROM 
+*        Write Enable status
+*        runSt is GT_TRUE: Register Loader Running, whenever the register loader 
+*            is busy executing the instructions contained in the EEPROM.
+*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to 
+*            the EEPROM is possible. 
+*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
+*            This reflects the value of the EE_WE configuration pin after Reset.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		isoPtrs -  total number of isochronous pointers 
+*        runSt   -   [GT_TRUE] / [GT_FALSE)
+*        writeEn -   [GT_TRUE] / [GT_FALSE)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoPtrThreshold
+GT_STATUS gsysGetStEeprom
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*isoPtrs
+    IN  GT_QD_DEV         *dev,
+    OUT GT_BOOL            *writeEn,
+    OUT GT_BOOL            *runSt
 );
 
 /*******************************************************************************
-* gqavSetGlobalDisQSD4MGMT
+* gsysSetScratchMiscCtrl
 *
 * DESCRIPTION:
-*		This routine set Disable Queue Scheduler Delays for Management frames..
+*        Set Scratch and Misc control data to the Scratch and Misc Control register. 
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
 *
 * INPUTS:
-*		en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
-*			Scheduler Delays and the corresponding rate regulator does not account
-*			for MGMT frames through this queue.
-*			GT_FALSE, the MGMT frames follow similar rate regulation and delay
-*			regulation envelope as specified for the isochronous queue that the
-*			MGMT frames are sharing with.
+*        point - Pointer to the Scratch and Misc. Control register.
+*        data  - Scratch and Misc. Control data written to the register 
+*                pointed to by the point above.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalDisQSD4MGMT
+GT_STATUS gsysSetScratchMiscCtrl
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            data
 );
 
 /*******************************************************************************
-* gqavGetGlobalDisQSD4MGMT
+* gsysGetScratchMiscCtrl
 *
 * DESCRIPTION:
-*		This routine Get Disable Queue Scheduler Delays for Management frames..
+*        Get Scratch and Misc control data from the Scratch and Misc Control register. 
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
+
 *
 * INPUTS:
-*		None.
+*        point - Pointer to the Scratch and Misc. Control register.
 *
 * OUTPUTS:
-*		en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
-*			Scheduler Delays and the corresponding rate regulator does not account
-*			for MGMT frames through this queue.
-*			GT_FALSE, the MGMT frames follow similar rate regulation and delay
-*			regulation envelope as specified for the isochronous queue that the
-*			MGMT frames are sharing with.
+*        data - Scratch and Misc. Control data read from the register 
+*                pointed to by the point above.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalDisQSD4MGMT
+GT_STATUS gsysGetScratchMiscCtrl
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *data
 );
 
 /*******************************************************************************
-* gqavSetGlobalInterrupt
+* gsysSetScratchBits
 *
 * DESCRIPTION:
-*		This routine set QAV interrupt enable, 
-*		The QAV interrypts include:
-*		[GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
-*		[GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
-*		[GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
-*		[GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
-*											  Interrupt Enable 
+*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired. 
+*        These bits do not connect to any hardware function.
 *
 * INPUTS:
-*		intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
-*				[GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
+*        scritch - written bits.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalInterrupt
+GT_STATUS gsysSetScratchBits
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		intEn
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U16            scratch
 );
 
 /*******************************************************************************
-* gqavGetGlobalInterrupt
+* gsysGetScratchBits
 *
 * DESCRIPTION:
-*       This routine get QAV interrupt status and enable status, 
-*		The QAV interrypt status include:
-*		 [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded  
-*		 [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status   
-*		 [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status 
-*		 [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
-*											    Interrupt Status 
-*		The QAV interrypt enable status include:
-*		 [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
-*		 [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
-*												  Interrupt Enable 
+*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired. 
+*        These bits do not connect to any hardware function.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR     
-*				[GT_QAV_INT_STATUS_ISO_DEL_BIT] OR   
-*				[GT_QAV_INT_STATUS_ISO_DIS_BIT] OR   
-*				[GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
-*				[GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
-*				[GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
+*        scritch - read bits.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalInterrupt
+GT_STATUS gsysGetScratchBits
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*intEnSt
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U16            *scratch
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoInterruptPort
+* gsysSetGpioConfigMod
 *
 * DESCRIPTION:
-*		This routine get Isochronous interrupt port.
-*		This field indicates the port number for IsoDisInt or IsoLimitExInt 
-*		bits. Only one such interrupt condition can be detected by hardware at one 
-*		time. Once an interrupt bit has been set along with the IsoIntPort, the 
-*		software would have to come and clear the bits before hardware records 
-*		another interrupt event.
+*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
+*        to configure GPIO mode.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only. 
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
 *
 * INPUTS:
-*		None.
+*        mode - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*		port - port number for IsoDisInt or IsoLimitExInt bits.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoInterruptPort
+GT_STATUS gsysSetGpioConfigMod
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*port
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            mode
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoDelayLmt
+* gsysGetGpioConfigMod
 *
 * DESCRIPTION:
-*		This routine set Isochronous queue delay Limit
-*		This field represents a per-port isochronous delay limit that 
-*		will be checked by the queue controller logic to ensure no isochronous 
-*		packets suffer more than this delay w.r.t to their eligibility time slot.
-*		This represents the number of Queue Time Slots. The interval for the QTS 
-*		can be configured using the register in Qav Global Configuration, Offset 0x2.
+*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only. 
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
 *
 * INPUTS:
-*		limit - per-port isochronous delay limit.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        mode - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoDelayLmt
+GT_STATUS gsysGetGpioConfigMod
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		limit
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *mode
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoDelayLmt
+* gsysSetGpioDirection
 *
 * DESCRIPTION:
-*		This routine get Isochronous queue delay Limit
-*		This field represents a per-port isochronous delay limit that 
-*		will be checked by the queue controller logic to ensure no isochronous 
-*		packets suffer more than this delay w.r.t to their eligibility time slot.
-*		This represents the number of Queue Time Slots. The interval for the QTS 
-*		can be configured using the register in Qav Global Configuration, Offset 0x2.
+*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0]. 
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*		None.
+*        dir - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*		limit - per-port isochronous delay limit.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoDelayLmt
+GT_STATUS gsysSetGpioDirection
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*limit
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            dir
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoMonEn
+* gsysGetGpioDirection
 *
 * DESCRIPTION:
-*       This routine set Isochronous monitor enable
-*		Set GT_TRUE: this bit enables the statistics gathering capabilities stated
-*		in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
-*		software is expected to program the IsoMonPort (PTP Global Status Offset
-*		0xD) indicating which port of the device does the software wants to monitor.
-*		Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
-*		IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
-*		set to a zero.
-*		Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*        get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0]. 
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*		en - GT_TRUE / GT_FALSE.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        dir - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoMonEn
+GT_STATUS gsysGetGpioDirection
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U32            *dir
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoMonEn
+* gsysSetGpioData
 *
 * DESCRIPTION:
-*		This routine get Isochronous monitor enable
-*		Set GT_TRUE: this bit enables the statistics gathering capabilities stated
-*		in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
-*		software is expected to program the IsoMonPort (PTP Global Status Offset
-*		0xD) indicating which port of the device does the software wants to monitor.
-*		Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
-*		IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
-*		set to a zero.
-*		Set GT_FALSE: this bit disables the statistics gathering capabilities.
+*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go 
+*        to a holding register but will not appear on the pin nor in this register. 
+*        Reads of this register will return the actual, real-time, data that is 
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go 
+*        to a holding register and will appear on the GPIOs pin. Reads of this register 
+*        will return the actual, real-time, data that is appearing on the GPIOs pin 
+*        (which in this case should be the data written, but if its isnt that would 
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written 
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*		None.
+*        data - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*		en - GT_TRUE / GT_FALSE.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoMonEn
+GT_STATUS gsysSetGpioData
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            data
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoMonPort
+* gsysGetGpioData
 *
 * DESCRIPTION:
-*		This routine set Isochronous monitoring port.
-*		This field is updated by software along with Iso Mon En bit 
-*		(Qav Global Status, offset 0xD) and it indicates the port number that 
-*		the software wants the hardware to start monitoring i.e., start updating 
-*		IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
-*		the above stats when IsoMonPort is changed..
+*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go 
+*        to a holding register but will not appear on the pin nor in this register. 
+*        Reads of this register will return the actual, real-time, data that is 
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go 
+*        to a holding register and will appear on the GPIOs pin. Reads of this register 
+*        will return the actual, real-time, data that is appearing on the GPIOs pin 
+*        (which in this case should be the data written, but if its isnt that would 
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written 
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*		port -  port number .
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        data - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoMonPort
+GT_STATUS gsysGetGpioData
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		port
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *data
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoMonPort
+* gsysGetConfigData
 *
 * DESCRIPTION:
-*		This routine get Isochronous monitoring port.
-*		This field is updated by software along with Iso Mon En bit 
-*		(Qav Global Status, offset 0xD) and it indicates the port number that 
-*		the software wants the hardware to start monitoring i.e., start updating 
-*		IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
-*		the above stats when IsoMonPort is changed..
-*
-* INPUTS:
-*		None.
+*        Get Reset Configuration Pin Data 0-3. 
+*        These registers return the values observed after a hardware Reset on the 
+*        listed CONFIG data listed below.
+*            Config data 0:
+*              Bit    Config    Pin's Primary Name
+*                0    USER[0]        P6_OUTD[5]
+*                1    USER[1]        P6_OUTD[6]
+*                2    USER[2]        P6_OUTD[7]
+*                3    ADDR[0]        P5_OUTD[0]
+*                4    ADDR[1]        P5_OUTD[5]
+*                5    ADDR[2]        P5_OUTD[6]
+*                6    ADDR]3]        P5_OUTD[7]
+*                7    ADDR[4]        P5_OUTD[1]
+*            Config data 1:
+*                0    LED_SEL[0]    P1_LED
+*                1    LED_SEL[1]    P2_LED
+*                2    4COL P3_LED
+*                3    NormCx        P4_LED
+*                4    Jumbo        P0_LED
+*                5    EE_WE        EE_CS/C2_LED
+*                6    FD_FLOW        EE_CLK/C1_LED
+*                7    HD_FLOW        EE_DIN/C0_LED
+*            Config data 2:
+*                0    P5_MODE[0]    P5_OUTD[2]
+*                1    P5_MODE[1]    P5_OUTD[3]
+*                2    P5_MODE[2]    P5_OUTD[4]
+*                3    Reserved for future use
+*                4    P6_MODE[0]    P6_OUTD[2]
+*                5    P6_MODE[1]    P6_OUTD[3]
+*                6    P6_MODE[2]    P6_OUTD[4]
+*                7    Reserved for future use
+*            Config data 3:
+*                0    RMU_MODE[0] P6_OUTD[0]
+*                1    RMU_MODE[1] P6_OUTD[1]
+*                2    S_VDDOS[0]    PTP_TRIG 
+*                3    CLK125EN    CLK125
+*                4    P5_VDDOS[0] P5_GTXCLK
+*                5    P5_VDDOS[1] P5_OUTEN
+*                6    P6_VDDOS[0] P5_GTXCLK
+*                7    P6_VDDOS[1] P6_OUTEN
+* INPUTS:
+*        None.
 *
 * OUTPUTS:
-*		port -  port number.
+*       cfgDat - GT_CONFIG_DTTA
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoMonPort
+GT_STATUS gsysGetConfigData
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*port
+    IN  GT_QD_DEV             *dev,
+    OUT  GT_CONFIG_DATA        *cfgData
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoHiDisCtr
+* gsysSetSyncETai
 *
 * DESCRIPTION:
-*		This routine set Isochronous hi queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous hi packets discarded 
-*		by Queue Controller.
+*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
 *
 * INPUTS:
-*		disCtr - upcounter of number of isochronous hi packets discarded 
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoHiDisCtr
+GT_STATUS gsysSetSyncETai
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		disCtr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoHiDisCtr
+* gsysGetSyncETai
 *
 * DESCRIPTION:
-*		This routine get Isochronous hi queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous hi packets discarded 
-*		by Queue Controller.
+*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		disCtr - upcounter of number of isochronous hi packets discarded 
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI*
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoHiDisCtr
+GT_STATUS gsysGetSyncETai
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*disCtr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 );
 
 /*******************************************************************************
-* gqavSetGlobalIsoLoDisCtr
+* gsysSetP6_Clock
 *
 * DESCRIPTION:
-*		This routine set Isochronous Lo queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous lo packets discarded 
-*		by Queue Controller.
+*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
 *
 * INPUTS:
-*		disCtr - upcounter of number of isochronous lo packets discarded 
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavSetGlobalIsoLoDisCtr
+GT_STATUS gsysSetP6_Clock
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		disCtr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 );
 
 /*******************************************************************************
-* gqavGetGlobalIsoLoDisCtr
+* gsysGetP6_Clock
 *
 * DESCRIPTION:
-*		This routine set Isochronous Lo queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous lo packets discarded 
-*		by Queue Controller.
+*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		disCtr - upcounter of number of isochronous lo packets discarded 
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetGlobalIsoLoDisCtr
+GT_STATUS gsysGetP6_Clock
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*disCtr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 );
 
 /*******************************************************************************
-* gsysSetUseIpMappingTable
+* gsysSetP5_Clock
 *
 * DESCRIPTION:
-*		This API set to use IP Frame Priorities from this table. 
-*		Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
-*			initial IP_FPRI use Ip Mappingg table priorities.
-*		Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
-*			frames initial IP_FPRI is generated by using the frames IP_QPRI
-*			as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
-*			from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
 *
 * INPUTS:
-*		en	- [GT_TRUE] / [GT_FALSE]
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gsysSetUseIpMappingTable
+GT_STATUS gsysSetP5_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_BOOL			en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 );
 
 /*******************************************************************************
-* gsysGetUseIpMappingTable
+* gsysGetP5_Clock
 *
 * DESCRIPTION:
-*		This API get to use IP Frame Priorities from this table. 
-*		Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
-*			initial IP_FPRI use Ip Mappingg table priorities.
-*		Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
-*			frames initial IP_FPRI is generated by using the frames IP_QPRI
-*			as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
-*			from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en	- [GT_TRUE] / [GT_FALSE]
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gsysGetUseIpMappingTable
+GT_STATUS gsysGetP5_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_BOOL			*en
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 );
 
 /*******************************************************************************
-* gsysSetIpMappingPrio
+* gsysSetEEPROM
 *
 * DESCRIPTION:
-*		Set IPv4 and IPv6 Frame Priority Mapping, and 
-*		IPv4 and IPv6 Queue Priority Mapping.
-*       The ipFpri value is used as the frames initial FPRI when the frame is 
-*		an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
-*		is configured to use IP FPris.
-*       The ipQpri value is used as the frames initial QPRI when the frame is 
-*		an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
-*		registers (Port offset 0x04) are configured to use IP QPris.
+*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
 *
 * INPUTS:
-*		point - Pointer to the Ip Mapping Table.
-*				0 - 0x3f;
-*		ipFpri -  The value is 0 - 7
-*		ipQpri -  The value is 0 - 3.
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gsysSetIpMappingPrio
+GT_STATUS gsysSetEEPROM
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    IN  GT_U8			ipFpri,
-    IN  GT_U8			ipQpri
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            dsm,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 );
 
 /*******************************************************************************
-* gsysGetIpMappingPrio
+* gsysGetEEPROM
 *
 * DESCRIPTION:
-*		Get IPv4 and IPv6 Frame Priority Mapping, and 
-*		IPv4 and IPv6 Queue Priority Mapping.
-*       The ipFpri value is used as the frames initial FPRI when the frame is 
-*		an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
-*		is configured to use IP FPris.
-*		The ipQpri value is used as the frames initial QPRI when the frame is 
-*		an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
-*		registers (Port offset 0x04) are configured to use IP QPris.
+*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
 *
 * INPUTS:
-*		point - Pointer to the Ip Mapping Table.
-*				0 - 0x3f;
+*        None.
 *
 * OUTPUTS:
-*		ipFpri -  The value is 0 - 7
-*		ipQpri -  The value is 0 - 3.
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None
 *
 *******************************************************************************/
-GT_STATUS gsysGetIpMappingPrio
+GT_STATUS gsysGetEEPROM
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    OUT  GT_U8			*ipFpri,
-    OUT  GT_U8			*ipQpri
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *dsm,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 );
 
+
+/* gtAdvVct.c */
+
 /*******************************************************************************
-* gsysReadEeprom
+* gvctGetAdvCableDiag
 *
 * DESCRIPTION:
-*		Read EEPROM from EEPROMs address where the EEOp is performed.
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
 *
 * INPUTS:
-*		addr - EEPROM Address. 
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
 *
 * OUTPUTS:
-*		data -  Data that was read back from the EEPROM.
+*       cableStatus - the port copper cable status.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
 *
 *******************************************************************************/
-GT_STATUS gsysReadEeprom
+GT_STATUS gvctGetAdvCableDiag
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr,
-    OUT  GT_U8			*data
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
 );
 
 /*******************************************************************************
-* gsysWriteEeprom
+* gvctGetAdvExtendedStatus
 *
 * DESCRIPTION:
-*		Write EEPROM at the EEPROMs address where the EEOp is performed.
+*        This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        DSP based cable length is also provided.
 *
 * INPUTS:
-*		addr - EEPROM Address. 
-*		data - Data to be written to the EEPROM
+*       dev  - pointer to GT driver structure returned from mdLoadDriver
+*       port - logical port number.
 *
 * OUTPUTS:
-*		None.
+*       extendedStatus - the extended cable status.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys 
+*            in 88E6165 family and 88E6351 family devices
 *
 *******************************************************************************/
-GT_STATUS gsysWriteEeprom
+GT_STATUS gvctGetAdvExtendedStatus
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr,
-    IN  GT_U8			data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
 );
 
+#ifdef CONFIG_AVB_FPGA
+
 /*******************************************************************************
-* gsysRestartEeprom
+* gptpGetFPGAIntStatus
 *
 * DESCRIPTION:
-*		Restart Register Loader execution at the EEPROMs address where the EEOp 
-*		is performed
+*       This routine gets interrupt status of PTP logic.
 *
 * INPUTS:
-*		addr - EEPROM Address. .
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        ptpInt    - PTP Int Status
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysRestartEeprom
+GT_STATUS gptpGetFPGAIntStatus
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
 );
 
 /*******************************************************************************
-* gsysHaltEeprom
+* gptpSetFPGAIntStatus
 *
 * DESCRIPTION:
-*		Halt (stop executing the EEPROM if its not already stopped)
+*       This routine sets interrupt status of PTP logic.
 *
 * INPUTS:
-*		None.
+*    ptpInt    - PTP Int Status
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysHaltEeprom
+GT_STATUS gptpSetFPGAIntStatus
 (
-    IN  GT_QD_DEV 		*dev
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
 );
 
 /*******************************************************************************
-* gsysGetStEeprom
+* gptpSetFPGAIntEn
 *
 * DESCRIPTION:
-*		Get EEPROM status. They are Register Loader Running status and EEPROM 
-*		Write Enable status
-*		runSt is GT_TRUE: Register Loader Running, whenever the register loader 
-*			is busy executing the instructions contained in the EEPROM.
-*		writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to 
-*			the EEPROM is possible. 
-*		writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
-*			This reflects the value of the EE_WE configuration pin after Reset.
+*       This routine enables PTP interrupt.
 *
 * INPUTS:
-*		None.
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
 *
 * OUTPUTS:
-*		runSt   -   [GT_TRUE] / [GT_FALSE)
-*		writeEn -   [GT_TRUE] / [GT_FALSE)
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetStEeprom
+GT_STATUS gptpSetFPGAIntEn
 (
-    IN  GT_QD_DEV 		*dev,
-	OUT GT_BOOL			*writeEn,
-	OUT GT_BOOL			*runSt
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
 );
 
 /*******************************************************************************
-* gsysSetScratchMiscCtrl
+* gptpGetClockSource
 *
 * DESCRIPTION:
-*		Set Scratch and Misc control data to the Scratch and Misc Control register. 
-*		The register of Scratch and Misc control are.
-*				Scratch Byte 0
-*				Scratch Byte 1
-*				GPIO Configuration
-*				Reserved for future use
-*				GPIO Direction
-*				GPIO Data
-*				CONFIG Data 0
-*				CONFIG Data 1
-*				CONFIG Data 2
-*				CONFIG Data 3
-*				SyncE & TAICLK125s Drive
-*				P5s & CLK125s Clock Drive
-*				P6s Clock Drive
-*				EEPROM Pad drive
+*       This routine gets PTP Clock source setup.
 *
 * INPUTS:
-*		point - Pointer to the Scratch and Misc. Control register.
-*		data  - Scratch and Misc. Control data written to the register 
-*				pointed to by the point above.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetScratchMiscCtrl
+GT_STATUS gptpGetClockSource
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    IN  GT_U8			data
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
 );
 
 /*******************************************************************************
-* gsysGetScratchMiscCtrl
+* gptpSetClockSource
 *
 * DESCRIPTION:
-*		Get Scratch and Misc control data from the Scratch and Misc Control register. 
-*		The register of Scratch and Misc control are.
-*				Scratch Byte 0
-*				Scratch Byte 1
-*				GPIO Configuration
-*				Reserved for future use
-*				GPIO Direction
-*				GPIO Data
-*				CONFIG Data 0
-*				CONFIG Data 1
-*				CONFIG Data 2
-*				CONFIG Data 3
-*				SyncE & TAICLK125s Drive
-*				P5s & CLK125s Clock Drive
-*				P6s Clock Drive
-*				EEPROM Pad drive
-
+*       This routine sets PTP Clock source setup.
 *
 * INPUTS:
-*		point - Pointer to the Scratch and Misc. Control register.
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * OUTPUTS:
-*		data - Scratch and Misc. Control data read from the register 
-*				pointed to by the point above.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetScratchMiscCtrl
+GT_STATUS gptpSetClockSource
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    OUT  GT_U8			*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
 );
 
 /*******************************************************************************
-* gsysSetScratchBits
+* gptpGetP9Mode
 *
 * DESCRIPTION:
-*		Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
-*		These bits are 100% available to software for whatever purpose desired. 
-*		These bits do not connect to any hardware function.
+*       This routine gets Port 9 Mode.
 *
 * INPUTS:
-*		scritch - written bits.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetScratchBits
+GT_STATUS gptpGetP9Mode
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U16			scratch
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
 );
 
 /*******************************************************************************
-* gsysGetScratchBits
+* gptpSetP9Mode
 *
 * DESCRIPTION:
-*		Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
-*		These bits are 100% available to software for whatever purpose desired. 
-*		These bits do not connect to any hardware function.
+*       This routine sets Port 9 Mode.
 *
 * INPUTS:
-*		None.
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * OUTPUTS:
-*		scritch - read bits.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetScratchBits
+GT_STATUS gptpSetP9Mode
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U16			*scratch
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
 );
 
 /*******************************************************************************
-* gsysSetGpioConfigMod
+* gptpReset
 *
 * DESCRIPTION:
-*		Set bits to the Scratch and Misc Control register <GPIO Configuration>
-*		to configure GPIO mode.
-*		The bits are shared General Purpose Input Output mode Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*       This routine performs software reset for PTP logic.
 *
 * INPUTS:
-*		mode - OR [GT_GPIO_BIT_x]
+*        None.
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetGpioConfigMod
+GT_STATUS gptpReset
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			mode
+    IN  GT_QD_DEV     *dev
 );
 
 /*******************************************************************************
-* gsysGetGpioConfigMod
+* gptpGetCycleAdjustEn
 *
 * DESCRIPTION:
-*		Get mode from the Scratch and Misc Control register <GPIO Configuration>.
-*		The bits are shared General Purpose Input Output mode Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*       This routine checks if PTP Duty Cycle Adjustment is enabled.
 *
 * INPUTS:
-*		None.
+*       None.
 *
 * OUTPUTS:
-*		mode - OR [GT_GPIO_BIT_x]
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetGpioConfigMod
+GT_STATUS gptpGetCycleAdjustEn
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			*mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
 );
 
 /*******************************************************************************
-* gsysSetGpioDirection
+* gptpSetCycleAdjustEn
 *
 * DESCRIPTION:
-*		Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
-*		The bits are used to control the direction of GPIO[6:0]. 
-*		When a GPIOs bit is set to a one that GPIO will become an input. When a
-*		GPIOs bit is cleared to a zero that GPIO will become an output
-*		General Purpose Input Output direction bits are:
-*		Bit 6 - GT_GPIO_BIT_6
-*		Bit 5 - GT_GPIO_BIT_5
-*		Bit 4 - GT_GPIO_BIT_4
-*		Bit 3 - GT_GPIO_BIT_3
-*		Bit 2 - GT_GPIO_BIT_2
-*		Bit 1 - GT_GPIO_BIT_1
-*		Bit 0 - GT_GPIO_BIT_0
+*       This routine enables/disables PTP Duty Cycle Adjustment.
 *
 * INPUTS:
-*		dir - OR [GT_GPIO_BIT_x]
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetGpioDirection
+GT_STATUS gptpSetCycleAdjustEn
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			dir
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
 );
 
 /*******************************************************************************
-* gsysGetGpioDirection
+* gptpGetCycleAdjust
 *
 * DESCRIPTION:
-*		get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
-*		The bits are used to control the direction of GPIO[6:0]. 
-*		When a GPIOs bit is set to a one that GPIO will become an input. When a
-*		GPIOs bit is cleared to a zero that GPIO will become an output
-*		General Purpose Input Output direction bits are:
-*		Bit 6 - GT_GPIO_BIT_6
-*		Bit 5 - GT_GPIO_BIT_5
-*		Bit 4 - GT_GPIO_BIT_4
-*		Bit 3 - GT_GPIO_BIT_3
-*		Bit 2 - GT_GPIO_BIT_2
-*		Bit 1 - GT_GPIO_BIT_1
-*		Bit 0 - GT_GPIO_BIT_0
+*       This routine gets clock duty cycle adjustment value.
 *
 * INPUTS:
-*		None.
+*       None.
 *
 * OUTPUTS:
-*		dir - OR [GT_GPIO_BIT_x]
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetGpioDirection
+GT_STATUS gptpGetCycleAdjust
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U32			*dir
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
 );
 
 /*******************************************************************************
-* gsysSetGpioData
+* gptpSetCycleAdjust
 *
 * DESCRIPTION:
-*		Set Gpio data to the Scratch and Misc Control register <GPIO data>.
-*		When a GPIOs bit is set to be an input, data written to this bit will go 
-*		to a holding register but will not appear on the pin nor in this register. 
-*		Reads of this register will return the actual, real-time, data that is 
-*		appearing on the GPIOs pin.
-*		When a GPIOs bit is set to be an output, data written to this bit will go 
-*		to a holding register and will appear on the GPIOs pin. Reads of this register 
-*		will return the actual, real-time, data that is appearing on the GPIOs pin 
-*		(which in this case should be the data written, but if its isnt that would 
-*		be an indication of a conflict).
-*		When a pins direction changes from input to output, the data last written 
-*		to the holding register appears on the GPIOs pin
-*		General Purpose Input Output data bits are:
-*		Bit 6 - GT_GPIO_BIT_6
-*		Bit 5 - GT_GPIO_BIT_5
-*		Bit 4 - GT_GPIO_BIT_4
-*		Bit 3 - GT_GPIO_BIT_3
-*		Bit 2 - GT_GPIO_BIT_2
-*		Bit 1 - GT_GPIO_BIT_1
-*		Bit 0 - GT_GPIO_BIT_0
+*       This routine sets clock duty cycle adjustment value.
 *
 * INPUTS:
-*		data - OR [GT_GPIO_BIT_x]
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetGpioData
+GT_STATUS gptpSetCycleAdjust
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
 );
 
 /*******************************************************************************
-* gsysGetGpioData
+* gptpGetPLLEn
 *
 * DESCRIPTION:
-*		get Gpio data to the Scratch and Misc Control register <GPIO data>.
-*		When a GPIOs bit is set to be an input, data written to this bit will go 
-*		to a holding register but will not appear on the pin nor in this register. 
-*		Reads of this register will return the actual, real-time, data that is 
-*		appearing on the GPIOs pin.
-*		When a GPIOs bit is set to be an output, data written to this bit will go 
-*		to a holding register and will appear on the GPIOs pin. Reads of this register 
-*		will return the actual, real-time, data that is appearing on the GPIOs pin 
-*		(which in this case should be the data written, but if its isnt that would 
-*		be an indication of a conflict).
-*		When a pins direction changes from input to output, the data last written 
-*		to the holding register appears on the GPIOs pin
-*		General Purpose Input Output data bits are:
-*		Bit 6 - GT_GPIO_BIT_6
-*		Bit 5 - GT_GPIO_BIT_5
-*		Bit 4 - GT_GPIO_BIT_4
-*		Bit 3 - GT_GPIO_BIT_3
-*		Bit 2 - GT_GPIO_BIT_2
-*		Bit 1 - GT_GPIO_BIT_1
-*		Bit 0 - GT_GPIO_BIT_0
+*       This routine checks if PLL is enabled.
 *
 * INPUTS:
-*		None.
+*       None.
 *
 * OUTPUTS:
-*		data - OR [GT_GPIO_BIT_x]
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
-GT_STATUS gsysGetGpioData
+GT_STATUS gptpGetPLLEn
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			*data
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
 );
 
 /*******************************************************************************
-* gsysGetConfigData
+* gptpSetPLLEn
 *
 * DESCRIPTION:
-*		Get Reset Configuration Pin Data 0-3. 
-*		These registers return the values observed after a hardware Reset on the 
-*		listed CONFIG data listed below.
-*			Config data 0:
-*			  Bit	Config	Pin's Primary Name
-*				0	USER[0]		P6_OUTD[5]
-*				1	USER[1]		P6_OUTD[6]
-*				2	USER[2]		P6_OUTD[7]
-*				3	ADDR[0]		P5_OUTD[0]
-*				4	ADDR[1]		P5_OUTD[5]
-*				5	ADDR[2]		P5_OUTD[6]
-*				6	ADDR]3]		P5_OUTD[7]
-*				7	ADDR[4]		P5_OUTD[1]
-*			Config data 1:
-*				0	LED_SEL[0]	P1_LED
-*				1	LED_SEL[1]	P2_LED
-*				2	4COL P3_LED
-*				3	NormCx		P4_LED
-*				4	Jumbo		P0_LED
-*				5	EE_WE		EE_CS/C2_LED
-*				6	FD_FLOW		EE_CLK/C1_LED
-*				7	HD_FLOW		EE_DIN/C0_LED
-*			Config data 2:
-*				0	P5_MODE[0]	P5_OUTD[2]
-*				1	P5_MODE[1]	P5_OUTD[3]
-*				2	P5_MODE[2]	P5_OUTD[4]
-*				3	Reserved for future use
-*				4	P6_MODE[0]	P6_OUTD[2]
-*				5	P6_MODE[1]	P6_OUTD[3]
-*				6	P6_MODE[2]	P6_OUTD[4]
-*				7	Reserved for future use
-*			Config data 3:
-*				0	RMU_MODE[0] P6_OUTD[0]
-*				1	RMU_MODE[1] P6_OUTD[1]
-*				2	S_VDDOS[0]	PTP_TRIG 
-*				3	CLK125EN	CLK125
-*				4	P5_VDDOS[0] P5_GTXCLK
-*				5	P5_VDDOS[1] P5_OUTEN
-*				6	P6_VDDOS[0] P5_GTXCLK
-*				7	P6_VDDOS[1] P6_OUTEN
-* INPUTS:
-*		None.
+*       This routine enables/disables PLL device.
+*
+* INPUTS:
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
 *
 * OUTPUTS:
-*       cfgDat - GT_CONFIG_DTTA
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       PLL Frequence selection is based on the Clock Recovery PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
-GT_STATUS gsysGetConfigData
+GT_STATUS gptpSetPLLEn
 (
-    IN  GT_QD_DEV 			*dev,
-    OUT  GT_CONFIG_DATA		*cfgData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
 );
 
 /*******************************************************************************
-* gsysSetSyncETai
+* gptpGetDDSReg
 *
 * DESCRIPTION:
-*		Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
+*       This routine gets DDS register data.
 *
 * INPUTS:
-*		zpr - ZPR for SyncE and TAI
-*		znr - ZNR for SyncE and TAI
+*    ddsReg    - DDS Register
 *
 * OUTPUTS:
-*		None.
+*    ddsData    - register data
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetSyncETai
+GT_STATUS gptpGetDDSReg
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
 );
 
 /*******************************************************************************
-* gsysGetSyncETai
+* gptpSetDDSReg
 *
 * DESCRIPTION:
-*		Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
+*       This routine sets DDS register data.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
 *
 * INPUTS:
-*		None.
+*    ddsReg    - DDS Register
+*    ddsData    - register data
 *
 * OUTPUTS:
-*		zpr - ZPR for SyncE and TAI
-*		znr - ZNR for SyncE and TAI*
+*    none
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetSyncETai
+GT_STATUS gptpSetDDSReg
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
 );
 
 /*******************************************************************************
-* gsysSetP6_Clock
+* gptpUpdateDDSReg
 *
 * DESCRIPTION:
-*		Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
+*       This routine updates DDS register data.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
 *
 * INPUTS:
-*		zpr - ZPR for P6_Clock
-*		znr - ZNR for P6_Clock
+*    none
 *
 * OUTPUTS:
-*		None.
+*    none
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetP6_Clock
+GT_STATUS gptpUpdateDDSReg
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV     *dev
 );
 
 /*******************************************************************************
-* gsysGetP6_Clock
+* gptpSetADFReg
 *
 * DESCRIPTION:
-*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
+*       This routine sets ADF4156 register data.
 *
 * INPUTS:
-*		None.
+*    adfData    - register data
 *
 * OUTPUTS:
-*		zpr - ZPR for P6_Clock
-*		znr - ZNR for P6_Clock
+*    none
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetP6_Clock
+GT_STATUS gptpSetADFReg
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
 );
+#endif  /*  CONFIG_AVB_FPGA */
 
+/* gtTCAM.c */
 /*******************************************************************************
-* gsysSetP5_Clock
+* gtcamFlushAll
 *
 * DESCRIPTION:
-*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
+*       This routine is to flush all entries. A Flush All command will initialize 
+*       TCAM Pages 0 and 1, offsets 0x02 to 0x1B to 0x0000, and TCAM Page 2 offset
+*       0x02 to 0x05 to 0x0000 for all TCAM entries with the exception that TCAM 
+*       Page 0 offset 0x02 will be initialized to 0x00FF.
+*
 *
 * INPUTS:
-*		zpr - ZPR for P5_Clock
-*		znr - ZNR for P5_Clock
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetP5_Clock
+GT_STATUS gtcamFlushAll
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV     *dev
 );
 
 /*******************************************************************************
-* gsysGetP5_Clock
+* gtcamFlushEntry
 *
 * DESCRIPTION:
-*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
+*       This routine is to flush a single entry. A Flush a single TCAM entry command 
+*       will write the same values to a TCAM entry as a Flush All command, but it is
+*       done to the selected single TCAM entry only.
+*
 *
 * INPUTS:
-*		None.
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
 *
 * OUTPUTS:
-*		zpr - ZPR for P5_Clock
-*		znr - ZNR for P5_Clock
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetP5_Clock
+GT_STATUS gtcamFlushEntry
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer
 );
 
 /*******************************************************************************
-* gsysSetEEPROM
+* gtcamLoadEntry
 *
 * DESCRIPTION:
-*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*       This routine loads a TCAM entry.
+*    	The load sequence of TCAM entry is critical. Each TCAM entry is made up of
+*       3 pages of data. All 3 pages need to loaded in a particular order for the TCAM 
+*       to operate correctly while frames are flowing through the switch. 
+*       If the entry is currently valid, it must first be flushed. Then page 2 needs 
+*       to be loaded first, followed by page 1 and then finally page 0. 
+*       Each page load requires its own write TCAMOp with these TCAM page bits set 
+*       accordingly. 
 *
 * INPUTS:
-*		dsm - DSM for EEPROM cycle
-*		zpr - ZPR for EEPROM cycle
-*		znr - ZNR for EEPROM cycle
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
 *
 * OUTPUTS:
-*		None.
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysSetEEPROM
+GT_STATUS gtcamLoadEntry
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			dsm,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
 );
 
 /*******************************************************************************
-* gsysGetEEPROM
+* gtcamPurgyEntry
 *
 * DESCRIPTION:
-*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
+*       This routine Purgy a TCAM entry.
 *
 * INPUTS:
-*		None.
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
 *
 * OUTPUTS:
-*		dsm - DSM for EEPROM cycle
-*		zpr - ZPR for EEPROM cycle
-*		znr - ZNR for EEPROM cycle
+*       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*       None
 *
 *******************************************************************************/
-GT_STATUS gsysGetEEPROM
+GT_STATUS gtcamPurgyEntry
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*dsm,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
 );
 
-
-/* gtAdvVct.c */
-
 /*******************************************************************************
-* gvctGetAdvCableDiag
+* gtcamReadTCAMData
 *
 * DESCRIPTION:
-*       This routine perform the advanced virtual cable test for the requested
-*       port and returns the the status per MDI pair.
+*       This routine loads the global 3 offsets 0x02 to 0x1B registers with 
+*       the data found in the TCAM entry and its TCAM page pointed to by the TCAM
+*       entry and TCAM page bits of this register (bits 7:0 and 11:10 respectively.
+*
 *
 * INPUTS:
-*       port - logical port number.
-*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
 *
 * OUTPUTS:
-*       cableStatus - the port copper cable status.
+*        tcamData    - Tcam entry Data
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are supporting this API.
+*       None
 *
 *******************************************************************************/
-GT_STATUS gvctGetAdvCableDiag
+GT_STATUS gtcamReadTCAMData
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_LPORT        port,
-    IN  GT_ADV_VCT_MODE mode,
-    OUT GT_ADV_CABLE_STATUS *cableStatus
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
 );
 
 /*******************************************************************************
-* gvctGetAdvExtendedStatus
+* gtcamGetNextTCAMData
 *
 * DESCRIPTION:
-*		This routine retrieves extended cable status, such as Pair Poloarity,
-*		Pair Swap, and Pair Skew. Note that this routine will be success only
-*		if 1000Base-T Link is up.
-*		DSP based cable length is also provided.
+*       This routine  finds the next higher TCAM Entry number that is valid (i.e.,
+*       any entry whose Page 0 offset 0x02 is not equal to 0x00FF). The TCAM Entry 
+*       register (bits 7:0) is used as the TCAM entry to start from. To find 
+*       the lowest number TCAM Entry that is valid, start the Get Next operation 
+*       with TCAM Entry set to 0xFF.
+*
 *
 * INPUTS:
-*       dev  - pointer to GT driver structure returned from mdLoadDriver
-*       port - logical port number.
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 255)
 *
 * OUTPUTS:
-*       extendedStatus - the extended cable status.
+*        tcamData    - Tcam entry Data
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Supporting Device list:
-*       	88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys 
-*			in 88E6165 family and 88E6351 family devices
+*       None
 *
 *******************************************************************************/
-GT_STATUS gvctGetAdvExtendedStatus
+GT_STATUS gtcamGetNextTCAMData
 (
     IN  GT_QD_DEV     *dev,
-    IN  GT_LPORT   port,
-    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
 );
 
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiSelect.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiSelect.h
new file mode 100755
index 0000000..de2585c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiSelect.h
@@ -0,0 +1,53 @@
+ #include <Copyright.h>
+
+/********************************************************************************
+* msApiSelect.h
+*
+* DESCRIPTION:
+*       API selection for QuarterDeck Device
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*
+*******************************************************************************/
+
+#ifndef __msApiSelect_h
+#define __msApiSelect_h
+
+/* Micro definitions */ 
+/* Customers set self selection for DSDT  in here */
+
+/* DSDT phy API use Mad driver(DSDT/phy) */
+#if 1
+#undef GT_USE_MAD 
+#else
+#define GT_USE_MAD 1
+#endif
+
+/* DSDT uses RMGMT to replace SMI */
+#if 1
+#undef GT_RMGMT_ACCESS 
+#else
+#define GT_RMGMT_ACCESS 1
+#endif
+
+/* Only for Keystone FPGA design of PTP */
+#if 1
+#undef CONFIG_AVB_FPGA 
+#undef CONFIG_AVB_FPGA_2
+#else
+#define CONFIG_AVB_FPGA  1
+#define CONFIG_AVB_FPGA_2 1
+#endif
+
+/* To use port mapping functions in Dev configuration */
+#if 1
+#undef GT_PORT_MAP_IN_DEV 
+#else
+#define GT_PORT_MAP_IN_DEV  1
+#endif
+
+
+
+#endif /* __msApiSelect_h */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiTypes.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiTypes.h
old mode 100644
new mode 100755
index 1f6ff26..3afd0c7
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiTypes.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiTypes.h
@@ -48,9 +48,9 @@ typedef unsigned long  GT_U32;
 typedef unsigned int   GT_UINT; 
 
 typedef union {
-	GT_U8	c[8];
-	GT_U16	s[4];
-	GT_U32	l[2];
+    GT_U8    c[8];
+    GT_U16    s[4];
+    GT_U32    l[2];
 } GT_U64;
 
 
@@ -65,13 +65,13 @@ typedef unsigned int  (*GT_INTFUNCPTR)  (void); /* ptr to function returning int
 
 /* module state */
 typedef enum {
-	GT_STATE_NONE = 0,	/* Uninitialized */
-	GT_STATE_IDLE,		/* Initialized, but not started (or stopped) */
-	GT_STATE_ACTIVE		/* Started */
+    GT_STATE_NONE = 0,    /* Uninitialized */
+    GT_STATE_IDLE,        /* Initialized, but not started (or stopped) */
+    GT_STATE_ACTIVE        /* Started */
 } GT_STATE;
 
 
-#define	GT_ETHERNET_HEADER_SIZE		(6)
+#define    GT_ETHERNET_HEADER_SIZE        (6)
 
 typedef struct
 {
@@ -89,9 +89,9 @@ typedef struct
 /* status / error codes */
 typedef int GT_STATUS;
 
-#define GT_ERROR		   (-1)
-#define GT_OK			   (0x00)	/* Operation succeeded                   */
-#define GT_FAIL			   (0x01)	/* Operation failed                      */
+#define GT_ERROR           (-1)
+#define GT_OK               (0x00)    /* Operation succeeded                   */
+#define GT_FAIL               (0x01)    /* Operation failed                      */
 #define GT_BAD_VALUE       (0x02)   /* Illegal value (general)               */
 #define GT_BAD_PARAM       (0x04)   /* Illegal parameter in function called  */
 #define GT_NOT_FOUND       (0x0B)   /* Item not found                        */
@@ -102,4 +102,8 @@ typedef int GT_STATUS;
 #define GT_ALREADY_EXIST   (0x1B)   /* Tried to create existing item         */
 #define GT_BAD_CPU_PORT    (0x20)   /* Input CPU Port is not valid physical port number */
 
+extern GT_U8 qdLong2Char(GT_U32 data);
+extern GT_U8 qdShort2Char(GT_U16 data);
+extern GT_U16 qdLong2Short(GT_U32 data);
+
 #endif /* MV_TYPES_H */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiWince.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/Include/msApiWince.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/README b/arch/arm/plat-armada/mv_hal/qd-dsdt/README
deleted file mode 100644
index b9b290c..0000000
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/README
+++ /dev/null
@@ -1,393 +0,0 @@
-
-                    DSDT Release version 2.8b
-                   ==========================
-
-Table of Content:
------------------
-1) Release History 
-2) Source Code Organization
-3) General Introduction
-4) HOW TO - Build qdDrv.o for vxWorks
-5) HOW TO - Build qdDrv.lib for WinCE
-6) HOW TO - Build qdDrv.o for Linux
-7) Changes
-8) New APIs
-
-
-1) Release History 
-------------------
-DSDT2.8b.zip - Oct. 2009 Added GPL and BSD license options to copyright header.
-
-DSDT2.8a.zip - Mar. 2009. Bug fixes.
-         1. Bug fixes for SERDES interface configuration.
-         2. VCT fixes for 88E616x, 88E617x, 88E635x internal PHYs.
-         3. Auto Scan issues on 88E617x, 88E635x family.
-         4. msgIdStartBit in GT_PTP_CONFIG is obsolete.
-         5. TRUNK ATU entries for 88E616x, 88E617x, 88E635x are configured properly.
-         6. Port mapping macros with GT_USE_SIMPLE_PORT_MAPPING are casted properly.
-         7. Deleted to support 6095 family for Ingress Rate Limit with Flow control.
-         8. Deleted unused definition in GT_QPRI_TBL_ENTRY.
-         9. Device definition for GT_88E6124, GT_88E6325, GT_88E6371 has been corrected to
-		     GT_88E6125, GT_88E6321, GT_88E6350, respectively.
-
-DSDT2.8.zip - Nov. 2008. added support for 88E6351 family (88E6351,88E6175,88E6124)
-		  1. New APIs are added to support new devices.
-
-DSDT2.7a.zip - March. 2008.
-		  1. Fixed known bugs.
-		  2. Enhanced some of the APIs.
-
-DSDT2.7.zip - May. 2007. added support for 88E6165 family (88E6123,88E6125,88E6140,88E6161)
-		  1. New APIs are added to support new devices.
-		  2. Bug fix
-			GT_PIRL2_DATA structure includes GT_PIRL_COUNT_MODE enum type, 
-			which should be GT_PIRL2_COUNT_MODE.
-			88E6083 support Static Management frame.
-			gprtSetForwardUnknown deals with wrong bit.
-		  3. Removed Diag program that make user confused with missing files.
-
-DSDT2.6b.zip - Jan. 2007.
-		  1. Bug Fixes
-		  2. PIRL Rate Limiting Parameter update
-
-DSDT2.6a.zip - Nov. 2006. added support for 88E6045.
-
-DSDT2.6.zip - Jul. 2006. added support for 88E6097, 88E6096, 88E6046, 88E6047, and 88E6085.
-		  1. New APIs are added to support new devices.
-		  2. Bug fixes those were in 2.6 preliminary release.
-
-DSDT2.6pre.zip - Apr. 2006. added preliminary support for 88E6097.
-		  1. New features are added.
-		  2. Some parameters in the existing APIs are modified to support extended feature.
-
-DSDT2.5b.zip - Jan. 2006.
-		  1. added gtDelay function after disabling PPU
-		  	Since delay function is system/OS dependent, it is required that DSDT user
-		  	fill up the gtDelay function based its platform parameters.
-		  	gtDelay function is located in src\msApi\gtUtils.c
-		  2. Unused GT_STATUS definitions are removed.
-
-DSDT2.5a.zip - Jan. 2006, added support for 88E6122 and 88E6121 and new feature that bypasses
-		  initial device setup, and bug fixes in the previous release.
-		  1. Bypass initial configuration when loading driver.
-		  2. Bug fixes: 
-		  	1) synchronization issues.
-		  	2) port vector of 0xFF was treated as an invalid vector.
-
-DSDT2.5.zip - Nov. 2005, added support for 88E6065, 88E6035, 88E6055, 88E6061, and 88E6031,
-		  and bug fixes in the previous release.
-		  1. New APIs are added to support new devices.
-		  2. Bug fixes: 
-		  	1) gfdbGetAtuEntryNext API returns GT_NO_SUCH when Entry's MAC is Broadcast address.
-		  	2) entryState in GT_ATU_ENTRY follows the definition.
-		  	3) gsysSetTrunkMaskTable API does not overwrite HashTrunk value anymore.
-		  	4) 10/100 FastEthernet Phy Reset occurs along with Speed, Duplex modification.
-
-
-DSDT2.4a.zip - Oct. 2005, added support for 88E6131 and a bug fix.
-		  1. gprtPortPowerDown(gtPhyCtrl.c) didn't work due to reset - reset is not called after PowerDown bit change.
-
-DSDT2.4.zip - Aug. 2005, bug fixes and modifications
-		  1. gprtSetPktGenEnable(gtPhyCtrl.c) didn't work with Serdes Device - resolved.
-		  2. gprtSetPortAutoMode(gtPhyCtrl.c) dropped 1000Mbps Half duplex mode - resolved.
-		  3. gprtGetPhyLinkStatus(gtPhyCtrl.c) returned LinkOn when there is no phy connected - resolved.
-		  4. gprtSetPortDuplexMode(gtPhyCtrl.c) reset 1000M Speed - resolved.
-		  5. gfdbSetAtuSize(gtBrgFdb.c), now, returns GT_NOT_SUPPORT if ATU size of the device 
-		     is not configurable.
-		  6. gprtSetPortLoopback(gtPhyCtrl.c) treats Fast Ethernet Phy and Gigabit Ethernet Phy
-		  	 differently.
-		  7. GT_GET_SERDES_PORT, now, does the error checking.
-		  8. IS_CONFIGURABLE_PHY reads PHY ID and returns the ID
-
-DSDT2.4pre.zip - July. 2005, added support for 88E6108
-		  1. New features are added.
-		  2. Arguments in gprtSetPause and gprtSetPortSpeed are modified to support
-			 1000M Phys.
-		  3. Driver functions are added to support Marvell Alask Phys and to be
-		     expanded easily for the future Phys.
-
-DSDT2.3c.zip - May. 2005,
-		  1. New features in Rev1 or Rev2 of 88E6095 are added
-		  2. gfdbGetAgingTimeout, and gfdbGetLearnEnable are added
-		  3. Bug fixes in grcSetEgressRate and grcSetPri0Rate
-		  4. Resetting TrunkID, when gprtSetTrunkPort is called to disable Trunk, is applied
-		     only to Rev0 of 88E6095 and 88E6185
-
-DSDT2.3b.zip - Mar. 2005, 
-		  1. gstpSetMode function does not modify Port State any more, since STP module
-		     sets the port state. gstpSetMode sets the switch so that it can receive 
-			  BPDU packets.
-		  2. gtLoadDriver clears Rsvd2Cpu and Rsvd2CpuEn bits.
-		  3. TrunkID will be reset when gprtSetTrunkPort is called to disable Trunk.
-		  4. "Check PPU Status in order to verify PPU disabled" is applied to gtVct.c
-
-DSDT2.3a.zip - Jan. 2005, added support for 88E6152, 88E6155, 88E6182, and 88E6092 
-		  devices, removed non-existing devices, and bug fix in 2.3 release.
-		  Fix :
-		  Check PPU Status in order to verify PPU disabled.
-
-DSDT2.3.zip - Nov. 2004, support for 88E6185 and bug fixes in 2.3 preliminary release.
-		  Fixes :
-		  1) Provide some delay after disabling PPU.
-		  2) VCT runs after disabling PPU.
-
-DSDT2.3pre.zip - Nov. 2004, added preliminary support for 88E6185.
-
-DSDT2.2a.zip - Nov. 2004, added semaphore support for MII Access with multi address mode.
-
-DSDT2.2.zip - Oct. 2004, support for 88E6095 and bug fixes in 2.2 preliminary release.
-
-DSDT2.2pre.zip - Sep. 2004, added preliminary support for 88E6095 and work-around for VCT
-		  based on VCT Application Note.
-
-DSDT2.1a.zip - Apr. 2004, support 88E6093 and bug fixes.
-		  Device Driver Package name has been changed from QDDriver to DSDT(Datacom
-		  Same Driver Technology).
-		  Bug Fixes : 
-		  1) DBNum was not correctly handled while getting entry from VTU Table.
-		  2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
-		  3) Correction of 88E6183 RMON Counter Structure and Enum.
-		  4) ATU Interrupt Handling routine
-
-qdDriver2.1-pre.zip - Apr. 2004, added preliminary support for 88E6093 and bug fixes.
-		  Bug Fixes : 
-		  1) DBNum was not incorrectly handled while getting entry from 
-		  VTU Table.
-		  2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
-		
-qdDriver2.0a.zip - Dec. 2003, provides functions, which can read/write  
-		  Switch Port Registers and Switch Global Registers:
-		  gprtGetSwitchReg,
-		  gprtSetSwitchReg,
-		  gprtGetGlobalReg, and
-		  gprtSetGlobalReg
-
-qdDriver2.0.zip - July. 2003, supports Multi Address Mode for upcoming device.
-		  AUTO_SCAN_MODE, MANUAL_MODE, and MULTI_ADDR_MODE are added
-		  to find a QD Family device.
-		  Supports Sapphire (10 port Gigabit switch).
-
-qdDriver1.4a.zip - Apr. 2003, bug fixes.
-		  Bug fixes on portVec in GT_ATU_ENTRY structure, which supported only 
-		  total of 8 ports (defined as GT_U8). It's now defined as GT_U32.
-		  utils.c and testApi.c in Diag directory also modified to support 
-		  the switch with more than 8 ports.
-
-qdDriver1.4.zip - Apr. 2003, added support for Ocatne (6083).
-		  Removed NO-OPs, which created when DBG_PRINT is undefined. 
-		  Bug fixes on gprtSetIGMPSnoop and gprtGetIGMPSnoop functions,
-		  and GT_PRI0_RATE enum type.
-
-qdDriver1.3h.zip - Feb. 2003, added support for Extended Cable Status, 
-		  such as Impediance mismatch, Pair Skew, Pair Swap and Pair Polarity.
-		  Bug fixes on FFox-EG and FFox-XP device ID.
-
-qdDriver1.3g.zip - Dec. 2002, added preliminary support for Octane (6083)
-
-qdDriver1.3.zip - Oct. 2002, added support for ClipperShip (6063)
-		  This driver works with all released devices, including
-		  6051, 6052, 6021, and 6063
-
-qdDriver1.2.zip - Aug. 2002, added support for FullSail (6021)
-				
-qdDriver1.1.zip - June, 2002 OS independent QuarterDeck Driver Release 
-		  Based on 1.0 release, but removed OS dependency. The driver
-		  is designed to work with any OS without code changes.
-
-qdDriver1.0.zip - Feb. 2002, Initial QuaterDeck Driver Release
-		  Based on vxWorks OS, support 6051/6052
-
-
-2) Source Code Organization
---------------------------
-	2.1) src
-		DSDT Driver Suite Source Code.
-
-	2.2) Include directory
-		DSDT Driver Suite Header files and Prototype files
-
-	2.3) Library
-		Object files for DSDT driver Suite
-
-	2.4) Sample
-		Sample Code that shows how to use MSAPIs, e.g., init DSDT, setup VLAN for Home Gateway, etc.
-
-	* The DSDT Driver Suite Source Code is OS independent, and fully supported by Marvell.
-	* The Sample Codes are tested under vxworks, and is provided for reference only.
-
-
-3) General Introduction
------------------------
-
-The DSDT driver suite is standalone program, which is independent of both OS and Platform. 
-As such, applications of MSAPIs need to register platform specific functions. 
-This is done by calling qdLoadDriver function. This function returns a pointer (*dev), 
-which contains the device and platform information. It will then be used for each MSAPI call. 
-
-msApiInit.c file in Diag directory and Sample\Initialization directory demonstrate 
-how you can register those functions.
-
-msApiInit.c
-	qdStart is the main function to initialize DSDT Driver and does the 
-	followings:
-	a) register the platform specific functions. 
-	   1.1 and 1.2 below are required. 1.3 to 1.6 is optional.
-		1.1) readMii - BSP specific MII read function 
-		1.2) writeMii - BSP specific MII write function 
-		1.3) semCreate - OS specific semaphore create function.
-		1.4) semDelete - OS specific semaphore delete function.
-		1.5) semTake - OS specific semaphore take function.
-		1.6) semGive - OS specific semaphore give function.
-
-		Notes) The given example will use DB-88E6218 BSP as an example.
-
-	b) Initialize BSP provided routine (if required).
-
-	c) Calls qdLoadDriver routine.
-		1.1) Input (GT_SYS_CONFIG) - CPU Port Number (Board Specific) and Port Mode 
-		(either 1 for Forwarding mode or 0 for Hardware default mode)
-		1.2) Output (GT_QD_DEV) - Contains all device (QD) and platform specific info.
-		     It will be used for all API calls.
-
-	d) Calls sysEnable (for future use.)
-
-
-4) HOW TO - Build qdDrv.o for vxWorks
--------------------------------------
-
-1. Extract the given ZIP file into c:\DSDT_2.x directory
-   You may change the directory name to your choice, and change the environment variable below accordingly.
-2. Edit setenv.bat file in c:\DSDT_2.x\tools
-3. Modify the following variables according to your setup.
-set USER_BASE=C:\DSDT_2.x
-set PROJ_NAME=qdDrv
-set WIND_BASE=C:\Tornado
-set TARGETCPU=MIPS		;ARM for ARM Cpu
-set WIND_HOST_TYPE=x86-win32
-4. run "setenv"
-5. Change directory to c:\DSDT_2.x\src
-6. run "make"
-7. qdDrv.o and qdDrv.map will be created in c:\DSDT_2.x\Library.
-
-
-5) HOW TO - Build qdDrv.lib for WinCE
--------------------------------------
-
-1. Extract the given ZIP file into c:\DSDT_2.x directory(directory can be changed)
-2. Edit setenv.bat file in c:\DSDT_2.x\tools
-3. Modify the following variables according to your setup.
-set USER_BASE=C:\DSDT_2.x
-set PROJ_NAME=qdDrv
-set TARGETCPU=x86		;MIPSIV for MIPS IV
-set WCEROOT=C:\WINCE400
-
-4. run "setenv WINCE"
-5. Change directory to c:\DSDT_2.x\src
-6. run "make"
-7. qdDrv.lib will be created in c:\DSDT_2.x\Library.
-
-
-6) HOW TO - Build qdDrv.o for Linux
------------------------------------
-
-1. Extract the given ZIP file into $HOME/DSDT_2.x directory(directory can be changed)
-	in Linux system (verified with RedHat 7.3)
-2. Edit setenv file in $HOME/DSDT_2.x/tools
-3. Modify the following variables according to your setup.
-	declare -x USER_BASE=$HOME/DSDT_2.x
-	declare -x PROJ_NAME=qdDrv
-4. run "source setenv"
-5. Change directory to $HOME/DSDT_2.x/src
-6. run "make"
-7. qdDrv.o and qdDrv.map will be created in $HOME/DSDT_2.x/Library.
-
-
-7) Changes
------------
-1. SERDES interface configuration
-	1) APIs in gtPhyCtrl.c can be used for SERDES interface.
-	2) When SERDES interface is accessed, physical SMI address should be used
-	   instead of logical number. This is due to the logical address confliction 
-	   between external phys and SERDES.
-	e.g.) To change the Speed for the first SERDES port (SMI address 0xC)
-		the following API can be used:
-		gprtSetPortSpeed(sw_dev, 0xC, PHY_SPEED_1000_MBPS);
-
-2. VCT for 88E616x, 88E617x, 88E635x
-	1) New APIs added as defined the following section
-
-3. Supports Auto Scan mode for 88E617x, 88E635x devices
-4. msgIdStartBit in GT_PTP_CONFIG is obsolete.
-5. TRUNK ATU entries for 88E616x, 88E617x, 88E635x are configured properly.
-6. Port mapping macros with GT_USE_SIMPLE_PORT_MAPPING are casted properly.
-7. Deleted to support 6095 family for Ingress Rate Limit with Flow control.
-8. Deleted unused definition in GT_QPRI_TBL_ENTRY.
-9. Device definition for GT_88E6124, GT_88E6325, GT_88E6371 has been corrected to
-	GT_88E6125, GT_88E6321, GT_88E6350, respectively.
-
-
-8) New APIs
------------
-
-1. gtAdvVct.c
-
-	1.1) gvctGetAdvCableDiag
-
-	DESCRIPTION
-		This routine perform the advanced virtual cable test (TDR) for the requested
-		port and returns the the status per MDI pair.
-		DSP based cable length is not provided. Please refer to the API, 
-		gvctGetAdvExtendedStatus, for DSP.
-
-	SYNOPSIS
-		GT_STATUS gvctGetAdvCableDiag
-		(
-		    IN  GT_QD_DEV *dev,
-		    IN  GT_LPORT        port,
-		    IN  GT_ADV_VCT_MODE mode,
-		    OUT GT_ADV_CABLE_STATUS *cableStatus
-		)
-
-	ARGUMENTS
-		INPUTS:
-			port - logical port number.
-			mode - advance VCT mode (either First Peak or Maximum Peak)
-
-		OUTPUTS:
-			cableStatus - the copper cable status.
-	
-	RETURNS
-		GT_OK   - on success
-		GT_FAIL - on error
-		GT_NOT_SUPPORTED - if current device does not support this feature.
-
-
-	1.2) gvctGetAdvExtendedStatus
-
-	DESCRIPTION
-		This routine retrieves extended cable status, such as Pair Poloarity,
-		Pair Swap, and Pair Skew. Note that this routine will be success only
-		if 1000Base-T Link is up.
-		DSP based cable length is also provided.
-
-	SYNOPSIS
-		GT_STATUS gvctGetAdvExtendedStatus
-		(
-		    IN  GT_QD_DEV     *dev,
-		    IN  GT_LPORT   port,
-		    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
-		)
-
-
-	ARGUMENTS
-		INPUTS:
-			port - logical port number.
-
-		OUTPUTS:
-			extendedStatus - the extended cable status.
-	
-	RETURNS
-		GT_OK   - on success
-		GT_FAIL - on error
-		GT_NOT_SUPPORTED - if current device does not support this feature.
-	
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/README_SW.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/README_SW.txt
new file mode 100755
index 0000000..22885f8
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/README_SW.txt
@@ -0,0 +1,393 @@
+
+                    Switch driver in DSDT Release version 3.0D
+                   ============================================
+
+Table of Content:
+-----------------
+1) Release History 
+2) Source Code Organization
+3) General Introduction
+4) HOW TO - Build qdDrv.o for vxWorks
+5) HOW TO - Build qdDrv.lib for WinCE
+6) HOW TO - Build qdDrv.o for Linux
+7) HOW TO - Use phy driver (madDrv) in qdDrv.o 
+8) HOW TO - select features in msApiSelect.h  
+9) HOW TO - Build kinds of driver  
+10) Changes - DSDT 3.0B change list
+
+
+1) Release History 
+------------------
+DSDT_3.0D/switch - Jan 10. 2011. 
+          0. update phy.
+DSDT_3.0c/switch - Dec 10. 2010. 
+          0. Added new PTP and TAI feature  of 88E6352.
+          1. Added msApiSelect.h to allow Customer to select DSDT functions.
+          3. Moved port mapping functions into Dev structure, which is selected by Customer. 
+DSDT_3.0B/switch - Nov 16. 2010. 
+          0. Added 88E6352 family.
+          1. Added semaphore for Remote management access.
+          2. Fixed bugs for 88ECxxx.
+          3. Added port mapping functions into system config.
+DSDT_3.0A/switch - Aug 18. 2010. 
+          0. Fixed 6152/6155 port vector.
+          1. Fixed warning problems for long to short.
+          2. Fixed API gatuGetViolation DB Number error.
+DSDT_3.0/switch - May 26. 2010. 
+          0. based on DSDT2.8a.
+          1. Support Marvell F2R (Remote management) function.
+          2. Added device group 1 to extend device number.
+          3. Added to support 88EC0xx.
+          4. Added to use Marvell Phy driver (madDrv).
+          5. Changed name form DSDT* to DSDT*/switch. The name QD is kept to indicate DSDT switch driver. 
+          6. Added to support 88EC0XX and 88E6250 group.
+DSDT2.8a.zip - Jan. 2009. Fixed problem.
+              1. Deleted to support 6095 family for Ingress Rate Limit withFlow control.
+              2. Deleted unused definition in GT_QPRI_TBL_ENTRY.
+DSDT2.8.zip - Nov. 2008. added support for 88E6351 family (88E6351, 88E6175, 88E6124)
+          1. New APIs are added to support new devices.
+
+DSDT2.7a.zip - March. 2008.
+          1. Fixed known bugs.
+          2. Enhanced some of the APIs.
+
+DSDT2.7.zip - May. 2007. added support for 88E6165 family (88E6123, 88E6125, 88E6140, 88E6161)
+          1. New APIs are added to support new devices.
+          2. Bug fix
+            GT_PIRL2_DATA structure includes GT_PIRL_COUNT_MODE enum type, 
+            which should be GT_PIRL2_COUNT_MODE.
+            88E6083 support Static Management frame.
+            gprtSetForwardUnknown deals with wrong bit.
+          3. Removed Diag program that make user confused with missing files.
+
+DSDT2.6b.zip - Jan. 2007.
+          1. Bug Fixes
+          2. PIRL Rate Limiting Parameter update
+
+DSDT2.6a.zip - Nov. 2006. added support for 88E6045.
+
+DSDT2.6.zip - Jul. 2006. added support for 88E6097, 88E6096, 88E6046, 88E6047, and 88E6085.
+          1. New APIs are added to support new devices.
+          2. Bug fixes those were in 2.6 preliminary release.
+
+DSDT2.6pre.zip - Apr. 2006. added preliminary support for 88E6097.
+          1. New features are added.
+          2. Some parameters in the existing APIs are modified to support extended feature.
+
+DSDT2.5b.zip - Jan. 2006.
+          1. added gtDelay function after disabling PPU
+              Since delay function is system/OS dependent, it is required that DSDT user
+              fill up the gtDelay function based its platform parameters.
+              gtDelay function is located in src\msApi\gtUtils.c
+          2. Unused GT_STATUS definitions are removed.
+
+DSDT2.5a.zip - Jan. 2006, added support for 88E6122 and 88E6121 and new feature that bypasses
+          initial device setup, and bug fixes in the previous release.
+          1. Bypass initial configuration when loading driver.
+          2. Bug fixes: 
+              1) synchronization issues.
+              2) port vector of 0xFF was treated as an invalid vector.
+
+DSDT2.5.zip - Nov. 2005, added support for 88E6065, 88E6035, 88E6055, 88E6061, and 88E6031,
+          and bug fixes in the previous release.
+          1. New APIs are added to support new devices.
+          2. Bug fixes: 
+              1) gfdbGetAtuEntryNext API returns GT_NO_SUCH when Entry's MAC is Broadcast address.
+              2) entryState in GT_ATU_ENTRY follows the definition.
+              3) gsysSetTrunkMaskTable API does not overwrite HashTrunk value anymore.
+              4) 10/100 FastEthernet Phy Reset occurs along with Speed, Duplex modification.
+
+
+DSDT2.4a.zip - Oct. 2005, added support for 88E6131 and a bug fix.
+          1. gprtPortPowerDown(gtPhyCtrl.c) didn't work due to reset - reset is not called after PowerDown bit change.
+
+DSDT2.4.zip - Aug. 2005, bug fixes and modifications
+          1. gprtSetPktGenEnable(gtPhyCtrl.c) didn't work with Serdes Device - resolved.
+          2. gprtSetPortAutoMode(gtPhyCtrl.c) dropped 1000Mbps Half duplex mode - resolved.
+          3. gprtGetPhyLinkStatus(gtPhyCtrl.c) returned LinkOn when there is no phy connected - resolved.
+          4. gprtSetPortDuplexMode(gtPhyCtrl.c) reset 1000M Speed - resolved.
+          5. gfdbSetAtuSize(gtBrgFdb.c), now, returns GT_NOT_SUPPORT if ATU size of the device 
+             is not configurable.
+          6. gprtSetPortLoopback(gtPhyCtrl.c) treats Fast Ethernet Phy and Gigabit Ethernet Phy
+               differently.
+          7. GT_GET_SERDES_PORT, now, does the error checking.
+          8. IS_CONFIGURABLE_PHY reads PHY ID and returns the ID
+
+DSDT2.4pre.zip - July. 2005, added support for 88E6108
+          1. New features are added.
+          2. Arguments in gprtSetPause and gprtSetPortSpeed are modified to support
+             1000M Phys.
+          3. Driver functions are added to support Marvell Alask Phys and to be
+             expanded easily for the future Phys.
+
+DSDT2.3c.zip - May. 2005,
+          1. New features in Rev1 or Rev2 of 88E6095 are added
+          2. gfdbGetAgingTimeout, and gfdbGetLearnEnable are added
+          3. Bug fixes in grcSetEgressRate and grcSetPri0Rate
+          4. Resetting TrunkID, when gprtSetTrunkPort is called to disable Trunk, is applied
+             only to Rev0 of 88E6095 and 88E6185
+
+DSDT2.3b.zip - Mar. 2005, 
+          1. gstpSetMode function does not modify Port State any more, since STP module
+             sets the port state. gstpSetMode sets the switch so that it can receive 
+              BPDU packets.
+          2. gtLoadDriver clears Rsvd2Cpu and Rsvd2CpuEn bits.
+          3. TrunkID will be reset when gprtSetTrunkPort is called to disable Trunk.
+          4. "Check PPU Status in order to verify PPU disabled" is applied to gtVct.c
+
+DSDT2.3a.zip - Jan. 2005, added support for 88E6152, 88E6155, 88E6182, and 88E6092 
+          devices, removed non-existing devices, and bug fix in 2.3 release.
+          Fix :
+          Check PPU Status in order to verify PPU disabled.
+
+DSDT2.3.zip - Nov. 2004, support for 88E6185 and bug fixes in 2.3 preliminary release.
+          Fixes :
+          1) Provide some delay after disabling PPU.
+          2) VCT runs after disabling PPU.
+
+DSDT2.3pre.zip - Nov. 2004, added preliminary support for 88E6185.
+
+DSDT2.2a.zip - Nov. 2004, added semaphore support for MII Access with multi address mode.
+
+DSDT2.2.zip - Oct. 2004, support for 88E6095 and bug fixes in 2.2 preliminary release.
+
+DSDT2.2pre.zip - Sep. 2004, added preliminary support for 88E6095 and work-around for VCT
+          based on VCT Application Note.
+
+DSDT2.1a.zip - Apr. 2004, support 88E6093 and bug fixes.
+          Device Driver Package name has been changed from QDDriver to DSDT(Datacom
+          Same Driver Technology).
+          Bug Fixes : 
+          1) DBNum was not correctly handled while getting entry from VTU Table.
+          2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
+          3) Correction of 88E6183 RMON Counter Structure and Enum.
+          4) ATU Interrupt Handling routine
+
+qdDriver2.1-pre.zip - Apr. 2004, added preliminary support for 88E6093 and bug fixes.
+          Bug Fixes : 
+          1) DBNum was not incorrectly handled while getting entry from 
+          VTU Table.
+          2) Member Tag in VTU entry was not defined correctly for 88E6183 family.
+        
+qdDriver2.0a.zip - Dec. 2003, provides functions, which can read/write  
+          Switch Port Registers and Switch Global Registers:
+          gprtGetSwitchReg,
+          gprtSetSwitchReg,
+          gprtGetGlobalReg, and
+          gprtSetGlobalReg
+
+qdDriver2.0.zip - July. 2003, supports Multi Address Mode for upcoming device.
+          AUTO_SCAN_MODE, MANUAL_MODE, and MULTI_ADDR_MODE are added
+          to find a QD Family device.
+          Supports Sapphire (10 port Gigabit switch).
+
+qdDriver1.4a.zip - Apr. 2003, bug fixes.
+          Bug fixes on portVec in GT_ATU_ENTRY structure, which supported only 
+          total of 8 ports (defined as GT_U8). It's now defined as GT_U32.
+          utils.c and testApi.c in Diag directory also modified to support 
+          the switch with more than 8 ports.
+
+qdDriver1.4.zip - Apr. 2003, added support for Ocatne (6083).
+          Removed NO-OPs, which created when DBG_PRINT is undefined. 
+          Bug fixes on gprtSetIGMPSnoop and gprtGetIGMPSnoop functions,
+          and GT_PRI0_RATE enum type.
+
+qdDriver1.3h.zip - Feb. 2003, added support for Extended Cable Status, 
+          such as Impediance mismatch, Pair Skew, Pair Swap and Pair Polarity.
+          Bug fixes on FFox-EG and FFox-XP device ID.
+
+qdDriver1.3g.zip - Dec. 2002, added preliminary support for Octane (6083)
+
+qdDriver1.3.zip - Oct. 2002, added support for ClipperShip (6063)
+          This driver works with all released devices, including
+          6051, 6052, 6021, and 6063
+
+qdDriver1.2.zip - Aug. 2002, added support for FullSail (6021)
+                
+qdDriver1.1.zip - June, 2002 OS independent QuarterDeck Driver Release 
+          Based on 1.0 release, but removed OS dependency. The driver
+          is designed to work with any OS without code changes.
+
+qdDriver1.0.zip - Feb. 2002, Initial QuaterDeck Driver Release
+          Based on vxWorks OS, support 6051/6052
+
+
+2) Source Code Organization
+--------------------------
+    2.1) src
+        Switch Driver Suite Source Code.
+
+    2.2) Include directory
+        Switch Driver Suite Header files and Prototype files
+
+    2.3) Library
+        Object files for Switch driver Suite
+
+    2.4) Sample
+        Sample Code that shows how to use MSAPIs, e.g., init Switch driver, setup VLAN for Home Gateway, etc.
+
+    2.5) Tools
+	Building related files
+
+    2.6) mad 
+        Marvell Phy Driver (madDrv). See mad/README.txt for more detail.	
+
+
+    * The Switch Driver Suite Source Code is OS independent, and fully supported by Marvell.
+    * The Sample Codes are tested under vxworks and Linux, and is provided for reference only.
+
+
+3) General Introduction
+-----------------------
+
+The Switch driver suite is standalone program, which is independent of both OS and Platform. 
+As such, applications of MSAPIs need to register platform specific functions. 
+This is done by calling qdLoadDriver function. This function returns a pointer (*dev), 
+which contains the device and platform information. It will then be used for each MSAPI call. 
+
+msApiInit.c file in Diag directory and Sample\Initialization directory demonstrate 
+how you can register those functions.
+
+msApiInit.c
+    qdStart is the main function to initialize Switch Driver and does the 
+    followings:
+    a) register the platform specific functions. 
+       1.1 and 1.2 below are required.
+       1.3 to 1.4 are for F2R(Remote management), it is selected 
+          by flag GT_RMGMT_ACCESS in IncludemsApiDefs.h.
+       1.5 to 1.8 are optional.
+        1.1) readMii - BSP specific MII read function 
+        1.2) writeMii - BSP specific MII write function 
+        1.3) hwAccessMod - BSP supported function mode 
+        1.4) hwAccess - BSP specific hardware access function 
+        1.5) semCreate - OS specific semaphore create function.
+        1.6) semDelete - OS specific semaphore delete function.
+        1.7) semTake - OS specific semaphore take function.
+        1.8) semGive - OS specific semaphore give function.
+
+        Notes) The given example will use DB-88E6218 BSP as an example.
+
+    b) Initialize BSP provided routine (if required).
+
+    c) Calls qdLoadDriver routine.
+        1.1) Input (GT_SYS_CONFIG) - CPU Port Number (Board Specific) and Port Mode 
+        (either 1 for Forwarding mode or 0 for Hardware default mode)
+        1.2) Output (GT_QD_DEV) - Contains all device (Switch) and platform specific info.
+             It will be used for all API calls.
+
+    d) Calls sysEnable (for future use.)
+
+
+4) HOW TO - Build qdDrv.o for vxWorks
+-------------------------------------
+
+1. Extract the given ZIP file into c:\DSDT_3.x\switch directory
+   You may change the directory name to your choice, and change the environment variable below accordingly.
+2. Edit setenv.bat file in c:\DSDT_3.x\switch\tools
+3. Modify the following variables according to your setup.
+set DSDT_USER_BASE=C:\DSDT_3.x\switch
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE or TRUE
+set WIND_BASE=C:\Tornado
+set TARGETCPU=MIPS        ;ARM for ARM Cpu
+set WIND_HOST_TYPE=x86-win32
+4. run "setenv"
+5. Change directory to c:\DSDT_3.x\switch\src
+6. run "make"
+7. qdDrv.o and qdDrv.map will be created in c:\DSDT_3.x\switch\Library.
+
+
+5) HOW TO - Build qdDrv.lib for WinCE
+-------------------------------------
+
+1. Extract the given ZIP file into c:\DSDT_3.x\switch directory(directory can be changed)
+2. Edit setenv.bat file in c:\DSDT_3.x\switch\tools
+3. Modify the following variables according to your setup.
+set DSDT_USER_BASE=C:\DSDT_3.x\switch
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE or TRUE
+set TARGETCPU=x86        ;MIPSIV for MIPS IV
+set WCEROOT=C:\WINCE400
+
+4. run "setenv WINCE"
+5. Change directory to c:\DSDT_3.x\switch\src
+6. run "make"
+7. qdDrv.lib will be created in c:\DSDT_3.x\switch\Library.
+
+
+6) HOW TO - Build qdDrv.o for Linux
+-----------------------------------
+
+1. Extract the given ZIP file into $HOME/DSDT_3.x/switch directory(directory can be changed)
+ `   in Linux system (verified with Fedore 8.x)
+2. Edit setenv file in $HOME/DSDT_3.x/switch/tools
+3. Modify the following variables according to your setup.
+    declare -x DSDT_USER_BASE=$HOME/DSDT_3.x/switch
+    declare -x DSDT_PROJ_NAME=qdDrv
+    declare -x DSDT_USE_MAD=FALSE or TRUE
+4. run "source setenv"
+5. Change directory to $HOME/DSDT_3.x/switch/src
+6. run "make"
+7. qdDrv.o and qdDrv.map will be created in $HOME/DSDT_3.x/switch/Library.
+
+7) HOW TO - Use Phy driver in qdDrv.o
+-------------------------------------
+
+ The Phy driver(MAD) supports Marvell Phy products. It includes the phys in switch chips. 
+ From DSDT 3.0A, the Switch driver added function to merge MAD driver 
+ to replace original Phy regarded functions. This is an option.
+ There is no any difference from original phy APIs of Switch, when it uses MAD APIs.
+ For old chips, it is selectible to use ether original Phy API function or call MAD functions. The selection is setting global variable <DSDT_USE_MAD> as TRUE or FALSE.
+ Run <make DSDT_USE_MAD=TRUE> to build switch driver with MAD APIs.
+
+8) HOW TO - select features in msApiSelect.h  
+-----------------------------------
+
+ Customer can ignore the selections. The default selections are <undef> for all.
+
+ From DSDT_3.0D, DSDT addes file <msApiSelect.h> in DSDT*.*/Include.
+ The file allows customer to select self features.
+ Now selections are:
+    GT_PORT_MAP_IN_DEV: To use port mapping functions in Dev configuration.
+    GT_RMGMT_ACCESS: DSDT uses RMGMT to replace SMI.
+    GT_USE_MAD: the phy APIs of switch use Mad driver(DSDT/phy).
+
+ If customer wants to use the selection,
+   1. Addes a Micro definition <CHECK_API_SELECT> in customers build enviroment.
+     For example, in <makefile>, addes <CFLAGS += -DCHECK_API_SELECT>.
+   2. In file <Include/msApiSelect>, set correct selections.
+   3. Re-build DSDT/switch.
+  
+
+9) HOW TO - build driver  
+-----------------------------------
+
+ Change directory to $HOME/DSDT_3.x/
+ <make switch>: to build switch driver image only.
+ <make phy>: to build phy driver image only.
+ <make>: to build switch and phy driver images, and switch driver does not use MAD APIs.
+ <make DSDT_USE_MAD=TRUE>: to build switch and phy driver images, and switch driver uses MAD APIs.
+ 
+10) CHANGES
+-----------
+1. Supports Marvell F2R (RMGMT) function.
+   Added one BSP provided function and one BSP function configuration selection 
+   in Device configuration. The new BSP function is HwAccess. It is a read/write integration function, 
+   like Marvell's F2R(RMGMT) access function.
+   The variable HwAccessMode is configuration selection parameter. It indicates 
+   to use SMI or F2R function in BSP.
+   The F2R support can be selected by flag <GT_RMGMT_ACCESS> in Include/msApiDefs.h. 
+   Thw flag GT_RMGMT_ACCESS is useful to compatible backwards.
+   Customer, who do not provider <HwAccess function>, still can set to use GT_RMGMT_ACCESS.
+   The DSDT switch driver include function to allow customer use Read/Write functions only.
+2. Added device group 1 to meet extended requirement of Marvell SOHO switch products.
+3. Added to support new chips 88EC0xx and 6250.
+4. Merged Marvell Phy Driver (MAD). 
+   The qdDriver can use Phy driver to replace the Phy part of the qdDriver.
+   It is selected by flag GT_USE_MAD in Include/msApiDefs.inc. Or it can be set in Makefile.
+5. Added 88E6352 family. Added to support Tcam,WoL/WoF.
+6. Added a new semaphore for Remote management access.
+7. Added port mapping functions into system config.
+8. Sdded <msApiSelect.h> to allow customer to select self features.
+   Customer can set: USE_MAD, PORT_MAP_IN_DEV, USE_RMGMT...
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/mvCompVer.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/mvCompVer.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/802_1q.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/802_1q.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/802.1Q/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/advCableTest.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/advCableTest.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/cableTest.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/cableTest.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CableTest/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c
old mode 100644
new mode 100755
index 7431eb3..79e341a
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/crossChipTrunk.c
@@ -3,12 +3,12 @@
 * crossChipTrunk.c
 *
 * DESCRIPTION:
-*		This sample shows how to setup the Cross Chip TRUNK
-*		
+*        This sample shows how to setup the Cross Chip TRUNK
+*        
 * DEPENDENCIES:
-*		Please check the device's spec. if the device supports this feature.
-*		At the moment this sample was written, 88E6095 was the only device support
-*		this feature.
+*        Please check the device's spec. if the device supports this feature.
+*        At the moment this sample was written, 88E6095 was the only device support
+*        this feature.
 *
 * FILE REVISION NUMBER:
 *
@@ -17,325 +17,331 @@
 
 #include "msSample.h"
 
-#define N_OF_QD_DEVICES	2
-#define MAX_PORT_IN_TRUNK 4
+#define N_OF_QD_DEVICES    2
 
 /* qdMultiDev is defined in sample/MultiDevice/msApiInit.c */
-extern GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES];	
+extern GT_QD_DEV       *qdMultiDev[N_OF_QD_DEVICES];    
+
+/*
+#ifndef TRUNK_MEMBER
+#define MAX_PORT_IN_TRUNK 4
 
 typedef struct _TRUNK_SET {
-	GT_U32	devIndex;
-	GT_U32	port;
+    GT_U32    devIndex;
+    GT_U32    port;
 } TRUNK_SET;
 
 typedef struct _TRUNK_MEMBER {
-	GT_U32	trunkId;
-	GT_U32	nTrunkPort;
-	TRUNK_SET trunkSet[MAX_PORT_IN_TRUNK];
+    GT_U32    trunkId;
+    GT_U32    nTrunkPort;
+    TRUNK_SET trunkSet[MAX_PORT_IN_TRUNK];
 } TRUNK_MEMBER;
 
+#endif
+*/
+
 GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm);
 
 /*
-	Setup Trunk with the following member ports:
-		Port 0,1,2 of Device 0, and
-		Port 0 of Device 1,
-	where Device 0 is the first Switch Device Structure in qdMultiDev array 
-	and Device 1 is the second Switch Device Structure in qdMultiDev array.
+    Setup Trunk with the following member ports:
+        Port 0,1,2 of Device 0, and
+        Port 0 of Device 1,
+    where Device 0 is the first Switch Device Structure in qdMultiDev array 
+    and Device 1 is the second Switch Device Structure in qdMultiDev array.
 */
 GT_STATUS crossChipTrunkSetup()
 {
-	TRUNK_MEMBER tm;
-
-	tm.trunkId = 1;
-	tm.nTrunkPort = 4;
-	tm.trunkSet[0].devIndex = 0;
-	tm.trunkSet[0].port = 0;
-	tm.trunkSet[1].devIndex = 0;
-	tm.trunkSet[1].port = 1;
-	tm.trunkSet[2].devIndex = 0;
-	tm.trunkSet[2].port = 2;
-	tm.trunkSet[3].devIndex = 1;
-	tm.trunkSet[3].port = 0;
-
-	return sampleCrossChipTrunk(qdMultiDev, &tm);
+    TRUNK_MEMBER tm;
+
+    tm.trunkId = 1;
+    tm.nTrunkPort = 4;
+    tm.trunkSet[0].devIndex = 0;
+    tm.trunkSet[0].port = 0;
+    tm.trunkSet[1].devIndex = 0;
+    tm.trunkSet[1].port = 1;
+    tm.trunkSet[2].devIndex = 0;
+    tm.trunkSet[2].port = 2;
+    tm.trunkSet[3].devIndex = 1;
+    tm.trunkSet[3].port = 0;
+
+    return sampleCrossChipTrunk(qdMultiDev, &tm);
 }
 
 GT_STATUS sampleCrossChipTrunk(GT_QD_DEV *dev[], TRUNK_MEMBER* tm)
 {
-	GT_STATUS status;
-	int i,j,index;
-	GT_U32 mask, trunkId;
-	TRUNK_SET* ts;
-	GT_U32 portVec[N_OF_QD_DEVICES];	
-	GT_U32 casecadeVec = 0xC0;	/* Port 6 and 7. ToDo : get this value from user or device */
-
-	/*
-	 *	Enable Trunk for each member of the Trunk and set the Trunk ID (1).
-	*/ 
-
-	printf("Setting TRUNK\n");
-	printf("Trunk ID : %i\n",(unsigned int)tm->trunkId);
-	printf("N Ports  : %i\n",(unsigned int)tm->nTrunkPort);
-	printf("1st Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[0].devIndex,(unsigned int)tm->trunkSet[0].port);
-	printf("2nd Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[1].devIndex,(unsigned int)tm->trunkSet[1].port);
-	printf("3rd Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[2].devIndex,(unsigned int)tm->trunkSet[2].port);
-	printf("4th Port  : Dev %i, Port %i\n",
-			(unsigned int)tm->trunkSet[3].devIndex,(unsigned int)tm->trunkSet[3].port);
-
-	trunkId = tm->trunkId;
-
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-		portVec[i] = 0;
-
-	printf("Enabling TRUNK for each member port.\n");
-	for(i=0; i<tm->nTrunkPort; i++)
-	{
-		ts = &tm->trunkSet[i];
-
-		if(ts->devIndex >= N_OF_QD_DEVICES)
-		{
-			printf("Device %i is supported. Max Device Number is %i\n",(unsigned int)ts->devIndex,N_OF_QD_DEVICES-1);
-			return GT_FAIL;
-		}
-
-		if((dev[ts->devIndex] == NULL) || (!dev[ts->devIndex]->devEnabled))
-		{
-			printf("Device %i is not initialized\n",(unsigned int)ts->devIndex);
-			return GT_FAIL;
-		}
-
-		/* enabled trunk on the given port */
-		if((status = gprtSetTrunkPort(dev[ts->devIndex],ts->port,GT_TRUE,trunkId)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-			return status;
-		}
-
-		portVec[ts->devIndex] |= (1 << ts->port);
-	}
-
-	/*
-	 *	Set Trunk Route Table for the given Trunk ID.
-	*/ 
-	printf("Setting TRUNK Routing Table\n");
-	for(i=0; i<N_OF_QD_DEVICES; i++)
-	{
-		if((dev[i] == NULL) || (!dev[i]->devEnabled))
-		{
-			printf("Device %i is not initialized\n",i);
-			break;
-		}
-
-		if((status = gsysSetTrunkRouting(dev[i],trunkId,portVec[i]|casecadeVec)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-			return status;
-		}
-	}
-
-	/*
-	 *	Set Trunk Mask Table for load balancing.
-	*/ 
-	printf("Setting TRUNK Mask for Load Balancing\n");
-	for(i=0; i<8; i++)
-	{
-		/* choose a port to be used for the given addr combo index */
-		index = i % tm->nTrunkPort;
-		ts = &tm->trunkSet[index];
-		
-		for(j=0; j<N_OF_QD_DEVICES; j++)
-		{
-			if((dev[j] == NULL) || (!dev[j]->devEnabled))
-			{
-				printf("Device %i is not initialized\n",j);
-				continue;
-			}
-
-			if(portVec[j] == 0)
-				continue;
-
-			if((status = gsysGetTrunkMaskTable(dev[j],i,&mask)) != GT_OK)
-			{
-				MSG_PRINT(("gsysGetTrunkMaskTable return Failed\n"));
-				return status;
-			}
-
-			mask &= ~portVec[j];
-
-			if(ts->devIndex == j)
-				mask |= (1 << ts->port);
-			
-			if((status = gsysSetTrunkMaskTable(dev[j],i,mask)) != GT_OK)
-			{
-				MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-				return status;
-			}
-		}
-	}
-	
-	return GT_OK;
+    GT_STATUS status;
+    int i,j,index;
+    GT_U32 mask, trunkId;
+    TRUNK_SET* ts;
+    GT_U32 portVec[N_OF_QD_DEVICES];    
+    GT_U32 casecadeVec = 0xC0;    /* Port 6 and 7. ToDo : get this value from user or device */
+
+    /*
+     *    Enable Trunk for each member of the Trunk and set the Trunk ID (1).
+    */ 
+
+    printf("Setting TRUNK\n");
+    printf("Trunk ID : %i\n",(unsigned int)tm->trunkId);
+    printf("N Ports  : %i\n",(unsigned int)tm->nTrunkPort);
+    printf("1st Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[0].devIndex,(unsigned int)tm->trunkSet[0].port);
+    printf("2nd Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[1].devIndex,(unsigned int)tm->trunkSet[1].port);
+    printf("3rd Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[2].devIndex,(unsigned int)tm->trunkSet[2].port);
+    printf("4th Port  : Dev %i, Port %i\n",
+            (unsigned int)tm->trunkSet[3].devIndex,(unsigned int)tm->trunkSet[3].port);
+
+    trunkId = tm->trunkId;
+
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+        portVec[i] = 0;
+
+    printf("Enabling TRUNK for each member port.\n");
+    for(i=0; i<tm->nTrunkPort; i++)
+    {
+        ts = &tm->trunkSet[i];
+
+        if(ts->devIndex >= N_OF_QD_DEVICES)
+        {
+            printf("Device %i is supported. Max Device Number is %i\n",(unsigned int)ts->devIndex,N_OF_QD_DEVICES-1);
+            return GT_FAIL;
+        }
+
+        if((dev[ts->devIndex] == NULL) || (!dev[ts->devIndex]->devEnabled))
+        {
+            printf("Device %i is not initialized\n",(unsigned int)ts->devIndex);
+            return GT_FAIL;
+        }
+
+        /* enabled trunk on the given port */
+        if((status = gprtSetTrunkPort(dev[ts->devIndex],ts->port,GT_TRUE,trunkId)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+            return status;
+        }
+
+        portVec[ts->devIndex] |= (1 << ts->port);
+    }
+
+    /*
+     *    Set Trunk Route Table for the given Trunk ID.
+    */ 
+    printf("Setting TRUNK Routing Table\n");
+    for(i=0; i<N_OF_QD_DEVICES; i++)
+    {
+        if((dev[i] == NULL) || (!dev[i]->devEnabled))
+        {
+            printf("Device %i is not initialized\n",i);
+            break;
+        }
+
+        if((status = gsysSetTrunkRouting(dev[i],trunkId,portVec[i]|casecadeVec)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+            return status;
+        }
+    }
+
+    /*
+     *    Set Trunk Mask Table for load balancing.
+    */ 
+    printf("Setting TRUNK Mask for Load Balancing\n");
+    for(i=0; i<8; i++)
+    {
+        /* choose a port to be used for the given addr combo index */
+        index = i % tm->nTrunkPort;
+        ts = &tm->trunkSet[index];
+        
+        for(j=0; j<N_OF_QD_DEVICES; j++)
+        {
+            if((dev[j] == NULL) || (!dev[j]->devEnabled))
+            {
+                printf("Device %i is not initialized\n",j);
+                continue;
+            }
+
+            if(portVec[j] == 0)
+                continue;
+
+            if((status = gsysGetTrunkMaskTable(dev[j],i,&mask)) != GT_OK)
+            {
+                MSG_PRINT(("gsysGetTrunkMaskTable return Failed\n"));
+                return status;
+            }
+
+            mask &= ~portVec[j];
+
+            if(ts->devIndex == j)
+                mask |= (1 << ts->port);
+            
+            if((status = gsysSetTrunkMaskTable(dev[j],i,mask)) != GT_OK)
+            {
+                MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+                return status;
+            }
+        }
+    }
+    
+    return GT_OK;
 }
 
 
 
 /*
-	Assumption 1: Device ID, Cascading Port, CPU Port, and Interswitch Port are
-		already set properly. For more information, please refer to the 
-		sample/MultiDevice/msApiInit.c
+    Assumption 1: Device ID, Cascading Port, CPU Port, and Interswitch Port are
+        already set properly. For more information, please refer to the 
+        sample/MultiDevice/msApiInit.c
 
-	Assumption 2: Port 0,1,2 of Device 0 and Port 0 of Device 1 are member of a 
-		trunk with Trunk ID 1.
+    Assumption 2: Port 0,1,2 of Device 0 and Port 0 of Device 1 are member of a 
+        trunk with Trunk ID 1.
 */
 
 GT_STATUS sampleFixedCrossChipTrunk(GT_QD_DEV *dev[])
 {
-	GT_STATUS status;
-	int i;
-	GT_U32 mask, trunkBit, trunkId;
-
-	/*
-	 *	Enable Trunk for each member of the Trunk and set the Trunk ID (1).
-	*/ 
-
-	trunkId = 1;
-
-	if((dev[0] == NULL) || (!dev[0]->devEnabled))
-	{
-		printf("Device 0 is not initialized\n");
-		return GT_FAIL;
-	}
-	if((dev[1] == NULL) || (!dev[1]->devEnabled))
-	{
-		printf("Device 1 is not initialized\n");
-		return GT_FAIL;
-	}
-
-	/* setup for Device 0 port 0 */
-	if((status = gprtSetTrunkPort(dev[0],0,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 0 port 1 */
-	if((status = gprtSetTrunkPort(dev[0],1,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 0 port 2 */
-	if((status = gprtSetTrunkPort(dev[0],2,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 1 port 0 */
-	if((status = gprtSetTrunkPort(dev[1],0,GT_TRUE,trunkId)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
-		return status;
-	}
-
-
-	/*
-	 *	Set Trunk Route Table for the given Trunk ID.
-	*/ 
-
-	/* setup for Device 0, trunk ID 1 : port 0,1,2, and 9 (cascading port, assumption1) */
-	if((status = gsysSetTrunkRouting(dev[0],trunkId,0x7|0x200)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-		return status;
-	}
-
-	/* setup for Device 1, trunk ID 1 : port 0, and 8 (cascading port, assumption1) */
-	if((status = gsysSetTrunkRouting(dev[1],trunkId,0x1|0x100)) != GT_OK)
-	{
-		MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
-		return status;
-	}
-
-
-	/*
-	 *	Set Trunk Mask Table for load balancing.
-	*/ 
-
-	/*
-	   Trunk Mask Table for Device 0:
+    GT_STATUS status;
+    int i;
+    GT_U32 mask, trunkBit, trunkId;
+
+    /*
+     *    Enable Trunk for each member of the Trunk and set the Trunk ID (1).
+    */ 
+
+    trunkId = 1;
+
+    if((dev[0] == NULL) || (!dev[0]->devEnabled))
+    {
+        printf("Device 0 is not initialized\n");
+        return GT_FAIL;
+    }
+    if((dev[1] == NULL) || (!dev[1]->devEnabled))
+    {
+        printf("Device 1 is not initialized\n");
+        return GT_FAIL;
+    }
+
+    /* setup for Device 0 port 0 */
+    if((status = gprtSetTrunkPort(dev[0],0,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 0 port 1 */
+    if((status = gprtSetTrunkPort(dev[0],1,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 0 port 2 */
+    if((status = gprtSetTrunkPort(dev[0],2,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 1 port 0 */
+    if((status = gprtSetTrunkPort(dev[1],0,GT_TRUE,trunkId)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetTrunkPort return Failed\n"));
+        return status;
+    }
+
+
+    /*
+     *    Set Trunk Route Table for the given Trunk ID.
+    */ 
+
+    /* setup for Device 0, trunk ID 1 : port 0,1,2, and 9 (cascading port, assumption1) */
+    if((status = gsysSetTrunkRouting(dev[0],trunkId,0x7|0x200)) != GT_OK)
+    {
+        MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+        return status;
+    }
+
+    /* setup for Device 1, trunk ID 1 : port 0, and 8 (cascading port, assumption1) */
+    if((status = gsysSetTrunkRouting(dev[1],trunkId,0x1|0x100)) != GT_OK)
+    {
+        MSG_PRINT(("gsysSetTrunkRouting return Failed\n"));
+        return status;
+    }
+
+
+    /*
+     *    Set Trunk Mask Table for load balancing.
+    */ 
+
+    /*
+       Trunk Mask Table for Device 0:
  
-						10	9	8	7	6	5	4	3	2	1	0
-	   TrunkMask[0]		1	1	1	1	1	1	1	1	0	0	1
-	   TrunkMask[1]		1	1	1	1	1	1	1	1	0	1	0
-	   TrunkMask[2]		1	1	1	1	1	1	1	1	1	0	0
-	   TrunkMask[3]		1	1	1	1	1	1	1	1	0	0	0
-	   TrunkMask[4]		1	1	1	1	1	1	1	1	0	0	1
-	   TrunkMask[5]		1	1	1	1	1	1	1	1	0	1	0
-	   TrunkMask[6]		1	1	1	1	1	1	1	1	1	0	0
-	   TrunkMask[7]		1	1	1	1	1	1	1	1	0	0	0
-
-
-	   Trunk Mask Table for Device 1:
+                        10    9    8    7    6    5    4    3    2    1    0
+       TrunkMask[0]        1    1    1    1    1    1    1    1    0    0    1
+       TrunkMask[1]        1    1    1    1    1    1    1    1    0    1    0
+       TrunkMask[2]        1    1    1    1    1    1    1    1    1    0    0
+       TrunkMask[3]        1    1    1    1    1    1    1    1    0    0    0
+       TrunkMask[4]        1    1    1    1    1    1    1    1    0    0    1
+       TrunkMask[5]        1    1    1    1    1    1    1    1    0    1    0
+       TrunkMask[6]        1    1    1    1    1    1    1    1    1    0    0
+       TrunkMask[7]        1    1    1    1    1    1    1    1    0    0    0
+
+
+       Trunk Mask Table for Device 1:
  
-						10	9	8	7	6	5	4	3	2	1	0
-	   TrunkMask[0]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[1]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[2]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[3]		1	1	1	1	1	1	1	1	1	1	1
-	   TrunkMask[4]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[5]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[6]		1	1	1	1	1	1	1	1	1	1	0
-	   TrunkMask[7]		1	1	1	1	1	1	1	1	1	1	1
-
-	*/
-
-	/* setup for Device 0 */
-	for(i=0; i<8; i++)
-	{
-		if((i%4) == 3)
-		{
-			trunkBit = 0;
-		}
-		else
-		{
-			trunkBit = 1 << (i%4);
-		}		
-
-		mask = 0x7F8 | trunkBit;
-	
-		if((status = gsysSetTrunkMaskTable(dev[0],i,mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-
-	}
-	
-	/* setup for Device 1 */
-	for(i=0; i<8; i++)
-	{
-		if((i%4) == 3)
-		{
-			trunkBit = 1;
-		}
-		else
-		{
-			trunkBit = 0;
-		}		
-
-		mask = 0x7FE | trunkBit;
-	
-		if((status = gsysSetTrunkMaskTable(dev[1],i,mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-
-	}
-	return GT_OK;
+                        10    9    8    7    6    5    4    3    2    1    0
+       TrunkMask[0]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[1]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[2]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[3]        1    1    1    1    1    1    1    1    1    1    1
+       TrunkMask[4]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[5]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[6]        1    1    1    1    1    1    1    1    1    1    0
+       TrunkMask[7]        1    1    1    1    1    1    1    1    1    1    1
+
+    */
+
+    /* setup for Device 0 */
+    for(i=0; i<8; i++)
+    {
+        if((i%4) == 3)
+        {
+            trunkBit = 0;
+        }
+        else
+        {
+            trunkBit = 1 << (i%4);
+        }        
+
+        mask = 0x7F8 | trunkBit;
+    
+        if((status = gsysSetTrunkMaskTable(dev[0],i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+
+    }
+    
+    /* setup for Device 1 */
+    for(i=0; i<8; i++)
+    {
+        if((i%4) == 3)
+        {
+            trunkBit = 1;
+        }
+        else
+        {
+            trunkBit = 0;
+        }        
+
+        mask = 0x7FE | trunkBit;
+    
+        if((status = gsysSetTrunkMaskTable(dev[1],i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+
+    }
+    return GT_OK;
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/CrossChipTrunk/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/flowCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/flowCtrl.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/FlowControl/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/header.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/header.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Header/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/msSample.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/msSample.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/qdSimRegs.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Include/qdSimRegs.h
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/ev96122mii.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/ev96122mii.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msApiInit.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msApiInit.c
old mode 100644
new mode 100755
index 9a027c8..5f3cb95
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msApiInit.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msApiInit.c
@@ -23,93 +23,96 @@ GT_QD_DEV       *dev=&diagDev;
 
 /*
  *  Initialize the QuarterDeck. This should be done in BSP driver init routine.
- *	Since BSP is not combined with QuarterDeck driver, we are doing here.
+ *    Since BSP is not combined with QuarterDeck driver, we are doing here.
 */
 
 GT_STATUS qdStart(int cpuPort, int useQdSim, int devId) /* devId is used for simulator only */
 {
 GT_STATUS status;
 
-	/*
-	 *  Register all the required functions to QuarterDeck Driver.
-	*/
-	memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
-	memset((char*)&diagDev,0,sizeof(GT_QD_DEV));
+    /*
+     *  Register all the required functions to QuarterDeck Driver.
+    */
+    memset((char*)&cfg,0,sizeof(GT_SYS_CONFIG));
+    memset((char*)&diagDev,0,sizeof(GT_QD_DEV));
 
-	if(useQdSim == 0) /* use EV-96122 */
-	{
-		cfg.BSPFunctions.readMii   = gtBspReadMii;
-		cfg.BSPFunctions.writeMii  = gtBspWriteMii;
+    if(useQdSim == 0) /* use EV-96122 */
+    {
+        cfg.BSPFunctions.readMii   = gtBspReadMii;
+        cfg.BSPFunctions.writeMii  = gtBspWriteMii;
+#ifdef GT_RMGMT_ACCESS
+    cfg.BSPFunctions.hwAccess  = gtBspHwAccess; 
+#endif
 #ifdef USE_SEMAPHORE
-		cfg.BSPFunctions.semCreate = osSemCreate;
-		cfg.BSPFunctions.semDelete = osSemDelete;
-		cfg.BSPFunctions.semTake   = osSemWait;
-		cfg.BSPFunctions.semGive   = osSemSignal;
+        cfg.BSPFunctions.semCreate = osSemCreate;
+        cfg.BSPFunctions.semDelete = osSemDelete;
+        cfg.BSPFunctions.semTake   = osSemWait;
+        cfg.BSPFunctions.semGive   = osSemSignal;
 #else
-		cfg.BSPFunctions.semCreate = NULL;
-		cfg.BSPFunctions.semDelete = NULL;
-		cfg.BSPFunctions.semTake   = NULL;
-		cfg.BSPFunctions.semGive   = NULL;
+        cfg.BSPFunctions.semCreate = NULL;
+        cfg.BSPFunctions.semDelete = NULL;
+        cfg.BSPFunctions.semTake   = NULL;
+        cfg.BSPFunctions.semGive   = NULL;
 #endif
-		gtBspMiiInit(dev);
-	}
-	else	/* use QuaterDeck Simulator (No QD Device Required.) */
-	{
-		cfg.BSPFunctions.readMii   = qdSimRead;
-		cfg.BSPFunctions.writeMii  = qdSimWrite;
+        gtBspMiiInit(dev);
+    }
+    else    /* use QuaterDeck Simulator (No QD Device Required.) */
+    {
+        cfg.BSPFunctions.readMii   = qdSimRead;
+        cfg.BSPFunctions.writeMii  = qdSimWrite;
 #ifdef USE_SEMAPHORE
-		cfg.BSPFunctions.semCreate = osSemCreate;
-		cfg.BSPFunctions.semDelete = osSemDelete;
-		cfg.BSPFunctions.semTake   = osSemWait;
-		cfg.BSPFunctions.semGive   = osSemSignal;
+        cfg.BSPFunctions.semCreate = osSemCreate;
+        cfg.BSPFunctions.semDelete = osSemDelete;
+        cfg.BSPFunctions.semTake   = osSemWait;
+        cfg.BSPFunctions.semGive   = osSemSignal;
 #else
-		cfg.BSPFunctions.semCreate = NULL;
-		cfg.BSPFunctions.semDelete = NULL;
-		cfg.BSPFunctions.semTake   = NULL;
-		cfg.BSPFunctions.semGive   = NULL;
+        cfg.BSPFunctions.semCreate = NULL;
+        cfg.BSPFunctions.semDelete = NULL;
+        cfg.BSPFunctions.semTake   = NULL;
+        cfg.BSPFunctions.semGive   = NULL;
 #endif
 
-		qdSimInit(devId,0);
-	}
+        qdSimInit(devId,0);
+    }
 
-	cfg.initPorts = GT_TRUE;	/* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
-	cfg.cpuPortNum = cpuPort;
-#ifdef MANUAL_MODE	/* not defined. this is only for sample */
-	/* user may want to use this mode when there are two QD switchs on the same MII bus. */
-	cfg.mode.scanMode = SMI_MANUAL_MODE;	/* Use QD located at manually defined base addr */
-	cfg.mode.baseAddr = 0x10;	/* valid value in this case is either 0 or 0x10 */
+    cfg.initPorts = GT_TRUE;    /* Set switch ports to Forwarding mode. If GT_FALSE, use Default Setting. */
+    cfg.cpuPortNum = cpuPort;
+#ifdef MANUAL_MODE    /* not defined. this is only for sample */
+    /* user may want to use this mode when there are two QD switchs on the same MII bus. */
+    cfg.mode.scanMode = SMI_MANUAL_MODE;    /* Use QD located at manually defined base addr */
+    cfg.mode.baseAddr = 0x10;    /* valid value in this case is either 0 or 0x10 */
 #else
 #ifdef MULTI_ADDR_MODE
-	cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;	/* find a QD in indirect access mode */
-	cfg.mode.baseAddr = 1;		/* this is the phyAddr used by QD family device. 
-								Valid value are 1 ~ 31.*/
+    cfg.mode.scanMode = SMI_MULTI_ADDR_MODE;    /* find a QD in indirect access mode */
+    cfg.mode.baseAddr = 1;        /* this is the phyAddr used by QD family device. 
+                                Valid value are 1 ~ 31.*/
 #else
-	cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;	/* Scan 0 or 0x10 base address to find the QD */
-	cfg.mode.baseAddr = 0;
+    cfg.mode.scanMode = SMI_AUTO_SCAN_MODE;    /* Scan 0 or 0x10 base address to find the QD */
+    cfg.mode.baseAddr = 0;
 #endif
 #endif
-	if((status=qdLoadDriver(&cfg, dev)) != GT_OK)
-	{
-		MSG_PRINT(("qdLoadDriver return Failed\n"));
-		return status;
-	}
+    if((status=qdLoadDriver(&cfg, dev)) != GT_OK)
+    {
+        MSG_PRINT(("qdLoadDriver return Failed\n"));
+        return status;
+    }
 
-	MSG_PRINT(("Device ID     : 0x%x\n",dev->deviceId));
-	MSG_PRINT(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
-	MSG_PRINT(("No of Ports   : %d\n",dev->numOfPorts));
-	MSG_PRINT(("CPU Ports     : %d\n",dev->cpuPortNum));
+    MSG_PRINT(("Device ID     : 0x%x\n",dev->deviceId));
+    MSG_PRINT(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
+    MSG_PRINT(("No of Ports   : %d\n",dev->numOfPorts));
+    MSG_PRINT(("CPU Ports     : %d\n",dev->cpuPortNum));
 
-	/*
-	 *  start the QuarterDeck
-	*/
-	if((status=sysEnable(dev)) != GT_OK)
-	{
-		MSG_PRINT(("sysConfig return Failed\n"));
-		return status;
-	}
+    /*
+     *  start the QuarterDeck
+    */
+    if((status=sysEnable(dev)) != GT_OK)
+    {
+        MSG_PRINT(("sysConfig return Failed\n"));
+        return status;
+    }
 
-	MSG_PRINT(("QuarterDeck has been started.\n"));
+    MSG_PRINT(("QuarterDeck has been started.\n"));
 
-	return GT_OK;
+    return GT_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msSample.h b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msSample.h
old mode 100644
new mode 100755
index 310df7e..3c238e9
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msSample.h
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/msSample.h
@@ -18,11 +18,14 @@
 #include "vxWorks.h"
 #include "logLib.h"
 #endif
+
+#ifndef __KERNEL__
 #include "stdio.h"
 #include "stdarg.h"
 #include "stdlib.h"
 #include "time.h"
 #include "string.h"
+#endif
 
 #include "msApi.h"
 
@@ -52,48 +55,48 @@ typedef GT_STATUS (*GT_API_GET_PORT_U8) (GT_QD_DEV*, GT_LPORT,GT_U8*);
 
 typedef struct _TEST_API
 {
-	union
-	{
-		GT_API_SET_BOOL bool;
-		GT_API_MAC_ADDR mac;
-		GT_API_SET_PORT_BOOL port_bool;
-		GT_API_SET_PORT_U8 port_u8;
-		GT_API_SET_PORT_U16 port_u16;
-		GT_API_SET_PORT_U32 port_u32;
-	} setFunc;
-
-	union
-	{
-		GT_API_GET_BOOL bool;
-		GT_API_MAC_ADDR mac;
-		GT_API_GET_PORT_BOOL port_bool;
-		GT_API_GET_PORT_U8 port_u8;
-		GT_API_GET_PORT_U16 port_u16;
-		GT_API_GET_PORT_U32 port_u32;
-	} getFunc;
+    union
+    {
+        GT_API_SET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_SET_PORT_BOOL port_bool;
+        GT_API_SET_PORT_U8 port_u8;
+        GT_API_SET_PORT_U16 port_u16;
+        GT_API_SET_PORT_U32 port_u32;
+    } setFunc;
+
+    union
+    {
+        GT_API_GET_BOOL bool;
+        GT_API_MAC_ADDR mac;
+        GT_API_GET_PORT_BOOL port_bool;
+        GT_API_GET_PORT_U8 port_u8;
+        GT_API_GET_PORT_U16 port_u16;
+        GT_API_GET_PORT_U32 port_u32;
+    } getFunc;
 
 }TEST_API;
 
 typedef struct _TEST_STRUCT
 {
-	char strTest[16];
-	GT_API_VOID testFunc;
-	GT_U32 testResults;
+    char strTest[16];
+    GT_API_VOID testFunc;
+    GT_U32 testResults;
 } TEST_STRUCT;
 
 #define MSG_PRINT(x) testPrint x
 
-#define TEST_MAC_ENTRIES	32
+#define TEST_MAC_ENTRIES    32
 typedef struct _TEST_ATU_ENTRY
 {
-	GT_ATU_ENTRY atuEntry[TEST_MAC_ENTRIES];
+    GT_ATU_ENTRY atuEntry[TEST_MAC_ENTRIES];
 }TEST_ATU_ENTRY;
 
 typedef struct _ATU_ENTRY_INFO
 {
-	GT_ATU_ENTRY atuEntry;
-	GT_U16	hash;
-	GT_U16	bucket;
+    GT_ATU_ENTRY atuEntry;
+    GT_U16    hash;
+    GT_U16    bucket;
 } ATU_ENTRY_INFO;
 
 extern GT_SYS_CONFIG   pfTestSysCfg;
@@ -105,7 +108,15 @@ GT_STATUS qdSimSetPhyInt(unsigned int portNumber, unsigned short u16Data);
 GT_STATUS qdSimSetGlobalInt(unsigned short u16Data);
 
 GT_STATUS testAll(GT_QD_DEV*);
-void testPrint(char* format, ...);
+
+#ifdef __KERNEL__
+#define testPrint  printk
+#define printf  printk
+#define puts  printk
+#define rand  random32
+#else
+#define  testPrint printf
+#endif
 
 extern FGT_INT_HANDLER qdIntHandler;
 
@@ -113,11 +124,11 @@ int vtuEntryCmpFunc(void* buf, int a, int b);
 int atuEntryCmpFunc(void* buf, int a, int b);
 GT_STATUS gtSort(int list[], GT_CMP_FUNC cmpFunc, void* buf, GT_U32 len);
 GT_U16 createATUList(GT_QD_DEV *dev, TEST_ATU_ENTRY atuEntry[], GT_U16 entrySize, GT_U16 dbNumSize, 
-					GT_U16 sameMacsInEachDb, GT_U16 bSize);
+                    GT_U16 sameMacsInEachDb, GT_U16 bSize);
 GT_STATUS testFillUpAtu(GT_QD_DEV *dev, ATU_ENTRY_INFO *atuEntry, GT_U8 atuSize, 
-					GT_U8 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state);
+                    GT_U8 dbNum, GT_U16 first2Bytes, GT_ATU_UC_STATE state);
 GT_U16 runQDHash(GT_U8* eaddr, GT_U16 dbNum, int bSize, GT_U16* pHash, 
-					GT_U16* preBucket, GT_U16* posBucket);
+                    GT_U16* preBucket, GT_U16* posBucket);
 GT_STATUS testDisplayATUList();
 
 #undef USE_SEMAPHORE
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/osSem.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/osSem.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/qdSim.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/qdSim.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Initialization/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/qdInt.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/qdInt.c
old mode 100644
new mode 100755
index 16fdb06..d9017dd
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/qdInt.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/qdInt.c
@@ -3,8 +3,8 @@
 * qdInt.c
 *
 * DESCRIPTION:
-*		This sample shows how to call QuarterDeck Interrupt handler when QD INT
-*		raised, and how to take care each Interrupt Cause.
+*        This sample shows how to call QuarterDeck Interrupt handler when QD INT
+*        raised, and how to take care each Interrupt Cause.
 *
 * DEPENDENCIES:   NONE.
 *
@@ -16,370 +16,371 @@
 
 
 /*
- *	To enable quarterDeck interrupt, you need to call eventSetActive() and
- *	gprtPhyIntEnable(), as following sample routine.
- *	sampleQDIntEnable will enable all interrupt causes.
- *	For Port, GT_ATU_FULL, GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
- *	are enabled.
+ *    To enable quarterDeck interrupt, you need to call eventSetActive() and
+ *    gprtPhyIntEnable(), as following sample routine.
+ *    sampleQDIntEnable will enable all interrupt causes.
+ *    For Port, GT_ATU_FULL, GT_ATU_DONE, GT_PHY_INTERRUPT, and GT_EE_INTERRUPT
+ *    are enabled.
  *
- *	In this sample, GT_SPEED_CHANGED, GT_DUPLEX_CHANGED, and 
+ *    In this sample, GT_SPEED_CHANGED, GT_DUPLEX_CHANGED, and 
  *  GT_LINK_STATUS_CHANGED are enabled for ports 0 ~ 2.
 */
 GT_STATUS sampleQDIntEnable(GT_QD_DEV *dev)
 {
-	GT_STATUS status;
-	GT_LPORT port;
-	GT_U16 data;
-
-	/* 
-	 *	Enable QuarterDeck interrupt for ATUFull, ATUDone, PHYInt, and EEInt.
-	 *	If writing 0 into eventSetActive(), all port interrupt will be disabled.
-	*/
-	data = GT_STATS_DONE|GT_VTU_PROB|GT_VTU_DONE|
-		   GT_ATU_FULL|GT_ATU_DONE|GT_PHY_INTERRUPT|GT_EE_INTERRUPT;
-	if((status = eventSetActive(dev,data)) != GT_OK)
-	{
-		MSG_PRINT(("eventSetActive returned fail.\n"));
-		return status;
-	}
-
-	/* 
-	 *	Enable Phy interrupt for every possible interrupt cause.
-	 *	If writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
-	*/
-	data = 	GT_SPEED_CHANGED|GT_DUPLEX_CHANGED|GT_LINK_STATUS_CHANGED;
-
-	for(port=0; port<3; port++)
-	{
-		if((status = gprtPhyIntEnable(dev,port,data)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
-			return status;
-		}
-	}
-
-	return GT_OK;
+    GT_STATUS status;
+    GT_LPORT port;
+    GT_U16 data;
+
+    /* 
+     *    Enable QuarterDeck interrupt for ATUFull, ATUDone, PHYInt, and EEInt.
+     *    If writing 0 into eventSetActive(), all port interrupt will be disabled.
+    */
+    data = GT_STATS_DONE|GT_VTU_PROB|GT_VTU_DONE|
+           GT_ATU_FULL|GT_ATU_DONE|GT_EE_INTERRUPT;
+/*           GT_ATU_FULL|GT_ATU_DONE|GT_PHY_INTERRUPT|GT_EE_INTERRUPT; */
+    if((status = eventSetActive(dev,data)) != GT_OK)
+    {
+        MSG_PRINT(("eventSetActive returned fail.\n"));
+        return status;
+    }
+
+    /* 
+     *    Enable Phy interrupt for every possible interrupt cause.
+     *    If writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
+    */
+    data =     GT_SPEED_CHANGED|GT_DUPLEX_CHANGED|GT_LINK_STATUS_CHANGED;
+
+    for(port=0; port<3; port++)
+    {
+        if((status = gprtPhyIntEnable(dev,port,data)) != GT_OK)
+        {
+            MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
 }
 
 /*
- *	Disable QuarterDeck Interrupt.
+ *    Disable QuarterDeck Interrupt.
 */
 GT_STATUS sampleQDIntDisable(GT_QD_DEV *dev)
 {
-	GT_STATUS status;
-	GT_LPORT port;
-
-	/* 
-	 *	Writing 0 into eventSetActive(), all port interrupt will be disabled.
-	*/
-	if((status = eventSetActive(dev,0)) != GT_OK)
-	{
-		MSG_PRINT(("eventSetActive returned fail.\n"));
-		return status;
-	}
-
-	/* 
-	 *	Writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
-	*/
-	for(port=0; port<3; port++)
-	{
-		if((status = gprtPhyIntEnable(dev,port,0)) != GT_OK)
-		{
-			MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
-			return status;
-		}
-	}
-	return GT_OK;
+    GT_STATUS status;
+    GT_LPORT port;
+
+    /* 
+     *    Writing 0 into eventSetActive(), all port interrupt will be disabled.
+    */
+    if((status = eventSetActive(dev,0)) != GT_OK)
+    {
+        MSG_PRINT(("eventSetActive returned fail.\n"));
+        return status;
+    }
+
+    /* 
+     *    Writing 0 into gprtPhyIntEnable(), all port interrupt will be disabled.
+    */
+    for(port=0; port<3; port++)
+    {
+        if((status = gprtPhyIntEnable(dev,port,0)) != GT_OK)
+        {
+            MSG_PRINT(("gprtPhyIntEnable returned fail.\n"));
+            return status;
+        }
+    }
+    return GT_OK;
 }
 
 
 /*
- *	Assume that the following function, sampleQDIntVector(), is registered 
- *	when BSP calls intConnect for QD Interrupt.
- *	This sample will show how to deal with QuarterDeck Interrupt.
+ *    Assume that the following function, sampleQDIntVector(), is registered 
+ *    when BSP calls intConnect for QD Interrupt.
+ *    This sample will show how to deal with QuarterDeck Interrupt.
 */
 GT_STATUS sampleQDIntVector(GT_QD_DEV *dev)
 {
-	GT_U16 intCause, phyIntCause;
-	GT_U16 portVec;
-	GT_LPORT port;
-	GT_VTU_INT_STATUS vtuInt;
-	GT_ATU_INT_STATUS atuInt;
-
-	/*
-	 *	Disable QuarterDeck Interrupt in System Level.
-	 *	ToDo...
-	*/
-
-	/*
-	 *	Check if QD generated the interrupt.
-	*/
-	if(eventGetIntStatus(dev,&intCause) != GT_TRUE)
-	{
-		/* QD didn't generate the interrupt. */
-		return GT_FAIL;
-	}
-
-	/*
-	 *	QD generated interrupt with the reason in intCause.
-	*/
-
-	if(intCause & GT_STATS_DONE)
-	{
-		/* 
-		 *	Statistics Done Interrupt
-		 *	ToDo...
-		*/
-
-	}
-	if(intCause & GT_VTU_DONE)
-	{
-		/* 
-		 *	VTU Done Interrupt
-		 *	ToDo...
-		*/
-
-	}
-
-	if(intCause & GT_VTU_PROB)
-	{
-		/* 
-		 *	Vlan Table Problem/Violation.
-		 *	Need to read the cause.
-		*/
-		do {
-			if(gvtuGetIntStatus(dev,&vtuInt) != GT_OK)
-			{
-				/* failed to retrieve VTU Interrupt cause */
-				break;
-			}
-
-			if(vtuInt.vtuIntCause & GT_VTU_FULL_VIOLATION)
-			{
-				/* 
-				 *	Vlan Table is Full
-				 *	ToDo...
-				*/
-			}
-
-			if(vtuInt.vtuIntCause & GT_MEMBER_VIOLATION)
-			{
-				/* 
-				 *	Member Violation
-				 *	ToDo...
-				*/
-			}
-
-			if(vtuInt.vtuIntCause & GT_MISS_VIOLATION)
-			{
-				/* 
-				 *	Miss Violation
-				 *	ToDo...
-				*/
-			}
-		} while(vtuInt.vtuIntCause != 0);
-	}
-
-	if(intCause & GT_ATU_PROB)
-	{
-		/* 
-		 *	ATU cannot load or learn a new mapping due to all the available
-		 *	locations for an address being locked.
-		 *	ToDo...
-		*/
-		do {
-			if(gatuGetIntStatus(dev,&atuInt) != GT_OK)
-			{
-				/* failed to retrieve VTU Interrupt cause */
-				break;
-			}
-
-			if(atuInt.atuIntCause & GT_FULL_VIOLATION)
-			{
-				/* 
-				 *	Table is Full
-				 *	ToDo...
-				*/
-			}
-
-			if(atuInt.atuIntCause & GT_MEMBER_VIOLATION)
-			{
-				/* 
-				 *	Member Violation
-				 *	ToDo...
-				*/
-			}
-
-			if(atuInt.atuIntCause & GT_MISS_VIOLATION)
-			{
-				/* 
-				 *	Miss Violation
-				 *	ToDo...
-				*/
-			}
-		} while(atuInt.atuIntCause != 0);
-
-	}
-
-	if(intCause & GT_ATU_DONE)
-	{
-		/* 
-		 *	There is a transitions from a one to a zero on ATUBusy bit
-		 *	(Refer to ATU Operation Register.)
-		 *	ToDo...
-		*/
-
-	}
-
-	if(intCause & GT_PHY_INTERRUPT)
-	{
-		/* 
-		 *	At least one of the Phy generated interrupt.
-		 *	We need to read Phy Interrupt Summary and go through each phy
-		 *	based on the summary.
-		*/
-
-		if(gprtGetPhyIntPortSummary(dev,&portVec) != GT_OK)
-		{
-			return GT_FAIL;
-		}
-
-		port = 0;
-		while(portVec)
-		{
-			if(portVec & 0x01)
-			{
-				/*
-				 *	Call gprtGetPhyIntStatus to get intCause
-				*/
-				if(gprtGetPhyIntStatus(dev,port,&phyIntCause) != GT_OK)
-				{
-					/* 
-					 *	Something wrong with the system. Need to do the 
-					 *	necessary work. 
-					 *	ToDo...
-					*/
-				}
-
-				if(phyIntCause & GT_SPEED_CHANGED)
-				{
-					/* 
-					 *	Speed has been changed.
-					 *	ToDo...
-					*/
-				}
-
-				if(phyIntCause & GT_DUPLEX_CHANGED)
-				{
-					/* 
-					 *	Duplex mode has been changed.
-					 *	ToDo...
-					*/
-				}
-
-				if(phyIntCause & GT_PAGE_RECEIVED)
-				{
-					/* 
-					 *	Page received.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_AUTO_NEG_COMPLETED)
-				{
-					/* 
-					 *	AutoNegotiation completed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_LINK_STATUS_CHANGED)
-				{
-					/* 
-					 *	Link Status changed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_SYMBOL_ERROR)
-				{
-					/* 
-					 *	Symbol error
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_FALSE_CARRIER)
-				{
-					/* 
-					 *	False Carrier.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_FIFO_FLOW)
-				{
-					/* 
-					 *	Fifo Overflow/underflow error
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_CROSSOVER_CHANGED)
-				{
-					/* 
-					 *	MDI/MDIX crossover changed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_POLARITY_CHANGED)
-				{
-					/* 
-					 *	Polarity changed.
-					 *	ToDo...
-					*/
-
-				}
-
-				if(phyIntCause & GT_JABBER)
-				{
-					/* 
-					 *	Jabber
-					 *	ToDo...
-					*/
-
-				}
-			}
-
-			portVec >>= 1;
-			port++;
-		}
-	}
-
-	if(intCause & GT_EE_INTERRUPT)
-	{
-		/* 
-		 *	EEPROM is done loading registers.
-		 *	ToDo...
-		*/
-
-	}
-
-
-	/*
-	 *	Now, all the QuarterDeck related interrupt have been cleared,
-	 *	so it's OK to enable QuarterDeck Interrupt in System Level.
-	 *	ToDo...
-	*/
-	
-	return GT_OK;
+    GT_U16 intCause, phyIntCause;
+    GT_U16 portVec;
+    GT_LPORT port;
+    GT_VTU_INT_STATUS vtuInt;
+    GT_ATU_INT_STATUS atuInt;
+
+    /*
+     *    Disable QuarterDeck Interrupt in System Level.
+     *    ToDo...
+    */
+
+    /*
+     *    Check if QD generated the interrupt.
+    */
+    if(eventGetIntStatus(dev,&intCause) != GT_OK)
+    {
+        /* QD didn't generate the interrupt. */
+        return GT_FAIL;
+    }
+
+    /*
+     *    QD generated interrupt with the reason in intCause.
+    */
+
+    if(intCause & GT_STATS_DONE)
+    {
+        /* 
+         *    Statistics Done Interrupt
+         *    ToDo...
+        */
+
+    }
+    if(intCause & GT_VTU_DONE)
+    {
+        /* 
+         *    VTU Done Interrupt
+         *    ToDo...
+        */
+
+    }
+
+    if(intCause & GT_VTU_PROB)
+    {
+        /* 
+         *    Vlan Table Problem/Violation.
+         *    Need to read the cause.
+        */
+        do {
+            if(gvtuGetIntStatus(dev,&vtuInt) != GT_OK)
+            {
+                /* failed to retrieve VTU Interrupt cause */
+                break;
+            }
+
+            if(vtuInt.vtuIntCause & GT_VTU_FULL_VIOLATION)
+            {
+                /* 
+                 *    Vlan Table is Full
+                 *    ToDo...
+                */
+            }
+
+            if(vtuInt.vtuIntCause & GT_MEMBER_VIOLATION)
+            {
+                /* 
+                 *    Member Violation
+                 *    ToDo...
+                */
+            }
+
+            if(vtuInt.vtuIntCause & GT_MISS_VIOLATION)
+            {
+                /* 
+                 *    Miss Violation
+                 *    ToDo...
+                */
+            }
+        } while(vtuInt.vtuIntCause != 0);
+    }
+
+    if(intCause & GT_ATU_PROB)
+    {
+        /* 
+         *    ATU cannot load or learn a new mapping due to all the available
+         *    locations for an address being locked.
+         *    ToDo...
+        */
+        do {
+            if(gatuGetIntStatus(dev,&atuInt) != GT_OK)
+            {
+                /* failed to retrieve VTU Interrupt cause */
+                break;
+            }
+
+            if(atuInt.atuIntCause & GT_FULL_VIOLATION)
+            {
+                /* 
+                 *    Table is Full
+                 *    ToDo...
+                */
+            }
+
+            if(atuInt.atuIntCause & GT_MEMBER_VIOLATION)
+            {
+                /* 
+                 *    Member Violation
+                 *    ToDo...
+                */
+            }
+
+            if(atuInt.atuIntCause & GT_MISS_VIOLATION)
+            {
+                /* 
+                 *    Miss Violation
+                 *    ToDo...
+                */
+            }
+        } while(atuInt.atuIntCause != 0);
+
+    }
+
+    if(intCause & GT_ATU_DONE)
+    {
+        /* 
+         *    There is a transitions from a one to a zero on ATUBusy bit
+         *    (Refer to ATU Operation Register.)
+         *    ToDo...
+        */
+
+    }
+
+    if(intCause & GT_PHY_INTERRUPT)
+    {
+        /* 
+         *    At least one of the Phy generated interrupt.
+         *    We need to read Phy Interrupt Summary and go through each phy
+         *    based on the summary.
+        */
+
+        if(gprtGetPhyIntPortSummary(dev,&portVec) != GT_OK)
+        {
+            return GT_FAIL;
+        }
+
+        port = 0;
+        while(portVec)
+        {
+            if(portVec & 0x01)
+            {
+                /*
+                 *    Call gprtGetPhyIntStatus to get intCause
+                */
+                if(gprtGetPhyIntStatus(dev,port,&phyIntCause) != GT_OK)
+                {
+                    /* 
+                     *    Something wrong with the system. Need to do the 
+                     *    necessary work. 
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_SPEED_CHANGED)
+                {
+                    /* 
+                     *    Speed has been changed.
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_DUPLEX_CHANGED)
+                {
+                    /* 
+                     *    Duplex mode has been changed.
+                     *    ToDo...
+                    */
+                }
+
+                if(phyIntCause & GT_PAGE_RECEIVED)
+                {
+                    /* 
+                     *    Page received.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_AUTO_NEG_COMPLETED)
+                {
+                    /* 
+                     *    AutoNegotiation completed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_LINK_STATUS_CHANGED)
+                {
+                    /* 
+                     *    Link Status changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_SYMBOL_ERROR)
+                {
+                    /* 
+                     *    Symbol error
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_FALSE_CARRIER)
+                {
+                    /* 
+                     *    False Carrier.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_FIFO_FLOW)
+                {
+                    /* 
+                     *    Fifo Overflow/underflow error
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_CROSSOVER_CHANGED)
+                {
+                    /* 
+                     *    MDI/MDIX crossover changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_POLARITY_CHANGED)
+                {
+                    /* 
+                     *    Polarity changed.
+                     *    ToDo...
+                    */
+
+                }
+
+                if(phyIntCause & GT_JABBER)
+                {
+                    /* 
+                     *    Jabber
+                     *    ToDo...
+                    */
+
+                }
+            }
+
+            portVec >>= 1;
+            port++;
+        }
+    }
+
+    if(intCause & GT_EE_INTERRUPT)
+    {
+        /* 
+         *    EEPROM is done loading registers.
+         *    ToDo...
+        */
+
+    }
+
+
+    /*
+     *    Now, all the QuarterDeck related interrupt have been cleared,
+     *    so it's OK to enable QuarterDeck Interrupt in System Level.
+     *    ToDo...
+    */
+    
+    return GT_OK;
 
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Interrupt/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/loadBalance.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/loadBalance.c
old mode 100644
new mode 100755
index 10be0ac..bb718c4
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/loadBalance.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/loadBalance.c
@@ -3,8 +3,8 @@
 * loadBalance.c
 *
 * DESCRIPTION:
-*		This sample shows how to setup load balance among Trunk ports.
-*		In this sample, port 0,1,2, and 3 will be in the Trunk group.
+*        This sample shows how to setup load balance among Trunk ports.
+*        In this sample, port 0,1,2, and 3 will be in the Trunk group.
 *
 * DEPENDENCIES:
 *
@@ -19,39 +19,40 @@
 /*
    The following sample sets Trunk Mask Table as follows:
  
-					10	9	8	7	6	5	4	3	2	1	0
-   TrunkMask[0]		1	1	1	1	1	1	1	0	0	0	1
-   TrunkMask[1]		1	1	1	1	1	1	1	0	0	1	0
-   TrunkMask[2]		1	1	1	1	1	1	1	0	1	0	0
-   TrunkMask[3]		1	1	1	1	1	1	1	1	0	0	0
-   TrunkMask[4]		1	1	1	1	1	1	1	0	0	0	1
-   TrunkMask[5]		1	1	1	1	1	1	1	0	0	1	0
-   TrunkMask[6]		1	1	1	1	1	1	1	0	1	0	0
-   TrunkMask[7]		1	1	1	1	1	1	1	1	0	0	0
+                      10    9    8    7    6    5    4    3    2    1    0
+   TrunkMask[0]        1    1    1    1    1    1    1    0    0    0    1
+   TrunkMask[1]        1    1    1    1    1    1    1    0    0    1    0
+   TrunkMask[2]        1    1    1    1    1    1    1    0    1    0    0
+   TrunkMask[3]        1    1    1    1    1    1    1    1    0    0    0
+   TrunkMask[4]        1    1    1    1    1    1    1    0    0    0    1
+   TrunkMask[5]        1    1    1    1    1    1    1    0    0    1    0
+   TrunkMask[6]        1    1    1    1    1    1    1    0    1    0    0
+   TrunkMask[7]        1    1    1    1    1    1    1    1    0    0    0
 */
 
 GT_STATUS sampleLoadBalance(GT_QD_DEV *dev)
 {
-	GT_STATUS status;
-	int i;
-	GT_U32 mask, baseMask;
-
-	baseMask = 0xFFF0;	/* clear bits for port 0 ~ 3 */
-
-	/*
-	 *	Set the trunk mask table for load balancing.
-	*/
-	for(i=0; i<8; i++)
-	{
-		mask = baseMask | (1 << (i%4));
-
-		if((status = gsysSetTrunkMaskTable(dev,i,mask)) != GT_OK)
-		{
-			MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
-			return status;
-		}
-	}
-
-	return GT_OK;
+    GT_STATUS status;
+    int i;
+    GT_U32 mask, baseMask;
+
+    baseMask = (1 << dev->numOfPorts) - 1;
+    baseMask &= 0xFFF0;    /* clear bits for port 0 ~ 3 */
+
+    /*
+     *    Set the trunk mask table for load balancing.
+    */
+    for(i=0; i<8; i++)
+    {
+        mask = baseMask | (1 << (i%4));
+
+        if((status = gsysSetTrunkMaskTable(dev,i,mask)) != GT_OK)
+        {
+            MSG_PRINT(("gsysSetTrunkMaskTable return Failed\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/LoadBalance/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/macAddr.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/macAddr.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MACAddress/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/minimizeCPUTraffic.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/minimizeCPUTraffic.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MinimizeCPUTraffic/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MultiDevice/msApiInit.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/MultiDevice/msApiInit.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl2.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/pirl2.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PIRL/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c
old mode 100644
new mode 100755
index cc0e62f..b5bc42e
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/ptp.c
@@ -15,262 +15,268 @@
 
 /*
  *  PTP Init routine
- *	
- *	1) Setup each port to forward PTP frame to CPU port
- *	2) Enable PTP Interrupt (assumes that no other interrupt is used, but PTP)
- *	3) Configure PTP
- *	4) Enable PTP
+ *    
+ *    1) Setup each port to forward PTP frame to CPU port
+ *    2) Enable PTP Interrupt (assumes that no other interrupt is used, but PTP)
+ *    3) Configure PTP
+ *    4) Enable PTP
  *
- *	Notes: This sample uses the following configuration
- *	1) Enables only PTP interrupt
- *	2) Assumes PTP Ethernet Type is 0x88F7
- *	3) Time Stamp is enabled only for Message ID 0, 2, and 3
- *	4) Message ID 0 and 2 use Arr0 pointer and ID 3 uses Arr1 pointer
- *	5) PTP interrtups are enabled on Port 0 ~ 5
+ *    Notes: This sample uses the following configuration
+ *    1) Enables only PTP interrupt
+ *    2) Assumes PTP Ethernet Type is 0x88F7
+ *    3) Time Stamp is enabled only for Message ID 0, 2, and 3
+ *    4) Message ID 0 and 2 use Arr0 pointer and ID 3 uses Arr1 pointer
+ *    5) PTP interrtups are enabled on Port 0 ~ 5
  *
- *	Notes: Forwarding PTP fram to CPU port is based on Ether Type DSA Tag (8 bytes).
- *	Therefore, Ethernet device driver, that actually rx/tx the PTP frame,
- *	should expect/insert Ether Type DSA Tag.
+ *    Notes: Forwarding PTP fram to CPU port is based on Ether Type DSA Tag (8 bytes).
+ *    Therefore, Ethernet device driver, that actually rx/tx the PTP frame,
+ *    should expect/insert Ether Type DSA Tag.
 */
 
-STATUS samplePTPInit(GT_QD_DEV *dev)
+GT_STATUS samplePTPInit(GT_QD_DEV *dev)
 {
- 	GT_PTP_CONFIG ptpCfg;
-	GT_LPORT port;
-	GT_STATUS status;
-
-
-	/*
-	 *	1) Setup each port to forward PTP frame to CPU port
-	*/
-
-	/* setup EtypeType and Policy */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if ((status = gprtSetPortEType(dev, port, (GT_ETYPE)0x88F7)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPortEType returned not OK\n"));
-			return status;
-		}
-
-		if (port == dev->cpuPortNum)
-			continue;
-
-		if ((status = gprtSetPolicy(dev, port, POLICY_TYPE_ETYPE, FRAME_POLICY_TRAP)) != GT_OK)
-		{
-			MSG_PRINT(("gprtSetPolicy returned not OK\n"));
-			return status;
-		}
-	}
-
-	/* setup Frame Mode for CPU port */
-	if ((status = gprtSetFrameMode(dev, dev->cpuPortNum, GT_FRAME_MODE_ETHER_TYPE_DSA)) != GT_OK)
-	{
-		MSG_PRINT(("gprtSetFrameMode return failed\n"));
-		return status;
-	}
-
-	/*
-	 *	2) Enable PTP Interrupt
-	*/
-	eventSetActive(dev, GT_AVB_INT);
-
-
-	/*
-	 *	3) Configure PTP
-	*/
-	ptpCfg.ptpEType = 0x88F7;
-	ptpCfg.msgIdTSEn = 0xd;		/* id 0, 2, and 3 */
-	ptpCfg.tsArrPtr = 0x8;		/* id 0 and 2 for ARR0, id 3 for ARR1 */
-
-	/* Transport specific bits present in PTP Common Header */
-	ptpCfg.transSpec = 1;		
-
-	/* starting bit location for the Message ID field in the PTP Common Header */
-	ptpCfg.msgIdStartBit = 4;	
-
-	ptpCfg.ptpArrIntEn = 0x3F;
-	ptpCfg.ptpDepIntEn = 0x3F;
-	ptpCfg.disTSOverwrite = 0;
-
-
-	if ((status = gptpSetConfig(dev, &ptpCfg)) != GT_OK)
-	{
-		MSG_PRINT(("gptpSetConfig return failed\n"));
-		return status;
-	}
-	if ((status = gptpSetPTPEn(dev, GT_TRUE)) != GT_OK)
-	{
-		MSG_PRINT(("gptpSetPTPEn return failed\n"));
-		return status;
-	}
-
-	return GT_OK;
+     GT_PTP_CONFIG ptpCfg;
+    GT_LPORT port;
+    GT_STATUS status;
+
+
+    /*
+     *    1) Setup each port to forward PTP frame to CPU port
+    */
+
+    /* setup EtypeType and Policy */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if ((status = gprtSetPortEType(dev, port, (GT_ETYPE)0x88F7)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetPortEType returned not OK\n"));
+            return status;
+        }
+
+        if (port == dev->cpuPortNum)
+            continue;
+
+        if ((status = gprtSetPolicy(dev, port, POLICY_TYPE_ETYPE, FRAME_POLICY_TRAP)) != GT_OK)
+        {
+            MSG_PRINT(("gprtSetPolicy returned not OK\n"));
+            return status;
+        }
+    }
+
+    /* setup Frame Mode for CPU port */
+    if ((status = gprtSetFrameMode(dev, dev->cpuPortNum, GT_FRAME_MODE_ETHER_TYPE_DSA)) != GT_OK)
+    {
+        MSG_PRINT(("gprtSetFrameMode return failed\n"));
+        return status;
+    }
+
+    /*
+     *    2) Enable PTP Interrupt
+    */
+    eventSetActive(dev, GT_AVB_INT);
+
+
+    /*
+     *    3) Configure PTP
+    */
+    ptpCfg.ptpEType = 0x88F7;
+    ptpCfg.msgIdTSEn = 0xd;        /* id 0, 2, and 3 */
+    ptpCfg.tsArrPtr = 0x8;        /* id 0 and 2 for ARR0, id 3 for ARR1 */
+
+    /* Transport specific bits present in PTP Common Header */
+    ptpCfg.transSpec = 1;        
+
+    /* starting bit location for the Message ID field in the PTP Common Header */
+    ptpCfg.msgIdStartBit = 4;    
+
+    ptpCfg.ptpArrIntEn = 0x3F;
+    ptpCfg.ptpDepIntEn = 0x3F;
+    ptpCfg.disTSOverwrite = 0;
+
+
+    if ((status = gptpSetConfig(dev, &ptpCfg)) != GT_OK)
+    {
+        MSG_PRINT(("gptpSetConfig return failed\n"));
+        return status;
+    }
+    if ((status = gptpSetPTPEn(dev, GT_TRUE)) != GT_OK)
+    {
+        MSG_PRINT(("gptpSetPTPEn return failed\n"));
+        return status;
+    }
+
+    return GT_OK;
 }
 
 
 /*
  *  PTP Interrupt Handler
- *	
- *	1) for each port that causes PTP interrup, do the followings
- *	2) check Arrival 0 Time Stamp
- *	3) check Arrival 1 Time Stamp
- *	4) check Departure Time Stamp
+ *    
+ *    1) for each port that causes PTP interrup, do the followings
+ *    2) check Arrival 0 Time Stamp
+ *    3) check Arrival 1 Time Stamp
+ *    4) check Departure Time Stamp
 */
 
-STATUS samplePTPIntHandler(GT_QD_DEV *dev)
+GT_STATUS samplePTPIntHandler(GT_QD_DEV *dev)
 {
-	GT_U32 int_ports, i, int_status;
-	GT_STATUS status;
-	GT_PTP_TS_STATUS	ptpStatus;
-
-	/* disable AVB Interrupt */
-	eventSetActive(dev, 0);
-
-	/* read interrupt cause */
-	eventGetIntStatus(dev,(GT_U16*)&int_status);
-	if ((int_status & GT_AVB_INT) == 0)
-	{
-		/* it's not PTP interrupt */
-		return GT_FAIL;	
-	}
-
-	/* read AVB Int status */
-	if((status = gptpGetPTPInt(dev, &int_ports)) != GT_OK)
-	{
-	    MSG_PRINT(("gptpGetPTPInt return failed\n"));
-		goto ret_int;
-	}
-
-	/* for each port, get the timestamp information if necessary */
-	i = 0;
-	while(int_ports)
-	{
-		if(!(int_ports & 0x1))
-		{
-			i++;
-			int_ports >>= 1;
-			continue;
-		}
-
-		/* check Arrival0 Time Stamp */
-		if((status = gptpGetTimeStamped(dev, i, PTP_ARR0_TIME, &ptpStatus)) != GT_OK)
-		{
-		    MSG_PRINT(("gptpGetTimeStamped return failed\n"));
-			goto ret_int;
-		}
-
-		if (ptpStatus.isValid == GT_TRUE)
-		{
-			switch(ptpStatus.status)
-			{
-				case PTP_INT_NORMAL:
-					/* To Do: No error condition occurred. So store the time stamp and seqId */
-					break;
-
-				case PTP_INT_OVERWRITE:
-					/* To Do: PTP Logic received several PTP frames and only the last one is valid */
-					break;
-
-				case PTP_INT_DROP:
-					/* To Do: PTP Logic received several PTP frames and only the first one is valid */
-					break;
-
-				default:
-				    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
-					status = GT_FAIL;
-					goto ret_int;
-
-			}
-
-			if((status = gptpResetTimeStamp(dev, i, PTP_ARR0_TIME)) != GT_OK)
-			{
-			    MSG_PRINT(("gptpResetTimeStamp return failed\n"));
-				goto ret_int;
-			}
-		}
-		
-		/* check Arrival1 Time Stamp */
-		if((status = gptpGetTimeStamped(dev, i, PTP_ARR1_TIME, &ptpStatus)) != GT_OK)
-		{
-		    MSG_PRINT(("gptpGetTimeStamped return failed\n"));
-			goto ret_int;
-		}
-
-		if (ptpStatus.isValid == GT_TRUE)
-		{
-			switch(ptpStatus.status)
-			{
-				case PTP_INT_NORMAL:
-					/* To Do: No error condition occurred. So store the time stamp and seqId */
-					break;
-
-				case PTP_INT_OVERWRITE:
-					/* To Do: PTP Logic received several PTP frames and only the last one is valid */
-					break;
-
-				case PTP_INT_DROP:
-					/* To Do: PTP Logic received several PTP frames and only the first one is valid */
-					break;
-
-				default:
-				    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
-					status = GT_FAIL;
-					goto ret_int;
-			}
-
-			if((status = gptpResetTimeStamp(dev, i, PTP_ARR1_TIME)) != GT_OK)
-			{
-			    MSG_PRINT(("gptpResetTimeStamp return failed\n"));
-				goto ret_int;
-			}
-
-		}
-		
-		/* check Departure Time Stamp */
-		if((status = gptpGetTimeStamped(dev, i, PTP_DEP_TIME, &ptpStatus)) != GT_OK)
-		{
-		    MSG_PRINT(("gptpGetTimeStamped return failed\n"));
-			goto ret_int;
-		}
-
-		if (ptpStatus.isValid == GT_TRUE)
-		{
-			switch(ptpStatus.status)
-			{
-				case PTP_INT_NORMAL:
-					/* To Do: No error condition occurred. So store the time stamp and seqId */
-					break;
-
-				case PTP_INT_OVERWRITE:
-					/* To Do: PTP Logic received several PTP frames and only the last one is valid */
-					break;
-
-				case PTP_INT_DROP:
-					/* To Do: PTP Logic received several PTP frames and only the first one is valid */
-					break;
-
-				default:
-				    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
-					status = GT_FAIL;
-					goto ret_int;
-			}
-
-			if((status = gptpResetTimeStamp(dev, i, PTP_DEP_TIME)) != GT_OK)
-			{
-			    MSG_PRINT(("gptpResetTimeStamp return failed\n"));
-				goto ret_int;
-			}
-
-		}
-		
-		int_ports >>= 1;
-					
-	}
+    GT_U32 int_ports, i, int_status;
+    GT_STATUS status;
+    GT_PTP_TS_STATUS    ptpStatus;
+
+    /* disable AVB Interrupt */
+    eventSetActive(dev, 0);
+
+    /* read interrupt cause */
+    if((status=eventGetIntStatus(dev,(GT_U16*)&int_status))!=GT_OK)
+    {
+        return GT_FAIL;    
+    }
+
+
+    if ((int_status & GT_AVB_INT) == 0)
+    {
+        MSG_PRINT(("eventGetIntStatus return No AVB Interrupt\n"));
+        /* it's not PTP interrupt */
+        goto ret_int;
+    }
+
+    /* read AVB Int status */
+    if((status = gptpGetPTPInt(dev, &int_ports)) != GT_OK)
+    {
+        MSG_PRINT(("gptpGetPTPInt return failed\n"));
+        goto ret_int;
+    }
+
+    /* for each port, get the timestamp information if necessary */
+    i = 0;
+    while(int_ports)
+    {
+        if(!(int_ports & 0x1))
+        {
+            i++;
+            int_ports >>= 1;
+            continue;
+        }
+
+        /* check Arrival0 Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_ARR0_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_ARR0_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+        }
+        
+        /* check Arrival1 Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_ARR1_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_ARR1_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+
+        }
+        
+        /* check Departure Time Stamp */
+        if((status = gptpGetTimeStamped(dev, i, PTP_DEP_TIME, &ptpStatus)) != GT_OK)
+        {
+            MSG_PRINT(("gptpGetTimeStamped return failed\n"));
+            goto ret_int;
+        }
+
+        if (ptpStatus.isValid == GT_TRUE)
+        {
+            switch(ptpStatus.status)
+            {
+                case PTP_INT_NORMAL:
+                    /* To Do: No error condition occurred. So store the time stamp and seqId */
+                    break;
+
+                case PTP_INT_OVERWRITE:
+                    /* To Do: PTP Logic received several PTP frames and only the last one is valid */
+                    break;
+
+                case PTP_INT_DROP:
+                    /* To Do: PTP Logic received several PTP frames and only the first one is valid */
+                    break;
+
+                default:
+                    MSG_PRINT(("unknown ptp status %i\n", ptpStatus.status));
+                    status = GT_FAIL;
+                    goto ret_int;
+            }
+
+            if((status = gptpResetTimeStamp(dev, i, PTP_DEP_TIME)) != GT_OK)
+            {
+                MSG_PRINT(("gptpResetTimeStamp return failed\n"));
+                goto ret_int;
+            }
+
+        }
+        
+        int_ports >>= 1;
+                    
+    }
 
 ret_int:
-	eventSetActive(dev, GT_AVB_INT);
+    eventSetActive(dev, GT_AVB_INT);
 
-	return status;
+    return status;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PTP/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c
old mode 100644
new mode 100755
index 26d081a..371caad
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/phyPktGenSample.c
@@ -3,10 +3,10 @@
 * phyPktGenSample.c
 *
 * DESCRIPTION:
-*       Packet Generator setup sample (startPktGenerator and stopPktGenerator).
+*       Packet Generator setup sample (startQdPktGenerator and stopQdPktGenerator).
 *
 * DEPENDENCIES:
-*		Please check the phy device's spec. if the device supports this feature.
+*        Please check the phy device's spec. if the device supports this feature.
 *
 * FILE REVISION NUMBER:
 *
@@ -21,7 +21,7 @@
  *      length  - enum GT_PG_LENGTH  (GT_PG_LENGTH_64 or GT_PG_LENGTH_1514)
  *      tx      - enum GT_PG_TX      (GT_PG_TX_NORMAL or GT_PG_TX_ERROR)
 */
-GT_STATUS startPktGenerator
+GT_STATUS startQdPktGenerator
 (
     GT_QD_DEV      *dev,
     GT_LPORT       port,
@@ -46,7 +46,7 @@ GT_STATUS startPktGenerator
     pktInfo.tx = tx;           /* normal packet, error packet */
 
     /*
-     *	Start Packet Generator
+     *    Start Packet Generator
     */
     if((status = gprtSetPktGenEnable(dev,port,GT_TRUE,&pktInfo)) != GT_OK)
     {
@@ -61,7 +61,7 @@ GT_STATUS startPktGenerator
 /*
  * Stop Packet Generator.
  */
-GT_STATUS stopPktGenerator(GT_QD_DEV *dev,GT_LPORT port)
+GT_STATUS stopQdPktGenerator(GT_QD_DEV *dev,GT_LPORT port)
 {
     GT_STATUS status;
 
@@ -74,7 +74,7 @@ GT_STATUS stopPktGenerator(GT_QD_DEV *dev,GT_LPORT port)
     MSG_PRINT(("Stopping Packet Generator for port %i\n",(int)port));
 
     /*
-     *	Start Packet Generator
+     *    Start Packet Generator
     */
     if((status = gprtSetPktGenEnable(dev,port,GT_FALSE,NULL)) != GT_OK)
     {
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PktGen/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/portMonitor.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/portMonitor.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/PortMonitor/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/qos.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/qos.c
old mode 100644
new mode 100755
index 056faee..1d05fa5
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/qos.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/qos.c
@@ -4,7 +4,7 @@
 *
 * DESCRIPTION:
 *       Sample program which will show how to setup the Priority Queue for QoS
-*		
+*        
 *
 * DEPENDENCIES:   None.
 *
@@ -14,183 +14,184 @@
 #include "msSample.h"
 
 /*
- *	sampleQoS will enable using both IEEE 802.3ac Tag and IPv4/IPv6 Traffic 
- *	Class field and IEEE 802.3ac has a higher priority than IPv4/IPv6. 
- *	The following is the QoS mapping programmed by sampleQos:
- *	1) IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
- *		Priority 1~3 is using QuarterDeck Queue 0.
- *		Priority 0,4 is using QuarterDeck Queue 1.
- *		Priority 6,7 is using QuarterDeck Queue 2.
- *		Priority 5 is using QuarterDeck Queue 3.
- *	2) IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
- *		Priority 0~7 is using QuaterDeck Queue 0.
- *		Priority 8~31 is using QuaterDeck Queue 1.
- *		Priority 32~55 is using QuaterDeck Queue 2.
- *		Priority 56~63 is using QuaterDeck Queue 3.
- *	3) Each port's default priority is set to 1.
+ *    sampleQoS will enable using both IEEE 802.3ac Tag and IPv4/IPv6 Traffic 
+ *    Class field and IEEE 802.3ac has a higher priority than IPv4/IPv6. 
+ *    The following is the QoS mapping programmed by sampleQos:
+ *    1) IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
+ *        Priority 1~3 is using QuarterDeck Queue 0.
+ *        Priority 0,4 is using QuarterDeck Queue 1.
+ *        Priority 6,7 is using QuarterDeck Queue 2.
+ *        Priority 5 is using QuarterDeck Queue 3.
+ *    2) IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
+ *        Priority 0~7 is using QuaterDeck Queue 0.
+ *        Priority 8~31 is using QuaterDeck Queue 1.
+ *        Priority 32~55 is using QuaterDeck Queue 2.
+ *        Priority 56~63 is using QuaterDeck Queue 3.
+ *    3) Each port's default priority is set to 1.
 */
 GT_STATUS sampleQos(GT_QD_DEV *dev)
 {
-	GT_STATUS status;
-	GT_U8 priority;
-	GT_LPORT port;
-
-	for(port=0; port<7; port++)
-	{
-		/*
-		 *  Use IEEE Tag
-		 */
-		if((status = gqosUserPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gqosUserPrioMapEn return Failed\n"));
-			return status;
-		}
-
-		/*
-		 *  Use IPv4/IPv6 priority fields (use IP)
-		 */
-		if((status = gqosIpPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gqosIpPrioMapEn return Failed\n"));
-			return status;
-		}
-
-		/*
-		 *  IEEE Tag has higher priority than IP priority fields
-		 */
-		if((status = gqosSetPrioMapRule(dev,port,GT_TRUE)) != GT_OK)
-		{
-			MSG_PRINT(("gqosSetPrioMapRule return Failed\n"));
-			return status;
-		}
-	}
-
-	/*
-	 *	IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
-	 *	Priority 1~3 is using QuarterDeck Queue 0.
-	 *	Priority 0,4 is using QuarterDeck Queue 1.
-	 *	Priority 6,7 is using QuarterDeck Queue 2.
-	 *	Priority 5 is using QuarterDeck Queue 3.
-	*/
-
-	/*	Priority 0 is using QuarterDeck Queue 1. */
-	if((status = gcosSetUserPrio2Tc(dev,0,1)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 1 is using QuarterDeck Queue 0. */
-	if((status = gcosSetUserPrio2Tc(dev,1,0)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 2 is using QuarterDeck Queue 0. */
-	if((status = gcosSetUserPrio2Tc(dev,2,0)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 3 is using QuarterDeck Queue 0. */
-	if((status = gcosSetUserPrio2Tc(dev,3,0)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 4 is using QuarterDeck Queue 1. */
-	if((status = gcosSetUserPrio2Tc(dev,4,1)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 5 is using QuarterDeck Queue 3. */
-	if((status = gcosSetUserPrio2Tc(dev,5,3)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 6 is using QuarterDeck Queue 2. */
-	if((status = gcosSetUserPrio2Tc(dev,6,2)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-	/*	Priority 7 is using QuarterDeck Queue 2. */
-	if((status = gcosSetUserPrio2Tc(dev,7,2)) != GT_OK)
-	{
-		MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
-		return status;
-	}
-
-
-	/*
-	 *	IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
-	 *	Priority 0~7 is using QuaterDeck Queue 0.
-	 *	Priority 8~31 is using QuaterDeck Queue 1.
-	 *	Priority 32~55 is using QuaterDeck Queue 2.
-	 *	Priority 56~63 is using QuaterDeck Queue 3.
-	*/
-
-	/*	Priority 0~7 is using QuaterDeck Queue 0. */
-	for(priority=0; priority<8; priority++)
-	{
-		if((status = gcosSetDscp2Tc(dev,priority,0)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
-			return status;
-		}
-	}
-
-	/*	Priority 8~31 is using QuaterDeck Queue 1. */
-	for(priority=8; priority<32; priority++)
-	{
-		if((status = gcosSetDscp2Tc(dev,priority,1)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
-			return status;
-		}
-	}
-
-	/*	Priority 32~55 is using QuaterDeck Queue 2. */
-	for(priority=32; priority<56; priority++)
-	{
-		if((status = gcosSetDscp2Tc(dev,priority,2)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
-			return status;
-		}
-	}
-
-	/*	Priority 56~63 is using QuaterDeck Queue 3. */
-	for(priority=56; priority<64; priority++)
-	{
-		if((status = gcosSetDscp2Tc(dev,priority,3)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
-			return status;
-		}
-	}
-
-	/*
-	 * Each port's default priority is set to 1.
-	*/
-	for(port=0; port<7; port++)
-	{
-		if((status = gcosSetPortDefaultTc(dev,port,1)) != GT_OK)
-		{
-			MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
-			return status;
-		}
-	}
-
-	return GT_OK;
+    GT_STATUS status;
+    GT_U8 priority;
+    GT_LPORT port;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+       /*
+         *  Use IEEE Tag
+         */
+        if((status = gqosUserPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosUserPrioMapEn return Failed\n"));
+            return status;
+        }
+
+        /*
+         *  Use IPv4/IPv6 priority fields (use IP)
+         */
+        if((status = gqosIpPrioMapEn(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosIpPrioMapEn return Failed\n"));
+            return status;
+        }
+
+        /*
+         *  IEEE Tag has higher priority than IP priority fields
+         */
+        if((status = gqosSetPrioMapRule(dev,port,GT_TRUE)) != GT_OK)
+        {
+            MSG_PRINT(("gqosSetPrioMapRule return Failed\n"));
+            return status;
+        }
+        MSG_PRINT(("sampleQos port %d Ok\n", port));
+    }
+
+    /*
+     *    IEEE 802.3ac Tag (Priority 0 ~ 7, 3 bits)
+     *    Priority 1~3 is using QuarterDeck Queue 0.
+     *    Priority 0,4 is using QuarterDeck Queue 1.
+     *    Priority 6,7 is using QuarterDeck Queue 2.
+     *    Priority 5 is using QuarterDeck Queue 3.
+    */
+
+    /*    Priority 0 is using QuarterDeck Queue 1. */
+    if((status = gcosSetUserPrio2Tc(dev,0,1)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 1 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,1,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 2 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,2,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 3 is using QuarterDeck Queue 0. */
+    if((status = gcosSetUserPrio2Tc(dev,3,0)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 4 is using QuarterDeck Queue 1. */
+    if((status = gcosSetUserPrio2Tc(dev,4,1)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 5 is using QuarterDeck Queue 3. */
+    if((status = gcosSetUserPrio2Tc(dev,5,3)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 6 is using QuarterDeck Queue 2. */
+    if((status = gcosSetUserPrio2Tc(dev,6,2)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+    /*    Priority 7 is using QuarterDeck Queue 2. */
+    if((status = gcosSetUserPrio2Tc(dev,7,2)) != GT_OK)
+    {
+        MSG_PRINT(("gcosSetUserPrio2Tc returned fail.\n"));
+        return status;
+    }
+
+
+    /*
+     *    IPv4/IPv6 (Priority 0 ~ 63, 6 bits)
+     *    Priority 0~7 is using QuaterDeck Queue 0.
+     *    Priority 8~31 is using QuaterDeck Queue 1.
+     *    Priority 32~55 is using QuaterDeck Queue 2.
+     *    Priority 56~63 is using QuaterDeck Queue 3.
+    */
+
+    /*    Priority 0~7 is using QuaterDeck Queue 0. */
+    for(priority=0; priority<8; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,0)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 8~31 is using QuaterDeck Queue 1. */
+    for(priority=8; priority<32; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,1)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 32~55 is using QuaterDeck Queue 2. */
+    for(priority=32; priority<56; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,2)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*    Priority 56~63 is using QuaterDeck Queue 3. */
+    for(priority=56; priority<64; priority++)
+    {
+        if((status = gcosSetDscp2Tc(dev,priority,3)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    /*
+     * Each port's default priority is set to 1.
+    */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if((status = gcosSetPortDefaultTc(dev,port,1)) != GT_OK)
+        {
+            MSG_PRINT(("gcosSetDscp2Tc returned fail.\n"));
+            return status;
+        }
+    }
+
+    return GT_OK;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/QoSSetup/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/README b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/README
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/rmon.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/RMON/rmon.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/trailer.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/Trailer/trailer.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/hgVlan.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/hgVlan.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/readme.txt b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/VlanSetup/readme.txt
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/makefile
old mode 100644
new mode 100755
index 0a64060..a463ef3
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/makefile
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/sample/makefile
@@ -12,11 +12,11 @@ WORK_TO_DO = $(DEMONAME).o
 exe : $(WORK_TO_DO)
 
 # Include common variable definitions
-include $(TOOL_DIR)\make.defs
+include $(DSDT_TOOL_DIR)\make.defs
 
 .PHONY : exe
 
-QDLIB = $(LIB_DIR)/$(PROJ_NAME).o
+QDLIB = $(LIB_DIR)/$(DSDT_PROJ_NAME).o
 
 OBJDIRS	= $(subst /,\,$(dir $(QDLIB)))
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvConfig.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvConfig.c
old mode 100644
new mode 100755
index 488ebb2..2cb9828
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvConfig.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvConfig.c
@@ -28,10 +28,10 @@
 *       This function converts logical port number to physical port number
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -41,29 +41,29 @@
 GT_U8 lport2port
 (
     IN GT_U16    portVec,
-	IN GT_LPORT	 port
+    IN GT_LPORT     port
 )
 {
-    GT_U8	hwPort, tmpPort;
-
-	tmpPort = hwPort = 0;
-
-	while (portVec)
-	{
-		if(portVec & 0x1)
-		{
-			if((GT_LPORT)tmpPort == port)
-				break;
-			tmpPort++;
-		}
-		hwPort++;
-		portVec >>= 1;
-	}
-
-	if (!portVec)
-		hwPort = GT_INVALID_PORT;
-
-	return hwPort;
+    GT_U8    hwPort, tmpPort;
+
+    tmpPort = hwPort = 0;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if((GT_LPORT)tmpPort == port)
+                break;
+            tmpPort++;
+        }
+        hwPort++;
+        portVec >>= 1;
+    }
+
+    if (!portVec)
+        hwPort = GT_INVALID_PORT;
+
+    return hwPort;
 }
 
 /*******************************************************************************
@@ -73,10 +73,10 @@ GT_U8 lport2port
 *       This function converts physical port number to logical port number
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -86,29 +86,29 @@ GT_U8 lport2port
 GT_LPORT port2lport
 (
     IN GT_U16    portVec,
-	IN GT_U8	 hwPort
+    IN GT_U8     hwPort
 )
 {
-    GT_U8		tmpPort,port;
-
-	port = 0;
-	
-	if (hwPort == GT_INVALID_PORT)
-		return (GT_LPORT)hwPort;
-
-	if (!GT_IS_PORT_SET(portVec, hwPort))
-		return (GT_LPORT)GT_INVALID_PORT;
-
-	for (tmpPort = 0; tmpPort <= hwPort; tmpPort++)
-	{
-		if(portVec & 0x1)
-		{
-			port++;
-		}
-		portVec >>= 1;
-	}
-
-	return (GT_LPORT)port-1;
+    GT_U8        tmpPort,port;
+
+    port = 0;
+    
+    if (hwPort == GT_INVALID_PORT)
+        return (GT_LPORT)hwPort;
+
+    if (!GT_IS_PORT_SET(portVec, hwPort))
+        return (GT_LPORT)GT_INVALID_PORT;
+
+    for (tmpPort = 0; tmpPort <= hwPort; tmpPort++)
+    {
+        if(portVec & 0x1)
+        {
+            port++;
+        }
+        portVec >>= 1;
+    }
+
+    return (GT_LPORT)port-1;
 }
 
 /*******************************************************************************
@@ -118,10 +118,10 @@ GT_LPORT port2lport
 *       This function converts logical port vector to physical port vector
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		lVec 	- logical port vector
+*        portVec - physical port list in vector
+*        lVec     - logical port vector
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port vector
 *
@@ -131,33 +131,33 @@ GT_LPORT port2lport
 GT_U32 lportvec2portvec
 (
     IN GT_U16    portVec,
-	IN GT_U32	 lVec
+    IN GT_U32     lVec
 )
 {
-    GT_U32	pVec, vec;
-
-	pVec = 0;
-	vec = 1;
-
-	while (portVec)
-	{
-		if(portVec & 0x1)
-		{
-			if(lVec & 0x1)
-			{
-				pVec |= vec;
-			}
-			lVec >>= 1;
-		}
-
-		vec <<= 1;
-		portVec >>= 1;
-	}
-
-	if(lVec)
-		return GT_INVALID_PORT_VEC;
-
-	return pVec;
+    GT_U32    pVec, vec;
+
+    pVec = 0;
+    vec = 1;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if(lVec & 0x1)
+            {
+                pVec |= vec;
+            }
+            lVec >>= 1;
+        }
+
+        vec <<= 1;
+        portVec >>= 1;
+    }
+
+    if(lVec)
+        return GT_INVALID_PORT_VEC;
+
+    return pVec;
 }
 
 /*******************************************************************************
@@ -167,10 +167,10 @@ GT_U32 lportvec2portvec
 *       This function converts physical port vector to logical port vector
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		pVec 	- physical port vector
+*        portVec - physical port list in vector
+*        pVec     - physical port vector
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       logical port vector
 *
@@ -180,30 +180,30 @@ GT_U32 lportvec2portvec
 GT_U32 portvec2lportvec
 (
     IN GT_U16    portVec,
-	IN GT_U32	 pVec
+    IN GT_U32     pVec
 )
 {
-    GT_U32	lVec, vec;
-
-	lVec = 0;
-	vec = 1;
-
-	while (portVec)
-	{
-		if(portVec & 0x1)
-		{
-			if(pVec & 0x1)
-			{
-				lVec |= vec;
-			}
-			vec <<= 1;
-		}
-
-		pVec >>= 1;
-		portVec >>= 1;
-	}
-
-	return lVec;
+    GT_U32    lVec, vec;
+
+    lVec = 0;
+    vec = 1;
+
+    while (portVec)
+    {
+        if(portVec & 0x1)
+        {
+            if(pVec & 0x1)
+            {
+                lVec |= vec;
+            }
+            vec <<= 1;
+        }
+
+        pVec >>= 1;
+        portVec >>= 1;
+    }
+
+    return lVec;
 }
 
 /*******************************************************************************
@@ -213,10 +213,10 @@ GT_U32 portvec2lportvec
 *       This function converts logical port number to physical phy number.
 *
 * INPUTS:
-*		portVec - physical port list in vector
-*		port    - logical port number
+*        portVec - physical port list in vector
+*        port    - logical port number
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       physical port number
 *
@@ -226,22 +226,22 @@ GT_U32 portvec2lportvec
 GT_U8 lport2phy
 (
     IN GT_QD_DEV    *dev,
-	IN GT_LPORT	 port
+    IN GT_LPORT     port
 )
 {
-    GT_U8	hwPort;
-
-	/* check if it's for SERDES */
-	if(dev->validSerdesVec & (1<<port))
-	{
-		hwPort = (GT_U8)port;			
-	}
-	else
-	{
-		hwPort = GT_LPORT_2_PORT(port);
-	}
-
-	return hwPort;
+    GT_U8    hwPort;
+
+    /* check if it's for SERDES */
+    if(dev->validSerdesVec & (1<<port))
+    {
+        hwPort = (GT_U8)port;            
+    }
+    else
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+    }
+
+    return hwPort;
 }
 
 
@@ -252,9 +252,9 @@ GT_U8 lport2phy
 *       This function initializes the driver level of the quarterDeck software.
 *
 * INPUTS:
-*		None.
+*        None.
 * OUTPUTS:
-*		None.
+*        None.
 * RETURNS:
 *       GT_OK               - on success, or
 *       GT_OUT_OF_CPU_MEM   - if failed to allocate CPU memory,
@@ -277,24 +277,24 @@ GT_STATUS driverConfig
 #endif    
     GT_BOOL         highSmiDevAddr;
 
-	if(dev->accessMode == SMI_AUTO_SCAN_MODE)
-	{	
-	    /* Initialize the MII / SMI interface, search for the device */
-    	if((deviceId = miiSmiIfInit(dev,&highSmiDevAddr)) == 0)
-	    {
-    	    return GT_FAIL;
-	    }
-
-		dev->baseRegAddr = (highSmiDevAddr)?0x10:0;
-	}
-	else
-	{
-    	if((deviceId = miiSmiManualIfInit(dev,(GT_U32)dev->baseRegAddr)) == 0)
-	    {
-    	    return GT_FAIL;
-	    }
-	}
-	
+    if(dev->accessMode == SMI_AUTO_SCAN_MODE)
+    {    
+        /* Initialize the MII / SMI interface, search for the device */
+        if((deviceId = miiSmiIfInit(dev,&highSmiDevAddr)) == 0)
+        {
+            return GT_FAIL;
+        }
+
+        dev->baseRegAddr = (highSmiDevAddr)?0x10:0;
+    }
+    else
+    {
+        if((deviceId = miiSmiManualIfInit(dev,(GT_U32)dev->baseRegAddr)) == 0)
+        {
+            return GT_FAIL;
+        }
+    }
+    
     /* Init the device's config struct.             */
     dev->deviceId       = deviceId >> 4;
     dev->revision       = (GT_U8)deviceId & 0xF; 
@@ -348,57 +348,57 @@ GT_STATUS driverConfig
 *******************************************************************************/
 GT_STATUS driverEnable
 (
-	IN GT_QD_DEV    *dev
+    IN GT_QD_DEV    *dev
 )
 {
-	GT_UNUSED_PARAM(dev);
+    GT_UNUSED_PARAM(dev);
     return GT_OK;
 }
 
 
 GT_STATUS driverGetSerdesPort(GT_QD_DEV *dev, GT_U8* hwPort)
 {
-	switch(dev->deviceId)
-	{
-		case GT_88E6122:
-			if ((*hwPort<3) || (*hwPort>6))
-			{
-				*hwPort = GT_INVALID_PORT;
-			}
-			else
-			{
-				*hwPort += 9;
-			}
-			break;
-		case GT_88E6131:
-		case GT_88E6108:
-			if ((*hwPort<4) || (*hwPort>7))
-			{
-				*hwPort = GT_INVALID_PORT;
-			}
-			else
-			{
-				*hwPort += 8;
-			}
-			break;
-		case GT_88E6123:
-		case GT_88E6140:
-		case GT_88E6161:
-		case GT_88E6165:
-			if ((*hwPort<4) || (*hwPort>5))
-			{
-				*hwPort = GT_INVALID_PORT;
-			}
-			else
-			{
-				*hwPort += 8;
-			}
-			break;
-		default:
-			*hwPort = GT_INVALID_PORT;
-			break;
-	}
-	return GT_OK;
+    switch(dev->deviceId)
+    {
+        case GT_88E6122:
+            if ((*hwPort<3) || (*hwPort>6))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+                *hwPort += 9;
+            }
+            break;
+        case GT_88E6131:
+        case GT_88E6108:
+            if ((*hwPort<4) || (*hwPort>7))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+                *hwPort += 8;
+            }
+            break;
+        case GT_88E6123:
+        case GT_88E6140:
+        case GT_88E6161:
+        case GT_88E6165:
+            if ((*hwPort<4) || (*hwPort>5))
+            {
+                *hwPort = GT_INVALID_PORT;
+            }
+            else
+            {
+                *hwPort += 8;
+            }
+            break;
+        default:
+            *hwPort = GT_INVALID_PORT;
+            break;
+    }
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -408,13 +408,13 @@ GT_STATUS driverGetSerdesPort(GT_QD_DEV *dev, GT_U8* hwPort)
 *       This function get Phy ID from Phy register 2 and 3.
 *
 * INPUTS:
-*       hwPort	- port number where the Phy is connected
+*       hwPort    - port number where the Phy is connected
 *
 * OUTPUTS:
-*       phyId	- Phy ID
+*       phyId    - Phy ID
 *
 * RETURNS:
-*       GT_OK 	- if found Marvell Phy,
+*       GT_OK     - if found Marvell Phy,
 *       GT_FAIL - othrwise.
 *
 * COMMENTS:
@@ -423,31 +423,31 @@ GT_STATUS driverGetSerdesPort(GT_QD_DEV *dev, GT_U8* hwPort)
 *******************************************************************************/
 static GT_STATUS driverFindPhyID
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort,
-	OUT	GT_U32		 *phyID
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    OUT    GT_U32         *phyID
 )
 {
-	GT_U16 ouiMsb, ouiLsb;
-	GT_STATUS status;
-	
-	if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read Phy Register.\n"));
-		return status;
-	}
-
-	if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read Phy Register.\n"));
-		return status;
-	}
-
-	if(ouiMsb != MARVELL_OUI_MSb)
-		return GT_FAIL;
-
-	*phyID = (GT_U32)ouiLsb;
-					
+    GT_U16 ouiMsb, ouiLsb;
+    GT_STATUS status;
+    
+    if((status= hwReadPhyReg(dev,hwPort,2,&ouiMsb)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
+
+    if((status= hwReadPhyReg(dev,hwPort,3,&ouiLsb)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
+
+    if(ouiMsb != MARVELL_OUI_MSb)
+        return GT_FAIL;
+
+    *phyID = (GT_U32)ouiLsb;
+                    
     return GT_OK;
 }
 
@@ -459,14 +459,14 @@ static GT_STATUS driverFindPhyID
 *       This function verifies Marvell Phy.
 *
 * INPUTS:
-*       hwPort	- port number where the Phy is connected
+*       hwPort    - port number where the Phy is connected
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       1 - if Marvell Phy exists
-*		0 - otherwise
+*        0 - otherwise
 *
 * COMMENTS:
 *       None.
@@ -474,22 +474,22 @@ static GT_STATUS driverFindPhyID
 *******************************************************************************/
 GT_U32 driverIsPhyAttached
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
 )
 {
-	GT_U32		 phyId;
+    GT_U32         phyId;
 
-	if(hwPort > dev->maxPhyNum)
-		return 0;
+    if(hwPort > dev->maxPhyNum)
+        return 0;
 
-	if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
-	{
-	    DBG_INFO(("cannot find Marvell Phy.\n"));
-		return 0;
-	}
+    if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
+    {
+        DBG_INFO(("cannot find Marvell Phy.\n"));
+        return 0;
+    }
 
-	return 1;
+    return 1;
 }
 
 /*******************************************************************************
@@ -499,14 +499,14 @@ GT_U32 driverIsPhyAttached
 *       This function reads and returns Phy ID (register 3) of Marvell Phy.
 *
 * INPUTS:
-*       hwPort	- port number where the Phy is connected
+*       hwPort    - port number where the Phy is connected
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       phyId - if Marvell Phy exists
-*		GT_INVALID_PORT	  - otherwise
+*        GT_INVALID_PORT      - otherwise
 *
 * COMMENTS:
 *       None.
@@ -514,22 +514,22 @@ GT_U32 driverIsPhyAttached
 *******************************************************************************/
 GT_U32 driverGetPhyID
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort
 )
 {
-	GT_U32		 phyId;
+    GT_U32         phyId;
 
-	if(hwPort > dev->maxPhyNum)
-		return GT_INVALID_PHY;
+    if(hwPort > dev->maxPhyNum)
+        return GT_INVALID_PHY;
 
-	if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
-	{
-	    DBG_INFO(("cannot find Marvell Phy.\n"));
-		return GT_INVALID_PHY;
-	}
+    if(driverFindPhyID(dev,hwPort,&phyId) != GT_OK)
+    {
+        DBG_INFO(("cannot find Marvell Phy.\n"));
+        return GT_INVALID_PHY;
+    }
 
-	return phyId;
+    return phyId;
 }
 
 /*******************************************************************************
@@ -539,15 +539,15 @@ GT_U32 driverGetPhyID
 *       This function stores page register and Auto Reg Selection mode if needed.
 *
 * INPUTS:
-*       hwPort	 - port number where the Phy is connected
-*		pageType - type of the page registers
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
 *
 * OUTPUTS:
-*       autoOn	- GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
-*		pageReg - Page Register Data
+*       autoOn    - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg - Page Register Data
 *
 * RETURNS:
-*       GT_OK 	- if success
+*       GT_OK     - if success
 *       GT_FAIL - othrwise.
 *
 * COMMENTS:
@@ -556,73 +556,73 @@ GT_U32 driverGetPhyID
 *******************************************************************************/
 GT_STATUS driverPagedAccessStart
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort,
-	IN	GT_U8		 pageType,
-	OUT	GT_BOOL		 *autoOn,
-	OUT	GT_U16		 *pageReg
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    OUT    GT_BOOL         *autoOn,
+    OUT    GT_U16         *pageReg
 )
 {
-	GT_U16 data;
-	GT_STATUS status;
-
-	switch(pageType)
-	{
-		case GT_PHY_PAGE_WRITE_BACK:
-			break;
-		case GT_PHY_PAGE_DIS_AUTO1:	/* 88E1111 Type */
-			if((status= hwGetPhyRegField(dev,hwPort,27,9,1,&data)) != GT_OK)
-			{
-	    		DBG_INFO(("Not able to read Phy Register.\n"));
-				return status;
-			}
-
-			data ^= 0x1;	/* toggle bit 0 */
-		    BIT_2_BOOL(data, *autoOn);
-
-			if (*autoOn) /* Auto On */
-			{
-				if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
-				{
-	    			DBG_INFO(("Not able to write Phy Register.\n"));
-					return status;
-				}
-			}
-
-			break;	
-		case GT_PHY_PAGE_DIS_AUTO2:	/* 88E1112 Type */
-			if((status= hwGetPhyRegField(dev,hwPort,22,15,1,&data)) != GT_OK)
-			{
-	    		DBG_INFO(("Not able to read Phy Register.\n"));
-				return status;
-			}
-
-		    BIT_2_BOOL(data, *autoOn);
-			data ^= 0x1;	/* toggle bit 0 */
-
-			if (*autoOn) /* Auto On */
-			{
-				if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
-				{
-	    			DBG_INFO(("Not able to write Phy Register.\n"));
-					return status;
-				}
-			}
-
-			break;	
-
-		case GT_PHY_NO_PAGE:
-		default:
-			/* Nothing to do */
-			return GT_OK;
-	}
-
-
-	if((status= hwGetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read Phy Register.\n"));
-		return status;
-	}
+    GT_U16 data;
+    GT_STATUS status;
+
+    switch(pageType)
+    {
+        case GT_PHY_PAGE_WRITE_BACK:
+            break;
+        case GT_PHY_PAGE_DIS_AUTO1:    /* 88E1111 Type */
+            if((status= hwGetPhyRegField(dev,hwPort,27,9,1,&data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to read Phy Register.\n"));
+                return status;
+            }
+
+            data ^= 0x1;    /* toggle bit 0 */
+            BIT_2_BOOL(data, *autoOn);
+
+            if (*autoOn) /* Auto On */
+            {
+                if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;    
+        case GT_PHY_PAGE_DIS_AUTO2:    /* 88E1112 Type */
+            if((status= hwGetPhyRegField(dev,hwPort,22,15,1,&data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to read Phy Register.\n"));
+                return status;
+            }
+
+            BIT_2_BOOL(data, *autoOn);
+            data ^= 0x1;    /* toggle bit 0 */
+
+            if (*autoOn) /* Auto On */
+            {
+                if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;    
+
+        case GT_PHY_NO_PAGE:
+        default:
+            /* Nothing to do */
+            return GT_OK;
+    }
+
+
+    if((status= hwGetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read Phy Register.\n"));
+        return status;
+    }
 
     return GT_OK;
 }
@@ -635,16 +635,16 @@ GT_STATUS driverPagedAccessStart
 *       This function restores page register and Auto Reg Selection mode if needed.
 *
 * INPUTS:
-*       hwPort	 - port number where the Phy is connected
-*		pageType - type of the page registers
-*       autoOn	 - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
-*		pageReg  - Page Register Data
+*       hwPort     - port number where the Phy is connected
+*        pageType - type of the page registers
+*       autoOn     - GT_TRUE if Auto Reg Selection enabled, GT_FALSE otherwise.
+*        pageReg  - Page Register Data
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*       GT_OK 	- if success
+*       GT_OK     - if success
 *       GT_FAIL - othrwise.
 *
 * COMMENTS:
@@ -653,57 +653,57 @@ GT_STATUS driverPagedAccessStart
 *******************************************************************************/
 GT_STATUS driverPagedAccessStop
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort,
-	IN	GT_U8		 pageType,
-	IN	GT_BOOL		 autoOn,
-	IN	GT_U16		 pageReg
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    IN    GT_U8         pageType,
+    IN    GT_BOOL         autoOn,
+    IN    GT_U16         pageReg
 )
 {
-	GT_U16 data;
-	GT_STATUS status;
-
-	switch(pageType)
-	{
-		case GT_PHY_PAGE_WRITE_BACK:
-			break;
-		case GT_PHY_PAGE_DIS_AUTO1:	/* 88E1111 Type */
-			if (autoOn) /* Auto On */
-			{
-				data = 0;
-				if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
-				{
-	    			DBG_INFO(("Not able to write Phy Register.\n"));
-					return status;
-				}
-			}
-
-			break;	
-		case GT_PHY_PAGE_DIS_AUTO2:	/* 88E1112 Type */
-			if (autoOn) /* Auto On */
-			{
-				data = 1;
-				if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
-				{
-	    			DBG_INFO(("Not able to write Phy Register.\n"));
-					return status;
-				}
-			}
-
-			break;	
-
-		case GT_PHY_NO_PAGE:
-		default:
-			/* Nothing to do */
-			return GT_OK;
-	}
-
-
-	if((status= hwSetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to write Phy Register.\n"));
-		return status;
-	}
+    GT_U16 data;
+    GT_STATUS status;
+
+    switch(pageType)
+    {
+        case GT_PHY_PAGE_WRITE_BACK:
+            break;
+        case GT_PHY_PAGE_DIS_AUTO1:    /* 88E1111 Type */
+            if (autoOn) /* Auto On */
+            {
+                data = 0;
+                if((status= hwSetPhyRegField(dev,hwPort,27,9,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;    
+        case GT_PHY_PAGE_DIS_AUTO2:    /* 88E1112 Type */
+            if (autoOn) /* Auto On */
+            {
+                data = 1;
+                if((status= hwSetPhyRegField(dev,hwPort,22,15,1,data)) != GT_OK)
+                {
+                    DBG_INFO(("Not able to write Phy Register.\n"));
+                    return status;
+                }
+            }
+
+            break;    
+
+        case GT_PHY_NO_PAGE:
+        default:
+            /* Nothing to do */
+            return GT_OK;
+    }
+
+
+    if((status= hwSetPhyRegField(dev,hwPort,22,0,8,pageReg)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Register.\n"));
+        return status;
+    }
 
     return GT_OK;
 }
@@ -714,16 +714,16 @@ GT_STATUS driverPagedAccessStop
 *
 * DESCRIPTION:
 *       This function gets information of Phy connected to the given port.
-*		PhyInfo structure should have valid Phy ID.
+*        PhyInfo structure should have valid Phy ID.
 *
 * INPUTS:
-*       hwPort	- port number where the Phy is connected
+*       hwPort    - port number where the Phy is connected
 *
 * OUTPUTS:
-*       phyId	- Phy ID
+*       phyId    - Phy ID
 *
 * RETURNS:
-*       GT_OK 	- if found Marvell Phy,
+*       GT_OK     - if found Marvell Phy,
 *       GT_FAIL - othrwise.
 *
 * COMMENTS:
@@ -732,247 +732,247 @@ GT_STATUS driverPagedAccessStop
 *******************************************************************************/
 GT_STATUS driverFindPhyInformation
 (
-	IN  GT_QD_DEV    *dev,
-	IN	GT_U8		 hwPort,
-	OUT	GT_PHY_INFO	 *phyInfo
+    IN  GT_QD_DEV    *dev,
+    IN    GT_U8         hwPort,
+    OUT    GT_PHY_INFO     *phyInfo
 )
 {
-	GT_U32 phyId;
-	GT_U16 data;
-
-	phyId = phyInfo->phyId;
-
-	switch (phyId & PHY_MODEL_MASK)
-	{
-		case DEV_E3082:
-				phyInfo->anyPage = 0xFFFFFFFF;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_COPPER;
-				phyInfo->vctType = GT_PHY_VCT_TYPE1;
-				phyInfo->exStatusType = 0;
-				if ((phyId & PHY_REV_MASK) < 9)
-					phyInfo->dteType = GT_PHY_DTE_TYPE1;	/* need workaround */
-				else
-					phyInfo->dteType = GT_PHY_DTE_TYPE5;
-
-				phyInfo->pktGenType = 0;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_NO_PAGE;
-				break;
-
-	    case DEV_E104X:
-				phyInfo->anyPage = 0xFFFFFFFF;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_GIGABIT|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP;
-
-				phyInfo->dteType = 0;
-				if ((phyId & PHY_REV_MASK) < 3)
-					phyInfo->flag &= ~GT_PHY_VCT_CAPABLE; /* VCT is not supported */
-				else if ((phyId & PHY_REV_MASK) == 3)
-					phyInfo->vctType = GT_PHY_VCT_TYPE3;	/* Need workaround */
-				else 
-					phyInfo->vctType = GT_PHY_VCT_TYPE2;
-				phyInfo->exStatusType = 0;
-
-				phyInfo->pktGenType = 0;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_NO_PAGE;
-
-				break;
-
-		case DEV_E1111:
-				phyInfo->anyPage = 0xFFF1FE0C;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
-
-				phyInfo->vctType = GT_PHY_VCT_TYPE2;
-				phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
-				if ((phyId & PHY_REV_MASK) < 2)
-					phyInfo->dteType = GT_PHY_DTE_TYPE3;	/* Need workaround */
-				else
-					phyInfo->dteType = GT_PHY_DTE_TYPE2;
-
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
-				break;
-
-		case DEV_E1112:
-				phyInfo->anyPage = 0x1BC0780C;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_PKT_GENERATOR;
-
-				phyInfo->vctType = GT_PHY_VCT_TYPE4;
-				phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE2;
-				phyInfo->dteType = GT_PHY_DTE_TYPE4;
-
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO2;
-				break;
-
-		case DEV_E114X:
-				phyInfo->anyPage = 0x2FF1FE0C;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
-
-				phyInfo->vctType = GT_PHY_VCT_TYPE2;
-				phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
-				if ((phyId & PHY_REV_MASK) < 4)
-					phyInfo->dteType = GT_PHY_DTE_TYPE3;	/* Need workaround */
-				else
-					phyInfo->dteType = GT_PHY_DTE_TYPE2;
-
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
-
-				break;
-
-		case DEV_E1149:
-				phyInfo->anyPage = 0x2040FFFF;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_GIGABIT|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_PKT_GENERATOR;
-				phyInfo->vctType = GT_PHY_VCT_TYPE4;
-				phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
-				phyInfo->dteType = GT_PHY_DTE_TYPE4;
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
-				break;
-
-		case DEV_G15LV:
-				if (IS_IN_DEV_GROUP(dev,DEV_88E6108))
-				{
-					phyInfo->anyPage = 0x2040FFFF;
-					phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-									GT_PHY_EX_CABLE_STATUS|
-									GT_PHY_GIGABIT|
-									GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-									GT_PHY_PKT_GENERATOR;
-					phyInfo->vctType = GT_PHY_VCT_TYPE4;
-					phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
-					phyInfo->dteType = GT_PHY_DTE_TYPE4;
-					phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
-					phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-					phyInfo->lineLoopType = 0;
-					phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-					phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
-				}
-				else /* 88E6165 family */
-				{
-					phyInfo->anyPage = 0x2040FFFF;
-					phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-									GT_PHY_EX_CABLE_STATUS|
-									GT_PHY_GIGABIT|
-									GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-									GT_PHY_PKT_GENERATOR;
-					phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
-					phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
-					phyInfo->dteType = GT_PHY_DTE_TYPE4;
-					phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
-					phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-					phyInfo->lineLoopType = 0;
-					phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-					phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
-				}
-				break;
-
-		case DEV_EC010:
-				phyInfo->anyPage = 0x2040780C;
-				phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP;
-				phyInfo->vctType = GT_PHY_VCT_TYPE2;
-				phyInfo->exStatusType = 0;
-				phyInfo->dteType = GT_PHY_DTE_TYPE3;	/* Need workaround */
-				phyInfo->pktGenType = 0;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
-				break;
-
-		case DEV_S15LV:
-				phyInfo->anyPage = 0xFFFFFFFF;
-				phyInfo->flag = GT_PHY_SERDES_CORE|GT_PHY_GIGABIT|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_PKT_GENERATOR;
-				phyInfo->vctType = 0;
-				phyInfo->exStatusType = 0;
-				phyInfo->dteType = 0;
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE3;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE3;
-				phyInfo->lineLoopType = GT_PHY_LINE_LB_TYPE4;
-				phyInfo->exLoopType = 0;
-				phyInfo->pageType = GT_PHY_NO_PAGE;
-				break;
-
-		case DEV_G65G:
-				phyInfo->anyPage = 0x2040FFFF;
-				phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
-								GT_PHY_EX_CABLE_STATUS|
-								GT_PHY_GIGABIT|
-								GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
-								GT_PHY_PKT_GENERATOR;
-				phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
-				phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
-				phyInfo->dteType = GT_PHY_DTE_TYPE4;
-				phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
-				phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
-				phyInfo->lineLoopType = 0;
-				phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
-				phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
-				break;
-
-		default:
-			return GT_FAIL;
-	}
-					
-	if (phyInfo->flag & GT_PHY_GIGABIT)
-	{
-	    if(hwGetPhyRegField(dev,hwPort,15,12,4,&data) != GT_OK)
-		{
-        	DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,15));
-	   	    return GT_FAIL;
-		}
-
-		if(data & QD_GIGPHY_1000X_CAP)
-			phyInfo->flag |= GT_PHY_FIBER;
-
-		if(data & QD_GIGPHY_1000T_CAP)
-		{
-			phyInfo->flag |= GT_PHY_COPPER;
-		}
-		else
-		{
-			phyInfo->flag &= ~(GT_PHY_VCT_CAPABLE|GT_PHY_EX_CABLE_STATUS|GT_PHY_DTE_CAPABLE|GT_PHY_ADV_VCT_CAPABLE);
-		}
-	}
+    GT_U32 phyId;
+    GT_U16 data;
+
+    phyId = phyInfo->phyId;
+
+    switch (phyId & PHY_MODEL_MASK)
+    {
+        case DEV_E3082:
+        case DEV_MELODY:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_COPPER;
+                phyInfo->vctType = GT_PHY_VCT_TYPE1;
+                phyInfo->exStatusType = 0;
+                if ((phyId & PHY_REV_MASK) < 9)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE1;    /* need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE5;
+
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+                break;
+
+        case DEV_E104X:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_EXTERNAL_LOOP;
+
+                phyInfo->dteType = 0;
+                if ((phyId & PHY_REV_MASK) < 3)
+                    phyInfo->flag &= ~GT_PHY_VCT_CAPABLE; /* VCT is not supported */
+                else if ((phyId & PHY_REV_MASK) == 3)
+                    phyInfo->vctType = GT_PHY_VCT_TYPE3;    /* Need workaround */
+                else 
+                    phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = 0;
+
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+
+                break;
+
+        case DEV_E1111:
+                phyInfo->anyPage = 0xFFF1FE0C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
+                if ((phyId & PHY_REV_MASK) < 2)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE2;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
+                break;
+
+        case DEV_E1112:
+                phyInfo->anyPage = 0x1BC0780C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE2;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO2;
+                break;
+
+        case DEV_E114X:
+                phyInfo->anyPage = 0x2FF1FE0C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE;
+
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE1;
+                if ((phyId & PHY_REV_MASK) < 4)
+                    phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                else
+                    phyInfo->dteType = GT_PHY_DTE_TYPE2;
+
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE1;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_DIS_AUTO1;
+
+                break;
+
+        case DEV_E1149:
+                phyInfo->anyPage = 0x2040FFFF;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+
+        case DEV_G15LV:
+                if (dev->devName1 &DEV_88E6108)
+                {
+                    phyInfo->anyPage = 0x2040FFFF;
+                    phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                    GT_PHY_EX_CABLE_STATUS|
+                                    GT_PHY_GIGABIT|
+                                    GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                    GT_PHY_PKT_GENERATOR;
+                    phyInfo->vctType = GT_PHY_VCT_TYPE4;
+                    phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE3;
+                    phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                    phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                    phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                    phyInfo->lineLoopType = 0;
+                    phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                    phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                }
+                else /* 88E6165 family */
+                {
+                    phyInfo->anyPage = 0x2040FFFF;
+                    phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                    GT_PHY_EX_CABLE_STATUS|
+                                    GT_PHY_GIGABIT|
+                                    GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                    GT_PHY_PKT_GENERATOR;
+                    phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
+                    phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
+                    phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                    phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                    phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                    phyInfo->lineLoopType = 0;
+                    phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                    phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                }
+                break;
+
+        case DEV_EC010:
+                phyInfo->anyPage = 0x2040780C;
+                phyInfo->flag = GT_PHY_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|GT_PHY_RESTRICTED_PAGE|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP;
+                phyInfo->vctType = GT_PHY_VCT_TYPE2;
+                phyInfo->exStatusType = 0;
+                phyInfo->dteType = GT_PHY_DTE_TYPE3;    /* Need workaround */
+                phyInfo->pktGenType = 0;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+
+        case DEV_S15LV:
+                phyInfo->anyPage = 0xFFFFFFFF;
+                phyInfo->flag = GT_PHY_SERDES_CORE|GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = 0;
+                phyInfo->exStatusType = 0;
+                phyInfo->dteType = 0;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE3;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE3;
+                phyInfo->lineLoopType = GT_PHY_LINE_LB_TYPE4;
+                phyInfo->exLoopType = 0;
+                phyInfo->pageType = GT_PHY_NO_PAGE;
+                break;
+
+        case DEV_G65G:
+                phyInfo->anyPage = 0x2040FFFF;
+                phyInfo->flag = GT_PHY_ADV_VCT_CAPABLE|GT_PHY_DTE_CAPABLE|
+                                GT_PHY_EX_CABLE_STATUS|
+                                GT_PHY_GIGABIT|
+                                GT_PHY_MAC_IF_LOOP|GT_PHY_LINE_LOOP|GT_PHY_EXTERNAL_LOOP|
+                                GT_PHY_PKT_GENERATOR;
+                phyInfo->vctType = GT_PHY_ADV_VCT_TYPE2;
+                phyInfo->exStatusType = GT_PHY_EX_STATUS_TYPE6;
+                phyInfo->dteType = GT_PHY_DTE_TYPE4;
+                phyInfo->pktGenType = GT_PHY_PKTGEN_TYPE2;
+                phyInfo->macIfLoopType = GT_PHY_LOOPBACK_TYPE1;
+                phyInfo->lineLoopType = 0;
+                phyInfo->exLoopType = GT_PHY_EX_LB_TYPE0;
+                phyInfo->pageType = GT_PHY_PAGE_WRITE_BACK;
+                break;
+        default:
+            return GT_FAIL;
+    }
+                    
+    if (phyInfo->flag & GT_PHY_GIGABIT)
+    {
+        if(hwGetPhyRegField(dev,hwPort,15,12,4,&data) != GT_OK)
+        {
+            DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,15));
+               return GT_FAIL;
+        }
+
+        if(data & QD_GIGPHY_1000X_CAP)
+            phyInfo->flag |= GT_PHY_FIBER;
+
+        if(data & QD_GIGPHY_1000T_CAP)
+        {
+            phyInfo->flag |= GT_PHY_COPPER;
+        }
+        else
+        {
+            phyInfo->flag &= ~(GT_PHY_VCT_CAPABLE|GT_PHY_EX_CABLE_STATUS|GT_PHY_DTE_CAPABLE|GT_PHY_ADV_VCT_CAPABLE);
+        }
+    }
 
     return GT_OK;
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvEvents.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtDrvEvents.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtHwCntl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtHwCntl.c
old mode 100644
new mode 100755
index 9c06a45..be1f644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtHwCntl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/gtHwCntl.c
@@ -24,41 +24,42 @@ static GT_STATUS hwReadPPU(GT_QD_DEV *dev, GT_U16 *data);
 static GT_STATUS hwWritePPU(GT_QD_DEV *dev, GT_U16 data);
 static GT_STATUS coreReadPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	OUT GT_U16   *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
 );
 static GT_STATUS coreWritePhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
 );
 static GT_STATUS coreReadPagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	OUT GT_U16   *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
 );
 static GT_STATUS coreWritePagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
 );
 
 static GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
                         GT_U16* value);
 static GT_STATUS phyRegWritePPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
                        GT_U16 value);
+#ifndef GT_RMGMT_ACCESS
 static GT_STATUS phyReadGlobal2Reg
 (
     IN GT_QD_DEV *dev,
@@ -71,6 +72,7 @@ static GT_STATUS phyWriteGlobal2Reg
     IN  GT_U8    regAddr,
     IN  GT_U16   data
 );
+#endif
 
 
 /*******************************************************************************
@@ -80,9 +82,9 @@ static GT_STATUS phyWriteGlobal2Reg
 *       This function mapps port to smi address
 *
 * INPUTS:
-*		dev - device context
+*        dev - device context
 *       portNum - Port number to read the register for.
-*		accessType - type of register (Phy, Port, or Global)
+*        accessType - type of register (Phy, Port, or Global)
 *
 * OUTPUTS:
 *       None.
@@ -94,62 +96,68 @@ static GT_STATUS phyWriteGlobal2Reg
 GT_U8 portToSmiMapping
 (
     IN GT_QD_DEV *dev,
-    IN GT_U8	portNum,
-	IN GT_U32	accessType
+    IN GT_U8    portNum,
+    IN GT_U32    accessType
 )
 {
-	GT_U8 smiAddr;
-
-	if(IS_IN_DEV_GROUP(dev,DEV_8PORT_SWITCH))
-	{
-		switch(accessType)
-		{
-			case PHY_ACCESS:
-					if (dev->validPhyVec & (1<<portNum))
-						smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
-					else
-						smiAddr = 0xFF;
-					break;
-			case PORT_ACCESS:
-					if (dev->validPortVec & (1<<portNum))
-						smiAddr = PORT_REGS_START_ADDR_8PORT + portNum;
-					else
-						smiAddr = 0xFF;
-					break;
-			case GLOBAL_REG_ACCESS:
-					smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
-					break;
-			default:
-					smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
-					break;
-		}
-	}
-	else
-	{
-		smiAddr = dev->baseRegAddr;
-		switch(accessType)
-		{
-			case PHY_ACCESS:
-					if (dev->validPhyVec & (1<<portNum))
-						smiAddr += PHY_REGS_START_ADDR + portNum;
-					else
-						smiAddr = 0xFF;
-					break;
-			case PORT_ACCESS:
-					if (dev->validPortVec & (1<<portNum))
-						smiAddr += PORT_REGS_START_ADDR + portNum;
-					else
-						smiAddr = 0xFF;
-					break;
-			case GLOBAL_REG_ACCESS:
-					smiAddr += GLOBAL_REGS_START_ADDR;
-					break;
-			default:
-					smiAddr += GLOBAL_REGS_START_ADDR - 1;
-					break;
-		}
-	}
+    GT_U8 smiAddr;
 
+    if(IS_IN_DEV_GROUP(dev,DEV_8PORT_SWITCH))
+    {
+        switch(accessType)
+        {
+            case PHY_ACCESS:
+                    if (dev->validPhyVec & (1<<portNum))
+                        smiAddr = PHY_REGS_START_ADDR_8PORT + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case PORT_ACCESS:
+                    if (dev->validPortVec & (1<<portNum))
+                        smiAddr = PORT_REGS_START_ADDR_8PORT + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case GLOBAL_REG_ACCESS:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT;
+                    break;
+            case GLOBAL3_REG_ACCESS:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 2;
+                    break;
+            default:
+                    smiAddr = GLOBAL_REGS_START_ADDR_8PORT + 1;
+                    break;
+        }
+    }
+    else
+    {
+        smiAddr = dev->baseRegAddr;
+        switch(accessType)
+        {
+            case PHY_ACCESS:
+                    if (dev->validPhyVec & (1<<portNum))
+                        smiAddr += PHY_REGS_START_ADDR + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case PORT_ACCESS:
+                    if (dev->validPortVec & (1<<portNum))
+                        smiAddr += PORT_REGS_START_ADDR + portNum;
+                    else
+                        smiAddr = 0xFF;
+                    break;
+            case GLOBAL_REG_ACCESS:
+                    smiAddr += GLOBAL_REGS_START_ADDR;
+                    break;
+            default:
+					/*  88EC0XX uses PORT_REGS_START_ADDR -1 */
+                    if(IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+                      smiAddr += PORT_REGS_START_ADDR - 1;
+        	        else
+                      smiAddr += GLOBAL_REGS_START_ADDR - 1;
+                    break;
+        }
+    }
     return smiAddr;
 }
 
@@ -181,21 +189,21 @@ GT_U8 portToSmiMapping
 *******************************************************************************/
 GT_STATUS hwReadPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	OUT GT_U16   *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
 )
 {
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreReadPhyReg(dev, portNum, regAddr, data);
+    retVal = coreReadPhyReg(dev, portNum, regAddr, data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -223,21 +231,21 @@ GT_STATUS hwReadPhyReg
 *******************************************************************************/
 GT_STATUS hwWritePhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
 )
 {
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreWritePhyReg(dev, portNum, regAddr, data);
+    retVal = coreWritePhyReg(dev, portNum, regAddr, data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -277,16 +285,16 @@ GT_STATUS hwGetPhyRegField
 {
     GT_U16 mask;            /* Bits mask to be read */
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
+    retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	if (retVal != GT_OK)
-		return retVal;
+    if (retVal != GT_OK)
+        return retVal;
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -297,7 +305,7 @@ GT_STATUS hwGetPhyRegField
               portNum,regAddr));
     DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -338,17 +346,17 @@ GT_STATUS hwSetPhyRegField
 {
     GT_U16 mask;
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
+    retVal = coreReadPhyReg(dev, portNum, regAddr, &tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -362,9 +370,9 @@ GT_STATUS hwSetPhyRegField
     DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
               fieldLength,data));
 
-	retVal = coreWritePhyReg(dev, portNum, regAddr, tmpData);
+    retVal = coreWritePhyReg(dev, portNum, regAddr, tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
     return retVal;
 }
 
@@ -379,7 +387,7 @@ GT_STATUS hwSetPhyRegField
 *       portNum - Port number to read the register for.
 *       pageNum - Page number of the register to be read.
 *       regAddr - The register's address.
-*		anyPage - Any Page register vector
+*        anyPage - Any Page register vector
 *
 * OUTPUTS:
 *       data    - The read register's data.
@@ -394,23 +402,23 @@ GT_STATUS hwSetPhyRegField
 *******************************************************************************/
 GT_STATUS hwReadPagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	OUT GT_U16   *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
 )
 {
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
+    retVal = coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -424,7 +432,7 @@ GT_STATUS hwReadPagedPhyReg
 *       portNum - Port number to write the register for.
 *       pageNum - Page number of the register to be written.
 *       regAddr - The register's address.
-*		anyPage - Any Page register vector
+*        anyPage - Any Page register vector
 *       data    - The data to be written.
 *
 * OUTPUTS:
@@ -440,23 +448,23 @@ GT_STATUS hwReadPagedPhyReg
 *******************************************************************************/
 GT_STATUS hwWritePagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
 )
 {
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-	retVal = coreWritePagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
+    retVal = coreWritePagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -465,15 +473,15 @@ GT_STATUS hwWritePagedPhyReg
 *
 * DESCRIPTION:
 *       This function reads a specified field from a switch's port phy register
-*		in page mode.
+*        in page mode.
 *
 * INPUTS:
 *       portNum     - Port number to read the register for.
-*       pageNum 	- Page number of the register to be read.
+*       pageNum     - Page number of the register to be read.
 *       regAddr     - The register's address.
 *       fieldOffset - The field start bit index. (0 - 15)
 *       fieldLength - Number of bits to read.
-*		anyPage 	- Any Page register vector
+*        anyPage     - Any Page register vector
 *
 * OUTPUTS:
 *       data        - The read register field.
@@ -495,24 +503,24 @@ GT_STATUS hwGetPagedPhyRegField
     IN  GT_U8    regAddr,
     IN  GT_U8    fieldOffset,
     IN  GT_U8    fieldLength,
-	IN  GT_U32	 anyPage,
+    IN  GT_U32     anyPage,
     OUT GT_U16   *data
 )
 {
     GT_U16 mask;            /* Bits mask to be read */
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,&tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	if(retVal != GT_OK)
-	{
+    if(retVal != GT_OK)
+    {
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -532,15 +540,15 @@ GT_STATUS hwGetPagedPhyRegField
 *
 * DESCRIPTION:
 *       This function writes to specified field in a switch's port phy register
-*		in page mode
+*        in page mode
 *
 * INPUTS:
 *       portNum     - Port number to write the register for.
-*       pageNum 	- Page number of the register to be read.
+*       pageNum     - Page number of the register to be read.
 *       regAddr     - The register's address.
 *       fieldOffset - The field start bit index. (0 - 15)
 *       fieldLength - Number of bits to write.
-*		anyPage 	- Any Page register vector
+*        anyPage     - Any Page register vector
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -563,21 +571,21 @@ GT_STATUS hwSetPagedPhyRegField
     IN  GT_U8    regAddr,
     IN  GT_U8    fieldOffset,
     IN  GT_U8    fieldLength,
-	IN  GT_U32	 anyPage,
+    IN  GT_U32     anyPage,
     IN  GT_U16   data
 )
 {
     GT_U16 mask;
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     if((retVal=coreReadPagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,&tmpData)) != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -592,9 +600,9 @@ GT_STATUS hwSetPagedPhyRegField
               fieldLength,data));
     retVal = coreWritePagedPhyReg(dev,portNum,pageNum,regAddr,anyPage,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;	
+    return retVal;    
 }
 
 
@@ -607,8 +615,8 @@ GT_STATUS hwSetPagedPhyRegField
 * INPUTS:
 *       portNum     - Port number to write the register for.
 *       u16Data     - data should be written into Phy control register.
-*					  if this value is 0xFF, normal operation occcurs (read, 
-*					  update, and write back.)
+*                      if this value is 0xFF, normal operation occcurs (read, 
+*                      update, and write back.)
 *
 * OUTPUTS:
 *       None.
@@ -622,73 +630,73 @@ GT_STATUS hwSetPagedPhyRegField
 *******************************************************************************/
 GT_STATUS hwPhyReset
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_U8		portNum,
-	IN	GT_U16		u16Data
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U8        portNum,
+    IN    GT_U16        u16Data
 )
 {
     GT_U16 tmpData;
     GT_STATUS   retVal;
     GT_U32 retryCount;
-	GT_BOOL	pd = GT_FALSE;
+    GT_BOOL    pd = GT_FALSE;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     if((retVal=coreReadPhyReg(dev,portNum,0,&tmpData)) 
-   	    != GT_OK)
+           != GT_OK)
     {
-   	    DBG_INFO(("Reading Register failed\n"));
-		gtSemGive(dev,dev->multiAddrSem);
-       	return retVal;
+           DBG_INFO(("Reading Register failed\n"));
+        gtSemGive(dev,dev->multiAddrSem);
+           return retVal;
     }
 
-	if (tmpData & 0x800)
-	{
-		pd = GT_TRUE;
-	}
+    if (tmpData & 0x800)
+    {
+        pd = GT_TRUE;
+    }
 
-	if (u16Data != 0xFF)
-	{
-		tmpData = u16Data;
-	}
+    if (u16Data != 0xFF)
+    {
+        tmpData = u16Data;
+    }
 
     /* Set the desired bits to 0. */
-	if (pd)
-	{
-	    tmpData |= 0x800;
-	}
-	else
-	{
-	    tmpData |= 0x8000;
-	}
+    if (pd)
+    {
+        tmpData |= 0x800;
+    }
+    else
+    {
+        tmpData |= 0x8000;
+    }
 
     if((retVal=coreWritePhyReg(dev,portNum,0,tmpData)) 
         != GT_OK)
     {
         DBG_INFO(("Writing to register failed\n"));
-		gtSemGive(dev,dev->multiAddrSem);
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
     }
 
-	if (pd)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
-	    return GT_OK;
-	}
+    if (pd)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return GT_OK;
+    }
 
     for (retryCount = 0x1000; retryCount > 0; retryCount--)
     {
         if((retVal=coreReadPhyReg(dev,portNum,0,&tmpData)) != GT_OK)
         {
             DBG_INFO(("Reading register failed\n"));
-			gtSemGive(dev,dev->multiAddrSem);
+            gtSemGive(dev,dev->multiAddrSem);
             return retVal;
         }
         if ((tmpData & 0x8000) == 0)
             break;
     }
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     if (retryCount == 0)
     {
@@ -736,16 +744,16 @@ GT_STATUS hwReadPortReg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     DBG_INFO(("Read from port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
               portNum,phyAddr,regAddr));
@@ -788,22 +796,22 @@ GT_STATUS hwWritePortReg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
     DBG_INFO(("Write to port(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
               portNum,phyAddr,regAddr));
     DBG_INFO(("data 0x%x.\n",data));
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -843,24 +851,24 @@ GT_STATUS hwGetPortRegField
 {
     GT_U16 mask;            /* Bits mask to be read */
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	if (retVal != GT_OK)
-		return retVal;
-		
+    if (retVal != GT_OK)
+        return retVal;
+        
     CALC_MASK(fieldOffset,fieldLength,mask);
 
     tmpData = (tmpData & mask) >> fieldOffset;
@@ -910,24 +918,24 @@ GT_STATUS hwSetPortRegField
 {
     GT_U16 mask;
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -942,7 +950,7 @@ GT_STATUS hwSetPortRegField
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
@@ -957,7 +965,7 @@ GT_STATUS hwSetPortRegField
 * INPUTS:
 *       portNum     - Port number to write the register for.
 *       regAddr     - The register's address.
-*       mask 		- The bits to write.
+*       mask         - The bits to write.
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -969,7 +977,7 @@ GT_STATUS hwSetPortRegField
 *
 * COMMENTS:
 *       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
-*			and 0010b is written to bit[3:0]
+*            and 0010b is written to bit[3:0]
 *
 *******************************************************************************/
 GT_STATUS hwSetPortRegBits
@@ -982,24 +990,24 @@ GT_STATUS hwSetPortRegBits
 )
 {
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PORT_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     /* Set the desired bits to 0.                       */
     tmpData &= ~mask;
@@ -1011,7 +1019,7 @@ GT_STATUS hwSetPortRegBits
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
@@ -1054,11 +1062,11 @@ GT_STATUS hwReadGlobalReg
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     DBG_INFO(("read from global register: phyAddr 0x%x, regAddr 0x%x, ",
               phyAddr,regAddr));
@@ -1104,13 +1112,13 @@ GT_STATUS hwWriteGlobalReg
               phyAddr,regAddr));
     DBG_INFO(("data 0x%x.\n",data));
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-	return retVal;
+    return retVal;
 }
 
 
@@ -1148,25 +1156,26 @@ GT_STATUS hwGetGlobalRegField
 {
     GT_U16 mask;            /* Bits mask to be read */
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     if(retVal != GT_OK)
-	{
+    {
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
     tmpData = (tmpData & mask) >> fieldOffset;
@@ -1214,24 +1223,24 @@ GT_STATUS hwSetGlobalRegField
 {
     GT_U16 mask;
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal =  miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -1247,7 +1256,7 @@ GT_STATUS hwSetGlobalRegField
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
@@ -1283,19 +1292,18 @@ GT_STATUS hwReadGlobal2Reg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
-    DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
-              phyAddr,regAddr));
+    DBG_INFO(("read from global 2 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
     DBG_INFO(("data 0x%x.\n",*data));
     return retVal;
 }
@@ -1333,20 +1341,19 @@ GT_STATUS hwWriteGlobal2Reg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-    DBG_INFO(("Write to global 2 register: phyAddr 0x%x, regAddr 0x%x, ",
-              phyAddr,regAddr));
+    DBG_INFO(("Write to global 2 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
     DBG_INFO(("data 0x%x.\n",data));
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
@@ -1386,20 +1393,20 @@ GT_STATUS hwGetGlobal2RegField
 {
     GT_U16 mask;            /* Bits mask to be read */
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     if(retVal != GT_OK)
         return retVal;
@@ -1450,24 +1457,24 @@ GT_STATUS hwSetGlobal2RegField
 {
     GT_U16 mask;
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     CALC_MASK(fieldOffset,fieldLength,mask);
 
@@ -1483,7 +1490,7 @@ GT_STATUS hwSetGlobal2RegField
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
@@ -1496,7 +1503,7 @@ GT_STATUS hwSetGlobal2RegField
 *
 * INPUTS:
 *       regAddr     - The register's address.
-*       mask 		- The bits to write.
+*       mask         - The bits to write.
 *       data        - Data to be written.
 *
 * OUTPUTS:
@@ -1508,7 +1515,7 @@ GT_STATUS hwSetGlobal2RegField
 *
 * COMMENTS:
 *       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
-*			and 0010b is written to bit[3:0]
+*            and 0010b is written to bit[3:0]
 *
 *******************************************************************************/
 GT_STATUS hwSetGlobal2RegBits
@@ -1520,24 +1527,24 @@ GT_STATUS hwSetGlobal2RegBits
 )
 {
     GT_U16 tmpData;
-	GT_STATUS   retVal;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->multiAddrSem);
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
+    }
 
     /* Set the desired bits to 0.                       */
     tmpData &= ~mask;
@@ -1550,20 +1557,19 @@ GT_STATUS hwSetGlobal2RegBits
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
 
 
 /*******************************************************************************
-* hwReadMiiReg
+* hwReadGlobal3Reg
 *
 * DESCRIPTION:
-*       This function reads a switch register.
+*       This function reads a switch's global 3 register.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
 *       regAddr - The register's address.
 *
 * OUTPUTS:
@@ -1577,41 +1583,46 @@ GT_STATUS hwSetGlobal2RegBits
 *       None.
 *
 *******************************************************************************/
-GT_STATUS hwReadMiiReg
+GT_STATUS hwReadGlobal3Reg
 (
-    IN  GT_QD_DEV *dev,
-    IN  GT_U8     phyAddr,
-    IN  GT_U8     regAddr,
-    OUT GT_U16    *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
 )
 {
+    GT_U8       phyAddr;
     GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
 
- 	gtSemGive(dev,dev->multiAddrSem);
-
-    DBG_INFO(("Read from phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
-              phyAddr,regAddr,*data));
+    gtSemGive(dev,dev->multiAddrSem);
 
+    DBG_INFO(("read from global 3 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",*data));
     return retVal;
 }
 
 
 /*******************************************************************************
-* hwWriteMiiReg
+* hwWriteGlobal3Reg
 *
 * DESCRIPTION:
-*       This function writes a switch register.
+*       This function writes to a switch's global 3 register.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
 *       regAddr - The register's address.
+*       data    - The data to be written.
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*       None.
 *
 * RETURNS:
 *       GT_OK on success, or
@@ -1621,635 +1632,944 @@ GT_STATUS hwReadMiiReg
 *       None.
 *
 *******************************************************************************/
-GT_STATUS hwWriteMiiReg
+GT_STATUS hwWriteGlobal3Reg
 (
-    IN GT_QD_DEV *dev,
-    IN  GT_U8    phyAddr,
+    IN  GT_QD_DEV *dev,
     IN  GT_U8    regAddr,
     IN  GT_U16   data
 )
 {
+    GT_U8   phyAddr;
     GT_STATUS   retVal;
 
-	gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+    DBG_INFO(("Write to global 3 register: phyAddr 0x%x, regAddr 0x%x, ", phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
 
-	gtSemGive(dev,dev->multiAddrSem);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-    DBG_INFO(("Write to phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
-              phyAddr,regAddr,data));
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
 
     return retVal;
 }
 
 
 /*******************************************************************************
-* hwReadPPU
+* hwGetGlobal3RegField
 *
 * DESCRIPTION:
-*			This function reads PPU bit in Global Register
+*       This function reads a specified field from a switch's global 3 register.
 *
 * INPUTS:
-*			None.
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to read.
 *
 * OUTPUTS:
-*			data    - The read register's data.
+*       data        - The read register field.
 *
 * RETURNS:
-*			GT_OK on success, or
-*			GT_FAIL otherwise.
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
 *
 * COMMENTS:
-*			This function can be used to access PHY register connected to Gigabit
-*			Switch.
-*			Semaphore should be acquired before this function get called.
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
 *
 *******************************************************************************/
-static GT_STATUS hwReadPPU
+GT_STATUS hwGetGlobal3RegField
 (
-	IN  GT_QD_DEV *dev,
-	OUT GT_U16    *data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    OUT GT_U16   *data
 )
 {
-	GT_STATUS   retVal;
-	GT_U16		tmpData;
+    GT_U16 mask;            /* Bits mask to be read */
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
-    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
 
     if(retVal != GT_OK)
-	{
         return retVal;
-	}
 
-	*data = (tmpData >> 14) & 0x1;
+    CALC_MASK(fieldOffset,fieldLength,mask);
+    tmpData = (tmpData & mask) >> fieldOffset;
+    *data = tmpData;
+    DBG_INFO(("Read from global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fOff %d, fLen %d, data 0x%x.\n",fieldOffset,fieldLength,*data));
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    return GT_OK;
 }
 
+
 /*******************************************************************************
-* hwWritePPU
+* hwSetGlobal3RegField
 *
 * DESCRIPTION:
-*			This function writes PPU bit in Global Register
+*       This function writes to specified field in a switch's global 3 register.
 *
 * INPUTS:
-*			data - The value to write into PPU bit
+*       regAddr     - The register's address.
+*       fieldOffset - The field start bit index. (0 - 15)
+*       fieldLength - Number of bits to write.
+*       data        - Data to be written.
 *
 * OUTPUTS:
-*			None.
+*       None.
 *
 * RETURNS:
-*			GT_OK on success, or
-*			GT_FAIL otherwise.
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
 *
 * COMMENTS:
-*			This function can be used to access PHY register connected to Gigabit
-*			Switch.
-*			Semaphore should be acquired before this function get called.
+*       1.  The sum of fieldOffset & fieldLength parameters must be smaller-
+*           equal to 16.
 *
 *******************************************************************************/
-static GT_STATUS hwWritePPU
+GT_STATUS hwSetGlobal3RegField
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_U16    data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U8    fieldOffset,
+    IN  GT_U8    fieldLength,
+    IN  GT_U16   data
 )
 {
-	GT_STATUS   retVal;
-	GT_U16		tmpData;
+    GT_U16 mask;
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
     GT_U8       phyAddr;
 
-    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
-
-    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
-
-    if(retVal != GT_OK)
-	{
-        return retVal;
-	}
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
-	if (data)
-		tmpData |= (0x1 << 14);
-	else
-		tmpData &= ~(0x1 << 14);
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
 
-    retVal = miiSmiIfWriteRegister(dev,phyAddr,4,tmpData);
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
 
     if(retVal != GT_OK)
-	{
+    {
+        gtSemGive(dev,dev->multiAddrSem);
         return retVal;
-	}
-
-	/* busy wait - till PPU is actually disabled */
-	if (data == 0) /* disable PPU */
-	{
-		gtDelay(250);
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
-}
-
+    }
 
-static GT_STATUS coreReadPhyReg
-(
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	OUT GT_U16   *data
-)
-{
-	GT_U8       phyAddr;
-	GT_STATUS   retVal, retPPU;
-	GT_U16		orgPPU = 0;
-	GT_BOOL		usePPU = GT_FALSE;
-
-	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec && (1<<phyAddr)))
-		{
-			if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-			{
-				return retPPU;
-			}
-
-			if(orgPPU)
-			{
-				/* Disable PPU so that External Phy can be accessible */
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-		else
-			usePPU = GT_TRUE;
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
-	{
-		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-
-		if(orgPPU)
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
-			{
-				if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
-				{
-					if(dev->revision != 0)
-						usePPU = GT_TRUE;
-				}
-				else
-				{
-				 	usePPU = GT_TRUE;
-				}
-			}
-
-			/* Disable PPU so that External Phy can be accessible */
-			if (!usePPU)
-			{
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-	}
-
-	if (usePPU)
-	{
-		retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
-	}
-	else
-	{
-		retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
-	}
-
-	DBG_INFO(("Read from phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
-				portNum,phyAddr,regAddr));
-
-	if(orgPPU && (!usePPU))
-	{
-		if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-	}
-
-	return retVal;
-}
+    CALC_MASK(fieldOffset,fieldLength,mask);
 
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= ((data << fieldOffset) & mask);
 
-static GT_STATUS coreWritePhyReg
-(
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U16   data
-)
-{
-	GT_U8   		phyAddr;
-	GT_STATUS   retVal, retPPU;
-	GT_U16		orgPPU = 0;
-	GT_BOOL		usePPU = GT_FALSE;
-
-	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec && (1<<phyAddr)))
-		{
-			if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-			{
-				return retPPU;
-			}
-
-			if(orgPPU)
-			{
-				/* Disable PPU so that External Phy can be accessible */
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-						return retPPU;
-				}
-			}
-		}
-		else
-			usePPU = GT_TRUE;
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
-	{
-		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-
-		if(orgPPU)
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
-			{
-				if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
-				{
-					if(dev->revision != 0)
-						usePPU = GT_TRUE;
-				}
-				else
-				{
-				 	usePPU = GT_TRUE;
-				}
-			}
-
-			/* Disable PPU so that External Phy can be accessible */
-			if (!usePPU)
-			{
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-	}
-
-	DBG_INFO(("Write to phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
-				portNum,phyAddr,regAddr));
-	DBG_INFO(("data 0x%x.\n",data));
-
-	if (usePPU)
-	{
-		retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
-	}
-	else
-	{
-		retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
-	}
-
-	if(orgPPU && (!usePPU))
-	{
-		if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-	}
-
-	return retVal;
-}
+    DBG_INFO(("Write to global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("fieldOff %d, fieldLen %d, data 0x%x.\n",fieldOffset,
+              fieldLength,data));
 
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
 
-static GT_STATUS coreReadPagedPhyReg
-(
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	OUT GT_U16   *data
-)
-{
-	GT_U8       phyAddr,pageAddr;
-	GT_STATUS   retVal, retPPU;
-	GT_U16		orgPPU, tmpData, orgPage;
-	GT_BOOL		usePPU = GT_FALSE;
-
-	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
-
-	orgPPU = 0;
-
-	if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec && (1<<phyAddr)))
-		{
-			if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-			{
-				return retPPU;
-			}
-
-			if(orgPPU)
-			{
-				/* Disable PPU so that External Phy can be accessible */
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-		else
-			usePPU = GT_TRUE;
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
-	{
-		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-
-		if(orgPPU)
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
-			{
-				if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
-				{
-					if(dev->revision != 0)
-						usePPU = GT_TRUE;
-				}
-				else
-				{
-				 	usePPU = GT_TRUE;
-				}
-			}
-
-			/* Disable PPU so that External Phy can be accessible */
-			if (!usePPU)
-			{
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-	}
-
-	if(anyPage & (1 << regAddr))
-	{
-		if (usePPU)
-		{
-			retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
-		}
-		else
-		{
-			retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
-		}
-		DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
-					portNum,phyAddr,pageNum,regAddr));
-	}
-	else
-	{
-	    pageAddr = GT_GET_PAGE_ADDR(regAddr);
-
-		if (usePPU)
-		{
-			retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,&orgPage);
-		}
-		else
-		{
-			retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
-		}
-
-		if (retVal != GT_OK)
-		{
-			DBG_INFO(("Reading page register failed\n"));
-			return retVal;
-		}
-
-		if(pageAddr == 22)
-			tmpData = orgPage & 0xFF00;
-		else
-			tmpData = orgPage & 0xFFC0;
-		tmpData |= pageNum;
-
-		if (usePPU)
-		{
-			if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
-			{
-				retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
-
-				DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
-							portNum,phyAddr,pageNum,regAddr));
-			}
-		}
-		else
-		{
-			if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
-			{
-				retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
-
-				DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
-							portNum,phyAddr,pageNum,regAddr));
-			}
-		}
-	}
-
-	if(orgPPU && (!usePPU))
-	{
-		if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-	}
-
-	return retVal;
+    gtSemGive(dev,dev->multiAddrSem);
 
+    return retVal;
 }
 
-
+/*******************************************************************************
+* hwSetGlobal3RegBits
+*
+* DESCRIPTION:
+*       This function writes to specified bits in a switch's global 3 register.
+*
+* INPUTS:
+*       regAddr     - The register's address.
+*       mask         - The bits to write.
+*       data        - Data to be written.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       1.  When Data is 0x1002 and mask is 0xF00F, 0001b is written to bit[31:24]
+*            and 0010b is written to bit[3:0]
+*
+*******************************************************************************/
+GT_STATUS hwSetGlobal3RegBits
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   mask,
+    IN  GT_U16   data
+)
+{
+    GT_U16 tmpData;
+    GT_STATUS   retVal;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->multiAddrSem);
+        return retVal;
+    }
+
+    /* Set the desired bits to 0.                       */
+    tmpData &= ~mask;
+    /* Set the given data into the above reset bits.    */
+    tmpData |= (data & mask);
+
+    DBG_INFO(("Write to global 3 register: regAddr 0x%x, ",
+              regAddr));
+    DBG_INFO(("mask %d, data 0x%x.\n",mask,data));
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,tmpData);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    return retVal;
+}
+
+
+/*********************************************************************************************/
+
+/*******************************************************************************
+* hwReadMiiReg
+*
+* DESCRIPTION:
+*       This function reads a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwReadMiiReg
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U8     phyAddr,
+    IN  GT_U8     regAddr,
+    OUT GT_U16    *data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+     gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("Read from phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,*data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwWriteMiiReg
+*
+* DESCRIPTION:
+*       This function writes a switch register.
+*
+* INPUTS:
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwWriteMiiReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    phyAddr,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_STATUS   retVal;
+
+    gtSemTake(dev,dev->multiAddrSem,OS_WAIT_FOREVER);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+
+    gtSemGive(dev,dev->multiAddrSem);
+
+    DBG_INFO(("Write to phy(0x%x) register: regAddr 0x%x, data 0x%x.\n",
+              phyAddr,regAddr,data));
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* hwReadPPU
+*
+* DESCRIPTION:
+*            This function reads PPU bit in Global Register
+*
+* INPUTS:
+*            None.
+*
+* OUTPUTS:
+*            data    - The read register's data.
+*
+* RETURNS:
+*            GT_OK on success, or
+*            GT_FAIL otherwise.
+*
+* COMMENTS:
+*            This function can be used to access PHY register connected to Gigabit
+*            Switch.
+*            Semaphore should be acquired before this function get called.
+*
+*******************************************************************************/
+static GT_STATUS hwReadPPU
+(
+    IN  GT_QD_DEV *dev,
+    OUT GT_U16    *data
+)
+{
+    GT_STATUS   retVal;
+    GT_U16        tmpData;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    *data = (tmpData >> 14) & 0x1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* hwWritePPU
+*
+* DESCRIPTION:
+*            This function writes PPU bit in Global Register
+*
+* INPUTS:
+*            data - The value to write into PPU bit
+*
+* OUTPUTS:
+*            None.
+*
+* RETURNS:
+*            GT_OK on success, or
+*            GT_FAIL otherwise.
+*
+* COMMENTS:
+*            This function can be used to access PHY register connected to Gigabit
+*            Switch.
+*            Semaphore should be acquired before this function get called.
+*
+*******************************************************************************/
+static GT_STATUS hwWritePPU
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U16    data
+)
+{
+    GT_STATUS   retVal;
+    GT_U16        tmpData;
+    GT_U8       phyAddr;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    retVal =  miiSmiIfReadRegister(dev,phyAddr,4,&tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (data)
+        tmpData |= (0x1 << 14);
+    else
+        tmpData &= ~(0x1 << 14);
+
+    retVal = miiSmiIfWriteRegister(dev,phyAddr,4,tmpData);
+
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    /* busy wait - till PPU is actually disabled */
+    if (data == 0) /* disable PPU */
+    {
+        gtDelay(250);
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+static GT_STATUS coreReadPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr;
+    GT_STATUS   retVal, retPPU = 0;
+    GT_U16        orgPPU;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+        usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_PHY_ACCESS_NO_DIRECTLY))
+    {
+      usePPU = GT_TRUE;
+    }
+
+    if (usePPU)
+    {
+        retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+    }
+    else
+    {
+        retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+    }
+
+    DBG_INFO(("Read from phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ", portNum,phyAddr,regAddr));
+
+    if(orgPPU && (!usePPU))
+    {
+      if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+      {
+        return retPPU;
+      }
+    }
+
+    return retVal;
+}
+
+
+static GT_STATUS coreWritePhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U16   data
+)
+{
+    GT_U8           phyAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU = 0;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                        return retPPU;
+                }
+            }
+        }
+        else
+          usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_PHY_ACCESS_NO_DIRECTLY))
+    {
+      usePPU = GT_TRUE;
+    }
+
+    DBG_INFO(("Write to phy(%d) register: phyAddr 0x%x, regAddr 0x%x, ",
+                portNum,phyAddr,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    if (usePPU)
+    {
+        retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
+    }
+    else
+    {
+        retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
+}
+
+
+static GT_STATUS coreReadPagedPhyReg
+(
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    OUT GT_U16   *data
+)
+{
+    GT_U8       phyAddr,pageAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU, tmpData, orgPage;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+             usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+
+    if(anyPage & (1 << regAddr))
+    {
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+        }
+        DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                    portNum,phyAddr,pageNum,regAddr));
+    }
+    else
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,&orgPage);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
+        }
+
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Reading page register failed\n"));
+            return retVal;
+        }
+
+        if(pageAddr == 22)
+            tmpData = orgPage & 0xFF00;
+        else
+            tmpData = orgPage & 0xFFC0;
+        tmpData |= pageNum;
+
+        if (usePPU)
+        {
+            if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,data);
+
+                DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                            portNum,phyAddr,pageNum,regAddr));
+            }
+        }
+        else
+        {
+            if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
+
+                DBG_INFO(("Read from phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                            portNum,phyAddr,pageNum,regAddr));
+            }
+        }
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
+
+}
+
+
 static GT_STATUS coreWritePagedPhyReg
 (
-	IN GT_QD_DEV *dev,
-	IN  GT_U8    portNum,
-	IN  GT_U8    pageNum,
-	IN  GT_U8    regAddr,
-	IN  GT_U32	 anyPage,
-	IN  GT_U16   data
+    IN GT_QD_DEV *dev,
+    IN  GT_U8    portNum,
+    IN  GT_U8    pageNum,
+    IN  GT_U8    regAddr,
+    IN  GT_U32     anyPage,
+    IN  GT_U16   data
 )
 {
-	GT_U8   		phyAddr,pageAddr;
-	GT_STATUS   retVal, retPPU;
-	GT_U16		orgPPU, tmpData, orgPage;
-	GT_BOOL		usePPU = GT_FALSE;
-
-	phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
-
-	orgPPU = 0;
-
-	if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec && (1<<phyAddr)))
-		{
-			if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-			{
-				return retPPU;
-			}
-
-			if(orgPPU)
-			{
-				/* Disable PPU so that External Phy can be accessible */
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-		else
-			usePPU = GT_TRUE;
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
-	{
-		if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-
-		if(orgPPU)
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
-			{
-				if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
-				{
-					if(dev->revision != 0)
-						usePPU = GT_TRUE;
-				}
-				else
-				{
-				 	usePPU = GT_TRUE;
-				}
-			}
-
-			/* Disable PPU so that External Phy can be accessible */
-			if (!usePPU)
-			{
-				if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
-				{
-					return retPPU;
-				}
-			}
-		}
-	}
-
-	DBG_INFO(("Write to phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
-				portNum,phyAddr,pageNum,regAddr));
-	DBG_INFO(("data 0x%x.\n",data));
-
-	if(anyPage & (1 << regAddr))
-	{
-		if (usePPU)
-		{
-			retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
-		}
-		else
-		{
-			retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
-		}
-	}
-	else
-	{
-	    pageAddr = GT_GET_PAGE_ADDR(regAddr);
-
-		if (usePPU)
-		{
-			retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,&orgPage);
-		}
-		else
-		{
-			retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
-		}
-
-		if (retVal != GT_OK)
-		{
-			DBG_INFO(("Reading page register failed\n"));
-			return retVal;
-		}
-
-		if(pageAddr == 22)
-			tmpData = orgPage & 0xFF00;
-		else
-			tmpData = orgPage & 0xFFC0;
-		tmpData |= pageNum;
-
-		if (usePPU)
-		{
-			if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
-			{
-				retVal = phyRegWritePPUEn(dev,phyAddr,regAddr,data);
-			}
-		}
-		else
-		{
-			if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
-			{
-				retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
-			}
-		}
-	}
-
-	if(orgPPU && (!usePPU))
-	{
-		if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
-		{
-			return retPPU;
-		}
-	}
-
-	return retVal;
+    GT_U8           phyAddr,pageAddr;
+    GT_STATUS   retVal, retPPU;
+    GT_U16        orgPPU, tmpData, orgPage;
+    GT_BOOL        usePPU = GT_FALSE;
+
+    phyAddr = CALC_SMI_DEV_ADDR(dev, portNum, PHY_ACCESS);
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    orgPPU = 0;
+
+    if(IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        if((IS_IN_DEV_GROUP(dev,DEV_PPU_SERDES_ACCESS_RES)) && (dev->validSerdesVec & (1<<phyAddr)))
+        {
+            if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+
+            if(orgPPU)
+            {
+                /* Disable PPU so that External Phy can be accessible */
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+        else
+             usePPU = GT_TRUE;
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY))
+    {
+        if((retPPU=hwReadPPU(dev, &orgPPU)) != GT_OK)
+        {
+            return retPPU;
+        }
+
+        if(orgPPU)
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_PPU_PHY_ACCESS_RES))
+                {
+                    if(dev->revision != 0)
+                        usePPU = GT_TRUE;
+                }
+                else
+                {
+                     usePPU = GT_TRUE;
+                }
+            }
+
+            /* Disable PPU so that External Phy can be accessible */
+            if (!usePPU)
+            {
+                if((retPPU=hwWritePPU(dev, 0)) != GT_OK)
+                {
+                    return retPPU;
+                }
+            }
+        }
+    }
+
+    DBG_INFO(("Write to phy(%d) register: smiAddr 0x%x, pageNum 0x%x, regAddr 0x%x\n",
+                portNum,phyAddr,pageNum,regAddr));
+    DBG_INFO(("data 0x%x.\n",data));
+
+    if(anyPage & (1 << regAddr))
+    {
+        if (usePPU)
+        {
+            retVal = phyRegWritePPUEn (dev,phyAddr,regAddr,data);
+        }
+        else
+        {
+            retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+        }
+    }
+    else
+    {
+        pageAddr = GT_GET_PAGE_ADDR(regAddr);
+
+        if (usePPU)
+        {
+            retVal = phyRegReadPPUEn (dev,phyAddr,regAddr,&orgPage);
+        }
+        else
+        {
+            retVal = miiSmiIfReadRegister(dev,phyAddr,pageAddr,&orgPage);
+        }
+
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Reading page register failed\n"));
+            return retVal;
+        }
+
+        if(pageAddr == 22)
+            tmpData = orgPage & 0xFF00;
+        else
+            tmpData = orgPage & 0xFFC0;
+        tmpData |= pageNum;
+
+        if (usePPU)
+        {
+            if((retVal = phyRegWritePPUEn(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = phyRegWritePPUEn(dev,phyAddr,regAddr,data);
+            }
+        }
+        else
+        {
+            if((retVal = miiSmiIfWriteRegister(dev,phyAddr,pageAddr,tmpData)) == GT_OK)
+            {
+                retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
+            }
+        }
+    }
+
+        if(orgPPU && (!usePPU))
+        {
+            if((retPPU=hwWritePPU(dev, orgPPU)) != GT_OK)
+            {
+                return retPPU;
+            }
+        }
+
+    return retVal;
 }
 
 
@@ -2277,17 +2597,58 @@ static GT_STATUS coreWritePagedPhyReg
 *******************************************************************************/
 static GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
                         unsigned short* value)
+#ifdef GT_RMGMT_ACCESS
+{
+  GT_U16 smiReg;
+  GT_STATUS   retVal;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  DBG_INFO(("Read Phy register while PPU Enabled\n"));
+
+  regAccess.entries = 4;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[0].data = 15;
+  smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[1].data = smiReg;
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[2].data = 15;
+
+  regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+  regAccess.rw_reg_list[3].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[3].reg = QD_REG_SMI_PHY_DATA;
+  regAccess.rw_reg_list[3].data = 0;
+  retVal = hwAccessMultiRegs(dev, &regAccess);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+  *value = (unsigned short)regAccess.rw_reg_list[3].data;
+    
+  return GT_OK;
+}
+#else
 {
-	volatile unsigned int timeOut; /* in 100MS units */
-	volatile int i;
-	GT_U16 smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+    GT_U16 smiReg;
 
-	DBG_INFO(("Read Phy register while PPU Enabled\n"));
+    DBG_INFO(("Read Phy register while PPU Enabled\n"));
 
-	/* first check that it is not busy */
+    /* first check that it is not busy */
     if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
     {
-		DBG_INFO(("Reading Phy register Failed\n"));
+        DBG_INFO(("Reading Phy register Failed\n"));
         return GT_FAIL;
     }
     timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
@@ -2299,19 +2660,19 @@ static GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigne
         {
             if(timeOut-- < 1 ) 
             {
-				DBG_INFO(("Reading Phy register Timed Out\n"));
-    	        return GT_FAIL;
-    	    }
-		    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
-		    {
-				DBG_INFO(("Reading Phy register Failed\n"));
-		        return GT_FAIL;
-		    }
+                DBG_INFO(("Reading Phy register Timed Out\n"));
+                return GT_FAIL;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Reading Phy register Failed\n"));
+                return GT_FAIL;
+            }
         } while (smiReg & QD_SMI_BUSY);
     }
 
     smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | 
-    		(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
 
     if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, smiReg) != GT_OK)
     {
@@ -2326,29 +2687,30 @@ static GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigne
     if(smiReg & QD_SMI_BUSY) 
     {
         for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
-		do 
-		{
+        do 
+        {
             if(timeOut-- < 1 ) 
             {
-				DBG_INFO(("Reading Phy register Timed Out\n"));
-    	        return GT_FALSE;
-    	    }
-		    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
-		    {
-				DBG_INFO(("Reading Phy register Failed\n"));
-		        return GT_FAIL;
-		    }
+                DBG_INFO(("Reading Phy register Timed Out\n"));
+                return GT_FALSE;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Reading Phy register Failed\n"));
+                return GT_FAIL;
+            }
         } while (smiReg & QD_SMI_BUSY);
-	}
+    }
     if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_DATA, &smiReg) != GT_OK)
     {
-		DBG_INFO(("Reading Phy register Failed\n"));
+        DBG_INFO(("Reading Phy register Failed\n"));
         return GT_FAIL;
     }
-	*value = (unsigned short)smiReg;
+    *value = (unsigned short)smiReg;
     
-	return GT_OK;
+    return GT_OK;
 }
+#endif
 
 /*****************************************************************************
 * phyRegWritePPUEn
@@ -2375,17 +2737,54 @@ static GT_STATUS phyRegReadPPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigne
 
 static GT_STATUS phyRegWritePPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
                        unsigned short value)
+#ifdef GT_RMGMT_ACCESS
+{
+  GT_U16 smiReg;
+  GT_STATUS   retVal;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  DBG_INFO(("Write Phy register while PPU Enabled\n"));
+
+  regAccess.entries = 3;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[0].data = 15;
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_PHY_DATA;
+  regAccess.rw_reg_list[1].data = value;
+
+  smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_PHY_CMD;
+  regAccess.rw_reg_list[2].data = smiReg;
+
+  retVal = hwAccessMultiRegs(dev, &regAccess);
+  if(retVal != GT_OK)
+  {
+    return retVal;
+  }
+    
+  return GT_OK;
+}
+#else
 {
-	volatile unsigned int timeOut; /* in 100MS units */
-	volatile int i;
-	GT_U16 smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
+    GT_U16 smiReg;
 
-	DBG_INFO(("Writing Phy register while PPU Enabled\n"));
+    DBG_INFO(("Writing Phy register while PPU Enabled\n"));
 
-	/* first check that it is not busy */
+    /* first check that it is not busy */
     if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
     {
-		DBG_INFO(("Reading Phy register Failed\n"));
+        DBG_INFO(("Reading Phy register Failed\n"));
         return GT_FAIL;
     }
     timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
@@ -2397,35 +2796,34 @@ static GT_STATUS phyRegWritePPUEn (GT_QD_DEV* dev, unsigned int phyAddr , unsign
         {
             if(timeOut-- < 1 ) 
             {
-				DBG_INFO(("Writing Phy register Timed Out\n"));
-    	        return GT_FALSE;
-    	    }
-		    if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
-		    {
-				DBG_INFO(("Writing Phy register Failed\n"));
-		        return GT_FAIL;
-		    }
+                DBG_INFO(("Writing Phy register Timed Out\n"));
+                return GT_FALSE;
+            }
+            if(phyReadGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, &smiReg) != GT_OK)
+            {
+                DBG_INFO(("Writing Phy register Failed\n"));
+                return GT_FAIL;
+            }
         } while (smiReg & QD_SMI_BUSY);
     }
 
     if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_DATA, value) != GT_OK)
     {
-		DBG_INFO(("Writing Phy Data register Failed\n"));
+        DBG_INFO(("Writing Phy Data register Failed\n"));
         return GT_FAIL;
     }
     smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | 
-			(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
 
     if(phyWriteGlobal2Reg(dev,QD_REG_SMI_PHY_CMD, smiReg) != GT_OK)
     {
-		DBG_INFO(("Writing Phy Command register Failed\n"));
+        DBG_INFO(("Writing Phy Command register Failed\n"));
         return GT_FAIL;
     }
 
     return GT_OK;
 }
 
-
 static GT_STATUS phyReadGlobal2Reg
 (
     IN GT_QD_DEV *dev,
@@ -2437,10 +2835,10 @@ static GT_STATUS phyReadGlobal2Reg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
     retVal = miiSmiIfReadRegister(dev,phyAddr,regAddr,data);
 
@@ -2462,13 +2860,57 @@ static GT_STATUS phyWriteGlobal2Reg
     GT_STATUS   retVal;
 
     phyAddr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
-	if (phyAddr == 0xFF)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (phyAddr == 0xFF)
+    {
+        return GT_BAD_PARAM;
+    }
 
     retVal = miiSmiIfWriteRegister(dev,phyAddr,regAddr,data);
 
     return retVal;
 }
+#endif
 
+#ifdef GT_RMGMT_ACCESS
+/*******************************************************************************
+* hwAccessMultiRegs
+*
+* DESCRIPTION:
+*       This function accesses switch's registers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
+* OUTPUTS:
+*   regList
+*
+* RETURNS:
+*       GT_OK on success, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS hwAccessMultiRegs
+(
+    IN GT_QD_DEV *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+)
+{
+  GT_STATUS   retVal;
+
+  gtSemTake(dev,dev->hwAccessRegsSem,OS_WAIT_FOREVER);
+
+  retVal = qdAccessRegs(dev, regList);
+
+  gtSemGive(dev,dev->hwAccessRegsSem);
+
+  return retVal;
+}
+#endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/makefile
old mode 100644
new mode 100755
index f6a5efc..2665ee7
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/makefile
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/driver/makefile
@@ -1,32 +1,33 @@
 # Source files in this directory
-CSOURCES	= gtDrvConfig.c gtDrvEvents.c gtHwCntl.c
-ASOURCES	=
+TARGET = 
+CSOURCES    = gtDrvConfig.c gtDrvEvents.c gtHwCntl.c
+ASOURCES    =
 
 # Include common variable definitions
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.defs
+include $(DSDT_TOOL_DIR)\make.defs
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.defs
+include $(DSDT_TOOL_DIR)\makewce.defs
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.defs
+include $(DSDT_TOOL_DIR)/makelnx.defs
 endif
 
 # Add in extra stuffs
-EXTRA_INCLUDE	+=
-EXTRA_DEFINE	+=
-ADDED_CFLAGS	+=
+EXTRA_INCLUDE    +=
+EXTRA_DEFINE    +=
+ADDED_CFLAGS    +=
 
 # Include common build rules
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.rules
+include $(DSDT_TOOL_DIR)\make.rules
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.rules
+include $(DSDT_TOOL_DIR)\makewce.rules
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.rules
+include $(DSDT_TOOL_DIR)/makelnx.rules
 endif
 
 # end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile
old mode 100644
new mode 100755
index af07875..74d6d98
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/makefile
@@ -6,20 +6,20 @@
 #
 #######################################################################
 
-TARGET = $(PROJ_NAME)
+TARGET = $(DSDT_PROJ_NAME)
 
 ifeq ($(OS_RUN),VXWORKS)
-WORK_TO_DO = $(PROJ_NAME).o
+WORK_TO_DO = $(DSDT_PROJ_NAME).o
 
 # Include common variable definitions
-include $(TOOL_DIR)\make.defs
+include $(DSDT_TOOL_DIR)\make.defs
 endif
 
 ifeq ($(OS_RUN),LINUX)
-WORK_TO_DO = $(PROJ_NAME).o
+WORK_TO_DO = $(DSDT_PROJ_NAME).o
 
 # Include common variable definitions
-include $(TOOL_DIR)/makelnx.defs
+include $(DSDT_TOOL_DIR)/makelnx.defs
 endif
 
 exe : $(WORK_TO_DO)
@@ -30,6 +30,11 @@ vpath %.o    $(OBJDIR)
 vpath %.lib  $(OBJDIR)
 
 MAINDRV_PATH = $(SRC_BASE_PATH)
+MAD_ROOT = $(SRC_BASE_PATH)/../../phy
+
+SRC_OBJ_DIR = $(MAINDRV_PATH)/driver \
+               $(MAINDRV_PATH)/msapi \
+               $(MAINDRV_PATH)/platform
 
 OBJECTS_LIST = $(MAINDRV_PATH)/driver/$(OBJDIR)/driver.o \
                $(MAINDRV_PATH)/msapi/$(OBJDIR)/msapi.o \
@@ -44,10 +49,10 @@ OBJDIRS_/ = $(subst \,/,$(OBJDIRS))
 LIBDIRS_/ = $(subst \,/,$(LIBDIRS))
 
 ifeq ($(OS_RUN),VXWORKS)
-$(PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
+$(DSDT_PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
 	@ $(ECHO) '------------'
 	@ $(ECHO) 'Building $@'
-	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(PROJ_NAME).map -o $(LIB_DIR)/$(PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
+	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(DSDT_PROJ_NAME).map -o $(LIB_DIR)/$(DSDT_PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
 
 $(OBJECTS) : FORCE
 	@($(CD) $(subst /,\,$(dir $(@D)))) && $(MAKE)
@@ -58,10 +63,10 @@ $(MAD_OBJ) : FORCE
 endif
 
 ifeq ($(OS_RUN),LINUX)
-$(PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
+$(DSDT_PROJ_NAME).o : $(OBJECTS) $(MAD_OBJ)
 	@ $(ECHO) '------------'
 	@ $(ECHO) 'Building $@'
-	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(PROJ_NAME).map -o $(LIB_DIR)/$(PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
+	$(LD) $(LDFLAGS) -Map $(LIB_DIR)/$(DSDT_PROJ_NAME).map -o $(LIB_DIR)/$(DSDT_PROJ_NAME).o $(OBJECTS) $(MAD_OBJ)
 
 $(OBJECTS) : FORCE
 	@cd $(dir $(@D)); $(MAKE)
@@ -78,19 +83,24 @@ ifeq ($(OS_RUN),VXWORKS)
 clean :
 	@for %x in ($(OBJDIRS)) do \
 	    @($(CD) %x..) && $(MAKE) clean
-	- ($(CD) $(LIBDIRS)) && $(RM) $(PROJ_NAME).o
-	- ($(CD) $(LIBDIRS)) && $(RM) $(PROJ_NAME).map
+	- ($(CD) $(LIBDIRS)) && $(RM) $(DSDT_PROJ_NAME).o
+	- ($(CD) $(LIBDIRS)) && $(RM) $(DSDT_PROJ_NAME).map
 	@if exist $(MAD_ROOT) $(MAKE) -C $(MAD_ROOT)/src clean
 endif
 
 ifeq ($(OS_RUN),LINUX)
 clean :
+	@for i in $(SRC_OBJ_DIR); do	\
+		cd $$i; $(RM) -r -f *.o *.map makedeps *obj; 	\
+	done
+#		cd $$i; $(RM) -f *.o *.map; 	
 	@for i in $(OBJDIRS_/); do	\
-		cd $$i..; $(MAKE) clean;	\
+		$(RM) -r -f  $$i;	\
 	done
-	@cd $(LIBDIRS_/); $(RM) $(PROJ_NAME).o
-	@cd $(LIBDIRS_/); $(RM) $(PROJ_NAME).map
-	@if exist $(MAD_ROOT) $(MAKE) -C $(MAD_ROOT)/src clean
+#		cd $$i..; $(MAKE) clean;	
+	@cd $(LIB_DIR); $(RM) *.o
+	@cd $(LIB_DIR); $(RM) *.map
+	$(MAKE) -C $(MAD_ROOT)/src clean
 endif
 
 #end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct.c
old mode 100644
new mode 100755
index fb1bf2c..e0a3a84
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct.c
@@ -17,6 +17,9 @@
 #include <gtDrvSwRegs.h>
 #include <gtHwCntl.h>
 #include <gtSem.h>
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
 
 #define GT_LOOKUP_TABLE_ENTRY  128  /* 73 */
 
@@ -44,25 +47,25 @@ static  GT_U8 tbl_1111[GT_LOOKUP_TABLE_ENTRY] =
 
 static  GT_U8 tbl_1112[GT_LOOKUP_TABLE_ENTRY] =   /* from 17*/
                     {  0,  4,  8, 11, 14, 18, 21, 24, 28, 31, 
-					  34, 37, 39, 42, 44, 47, 49, 52, 54, 56, 
-					  58, 60, 62, 64, 66, 68, 70, 72, 74, 75, 
-					  77, 79, 80, 82, 83, 85, 87, 88, 89, 91, 
-					  92, 94, 95, 96, 98, 99,100,101,103,104,
-					  105,106,107,108,109,111,112,113,114,115,
-					  116,117,118,119,120,121,122,123,124,124,
-					  125,126,127,128,129,130,131,131,132,133,
-					  134,135,135,136,137,138,139,139,140,141,
-					  142,142,143,144,144,145,146,147,147,148};
+                      34, 37, 39, 42, 44, 47, 49, 52, 54, 56, 
+                      58, 60, 62, 64, 66, 68, 70, 72, 74, 75, 
+                      77, 79, 80, 82, 83, 85, 87, 88, 89, 91, 
+                      92, 94, 95, 96, 98, 99,100,101,103,104,
+                      105,106,107,108,109,111,112,113,114,115,
+                      116,117,118,119,120,121,122,123,124,124,
+                      125,126,127,128,129,130,131,131,132,133,
+                      134,135,135,136,137,138,139,139,140,141,
+                      142,142,143,144,144,145,146,147,147,148};
 
 static  GT_U8 tbl_1116[GT_LOOKUP_TABLE_ENTRY] =   /* from 16*/
                     {  2,  4,  8, 14, 18, 20, 25, 30, 33, 36, 
-					  39, 42, 46, 48, 51, 54, 57, 59, 62, 64, 
-					  66, 69, 71, 73, 75, 77, 80, 81, 83, 85, 
-					  87, 88, 90, 93, 95, 97, 98, 100, 101, 103, 
-					  104,106,106,107,109,110,111,113,114,115,
-					  116,118,119,120,121,122,124,125,126,127,
-					  128,129,130,131,132,133,134,135,136,137,
-					  138,139,140};
+                      39, 42, 46, 48, 51, 54, 57, 59, 62, 64, 
+                      66, 69, 71, 73, 75, 77, 80, 81, 83, 85, 
+                      87, 88, 90, 93, 95, 97, 98, 100, 101, 103, 
+                      104,106,106,107,109,110,111,113,114,115,
+                      116,118,119,120,121,122,124,125,126,127,
+                      128,129,130,131,132,133,134,135,136,137,
+                      138,139,140};
 
 static  GT_U8 tbl_1240[GT_LOOKUP_TABLE_ENTRY] = 
                     {  1,  2,  5, 10, 13, 15, 18, 22, 26, 30, 
@@ -79,13 +82,13 @@ static  GT_U8 tbl_1240[GT_LOOKUP_TABLE_ENTRY] =
 * getDetailedAdvVCTResult
 *
 * DESCRIPTION:
-*		This routine differenciate Open/Short from Impedance mismatch.
+*        This routine differenciate Open/Short from Impedance mismatch.
 *
 * INPUTS:
-*		amp - amplitude
-*		len - distance to fault
-*		vctResult - test result 
-*					(Impedance mismatch, either > 115 ohms, or < 85 ohms)
+*        amp - amplitude
+*        len - distance to fault
+*        vctResult - test result 
+*                    (Impedance mismatch, either > 115 ohms, or < 85 ohms)
 *
 * OUTPUTS:
 *
@@ -99,312 +102,312 @@ static  GT_U8 tbl_1240[GT_LOOKUP_TABLE_ENTRY] =
 static
 GT_ADV_VCT_STATUS getDetailedAdvVCTResult
 (
-	IN  GT_U32  devType,
-	IN  GT_U32  amp,
-	IN  GT_U32  len,
-	IN  GT_ADV_VCT_STATUS result
+    IN  GT_U32  devType,
+    IN  GT_U32  amp,
+    IN  GT_U32  len,
+    IN  GT_ADV_VCT_STATUS result
 )
 {
-	GT_ADV_VCT_STATUS vctResult;
-	GT_BOOL    update = GT_FALSE;
-
-	DBG_INFO(("getDetailedAdvVCTResult Called.\n"));
-
-	if (devType == GT_PHY_ADV_VCT_TYPE2)
-	{
-		if(len < 10)
-		{
-			if(amp > 54)  /* 90 x 0.6 */
-				update = GT_TRUE;
-		}
-		else if(len < 50)
-		{
-			if(amp > 42) /* 70 x 0.6 */
-				update = GT_TRUE;
-		}
-		else if(len < 110)
-		{
-			if(amp > 30)  /* 50 x 0.6 */
-				update = GT_TRUE;
-		}
-		else if(len < 140)
-		{
-			if(amp > 24)  /* 40 x 0.6 */
-				update = GT_TRUE;
-		}
-		else
-		{
-			if(amp > 18) /* 30 x 0.6 */
-				update = GT_TRUE;
-		}
-	}
-	else
-	{
-		if(len < 10)
-		{
-			if(amp > 90)  
-				update = GT_TRUE;
-		}
-		else if(len < 50)
-		{
-			if(amp > 70) 
-				update = GT_TRUE;
-		}
-		else if(len < 110)
-		{
-			if(amp > 50)  
-				update = GT_TRUE;
-		}
-		else if(len < 140)
-		{
-			if(amp > 40)  
-				update = GT_TRUE;
-		}
-		else
-		{
-			if(amp > 30) 
-				update = GT_TRUE;
-		}
-	}
-
-
-	switch (result)
-	{
-		case GT_ADV_VCT_IMP_GREATER_THAN_115:
-				if(update)
-					vctResult = GT_ADV_VCT_OPEN;
-				else
-					vctResult = result;
-				break;
-		case GT_ADV_VCT_IMP_LESS_THAN_85:
-				if(update)
-					vctResult = GT_ADV_VCT_SHORT;
-				else
-					vctResult = result;
-				break;
-		default:
-				vctResult = result;
-				break;
-	}
-
-	return vctResult;
+    GT_ADV_VCT_STATUS vctResult;
+    GT_BOOL    update = GT_FALSE;
+
+    DBG_INFO(("getDetailedAdvVCTResult Called.\n"));
+
+    if (devType == GT_PHY_ADV_VCT_TYPE2)
+    {
+        if(len < 10)
+        {
+            if(amp > 54)  /* 90 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 50)
+        {
+            if(amp > 42) /* 70 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 110)
+        {
+            if(amp > 30)  /* 50 x 0.6 */
+                update = GT_TRUE;
+        }
+        else if(len < 140)
+        {
+            if(amp > 24)  /* 40 x 0.6 */
+                update = GT_TRUE;
+        }
+        else
+        {
+            if(amp > 18) /* 30 x 0.6 */
+                update = GT_TRUE;
+        }
+    }
+    else
+    {
+        if(len < 10)
+        {
+            if(amp > 90)  
+                update = GT_TRUE;
+        }
+        else if(len < 50)
+        {
+            if(amp > 70) 
+                update = GT_TRUE;
+        }
+        else if(len < 110)
+        {
+            if(amp > 50)  
+                update = GT_TRUE;
+        }
+        else if(len < 140)
+        {
+            if(amp > 40)  
+                update = GT_TRUE;
+        }
+        else
+        {
+            if(amp > 30) 
+                update = GT_TRUE;
+        }
+    }
+
+
+    switch (result)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+                if(update)
+                    vctResult = GT_ADV_VCT_OPEN;
+                else
+                    vctResult = result;
+                break;
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+                if(update)
+                    vctResult = GT_ADV_VCT_SHORT;
+                else
+                    vctResult = result;
+                break;
+        default:
+                vctResult = result;
+                break;
+    }
+
+    return vctResult;
 }
 
 /*******************************************************************************
 * analizeAdvVCTResult
 *
 * DESCRIPTION:
-*		This routine analize the Advanced VCT result.
+*        This routine analize the Advanced VCT result.
 *
 * INPUTS:
-*		channel - channel number where test was run
-*		crossChannelReg - register values after the test is completed
-*		mode    - use formula for normal cable case
+*        channel - channel number where test was run
+*        crossChannelReg - register values after the test is completed
+*        mode    - use formula for normal cable case
 *
 * OUTPUTS:
-*		cableStatus - analized test result.
+*        cableStatus - analized test result.
 *
 * RETURNS:
-*		-1, or distance to fault
+*        -1, or distance to fault
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 static
 GT_16 analizeAdvVCTNoCrosspairResult
 (
-	IN  GT_U32  devType,
-	IN  int     channel, 
-	IN  GT_U16 *crossChannelReg, 
-	IN  GT_BOOL isShort,
-	OUT GT_ADV_CABLE_STATUS *cableStatus
+    IN  GT_U32  devType,
+    IN  int     channel, 
+    IN  GT_U16 *crossChannelReg, 
+    IN  GT_BOOL isShort,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
 )
 {
-	int len;
-	GT_16 dist2fault;
-	GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
-
-	DBG_INFO(("analizeAdvVCTNoCrosspairResult Called.\n"));
-	DBG_INFO(("analizeAdvVCTNoCrosspairResult chan %d reg data %x\n", channel, crossChannelReg[channel]));
-
-	dist2fault = -1;
-
-	/* check if test is failed */
-	if(IS_VCT_FAILED(crossChannelReg[channel]))
-	{
-		cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
-		return dist2fault;
-	}
-
-	/* Check if fault detected */
-	if(IS_ZERO_AMPLITUDE(crossChannelReg[channel]))
-	{
-		cableStatus->cableStatus[channel] = GT_ADV_VCT_NORMAL;
-		return dist2fault;
-	}
-
-	/* find out test result by reading Amplitude */
-	if(IS_POSITIVE_AMPLITUDE(crossChannelReg[channel]))
-	{
-		vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
-	}
-	else
-	{
-		vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
-	}
-
-	/* 
-	 * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
-	 * GT_ADV_VCT_IMP_LESS_THAN_85
-	 */
-	switch (vctResult)
-	{
-		case GT_ADV_VCT_IMP_GREATER_THAN_115:
-		case GT_ADV_VCT_IMP_LESS_THAN_85:
-			if(!isShort)
-			{
-				len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
-			}
-			else
-			{
-				len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
-			}
-			DBG_INFO(("@@@@ no cross len %d\n", len));
-
-			if (len < 0)
-				len = 0;
-			cableStatus->u[channel].dist2fault = (GT_16)len;
-			vctResult = getDetailedAdvVCTResult(
-									devType,
-									GET_AMPLITUDE(crossChannelReg[channel]),
-									len,
-									vctResult);
-			dist2fault = (GT_16)len;
-			break;
-		default:
-			break;
-	}
-
-	cableStatus->cableStatus[channel] = vctResult;
-
-	return dist2fault;
+    int len;
+    GT_16 dist2fault;
+    GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
+
+    DBG_INFO(("analizeAdvVCTNoCrosspairResult Called.\n"));
+    DBG_INFO(("analizeAdvVCTNoCrosspairResult chan %d reg data %x\n", channel, crossChannelReg[channel]));
+
+    dist2fault = -1;
+
+    /* check if test is failed */
+    if(IS_VCT_FAILED(crossChannelReg[channel]))
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
+        return dist2fault;
+    }
+
+    /* Check if fault detected */
+    if(IS_ZERO_AMPLITUDE(crossChannelReg[channel]))
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_NORMAL;
+        return dist2fault;
+    }
+
+    /* find out test result by reading Amplitude */
+    if(IS_POSITIVE_AMPLITUDE(crossChannelReg[channel]))
+    {
+        vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
+    }
+    else
+    {
+        vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
+    }
+
+    /* 
+     * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
+     * GT_ADV_VCT_IMP_LESS_THAN_85
+     */
+    switch (vctResult)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+            if(!isShort)
+            {
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
+            }
+            else
+            {
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
+            }
+            DBG_INFO(("@@@@ no cross len %d\n", len));
+
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].dist2fault = (GT_16)len;
+            vctResult = getDetailedAdvVCTResult(
+                                    devType,
+                                    GET_AMPLITUDE(crossChannelReg[channel]),
+                                    len,
+                                    vctResult);
+            dist2fault = (GT_16)len;
+            break;
+        default:
+            break;
+    }
+
+    cableStatus->cableStatus[channel] = vctResult;
+
+    return dist2fault;
 }
 
 
 static
 GT_16 analizeAdvVCTResult
 (
-	IN  GT_U32  devType,
-	IN  int     channel, 
-	IN  GT_U16 *crossChannelReg, 
-	IN  GT_BOOL isShort,
-	OUT GT_ADV_CABLE_STATUS *cableStatus
+    IN  GT_U32  devType,
+    IN  int     channel, 
+    IN  GT_U16 *crossChannelReg, 
+    IN  GT_BOOL isShort,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
 )
 {
-	int i, len;
-	GT_16 dist2fault;
-	GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
-
-	DBG_INFO(("analizeAdvVCTResult(Crosspair) chan %d reg data %x\n", channel, crossChannelReg[channel]));
-	DBG_INFO(("analizeAdvVCTResult Called.\n"));
-
-	dist2fault = -1;
-
-	/* check if test is failed */
-	for (i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		if(IS_VCT_FAILED(crossChannelReg[i]))
-		{
-			cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
-			return dist2fault;
-		}
-	}
-
-	/* find out test result by reading Amplitude */
-	for (i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		if (i == channel)
-		{
-			if(!IS_ZERO_AMPLITUDE(crossChannelReg[i]))
-			{
-				if(IS_POSITIVE_AMPLITUDE(crossChannelReg[i]))
-				{
-					vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
-				}
-				else
-				{
-					vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
-				}
-			}
-			continue;
-		}
-
-		if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
-			continue;
-
-		vctResult = GT_ADV_VCT_CROSS_PAIR_SHORT;
-		break;
-	}
-
-	/* if it is cross pair short, check the distance for each channel */
-	if(vctResult == GT_ADV_VCT_CROSS_PAIR_SHORT)
-	{
-		cableStatus->cableStatus[channel] = GT_ADV_VCT_CROSS_PAIR_SHORT;
-		for (i=0; i<GT_MDI_PAIR_NUM; i++)
-		{
-			if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
-			{
-				cableStatus->u[channel].crossShort.channel[i] = GT_FALSE;
-				cableStatus->u[channel].crossShort.dist2fault[i] = 0;
-				continue;
-			}
+    int i, len;
+    GT_16 dist2fault;
+    GT_ADV_VCT_STATUS vctResult = GT_ADV_VCT_NORMAL;
+
+    DBG_INFO(("analizeAdvVCTResult(Crosspair) chan %d reg data %x\n", channel, crossChannelReg[channel]));
+    DBG_INFO(("analizeAdvVCTResult Called.\n"));
+
+    dist2fault = -1;
+
+    /* check if test is failed */
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        if(IS_VCT_FAILED(crossChannelReg[i]))
+        {
+            cableStatus->cableStatus[channel] = GT_ADV_VCT_FAIL;
+            return dist2fault;
+        }
+    }
+
+    /* find out test result by reading Amplitude */
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        if (i == channel)
+        {
+            if(!IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            {
+                if(IS_POSITIVE_AMPLITUDE(crossChannelReg[i]))
+                {
+                    vctResult = GT_ADV_VCT_IMP_GREATER_THAN_115;
+                }
+                else
+                {
+                    vctResult = GT_ADV_VCT_IMP_LESS_THAN_85;
+                }
+            }
+            continue;
+        }
+
+        if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            continue;
+
+        vctResult = GT_ADV_VCT_CROSS_PAIR_SHORT;
+        break;
+    }
+
+    /* if it is cross pair short, check the distance for each channel */
+    if(vctResult == GT_ADV_VCT_CROSS_PAIR_SHORT)
+    {
+        cableStatus->cableStatus[channel] = GT_ADV_VCT_CROSS_PAIR_SHORT;
+        for (i=0; i<GT_MDI_PAIR_NUM; i++)
+        {
+            if(IS_ZERO_AMPLITUDE(crossChannelReg[i]))
+            {
+                cableStatus->u[channel].crossShort.channel[i] = GT_FALSE;
+                cableStatus->u[channel].crossShort.dist2fault[i] = 0;
+                continue;
+            }
             
-			cableStatus->u[channel].crossShort.channel[i] = GT_TRUE;
-			if(!isShort)
-				len = (int)GT_ADV_VCT_CALC(crossChannelReg[i] & 0xFF);
-			else
-				len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[i] & 0xFF);
-			DBG_INFO(("@@@@ len %d\n", len));
-
-			if (len < 0)
-				len = 0;
-			cableStatus->u[channel].crossShort.dist2fault[i] = (GT_16)len;
-			dist2fault = (GT_16)len;
-		}
-
-		return dist2fault;
-	}
-
-	/* 
-	 * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
-	 * GT_ADV_VCT_IMP_LESS_THAN_85
-	 */
-	switch (vctResult)
-	{
-		case GT_ADV_VCT_IMP_GREATER_THAN_115:
-		case GT_ADV_VCT_IMP_LESS_THAN_85:
-			if(isShort)
-				len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
-			else
-				len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
-			if (len < 0)
-				len = 0;
-			cableStatus->u[channel].dist2fault = (GT_16)len;
-			vctResult = getDetailedAdvVCTResult(
-									devType,
-									GET_AMPLITUDE(crossChannelReg[channel]),
-									len,
-									vctResult);
-			dist2fault = (GT_16)len;
-			break;
-		default:
-			break;
-	}
-
-	cableStatus->cableStatus[channel] = vctResult;
-
-	return dist2fault;
+            cableStatus->u[channel].crossShort.channel[i] = GT_TRUE;
+            if(!isShort)
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[i] & 0xFF);
+            else
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[i] & 0xFF);
+            DBG_INFO(("@@@@ len %d\n", len));
+
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].crossShort.dist2fault[i] = (GT_16)len;
+            dist2fault = (GT_16)len;
+        }
+
+        return dist2fault;
+    }
+
+    /* 
+     * now, calculate the distance for GT_ADV_VCT_IMP_GREATER_THAN_115 and
+     * GT_ADV_VCT_IMP_LESS_THAN_85
+     */
+    switch (vctResult)
+    {
+        case GT_ADV_VCT_IMP_GREATER_THAN_115:
+        case GT_ADV_VCT_IMP_LESS_THAN_85:
+            if(isShort)
+                len = (int)GT_ADV_VCT_CALC(crossChannelReg[channel] & 0xFF);
+            else
+                len = (int)GT_ADV_VCT_CALC_SHORT(crossChannelReg[channel] & 0xFF);
+            if (len < 0)
+                len = 0;
+            cableStatus->u[channel].dist2fault = (GT_16)len;
+            vctResult = getDetailedAdvVCTResult(
+                                    devType,
+                                    GET_AMPLITUDE(crossChannelReg[channel]),
+                                    len,
+                                    vctResult);
+            dist2fault = (GT_16)len;
+            break;
+        default:
+            break;
+    }
+
+    cableStatus->cableStatus[channel] = vctResult;
+
+    return dist2fault;
 }
 
 
@@ -412,116 +415,116 @@ GT_16 analizeAdvVCTResult
 * runAdvCableTest_1181
 *
 * DESCRIPTION:
-*		This routine performs the advanced virtual cable test for the PHY with
-*		multiple page mode and returns the the status per MDIP/N.
+*        This routine performs the advanced virtual cable test for the PHY with
+*        multiple page mode and returns the the status per MDIP/N.
 *
 * INPUTS:
-*		port - logical port number.
-*		mode - GT_TRUE, if short cable detect is required
-*			   GT_FALSE, otherwise
+*        port - logical port number.
+*        mode - GT_TRUE, if short cable detect is required
+*               GT_FALSE, otherwise
 *
 * OUTPUTS:
-*		cableStatus - the port copper cable status.
-*		tooShort    - if known distance to fault is too short
+*        cableStatus - the port copper cable status.
+*        tooShort    - if known distance to fault is too short
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 static 
 GT_STATUS runAdvCableTest_1181
-(	
-	IN  GT_QD_DEV       *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
-	IN  GT_BOOL         mode,
-	OUT GT_ADV_CABLE_STATUS *cableStatus,
-	OUT GT_BOOL         *tooShort
+(    
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_BOOL         mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus,
+    OUT GT_BOOL         *tooShort
 )
 {
-	GT_STATUS retVal;
-	GT_U16 u16Data;
-	GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
-	int i,j;
-	GT_16  dist2fault;
-
-	VCT_REGISTER regList[GT_MDI_PAIR_NUM][GT_MDI_PAIR_NUM] = {
-							{{8,16},{8,17},{8,18},{8,19}},  /* channel 0 */
-							{{8,24},{8,25},{8,26},{8,27}},  /* channel 1 */
-							{{9,16},{9,17},{9,18},{9,19}},  /* channel 2 */
-							{{9,24},{9,25},{9,26},{9,27}}   /* channel 3 */
-							};
-
-	DBG_INFO(("runAdvCableTest_1181 Called.\n"));
-
-	if (mode)
-		*tooShort = GT_FALSE;
-
-	/* 
-	 * start Advanced Virtual Cable Tester
-	 */
-	if((retVal = hwSetPagedPhyRegField(
-						dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,15,1,phyInfo->anyPage,1)) != GT_OK)
-	{
-		DBG_INFO(("Writing to paged phy reg failed.\n"));
-		return retVal;
-	}
-
-	/* 
-	 * loop until test completion and result is valid
-	 */
-	do
-	{
-		if((retVal = hwReadPagedPhyReg(
-							dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			DBG_INFO(("Reading from paged phy reg failed.\n"));
-			return retVal;
-		}
-	} while(u16Data & 0x8000);
-
-	DBG_INFO(("Page 8 of Reg20 after test : %0#x.\n", u16Data));
-
-	for (i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		/*
-		 * read the test result for the cross pair against selected MDI Pair
-		 */
-		for (j=0; j<GT_MDI_PAIR_NUM; j++)
-		{
-			if((retVal = hwReadPagedPhyReg(
-								dev,hwPort,
-								regList[i][j].page,
-								regList[i][j].regOffset,
-								phyInfo->anyPage,
-								&crossChannelReg[j])) != GT_OK)
-			{
-				DBG_INFO(("Reading from paged phy reg failed.\n"));
-				return retVal;
-			}
-		}
-
-		/*
-		 * analyze the test result for RX Pair
-		 */
-		dist2fault = analizeAdvVCTResult(phyInfo->vctType, i, crossChannelReg, mode, cableStatus);
-
-		if(mode)
-		{
-			if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
-			{
-				DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
-				*tooShort = GT_TRUE;
-				break;
-			}
-		}
-	}
-
-	return GT_OK;
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+    GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
+    int i,j;
+    GT_16  dist2fault;
+
+    VCT_REGISTER regList[GT_MDI_PAIR_NUM][GT_MDI_PAIR_NUM] = {
+                            {{8,16},{8,17},{8,18},{8,19}},  /* channel 0 */
+                            {{8,24},{8,25},{8,26},{8,27}},  /* channel 1 */
+                            {{9,16},{9,17},{9,18},{9,19}},  /* channel 2 */
+                            {{9,24},{9,25},{9,26},{9,27}}   /* channel 3 */
+                            };
+
+    DBG_INFO(("runAdvCableTest_1181 Called.\n"));
+
+    if (mode)
+        *tooShort = GT_FALSE;
+
+    /* 
+     * start Advanced Virtual Cable Tester
+     */
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,15,1,phyInfo->anyPage,1)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    /* 
+     * loop until test completion and result is valid
+     */
+    do
+    {
+        if((retVal = hwReadPagedPhyReg(
+                            dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+    } while(u16Data & 0x8000);
+
+    DBG_INFO(("Page 8 of Reg20 after test : %0#x.\n", u16Data));
+
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the cross pair against selected MDI Pair
+         */
+        for (j=0; j<GT_MDI_PAIR_NUM; j++)
+        {
+            if((retVal = hwReadPagedPhyReg(
+                                dev,hwPort,
+                                regList[i][j].page,
+                                regList[i][j].regOffset,
+                                phyInfo->anyPage,
+                                &crossChannelReg[j])) != GT_OK)
+            {
+                DBG_INFO(("Reading from paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+
+        /*
+         * analyze the test result for RX Pair
+         */
+        dist2fault = analizeAdvVCTResult(phyInfo->vctType, i, crossChannelReg, mode, cableStatus);
+
+        if(mode)
+        {
+            if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
+            {
+                DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
+                *tooShort = GT_TRUE;
+                break;
+            }
+        }
+    }
+
+    return GT_OK;
 }
 
 
@@ -530,433 +533,433 @@ GT_STATUS runAdvCableTest_1181
 * getAdvCableStatus_1181
 *
 * DESCRIPTION:
-*		This routine performs the virtual cable test for the PHY with
-*		multiple page mode and returns the the status per MDIP/N.
+*        This routine performs the virtual cable test for the PHY with
+*        multiple page mode and returns the the status per MDIP/N.
 *
 * INPUTS:
-*		port - logical port number.
-*		mode - advance VCT mode (either First Peak or Maximum Peak)
+*        port - logical port number.
+*        mode - advance VCT mode (either First Peak or Maximum Peak)
 *
 * OUTPUTS:
-*		cableStatus - the port copper cable status.
+*        cableStatus - the port copper cable status.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 static 
 GT_STATUS getAdvCableStatus_1181
-(	
-	IN  GT_QD_DEV          *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
-	IN  GT_ADV_VCT_MODE mode,
-	OUT GT_ADV_CABLE_STATUS *cableStatus
+(    
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS retVal;
-	GT_U16 orgPulse, u16Data;
-	GT_BOOL flag, tooShort;
-
-	flag = GT_TRUE;
-
-	/*
-	 * set Adv VCT Mode
-	 */
-	switch (mode.mode)
-	{
-		case GT_ADV_VCT_FIRST_PEAK:
-			break;
-		case GT_ADV_VCT_MAX_PEAK:
-			break;
-		default:
-			DBG_INFO(("Unknown Advanced VCT Mode.\n"));
-			return GT_BAD_PARAM;
-	}
-
-	u16Data = (mode.mode<<6) | (mode.peakDetHyst) | (mode.sampleAvg<<8);
-	if((retVal = hwSetPagedPhyRegField(
-						dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,0,11,phyInfo->anyPage,u16Data)) != GT_OK)
-	{
-		DBG_INFO(("Writing to paged phy reg failed.\n"));
-		return retVal;
-	}
-
-	if (flag)
-	{
-		/* save original Pulse Width */
-		if((retVal = hwGetPagedPhyRegField(
-							dev,hwPort,9,23,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
-		{
-			DBG_INFO(("Reading paged phy reg failed.\n"));
-			return retVal;
-		}
-
-		/* set the Pulse Width with default value */
-		if (orgPulse != 0)
-		{
-			if((retVal = hwSetPagedPhyRegField(
-								dev,hwPort,9,23,10,2,phyInfo->anyPage,0)) != GT_OK)
-			{
-				DBG_INFO(("Writing to paged phy reg failed.\n"));
-				return retVal;
-			}
-		}
-	}
-
-	if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,flag,cableStatus,&tooShort)) != GT_OK)
-	{
-		DBG_INFO(("Running advanced VCT failed.\n"));
-		return retVal;
-	}
-
-	if (flag)
-	{
-		if(tooShort)
-		{
-			/* set the Pulse Width with minimum width */
-			if((retVal = hwSetPagedPhyRegField(
-								dev,hwPort,9,23,10,2,phyInfo->anyPage,3)) != GT_OK)
-			{
-				DBG_INFO(("Writing to paged phy reg failed.\n"));
-				return retVal;
-			}
-
-			/* run the Adv VCT again */
-			if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,GT_FALSE,cableStatus,&tooShort)) != GT_OK)
-			{
-				DBG_INFO(("Running advanced VCT failed.\n"));
-				return retVal;
-			}
-
-		}
-
-		/* set the Pulse Width back to the original value */
-		if((retVal = hwSetPagedPhyRegField(
-							dev,hwPort,9,23,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
-		{
-			DBG_INFO(("Writing to paged phy reg failed.\n"));
-			return retVal;
-		}
-
-	}
-
-	return GT_OK;
+    GT_STATUS retVal;
+    GT_U16 orgPulse, u16Data;
+    GT_BOOL flag, tooShort;
+
+    flag = GT_TRUE;
+
+    /*
+     * set Adv VCT Mode
+     */
+    switch (mode.mode)
+    {
+        case GT_ADV_VCT_FIRST_PEAK:
+            break;
+        case GT_ADV_VCT_MAX_PEAK:
+            break;
+        default:
+            DBG_INFO(("Unknown Advanced VCT Mode.\n"));
+            return GT_BAD_PARAM;
+    }
+
+    u16Data = (mode.mode<<6) | (mode.peakDetHyst) | (mode.sampleAvg<<8);
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,8,QD_REG_ADV_VCT_CONTROL_8,0,11,phyInfo->anyPage,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        /* save original Pulse Width */
+        if((retVal = hwGetPagedPhyRegField(
+                            dev,hwPort,9,23,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Reading paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        /* set the Pulse Width with default value */
+        if (orgPulse != 0)
+        {
+            if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,9,23,10,2,phyInfo->anyPage,0)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,flag,cableStatus,&tooShort)) != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        if(tooShort)
+        {
+            /* set the Pulse Width with minimum width */
+            if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,9,23,10,2,phyInfo->anyPage,3)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+
+            /* run the Adv VCT again */
+            if((retVal=runAdvCableTest_1181(dev,hwPort,phyInfo,GT_FALSE,cableStatus,&tooShort)) != GT_OK)
+            {
+                DBG_INFO(("Running advanced VCT failed.\n"));
+                return retVal;
+            }
+
+        }
+
+        /* set the Pulse Width back to the original value */
+        if((retVal = hwSetPagedPhyRegField(
+                            dev,hwPort,9,23,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+    }
+
+    return GT_OK;
 }
 
 
 static 
 GT_STATUS runAdvCableTest_1116_set
-(	
-	IN  GT_QD_DEV          *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
-	IN  GT_32           channel,
-	IN  GT_ADV_VCT_TRANS_CHAN_SEL		crosspair
+(    
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_32           channel,
+    IN  GT_ADV_VCT_TRANS_CHAN_SEL        crosspair
 )
 {
-	GT_STATUS retVal;
+    GT_STATUS retVal;
 
-	DBG_INFO(("runAdvCableTest_1116_set Called.\n"));
+    DBG_INFO(("runAdvCableTest_1116_set Called.\n"));
 
-	/* 
-	 * start Advanced Virtual Cable Tester
-	 */
-	if((retVal = hwSetPagedPhyRegField(
-						dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,15,1,phyInfo->anyPage,1)) != GT_OK)
-	{
-		DBG_INFO(("Writing to paged phy reg failed.\n"));
-		return retVal;
-	}
+    /* 
+     * start Advanced Virtual Cable Tester
+     */
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,15,1,phyInfo->anyPage,1)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 static 
 GT_STATUS runAdvCableTest_1116_check
-(	
-	IN  GT_QD_DEV       *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo
+(    
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo
 )
 {
-	GT_STATUS retVal;
-	GT_U16 u16Data;
-
-	/* 
-	 * loop until test completion and result is valid
-	 */
-	do {
-		if((retVal = hwReadPagedPhyReg(
-							dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			DBG_INFO(("Reading from paged phy reg failed.\n"));
-			return retVal;
-		}
-	} while (u16Data & 0x8000);
-
-	return GT_OK;
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+
+    /* 
+     * loop until test completion and result is valid
+     */
+    do {
+        if((retVal = hwReadPagedPhyReg(
+                            dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+    } while (u16Data & 0x8000);
+
+    return GT_OK;
 }
 
 static 
 GT_STATUS runAdvCableTest_1116_get
-(	
-	IN  GT_QD_DEV          *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
-	IN  GT_ADV_VCT_TRANS_CHAN_SEL	crosspair,
-	IN  GT_32			channel,
-	OUT GT_ADV_CABLE_STATUS *cableStatus,
-	OUT GT_BOOL         *tooShort
+(    
+    IN  GT_QD_DEV          *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_TRANS_CHAN_SEL    crosspair,
+    IN  GT_32            channel,
+    OUT GT_ADV_CABLE_STATUS *cableStatus,
+    OUT GT_BOOL         *tooShort
 )
 {
-	GT_STATUS retVal;
-	GT_U16 u16Data;
-	GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
-	int j;
-	GT_16  dist2fault;
-	GT_BOOL         mode;
-	GT_BOOL         localTooShort[GT_MDI_PAIR_NUM];
-
-	VCT_REGISTER regList[GT_MDI_PAIR_NUM] = { {5,16},{5,17},{5,18},{5,19} };
-
-	mode = GT_TRUE;
-
-	DBG_INFO(("runAdvCableTest_1116_get Called.\n"));
-
-	if ((retVal = hwReadPagedPhyReg(
-						dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
-	{
-		DBG_INFO(("Reading from paged phy reg failed.\n"));
-		return retVal;
-	}
-
-	DBG_INFO(("Page 5 of Reg23 after test : %0#x.\n", u16Data));
-
-	/*
-	 * read the test result for the cross pair against selected MDI Pair
-	 */
-	for (j=0; j<GT_MDI_PAIR_NUM; j++)
-	{
-		if((retVal = hwReadPagedPhyReg(
-								dev,hwPort,
-								regList[j].page,
-								regList[j].regOffset,
-								phyInfo->anyPage,
-								&crossChannelReg[j])) != GT_OK)
-		{
-			DBG_INFO(("Reading from paged phy reg failed.\n"));
-			return retVal;
-		}
-		DBG_INFO(("@@@@@ reg channel %d is %x \n", j, crossChannelReg[j]));
-	}
-
-	/*
-	 * analyze the test result for RX Pair
-	 */
-	for (j=0; j<GT_MDI_PAIR_NUM; j++)
-	{
-		if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
-			dist2fault = analizeAdvVCTResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
-		else
-			dist2fault = analizeAdvVCTNoCrosspairResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
-
-		localTooShort[j]=GT_FALSE;
-		if((mode)&&(*tooShort==GT_FALSE))
-		{
-			if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
-			{
-				DBG_INFO(("@@@#@@@@ it is too short dist2fault %d\n", dist2fault));
-				DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
-				localTooShort[j]=GT_TRUE;
-			}
-		}
-	}
-
-	/* check and decide if length is too short */
-	for (j=0; j<GT_MDI_PAIR_NUM; j++)
-	{
-		if (localTooShort[j]==GT_FALSE) break;
-	}
-
-	if (j==GT_MDI_PAIR_NUM)
-		*tooShort = GT_TRUE;
-
-	return GT_OK;
+    GT_STATUS retVal;
+    GT_U16 u16Data;
+    GT_U16 crossChannelReg[GT_MDI_PAIR_NUM];
+    int j;
+    GT_16  dist2fault;
+    GT_BOOL         mode;
+    GT_BOOL         localTooShort[GT_MDI_PAIR_NUM];
+
+    VCT_REGISTER regList[GT_MDI_PAIR_NUM] = { {5,16},{5,17},{5,18},{5,19} };
+
+    mode = GT_TRUE;
+
+    DBG_INFO(("runAdvCableTest_1116_get Called.\n"));
+
+    if ((retVal = hwReadPagedPhyReg(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading from paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("Page 5 of Reg23 after test : %0#x.\n", u16Data));
+
+    /*
+     * read the test result for the cross pair against selected MDI Pair
+     */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if((retVal = hwReadPagedPhyReg(
+                                dev,hwPort,
+                                regList[j].page,
+                                regList[j].regOffset,
+                                phyInfo->anyPage,
+                                &crossChannelReg[j])) != GT_OK)
+        {
+            DBG_INFO(("Reading from paged phy reg failed.\n"));
+            return retVal;
+        }
+        DBG_INFO(("@@@@@ reg channel %d is %x \n", j, crossChannelReg[j]));
+    }
+
+    /*
+     * analyze the test result for RX Pair
+     */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
+            dist2fault = analizeAdvVCTResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
+        else
+            dist2fault = analizeAdvVCTNoCrosspairResult(phyInfo->vctType, j, crossChannelReg, mode&(*tooShort), cableStatus);
+
+        localTooShort[j]=GT_FALSE;
+        if((mode)&&(*tooShort==GT_FALSE))
+        {
+            if ((dist2fault>=0) && (dist2fault<GT_ADV_VCT_ACCEPTABLE_SHORT_CABLE))
+            {
+                DBG_INFO(("@@@#@@@@ it is too short dist2fault %d\n", dist2fault));
+                DBG_INFO(("Distance to Fault is too Short. So, rerun after changing pulse width\n"));
+                localTooShort[j]=GT_TRUE;
+            }
+        }
+    }
+
+    /* check and decide if length is too short */
+    for (j=0; j<GT_MDI_PAIR_NUM; j++)
+    {
+        if (localTooShort[j]==GT_FALSE) break;
+    }
+
+    if (j==GT_MDI_PAIR_NUM)
+        *tooShort = GT_TRUE;
+
+    return GT_OK;
 }
 
 static 
 GT_STATUS runAdvCableTest_1116
-(	
+(    
     IN  GT_QD_DEV          *dev,
     IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN    GT_PHY_INFO        *phyInfo,
     IN  GT_BOOL         mode,
     IN  GT_ADV_VCT_TRANS_CHAN_SEL   crosspair,
     OUT GT_ADV_CABLE_STATUS *cableStatus,
     OUT GT_BOOL         *tooShort
 )
 {
-	GT_STATUS retVal;
-	GT_32  channel;
-
-	DBG_INFO(("runAdvCableTest_1116 Called.\n"));
-
-	if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
-	{
-		channel = crosspair - GT_ADV_VCT_TCS_CROSSPAIR_0;
-	}
-	else
-	{
-		channel = 0;
-	}
-
-	/* Set transmit channel */
-	if((retVal=runAdvCableTest_1116_set(dev,hwPort, phyInfo,channel, crosspair)) != GT_OK) 
-	{
-		DBG_INFO(("Running advanced VCT failed.\n"));
-		return retVal;
-	}
-
-	/* 
-	 * check test completion
-	 */
-	retVal = runAdvCableTest_1116_check(dev,hwPort,phyInfo);
-	if (retVal != GT_OK)
-	{
-		DBG_INFO(("Running advanced VCT failed.\n"));
-		return retVal;
-	}
-
-	/*
-	 * read the test result for the cross pair against selected MDI Pair
-	 */
-	retVal = runAdvCableTest_1116_get(dev, hwPort, phyInfo, crosspair,
-									channel,cableStatus,(GT_BOOL *)tooShort);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Running advanced VCT get failed.\n"));
-	}
-
-	return retVal;
+    GT_STATUS retVal;
+    GT_32  channel;
+
+    DBG_INFO(("runAdvCableTest_1116 Called.\n"));
+
+    if (crosspair!=GT_ADV_VCT_TCS_NO_CROSSPAIR)
+    {
+        channel = crosspair - GT_ADV_VCT_TCS_CROSSPAIR_0;
+    }
+    else
+    {
+        channel = 0;
+    }
+
+    /* Set transmit channel */
+    if((retVal=runAdvCableTest_1116_set(dev,hwPort, phyInfo,channel, crosspair)) != GT_OK) 
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    /* 
+     * check test completion
+     */
+    retVal = runAdvCableTest_1116_check(dev,hwPort,phyInfo);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    /*
+     * read the test result for the cross pair against selected MDI Pair
+     */
+    retVal = runAdvCableTest_1116_get(dev, hwPort, phyInfo, crosspair,
+                                    channel,cableStatus,(GT_BOOL *)tooShort);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT get failed.\n"));
+    }
+
+    return retVal;
 }
 
 static 
 GT_STATUS getAdvCableStatus_1116
-(	
-	IN  GT_QD_DEV       *dev,
-	IN  GT_U8           hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
-	IN  GT_ADV_VCT_MODE mode,
-	OUT GT_ADV_CABLE_STATUS *cableStatus
+(    
+    IN  GT_QD_DEV       *dev,
+    IN  GT_U8           hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS retVal;
-	GT_U16 orgPulse, u16Data;
-	GT_BOOL flag, tooShort;
-	GT_ADV_VCT_TRANS_CHAN_SEL crosspair;
-
-	flag = GT_TRUE;
-	crosspair = mode.transChanSel;
-
-	/*
-	 * Check Adv VCT Mode
-	 */
-	switch (mode.mode)
-	{
-		case GT_ADV_VCT_FIRST_PEAK:
-		case GT_ADV_VCT_MAX_PEAK:
-				break;
-
-		default:
-				DBG_INFO(("Unknown ADV VCT Mode.\n"));
-				return GT_NOT_SUPPORTED;
-	}
-
-	if((retVal = hwGetPagedPhyRegField(
-							dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,&u16Data)) != GT_OK)
-	{
-		DBG_INFO(("Reading paged phy reg failed.\n"));
-		return retVal;
-	}
-
-	u16Data |= ((mode.mode<<6) | (mode.transChanSel<<11));
-	if (mode.peakDetHyst) u16Data |= (mode.peakDetHyst);
-	if (mode.sampleAvg) u16Data |= (mode.sampleAvg<<8) ;
-
-	if((retVal = hwSetPagedPhyRegField(
-						dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,u16Data)) != GT_OK)
-	{
-		DBG_INFO(("Writing to paged phy reg failed.\n"));
-		return retVal;
-	}
-
-	if (flag)
-	{
-		/* save original Pulse Width */
-		if((retVal = hwGetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
-		{
-			DBG_INFO(("Reading paged phy reg failed.\n"));
-			return retVal;
-		}
-
-		/* set the Pulse Width with default value */
-		if (orgPulse != 0)
-		{
-			if((retVal = hwSetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,0)) != GT_OK)
-			{
-				DBG_INFO(("Writing to paged phy reg failed.\n"));
-				return retVal;
-			}
-		}
-		tooShort=GT_FALSE;
-	}
-
-	if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,flag,crosspair, 
-									cableStatus,&tooShort)) != GT_OK)
-	{
-		DBG_INFO(("Running advanced VCT failed.\n"));
-		return retVal;
-	}
-
-	if (flag)
-	{
-		if(tooShort)
-		{
-			/* set the Pulse Width with minimum width */
-			if((retVal = hwSetPagedPhyRegField(
-										dev,hwPort,5,28,10,2,phyInfo->anyPage,3)) != GT_OK)
-			{
-				DBG_INFO(("Writing to paged phy reg failed.\n"));
-				return retVal;
-			}
-
-			/* run the Adv VCT again */
-			if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,GT_FALSE,crosspair,
-										cableStatus,&tooShort)) != GT_OK)
-			{
-				DBG_INFO(("Running advanced VCT failed.\n"));
-				return retVal;
-			}
-
-		}
-
-		/* set the Pulse Width back to the original value */
-		if((retVal = hwSetPagedPhyRegField(
-								dev,hwPort,5,28,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
-		{
-			DBG_INFO(("Writing to paged phy reg failed.\n"));
-			return retVal;
-		}
-
-	}
-
-	return GT_OK;
+    GT_STATUS retVal;
+    GT_U16 orgPulse, u16Data;
+    GT_BOOL flag, tooShort;
+    GT_ADV_VCT_TRANS_CHAN_SEL crosspair;
+
+    flag = GT_TRUE;
+    crosspair = mode.transChanSel;
+
+    /*
+     * Check Adv VCT Mode
+     */
+    switch (mode.mode)
+    {
+        case GT_ADV_VCT_FIRST_PEAK:
+        case GT_ADV_VCT_MAX_PEAK:
+                break;
+
+        default:
+                DBG_INFO(("Unknown ADV VCT Mode.\n"));
+                return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal = hwGetPagedPhyRegField(
+                            dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Reading paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    u16Data |= ((mode.mode<<6) | (mode.transChanSel<<11));
+    if (mode.peakDetHyst) u16Data |= (mode.peakDetHyst);
+    if (mode.sampleAvg) u16Data |= (mode.sampleAvg<<8) ;
+
+    if((retVal = hwSetPagedPhyRegField(
+                        dev,hwPort,5,QD_REG_ADV_VCT_CONTROL_5,0,13,phyInfo->anyPage,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Writing to paged phy reg failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        /* save original Pulse Width */
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,&orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Reading paged phy reg failed.\n"));
+            return retVal;
+        }
+
+        /* set the Pulse Width with default value */
+        if (orgPulse != 0)
+        {
+            if((retVal = hwSetPagedPhyRegField(dev,hwPort,5,28,10,2,phyInfo->anyPage,0)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+        }
+        tooShort=GT_FALSE;
+    }
+
+    if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,flag,crosspair, 
+                                    cableStatus,&tooShort)) != GT_OK)
+    {
+        DBG_INFO(("Running advanced VCT failed.\n"));
+        return retVal;
+    }
+
+    if (flag)
+    {
+        if(tooShort)
+        {
+            /* set the Pulse Width with minimum width */
+            if((retVal = hwSetPagedPhyRegField(
+                                        dev,hwPort,5,28,10,2,phyInfo->anyPage,3)) != GT_OK)
+            {
+                DBG_INFO(("Writing to paged phy reg failed.\n"));
+                return retVal;
+            }
+
+            /* run the Adv VCT again */
+            if((retVal=runAdvCableTest_1116(dev,hwPort,phyInfo,GT_FALSE,crosspair,
+                                        cableStatus,&tooShort)) != GT_OK)
+            {
+                DBG_INFO(("Running advanced VCT failed.\n"));
+                return retVal;
+            }
+
+        }
+
+        /* set the Pulse Width back to the original value */
+        if((retVal = hwSetPagedPhyRegField(
+                                dev,hwPort,5,28,10,2,phyInfo->anyPage,orgPulse)) != GT_OK)
+        {
+            DBG_INFO(("Writing to paged phy reg failed.\n"));
+            return retVal;
+        }
+
+    }
+
+    return GT_OK;
 }
 
 
@@ -980,7 +983,7 @@ GT_STATUS getAdvCableStatus_1116
 *
 * COMMENTS:
 *       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are supporting this API.
+*        are supporting this API.
 *
 *******************************************************************************/
 GT_STATUS gvctGetAdvCableDiag
@@ -991,169 +994,174 @@ GT_STATUS gvctGetAdvCableDiag
     OUT GT_ADV_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status;
-	GT_U8 hwPort;
-	GT_U16 u16Data, org0;
-	GT_BOOL ppuEn;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn, autoNeg;
-	GT_U16			pageReg;
-	int i;
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_U16 u16Data, org0;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn, autoNeg;
+    GT_U16            pageReg;
+    int i;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gvctGetAdvCableDiag_mad(dev, port, mode, cableStatus);
+#endif
 
     DBG_INFO(("gvctGetCableDiag Called.\n"));
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports VCT */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_ADV_VCT_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Need to disable PPUEn for safe. */
-	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
-	{
-		ppuEn = GT_FALSE;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to disable PPUEn.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-		gtDelay(250);
-	}
-		
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	/*
-	 * If Fiber is used, simply return with test fail.
-	 */
-	if(phyInfo.flag & GT_PHY_FIBER)
-	{
-		if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo.anyPage,&u16Data)) != GT_OK)
-		{
-			return status;
-		}
-
-		if(u16Data & 0x400)
-		{
-			for (i=0; i<GT_MDI_PAIR_NUM; i++)
-			{
-				cableStatus->cableStatus[i] = GT_ADV_VCT_FAIL;
-			}
-			return GT_OK;
-		}
-	}
-
-	/*
-	 * Check the link
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to reset the Phy.\n"));
-		return status;
-	}
-
-	autoNeg = GT_FALSE;
-	org0 = 0;
-	if (!(u16Data & 0x400))
-	{
-		/* link is down, so disable auto-neg if enabled */
-		if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&u16Data)) != GT_OK)
-		{
-		    DBG_INFO(("Not able to reset the Phy.\n"));
-			return status;
-		}
-		
-		org0 = u16Data;
-
-		if (u16Data & 0x1000)
-		{
-			u16Data = 0x140;
-
-			/* link is down, so disable auto-neg if enabled */
-			if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,u16Data)) != GT_OK)
-			{
-			    DBG_INFO(("Not able to reset the Phy.\n"));
-				return status;
-			}
-
-			if((status= hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-			{
-			    DBG_INFO(("Not able to reset the Phy.\n"));
-				return status;
-			}
-			autoNeg = GT_TRUE;		
-		}
-	}
-
-	switch(phyInfo.vctType)
-	{
-		case GT_PHY_ADV_VCT_TYPE1:
-			status = getAdvCableStatus_1181(dev,hwPort,&phyInfo,mode,cableStatus);
-			break;
-		case GT_PHY_ADV_VCT_TYPE2:
-			status = getAdvCableStatus_1116(dev,hwPort,&phyInfo,mode,cableStatus);
-			break;
-		default:
-			status = GT_FAIL;
-			break;
-	}
-
-	if (autoNeg)
-	{
-		if((status= hwPhyReset(dev,hwPort,org0)) != GT_OK)
-		{
-		    DBG_INFO(("Not able to reset the Phy.\n"));
-			goto cableDiagCleanup;
-			return status;
-		}
-	}
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_ADV_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+        
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /*
+     * If Fiber is used, simply return with test fail.
+     */
+    if(phyInfo.flag & GT_PHY_FIBER)
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+
+        if(u16Data & 0x400)
+        {
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                cableStatus->cableStatus[i] = GT_ADV_VCT_FAIL;
+            }
+            return GT_OK;
+        }
+    }
+
+    /*
+     * Check the link
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        return status;
+    }
+
+    autoNeg = GT_FALSE;
+    org0 = 0;
+    if (!(u16Data & 0x400))
+    {
+        /* link is down, so disable auto-neg if enabled */
+        if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+            DBG_INFO(("Not able to reset the Phy.\n"));
+            return status;
+        }
+        
+        org0 = u16Data;
+
+        if (u16Data & 0x1000)
+        {
+            u16Data = 0x140;
+
+            /* link is down, so disable auto-neg if enabled */
+            if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,u16Data)) != GT_OK)
+            {
+                DBG_INFO(("Not able to reset the Phy.\n"));
+                return status;
+            }
+
+            if((status= hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+            {
+                DBG_INFO(("Not able to reset the Phy.\n"));
+                return status;
+            }
+            autoNeg = GT_TRUE;        
+        }
+    }
+
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_ADV_VCT_TYPE1:
+            status = getAdvCableStatus_1181(dev,hwPort,&phyInfo,mode,cableStatus);
+            break;
+        case GT_PHY_ADV_VCT_TYPE2:
+            status = getAdvCableStatus_1116(dev,hwPort,&phyInfo,mode,cableStatus);
+            break;
+        default:
+            status = GT_FAIL;
+            break;
+    }
+
+    if (autoNeg)
+    {
+        if((status= hwPhyReset(dev,hwPort,org0)) != GT_OK)
+        {
+            DBG_INFO(("Not able to reset the Phy.\n"));
+            goto cableDiagCleanup;
+            return status;
+        }
+    }
 
 cableDiagCleanup:
 
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to enable PPUEn.\n"));
-			status = GT_FAIL;
-		}
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return status;	
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;    
 }
 
 
@@ -1180,7 +1188,7 @@ cableDiagCleanup:
 static
 GT_STATUS dspLookup
 (
-	IN	GT_PHY_INFO		*phyInfo,
+    IN    GT_PHY_INFO        *phyInfo,
     IN  GT_U16 regValue, 
     OUT GT_32  *cableLen
 )
@@ -1189,13 +1197,13 @@ GT_STATUS dspLookup
     GT_U8* tbl;
     switch(phyInfo->exStatusType)
     {
-        case GT_PHY_EX_STATUS_TYPE1:	/* 88E1111/88E1141/E1145 */
+        case GT_PHY_EX_STATUS_TYPE1:    /* 88E1111/88E1141/E1145 */
             startEntry = 18-1;
             tableEntry = 80;
             tbl = tbl_1111;
             break;
 
-        case GT_PHY_EX_STATUS_TYPE2:	/* 88E1112 */
+        case GT_PHY_EX_STATUS_TYPE2:    /* 88E1112 */
             startEntry = 17;
             tableEntry = 100;
             tbl = tbl_1112;
@@ -1220,16 +1228,16 @@ GT_STATUS dspLookup
             break;
 
         case GT_PHY_EX_STATUS_TYPE6:   /* 88E6165 Internal Phy */
-			if ((phyInfo->phyId & PHY_MODEL_MASK) == DEV_G65G)
-	            startEntry = 18;
-			else
-	            startEntry = 21;
+            if ((phyInfo->phyId & PHY_MODEL_MASK) == DEV_G65G)
+                startEntry = 18;
+            else
+                startEntry = 21;
             tableEntry = 76;
             tbl = tbl_1240;
             break;
 
-		default:
-			return GT_NOT_SUPPORTED;
+        default:
+            return GT_NOT_SUPPORTED;
     }
 
     if (tbl == NULL)
@@ -1283,7 +1291,7 @@ GT_STATUS getDSPDistance_1111
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8  hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN    GT_PHY_INFO        *phyInfo,
     IN  GT_U32 mdi,
     OUT GT_32 *cableLen
 )
@@ -1331,7 +1339,7 @@ GT_STATUS getDSPDistance_1181
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8  hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN    GT_PHY_INFO        *phyInfo,
     IN  GT_U32 mdi,
     OUT GT_32 *cableLen
 )
@@ -1406,7 +1414,7 @@ GT_STATUS getDSPDistance_1240
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8  hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN    GT_PHY_INFO        *phyInfo,
     IN  GT_U32 mdi,
     OUT GT_32 *cableLen
 )
@@ -1461,7 +1469,7 @@ GT_STATUS getDSPDistance_1240
 *
 * DESCRIPTION:
 *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
-*		for 1000M phy with multiple page mode
+*        for 1000M phy with multiple page mode
 *
 * INPUTS:
 *       dev - device context.
@@ -1480,9 +1488,9 @@ GT_STATUS getDSPDistance_1240
 *******************************************************************************/
 static GT_STATUS getExStatus_28
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8	        hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
     OUT GT_ADV_EXTENDED_STATUS *extendedStatus
 )
 {
@@ -1493,7 +1501,7 @@ static GT_STATUS getExStatus_28
     /* DSP based cable length */
     for (i=0; i<GT_MDI_PAIR_NUM; i++)
     {
-        if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,&extendedStatus->cableLen[i])) != GT_OK)
+        if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,(GT_32 *)&(extendedStatus->cableLen[i]))) != GT_OK)
         {
             DBG_INFO(("getDSPDistance failed.\n"));
             return retVal;
@@ -1518,8 +1526,8 @@ static GT_STATUS getExStatus_28
         return GT_OK;
     }
 
-	extendedStatus->isValid = GT_TRUE;
-	
+    extendedStatus->isValid = GT_TRUE;
+    
     /* get Pair Polarity */
     for(i=0; i<GT_MDI_PAIR_NUM; i++)
     {
@@ -1583,7 +1591,7 @@ static GT_STATUS getExStatus_28
 *
 * DESCRIPTION:
 *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
-*		for 1000M phy with multiple page mode
+*        for 1000M phy with multiple page mode
 *
 * INPUTS:
 *       dev - device context.
@@ -1602,9 +1610,9 @@ static GT_STATUS getExStatus_28
 *******************************************************************************/
 static GT_STATUS getExStatus
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8	        hwPort,
-	IN	GT_PHY_INFO		*phyInfo,
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
+    IN    GT_PHY_INFO        *phyInfo,
     OUT GT_ADV_EXTENDED_STATUS *extendedStatus
 )
 {
@@ -1619,7 +1627,7 @@ static GT_STATUS getExStatus
         case GT_PHY_EX_STATUS_TYPE2:
             for (i=0; i<GT_MDI_PAIR_NUM; i++)
             {
-                if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,&extendedStatus->cableLen[i])) != GT_OK)
+                if((retVal = getDSPDistance_1111(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
                 {
                     DBG_INFO(("getDSPDistance failed.\n"));
                     return retVal;
@@ -1631,7 +1639,7 @@ static GT_STATUS getExStatus
         case GT_PHY_EX_STATUS_TYPE5:
             for (i=0; i<GT_MDI_PAIR_NUM; i++)
             {
-                if((retVal = getDSPDistance_1181(dev,hwPort,phyInfo,i,&extendedStatus->cableLen[i])) != GT_OK)
+                if((retVal = getDSPDistance_1181(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
                 {
                     DBG_INFO(("getDSPDistance failed.\n"));
                     return retVal;
@@ -1642,7 +1650,7 @@ static GT_STATUS getExStatus
         case GT_PHY_EX_STATUS_TYPE6:
             for (i=0; i<GT_MDI_PAIR_NUM; i++)
             {
-                if((retVal = getDSPDistance_1240(dev,hwPort,phyInfo,i,&extendedStatus->cableLen[i])) != GT_OK)
+                if((retVal = getDSPDistance_1240(dev,hwPort,phyInfo,i,(GT_32 *)&extendedStatus->cableLen[i])) != GT_OK)
                 {
                     DBG_INFO(("getDSPDistance failed.\n"));
                     return retVal;
@@ -1651,7 +1659,7 @@ static GT_STATUS getExStatus
             break;
 
         default:
-			return GT_NOT_SUPPORTED;
+            return GT_NOT_SUPPORTED;
     }
 
     /*
@@ -1671,8 +1679,8 @@ static GT_STATUS getExStatus
         return GT_OK;
     }
 
-	extendedStatus->isValid = GT_TRUE;
-	
+    extendedStatus->isValid = GT_TRUE;
+    
     /* get Pair Polarity */
     for(i=0; i<GT_MDI_PAIR_NUM; i++)
     {
@@ -1737,14 +1745,14 @@ static GT_STATUS getExStatus
 *
 * DESCRIPTION:
 *       This routine retrieves extended cable status, such as Pair Poloarity,
-*		Pair Swap, and Pair Skew. Note that this routine will be success only
-*		if 1000Base-T Link is up.
-*		Note: Since DSP based cable length in extended status is based on 
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        Note: Since DSP based cable length in extended status is based on 
 *             constants from test results. At present, only E1181, E1111, and
 *             E1112 are available.
 *
 * INPUTS:
-*       dev  - pointer to GT driver structure returned from mdLoadDriver
+*       dev  - pointer to GT driver structure returned from qdLoadDriver
 *       port - logical port number.
 *
 * OUTPUTS:
@@ -1755,9 +1763,9 @@ static GT_STATUS getExStatus
 *       GT_FAIL - on error
 *
 * COMMENTS:
-*		Supporting Device list:
-*       	88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys 
-*			in 88E6165 family and 88E6351 family devices
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys 
+*            in 88E6165 family and 88E6351 family devices
 *
 *******************************************************************************/
 GT_STATUS gvctGetAdvExtendedStatus
@@ -1767,62 +1775,67 @@ GT_STATUS gvctGetAdvExtendedStatus
     OUT GT_ADV_EXTENDED_STATUS *extendedStatus
 )
 {
-	GT_STATUS retVal;
-	GT_U8 hwPort;
-	GT_BOOL ppuEn;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
+    GT_STATUS retVal;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gvctGetAdvExtendedStatus_mad(dev, port, extendedStatus);
+#endif
 
     DBG_INFO(("gvctGetAdvExtendedStatus Called.\n"));
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports VCT */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Need to disable PPUEn for safe. */
-	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
-	{
-		ppuEn = GT_FALSE;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if((retVal = gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to disable PPUEn.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-		gtDelay(250);
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((retVal = gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
 
     switch(phyInfo.exStatusType)
     {
@@ -1847,9 +1860,9 @@ GT_STATUS gvctGetAdvExtendedStatus
 
             break;
         default:
-			retVal = GT_NOT_SUPPORTED;
+            retVal = GT_NOT_SUPPORTED;
     }
 
-	return retVal;
+    return retVal;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct_mad.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct_mad.c
new file mode 100755
index 0000000..8243ec4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtAdvVct_mad.c
@@ -0,0 +1,228 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtAdvVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+
+#include <madApi.h>
+
+/*******************************************************************************
+* gvctGetAdvCableStatus_mad
+*
+* DESCRIPTION:
+*       This routine perform the advanced virtual cable test for the requested
+*       port and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*       mode - advance VCT mode (either First Peak or Maximum Peak)
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are supporting this API.
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    IN  GT_ADV_VCT_MODE mode,
+    OUT GT_ADV_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_BOOL ppuEn;
+    GT_U8 hwPort;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_ADV_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+        
+
+    if ( mdDiagGetAdvCableStatus(&(dev->mad_dev),port,*((MAD_ADV_VCT_MODE *)&mode),(MAD_ADV_CABLE_STATUS*)cableStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGetAdvCableStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;    
+}
+
+
+/*******************************************************************************
+* gvctGetAdvExtendedStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves extended cable status, such as Pair Poloarity,
+*        Pair Swap, and Pair Skew. Note that this routine will be success only
+*        if 1000Base-T Link is up.
+*        Note: Since DSP based cable length in extended status is based on 
+*             constants from test results. At present, only E1181, E1111, and
+*             E1112 are available.
+*
+* INPUTS:
+*       dev  - pointer to GT driver structure returned from qdLoadDriver
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - the extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*        Supporting Device list:
+*           88E1111, 88E1112, 88E1141~6, 88E1149, and Internal Gigabit Phys 
+*            in 88E6165 family and 88E6351 family devices
+*
+*******************************************************************************/
+GT_STATUS gvctGetAdvExtendedStatus_mad
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT   port,
+    OUT GT_ADV_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS retVal=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetAdvExtendedStatus_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((retVal = gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGet1000BTExtendedStatus(&(dev->mad_dev),port,(MAD_1000BT_EXTENDED_STATUS*)extendedStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGet1000BTExtendedStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+           DBG_INFO(("Not able to enable PPUEn.\n"));
+           return GT_FALSE;
+        }
+    }
+
+    return retVal;
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c
old mode 100644
new mode 100755
index 234ec9c..b93d72d
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgFdb.c
@@ -17,6 +17,9 @@
 #include <gtHwCntl.h>
 #include <gtDrvSwRegs.h>
 
+#ifdef __KERNELL__
+extern void printk(char* format, ...);
+#endif
 
 /****************************************************************************/
 /* Forward function declaration.                                            */
@@ -25,31 +28,31 @@ static GT_STATUS atuOperationPerform
 (
     IN      GT_QD_DEV           *dev,
     IN      GT_ATU_OPERATION    atuOp,
-	INOUT	GT_EXTRA_OP_DATA	*opData,
-    INOUT 	GT_ATU_ENTRY    	*atuEntry
+    INOUT    GT_EXTRA_OP_DATA    *opData,
+    INOUT     GT_ATU_ENTRY        *atuEntry
 );
 
 static GT_STATUS atuStateAppToDev
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL		unicast,
-	IN  GT_U32		state,
-	OUT GT_U32		*newOne
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
 );
 
 static GT_STATUS atuStateDevToApp
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL		unicast,
-	IN  GT_U32		state,
-	OUT GT_U32		*newOne
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
 );
 
 static GT_STATUS atuGetStats
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_ATU_STAT	*atuStat,
-	OUT GT_U32		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_ATU_STAT    *atuStat,
+    OUT GT_U32        *count
 );
 
 
@@ -58,33 +61,33 @@ static GT_STATUS atuGetStats
 *
 * DESCRIPTION:
 *       Port's auto learning limit. When the limit is non-zero value, the number
-*		of MAC addresses that can be learned on this port are limited to the value
-*		specified in this API. When the learn limit has been reached any frame 
-*		that ingresses this port with a source MAC address not already in the 
-*		address database that is associated with this port will be discarded. 
-*		Normal auto-learning will resume on the port as soon as the number of 
-*		active unicast MAC addresses associated to this port is less than the 
-*		learn limit.
-*		CPU directed ATU Load, Purge, or Move will not have any effect on the 
-*		learn limit.
-*		This feature is disabled when the limit is zero.
-*		The following care is needed when enabling this feature:
-*			1) dsable learning on the ports
-*			2) flush all non-static addresses in the ATU
-*			3) define the desired limit for the ports
-*			4) re-enable learing on the ports
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame 
+*        that ingresses this port with a source MAC address not already in the 
+*        address database that is associated with this port will be discarded. 
+*        Normal auto-learning will resume on the port as soon as the number of 
+*        active unicast MAC addresses associated to this port is less than the 
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the 
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
 *
 * INPUTS:
 *       port  - logical port number
 *       limit - auto learning limit ( 0 ~ 255 )
-*											  
+*                                              
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
+*        GT_BAD_PARAM - if limit > 0xFF
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -95,49 +98,49 @@ static GT_STATUS atuGetStats
 *******************************************************************************/
 GT_STATUS gfdbSetPortAtuLearnLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT  	port,
-	IN  GT_U32   	limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       limit
 )
 {
-	GT_U16          data, mask;
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data, mask;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gfdbSetPortAtuLearnLimit Called.\n"));
+    DBG_INFO(("gfdbSetPortAtuLearnLimit Called.\n"));
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check device if it has fixed ATU Size. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    /* Check device if it has fixed ATU Size. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (limit > 0xFF)
-	{
-		DBG_INFO(("Bad Parameter\n"));
-		return GT_BAD_PARAM;
-	}
+    if (limit > 0xFF)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
 
-	mask = 0x80FF;
+    mask = 0x80FF;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
-		mask |= 0x1000;
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
+        mask |= 0x1000;
 
-	data = (GT_U16) limit;
+    data = (GT_U16) limit;
 
-	/* Set the learn limit bits.                  */
-	retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Set the learn limit bits.                  */
+    retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -146,33 +149,33 @@ GT_STATUS gfdbSetPortAtuLearnLimit
 *
 * DESCRIPTION:
 *      Port's auto learning limit. When the limit is non-zero value, the number
-*		of MAC addresses that can be learned on this port are limited to the value
-*		specified in this API. When the learn limit has been reached any frame 
-*		that ingresses this port with a source MAC address not already in the 
-*		address database that is associated with this port will be discarded. 
-*		Normal auto-learning will resume on the port as soon as the number of 
-*		active unicast MAC addresses associated to this port is less than the 
-*		learn limit.
-*		CPU directed ATU Load, Purge, or Move will not have any effect on the 
-*		learn limit.
-*		This feature is disabled when the limit is zero.
-*		The following care is needed when enabling this feature:
-*			1) dsable learning on the ports
-*			2) flush all non-static addresses in the ATU
-*			3) define the desired limit for the ports
-*			4) re-enable learing on the ports
+*        of MAC addresses that can be learned on this port are limited to the value
+*        specified in this API. When the learn limit has been reached any frame 
+*        that ingresses this port with a source MAC address not already in the 
+*        address database that is associated with this port will be discarded. 
+*        Normal auto-learning will resume on the port as soon as the number of 
+*        active unicast MAC addresses associated to this port is less than the 
+*        learn limit.
+*        CPU directed ATU Load, Purge, or Move will not have any effect on the 
+*        learn limit.
+*        This feature is disabled when the limit is zero.
+*        The following care is needed when enabling this feature:
+*            1) dsable learning on the ports
+*            2) flush all non-static addresses in the ATU
+*            3) define the desired limit for the ports
+*            4) re-enable learing on the ports
 *
 * INPUTS:
-*		port  - logical port number
-*											  
+*        port  - logical port number
+*                                              
 * OUTPUTS:
-*		limit - auto learning limit ( 0 ~ 255 )
+*        limit - auto learning limit ( 0 ~ 255 )
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -180,49 +183,49 @@ GT_STATUS gfdbSetPortAtuLearnLimit
 *******************************************************************************/
 GT_STATUS gfdbGetPortAtuLearnLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT  	port,
-	OUT GT_U32   	*limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    OUT GT_U32       *limit
 )
 {
-	GT_U16          data, mask;
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gfdbGetPortAtuLearnLimit Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Check device if it has fixed ATU Size. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
-	{
-		return GT_NOT_SUPPORTED;
-	}
-
-	mask = 0x9000;
-	data = (GT_U16) 0x1000;
-
-	/* Set the learn limit bits.                  */
-	retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-
-	/* Get the ReadLearnLimit bit. */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 0, 8, &data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-
-	*limit = (GT_U32)data;
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    GT_U16          data, mask;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gfdbGetPortAtuLearnLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Check device if it has fixed ATU Size. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT_READ))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    mask = 0x9000;
+    data = (GT_U16) 0x1000;
+
+    /* Set the learn limit bits.                  */
+    retVal = hwSetPortRegBits(dev,hwPort, QD_REG_PORT_ATU_CONTROL, mask, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    /* Get the ReadLearnLimit bit. */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 0, 8, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    *limit = (GT_U32)data;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -232,12 +235,12 @@ GT_STATUS gfdbGetPortAtuLearnLimit
 *
 * DESCRIPTION:
 *       Read the current number of active unicast MAC addresses associated with 
-*		the given port. This counter (LearnCnt) is held at zero if learn limit
-*		(gfdbSetPortAtuLearnLimit API) is set to zero.
+*        the given port. This counter (LearnCnt) is held at zero if learn limit
+*        (gfdbSetPortAtuLearnLimit API) is set to zero.
 *
 * INPUTS:
 *       port  - logical port number
-*											  
+*                                              
 * OUTPUTS:
 *       count - current auto learning count
 *
@@ -254,9 +257,9 @@ GT_STATUS gfdbGetPortAtuLearnLimit
 *******************************************************************************/
 GT_STATUS gfdbGetPortAtuLearnCnt
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT  	port,
-    IN  GT_U32   	*count
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_U32       *count
 )
 {
     GT_U16          data;
@@ -268,10 +271,10 @@ GT_STATUS gfdbGetPortAtuLearnCnt
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check device if this feature is supported. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    /* Check device if this feature is supported. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
     {
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the ReadLearnCnt bit. */
@@ -282,16 +285,16 @@ GT_STATUS gfdbGetPortAtuLearnCnt
         return retVal;
     }
 
-	if(data == 0)
-	{
-	    /* Set the ReadLearnCnt bit. */
-    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 15, 1, 1);
-	    if(retVal != GT_OK)
-    	{
-        	DBG_INFO(("Failed.\n"));
-	        return retVal;
-    	}
-	}
+    if(data == 0)
+    {
+        /* Set the ReadLearnCnt bit. */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 15, 1, 1);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
 
     /* Get the LearnCnt bits. */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 0, 8, &data);
@@ -301,7 +304,7 @@ GT_STATUS gfdbGetPortAtuLearnCnt
         return retVal;
     }
 
-	*count = (GT_U32)data;
+    *count = (GT_U32)data;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -331,67 +334,67 @@ GT_STATUS gfdbGetPortAtuLearnCnt
 *******************************************************************************/
 GT_STATUS gfdbGetAtuAllCount
 (
-    IN  GT_QD_DEV 	*dev,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *count
 )
 {
     GT_U32          dbNum, maxDbNum, numOfEntries;
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_ATU_STAT		atuStat;
+    GT_ATU_STAT        atuStat;
 
     DBG_INFO(("gfdbGetAtuAllCount Called.\n"));
 
-	if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
-	{
-		atuStat.op = GT_ATU_STATS_ALL;
-		return atuGetStats(dev,&atuStat,count);
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_ALL;
+        return atuGetStats(dev,&atuStat,count);
+    }
 
     numOfEntries = 0;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
-		maxDbNum = 16;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-		maxDbNum = 64;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-		maxDbNum = 256;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
-		maxDbNum = 4096;
-	else
-		maxDbNum = 1;
-
-	for(dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-		entry.DBNum = (GT_U16)dbNum;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-		    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
-		else
-    		gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
-
-	    while(1)
-    	{
-	        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
-        	if(retVal != GT_OK)
-	        {
-    	        DBG_INFO(("Failed.\n"));
-        	    return retVal;
-	        }
-
-    	    if(IS_BROADCAST_MAC(entry.macAddr))
-			{
-				if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-					break;
-				else if(entry.entryState.ucEntryState == 0)
-					break;
-	        	numOfEntries++;
-				break;
-			}
-
-        	numOfEntries++;
-	    }
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+        maxDbNum = 16;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        maxDbNum = 64;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        maxDbNum = 256;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+        maxDbNum = 4096;
+    else
+        maxDbNum = 1;
+
+    for(dbNum=0; dbNum<maxDbNum; dbNum++)
+    {
+        entry.DBNum = (GT_U16)dbNum;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+            gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+        else
+            gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+        while(1)
+        {
+            retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+
+            if(IS_BROADCAST_MAC(entry.macAddr))
+            {
+                if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+                    break;
+                else if(entry.entryState.ucEntryState == 0)
+                    break;
+                numOfEntries++;
+                break;
+            }
+
+            numOfEntries++;
+        }
+    }
 
     *count = numOfEntries;
     DBG_INFO(("OK.\n"));
@@ -422,55 +425,55 @@ GT_STATUS gfdbGetAtuAllCount
 *******************************************************************************/
 GT_STATUS gfdbGetAtuAllCountInDBNum
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_U32 		dbNum,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
 )
 {
     GT_U32          numOfEntries;
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_ATU_STAT		atuStat;
+    GT_ATU_STAT        atuStat;
 
     DBG_INFO(("gfdbGetAtuAllCountInDBNum Called.\n"));
 
-	if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
-	{
-		atuStat.op = GT_ATU_STATS_ALL_FID;
-		atuStat.DBNum = dbNum;
-		return atuGetStats(dev,&atuStat,count);
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_ALL_FID;
+        atuStat.DBNum = dbNum;
+        return atuGetStats(dev,&atuStat,count);
+    }
 
     numOfEntries = 0;
-	
-	entry.DBNum = (GT_U16)dbNum;
+    
+    entry.DBNum = (GT_U16)dbNum;
 
-	if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-	    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
-	else
-    	gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
 
-	while(1)
+    while(1)
     {
-	    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
-    	if(retVal != GT_OK)
-	    {
+        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+        if(retVal != GT_OK)
+        {
             DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
+            return retVal;
+        }
 
         if(IS_BROADCAST_MAC(entry.macAddr))
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-				break;
-			else if(entry.entryState.ucEntryState == 0)
-				break;
-	    	numOfEntries++;
-			break;
-		}
-
-    	numOfEntries++;
-	}
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+                break;
+            else if(entry.entryState.ucEntryState == 0)
+                break;
+            numOfEntries++;
+            break;
+        }
+
+        numOfEntries++;
+    }
 
     *count = numOfEntries;
     DBG_INFO(("OK.\n"));
@@ -501,60 +504,60 @@ GT_STATUS gfdbGetAtuAllCountInDBNum
 *******************************************************************************/
 GT_STATUS gfdbGetAtuDynamicCountInDBNum
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_U32 		dbNum,
-    OUT GT_U32 		*count
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32         dbNum,
+    OUT GT_U32         *count
 )
 {
     GT_U32          numOfEntries, tmpState;
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_ATU_UC_STATE	state;
-	GT_ATU_STAT		atuStat;
+    GT_ATU_UC_STATE    state;
+    GT_ATU_STAT        atuStat;
 
     DBG_INFO(("gfdbGetAtuDynamicCountInDBNum Called.\n"));
 
-	if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
-	{
-		atuStat.op = GT_ATU_STATS_NON_STATIC_FID;
-		atuStat.DBNum = dbNum;
-		return atuGetStats(dev,&atuStat,count);
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_NON_STATIC_FID;
+        atuStat.DBNum = dbNum;
+        return atuGetStats(dev,&atuStat,count);
+    }
 
     numOfEntries = 0;
-	
-	entry.DBNum = (GT_U16)dbNum;
+    
+    entry.DBNum = (GT_U16)dbNum;
 
-	if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-	    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
-	else
-    	gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
 
-	while(1)
+    while(1)
     {
-	    retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
         if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
+        {
+            DBG_INFO(("Failed.\n"));
             return retVal;
-	    }
+        }
 
-    	if(IS_BROADCAST_MAC(entry.macAddr))
+        if(IS_BROADCAST_MAC(entry.macAddr))
             break;
 
-	    if(IS_MULTICAST_MAC(entry.macAddr))
-	    {
-	        continue;
-    	}
-
-		atuStateDevToApp(dev,GT_TRUE,entry.entryState.ucEntryState,&tmpState);
-		state = (GT_ATU_UC_STATE)tmpState;
-		if (state == GT_UC_DYNAMIC)
-		{
-	    	numOfEntries++;
-		}
-	}
-	
+        if(IS_MULTICAST_MAC(entry.macAddr))
+        {
+            continue;
+        }
+
+        atuStateDevToApp(dev,GT_TRUE,entry.entryState.ucEntryState,&tmpState);
+        state = (GT_ATU_UC_STATE)tmpState;
+        if (state == GT_UC_DYNAMIC)
+        {
+            numOfEntries++;
+        }
+    }
+    
     *count = numOfEntries;
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -595,37 +598,37 @@ GT_STATUS gfdbSetAtuSize
 
     DBG_INFO(("gfdbSetAtuSize Called.\n"));
 
-	switch(size)
-	{
-		case ATU_SIZE_256:
-			if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
-				data = 0;
-			else
-				return GT_NOT_SUPPORTED;
-			break;
-    	case ATU_SIZE_512:
-    	case ATU_SIZE_1024:
-    	case ATU_SIZE_2048:
-			if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
-				data = (GT_U16)size;
-			else
-				data = (GT_U16)size - 1;
-			break;
-
-    	case ATU_SIZE_4096:
-			if ((IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))||(IS_IN_DEV_GROUP(dev,DEV_ATU_562_2048)))
-				return GT_NOT_SUPPORTED;
-			else
-				data = 3;
-			break;
-		default:
-			return GT_NOT_SUPPORTED;
-	}
-	
-	/* Check device if it has fixed ATU Size. */
-	if (IS_IN_DEV_GROUP(dev,DEV_ATU_SIZE_FIXED))
-    {
-		return GT_NOT_SUPPORTED;
+    switch(size)
+    {
+        case ATU_SIZE_256:
+            if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+                data = 0;
+            else
+                return GT_NOT_SUPPORTED;
+            break;
+        case ATU_SIZE_512:
+        case ATU_SIZE_1024:
+        case ATU_SIZE_2048:
+            if (IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))
+                data = (GT_U16)size;
+            else
+                data = (GT_U16)size - 1;
+            break;
+
+        case ATU_SIZE_4096:
+            if ((IS_IN_DEV_GROUP(dev,DEV_ATU_256_2048))||(IS_IN_DEV_GROUP(dev,DEV_ATU_562_2048)))
+                return GT_NOT_SUPPORTED;
+            else
+                data = 3;
+            break;
+        default:
+            return GT_NOT_SUPPORTED;
+    }
+    
+    /* Check device if it has fixed ATU Size. */
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_SIZE_FIXED))
+    {
+        return GT_NOT_SUPPORTED;
     }
 
     /* Set the Software reset bit.                  */
@@ -637,6 +640,27 @@ GT_STATUS gfdbSetAtuSize
     }
 
     /* Make sure the reset operation is completed.  */
+#ifdef GT_RMGMT_ACCESS 
+    /*    if (IS_IN_DEV_GROUP(dev,DEV_RMGMT)) */
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_1;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_GLOBAL_STATUS;
+      regAccess.rw_reg_list[0].data = 11;
+
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
     data = 0;
     while(data == 0)
     {
@@ -647,6 +671,8 @@ GT_STATUS gfdbSetAtuSize
             return retVal;
         }
     }
+    }
+#endif
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -691,16 +717,16 @@ GT_STATUS gfdbGetAgingTimeRange
         return GT_BAD_PARAM;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
-	{
-		*minTimeout = 15;
-		*maxTimeout = 3825;
-	}
-	else
-	{
-		*minTimeout = 16;
-		*maxTimeout = 4080;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+    {
+        *minTimeout = 15;
+        *maxTimeout = 3825;
+    }
+    else
+    {
+        *minTimeout = 16;
+        *maxTimeout = 4080;
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -712,8 +738,8 @@ GT_STATUS gfdbGetAgingTimeRange
 * DESCRIPTION:
 *       Gets the timeout period in seconds for aging out dynamically learned
 *       forwarding information. The returned value may not be the same as the value
-*		programmed with <gfdbSetAgingTimeout>. Please refer to the description of
-*		<gfdbSetAgingTimeout>.
+*        programmed with <gfdbSetAgingTimeout>. Please refer to the description of
+*        <gfdbSetAgingTimeout>.
 *
 * INPUTS:
 *       None.
@@ -739,14 +765,14 @@ GT_STATUS gfdbGetAgingTimeout
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-	GT_U16			timeBase;
+    GT_U16            timeBase;
 
     DBG_INFO(("gfdbGetAgingTimeout Called.\n"));
  
-	if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
-		timeBase = 15;
-	else
-		timeBase = 16;
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+        timeBase = 15;
+    else
+        timeBase = 16;
 
     /* Get the Time Out value.              */
     retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,&data);
@@ -756,7 +782,7 @@ GT_STATUS gfdbGetAgingTimeout
         return retVal;
     }
 
-	*timeout = data*timeBase;
+    *timeout = data*timeBase;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -769,14 +795,14 @@ GT_STATUS gfdbGetAgingTimeout
 * DESCRIPTION:
 *       Sets the timeout period in seconds for aging out dynamically learned
 *       forwarding information. The standard recommends 300 sec.
-*		Supported aging timeout values are multiple of time-base, where time-base
-*		is either 15 or 16 seconds, depending on the Switch device. For example,
-*		88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
-*		48,..., and 4080. If unsupported timeout value (bigger than 16) is used, 
-*		the value will be rounded to the nearest supported value smaller than the 
-*		given timeout. If the given timeout is less than 16, minimum timeout value
-*		16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
-*		<gfdbGetAgingTimeRange> function can be used to find the time-base.
+*        Supported aging timeout values are multiple of time-base, where time-base
+*        is either 15 or 16 seconds, depending on the Switch device. For example,
+*        88E6063 uses time-base 16, and so supported aging timeouts are 0,16,32,
+*        48,..., and 4080. If unsupported timeout value (bigger than 16) is used, 
+*        the value will be rounded to the nearest supported value smaller than the 
+*        given timeout. If the given timeout is less than 16, minimum timeout value
+*        16 will be used instead. E.g.) 35 becomes 32 and 5 becomes 16.
+*        <gfdbGetAgingTimeRange> function can be used to find the time-base.
 *
 * INPUTS:
 *       timeout - aging time in seconds.
@@ -802,25 +828,25 @@ GT_STATUS gfdbSetAgingTimeout
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-	GT_U16			timeBase;
+    GT_U16            timeBase;
 
     DBG_INFO(("gfdbSetAgingTimeout Called.\n"));
  
-	if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
-		timeBase = 15;
-	else
-		timeBase = 16;
-
-	if((timeout < timeBase) && (timeout != 0))
-	{	
- 	   data = 1;
-	}
-	else
-	{
- 	   data = (GT_U16)(timeout/timeBase);
-	   if (data & 0xFF00)
-			data = 0xFF;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_ATU_15SEC_AGING))
+        timeBase = 15;
+    else
+        timeBase = 16;
+
+    if((timeout < timeBase) && (timeout != 0))
+    {    
+        data = 1;
+    }
+    else
+    {
+        data = (GT_U16)(timeout/timeBase);
+       if (data & 0xFF00)
+            data = 0xFF;
+    }
 
     /* Set the Time Out value.              */
     retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,4,8,data);
@@ -839,82 +865,84 @@ GT_STATUS gfdbSetAgingTimeout
 * gfdbGetLearn2All
 *
 * DESCRIPTION:
-*		When more than one Marvell device is used to form a single 'switch', it
-*		may be desirable for all devices in the 'switch' to learn any address this 
-*		device learns. When this bit is set to a one all other devices in the 
-*		'switch' learn the same addresses this device learns. When this bit is 
-*		cleared to a zero, only the devices that actually receive frames will learn
-*		from those frames. This mode typically supports more active MAC addresses 
-*		at one time as each device in the switch does not need to learn addresses 
-*		it may nerver use.
+*        When more than one Marvell device is used to form a single 'switch', it
+*        may be desirable for all devices in the 'switch' to learn any address this 
+*        device learns. When this bit is set to a one all other devices in the 
+*        'switch' learn the same addresses this device learns. When this bit is 
+*        cleared to a zero, only the devices that actually receive frames will learn
+*        from those frames. This mode typically supports more active MAC addresses 
+*        at one time as each device in the switch does not need to learn addresses 
+*        it may nerver use.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
+*        mode  - GT_TRUE if Learn2All is enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *
 *******************************************************************************/
 GT_STATUS gfdbGetLearn2All
 (
-	IN  GT_QD_DEV    *dev,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* to keep the read valve       */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* to keep the read valve       */
 
-	DBG_INFO(("gprtGetLearn2All Called.\n"));
+    DBG_INFO(("gprtGetLearn2All Called.\n"));
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if ((!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* Get the Learn2All. */
-	retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, &data);
+    /* Get the Learn2All. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, &data);
 
-	BIT_2_BOOL(data, *mode);
+    BIT_2_BOOL(data, *mode);
 
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*******************************************************************************
 * gfdbSetLearn2All
 *
 * DESCRIPTION:
-*		Enable or disable Learn2All mode.
+*        Enable or disable Learn2All mode.
 *
 * INPUTS:
-*		mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
+*        mode - GT_TRUE to set Learn2All, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -923,37 +951,39 @@ GT_STATUS gfdbGetLearn2All
 *******************************************************************************/
 GT_STATUS gfdbSetLearn2All
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           /* Used to poll the SWReset bit */
-	GT_STATUS       retVal;         /* Functions return value.      */
-
-	DBG_INFO(("gprtSetLearn2All Called.\n"));
-
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set Learn2All. */
-	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetLearn2All Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if ((!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set Learn2All. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 3, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -961,150 +991,150 @@ GT_STATUS gfdbSetLearn2All
 * gfdbGetMacAvb
 *
 * DESCRIPTION:
-*		ATU MAC entry in AVB mode.
-*		When enabled, ATU entries operate in AVB mode:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
 *
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
-*			GT_UC_STATIC_AVB_ENTRY
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
+*            GT_UC_STATIC_AVB_ENTRY
 *
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_AVB_ENTRY, and
-*			GT_MC_PRIO_STATIC_AVB_ENTRY
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
 *
-*		When disabled, ATU entries operate in non-AVB mode:
+*        When disabled, ATU entries operate in non-AVB mode:
 *
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_NRL, and 
-*			GT_UC_STATIC_NRL
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and 
+*            GT_UC_STATIC_NRL
 *
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_UNLIMITED_RATE, and
-*			GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
+*        mode  - GT_TRUE if MacAvb is enabled, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *
 *******************************************************************************/
 GT_STATUS gfdbGetMacAvb
 (
-	IN  GT_QD_DEV    *dev,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* to keep the read valve       */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* to keep the read valve       */
 
-	DBG_INFO(("gfdbGetMacAvb Called.\n"));
+    DBG_INFO(("gfdbGetMacAvb Called.\n"));
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* Get the bit. */
-	retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, &data);
+    /* Get the bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, &data);
 
-	BIT_2_BOOL(data, *mode);
+    BIT_2_BOOL(data, *mode);
 
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*******************************************************************************
 * gfdbSetMacAvb
 *
 * DESCRIPTION:
-*		ATU MAC entry in AVB mode.
-*		When enabled, ATU entries operate in AVB mode:
+*        ATU MAC entry in AVB mode.
+*        When enabled, ATU entries operate in AVB mode:
 *
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
-*			GT_UC_STATIC_AVB_ENTRY
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_AVB_ENTRY, and 
+*            GT_UC_STATIC_AVB_ENTRY
 *
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_AVB_ENTRY, and
-*			GT_MC_PRIO_STATIC_AVB_ENTRY
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_AVB_ENTRY, and
+*            GT_MC_PRIO_STATIC_AVB_ENTRY
 *
-*		When disabled, ATU entries operate in non-AVB mode:
+*        When disabled, ATU entries operate in non-AVB mode:
 *
-*		GT_ATU_UC_STATE - support
-*			GT_UC_NO_PRI_STATIC_NRL, and 
-*			GT_UC_STATIC_NRL
+*        GT_ATU_UC_STATE - support
+*            GT_UC_NO_PRI_STATIC_NRL, and 
+*            GT_UC_STATIC_NRL
 *
-*		GT_ATU_MC_STATE - support
-*			GT_MC_STATIC_UNLIMITED_RATE, and
-*			GT_MC_PRIO_STATIC_UNLIMITED_RATE
+*        GT_ATU_MC_STATE - support
+*            GT_MC_STATIC_UNLIMITED_RATE, and
+*            GT_MC_PRIO_STATIC_UNLIMITED_RATE
 *
 * INPUTS:
-*		mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
+*        mode - GT_TRUE to enable MacAvb, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gfdbSetMacAvb
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           /* Used to poll the SWReset bit */
-	GT_STATUS       retVal;         /* Functions return value.      */
-
-	DBG_INFO(("gprtSetMacAvb Called.\n"));
-
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the bit */
-	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           /* Used to poll the SWReset bit */
+    GT_STATUS       retVal;         /* Functions return value.      */
+
+    DBG_INFO(("gprtSetMacAvb Called.\n"));
+
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MAC_AVB))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the bit */
+    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL, 15, 1, data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -1134,71 +1164,71 @@ GT_STATUS gfdbSetMacAvb
 *******************************************************************************/
 GT_STATUS gfdbGetAtuDynamicCount
 (
-    IN  GT_QD_DEV 	*dev,
-    OUT GT_U32 		*numDynEntries
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32         *numDynEntries
 )
 {
     GT_U32          dbNum, maxDbNum, numOfEntries, tmpState;
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_ATU_UC_STATE	state;
-	GT_ATU_STAT		atuStat;
+    GT_ATU_UC_STATE    state;
+    GT_ATU_STAT        atuStat;
 
     DBG_INFO(("gfdbGetAtuDynamicCount Called.\n"));
 
-	if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
-	{
-		atuStat.op = GT_ATU_STATS_NON_STATIC;
-		return atuGetStats(dev,&atuStat,numDynEntries);
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_STATS))
+    {
+        atuStat.op = GT_ATU_STATS_NON_STATIC;
+        return atuGetStats(dev,&atuStat,numDynEntries);
+    }
 
     numOfEntries = 0;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
-		maxDbNum = 16;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-		maxDbNum = 64;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-		maxDbNum = 256;
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
-		maxDbNum = 4096;
-	else
-		maxDbNum = 1;
-
-	for(dbNum=0; dbNum<maxDbNum; dbNum++)
-	{
-		entry.DBNum = (GT_U16)dbNum;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-		    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
-		else
-    		gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
-
-	    while(1)
-    	{
-	        retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
-        	if(retVal != GT_OK)
-	        {
-    	        DBG_INFO(("Failed.\n"));
-        	    return retVal;
-	        }
-
-    	    if(IS_BROADCAST_MAC(entry.macAddr))
-        	    break;
-
-	        if(IS_MULTICAST_MAC(entry.macAddr))
-	        {
-	            continue;
-    	    }
-
-			atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,&tmpState);
-			state = (GT_ATU_UC_STATE)tmpState;
-			if (state == GT_UC_DYNAMIC)
-			{
-	        	numOfEntries++;
-			}
-	    }
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL))
+        maxDbNum = 16;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        maxDbNum = 64;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        maxDbNum = 256;
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+        maxDbNum = 4096;
+    else
+        maxDbNum = 1;
+
+    for(dbNum=0; dbNum<maxDbNum; dbNum++)
+    {
+        entry.DBNum = (GT_U16)dbNum;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+            gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+        else
+            gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+
+        while(1)
+        {
+            retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+
+            if(IS_BROADCAST_MAC(entry.macAddr))
+                break;
+
+            if(IS_MULTICAST_MAC(entry.macAddr))
+            {
+                continue;
+            }
+
+            atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,&tmpState);
+            state = (GT_ATU_UC_STATE)tmpState;
+            if (state == GT_UC_DYNAMIC)
+            {
+                numOfEntries++;
+            }
+        }
+    }
 
     *numDynEntries = numOfEntries;
     DBG_INFO(("OK.\n"));
@@ -1226,11 +1256,11 @@ GT_STATUS gfdbGetAtuDynamicCount
 * COMMENTS:
 *       Search starts from Mac[00:00:00:00:00:00]
 *
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbGetAtuEntryFirst
@@ -1244,12 +1274,12 @@ GT_STATUS gfdbGetAtuEntryFirst
 
     DBG_INFO(("gfdbGetAtuEntryFirst Called.\n"));
 
-	if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-	    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
-	else
-    	gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
+    if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+    else
+        gtMemSet(entry.macAddr.arEther,0xFF,sizeof(GT_ETHERADDR));
 
-	entry.DBNum = atuEntry->DBNum;
+    entry.DBNum = atuEntry->DBNum;
 
     DBG_INFO(("DBNum : %i\n",entry.DBNum));
 
@@ -1262,25 +1292,25 @@ GT_STATUS gfdbGetAtuEntryFirst
 
     if(IS_BROADCAST_MAC(entry.macAddr))
     {
-		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-		{
-	        DBG_INFO(("Failed (Invalid Mac).\n"));
-    	    return GT_NO_SUCH;
-		}
-		else if(entry.entryState.ucEntryState == 0)
-		{
-	        DBG_INFO(("Failed (Invalid Mac).\n"));
-    	    return GT_NO_SUCH;
-		}
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
     }
 
     gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
     atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
     atuEntry->prio      = entry.prio;
     atuEntry->trunkMember = entry.trunkMember;
-	atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
-	atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
-	atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
 
     if(IS_MULTICAST_MAC(entry.macAddr))
     {
@@ -1290,13 +1320,13 @@ GT_STATUS gfdbGetAtuEntryFirst
             return GT_FAIL;
         }
 
-		atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.mcEntryState);
+        atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.mcEntryState);
     }
     else
     {
-		atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.ucEntryState);
+        atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.ucEntryState);
     }
 
     DBG_INFO(("OK.\n"));
@@ -1326,11 +1356,11 @@ GT_STATUS gfdbGetAtuEntryFirst
 *       Search starts from atu.macAddr[xx:xx:xx:xx:xx:xx] specified by the
 *       user.
 *
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbGetAtuEntryNext
@@ -1346,12 +1376,12 @@ GT_STATUS gfdbGetAtuEntryNext
 
     if(IS_BROADCAST_MAC(atuEntry->macAddr))
     {
-   	    return GT_NO_SUCH;
+           return GT_NO_SUCH;
     }
 
     gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
 
-	entry.DBNum = atuEntry->DBNum;
+    entry.DBNum = atuEntry->DBNum;
     DBG_INFO(("DBNum : %i\n",entry.DBNum));
 
     retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
@@ -1363,25 +1393,25 @@ GT_STATUS gfdbGetAtuEntryNext
 
     if(IS_BROADCAST_MAC(entry.macAddr))
     {
-		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-		{
-	        DBG_INFO(("Failed (Invalid Mac).\n"));
-    	    return GT_NO_SUCH;
-		}
-		else if(entry.entryState.ucEntryState == 0)
-		{
-	        DBG_INFO(("Failed (Invalid Mac).\n"));
-    	    return GT_NO_SUCH;
-		}
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
     }
 
     gtMemCpy(atuEntry->macAddr.arEther,entry.macAddr.arEther,6);
     atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
     atuEntry->prio      = entry.prio;
     atuEntry->trunkMember = entry.trunkMember;
-	atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
-	atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
-	atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
 
     if(IS_MULTICAST_MAC(entry.macAddr))
     {
@@ -1391,13 +1421,13 @@ GT_STATUS gfdbGetAtuEntryNext
             return GT_FAIL;
         }
 
-		atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.mcEntryState);
+        atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.mcEntryState);
     }
     else
     {
-		atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.ucEntryState);
+        atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.ucEntryState);
     }
 
     DBG_INFO(("OK.\n"));
@@ -1426,11 +1456,11 @@ GT_STATUS gfdbGetAtuEntryNext
 *       GT_BAD_PARAM    - on bad parameter
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbFindAtuMacEntry
@@ -1447,8 +1477,7 @@ GT_STATUS gfdbFindAtuMacEntry
     DBG_INFO(("gfdbFindAtuMacEntry Called.\n"));
     *found = GT_FALSE;
     gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
-	entry.DBNum = atuEntry->DBNum;
-
+    entry.DBNum = atuEntry->DBNum;
     /* Decrement 1 from mac address.    */
     for(i=5; i >= 0; i--)
     {
@@ -1457,7 +1486,7 @@ GT_STATUS gfdbFindAtuMacEntry
             entry.macAddr.arEther[i] -= 1;
             break;
         }
-		else
+        else
             entry.macAddr.arEther[i] = 0xFF;
     }
 
@@ -1477,30 +1506,45 @@ GT_STATUS gfdbFindAtuMacEntry
 
     if(IS_BROADCAST_MAC(entry.macAddr))
     {
-		if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
-		{
-	        DBG_INFO(("Failed (Broadcast addr is not valid).\n"));
-    	    return GT_NO_SUCH;
-		}
-		else if(entry.entryState.ucEntryState == 0)
-		{
-	        DBG_INFO(("Failed (Invalid Mac).\n"));
-    	    return GT_NO_SUCH;
-		}
+        if(IS_IN_DEV_GROUP(dev,DEV_BROADCAST_INVALID))
+        {
+            DBG_INFO(("Failed (Broadcast addr is not valid).\n"));
+            return GT_NO_SUCH;
+        }
+        else if(entry.entryState.ucEntryState == 0)
+        {
+            DBG_INFO(("Failed (Invalid Mac).\n"));
+            return GT_NO_SUCH;
+        }
     }
-
-	if(gtMemCmp((char*)atuEntry->macAddr.arEther,(char*)entry.macAddr.arEther,ETHERNET_HEADER_SIZE))
-	{
+    if(gtMemCmp((char*)atuEntry->macAddr.arEther,(char*)entry.macAddr.arEther,ETHERNET_HEADER_SIZE))
+    {
+#ifdef __KERNELL__
+printk("@@@@@@@@@@@@@  error gfdbFindAtuMacEntry:check: %02x:%02x:%02x:%02x:%02x:%02x get: %02x:%02x:%02x:%02x:%02x:%02x\n",
+    atuEntry->macAddr.arEther[0], 
+    atuEntry->macAddr.arEther[1], 
+    atuEntry->macAddr.arEther[2], 
+    atuEntry->macAddr.arEther[3], 
+    atuEntry->macAddr.arEther[4], 
+    atuEntry->macAddr.arEther[5], 
+    entry.macAddr.arEther[0],
+    entry.macAddr.arEther[1],
+    entry.macAddr.arEther[2],
+    entry.macAddr.arEther[3],
+    entry.macAddr.arEther[4],
+    entry.macAddr.arEther[5]
+);
+#endif
         DBG_INFO(("Failed.\n"));
         return GT_NO_SUCH;
-	}
+    }
 
     atuEntry->portVec   = GT_PORTVEC_2_LPORTVEC(entry.portVec);
     atuEntry->prio      = entry.prio;
     atuEntry->trunkMember = entry.trunkMember;
-	atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
-	atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
-	atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
+    atuEntry->exPrio.useMacFPri = entry.exPrio.useMacFPri;
+    atuEntry->exPrio.macFPri = entry.exPrio.macFPri;
+    atuEntry->exPrio.macQPri = entry.exPrio.macQPri;
 
     if(IS_MULTICAST_MAC(entry.macAddr))
     {
@@ -1510,13 +1554,13 @@ GT_STATUS gfdbFindAtuMacEntry
             return GT_FAIL;
         }
 
-		atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.mcEntryState);
+        atuStateDevToApp(dev,GT_FALSE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.mcEntryState);
     }
     else
     {
-		atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
-						(GT_U32*)&atuEntry->entryState.ucEntryState);
+        atuStateDevToApp(dev,GT_TRUE,(GT_U32)entry.entryState.ucEntryState,
+                        (GT_U32*)&atuEntry->entryState.ucEntryState);
     }
 
     *found = GT_TRUE;
@@ -1560,14 +1604,14 @@ GT_STATUS gfdbFlush
 
     DBG_INFO(("gfdbFlush Called.\n"));
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	entry.DBNum = 0;
-	entry.entryState.ucEntryState = 0;
+    entry.DBNum = 0;
+    entry.entryState.ucEntryState = 0;
 
     if(flushCmd == GT_FLUSH_ALL)
         retVal = atuOperationPerform(dev,FLUSH_ALL,NULL,&entry);
@@ -1591,11 +1635,11 @@ GT_STATUS gfdbFlush
 * DESCRIPTION:
 *       This routine flush all or unblocked addresses from the particular
 *       ATU Database (DBNum). If multiple address databases are being used, this
-*		API can be used to flush entries in a particular DBNum database.
+*        API can be used to flush entries in a particular DBNum database.
 *
 * INPUTS:
 *       flushCmd - the flush operation type.
-*		DBNum	 - ATU MAC Address Database Number. 
+*        DBNum     - ATU MAC Address Database Number. 
 *
 * OUTPUTS:
 *       None
@@ -1614,7 +1658,7 @@ GT_STATUS gfdbFlushInDB
 (
     IN GT_QD_DEV    *dev,
     IN GT_FLUSH_CMD flushCmd,
-	IN GT_U32 DBNum
+    IN GT_U32 DBNum
 )
 {
     GT_STATUS       retVal;
@@ -1624,17 +1668,17 @@ GT_STATUS gfdbFlushInDB
     DBG_INFO(("gfdbFush: dev=%x, dev->atuRegsSem=%d \n",dev, dev->atuRegsSem));
 
     /* check if device supports this feature */
-	if ((!IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL)) && 
-		(!IS_IN_DEV_GROUP(dev,DEV_DBNUM_64)) && 
-		(!IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096)) && 
-		(!IS_IN_DEV_GROUP(dev,DEV_DBNUM_256)))
-	{
+    if ((!IS_IN_DEV_GROUP(dev,DEV_DBNUM_FULL)) && 
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_64)) && 
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096)) && 
+        (!IS_IN_DEV_GROUP(dev,DEV_DBNUM_256)))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+        return GT_NOT_SUPPORTED;
+    }
 
-	entry.DBNum = (GT_U16)DBNum;
-	entry.entryState.ucEntryState = 0;
+    entry.DBNum = (GT_U16)DBNum;
+    entry.entryState.ucEntryState = 0;
 
     if(flushCmd == GT_FLUSH_ALL)
         retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,NULL,&entry);
@@ -1659,9 +1703,9 @@ GT_STATUS gfdbFlushInDB
 *       This routine moves all or unblocked addresses from a port to another.
 *
 * INPUTS:
-* 		moveCmd  - the move operation type.
-*		moveFrom - port where moving from
-*		moveTo   - port where moving to
+*         moveCmd  - the move operation type.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
 *
 * OUTPUTS:
 *       None
@@ -1678,35 +1722,35 @@ GT_STATUS gfdbFlushInDB
 *******************************************************************************/
 GT_STATUS gfdbMove
 (
-	IN GT_QD_DEV    *dev,
-	IN GT_MOVE_CMD  moveCmd,
-	IN GT_LPORT		moveFrom,
-	IN GT_LPORT		moveTo
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD  moveCmd,
+    IN GT_LPORT        moveFrom,
+    IN GT_LPORT        moveTo
 )
 {
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_EXTRA_OP_DATA	opData;
+    GT_EXTRA_OP_DATA    opData;
 
     DBG_INFO(("gfdbMove Called.\n"));
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	entry.DBNum = 0;
-	entry.entryState.ucEntryState = 0xF;
-	if (moveTo == 0xF)
-		opData.moveTo = moveTo;
-	else
-		opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
-	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+    entry.DBNum = 0;
+    entry.entryState.ucEntryState = 0xF;
+    if (moveTo == 0xF)
+        opData.moveTo = moveTo;
+    else
+        opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+    opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
 
-	if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
-		return GT_BAD_PARAM;
+    if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
+        return GT_BAD_PARAM;
 
     if(moveCmd == GT_MOVE_ALL)
         retVal = atuOperationPerform(dev,FLUSH_ALL,&opData,&entry);
@@ -1733,9 +1777,9 @@ GT_STATUS gfdbMove
 *
 * INPUTS:
 *       moveCmd  - the move operation type.
-*		DBNum	 - ATU MAC Address Database Number.
-*		moveFrom - port where moving from
-*		moveTo   - port where moving to
+*        DBNum     - ATU MAC Address Database Number.
+*        moveFrom - port where moving from
+*        moveTo   - port where moving to
 *
 * OUTPUTS:
 *       None
@@ -1753,36 +1797,36 @@ GT_STATUS gfdbMove
 GT_STATUS gfdbMoveInDB
 (
     IN GT_QD_DEV    *dev,
-    IN GT_MOVE_CMD 	moveCmd,
-	IN GT_U32 		DBNum,
-	IN GT_LPORT		moveFrom,
-	IN GT_LPORT		moveTo
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_U32         DBNum,
+    IN GT_LPORT        moveFrom,
+    IN GT_LPORT        moveTo
 )
 {
     GT_STATUS       retVal;
     GT_ATU_ENTRY    entry;
-	GT_EXTRA_OP_DATA	opData;
+    GT_EXTRA_OP_DATA    opData;
 
     DBG_INFO(("gfdbMoveInDB Called.\n"));
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_802_1W))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	entry.DBNum = (GT_U16)DBNum;
-	entry.entryState.ucEntryState = 0xF;
+    entry.DBNum = (GT_U16)DBNum;
+    entry.entryState.ucEntryState = 0xF;
 
-	if (moveTo == 0xF)
-		opData.moveTo = moveTo;
-	else
-		opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
-	opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
+    if (moveTo == 0xF)
+        opData.moveTo = moveTo;
+    else
+        opData.moveTo = (GT_U32)GT_LPORT_2_PORT(moveTo);
+    opData.moveFrom = (GT_U32)GT_LPORT_2_PORT(moveFrom);
 
-	if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
-		return GT_BAD_PARAM;
+    if((opData.moveTo == 0xFF) || (opData.moveFrom == 0xFF))
+        return GT_BAD_PARAM;
 
     if(moveCmd == GT_MOVE_ALL)
         retVal = atuOperationPerform(dev,FLUSH_ALL_IN_DB,&opData,&entry);
@@ -1825,21 +1869,14 @@ GT_STATUS gfdbMoveInDB
 *******************************************************************************/
 GT_STATUS gfdbRemovePort
 (
-	IN GT_QD_DEV    *dev,
-    IN GT_MOVE_CMD 	moveCmd,
-    IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port
 )
 {
     DBG_INFO(("gfdbRemovePort Called.\n"));
 
-	/* Only 88E6093 Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_RM_PORTS))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	return gfdbMove(dev,moveCmd,port,(GT_LPORT)0xF);
+    return gfdbMove(dev,moveCmd,port,(GT_LPORT)0xF);
 }
 
 
@@ -1853,7 +1890,7 @@ GT_STATUS gfdbRemovePort
 * INPUTS:
 *       moveCmd  - the move operation type.
 *       port - the logical port number.
-*		DBNum	 - ATU MAC Address Database Number.
+*        DBNum     - ATU MAC Address Database Number.
 *
 * OUTPUTS:
 *       None
@@ -1870,21 +1907,15 @@ GT_STATUS gfdbRemovePort
 *******************************************************************************/
 GT_STATUS gfdbRemovePortInDB
 (
-	IN GT_QD_DEV    *dev,
-    IN GT_MOVE_CMD 	moveCmd,
-    IN GT_LPORT		port,
-	IN GT_U32 		DBNum
+    IN GT_QD_DEV    *dev,
+    IN GT_MOVE_CMD     moveCmd,
+    IN GT_LPORT        port,
+    IN GT_U32         DBNum
 )
 {
     DBG_INFO(("gfdbRemovePortInDB Called.\n"));
 
-	/* Only 88E6093 Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_RM_PORTS))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-	return gfdbMoveInDB(dev,moveCmd,DBNum,port,(GT_LPORT)0xF);
+    return gfdbMoveInDB(dev,moveCmd,DBNum,port,(GT_LPORT)0xF);
 }
 
 
@@ -1906,11 +1937,11 @@ GT_STATUS gfdbRemovePortInDB
 *       GT_BAD_PARAM   - on invalid port vector
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 * GalTis:
 *
@@ -1926,69 +1957,69 @@ GT_STATUS gfdbAddMacEntry
 
     DBG_INFO(("gfdbAddMacEntry Called.\n"));
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     gtMemCpy(entry.macAddr.arEther,macEntry->macAddr.arEther,6);
-	entry.DBNum		= macEntry->DBNum;
+    entry.DBNum        = macEntry->DBNum;
     entry.portVec     = GT_LPORTVEC_2_PORTVEC(macEntry->portVec);
-	if(entry.portVec == GT_INVALID_PORT_VEC)
-	{
-		return GT_BAD_PARAM;
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
-	{
-		if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
-		{
-			entry.exPrio.useMacFPri = macEntry->exPrio.useMacFPri;
-			entry.exPrio.macFPri = macEntry->exPrio.macFPri;
-			entry.exPrio.macQPri = macEntry->exPrio.macQPri;
-		}
-		else
-		{
-			entry.exPrio.useMacFPri = 0;
-			entry.exPrio.macFPri = 0;
-			entry.exPrio.macQPri = macEntry->exPrio.macQPri;
-		}
-    	entry.prio	    = 0;
-	}
-	else
-	{
-		entry.exPrio.useMacFPri = 0;
-		entry.exPrio.macFPri = 0;
-		entry.exPrio.macQPri = 0;
-    	entry.prio	    = macEntry->prio;
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
-	{
-	    entry.trunkMember = macEntry->trunkMember;
-	}
-	else
-	{
-	    entry.trunkMember = GT_FALSE;
-	}
+    if(entry.portVec == GT_INVALID_PORT_VEC)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
+        {
+            entry.exPrio.useMacFPri = macEntry->exPrio.useMacFPri;
+            entry.exPrio.macFPri = macEntry->exPrio.macFPri;
+            entry.exPrio.macQPri = macEntry->exPrio.macQPri;
+        }
+        else
+        {
+            entry.exPrio.useMacFPri = 0;
+            entry.exPrio.macFPri = macEntry->exPrio.macQPri;
+            entry.exPrio.macQPri = macEntry->exPrio.macQPri;
+        }
+        entry.prio        = 0;
+    }
+    else
+    {
+        entry.exPrio.useMacFPri = 0;
+        entry.exPrio.macFPri = 0;
+        entry.exPrio.macQPri = 0;
+        entry.prio        = macEntry->prio;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        entry.trunkMember = macEntry->trunkMember;
+    }
+    else
+    {
+        entry.trunkMember = GT_FALSE;
+    }
 
     if(IS_MULTICAST_MAC(entry.macAddr))
     {
-		atuStateAppToDev(dev,GT_FALSE,(GT_U32)macEntry->entryState.mcEntryState,
-							(GT_U32*)&entry.entryState.ucEntryState);
+        atuStateAppToDev(dev,GT_FALSE,(GT_U32)macEntry->entryState.mcEntryState,
+                            (GT_U32*)&entry.entryState.ucEntryState);
     }
     else
-	{
-		atuStateAppToDev(dev,GT_TRUE,(GT_U32)macEntry->entryState.ucEntryState,
-							(GT_U32*)&entry.entryState.ucEntryState);
-	}
+    {
+        atuStateAppToDev(dev,GT_TRUE,(GT_U32)macEntry->entryState.ucEntryState,
+                            (GT_U32*)&entry.entryState.ucEntryState);
+    }
 
-	if (entry.entryState.ucEntryState == 0)
-	{
+    if (entry.entryState.ucEntryState == 0)
+    {
         DBG_INFO(("Entry State should not be ZERO.\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
     if(retVal != GT_OK)
@@ -2006,7 +2037,7 @@ GT_STATUS gfdbAddMacEntry
 *
 * DESCRIPTION:
 *       Deletes MAC address entry. If DBNum or FID is used, gfdbDelAtuEntry API
-*		would be the better choice to delete an entry in ATU.
+*        would be the better choice to delete an entry in ATU.
 *
 * INPUTS:
 *       macAddress - mac address.
@@ -2034,21 +2065,21 @@ GT_STATUS gfdbDelMacEntry
 
     DBG_INFO(("gfdbDelMacEntry Called.\n"));
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     gtMemCpy(entry.macAddr.arEther,macAddress->arEther,6);
-	entry.DBNum = 0;
-	entry.prio = 0;
-	entry.portVec = 0;
-	entry.entryState.ucEntryState = 0;
-	entry.trunkMember = GT_FALSE;
-	entry.exPrio.useMacFPri = GT_FALSE;
-	entry.exPrio.macFPri = 0;
-	entry.exPrio.macQPri = 0;
+    entry.DBNum = 0;
+    entry.prio = 0;
+    entry.portVec = 0;
+    entry.entryState.ucEntryState = 0;
+    entry.trunkMember = GT_FALSE;
+    entry.exPrio.useMacFPri = GT_FALSE;
+    entry.exPrio.macFPri = 0;
+    entry.exPrio.macQPri = 0;
 
     retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
     if(retVal != GT_OK)
@@ -2080,11 +2111,11 @@ GT_STATUS gfdbDelMacEntry
 *       GT_NO_SUCH      - if specified address entry does not exist
 *
 * COMMENTS:
-*		DBNum in atuEntry - 
-*			ATU MAC Address Database number. If multiple address 
-*			databases are not being used, DBNum should be zero.
-*			If multiple address databases are being used, this value
-*			should be set to the desired address database number.
+*        DBNum in atuEntry - 
+*            ATU MAC Address Database number. If multiple address 
+*            databases are not being used, DBNum should be zero.
+*            If multiple address databases are being used, this value
+*            should be set to the desired address database number.
 *
 *******************************************************************************/
 GT_STATUS gfdbDelAtuEntry
@@ -2098,21 +2129,21 @@ GT_STATUS gfdbDelAtuEntry
 
     DBG_INFO(("gfdbDelMacEntry Called.\n"));
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
+    if (!IS_IN_DEV_GROUP(dev,DEV_STATIC_ADDR))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     gtMemCpy(entry.macAddr.arEther,atuEntry->macAddr.arEther,6);
-	entry.DBNum = atuEntry->DBNum;
-	entry.prio = 0;
-	entry.portVec = 0;
+    entry.DBNum = atuEntry->DBNum;
+    entry.prio = 0;
+    entry.portVec = 0;
     entry.entryState.ucEntryState = 0;
     entry.trunkMember = GT_FALSE;
-	entry.exPrio.useMacFPri = GT_FALSE;
-	entry.exPrio.macFPri = 0;
-	entry.exPrio.macQPri = 0;
+    entry.exPrio.useMacFPri = GT_FALSE;
+    entry.exPrio.macFPri = 0;
+    entry.exPrio.macQPri = 0;
 
     retVal = atuOperationPerform(dev,LOAD_PURGE_ENTRY,NULL,&entry);
     if(retVal != GT_OK)
@@ -2155,37 +2186,37 @@ GT_STATUS gfdbLearnEnable
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* Data to be set into the      */
                                     /* register.                    */
-	GT_LPORT	port;
-	GT_BOOL		mode;
+    GT_LPORT    port;
+    GT_BOOL        mode;
 
     DBG_INFO(("gfdbLearnEnable Called.\n"));
     BOOL_2_BIT(en,data);
     data = 1 - data;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		mode = (en)?GT_FALSE:GT_TRUE;
-
-		for (port=0; port<dev->numOfPorts; port++)
-		{
-			retVal = gprtSetLearnDisable(dev,port,mode);
-		    if(retVal != GT_OK)
-    		{
-	    	    DBG_INFO(("Failed.\n"));
-    	    	return retVal;
-		    }
-		}
-	}
-	else
-	{
-	    /* Set the Learn Enable bit.            */
-    	retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,data);
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}	
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        mode = (en)?GT_FALSE:GT_TRUE;
+
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            retVal = gprtSetLearnDisable(dev,port,mode);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                return retVal;
+            }
+        }
+    }
+    else
+    {
+        /* Set the Learn Enable bit.            */
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }    
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -2206,7 +2237,7 @@ GT_STATUS gfdbLearnEnable
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -2224,20 +2255,20 @@ GT_STATUS gfdbGetLearnEnable
                                     /* register.                    */
     DBG_INFO(("gfdbGetLearnEnable Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		return GT_NOT_SUPPORTED;
-	}
-	else
-	{
-	    /* Get the Learn Enable bit.            */
-    	retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,&data);
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}	
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+    else
+    {
+        /* Get the Learn Enable bit.            */
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,14,1,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }    
 
     data = 1 - data;
     BOOL_2_BIT(data, *en);
@@ -2268,7 +2299,7 @@ GT_STATUS gfdbGetLearnEnable
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -2280,27 +2311,29 @@ GT_STATUS gatuGetViolation
 )
 {
     GT_U16              intCause;
-    GT_STATUS       	retVal;
-    GT_ATU_ENTRY    	entry;
-	GT_EXTRA_OP_DATA	opData;
-	GT_BOOL				found, ageInt;
+    GT_STATUS           retVal;
+    GT_ATU_ENTRY        entry;
+    GT_EXTRA_OP_DATA    opData;
+    GT_BOOL                found, ageInt;
 
     DBG_INFO(("gatuGetViolation Called.\n"));
 
-	/* check which Violation occurred */
+    /* check which Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,3,1,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read ATU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read ATU OPERATION Register.\n"));
         return retVal;
     }
 
-	if (!intCause)
-	{
-		/* No Violation occurred. */
-		atuIntStatus->atuIntCause = 0;
-		return GT_OK;
-	}
+    if (!intCause)
+    {
+        /* No Violation occurred. */
+        atuIntStatus->atuIntCause = 0;
+        return GT_OK;
+    }
+
+    entry.DBNum = 0;
 
     retVal = atuOperationPerform(dev,SERVICE_VIOLATIONS,&opData,&entry);
     if(retVal != GT_OK)
@@ -2311,33 +2344,34 @@ GT_STATUS gatuGetViolation
 
     gtMemCpy(atuIntStatus->macAddr.arEther,entry.macAddr.arEther,6);
 
-	atuIntStatus->atuIntCause = (GT_U16)opData.intCause;
-	atuIntStatus->spid = entry.entryState.ucEntryState;
-
-	if(atuIntStatus->spid != 0xF)
-		atuIntStatus->spid = (GT_U8)GT_PORT_2_LPORT(atuIntStatus->spid);
-			
-	if (IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
-	{
-		if (opData.intCause == GT_AGE_VIOLATION)
-		{
-			atuIntStatus->atuIntCause = GT_AGE_OUT_VIOLATION;
-		}
-		else if (opData.intCause == GT_MISS_VIOLATION)
-		{
-			/* check if it's AGE Violation */
-			if((retVal = gsysGetAgeInt(dev, &ageInt)) != GT_OK)
-				return retVal;
-
-			if(ageInt)
-			{
-				gfdbFindAtuMacEntry(dev, &entry, &found);
-				if ((found) && (entry.entryState.ucEntryState <= 4))
-					atuIntStatus->atuIntCause = GT_AGE_VIOLATION;
-			}
-			
-		}
-	}
+    atuIntStatus->atuIntCause = (GT_U16)opData.intCause;
+    atuIntStatus->spid = entry.entryState.ucEntryState;
+    atuIntStatus->dbNum = qdShort2Char(entry.DBNum);
+
+    if(atuIntStatus->spid != 0xF)
+        atuIntStatus->spid = (GT_U8)GT_PORT_2_LPORT(atuIntStatus->spid);
+            
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    {
+        if (opData.intCause == GT_AGE_VIOLATION)
+        {
+            atuIntStatus->atuIntCause = GT_AGE_OUT_VIOLATION;
+        }
+        else if (opData.intCause == GT_MISS_VIOLATION)
+        {
+            /* check if it's AGE Violation */
+            if((retVal = gsysGetAgeInt(dev, &ageInt)) != GT_OK)
+                return retVal;
+
+            if(ageInt)
+            {
+                gfdbFindAtuMacEntry(dev, &entry, &found);
+                if ((found) && (entry.entryState.ucEntryState <= 4))
+                    atuIntStatus->atuIntCause = GT_AGE_VIOLATION;
+            }
+            
+        }
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -2378,8 +2412,8 @@ static GT_STATUS atuOperationPerform
 (
     IN      GT_QD_DEV           *dev,
     IN      GT_ATU_OPERATION    atuOp,
-	INOUT	GT_EXTRA_OP_DATA	*opData,
-    INOUT 	GT_ATU_ENTRY    	*entry
+    INOUT    GT_EXTRA_OP_DATA    *opData,
+    INOUT     GT_ATU_ENTRY        *entry
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2388,13 +2422,31 @@ static GT_STATUS atuOperationPerform
     GT_U16          opcodeData;           /* Data to be set into the      */
                                     /* register.                    */
     GT_U8           i;
-    GT_U16			portMask;
+    GT_U16            portMask;
 
     gtSemTake(dev,dev->atuRegsSem,OS_WAIT_FOREVER);
 
-	portMask = (1 << dev->maxPorts) - 1;
+    portMask = (1 << dev->maxPorts) - 1;
 
     /* Wait until the ATU in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -2405,121 +2457,158 @@ static GT_STATUS atuOperationPerform
             return retVal;
         }
     }
+#endif
+
+    opcodeData = 0;
 
-	opcodeData = 0;
-
-	switch (atuOp)
-	{
-		case LOAD_PURGE_ENTRY:
-				if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY) || 
-					IS_IN_DEV_GROUP(dev,DEV_TRUNK))
-				{
-					if (IS_IN_DEV_GROUP(dev,DEV_TRUNK) && entry->trunkMember)
-					{
-						/* portVec represents trunk ID */
-				        data = (GT_U16)( 0x8000 | (((entry->portVec) & 0xF) << 4) |
-        			         (((entry->entryState.ucEntryState) & 0xF)) );
-					}
-					else
-					{
-				        data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
-        			         (((entry->entryState.ucEntryState) & 0xF)) );
-					}
-					opcodeData |= (entry->prio & 0x7) << 8;
-				}
-				else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
-				{
-			        data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
-        			         (((entry->entryState.ucEntryState) & 0xF)) |
-        			         (((entry->exPrio.macQPri) & 0x3) << 14) );
-					if(entry->exPrio.useMacFPri == GT_TRUE)
-						data |= ((1 << 13) | ((entry->exPrio.macFPri & 0x7) << 10));
-				}
-				else
-				{
-			        data = (GT_U16)( (((entry->prio) & 0x3) << 14) | 
-			        		(((entry->portVec) & portMask) << 4) |
-        					(((entry->entryState.ucEntryState) & 0xF)) );
-				}
-		        retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
-        		if(retVal != GT_OK)
-		        {
-        		    gtSemGive(dev,dev->atuRegsSem);
-		            return retVal;
-        		}
-				/* pass thru */
-
-		case GET_NEXT_ENTRY:
-		        for(i = 0; i < 3; i++)
-        		{
-		            data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
-        		    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),data);
-		            if(retVal != GT_OK)
-        		    {
-		                gtSemGive(dev,dev->atuRegsSem);
-        		        return retVal;
-		            }
-        		}
-				break;
-
-		case FLUSH_ALL:
-		case FLUSH_UNLOCKED:
-		case FLUSH_ALL_IN_DB:
-		case FLUSH_UNLOCKED_IN_DB:
-				if (entry->entryState.ucEntryState == 0xF)
-				{
-			        data = (GT_U16)(0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8));
-				}
-				else
-				{
-			        data = 0;
-				}
-		        retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
-       			if(retVal != GT_OK)
-	        	{
-       		    	gtSemGive(dev,dev->atuRegsSem);
-		            return retVal;
-   	    		}
-				break;
-
-		case SERVICE_VIOLATIONS:
-
-				break;
-
-		default :
-				return GT_FAIL;
-	}
+    switch (atuOp)
+    {
+        case LOAD_PURGE_ENTRY:
+                if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY) &&
+                    (!((IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY))||
+                       (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY))))) ||
+                    IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+                {
+                    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK) && entry->trunkMember)
+                    {
+                        /* portVec represents trunk ID */
+                        data = (GT_U16)( 0x8000 | (((entry->portVec) & 0xF) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) );
+                    }
+                    else
+                    {
+                        data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) );
+                    }
+                    opcodeData |= (entry->prio & 0x7) << 8;
+                }
+                else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+                {
+                  if(IS_IN_DEV_GROUP(dev,DEV_MACPRI_IN_TABLE))
+				  {
+                    data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             ((entry->entryState.ucEntryState) & 0xF) );
+                    data |= ((entry->prio & 0x7) << 13);
+				  }
+				  else
+				  {
+                    data = (GT_U16)( (((entry->portVec) & portMask) << 4) |
+                             (((entry->entryState.ucEntryState) & 0xF)) |
+                             (((entry->exPrio.macQPri) & 0x3) << 14) );
+                    if(entry->exPrio.useMacFPri == GT_TRUE)
+                        data |= ((1 << 13) | ((entry->exPrio.macFPri & 0x7) << 10));
+				  }
+                }
+                else
+                {
+                    data = (GT_U16)( (((entry->prio) & 0x3) << 14) | 
+                            (((entry->portVec) & portMask) << 4) |
+                            (((entry->entryState.ucEntryState) & 0xF)) );
+                }
+                retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->atuRegsSem);
+                    return retVal;
+                }
+                /* pass thru */
+
+        case GET_NEXT_ENTRY:
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+  
+      for(i = 0; i < 3; i++)
+      {
+        data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+        regAccess.rw_reg_list[i].cmd = HW_REG_WRITE;
+        regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+        regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i;
+        regAccess.rw_reg_list[i].data = data;
+      }
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->atuRegsSem);
+        return retVal;
+      }
+    }
+#else
+                for(i = 0; i < 3; i++)
+                {
+                    data=(entry->macAddr.arEther[2*i] << 8)|(entry->macAddr.arEther[1 + 2*i]);
+                    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),data);
+                    if(retVal != GT_OK)
+                    {
+                        gtSemGive(dev,dev->atuRegsSem);
+                        return retVal;
+                    }
+                }
+#endif
+                break;
+
+        case FLUSH_ALL:
+        case FLUSH_UNLOCKED:
+        case FLUSH_ALL_IN_DB:
+        case FLUSH_UNLOCKED_IN_DB:
+                if (entry->entryState.ucEntryState == 0xF)
+                {
+                    data = (GT_U16)(0xF | ((opData->moveFrom & 0xF) << 4) | ((opData->moveTo & 0xF) << 8));
+                }
+                else
+                {
+                    data = 0;
+                }
+                retVal = hwWriteGlobalReg(dev,QD_REG_ATU_DATA_REG,data);
+                   if(retVal != GT_OK)
+                {
+                       gtSemGive(dev,dev->atuRegsSem);
+                    return retVal;
+                   }
+                break;
+
+        case SERVICE_VIOLATIONS:
+
+                break;
+
+        default :
+                return GT_FAIL;
+    }
 
     /* Set DBNum */
-	if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-	{
-	    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,(GT_U16)(entry->DBNum & 0xFFF));
-    	if(retVal != GT_OK)
-	    {
-    	    gtSemGive(dev,dev->atuRegsSem);
-        	return retVal;
-	    }
-	}
-	else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-	{
-	    retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,(GT_U16)((entry->DBNum & 0xF0) >> 4));
-    	if(retVal != GT_OK)
-	    {
-    	    gtSemGive(dev,dev->atuRegsSem);
-        	return retVal;
-	    }
-	}
-	else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-	{
-	    opcodeData |= ((entry->DBNum & 0x30) << 4);	/* Op Reg bit 9:8 */
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,(GT_U16)(entry->DBNum & 0xFFF));
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,(GT_U16)((entry->DBNum & 0xF0) >> 4));
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        opcodeData |= ((entry->DBNum & 0x30) << 4);    /* Op Reg bit 9:8 */
+    }
 
     /* Set the ATU Operation register in addtion to DBNum setup  */
 
-	if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-	    opcodeData |= ((1 << 15) | (atuOp << 12));
-	else
-	    opcodeData |= ((1 << 15) | (atuOp << 12) | (entry->DBNum & 0xF));
+    if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        opcodeData |= ((1 << 15) | (atuOp << 12));
+    else
+    {
+        opcodeData |= ((1 << 15) | (atuOp << 12) | (entry->DBNum & 0xF));
+    }
 
     retVal = hwWriteGlobalReg(dev,QD_REG_ATU_OPERATION,opcodeData);
     if(retVal != GT_OK)
@@ -2528,113 +2617,157 @@ static GT_STATUS atuOperationPerform
         return retVal;
     }
 
-	/* If the operation is to service violation operation wait for the response   */
-	if(atuOp == SERVICE_VIOLATIONS)
-	{
-		/* Wait until the VTU in ready. */
-		data = 1;
-		while(data == 1)
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->atuRegsSem);
-				return retVal;
-			}
-		}
-
-		/* get the Interrupt Cause */
-		retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,4,4,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->atuRegsSem);
-			return retVal;
-		}
-
-		if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
-		{
-			data &= 0x7;	/* only 3 bits are valid for non age_out_int group */
-		}
-
-		switch (data)
-		{
-			case 8:	/* Age Interrupt */
-				opData->intCause = GT_AGE_VIOLATION;
-				break;
-			case 4:	/* Member Violation */
-				opData->intCause = GT_MEMBER_VIOLATION;
-				break;
-			case 2:	/* Miss Violation */
-				opData->intCause = GT_MISS_VIOLATION;
-				break;
-			case 1:	/* Full Violation */
-				opData->intCause = GT_FULL_VIOLATION;
-				break;
-			default:
-				opData->intCause = 0;
-				gtSemGive(dev,dev->atuRegsSem);
-				return GT_OK;
-		}
-
-		/* get the DBNum that was involved in the violation */
-
-		entry->DBNum = 0;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-		{
-		    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,&data);
-    		if(retVal != GT_OK)
-	    	{
-	    	    gtSemGive(dev,dev->atuRegsSem);
-    	    	return retVal;
-	    	}
-			entry->DBNum = (GT_U16)data;
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-		{
-		    retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,&data);
-    		if(retVal != GT_OK)
-	    	{
-	    	    gtSemGive(dev,dev->atuRegsSem);
-    	    	return retVal;
-	    	}
-			entry->DBNum = (GT_U16)data << 4;
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,2,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->atuRegsSem);
-				return retVal;
-			}
-			entry->DBNum = (GT_U16)data << 4;
-		}
-
-		if(!IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,0,4,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->atuRegsSem);
-				return retVal;
-			}
-
-			entry->DBNum |= (GT_U8)(data & 0xF);
-		}
-
-		/* get the Source Port ID that was involved in the violation */
-
-		retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->atuRegsSem);
-			return retVal;
-		}
-
-		entry->entryState.ucEntryState = data & 0xF;
+    /* If the operation is to service violation operation wait for the response   */
+    if(atuOp == SERVICE_VIOLATIONS)
+    {
+        /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+  
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+          return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /* get the Interrupt Cause */
+        retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,4,4,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+        if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+        {
+            data &= 0x7;    /* only 3 bits are valid for non age_out_int group */
+        }
+    
+        switch (data)
+        {
+            case 8:    /* Age Interrupt */
+                opData->intCause = GT_AGE_VIOLATION;
+                break;
+            case 4:    /* Member Violation */
+                opData->intCause = GT_MEMBER_VIOLATION;
+                break;
+            case 2:    /* Miss Violation */
+                opData->intCause = GT_MISS_VIOLATION;
+                break;
+            case 1:    /* Full Violation */
+                opData->intCause = GT_FULL_VIOLATION;
+                break;
+            default:
+                opData->intCause = 0;
+                gtSemGive(dev,dev->atuRegsSem);
+                return GT_OK;
+        }
+
+        /* get the DBNum that was involved in the violation */
+
+        entry->DBNum = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_FID_REG,0,12,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data;
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_CONTROL,12,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data << 4;
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,2,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->DBNum = (GT_U16)data << 4;
+        }
+
+        if(!IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,0,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+
+            entry->DBNum |= (GT_U8)(data & 0xF);
+        }
+
+        /* get the Source Port ID that was involved in the violation */
+
+        retVal = hwReadGlobalReg(dev,QD_REG_ATU_DATA_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+        }
+
+        entry->entryState.ucEntryState = data & 0xF;
 
         /* Get the Mac address  */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 3;
+  
+          for(i = 0; i < 3; i++)
+          {
+            regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+            regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+            regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i;
+            regAccess.rw_reg_list[i].data = 0;
+          }
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+          }
+          for(i = 0; i < 3; i++)
+          {
+            entry->macAddr.arEther[2*i] = qdLong2Char(regAccess.rw_reg_list[i].data >> 8);
+            entry->macAddr.arEther[1 + 2*i] = qdLong2Char(regAccess.rw_reg_list[i].data & 0xFF);
+          }
+        }
+#else
         for(i = 0; i < 3; i++)
         {
             retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_ATU_MAC_BASE+i),&data);
@@ -2646,18 +2779,57 @@ static GT_STATUS atuOperationPerform
             entry->macAddr.arEther[2*i] = data >> 8;
             entry->macAddr.arEther[1 + 2*i] = data & 0xFF;
         }
+#endif
 
 
-	} /* end of service violations */
+    } /* end of service violations */
     /* If the operation is a gen next operation wait for the response   */
     if(atuOp == GET_NEXT_ENTRY)
     {
-		entry->trunkMember = GT_FALSE;
-		entry->exPrio.useMacFPri = GT_FALSE;
-		entry->exPrio.macFPri = 0;
+        entry->trunkMember = GT_FALSE;
+        entry->exPrio.useMacFPri = GT_FALSE;
+        entry->exPrio.macFPri = 0;
         entry->exPrio.macQPri = 0;
 
         /* Wait until the ATU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 5;
+  
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_ATU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+  
+          for(i = 1; i < 4; i++)
+          {
+            regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+            regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+            regAccess.rw_reg_list[i].reg = QD_REG_ATU_MAC_BASE+i-1;
+            regAccess.rw_reg_list[i].data = 0;
+          }
+
+          regAccess.rw_reg_list[4].cmd = HW_REG_READ;
+          regAccess.rw_reg_list[4].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[4].reg = QD_REG_ATU_DATA_REG;
+          regAccess.rw_reg_list[4].data = 0;
+
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->atuRegsSem);
+            return retVal;
+          }
+          for(i = 0; i < 3; i++)
+          {
+            entry->macAddr.arEther[2*i] = qdLong2Char(regAccess.rw_reg_list[i+1].data >> 8);
+            entry->macAddr.arEther[1 + 2*i] = qdLong2Char(regAccess.rw_reg_list[i+1].data & 0xFF);
+          }
+          data = qdLong2Short(regAccess.rw_reg_list[4].data);
+        }
+#else
         data = 1;
         while(data == 1)
         {
@@ -2688,40 +2860,57 @@ static GT_STATUS atuOperationPerform
             gtSemGive(dev,dev->atuRegsSem);
             return retVal;
         }
+#endif
 
         /* Get the Atu data register fields */
-		if(IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_TRUNK))
-		{
-			if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
-			{
-				entry->trunkMember = (data & 0x8000)?GT_TRUE:GT_FALSE;
-			}
-
-			entry->portVec = (data >> 4) & portMask;
-			entry->entryState.ucEntryState = data & 0xF;
-			retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,3,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->atuRegsSem);
-				return retVal;
-			}
-			entry->prio = (GT_U8)data;
-		}
-		else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
-		{
-	        entry->prio = 0;
-    	    entry->portVec = (data >> 4) & portMask;
-        	entry->entryState.ucEntryState = data & 0xF;
-			entry->exPrio.useMacFPri = (data & 0x2000)?GT_TRUE:GT_FALSE;
-			entry->exPrio.macFPri = (data >> 10) & 0x7;
-	        entry->exPrio.macQPri = data >> 14;
-		}
-		else
-		{
-	        entry->prio = data >> 14;
-    	    entry->portVec = (data >> 4) & portMask;
-        	entry->entryState.ucEntryState = data & 0xF;
-		}
+        if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY) &&
+            (!((IS_IN_DEV_GROUP(dev,DEV_88EC000_FAMILY))||
+               (IS_IN_DEV_GROUP(dev,DEV_88ESPANNAK_FAMILY))))) ||
+            IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+        {
+            if (IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+            {
+                entry->trunkMember = (data & 0x8000)?GT_TRUE:GT_FALSE;
+            }
+
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            retVal = hwGetGlobalRegField(dev,QD_REG_ATU_OPERATION,8,3,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->atuRegsSem);
+                return retVal;
+            }
+            entry->prio = (GT_U8)data;
+        }
+        else if(IS_IN_DEV_GROUP(dev,DEV_ATU_EXT_PRI))
+        {
+          if(IS_IN_DEV_GROUP(dev,DEV_MACPRI_IN_TABLE))
+		  {
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            entry->prio = (data >> 13) & 0x7;
+            entry->exPrio.macFPri = entry->prio;
+            entry->exPrio.macQPri = entry->prio; 
+            entry->prio = 0;
+            entry->exPrio.useMacFPri = GT_FALSE; /* doesn't care */
+		  }
+		  else
+		  {
+            entry->prio = 0;
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+            entry->exPrio.useMacFPri = (data & 0x2000)?GT_TRUE:GT_FALSE;
+            entry->exPrio.macFPri = (data >> 10) & 0x7;
+            entry->exPrio.macQPri = data >> 14;
+		  }
+        }
+        else
+        {
+            entry->prio = data >> 14;
+            entry->portVec = (data >> 4) & portMask;
+            entry->entryState.ucEntryState = data & 0xF;
+        }
     }
 
     gtSemGive(dev,dev->atuRegsSem);
@@ -2730,364 +2919,364 @@ static GT_STATUS atuOperationPerform
 
 static GT_STATUS atuStateAppToDev
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL		unicast,
-	IN  GT_U32		state,
-	OUT GT_U32		*newOne
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
 )
 {
-	GT_U32	newState;
-	GT_STATUS	retVal = GT_OK;
-
-	if(unicast)
-	{
-		switch ((GT_ATU_UC_STATE)state)
-		{
-			case GT_UC_INVALID:
-				newState = state;
-				break;
-
-			case GT_UC_DYNAMIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
-				{
-					newState = 7;
-				}
-				else
-				{
-					newState = 0xE;
-				}
-				break;
-
-			case GT_UC_NO_PRI_TO_CPU_STATIC_NRL:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC_NRL))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_TO_CPU_STATIC_NRL:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC_NRL))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_NO_PRI_STATIC_NRL:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC_NRL))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_STATIC_NRL:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC_NRL))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_NO_PRI_TO_CPU_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_TO_CPU_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_NO_PRI_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_UC_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_UC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			default:
-				if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
-				{
-					newState = 7;
-				}
-				else
-				{
-					newState = 0xE;
-				}
-				retVal = GT_BAD_PARAM;
-				break;
-
-		}
-	}
-	else
-	{
-		switch ((GT_ATU_UC_STATE)state)
-		{
-			case GT_MC_INVALID:
-				newState = state;
-				break;
-
-			case GT_MC_MGM_STATIC_UNLIMITED_RATE:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC_UNLIMITED_RATE))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_STATIC_UNLIMITED_RATE:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC_UNLIMITED_RATE))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_MGM_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_PRIO_STATIC_UNLIMITED_RATE:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC_UNLIMITED_RATE))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_PRIO_MGM_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			case GT_MC_PRIO_STATIC:
-				if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC))
-				{
-					newState = state;
-				}
-				else
-				{
-					newState = (GT_U32)GT_MC_STATIC;
-					retVal = GT_BAD_PARAM;
-				}
-				break;
-
-			default:
-				newState = (GT_U32)GT_MC_STATIC;
-				retVal = GT_BAD_PARAM;
-				break;
-
-		}
-	}
-	
-	*newOne = newState;
-	return retVal;
+    GT_U32    newState;
+    GT_STATUS    retVal = GT_OK;
+
+    if(unicast)
+    {
+        switch ((GT_ATU_UC_STATE)state)
+        {
+            case GT_UC_INVALID:
+                newState = state;
+                break;
+
+            case GT_UC_DYNAMIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
+                {
+                    newState = 7;
+                }
+                else
+                {
+                    newState = 0xE;
+                }
+                break;
+
+            case GT_UC_NO_PRI_TO_CPU_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_TO_CPU_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_STATIC_NRL:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC_NRL))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_TO_CPU_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_TO_CPU_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_TO_CPU_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_TO_CPU_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_NO_PRI_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_NO_PRI_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_UC_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_UC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            default:
+                if (IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC))
+                {
+                    newState = 7;
+                }
+                else
+                {
+                    newState = 0xE;
+                }
+                retVal = GT_BAD_PARAM;
+                break;
+
+        }
+    }
+    else
+    {
+        switch ((GT_ATU_UC_STATE)state)
+        {
+            case GT_MC_INVALID:
+                newState = state;
+                break;
+
+            case GT_MC_MGM_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_MGM_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_MGM_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_MGM_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_STATIC_UNLIMITED_RATE:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC_UNLIMITED_RATE))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_MGM_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_MGM_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            case GT_MC_PRIO_STATIC:
+                if (IS_IN_DEV_GROUP(dev,DEV_MC_PRIO_STATIC))
+                {
+                    newState = state;
+                }
+                else
+                {
+                    newState = (GT_U32)GT_MC_STATIC;
+                    retVal = GT_BAD_PARAM;
+                }
+                break;
+
+            default:
+                newState = (GT_U32)GT_MC_STATIC;
+                retVal = GT_BAD_PARAM;
+                break;
+
+        }
+    }
+    
+    *newOne = newState;
+    return retVal;
 }
 
 static GT_STATUS atuStateDevToApp
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL		unicast,
-	IN  GT_U32		state,
-	OUT GT_U32		*newOne
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        unicast,
+    IN  GT_U32        state,
+    OUT GT_U32        *newOne
 )
 {
-	GT_U32	newState;
-	GT_STATUS	retVal = GT_OK;
-
-	if(unicast)
-	{
-		if (state == 0)
-		{
-			newState = (GT_U32)GT_UC_INVALID;
-		}
-		else if (state <= 7)
-		{
-			newState = (GT_U32)GT_UC_DYNAMIC;
-		}
-		else if ((state <= 0xE) && (!IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC)))
-		{
-			newState = (GT_U32)GT_UC_DYNAMIC;
-		}
-		else
-		{
-			newState = state;
-		}
-	}
-	else
-	{
-		newState = state;
-	}
-
-	*newOne = newState;
-	return retVal;
+    GT_U32    newState;
+    GT_STATUS    retVal = GT_OK;
+
+    if(unicast)
+    {
+        if (state == 0)
+        {
+            newState = (GT_U32)GT_UC_INVALID;
+        }
+        else if (state <= 7)
+        {
+            newState = (GT_U32)GT_UC_DYNAMIC;
+        }
+        else if ((state <= 0xE) && (!IS_IN_DEV_GROUP(dev,DEV_UC_7_DYNAMIC)))
+        {
+            newState = (GT_U32)GT_UC_DYNAMIC;
+        }
+        else
+        {
+            newState = state;
+        }
+    }
+    else
+    {
+        newState = state;
+    }
+
+    *newOne = newState;
+    return retVal;
 }
 
 
 static GT_STATUS atuGetStats
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_ATU_STAT	*atuStat,
-	OUT GT_U32		*count
+    IN  GT_QD_DEV    *dev,
+    IN  GT_ATU_STAT    *atuStat,
+    OUT GT_U32        *count
 )
 {
     GT_U32          numOfEntries, dbNum;
     GT_ATU_ENTRY    entry;
-	GT_U16			data,mode,bin;
+    GT_U16            data,mode,bin;
     GT_STATUS       retVal;
 
     DBG_INFO(("atuGetStats Called.\n"));
 
-	switch (atuStat->op)
-	{
-		case GT_ATU_STATS_ALL:
-		case GT_ATU_STATS_NON_STATIC:
-			dbNum = 0;
-			break;
-		case GT_ATU_STATS_ALL_FID:
-		case GT_ATU_STATS_NON_STATIC_FID:
-			dbNum = atuStat->DBNum;
-			break;
-		default:
-			return GT_FALSE;
-	}
+    switch (atuStat->op)
+    {
+        case GT_ATU_STATS_ALL:
+        case GT_ATU_STATS_NON_STATIC:
+            dbNum = 0;
+            break;
+        case GT_ATU_STATS_ALL_FID:
+        case GT_ATU_STATS_NON_STATIC_FID:
+            dbNum = atuStat->DBNum;
+            break;
+        default:
+            return GT_FALSE;
+    }
 
     numOfEntries = 0;
-	mode = atuStat->op;
+    mode = atuStat->op;
 
-	for(bin=0; bin<4; bin++)
-	{	
-		data = (bin << 14) | (mode << 12);
+    for(bin=0; bin<4; bin++)
+    {    
+        data = (bin << 14) | (mode << 12);
 
-	    retVal = hwWriteGlobal2Reg(dev, QD_REG_ATU_STATS, data);
-       	if(retVal != GT_OK)
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_ATU_STATS, data);
+           if(retVal != GT_OK)
         {
-   	        DBG_INFO(("Failed.\n"));
-       	    return retVal;
+               DBG_INFO(("Failed.\n"));
+               return retVal;
         }
-		
-		entry.DBNum = (GT_U16)dbNum;
-	    gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
+        
+        entry.DBNum = (GT_U16)dbNum;
+        gtMemSet(entry.macAddr.arEther,0,sizeof(GT_ETHERADDR));
 
         retVal = atuOperationPerform(dev,GET_NEXT_ENTRY,NULL,&entry);
-       	if(retVal == GT_FAIL)
+           if(retVal == GT_FAIL)
         {
-   	        DBG_INFO(("Failed.\n"));
-       	    return retVal;
+               DBG_INFO(("Failed.\n"));
+               return retVal;
         }
 
-	    retVal = hwReadGlobal2Reg(dev, QD_REG_ATU_STATS, &data);
-       	if(retVal != GT_OK)
+        retVal = hwReadGlobal2Reg(dev, QD_REG_ATU_STATS, &data);
+           if(retVal != GT_OK)
         {
-   	        DBG_INFO(("Failed.\n"));
-       	    return retVal;
+               DBG_INFO(("Failed.\n"));
+               return retVal;
         }
-		
-		numOfEntries += (data & 0xFFF);
-	}
+        
+        numOfEntries += (data & 0xFFF);
+    }
 
-	*count = numOfEntries;
+    *count = numOfEntries;
 
-	return GT_OK;
+    return GT_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStp.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStp.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStu.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgStu.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c
old mode 100644
new mode 100755
index 64a886f..bb35d61
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVlan.c
@@ -58,7 +58,7 @@ GT_STATUS gprtSetEgressMode
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_TAGGING)) != GT_OK ) 
       return retVal;
-	
+    
     switch (mode)
     {
         case (GT_UNMODIFY_EGRESS):
@@ -74,11 +74,11 @@ GT_STATUS gprtSetEgressMode
             break;
 
         case (GT_ADD_TAG):
-			if(!IS_IN_DEV_GROUP(dev,DEV_EGRESS_DOUBLE_TAGGING))
-			{
-		        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-				return GT_NOT_SUPPORTED;
-			}
+            if(!IS_IN_DEV_GROUP(dev,DEV_EGRESS_DOUBLE_TAGGING))
+            {
+                DBG_INFO(("GT_NOT_SUPPORTED\n"));
+                return GT_NOT_SUPPORTED;
+            }
             data = 3;
             break;
         default:
@@ -329,7 +329,7 @@ GT_STATUS gvlnSetPortVlanPorts
     phyPort = GT_LPORT_2_PORT(port);
     data = 0;
 
-	if(memPortsLen > dev->numOfPorts)
+    if(memPortsLen > dev->numOfPorts)
     {
         DBG_INFO(("Failed (PortsLen Too Big).\n"));
         return GT_BAD_PARAM;
@@ -408,8 +408,8 @@ GT_STATUS gvlnGetPortVlanPorts
     i = 0;
     for(phyPort = 0; phyPort < dev->maxPorts; phyPort++)
     {
-		if(!GT_IS_PORT_SET(dev->validPortVec, phyPort))
-			continue;
+        if(!GT_IS_PORT_SET(dev->validPortVec, phyPort))
+            continue;
 
         if(((1 << phyPort) & data) != 0)
         {
@@ -462,11 +462,13 @@ GT_STATUS gvlnSetPortUserPriLsb
 
     DBG_INFO(("gvlnSetPortUserPriLsb Called.\n"));
 
-	/* Gigabit Switch does not support this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Gigabit Switch does not support this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     phyPort = GT_LPORT_2_PORT(port);
@@ -519,11 +521,13 @@ GT_STATUS gvlnGetPortUserPriLsb
 
     DBG_INFO(("gvlnGetPortUserPriLsb Called.\n"));
 
-	/* Gigabit Switch does not support this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Gigabit Switch does not support this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     if(userPriLsb == NULL)
@@ -654,11 +658,11 @@ GT_STATUS gvlnGetPortVid
 *
 * DESCRIPTION:
 *       This routine sets the port's default VLAN database number (DBNum or 
-*		FID, Forwarding Information Database).
+*        FID, Forwarding Information Database).
 *
 * INPUTS:
-*       port	- logical port number to set.
-*       DBNum 	- database number for this port (or FID)
+*       port    - logical port number to set.
+*       DBNum     - database number for this port (or FID)
 *
 * OUTPUTS:
 *       None.
@@ -688,41 +692,41 @@ GT_STATUS gvlnSetPortVlanDBNum
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
-	{
-		if(DBNum > 4095)
-		{
-			return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8,(GT_U16)((DBNum & 0xFF0) >> 4));
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x000F));
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-	{
-		if(DBNum > 255)
-		{
-			return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4,(GT_U16)((DBNum & 0xF0) >> 4));
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-	{
-		if(DBNum > 63)
-		{
-			return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2,(GT_U16)((DBNum & 0x30) >> 4));
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
-	}
-	else
-	{
-		if(DBNum > 15)
-		{
-			return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+    {
+        if(DBNum > 4095)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8,(GT_U16)((DBNum & 0xFF0) >> 4));
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x000F));
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        if(DBNum > 255)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4,(GT_U16)((DBNum & 0xF0) >> 4));
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        if(DBNum > 63)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2,(GT_U16)((DBNum & 0x30) >> 4));
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+    }
+    else
+    {
+        if(DBNum > 15)
+        {
+            return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4,(GT_U16)(DBNum & 0x0F));
+    }
 
     if(retVal != GT_OK)
     {
@@ -740,13 +744,13 @@ GT_STATUS gvlnSetPortVlanDBNum
 *
 * DESCRIPTION:
 *       This routine gets the port's default VLAN database number (DBNum or
-*		FID, Forwarding Information Database).
+*        FID, Forwarding Information Database).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       DBNum 	- database number for this port (or FID)
+*       DBNum     - database number for this port (or FID)
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -777,26 +781,26 @@ GT_STATUS gvlnGetPortVlanDBNum
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8, &dataH);
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4, &dataH);
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
-	}
-	else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2, &dataH);
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
-	}
-	else
-	{
-		dataH = 0;
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_4096))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,8, &dataH);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL1,0,4, &dataH);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+    else if(IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,6,2, &dataH);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
+    else
+    {
+        dataH = 0;
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,12,4, &data);
+    }
 
     if(retVal != GT_OK)
     {
@@ -816,8 +820,8 @@ GT_STATUS gvlnGetPortVlanDBNum
 *       This routine sets the IEEE 802.1q mode for this port (11:10) 
 *
 * INPUTS:
-*       port	- logical port number to set.
-*       mode 	- 802.1q mode for this port 
+*       port    - logical port number to set.
+*       mode     - 802.1q mode for this port 
 *
 * OUTPUTS:
 *       None.
@@ -835,8 +839,8 @@ GT_STATUS gvlnGetPortVlanDBNum
 GT_STATUS gvlnSetPortVlanDot1qMode
 (
     IN GT_QD_DEV        *dev,
-    IN GT_LPORT 	port,
-    IN GT_DOT1Q_MODE	mode
+    IN GT_LPORT     port,
+    IN GT_DOT1Q_MODE    mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -850,14 +854,16 @@ GT_STATUS gvlnSetPortVlanDot1qMode
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_802_1Q)) != GT_OK ) 
       return retVal;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2,(GT_U16)mode );
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2,(GT_U16)mode );
-	}
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2,(GT_U16)mode );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2,(GT_U16)mode );
+    }
 
     if(retVal != GT_OK)
     {
@@ -875,10 +881,10 @@ GT_STATUS gvlnSetPortVlanDot1qMode
 *       This routine gets the IEEE 802.1q mode for this (bit 11:10).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       mode 	- 802.1q mode for this port 
+*       mode     - 802.1q mode for this port 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -913,14 +919,16 @@ GT_STATUS gvlnGetPortVlanDot1qMode
         return GT_BAD_PARAM;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2, &data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2, &data);
-	}
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_CONTROL2,10,2, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_PORT_VLAN_MAP,10,2, &data);
+    }
 
     if(retVal != GT_OK)
     {
@@ -961,8 +969,8 @@ GT_STATUS gvlnGetPortVlanDot1qMode
 GT_STATUS gvlnSetPortVlanForceDefaultVID
 (
     IN GT_QD_DEV        *dev,
-    IN GT_LPORT 	port,
-    IN GT_BOOL  	mode
+    IN GT_LPORT     port,
+    IN GT_BOOL      mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -998,10 +1006,10 @@ GT_STATUS gvlnSetPortVlanForceDefaultVID
 *       This routine gets the port mode for ForceDefaultVID (bit 12).
 *
 * INPUTS:
-*       port 	- logical port number to get.
+*       port     - logical port number to get.
 *
 * OUTPUTS:
-*       mode 	- ForceDefaultVID mode for this port 
+*       mode     - ForceDefaultVID mode for this port 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1016,8 +1024,8 @@ GT_STATUS gvlnSetPortVlanForceDefaultVID
 GT_STATUS gvlnGetPortVlanForceDefaultVID
 (
     IN GT_QD_DEV        *dev,
-    IN  GT_LPORT 	port,
-    OUT GT_BOOL    	*mode
+    IN  GT_LPORT     port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1057,9 +1065,9 @@ GT_STATUS gvlnGetPortVlanForceDefaultVID
 *
 * DESCRIPTION:
 *       This routine enables/disables Force Map feature.
-*		When Force Map feature is enabled, all received frames will be
-*		considered MGMT and they are mapped to the port or ports defined
-*		in the VLAN Table overriding the mapping from the address database.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
 *
 * INPUTS:
 *       port    - logical port number to set.
@@ -1080,8 +1088,8 @@ GT_STATUS gvlnGetPortVlanForceDefaultVID
 GT_STATUS gvlnSetForceMap
 (
     IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT 	port,
-    IN  GT_BOOL  	mode
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1093,10 +1101,10 @@ GT_STATUS gvlnSetForceMap
     phyPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     BOOL_2_BIT(mode,data);
 
@@ -1118,9 +1126,9 @@ GT_STATUS gvlnSetForceMap
 *
 * DESCRIPTION:
 *       This routine checks if Force Map feature is enabled.
-*		When Force Map feature is enabled, all received frames will be
-*		considered MGMT and they are mapped to the port or ports defined
-*		in the VLAN Table overriding the mapping from the address database.
+*        When Force Map feature is enabled, all received frames will be
+*        considered MGMT and they are mapped to the port or ports defined
+*        in the VLAN Table overriding the mapping from the address database.
 *
 * INPUTS:
 *       port    - logical port number to set.
@@ -1140,8 +1148,8 @@ GT_STATUS gvlnSetForceMap
 GT_STATUS gvlnGetForceMap
 (
     IN  GT_QD_DEV   *dev,
-    IN  GT_LPORT 	port,
-    OUT GT_BOOL  	*mode
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1153,10 +1161,10 @@ GT_STATUS gvlnGetForceMap
     phyPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_FORCE_MAP))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     retVal = hwGetPortRegField(dev,phyPort, QD_REG_PORT_VLAN_MAP, 8, 1, &data);
     if(retVal != GT_OK)
@@ -1177,31 +1185,31 @@ GT_STATUS gvlnGetForceMap
 * gvlnSetNoEgrPolicy
 *
 * DESCRIPTION:
-*		No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
-*		Check discards are not performed. This mode allowsa non-802.1Q enabled 
-*		port to send a frame to an 802.1Q enabled port that is configured in the
-*		Secure or Check 802.1Q mode. In this situation the frames will egress 
-*		even if the VID assigned to the frame is not found in the VTU.
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled 
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress 
+*        even if the VID assigned to the frame is not found in the VTU.
 *
 * INPUTS:
-*		mode - no egress policy mode
+*        mode - no egress policy mode
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gvlnSetNoEgrPolicy
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1209,11 +1217,11 @@ GT_STATUS gvlnSetNoEgrPolicy
 
     DBG_INFO(("gvlnSetNoEgrPolicy Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(mode,data);
@@ -1234,31 +1242,31 @@ GT_STATUS gvlnSetNoEgrPolicy
 * gvlnGetNoEgrPolicy
 *
 * DESCRIPTION:
-*		No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
-*		Check discards are not performed. This mode allowsa non-802.1Q enabled 
-*		port to send a frame to an 802.1Q enabled port that is configured in the
-*		Secure or Check 802.1Q mode. In this situation the frames will egress 
-*		even if the VID assigned to the frame is not found in the VTU.
+*        No Egress Policy. When this bit is set to a one Egress 802.1Q Secure and
+*        Check discards are not performed. This mode allowsa non-802.1Q enabled 
+*        port to send a frame to an 802.1Q enabled port that is configured in the
+*        Secure or Check 802.1Q mode. In this situation the frames will egress 
+*        even if the VID assigned to the frame is not found in the VTU.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode - no egress policy mode
+*        mode - no egress policy mode
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gvlnGetNoEgrPolicy
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1266,11 +1274,11 @@ GT_STATUS gvlnGetNoEgrPolicy
 
     DBG_INFO(("gvlnGetNoEgrPolicy Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NO_EGRESS_POLICY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related register */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c
old mode 100644
new mode 100755
index efe1f05..962acd7
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtBrgVtu.c
@@ -20,87 +20,91 @@
 /****************************************************************************/
 /* Forward function declaration.                                            */
 /****************************************************************************/
-#define MEMBER_TAG_CONV_FOR_APP(_dev,_tag)	memberTagConversionForApp(_dev,_tag)
-#define MEMBER_TAG_CONV_FOR_DEV(_dev,_tag)	memberTagConversionForDev(_dev,_tag)
+#define MEMBER_TAG_CONV_FOR_APP(_dev,_tag)    memberTagConversionForApp(_dev,_tag)
+#define MEMBER_TAG_CONV_FOR_DEV(_dev,_tag)    memberTagConversionForDev(_dev,_tag)
 
 static GT_U8 memberTagConversionForApp
 (
-    IN	GT_QD_DEV           *dev,
-    IN	GT_U8               tag
+    IN    GT_QD_DEV           *dev,
+    IN    GT_U8               tag
 )
 {
-	GT_U8 convTag;
-
-	/* check if memberTag needs to be converted */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-		return tag;
-
-	switch(tag)
-	{
-		case 0:
-				convTag = MEMBER_EGRESS_UNMODIFIED;
-				break;
-		case 1:
-				convTag = MEMBER_EGRESS_UNTAGGED;
-				break;
-		case 2:
-				convTag = MEMBER_EGRESS_TAGGED;
-				break;
-		case 3:
-				convTag = NOT_A_MEMBER;
-				break;
-		default:
-				DBG_INFO(("Unknown Tag (%#x) from Device !!!.\n",tag));
-				convTag = 0xFF;
-				break;
-			
-	}
-
-	return convTag;
+    GT_U8 convTag;
+
+    /* check if memberTag needs to be converted */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+        return tag;
+
+    switch(tag)
+    {
+        case 0:
+                convTag = MEMBER_EGRESS_UNMODIFIED;
+                break;
+        case 1:
+                convTag = MEMBER_EGRESS_UNTAGGED;
+                break;
+        case 2:
+                convTag = MEMBER_EGRESS_TAGGED;
+                break;
+        case 3:
+                convTag = NOT_A_MEMBER;
+                break;
+        default:
+                DBG_INFO(("Unknown Tag (%#x) from Device !!!.\n",tag));
+                convTag = 0xFF;
+                break;
+            
+    }
+
+    return convTag;
 }
 
 static GT_U8 memberTagConversionForDev
 (
-    IN	GT_QD_DEV           *dev,
-    IN	GT_U8               tag
+    IN    GT_QD_DEV           *dev,
+    IN    GT_U8               tag
 )
 {
-	GT_U8 convTag;
-
-	/* check if memberTag needs to be converted */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-		return tag;
-
-	switch(tag)
-	{
-		case MEMBER_EGRESS_UNMODIFIED:
-				convTag = 0;
-				break;
-		case NOT_A_MEMBER:
-				convTag = 3;
-				break;
-		case MEMBER_EGRESS_UNTAGGED:
-				convTag = 1;
-				break;
-		case MEMBER_EGRESS_TAGGED:
-				convTag = 2;
-				break;
-		default:
-				DBG_INFO(("Unknown Tag (%#x) from App. !!!.\n",tag));
-				convTag = 0xFF;
-				break;
-			
-	}
-
-	return convTag;
+    GT_U8 convTag;
+
+    /* check if memberTag needs to be converted */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+        return tag;
+
+    switch(tag)
+    {
+        case MEMBER_EGRESS_UNMODIFIED:
+                convTag = 0;
+                break;
+        case NOT_A_MEMBER:
+                convTag = 3;
+                break;
+        case MEMBER_EGRESS_UNTAGGED:
+                convTag = 1;
+                break;
+        case MEMBER_EGRESS_TAGGED:
+                convTag = 2;
+                break;
+        default:
+                DBG_INFO(("Unknown Tag (%#x) from App. !!!.\n",tag));
+                convTag = 0xFF;
+                break;
+            
+    }
+
+    return convTag;
 }
 
 static GT_STATUS vtuOperationPerform
 (
-    IN	    GT_QD_DEV           *dev,
+    IN        GT_QD_DEV           *dev,
     IN      GT_VTU_OPERATION    vtuOp,
     INOUT   GT_U8               *valid,
-    INOUT 	GT_VTU_ENTRY    	*vtuEntry
+    INOUT     GT_VTU_ENTRY        *vtuEntry
 );
 
 /*******************************************************************************
@@ -133,9 +137,9 @@ GT_STATUS gvtuGetEntryCount
 )
 {
     GT_U8               valid;
-    GT_U32		numOfEntries;
-    GT_STATUS       	retVal;
-    GT_VTU_ENTRY    	entry;
+    GT_U32        numOfEntries;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetEntryCount Called.\n"));
 
@@ -149,18 +153,18 @@ GT_STATUS gvtuGetEntryCount
     numOfEntries = 0;
     while(1)
     {
-		retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid,&entry);
-		if(retVal != GT_OK)
-		{
-		    DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
-	    	return retVal;
-		}
-
-		if( entry.vid==0xFFF )
-		{
-			if (valid==1) numOfEntries++;
-			break;
-		}
+        retVal = vtuOperationPerform(dev,GET_NEXT_ENTRY,&valid,&entry);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+            return retVal;
+        }
+
+        if( entry.vid==0xFFF )
+        {
+            if (valid==1) numOfEntries++;
+            break;
+        }
 
         numOfEntries++;
     }
@@ -203,10 +207,10 @@ GT_STATUS gvtuGetEntryFirst
 )
 {
     GT_U8               valid;
-    GT_STATUS       	retVal;
-    GT_U8       		port; 
-    GT_LPORT       		lport; 
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_U8               port; 
+    GT_LPORT               lport; 
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetEntryFirst Called.\n"));
 
@@ -227,28 +231,28 @@ GT_STATUS gvtuGetEntryFirst
     /* retrive the value from the operation */ 
 
     if((entry.vid == 0xFFF) && (valid == 0))
-		return GT_NO_SUCH;
+        return GT_NO_SUCH;
 
     vtuEntry->DBNum = entry.DBNum;
     vtuEntry->vid   = entry.vid;
 
-	vtuEntry->vidPriOverride = entry.vidPriOverride;
-	vtuEntry->vidPriority = entry.vidPriority;
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
 
-	vtuEntry->vidPolicy = entry.vidPolicy;
-	vtuEntry->sid = entry.sid;
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
 
-	vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
-	vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
-	vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
-	vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
-	vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
 
     for(lport=0; lport<dev->numOfPorts; lport++)
     {
-		port = GT_LPORT_2_PORT(lport);
-		vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
-		vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
     }
 
     DBG_INFO(("OK.\n"));
@@ -286,10 +290,10 @@ GT_STATUS gvtuGetEntryNext
 )
 {
     GT_U8               valid;
-    GT_STATUS       	retVal;
-    GT_U8       		port; 
-    GT_LPORT       		lport; 
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_U8               port; 
+    GT_LPORT               lport; 
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetEntryNext Called.\n"));
     
@@ -310,29 +314,29 @@ GT_STATUS gvtuGetEntryNext
 
     /* retrieve the value from the operation */ 
 
-	if((entry.vid == 0xFFF) && (valid == 0))
-		return GT_NO_SUCH;
+    if((entry.vid == 0xFFF) && (valid == 0))
+        return GT_NO_SUCH;
 
     vtuEntry->DBNum = entry.DBNum;
     vtuEntry->vid   = entry.vid;
 
-	vtuEntry->vidPriOverride = entry.vidPriOverride;
-	vtuEntry->vidPriority = entry.vidPriority;
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
 
-	vtuEntry->vidPolicy = entry.vidPolicy;
-	vtuEntry->sid = entry.sid;
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
 
-	vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
-	vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
-	vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
-	vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
-	vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
 
     for(lport=0; lport<dev->numOfPorts; lport++)
     {
-		port = GT_LPORT_2_PORT(lport);
-		vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
-		vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
     }
 
     DBG_INFO(("OK.\n"));
@@ -373,10 +377,10 @@ GT_STATUS gvtuFindVidEntry
 )
 {
     GT_U8               valid;
-    GT_STATUS       	retVal;
+    GT_STATUS           retVal;
     GT_U8               port;
     GT_LPORT            lport;
-    GT_VTU_ENTRY    	entry;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuFindVidEntry Called.\n"));
 
@@ -408,23 +412,23 @@ GT_STATUS gvtuFindVidEntry
 
     vtuEntry->DBNum = entry.DBNum;
 
-	vtuEntry->vidPriOverride = entry.vidPriOverride;
-	vtuEntry->vidPriority = entry.vidPriority;
+    vtuEntry->vidPriOverride = entry.vidPriOverride;
+    vtuEntry->vidPriority = entry.vidPriority;
 
-	vtuEntry->vidPolicy = entry.vidPolicy;
-	vtuEntry->sid = entry.sid;
+    vtuEntry->vidPolicy = entry.vidPolicy;
+    vtuEntry->sid = entry.sid;
 
-	vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
-	vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
-	vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
-	vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
-	vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
+    vtuEntry->vidExInfo.useVIDFPri = entry.vidExInfo.useVIDFPri;
+    vtuEntry->vidExInfo.vidFPri = entry.vidExInfo.vidFPri;
+    vtuEntry->vidExInfo.useVIDQPri = entry.vidExInfo.useVIDQPri;
+    vtuEntry->vidExInfo.vidQPri = entry.vidExInfo.vidQPri;
+    vtuEntry->vidExInfo.vidNRateLimit = entry.vidExInfo.vidNRateLimit;
 
     for(lport=0; lport<dev->numOfPorts; lport++)
     {
-		port = GT_LPORT_2_PORT(lport);
-		vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
-		vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
+        port = GT_LPORT_2_PORT(lport);
+        vtuEntry->vtuData.memberTagP[lport]=MEMBER_TAG_CONV_FOR_APP(dev,entry.vtuData.memberTagP[port]);
+        vtuEntry->vtuData.portStateP[lport]=entry.vtuData.portStateP[port];
     }
 
     *found = GT_TRUE;
@@ -467,9 +471,9 @@ GT_STATUS gvtuFlush
 
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK)
-	{
-		return retVal;
-	}
+    {
+        return retVal;
+    }
 
     retVal = vtuOperationPerform(dev,FLUSH_ALL,NULL,NULL);
     if(retVal != GT_OK)
@@ -497,7 +501,7 @@ GT_STATUS gvtuFlush
 * RETURNS:
 *       GT_OK             - on success
 *       GT_FAIL           - on error
-*       GT_FULL			  - vtu table is full
+*       GT_FULL              - vtu table is full
 *
 * COMMENTS:
 *       None.
@@ -512,13 +516,13 @@ GT_STATUS gvtuAddEntry
 )
 {
     GT_U8               valid;
-    GT_STATUS       	retVal;
-    GT_U8       	port; 
-    GT_LPORT       	lport; 
-    GT_VTU_ENTRY 	tmpVtuEntry;
-	GT_BOOL		 	found;
-	int				count = 5000;
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_U8           port; 
+    GT_LPORT           lport; 
+    GT_VTU_ENTRY     tmpVtuEntry;
+    GT_BOOL             found;
+    int                count = 5000;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuAddEntry Called.\n"));
 
@@ -529,106 +533,106 @@ GT_STATUS gvtuAddEntry
     entry.DBNum = vtuEntry->DBNum;
     entry.vid   = vtuEntry->vid;
 
-	if(IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
-	{
-		entry.vidPriOverride = 0;
-		entry.vidPriority = 0;
-
-		entry.vidPolicy = GT_FALSE;
-		entry.sid = 0;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
-		{
-			entry.vidExInfo.useVIDFPri = vtuEntry->vidExInfo.useVIDFPri;
-			entry.vidExInfo.vidFPri = vtuEntry->vidExInfo.vidFPri;
-			entry.vidExInfo.useVIDQPri = vtuEntry->vidExInfo.useVIDQPri;
-			entry.vidExInfo.vidQPri = vtuEntry->vidExInfo.vidQPri;
-			entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
-		}
-		else
-		{
-			entry.vidExInfo.useVIDFPri = 0;
-			entry.vidExInfo.vidFPri = 0;
-			entry.vidExInfo.useVIDQPri = 0;
-			entry.vidExInfo.vidQPri = 0;
-			entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
-		}
-	}
-	else
-	{
-		entry.vidPriOverride = vtuEntry->vidPriOverride;
-		entry.vidPriority = vtuEntry->vidPriority;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
-		{
-			entry.vidPolicy = vtuEntry->vidPolicy;
-		}
-		else
-		{
-			entry.vidPolicy = GT_FALSE;
-		}
-
-		if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
-		{
-			entry.sid = vtuEntry->sid;
-		}
-		else
-		{
-			entry.sid = 0;
-		}
-
-		entry.vidExInfo.useVIDFPri = 0;
-		entry.vidExInfo.vidFPri = 0;
-		entry.vidExInfo.useVIDQPri = 0;
-		entry.vidExInfo.vidQPri = 0;
-		entry.vidExInfo.vidNRateLimit = 0;
-	}
+    if(IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+    {
+        entry.vidPriOverride = 0;
+        entry.vidPriority = 0;
+
+        entry.vidPolicy = GT_FALSE;
+        entry.sid = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FQPRI_IN_TABLE))
+        {
+            entry.vidExInfo.useVIDFPri = vtuEntry->vidExInfo.useVIDFPri;
+            entry.vidExInfo.vidFPri = vtuEntry->vidExInfo.vidFPri;
+            entry.vidExInfo.useVIDQPri = vtuEntry->vidExInfo.useVIDQPri;
+            entry.vidExInfo.vidQPri = vtuEntry->vidExInfo.vidQPri;
+            entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
+        }
+        else
+        {
+            entry.vidExInfo.useVIDFPri = 0;
+            entry.vidExInfo.vidFPri = 0;
+            entry.vidExInfo.useVIDQPri = 0;
+            entry.vidExInfo.vidQPri = 0;
+            entry.vidExInfo.vidNRateLimit = vtuEntry->vidExInfo.vidNRateLimit;
+        }
+    }
+    else
+    {
+        entry.vidPriOverride = vtuEntry->vidPriOverride;
+        entry.vidPriority = vtuEntry->vidPriority;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+        {
+            entry.vidPolicy = vtuEntry->vidPolicy;
+        }
+        else
+        {
+            entry.vidPolicy = GT_FALSE;
+        }
+
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            entry.sid = vtuEntry->sid;
+        }
+        else
+        {
+            entry.sid = 0;
+        }
+
+        entry.vidExInfo.useVIDFPri = 0;
+        entry.vidExInfo.vidFPri = 0;
+        entry.vidExInfo.useVIDQPri = 0;
+        entry.vidExInfo.vidQPri = 0;
+        entry.vidExInfo.vidNRateLimit = 0;
+    }
 
     valid = 1; /* for load operation */
 
     for(port=0; port<dev->maxPorts; port++)
     {
-		lport = GT_PORT_2_LPORT(port);
-		if(lport == GT_INVALID_PORT)
-		{
-			entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,NOT_A_MEMBER);
-			entry.vtuData.portStateP[port] = 0;
-		}
-		else
-		{
-			entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,vtuEntry->vtuData.memberTagP[lport]);
-			if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-				entry.vtuData.portStateP[port] = vtuEntry->vtuData.portStateP[lport];
-			else
-				entry.vtuData.portStateP[port] = 0;
-		}
+        lport = GT_PORT_2_LPORT(port);
+        if(lport == GT_INVALID_PORT)
+        {
+            entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,NOT_A_MEMBER);
+            entry.vtuData.portStateP[port] = 0;
+        }
+        else
+        {
+            entry.vtuData.memberTagP[port] = MEMBER_TAG_CONV_FOR_DEV(dev,vtuEntry->vtuData.memberTagP[lport]);
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                entry.vtuData.portStateP[port] = vtuEntry->vtuData.portStateP[lport];
+            else
+                entry.vtuData.portStateP[port] = 0;
+        }
     }
 
     retVal = vtuOperationPerform(dev,LOAD_PURGE_ENTRY,&valid, &entry);
     if(retVal != GT_OK)
     {
-		DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
+        DBG_INFO(("Failed (vtuOperationPerform returned GT_FAIL).\n"));
         return retVal;
     }
 
-	/* verify that the given entry has been added */
-	tmpVtuEntry.vid = vtuEntry->vid;
-	tmpVtuEntry.DBNum = vtuEntry->DBNum;
-
-	if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
-	{
-		while(count--);
-		if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
-		{
-			DBG_INFO(("Added entry cannot be found\n"));
-			return retVal;
-		}
-	}
-	if(found == GT_FALSE)
-	{
-		DBG_INFO(("Added entry cannot be found\n"));
-		return GT_FAIL;
-	}
+    /* verify that the given entry has been added */
+    tmpVtuEntry.vid = vtuEntry->vid;
+    tmpVtuEntry.DBNum = vtuEntry->DBNum;
+
+    if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+    {
+        while(count--);
+        if((retVal = gvtuFindVidEntry(dev,&tmpVtuEntry,&found)) != GT_OK)
+        {
+            DBG_INFO(("Added entry cannot be found\n"));
+            return retVal;
+        }
+    }
+    if(found == GT_FALSE)
+    {
+        DBG_INFO(("Added entry cannot be found\n"));
+        return GT_FAIL;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -663,8 +667,8 @@ GT_STATUS gvtuDelEntry
 )
 {
     GT_U8               valid;
-    GT_STATUS       	retVal;
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuDelEntry Called.\n"));
 
@@ -708,7 +712,7 @@ GT_STATUS gvtuDelEntry
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -722,25 +726,25 @@ GT_STATUS gvtuGetViolation
     GT_U8               spid;
     GT_U16               vid;
     GT_U16               intCause;
-    GT_STATUS       	retVal;
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetViolation Called.\n"));
 
-	/* check which Violation occurred */
+    /* check which Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
         return retVal;
     }
 
-	if (intCause == 0)
-	{
-		/* No Violation occurred. */
-		vtuIntStatus->vtuIntCause = 0;
-		return GT_OK;
-	}
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
 
     entry.DBNum = 0;
 
@@ -751,22 +755,22 @@ GT_STATUS gvtuGetViolation
         return retVal;
     }
 
-	spid = entry.DBNum & 0xF;
-	vid = entry.vid;
-
-	if(spid == 0xF)
-	{
-		vtuIntStatus->vtuIntCause = GT_VTU_FULL_VIOLATION;
-		vtuIntStatus->spid = spid;
-		vtuIntStatus->vid = 0;
-	}
-	else
-	{
-		vtuIntStatus->vtuIntCause = intCause & (GT_MEMBER_VIOLATION | GT_MISS_VIOLATION);
-		vtuIntStatus->spid = spid;
-		vtuIntStatus->vid = vid;
-	}
-	
+    spid = entry.DBNum & 0xF;
+    vid = entry.vid;
+
+    if(spid == 0xF)
+    {
+        vtuIntStatus->vtuIntCause = GT_VTU_FULL_VIOLATION;
+        vtuIntStatus->spid = spid;
+        vtuIntStatus->vid = 0;
+    }
+    else
+    {
+        vtuIntStatus->vtuIntCause = intCause & (GT_MEMBER_VIOLATION | GT_MISS_VIOLATION);
+        vtuIntStatus->spid = spid;
+        vtuIntStatus->vid = vid;
+    }
+    
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -789,7 +793,7 @@ GT_STATUS gvtuGetViolation
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -801,25 +805,25 @@ GT_STATUS gvtuGetViolation2
 )
 {
     GT_U16               intCause;
-    GT_STATUS       	retVal;
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetViolation2 Called.\n"));
 
-	/* check if Violation occurred */
+    /* check if Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
         return retVal;
     }
 
-	if (intCause == 0)
-	{
-		/* No Violation occurred. */
-		vtuIntStatus->vtuIntCause = 0;
-		return GT_OK;
-	}
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
 
     entry.DBNum = 0;
 
@@ -830,35 +834,35 @@ GT_STATUS gvtuGetViolation2
         return retVal;
     }
 
-	/* check which Violation occurred */
+    /* check which Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,5,2,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
         return retVal;
     }
 
-	switch (intCause)
-	{
-		case 0:
-			/* No Violation occurred. */
-			vtuIntStatus->vtuIntCause = 0;
-			return GT_OK;
-		case 1:
-			/* Miss Violation */
-			vtuIntStatus->vtuIntCause = GT_MISS_VIOLATION;
-			break;
-		case 2:
-			/* Member Violation */
-			vtuIntStatus->vtuIntCause = GT_MEMBER_VIOLATION;
-			break;
-		default :
-			return GT_FAIL;
-	}
-
-	vtuIntStatus->spid = entry.DBNum & 0xF;
-	vtuIntStatus->vid = entry.vid;
-	
+    switch (intCause)
+    {
+        case 0:
+            /* No Violation occurred. */
+            vtuIntStatus->vtuIntCause = 0;
+            return GT_OK;
+        case 1:
+            /* Miss Violation */
+            vtuIntStatus->vtuIntCause = GT_MISS_VIOLATION;
+            break;
+        case 2:
+            /* Member Violation */
+            vtuIntStatus->vtuIntCause = GT_MEMBER_VIOLATION;
+            break;
+        default :
+            return GT_FAIL;
+    }
+
+    vtuIntStatus->spid = entry.DBNum & 0xF;
+    vtuIntStatus->vid = entry.vid;
+    
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -881,7 +885,7 @@ GT_STATUS gvtuGetViolation2
 *       GT_NOT_SUPPORT  - if current device does not support this feature.
 *
 * COMMENTS:
-*		This is an internal function. No user should call this function.
+*        This is an internal function. No user should call this function.
 *
 * GalTis:
 *
@@ -893,25 +897,25 @@ GT_STATUS gvtuGetViolation3
 )
 {
     GT_U16               intCause;
-    GT_STATUS       	retVal;
-    GT_VTU_ENTRY    	entry;
+    GT_STATUS           retVal;
+    GT_VTU_ENTRY        entry;
 
     DBG_INFO(("gvtuGetViolation3 Called.\n"));
 
-	/* check if Violation occurred */
+    /* check if Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,5,1,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
         return retVal;
     }
 
-	if (intCause == 0)
-	{
-		/* No Violation occurred. */
-		vtuIntStatus->vtuIntCause = 0;
-		return GT_OK;
-	}
+    if (intCause == 0)
+    {
+        /* No Violation occurred. */
+        vtuIntStatus->vtuIntCause = 0;
+        return GT_OK;
+    }
 
     entry.DBNum = 0;
 
@@ -922,33 +926,33 @@ GT_STATUS gvtuGetViolation3
         return retVal;
     }
 
-	/* check which Violation occurred */
+    /* check which Violation occurred */
     retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,4,3,&intCause);
     if(retVal != GT_OK)
     {
-	    DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
+        DBG_INFO(("ERROR to read VTU OPERATION Register.\n"));
         return retVal;
     }
 
-	vtuIntStatus->vtuIntCause = 0;
+    vtuIntStatus->vtuIntCause = 0;
 
-	if(intCause & 0x1)
-	{
-		vtuIntStatus->vtuIntCause |= GT_VTU_FULL_VIOLATION;
-	}
+    if(intCause & 0x1)
+    {
+        vtuIntStatus->vtuIntCause |= GT_VTU_FULL_VIOLATION;
+    }
 
-	if(intCause & 0x2)
-	{
-		vtuIntStatus->vtuIntCause |= GT_MISS_VIOLATION;
-	}
+    if(intCause & 0x2)
+    {
+        vtuIntStatus->vtuIntCause |= GT_MISS_VIOLATION;
+    }
 
-	if(intCause & 0x4)
-	{
-		vtuIntStatus->vtuIntCause |= GT_MEMBER_VIOLATION;
-	}
-			
-	vtuIntStatus->spid = entry.DBNum & 0xF;
-	vtuIntStatus->vid = entry.vid;
+    if(intCause & 0x4)
+    {
+        vtuIntStatus->vtuIntCause |= GT_MEMBER_VIOLATION;
+    }
+            
+    vtuIntStatus->spid = entry.DBNum & 0xF;
+    vtuIntStatus->vid = entry.vid;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -986,546 +990,603 @@ GT_STATUS gvtuGetViolation3
 
 static GT_STATUS vtuOperationPerform
 (
-    IN	    GT_QD_DEV           *dev,
+    IN        GT_QD_DEV           *dev,
     IN      GT_VTU_OPERATION    vtuOp,
     INOUT   GT_U8               *valid,
-	INOUT	GT_VTU_ENTRY    	*entry
+    INOUT    GT_VTU_ENTRY        *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* Data to be set into the      */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
                                 /* register.                    */
 
-	gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->vtuRegsSem,OS_WAIT_FOREVER);
 
-	/* Wait until the VTU in ready. */
-	data = 1;
+    /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
     while(data == 1)
     {
-		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-	}
-
-	/* Set the VTU data register    */
-	/* There is no need to setup data reg. on flush, get next, or service violation */
-	if((vtuOp != FLUSH_ALL) && (vtuOp != GET_NEXT_ENTRY) && (vtuOp != SERVICE_VIOLATIONS))
-	{
-
-		/****************** VTU DATA 1 REG *******************/
-
-		/* get data and wirte to QD_REG_VTU_DATA1_REG (ports 0 to 3) */
-
-		data =  (entry->vtuData.memberTagP[0] & 3)     |
-				((entry->vtuData.memberTagP[1] & 3)<<4) | 
-				((entry->vtuData.memberTagP[2] & 3)<<8);
-
-		if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-			data |= ((entry->vtuData.portStateP[0] & 3)<<2)	|
-					((entry->vtuData.portStateP[1] & 3)<<6) | 
-					((entry->vtuData.portStateP[2] & 3)<<10);
-			
-		if(dev->maxPorts > 3)
-		{
-			data |= ((entry->vtuData.memberTagP[3] & 3)<<12) ;
-			if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-				data |= ((entry->vtuData.portStateP[3] & 3)<<14) ;
-		}
-
-		retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-
-		/****************** VTU DATA 2 REG *******************/
-
-		/* get data and wirte to QD_REG_VTU_DATA2_REG (ports 4 to 7) */
-
-		if(dev->maxPorts > 4)
-		{
-			/* also need to set data register  ports 4 to 6 */
-
-			data =  (entry->vtuData.memberTagP[4] & 3)   |
-					((entry->vtuData.memberTagP[5] & 3) << 4);
-
-			if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-				data |= ((entry->vtuData.portStateP[4] & 3) << 2) |
-						((entry->vtuData.portStateP[5] & 3) << 6); 
-
-			if(dev->maxPorts > 6)
-			{
-				data |= ((entry->vtuData.memberTagP[6] & 3)<<8) ;
-				if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-					data |= ((entry->vtuData.portStateP[6] & 3)<<10) ;
-			}
-
-			if(dev->maxPorts > 7)
-			{
-				data |= ((entry->vtuData.memberTagP[7] & 3)<<12) ;
-				if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-					data |= ((entry->vtuData.portStateP[7] & 3)<<14) ;
-			}
-
-			if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
-			{
-				if(entry->vidExInfo.useVIDFPri == GT_TRUE)
-					data |= ((1 << 15) | ((entry->vidExInfo.vidFPri & 0x7) << 12));
-				if(entry->vidExInfo.useVIDQPri == GT_TRUE)
-					data |= ((1 << 11) | ((entry->vidExInfo.vidQPri & 0x3) << 9));
-				if(entry->vidExInfo.vidNRateLimit == GT_TRUE)
-					data |= (1 << 8);
-			}
-
-			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-		}
-
-
-		/****************** VTU DATA 3 REG *******************/
-
-		/* get data and wirte to QD_REG_VTU_DATA3_REG (ports 8 to 10) */
-
-		if(dev->maxPorts > 7)
-		{
-			/* also need to set data register  ports 8 to 9 */
-
-			data =  (entry->vtuData.memberTagP[8] & 3)   |
-					((entry->vtuData.memberTagP[9] & 3) << 4);
-
-			if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-				data |= ((entry->vtuData.portStateP[8] & 3) << 2)	|
-						((entry->vtuData.portStateP[9] & 3) << 6);
-
-			if(dev->maxPorts > 10)
-			{
-				data |= (entry->vtuData.memberTagP[10] & 3) << 8;
-
-				if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
-					data |= (entry->vtuData.portStateP[10] & 3) << 10;
-			}
-			
-			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-			{
-				if(entry->vidPriOverride == GT_TRUE)
-					data |= ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
-			}
-
-			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-		{
-			if(entry->vidPriOverride == GT_TRUE)
-				data = ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
-			else
-				data = 0;
-
-			retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-		}
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    /* Set the VTU data register    */
+    /* There is no need to setup data reg. on flush, get next, or service violation */
+    if((vtuOp != FLUSH_ALL) && (vtuOp != GET_NEXT_ENTRY) && (vtuOp != SERVICE_VIOLATIONS))
+    {
+
+        /****************** VTU DATA 1 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA1_REG (ports 0 to 3) */
+
+        data =  (entry->vtuData.memberTagP[0] & 3)     |
+                ((entry->vtuData.memberTagP[1] & 3)<<4) | 
+                ((entry->vtuData.memberTagP[2] & 3)<<8);
+
+        if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+            data |= ((entry->vtuData.portStateP[0] & 3)<<2)    |
+                    ((entry->vtuData.portStateP[1] & 3)<<6) | 
+                    ((entry->vtuData.portStateP[2] & 3)<<10);
+            
+        if(dev->maxPorts > 3)
+        {
+            data |= ((entry->vtuData.memberTagP[3] & 3)<<12) ;
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[3] & 3)<<14) ;
+        }
+
+        retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA1_REG,data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /****************** VTU DATA 2 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA2_REG (ports 4 to 7) */
+
+        if(dev->maxPorts > 4)
+        {
+            /* also need to set data register  ports 4 to 6 */
+
+            data =  (entry->vtuData.memberTagP[4] & 3)   |
+                    ((entry->vtuData.memberTagP[5] & 3) << 4);
+
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[4] & 3) << 2) |
+                        ((entry->vtuData.portStateP[5] & 3) << 6); 
+
+            if(dev->maxPorts > 6)
+            {
+                data |= ((entry->vtuData.memberTagP[6] & 3)<<8) ;
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= ((entry->vtuData.portStateP[6] & 3)<<10) ;
+            }
+
+            if(dev->maxPorts > 7)
+            {
+                data |= ((entry->vtuData.memberTagP[7] & 3)<<12) ;
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= ((entry->vtuData.portStateP[7] & 3)<<14) ;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+            {
+                if(entry->vidExInfo.useVIDFPri == GT_TRUE)
+                    data |= ((1 << 15) | ((entry->vidExInfo.vidFPri & 0x7) << 12));
+                if(entry->vidExInfo.useVIDQPri == GT_TRUE)
+                    data |= ((1 << 11) | ((entry->vidExInfo.vidQPri & 0x3) << 9));
+                if(entry->vidExInfo.vidNRateLimit == GT_TRUE)
+                    data |= (1 << 8);
+            }
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA2_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+
+
+        /****************** VTU DATA 3 REG *******************/
+
+        /* get data and wirte to QD_REG_VTU_DATA3_REG (ports 8 to 10) */
+
+        if(dev->maxPorts > 7)
+        {
+            /* also need to set data register  ports 8 to 9 */
+
+            data =  (entry->vtuData.memberTagP[8] & 3)   |
+                    ((entry->vtuData.memberTagP[9] & 3) << 4);
+
+            if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                data |= ((entry->vtuData.portStateP[8] & 3) << 2)    |
+                        ((entry->vtuData.portStateP[9] & 3) << 6);
+
+            if(dev->maxPorts > 10)
+            {
+                data |= (entry->vtuData.memberTagP[10] & 3) << 8;
+
+                if (IS_IN_DEV_GROUP(dev,DEV_802_1S))
+                    data |= (entry->vtuData.portStateP[10] & 3) << 10;
+            }
+            
+            if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+            {
+                if(entry->vidPriOverride == GT_TRUE)
+                    data |= ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+            }
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+        {
+            if(entry->vidPriOverride == GT_TRUE)
+                data = ((1 << 15) | ((entry->vidPriority & 0x7) << 12));
+            else
+                data = 0;
+
+            retVal = hwWriteGlobalReg(dev,QD_REG_VTU_DATA3_REG,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the VID register (QD_REG_VTU_VID_REG) */
+    /* There is no need to setup VID reg. on flush and service violation */
+    if((vtuOp != FLUSH_ALL) && (vtuOp != SERVICE_VIOLATIONS) )
+    {
+        data= ( (entry->vid) & 0xFFF ) | ( (*valid) << 12 );
+        retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }        
     }
 
-	/* Set the VID register (QD_REG_VTU_VID_REG) */
-	/* There is no need to setup VID reg. on flush and service violation */
-	if((vtuOp != FLUSH_ALL) && (vtuOp != SERVICE_VIOLATIONS) )
-	{
-    	data= ( (entry->vid) & 0xFFF ) | ( (*valid) << 12 );
-	    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_VID_REG),data);
-    	if(retVal != GT_OK)
-	    {
-    		gtSemGive(dev,dev->vtuRegsSem);
-	    	return retVal;
-    	}		
-	}
-
-	/* Set SID, FID, VIDPolicy, if it's Load operation */
-	if((vtuOp == LOAD_PURGE_ENTRY) && (*valid == 1))
-	{
-		if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
-		{
-	    	data= (entry->sid) & 0x3F;
-		    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),data);
-    		if(retVal != GT_OK)
-		    {
-    			gtSemGive(dev,dev->vtuRegsSem);
-	    		return retVal;
-	    	}		
-		}
-
-		data = 0;
-
-		if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-		{
-			if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
-			{
-	    		data= entry->vidPolicy << 12;
-			}
-
-	    	data |= (entry->DBNum & 0xFFF);
-
-		    retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),data);
-    		if(retVal != GT_OK)
-		    {
-    			gtSemGive(dev,dev->vtuRegsSem);
-	    		return retVal;
-	    	}		
-		}
-
-
-	}
-
-	/* Start the VTU Operation by defining the DBNum, vtuOp and VTUBusy    */
-	/* 
-	 * Flush operation will skip the above two setup (for data and vid), and 
-	 * come to here directly
-	 */
-
-	if(vtuOp == FLUSH_ALL)
-		data = (1 << 15) | (vtuOp << 12);
-	else
-	{
-		if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-		{
-			data = (1 << 15) | (vtuOp << 12);
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-		{
-			/* Since DBNum is defined as GT_U8, it cannot be >= 256. */
-			#if 0
-			if(entry->DBNum >= 256)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return GT_BAD_PARAM;
-			}	
-			#endif
-			data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0xF0) << 4) | (entry->DBNum & 0x0F);
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-		{
-			if(entry->DBNum >= 64)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return GT_BAD_PARAM;
-			}	
-			data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0x30) << 4) | (entry->DBNum & 0x0F);
-		}
-		else
-		{
-			if(entry->DBNum >= 16)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return GT_BAD_PARAM;
-			}	
-			data = (1 << 15) | (vtuOp << 12) | entry->DBNum;
-		}
-	}
-
-	retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
-	if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->vtuRegsSem);
-		return retVal;
-	}
-
-	/* only two operations need to go through the mess below to get some data 
-	 * after the operations -  service violation and get next entry
-	 */
-
-	/* If the operation is to service violation operation wait for the response   */
-	if(vtuOp == SERVICE_VIOLATIONS)
-	{
-		/* Wait until the VTU in ready. */
-		data = 1;
-		while(data == 1)
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-		}
-
-		/* get the Source Port ID that was involved in the violation */
-		retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-
-		entry->DBNum = (GT_U8)(data & 0xF);
-
-		/* get the VID that was involved in the violation */
-
-		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-
-		/* Get the vid - bits 0-11 */
-		entry->vid   = data & 0xFFF;
-
-
-	} /* end of service violations */
-
-	/* If the operation is a get next operation wait for the response   */
-	if(vtuOp == GET_NEXT_ENTRY)
-	{
-		entry->vidExInfo.useVIDFPri = GT_FALSE;
-		entry->vidExInfo.vidFPri = 0;
-
-		entry->vidExInfo.useVIDQPri = GT_FALSE;
-		entry->vidExInfo.vidQPri = 0;
-
-		entry->vidExInfo.vidNRateLimit = GT_FALSE;
-
-    	entry->sid = 0;
-   		entry->vidPolicy = GT_FALSE;
-
-		/* Wait until the VTU in ready. */
-		data = 1;
-		while(data == 1)
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-		}
-
-		/****************** get the vid *******************/
-
-		retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-
-		/* the vid is bits 0-11 */
-		entry->vid   = data & 0xFFF;
-
-		/* the vid valid is bits 12 */
-		*valid   = (data >> 12) & 1;
-		
-		if (*valid == 0)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return GT_OK;
-		}
-
-		/****************** get the SID *******************/
-		if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
-		{
-		    retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),&data);
-    		if(retVal != GT_OK)
-		    {
-    			gtSemGive(dev,dev->vtuRegsSem);
-	    		return retVal;
-	    	}		
-	    	entry->sid = data & 0x3F;
-		}
-
-		/****************** get the DBNum *******************/
-		if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
-		{
-		    retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),&data);
-    		if(retVal != GT_OK)
-		    {
-    			gtSemGive(dev,dev->vtuRegsSem);
-	    		return retVal;
-	    	}		
-
-			if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
-			{
-	    		entry->vidPolicy = (data >> 12) & 0x1;
-			}
-
-	    	entry->DBNum = data & 0xFFF;
-
-		}
-		else
-		{
-			retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-
-			entry->DBNum = data & 0xF;
-		
-			if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
-			{
-				retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,4,&data);
-				if(retVal != GT_OK)
-				{
-					gtSemGive(dev,dev->vtuRegsSem);
-					return retVal;
-				}
-
-				entry->DBNum |= ((data & 0xF) << 4);
-			}
-			else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
-			{
-				retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,2,&data);
-				if(retVal != GT_OK)
-				{
-					gtSemGive(dev,dev->vtuRegsSem);
-					return retVal;
-				}
-
-				entry->DBNum |= ((data & 0x3) << 4);
-			}
-		}
-
-
-		/****************** get the MemberTagP *******************/
-		retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->vtuRegsSem);
-			return retVal;
-		}
-
-		/* get data from data register for ports 0 to 2 */
-		entry->vtuData.memberTagP[0]  =  data & 3 ;
-		entry->vtuData.memberTagP[1]  = (data >> 4) & 3 ;
-		entry->vtuData.memberTagP[2]  = (data >> 8) & 3 ;
-		entry->vtuData.portStateP[0]  = (data >> 2) & 3 ;
-		entry->vtuData.portStateP[1]  = (data >> 6) & 3 ;
-		entry->vtuData.portStateP[2]  = (data >> 10) & 3 ;
-
-		/****************** for the switch more than 3 ports *****************/
-
-		if(dev->maxPorts > 3)
-		{
-			/* fullsail has 3 ports, clippership has 7 prots */
-			entry->vtuData.memberTagP[3]  = (data >>12) & 3 ;
-			entry->vtuData.portStateP[3]  = (data >>14) & 3 ;
-
-			/* get data from data register for ports 4 to 6 */
-			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-			entry->vtuData.memberTagP[4]  = data & 3 ;
-			entry->vtuData.memberTagP[5]  = (data >> 4) & 3 ;
-			entry->vtuData.portStateP[4]  = (data >> 2) & 3 ;
-			entry->vtuData.portStateP[5]  = (data >> 6) & 3 ;
-
-			if(dev->maxPorts > 6)
-			{
-				entry->vtuData.memberTagP[6]  = (data >> 8) & 3 ;
-				entry->vtuData.portStateP[6]  = (data >> 10) & 3 ;
-			}
-			
-			if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
-			{
-				entry->vidPriOverride = 0;
-				entry->vidPriority = 0;
-
-				entry->vidExInfo.useVIDFPri = (data & 0x8000)?GT_TRUE:GT_FALSE;
-				entry->vidExInfo.vidFPri = (data >> 12) & 0x7;
-
-				entry->vidExInfo.useVIDQPri = (data & 0x0800)?GT_TRUE:GT_FALSE;
-				entry->vidExInfo.vidQPri = (data >> 9) & 0x3;
-
-				entry->vidExInfo.vidNRateLimit = (data & 0x0100)?GT_TRUE:GT_FALSE;
-			}
-		}
-		/****************** upto 7 port switch *******************/
-
-		/****************** for the switch more than 7 ports *****************/
-
-		if(dev->maxPorts > 7)
-		{
-			/* fullsail has 3 ports, clippership has 7 prots */
-			entry->vtuData.memberTagP[7]  = (data >>12) & 3 ;
-			entry->vtuData.portStateP[7]  = (data >>14) & 3 ;
-
-			/* get data from data register for ports 4 to 6 */
-			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-			entry->vtuData.memberTagP[8]  = data & 3 ;
-			entry->vtuData.memberTagP[9]  = (data >> 4) & 3 ;
-			entry->vtuData.portStateP[8]  = (data >> 2) & 3 ;
-			entry->vtuData.portStateP[9]  = (data >> 6) & 3 ;
-
-			if(dev->maxPorts > 10)
-			{
-				entry->vtuData.memberTagP[10]  = (data >> 8) & 3 ;
-				entry->vtuData.portStateP[10]  = (data >> 10) & 3 ;
-			}
-
-			if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-			{
-				if (data & 0x8000)
-				{
-					entry->vidPriOverride = GT_TRUE;
-					entry->vidPriority = (data >> 12) & 0x7;
-				}
-				else
-				{
-					entry->vidPriOverride = GT_FALSE;
-					entry->vidPriority = 0;
-				}
-			}
-
-		}
-		else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-		{
-			/* get data from data register for ports 4 to 6 */
-			retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->vtuRegsSem);
-				return retVal;
-			}
-
-			if (data & 0x8000)
-			{
-				entry->vidPriOverride = GT_TRUE;
-				entry->vidPriority = (data >> 12) & 0x7;
-			}
-			else
-			{
-				entry->vidPriOverride = GT_FALSE;
-				entry->vidPriority = 0;
-			}
-		}
-
-		/****************** upto 11 ports switch *******************/
-
-	} /* end of get next entry */
-
-	gtSemGive(dev,dev->vtuRegsSem);
-	return GT_OK;
+    /* Set SID, FID, VIDPolicy, if it's Load operation */
+    if((vtuOp == LOAD_PURGE_ENTRY) && (*valid == 1))
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            data= (entry->sid) & 0x3F;
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }        
+        }
+
+        data = 0;
+
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+            {
+                data= entry->vidPolicy << 12;
+            }
+
+            data |= (entry->DBNum & 0xFFF);
+
+            retVal = hwWriteGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }        
+        }
+
+
+    }
+
+    /* Start the VTU Operation by defining the DBNum, vtuOp and VTUBusy    */
+    /* 
+     * Flush operation will skip the above two setup (for data and vid), and 
+     * come to here directly
+     */
+
+    if(vtuOp == FLUSH_ALL)
+        data = (1 << 15) | (vtuOp << 12);
+    else
+    {
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            data = (1 << 15) | (vtuOp << 12);
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+        {
+            /* Since DBNum is defined as GT_U8, it cannot be >= 256. */
+            #if 0
+            if(entry->DBNum >= 256)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }    
+            #endif
+            data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0xF0) << 4) | (entry->DBNum & 0x0F);
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+        {
+            if(entry->DBNum >= 64)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }    
+            data = (1 << 15) | (vtuOp << 12) | ((entry->DBNum & 0x30) << 4) | (entry->DBNum & 0x0F);
+        }
+        else
+        {
+            if(entry->DBNum >= 16)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return GT_BAD_PARAM;
+            }    
+            data = (1 << 15) | (vtuOp << 12) | entry->DBNum;
+        }
+    }
+
+    retVal = hwWriteGlobalReg(dev,QD_REG_VTU_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+    }
+
+    /* only two operations need to go through the mess below to get some data 
+     * after the operations -  service violation and get next entry
+     */
+
+    /* If the operation is to service violation operation wait for the response   */
+    if(vtuOp == SERVICE_VIOLATIONS)
+    {
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+  
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+          }
+        }
+#else
+        /* Wait until the VTU in ready. */
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /* get the Source Port ID that was involved in the violation */
+        retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        entry->DBNum = (GT_U8)(data & 0xF);
+
+        /* get the VID that was involved in the violation */
+
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* Get the vid - bits 0-11 */
+        entry->vid   = data & 0xFFF;
+
+
+    } /* end of service violations */
+
+    /* If the operation is a get next operation wait for the response   */
+    if(vtuOp == GET_NEXT_ENTRY)
+    {
+        entry->vidExInfo.useVIDFPri = GT_FALSE;
+        entry->vidExInfo.vidFPri = 0;
+
+        entry->vidExInfo.useVIDQPri = GT_FALSE;
+        entry->vidExInfo.vidQPri = 0;
+
+        entry->vidExInfo.vidNRateLimit = GT_FALSE;
+
+        entry->sid = 0;
+           entry->vidPolicy = GT_FALSE;
+
+        /* Wait until the VTU in ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 1;
+  
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_VTU_OPERATION;
+          regAccess.rw_reg_list[0].data = 15;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+        }
+#endif
+
+        /****************** get the vid *******************/
+
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_VID_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* the vid is bits 0-11 */
+        entry->vid   = data & 0xFFF;
+
+        /* the vid valid is bits 12 */
+        *valid   = (data >> 12) & 1;
+        
+        if (*valid == 0)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return GT_OK;
+        }
+
+        /****************** get the SID *******************/
+        if(IS_IN_DEV_GROUP(dev,DEV_802_1S_STU))
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_STU_SID_REG),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }        
+            entry->sid = data & 0x3F;
+        }
+
+        /****************** get the DBNum *******************/
+        if(IS_IN_DEV_GROUP(dev,DEV_FID_REG))
+        {
+            retVal = hwReadGlobalReg(dev,(GT_U8)(QD_REG_VTU_FID_REG),&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }        
+
+            if(IS_IN_DEV_GROUP(dev,DEV_POLICY))
+            {
+                entry->vidPolicy = (data >> 12) & 0x1;
+            }
+
+            entry->DBNum = data & 0xFFF;
+
+        }
+        else
+        {
+            retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,0,4,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            entry->DBNum = data & 0xF;
+        
+            if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_256))
+            {
+                retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,4,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->vtuRegsSem);
+                    return retVal;
+                }
+
+                entry->DBNum |= ((data & 0xF) << 4);
+            }
+            else if (IS_IN_DEV_GROUP(dev,DEV_DBNUM_64))
+            {
+                retVal = hwGetGlobalRegField(dev,QD_REG_VTU_OPERATION,8,2,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->vtuRegsSem);
+                    return retVal;
+                }
+
+                entry->DBNum |= ((data & 0x3) << 4);
+            }
+        }
+
+
+        /****************** get the MemberTagP *******************/
+        retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA1_REG,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->vtuRegsSem);
+            return retVal;
+        }
+
+        /* get data from data register for ports 0 to 2 */
+        entry->vtuData.memberTagP[0]  =  data & 3 ;
+        entry->vtuData.memberTagP[1]  = (data >> 4) & 3 ;
+        entry->vtuData.memberTagP[2]  = (data >> 8) & 3 ;
+        entry->vtuData.portStateP[0]  = (data >> 2) & 3 ;
+        entry->vtuData.portStateP[1]  = (data >> 6) & 3 ;
+        entry->vtuData.portStateP[2]  = (data >> 10) & 3 ;
+
+        /****************** for the switch more than 3 ports *****************/
+
+        if(dev->maxPorts > 3)
+        {
+            /* fullsail has 3 ports, clippership has 7 prots */
+            entry->vtuData.memberTagP[3]  = (data >>12) & 3 ;
+            entry->vtuData.portStateP[3]  = (data >>14) & 3 ;
+
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA2_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+            entry->vtuData.memberTagP[4]  = data & 3 ;
+            entry->vtuData.memberTagP[5]  = (data >> 4) & 3 ;
+            entry->vtuData.portStateP[4]  = (data >> 2) & 3 ;
+            entry->vtuData.portStateP[5]  = (data >> 6) & 3 ;
+
+            if(dev->maxPorts > 6)
+            {
+                entry->vtuData.memberTagP[6]  = (data >> 8) & 3 ;
+                entry->vtuData.portStateP[6]  = (data >> 10) & 3 ;
+            }
+            
+            if (IS_IN_DEV_GROUP(dev,DEV_VTU_EXT_INFO))
+            {
+                entry->vidPriOverride = 0;
+                entry->vidPriority = 0;
+
+                entry->vidExInfo.useVIDFPri = (data & 0x8000)?GT_TRUE:GT_FALSE;
+                entry->vidExInfo.vidFPri = (data >> 12) & 0x7;
+
+                entry->vidExInfo.useVIDQPri = (data & 0x0800)?GT_TRUE:GT_FALSE;
+                entry->vidExInfo.vidQPri = (data >> 9) & 0x3;
+
+                entry->vidExInfo.vidNRateLimit = (data & 0x0100)?GT_TRUE:GT_FALSE;
+            }
+        }
+        /****************** upto 7 port switch *******************/
+
+        /****************** for the switch more than 7 ports *****************/
+
+        if(dev->maxPorts > 7)
+        {
+            /* fullsail has 3 ports, clippership has 7 prots */
+            entry->vtuData.memberTagP[7]  = (data >>12) & 3 ;
+            entry->vtuData.portStateP[7]  = (data >>14) & 3 ;
+
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+            entry->vtuData.memberTagP[8]  = data & 3 ;
+            entry->vtuData.memberTagP[9]  = (data >> 4) & 3 ;
+            entry->vtuData.portStateP[8]  = (data >> 2) & 3 ;
+            entry->vtuData.portStateP[9]  = (data >> 6) & 3 ;
+
+            if(dev->maxPorts > 10)
+            {
+                entry->vtuData.memberTagP[10]  = (data >> 8) & 3 ;
+                entry->vtuData.portStateP[10]  = (data >> 10) & 3 ;
+            }
+
+            if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+            {
+                if (data & 0x8000)
+                {
+                    entry->vidPriOverride = GT_TRUE;
+                    entry->vidPriority = (data >> 12) & 0x7;
+                }
+                else
+                {
+                    entry->vidPriOverride = GT_FALSE;
+                    entry->vidPriority = 0;
+                }
+            }
+
+        }
+        else if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+        {
+            /* get data from data register for ports 4 to 6 */
+            retVal = hwReadGlobalReg(dev,QD_REG_VTU_DATA3_REG,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+            }
+
+            if (data & 0x8000)
+            {
+                entry->vidPriOverride = GT_TRUE;
+                entry->vidPriority = (data >> 12) & 0x7;
+            }
+            else
+            {
+                entry->vidPriOverride = GT_FALSE;
+                entry->vidPriority = 0;
+            }
+        }
+
+        /****************** upto 11 ports switch *******************/
+
+    } /* end of get next entry */
+
+    gtSemGive(dev,dev->vtuRegsSem);
+    return GT_OK;
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c
old mode 100644
new mode 100755
index 7333820..8195165
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtCCPVT.c
@@ -21,9 +21,9 @@
 /****************************************************************************/
 static GT_STATUS pvtOperationPerform
 (
-    IN   GT_QD_DEV 			*dev,
-    IN   GT_PVT_OPERATION	pvtOp,
-    INOUT GT_PVT_OP_DATA	*opData
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PVT_OPERATION    pvtOp,
+    INOUT GT_PVT_OP_DATA    *opData
 );
 
 
@@ -34,7 +34,7 @@ static GT_STATUS pvtOperationPerform
 *       This routine initializes the PVT Table to all one's (initial state)
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
 *       None.
@@ -50,32 +50,32 @@ static GT_STATUS pvtOperationPerform
 *******************************************************************************/
 GT_STATUS gpvtInitialize
 (
-	IN  GT_QD_DEV 	*dev
+    IN  GT_QD_DEV     *dev
 )
 {
-	GT_STATUS       	retVal;
-	GT_PVT_OPERATION	op;
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
 
-	DBG_INFO(("gpvtInitialize Called.\n"));
+    DBG_INFO(("gpvtInitialize Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	/* Program Tuning register */
-	op = PVT_INITIALIZE;
-	retVal = pvtOperationPerform(dev,op,NULL);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    /* Program Tuning register */
+    op = PVT_INITIALIZE;
+    retVal = pvtOperationPerform(dev,op,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -85,35 +85,35 @@ GT_STATUS gpvtInitialize
 *
 * DESCRIPTION:
 *       This routine write Cross Chip Port Vlan Data.
-*		Cross chip Port VLAN Data used as a bit mask to limit where cross chip
-*		frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
-*		API). Cross chip frames are Forward frames that ingress a DSA or Ether 
-*		Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
-*		bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
-*		to egress that port on this device. When a port's mask bit is zero,
-*		frames are not allowed to egress that port on this device.
-*
-*		The Cross Chip Port VLAN Table is accessed by ingressing frames based
-*		upon the original source port of the frame using the Forward frame's DSA tag
-*		fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
-*		that is accessed by the frame is:
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 0:
-*				If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
-*				If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 1:
-*				If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
-*				If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
-*
-*		Cross chip port VLANs with Trunks are supported in the table where this
-*		device's entries would be stored (defined by this device's Device Number).
-*		This portion of the table is available for Trunk entries because this device's
-*		port VLAN mappings to ports inside this device are masked by the port's
-*		VLAN Table (see gvlnSetPortVlanPorts API).
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether 
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
 *
 *
 * INPUTS:
-*		pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
-*		pvtData    - Cross Chip Port Vlan Data
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtData    - Cross Chip Port Vlan Data
 *
 * OUTPUTS:
 *       None.
@@ -121,7 +121,7 @@ GT_STATUS gpvtInitialize
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -130,58 +130,58 @@ GT_STATUS gpvtInitialize
 *******************************************************************************/
 GT_STATUS gpvtWritePVTData
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		pvtPointer,
-	IN  GT_U32		pvtData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    IN  GT_U32        pvtData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PVT_OPERATION	op;
-	GT_PVT_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+    GT_PVT_OP_DATA        opData;
 
-	DBG_INFO(("gpvtWritePVTData Called.\n"));
+    DBG_INFO(("gpvtWritePVTData Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given pointer is valid */
-	if (pvtPointer > 0x1FF)
+    if (pvtPointer > 0x1FF)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
     /* check if the given pvtData is valid */
-	if (pvtData >= (GT_U32)(1 << dev->maxPorts))
+    if (pvtData >= (GT_U32)(1 << dev->maxPorts))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* Program Tuning register */
-	op = PVT_WRITE;
-	opData.pvtAddr = pvtPointer;
+    /* Program Tuning register */
+    op = PVT_WRITE;
+    opData.pvtAddr = pvtPointer;
 
-	if((opData.pvtData = GT_LPORTVEC_2_PORTVEC(pvtData)) == GT_INVALID_PORT_VEC)
-	{
-		DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+    if((opData.pvtData = GT_LPORTVEC_2_PORTVEC(pvtData)) == GT_INVALID_PORT_VEC)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
 
 
-	retVal = pvtOperationPerform(dev,op,&opData);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
-		return retVal;
-	}
+    retVal = pvtOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -191,42 +191,42 @@ GT_STATUS gpvtWritePVTData
 *
 * DESCRIPTION:
 *       This routine reads Cross Chip Port Vlan Data.
-*		Cross chip Port VLAN Data used as a bit mask to limit where cross chip
-*		frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
-*		API). Cross chip frames are Forward frames that ingress a DSA or Ether 
-*		Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
-*		bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
-*		to egress that port on this device. When a port's mask bit is zero,
-*		frames are not allowed to egress that port on this device.
-*
-*		The Cross Chip Port VLAN Table is accessed by ingressing frames based
-*		upon the original source port of the frame using the Forward frame's DSA tag
-*		fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
-*		that is accessed by the frame is:
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 0:
-*				If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
-*				If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
-*			If 5 Bit Port (in Global 2, offset 0x1D) = 1:
-*				If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
-*				If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
-*
-*		Cross chip port VLANs with Trunks are supported in the table where this
-*		device's entries would be stored (defined by this device's Device Number).
-*		This portion of the table is available for Trunk entries because this device's
-*		port VLAN mappings to ports inside this device are masked by the port's
-*		VLAN Table (see gvlnSetPortVlanPorts API).
+*        Cross chip Port VLAN Data used as a bit mask to limit where cross chip
+*        frames can egress (in chip Port VLANs are masked using gvlnSetPortVlanPorts
+*        API). Cross chip frames are Forward frames that ingress a DSA or Ether 
+*        Type DSA port (see gprtSetFrameMode API). Bit 0 is a mask for port 0, 
+*        bit 1 for port 1, etc. When a port's mask bit is one, frames are allowed 
+*        to egress that port on this device. When a port's mask bit is zero,
+*        frames are not allowed to egress that port on this device.
+*
+*        The Cross Chip Port VLAN Table is accessed by ingressing frames based
+*        upon the original source port of the frame using the Forward frame's DSA tag
+*        fields Src_Dev, Src_Port/Src_Trunk and Src_Is_Trunk. The 1 entry of the 512
+*        that is accessed by the frame is:
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 0:
+*                If Src_Is_Trunk = 0   Src_Dev[4:0], Src_Port[3:0]119
+*                If Src_Is_Trunk = 1   Device Number (global offset 0x1C), Src_Trunk[3:0]
+*            If 5 Bit Port (in Global 2, offset 0x1D) = 1:
+*                If Src_Is_Trunk = 0   Src_Dev[3:0], Src_Port[4:0]120
+*                If Src_Is_Trunk = 1   Device Number[3:0], Src_Trunk[4:0]
+*
+*        Cross chip port VLANs with Trunks are supported in the table where this
+*        device's entries would be stored (defined by this device's Device Number).
+*        This portion of the table is available for Trunk entries because this device's
+*        port VLAN mappings to ports inside this device are masked by the port's
+*        VLAN Table (see gvlnSetPortVlanPorts API).
 *
 *
 * INPUTS:
-*		pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
+*        pvtPointer - pointer to the desired entry of PVT (0 ~ 511)
 *
 * OUTPUTS:
-*		pvtData    - Cross Chip Port Vlan Data
+*        pvtData    - Cross Chip Port Vlan Data
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -235,46 +235,46 @@ GT_STATUS gpvtWritePVTData
 *******************************************************************************/
 GT_STATUS gpvtReadPVTData
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		pvtPointer,
-	OUT GT_U32		*pvtData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        pvtPointer,
+    OUT GT_U32        *pvtData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PVT_OPERATION	op;
-	GT_PVT_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PVT_OPERATION    op;
+    GT_PVT_OP_DATA        opData;
 
-	DBG_INFO(("gpvtReadPVTData Called.\n"));
+    DBG_INFO(("gpvtReadPVTData Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
+    if (!IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_PORT_VLAN))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given pointer is valid */
-	if (pvtPointer > 0x1FF)
+    if (pvtPointer > 0x1FF)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* Program Tuning register */
-	op = PVT_READ;
-	opData.pvtAddr = pvtPointer;
-	retVal = pvtOperationPerform(dev,op,&opData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    /* Program Tuning register */
+    op = PVT_READ;
+    opData.pvtAddr = pvtPointer;
+    retVal = pvtOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (pvtOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	opData.pvtData &= (1 << dev->maxPorts) - 1;
-	*pvtData = GT_PORTVEC_2_LPORTVEC(opData.pvtData);
+    opData.pvtData &= (1 << dev->maxPorts) - 1;
+    *pvtData = GT_PORTVEC_2_LPORTVEC(opData.pvtData);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -311,12 +311,30 @@ static GT_STATUS pvtOperationPerform
     INOUT GT_PVT_OP_DATA     *opData
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
 
     gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
     /* Wait until the pvt in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PVT_ADDR;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -327,73 +345,93 @@ static GT_STATUS pvtOperationPerform
             return retVal;
         }
     }
+#endif
 
     /* Set the PVT Operation register */
-	switch (pvtOp)
-	{
-		case PVT_INITIALIZE:
-			data = (1 << 15) | (pvtOp << 12);
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->tblRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PVT_WRITE:
-			data = (GT_U16)opData->pvtData;
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_DATA,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->tblRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->tblRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PVT_READ:
-			data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->tblRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_PVT_ADDR,15,1,&data);
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->tblRegsSem);
-		            return retVal;
-        		}
-		    }
-
-			retVal = hwReadGlobal2Reg(dev,QD_REG_PVT_DATA,&data);
-			opData->pvtData = (GT_U32)data;
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->tblRegsSem);
-            	return retVal;
-	        }
-	
-			break;
-
-		default:
-			
-			gtSemGive(dev,dev->tblRegsSem);
-			return GT_FAIL;
-	}
+    switch (pvtOp)
+    {
+        case PVT_INITIALIZE:
+            data = (1 << 15) | (pvtOp << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PVT_WRITE:
+            data = (GT_U16)opData->pvtData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PVT_READ:
+            data = (GT_U16)((1 << 15) | (pvtOp << 12) | opData->pvtAddr);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PVT_ADDR,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+  
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PVT_ADDR;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PVT_ADDR,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->tblRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PVT_DATA,&data);
+            opData->pvtData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+    
+            break;
+
+        default:
+            
+            gtSemGive(dev,dev->tblRegsSem);
+            return GT_FAIL;
+    }
 
     gtSemGive(dev,dev->tblRegsSem);
     return retVal;
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtEvents.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtEvents.c
old mode 100644
new mode 100755
index 1f6b020..3901086
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtEvents.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtEvents.c
@@ -24,9 +24,9 @@
 *
 * INPUTS:
 *       eventType - the event type. any combination of the folowing: 
-*       	GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL(or GT_ATU_PROB),
-*       	GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
-*			and GT_AVB_INTERRUPT
+*           GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL(or GT_ATU_PROB),
+*           GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
+*            and GT_AVB_INTERRUPT
 *
 * OUTPUTS:
 *       None.
@@ -37,53 +37,53 @@
 *
 * COMMENTS:
 *       Each switch device has its own set of event Types. Please refer to the
-*		device datasheet for the list of event types that the device supports.
+*        device datasheet for the list of event types that the device supports.
 *
 *******************************************************************************/
 GT_STATUS eventSetActive
 (
     IN GT_QD_DEV *dev,
-    IN GT_U32 	 eventType
+    IN GT_U32      eventType
 )
 {
     GT_STATUS   retVal;   
-    GT_U16 	data;
-	GT_U16	intMask;
-    GT_U8 	len;
+    GT_U16     data;
+    GT_U16    intMask;
+    GT_U8     len;
 
     DBG_INFO(("eventSetActive Called.\n"));
 
-	data = (GT_U16) eventType;
-	len = 9;
+    data = (GT_U16) eventType;
+    len = 9;
 
-	if ((IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY_ONLY)) || 
-		(IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT)))
+    if ((IS_IN_DEV_GROUP(dev,DEV_EXTERNAL_PHY_ONLY)) || 
+        (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT)))
     {
-		intMask = GT_NO_INTERNAL_PHY_INT_MASK;
+        intMask = GT_NO_INTERNAL_PHY_INT_MASK;
+    }
+    else
+    {
+        intMask = GT_INT_MASK;
     }
-	else
-	{
-		intMask = GT_INT_MASK;
-	}
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
-	{
-		intMask &= ~GT_AVB_INT;
-		len = 8;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
+    {
+        intMask &= ~GT_AVB_INT;
+        len = 8;
+    }
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
-	{
-		intMask &= ~GT_DEVICE_INT;
-		len = 7;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    {
+        intMask &= ~GT_DEVICE_INT;
+        len = 7;
+    }
 
-	
-	if(data & ~intMask)
-	{
-	    DBG_INFO(("Invalid event type.\n"));
-		return GT_FAIL;
-	}
+    
+    if(data & ~intMask)
+    {
+        DBG_INFO(("Invalid event type.\n"));
+        return GT_FAIL;
+    }
 
     /* Set the IntEn bit.               */
     retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,0,len,data);
@@ -108,11 +108,11 @@ GT_STATUS eventSetActive
 *
 * OUTPUTS:
 *       intCause - It provides the source of interrupt of the following:
-*       		GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
-*       		GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
-*				and GT_AVB_INTERRUPT
-*				For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_PROB and 
-*				if there is no internal phy, GT_PHY_INTERRUPT is not supported.
+*               GT_STATS_DONE, GT_VTU_PROB, GT_VTU_DONE, GT_ATU_FULL,  
+*               GT_ATU_DONE, GT_PHY_INTERRUPT, GT_EE_INTERRUPT, GT_DEVICE_INT,
+*                and GT_AVB_INTERRUPT
+*                For Gigabit Switch, GT_ATU_FULL is replaced with GT_ATU_PROB and 
+*                if there is no internal phy, GT_PHY_INTERRUPT is not supported.
 *
 * RETURNS:
 *       GT_OK   - read success.
@@ -120,7 +120,7 @@ GT_STATUS eventSetActive
 *
 * COMMENTS:
 *       Each switch device has its own set of event Types. Please refer to the
-*		device datasheet for the list of event types that the device supports.
+*        device datasheet for the list of event types that the device supports.
 *
 *******************************************************************************/
 GT_STATUS eventGetIntStatus
@@ -129,15 +129,15 @@ GT_STATUS eventGetIntStatus
     OUT GT_U16   *intCause
 )
 {
-    GT_STATUS 	retVal;         /* Function calls return value.     */
-    GT_U8 		len;
+    GT_STATUS     retVal;         /* Function calls return value.     */
+    GT_U8         len;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
-		len = 9;
-	else if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
-		len = 8;
-	else
-		len = 7;
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_INTERRUPT))
+        len = 9;
+    else if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+        len = 8;
+    else
+        len = 7;
 
     retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,0,len,intCause);
 
@@ -153,21 +153,21 @@ GT_STATUS eventGetIntStatus
 *
 * INPUTS:
 *       intType - the type of interrupt which causes an interrupt.
-*			any combination of 
-*			GT_MEMEBER_VIOLATION,
-*			GT_MISS_VIOLATION,
-*			GT_FULL_VIOLATION
+*            any combination of 
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK - on success
-* 		GT_FAIL - on error
+*         GT_OK - on success
+*         GT_FAIL - on error
 *
 * COMMENTS:
-* 	FULL_VIOLATION is not supported by all switch devices.
-*	Please refer to the device datasheet.
+*     FULL_VIOLATION is not supported by all switch devices.
+*    Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gvtuGetIntStatus
@@ -184,27 +184,28 @@ GT_STATUS gvtuGetIntStatus
     if((IS_VALID_API_CALL(dev,1, DEV_802_1Q)) != GT_OK ) 
       return GT_FAIL; 
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-	    retVal = gvtuGetViolation2(dev,vtuIntStatus);
-	}
-	else if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-	{
-	    retVal = gvtuGetViolation3(dev,vtuIntStatus);
-	}
-	else
-	{
-	    retVal = gvtuGetViolation(dev,vtuIntStatus);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = gvtuGetViolation2(dev,vtuIntStatus);
+    }
+    else if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+	     	 (IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = gvtuGetViolation3(dev,vtuIntStatus);
+    }
+    else
+    {
+        retVal = gvtuGetViolation(dev,vtuIntStatus);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     
     return retVal;
 }
@@ -216,20 +217,20 @@ GT_STATUS gvtuGetIntStatus
 * Check to see if a specific type of ATU interrupt occured
 *
 * INPUTS:
-*      	intType - the type of interrupt which causes an interrupt.
-*			any combination of 
-*			GT_AGE_OUT_VIOLATION,
-*			GT_AGE_VIOLATION,
-*			GT_MEMEBER_VIOLATION,
-*			GT_MISS_VIOLATION,
-*			GT_FULL_VIOLATION 
+*          intType - the type of interrupt which causes an interrupt.
+*            any combination of 
+*            GT_AGE_OUT_VIOLATION,
+*            GT_AGE_VIOLATION,
+*            GT_MEMEBER_VIOLATION,
+*            GT_MISS_VIOLATION,
+*            GT_FULL_VIOLATION 
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK - on success
-* 		GT_FAIL - on error
+*         GT_OK - on success
+*         GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -246,21 +247,23 @@ GT_STATUS gatuGetIntStatus
     DBG_INFO(("gatuGetIntStatus Called.\n"));
    
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     retVal = gatuGetViolation(dev,atuIntStatus);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     
     return retVal;
 }
@@ -270,34 +273,35 @@ GT_STATUS gatuGetIntStatus
 * geventGetDevIntStatus
 *
 * DESCRIPTION:
-* 		Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch,
-*		SERDES Link Int, and Phy Int) have occurred.
+*         Check to see which device interrupts (WatchDog, JamLimit, Duplex Mismatch,
+*        SERDES Link Int, and Phy Int) have occurred.
 *
 * INPUTS:
 *       intType - the type of interrupt which causes an interrupt.
-*				  any combination of 
-*					GT_DEV_INT_WATCHDOG,
-*					GT_DEV_INT_JAMLIMIT,
-*					GT_DEV_INT_DUPLEX_MISMATCH,
-*					GT_DEV_INT_SERDES_LINK
-*					GT_DEV_INT_PHY
-*		port	- logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
-*				  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
-*		linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
-*				  asserted. It's in vector format, Bit 10 is for port 10, 
-*				  Bit 9 is for port 9, etc.
-*				  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
-*				  These bits are only valid of the port that is in 1000Base-X mode.
-*		phyInt  - port list where GT_DEV_INT_PHY interrupt is asserted.
-*				  It's in vector format, Bit 0 is for port 0, Bit 1 is for port 1, etc.
-*				  valid only if GT_DEV_INT_PHY bit is set in intType.
+*                  any combination of 
+*                    GT_DEV_INT_WATCHDOG,
+*                    GT_DEV_INT_JAMLIMIT,
+*                    GT_DEV_INT_DUPLEX_MISMATCH,
+*                    GT_DEV_INT_SERDES_LINK
+*                    GT_DEV_INT_WAKE_EVENT
+*                    GT_DEV_INT_PHY
+*        port    - logical port where GT_DEV_INT_DUPLEX_MISMATCH occurred.
+*                  valid only if GT_DEV_INT_DUPLEX_MISMATCH is set in intType.
+*        linkInt - SERDES port list where GT_DEV_INT_SERDES_LINK interrupt is
+*                  asserted. It's in vector format, Bit 10 is for port 10, 
+*                  Bit 9 is for port 9, etc.
+*                  valid only if GT_DEV_INT_SERDES_LINK bit is set in intType.
+*                  These bits are only valid of the port that is in 1000Base-X mode.
+*        phyInt  - port list where GT_DEV_INT_PHY interrupt is asserted.
+*                  It's in vector format, Bit 0 is for port 0, Bit 1 is for port 1, etc.
+*                  valid only if GT_DEV_INT_PHY bit is set in intType.
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK - on success
-* 		GT_FAIL - on error
+*         GT_OK - on success
+*         GT_FAIL - on error
 *
 * COMMENTS:
 *
@@ -305,88 +309,104 @@ GT_STATUS gatuGetIntStatus
 
 GT_STATUS geventGetDevIntStatus
 (
-    IN  GT_QD_DEV 			*dev,
-    OUT GT_DEV_INT_STATUS	*devIntStatus
+    IN  GT_QD_DEV             *dev,
+    OUT GT_DEV_INT_STATUS    *devIntStatus
 )
 {
     GT_STATUS       retVal;
-	GT_U16			data, hwPort;
+    GT_U16            data, hwPort;
 
     DBG_INFO(("geventGetDevIntStatus Called.\n"));
    
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
-	
-	devIntStatus->devIntCause = 0;
+    
+    devIntStatus->devIntCause = 0;
 
     retVal = hwReadGlobal2Reg(dev,QD_REG_DEVINT_SOURCE,&data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-
-	/* check SERDES Link Int and Phy Int, if applicable */
-	if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
-	{
-		/* check SERDES Link Int */
-		if (data & (0x7 << 8))
-		{
-			devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
-			devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (7<<8)));
-		}
-	}
-	else	/* DEV_DEVICE_INT_TYPE2 */
-	{
-		if (data & (0x3 << 11))
-		{
-			devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
-			devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (0x3 << 11)) >> 7);
-		}
-
-		if (data & 0x1F)
-		{
-			devIntStatus->devIntCause |= GT_DEV_INT_PHY;
-			devIntStatus->phyInt = GT_PORTVEC_2_LPORTVEC((data & 0x1F));
-		}
-	}
-
-	if (data & QD_DEV_INT_DUPLEX_MISMATCH)
-	{
-		devIntStatus->devIntCause |= GT_DEV_INT_DUPLEX_MISMATCH;
-
-		/* read port that causes the interrupt */
-	    retVal = hwGetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, &hwPort);
-	    if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Failed.\n"));
-			return retVal;
-		}
-
-		/* re-arm the interrupt event */
-	    retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
-	    if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Failed.\n"));
-			return retVal;
-		}
-
-		devIntStatus->port = GT_PORT_2_LPORT((GT_U8)hwPort);
-	}
-	    
-	if (data & QD_DEV_INT_WATCHDOG)
-	{
-		devIntStatus->devIntCause |= GT_DEV_INT_WATCHDOG;
-	}
-
-	if (data & QD_DEV_INT_JAMLIMIT)
-	{
-		devIntStatus->devIntCause |= GT_DEV_INT_JAMLIMIT;
-	}
+        return retVal;
+    }
+
+    /* check SERDES Link Int and Phy Int, if applicable */
+    if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+    {
+        /* check SERDES Link Int */
+        if (data & (0x7 << 8))
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
+            devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (7<<8)));
+        }
+    }
+    else  if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE2))  /* DEV_DEVICE_INT_TYPE2 */
+    {
+        if (data & (0x3 << 11))
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_SERDES_LINK;
+            devIntStatus->linkInt = GT_PORTVEC_2_LPORTVEC((data & (0x3 << 11)) >> 7);
+        }
+
+        if (data & 0x1F)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_PHY;
+            devIntStatus->phyInt = GT_PORTVEC_2_LPORTVEC((data & 0x1F));
+        }
+    }
+    else /* DEV_DEVICE_INT_TYPE3 */
+    {
+	  if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE3))  /* DEV_DEVICE_INT_TYPE3 */
+	  {
+        if (data & QD_DEV_INT_WAKE_EVENT)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_WAKE_EVENT;
+        }
+	  }
+
+        if (data & 0x1F)
+        {
+            devIntStatus->devIntCause |= GT_DEV_INT_PHY;
+            devIntStatus->phyInt = GT_PORTVEC_2_LPORTVEC((data & 0x1F));
+        }
+    }
+
+    if (data & QD_DEV_INT_DUPLEX_MISMATCH)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_DUPLEX_MISMATCH;
+
+        /* read port that causes the interrupt */
+        retVal = hwGetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, &hwPort);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        /* re-arm the interrupt event */
+        retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        devIntStatus->port = GT_PORT_2_LPORT((GT_U8)hwPort);
+    }
+        
+    if (data & QD_DEV_INT_WATCHDOG)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_WATCHDOG;
+    }
+
+    if (data & QD_DEV_INT_JAMLIMIT)
+    {
+        devIntStatus->devIntCause |= GT_DEV_INT_JAMLIMIT;
+    }
 
     return retVal;
 }
@@ -396,33 +416,33 @@ GT_STATUS geventGetDevIntStatus
 * geventSetAgeIntEn
 *
 * DESCRIPTION:
-*		This routine enables/disables Age Interrupt for a port.
-*		When it's enabled, ATU Age Violation interrupts from this port are enabled.
-*		An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
-*		and the ingressing frame's SA is contained in the ATU as a non-Static 
-*		entry with a EntryState less than 0x4.
+*        This routine enables/disables Age Interrupt for a port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
+*        and the ingressing frame's SA is contained in the ATU as a non-Static 
+*        entry with a EntryState less than 0x4.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Interrupt,
-*			   GT_FALUSE to disable
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventSetAgeIntEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -434,10 +454,10 @@ GT_STATUS geventSetAgeIntEn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -447,13 +467,13 @@ GT_STATUS geventSetAgeIntEn
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,11,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -461,33 +481,33 @@ GT_STATUS geventSetAgeIntEn
 * geventGetAgeIntEn
 *
 * DESCRIPTION:
-*		This routine gets Age Interrupt Enable for the port.
-*		When it's enabled, ATU Age Violation interrupts from this port are enabled.
-*		An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
-*		and the ingressing frame's SA is contained in the ATU as a non-Static 
-*		entry with a EntryState less than 0x4.
+*        This routine gets Age Interrupt Enable for the port.
+*        When it's enabled, ATU Age Violation interrupts from this port are enabled.
+*        An Age Violation will occur anytime a port is Locked(gprtSetLockedPort) 
+*        and the ingressing frame's SA is contained in the ATU as a non-Static 
+*        entry with a EntryState less than 0x4.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Interrupt,
-*			   GT_FALUSE to disable
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventGetAgeIntEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -499,23 +519,23 @@ GT_STATUS geventGetAgeIntEn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_BASED_AGE_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Age Interrupt Enable Mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,11,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -527,32 +547,32 @@ GT_STATUS geventGetAgeIntEn
 * geventSetAgeOutIntEn
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Age Out Interrupt,
-*			   GT_FALUSE to disable
+*        port - the logical port number
+*        mode - GT_TRUE to enable Age Out Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventSetAgeOutIntEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -564,10 +584,10 @@ GT_STATUS geventSetAgeOutIntEn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -577,13 +597,13 @@ GT_STATUS geventSetAgeOutIntEn
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -591,31 +611,31 @@ GT_STATUS geventSetAgeOutIntEn
 * geventGetAgeOutIntEn
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		mode - GT_TRUE, if Age Out Interrupt is enabled
-*			   GT_FALUSE, otherwise
+*        mode - GT_TRUE, if Age Out Interrupt is enabled
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventGetAgeOutIntEn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -627,23 +647,23 @@ GT_STATUS geventGetAgeOutIntEn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Age Out Interrupt Enable Mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -655,31 +675,31 @@ GT_STATUS geventGetAgeOutIntEn
 * geventSetOverLimitInt
 *
 * DESCRIPTION:
-*		This routine enables/disables Over Limit Interrupt for a port.
-*		If it's enabled, an ATU Miss violation will be generated when port auto
-*		learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbGetPortAtuLimitReached API).
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_TRUE to enable Over Limit Interrupt,
-*			   GT_FALUSE to disable
+*        port - the logical port number
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventSetOverLimitInt
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -691,10 +711,10 @@ GT_STATUS geventSetOverLimitInt
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -704,13 +724,13 @@ GT_STATUS geventSetOverLimitInt
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 13, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -718,30 +738,30 @@ GT_STATUS geventSetOverLimitInt
 * geventGetOverLimitInt
 *
 * DESCRIPTION:
-*		This routine enables/disables Over Limit Interrupt for a port.
-*		If it's enabled, an ATU Miss violation will be generated when port auto
-*		learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
+*        This routine enables/disables Over Limit Interrupt for a port.
+*        If it's enabled, an ATU Miss violation will be generated when port auto
+*        learn reached the limit(refer to gfdbSetPortAtuLearnLimit API).
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable Over Limit Interrupt,
-*			   GT_FALUSE to disable
+*        mode - GT_TRUE to enable Over Limit Interrupt,
+*               GT_FALUSE to disable
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS geventGetOverLimitInt
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -753,23 +773,23 @@ GT_STATUS geventGetOverLimitInt
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Set Over Limit Interrupt Enable Mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ATU_CONTROL, 13, 1, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -781,15 +801,15 @@ GT_STATUS geventGetOverLimitInt
 *
 * DESCRIPTION:
 *       This routine checks if learn limit has been reached.
-*		When it reached, the port can no longer auto learn any more MAC addresses
-*		because the address learn limit set on this port has been reached.
+*        When it reached, the port can no longer auto learn any more MAC addresses
+*        because the address learn limit set on this port has been reached.
 *
 * INPUTS:
 *       port  - logical port number
-*											  
+*                                              
 * OUTPUTS:
 *       limit - GT_TRUE, if limit has been reached
-*			    GT_FALSE, otherwise
+*                GT_FALSE, otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -803,9 +823,9 @@ GT_STATUS geventGetOverLimitInt
 *******************************************************************************/
 GT_STATUS geventGetPortAtuLimitReached
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT  	port,
-    IN  GT_BOOL   	*limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT      port,
+    IN  GT_BOOL       *limit
 )
 {
     GT_U16          data;
@@ -817,10 +837,10 @@ GT_STATUS geventGetPortAtuLimitReached
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check device if this feature is supported. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
+    /* Check device if this feature is supported. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ATU_LIMIT))
     {
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the LimitReached bit. */
@@ -841,166 +861,178 @@ GT_STATUS geventGetPortAtuLimitReached
 * eventSetDevInt
 *
 * DESCRIPTION:
-*		Device Interrupt.
-*		The following device interrupts are supported:
-*			GT_DEV_INT_WATCHDOG	- 
-*				WatchDog event interrupt (WatchDog event can be configured with 
-*				gwdSetEvent API)
-*			GT_DEV_INT_JAMLIMIT	-
-*				any of the ports detect an Ingress Jam Limit violation
-*				(see gprtSetPauseLimitIn API)
-*			GT_DEV_INT_DUPLEX_MISMATCH - 
-*				any of the ports detect a duplex mismatch (i.e., the local port is 
-*				in half duplex mode while the link partner is in full duplex mode)
-*			GT_DEV_INT_SERDES_LINK - 
-*				SERDES link change interrupt.
-*				An interrupt occurs when a SERDES port changes link status
-*				(link up or link down)
-*			GT_DEV_INT_PHY - Phy interrupt.
-*			
-*		If any of the above events is enabled, GT_DEVICE_INT interrupt will
-*		be asserted by the enabled event when GT_DEV_INT is enabled with 
-*		eventSetActive API.
-*		
+*        Device Interrupt.
+*        The following device interrupts are supported:
+*            GT_DEV_INT_WATCHDOG    - 
+*                WatchDog event interrupt (WatchDog event can be configured with 
+*                gwdSetEvent API)
+*            GT_DEV_INT_JAMLIMIT    -
+*                any of the ports detect an Ingress Jam Limit violation
+*                (see gprtSetPauseLimitIn API)
+*            GT_DEV_INT_DUPLEX_MISMATCH - 
+*                any of the ports detect a duplex mismatch (i.e., the local port is 
+*                in half duplex mode while the link partner is in full duplex mode)
+*            GT_DEV_INT_WAKE_EVENT - 
+*                any of the ports detect a Wake event interrupt
+*            GT_DEV_INT_SERDES_LINK - 
+*                SERDES link change interrupt.
+*                An interrupt occurs when a SERDES port changes link status
+*                (link up or link down)
+*            GT_DEV_INT_PHY - Phy interrupt.
+*            
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled event when GT_DEV_INT is enabled with 
+*        eventSetActive API.
+*        
 * INPUTS:
-*		devInt - GT_DEV_INT
+*        devInt - GT_DEV_INT
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS eventSetDevInt
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_DEV_EVENT    *devInt
+    IN  GT_QD_DEV    *dev,
+    IN  GT_DEV_EVENT    *devInt
 )
 {
-	GT_U16          data, event;
-	GT_U16			serdesMask, phyMask, mask;
-	GT_U32			pList;
+    GT_U16          data, event;
+    GT_U16            serdesMask=0, phyMask=0, mask=0;
+    GT_U32            pList;
     GT_STATUS       retVal;         /* Functions return value.      */
 
     DBG_INFO(("eventSetDevInt Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_DEVICE_INTERRUPT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	event = (GT_U16)devInt->event;
-
-	if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
-	{
-		serdesMask = mask = 7 << 8;	/* SERDES Port List */
-		phyMask = 0;
-	}
-	else
-	{
-		serdesMask = mask = 3 << 11;	/* SERDES Port List */
-		mask |= 0x1F;	/* Phy list */
-		phyMask = 0x1F;
-	}
-	mask |= QD_DEV_INT_WATCHDOG | QD_DEV_INT_JAMLIMIT | QD_DEV_INT_DUPLEX_MISMATCH;
-
-	data = 0;
-
- 	if (event & GT_DEV_INT_SERDES_LINK)
- 	{
-		/* check for valid SERDES Port List */
-		if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
-		{
-			pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
-			if ((GT_U16)pList & (~serdesMask))
-			{
-		        DBG_INFO(("GT_BAD_PARAM portList\n"));
-				return GT_BAD_PARAM;
-			}
-			data = (GT_U16)pList;
-		}
-		else
-		{
-			pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
-			pList <<= 7;
-			if ((GT_U16)pList & (~serdesMask))
-			{
-		        DBG_INFO(("GT_BAD_PARAM portList\n"));
-				return GT_BAD_PARAM;
-			}
-			data = (GT_U16)pList;
-		}
-	}
-
-	if (event & GT_DEV_INT_PHY)
-	{
-		/* check for valid Phy List */
-		if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
- 		{
-	        DBG_INFO(("GT_BAD_PARAM: PHY Int not supported.\n"));
- 			return GT_BAD_PARAM;
- 		}
-		else
-		{
-			pList = GT_LPORTVEC_2_PORTVEC(devInt->phyList);
-			if ((GT_U16)pList & (~phyMask))
-			{
-		        DBG_INFO(("GT_BAD_PARAM phyList\n"));
-				return GT_BAD_PARAM;
-			}
-
-			data |= (GT_U16)pList;
-		}
- 	}
-
-	if (event & GT_DEV_INT_WATCHDOG)
-	{
-		data |= QD_DEV_INT_WATCHDOG;
-	}
-
-	if (event & GT_DEV_INT_JAMLIMIT)
-	{
-		data |= QD_DEV_INT_JAMLIMIT;
-	}
-
-	if (event & GT_DEV_INT_DUPLEX_MISMATCH)
-	{
-		data |= QD_DEV_INT_DUPLEX_MISMATCH;
-	}
-
-	if (data & (~mask))
-	{
+        return GT_NOT_SUPPORTED;
+    }
+
+    event = (GT_U16)devInt->event;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+    {
+        serdesMask = mask = 7 << 8;    /* SERDES Port List */
+        phyMask = 0;
+    }
+    else if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE2))
+    {
+        serdesMask = mask = 3 << 11;    /* SERDES Port List */
+        mask |= 0x1F;    /* Phy list */
+        phyMask = 0x1F;
+    }
+    else 
+    {
+        mask |= 0x1F;    /* Phy list */
+        phyMask = 0x1F;
+    }
+    mask |= QD_DEV_INT_WATCHDOG | QD_DEV_INT_JAMLIMIT | QD_DEV_INT_DUPLEX_MISMATCH | QD_DEV_INT_WAKE_EVENT ;
+
+    data = 0;
+
+     if (event & GT_DEV_INT_SERDES_LINK)
+     {
+        /* check for valid SERDES Port List */
+        if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
+            if ((GT_U16)pList & (~serdesMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM portList\n"));
+                return GT_BAD_PARAM;
+            }
+            data = (GT_U16)pList;
+        }
+        else
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->portList);
+            pList <<= 7;
+            if ((GT_U16)pList & (~serdesMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM portList\n"));
+                return GT_BAD_PARAM;
+            }
+            data = (GT_U16)pList;
+        }
+    }
+
+    if (event & GT_DEV_INT_PHY)
+    {
+        /* check for valid Phy List */
+        if (IS_IN_DEV_GROUP(dev,DEV_DEVICE_INT_TYPE1))
+         {
+            DBG_INFO(("GT_BAD_PARAM: PHY Int not supported.\n"));
+             return GT_BAD_PARAM;
+         }
+        else
+        {
+            pList = GT_LPORTVEC_2_PORTVEC(devInt->phyList);
+            if ((GT_U16)pList & (~phyMask))
+            {
+                DBG_INFO(("GT_BAD_PARAM phyList\n"));
+                return GT_BAD_PARAM;
+            }
+
+            data |= (GT_U16)pList;
+        }
+     }
+
+    if (event & GT_DEV_INT_WATCHDOG)
+    {
+        data |= QD_DEV_INT_WATCHDOG;
+    }
+
+    if (event & GT_DEV_INT_JAMLIMIT)
+    {
+        data |= QD_DEV_INT_JAMLIMIT;
+    }
+
+    if (event & GT_DEV_INT_DUPLEX_MISMATCH)
+    {
+        data |= QD_DEV_INT_DUPLEX_MISMATCH;
+    }
+
+    if (event & GT_DEV_INT_WAKE_EVENT)
+    {
+        data |= QD_DEV_INT_WAKE_EVENT;
+    }
+
+    if (data & (~mask))
+    {
         DBG_INFO(("GT_BAD_PARAM portList\n"));
-		return GT_BAD_PARAM;
-	}
-
-	if (data & GT_DEV_INT_DUPLEX_MISMATCH)
-	{
-	    retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
-	    if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Failed.\n"));
-			return retVal;
-		}
-	}
+        return GT_BAD_PARAM;
+    }
+
+    if (data & GT_DEV_INT_DUPLEX_MISMATCH)
+    {
+        retVal = hwSetGlobal2RegField(dev, QD_REG_WD_CONTROL, 12, 4, 0xF);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
 
     /* Set the related bit. */
     retVal = hwSetGlobal2RegBits(dev,QD_REG_DEVINT_MASK, mask, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1010,39 +1042,39 @@ GT_STATUS eventSetDevInt
 * gwdSetEvent
 *
 * DESCRIPTION:
-*		Watch Dog Event.
-*		The following Watch Dog events are supported:
-*			GT_WD_QC  - Queue Controller Watch Dog enable.
-*						When enabled, the QC's watch dog circuit checks for link
-*						list errors and any errors found in the QC.
-*			GT_WD_EGRESS - Egress Watch Dog enable.
-*						When enabled, each port's egress circuit checks for problems
-*						between the port and the Queue Controller.
-*			GT_WD_FORCE - Force a Watch Dog event.
-*			
-*		If any of the above events is enabled, GT_DEVICE_INT interrupt will
-*		be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
-*		enabled with eventSetDevActive API and GT_DEV_INT is enabled with 
-*		eventSetActive API.
-*		
+*        Watch Dog Event.
+*        The following Watch Dog events are supported:
+*            GT_WD_QC  - Queue Controller Watch Dog enable.
+*                        When enabled, the QC's watch dog circuit checks for link
+*                        list errors and any errors found in the QC.
+*            GT_WD_EGRESS - Egress Watch Dog enable.
+*                        When enabled, each port's egress circuit checks for problems
+*                        between the port and the Queue Controller.
+*            GT_WD_FORCE - Force a Watch Dog event.
+*            
+*        If any of the above events is enabled, GT_DEVICE_INT interrupt will
+*        be asserted by the enabled WatchDog event when GT_DEV_INT_WATCHDOG is
+*        enabled with eventSetDevActive API and GT_DEV_INT is enabled with 
+*        eventSetActive API.
+*        
 * INPUTS:
-*		wdEvent - Watch Dog Events
+*        wdEvent - Watch Dog Events
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdSetEvent
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32	    wdEvent
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        wdEvent
 )
 {
     GT_U16          data, mask;           
@@ -1050,41 +1082,41 @@ GT_STATUS gwdSetEvent
 
     DBG_INFO(("gwdSetEvent Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	mask = (1 << 5) | (1 << 3) | (1 << 2);
-	data = 0;
+    mask = (1 << 5) | (1 << 3) | (1 << 2);
+    data = 0;
 
-	if (wdEvent & GT_WD_QC)
-	{
-		data |= (1 << 5);
-	}
+    if (wdEvent & GT_WD_QC)
+    {
+        data |= (1 << 5);
+    }
 
-	if (wdEvent & GT_WD_EGRESS)
-	{
-		data |= (1 << 3);
-	}
+    if (wdEvent & GT_WD_EGRESS)
+    {
+        data |= (1 << 3);
+    }
 
-	if (wdEvent & GT_WD_FORCE)
-	{
-		data |= (1 << 2);
-	}
+    if (wdEvent & GT_WD_FORCE)
+    {
+        data |= (1 << 2);
+    }
 
     /* Set the related bit. */
     retVal = hwSetGlobal2RegBits(dev,QD_REG_WD_CONTROL, mask, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1094,38 +1126,38 @@ GT_STATUS gwdSetEvent
 * gwdSetSWResetOnWD
 *
 * DESCRIPTION:
-*		SWReset on Watch Dog Event.
-*		When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
-*		will automatically reset the switch core's datapath just as if gsysSwReset
-*		API is called.
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
 *
-*		The Watch Dog History (gwdGetHistory API) won't be cleared by this 
-*		automatic SWReset. This allows the user to know if any watch dog event 
-*		ever occurred even if the swich is configured to automatically recover 
-*		from a watch dog.
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this 
+*        automatic SWReset. This allows the user to know if any watch dog event 
+*        ever occurred even if the swich is configured to automatically recover 
+*        from a watch dog.
 *
-*		When this feature is disabled, enabled watch dog events will not cause a
-*		SWReset.
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
 *
 * INPUTS:
-*		en   - GT_TRUE to enable SWReset on WD
-*			   GT_FALUSE to disable
+*        en   - GT_TRUE to enable SWReset on WD
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdSetSWResetOnWD
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL	    en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
 )
 {
     GT_U16          data;           
@@ -1133,10 +1165,10 @@ GT_STATUS gwdSetSWResetOnWD
 
     DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -1145,13 +1177,13 @@ GT_STATUS gwdSetSWResetOnWD
     retVal = hwSetGlobal2RegField(dev,QD_REG_WD_CONTROL, 0, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1161,38 +1193,38 @@ GT_STATUS gwdSetSWResetOnWD
 * gwdGetSWResetOnWD
 *
 * DESCRIPTION:
-*		SWReset on Watch Dog Event.
-*		When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
-*		will automatically reset the switch core's datapath just as if gsysSwReset
-*		API is called.
+*        SWReset on Watch Dog Event.
+*        When this feature is enabled, any enabled watch dog event (gwdSetEvent API) 
+*        will automatically reset the switch core's datapath just as if gsysSwReset
+*        API is called.
 *
-*		The Watch Dog History (gwdGetHistory API) won't be cleared by this 
-*		automatic SWReset. This allows the user to know if any watch dog event 
-*		ever occurred even if the swich is configured to automatically recover 
-*		from a watch dog.
+*        The Watch Dog History (gwdGetHistory API) won't be cleared by this 
+*        automatic SWReset. This allows the user to know if any watch dog event 
+*        ever occurred even if the swich is configured to automatically recover 
+*        from a watch dog.
 *
-*		When this feature is disabled, enabled watch dog events will not cause a
-*		SWReset.
+*        When this feature is disabled, enabled watch dog events will not cause a
+*        SWReset.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en   - GT_TRUE, if SWReset on WD is enabled
-*			   GT_FALUSE, otherwise
+*        en   - GT_TRUE, if SWReset on WD is enabled
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdGetSWResetOnWD
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL	    *en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 )
 {
     GT_U16          data;           
@@ -1200,23 +1232,23 @@ GT_STATUS gwdGetSWResetOnWD
 
     DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the related bit. */
     retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 0, 1, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *en);
 
@@ -1228,37 +1260,37 @@ GT_STATUS gwdGetSWResetOnWD
 * gwdGetHistory
 *
 * DESCRIPTION:
-*		This routine retrieves Watch Dog history. They are
-*
-*		wdEvent - 
-*			When it's set to GT_TRUE, some enabled Watch Dog event occurred.
-*			The following events are possible:
-*				QC WatchDog Event (GT_WD_QC)
-*				Egress WatchDog Event (GT_WD_EGRESS)
-*				Forced WatchDog Event (GT_WD_FORCE)
-*		egressEvent -
-*			If any port's egress logic detects an egress watch dog issue,
-*			this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
-*			event.
+*        This routine retrieves Watch Dog history. They are
+*
+*        wdEvent - 
+*            When it's set to GT_TRUE, some enabled Watch Dog event occurred.
+*            The following events are possible:
+*                QC WatchDog Event (GT_WD_QC)
+*                Egress WatchDog Event (GT_WD_EGRESS)
+*                Forced WatchDog Event (GT_WD_FORCE)
+*        egressEvent -
+*            If any port's egress logic detects an egress watch dog issue,
+*            this field is set to GT_TRUE, regardless of the enabling GT_WD_EGRESS
+*            event.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		history - GT_WD_EVENT_HISTORY structure
+*        history - GT_WD_EVENT_HISTORY structure
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdGetHistory
 (
-	IN  GT_QD_DEV			*dev,
-	OUT GT_WD_EVENT_HISTORY	*history
+    IN  GT_QD_DEV            *dev,
+    OUT GT_WD_EVENT_HISTORY    *history
 )
 {
     GT_U16          data;           
@@ -1266,39 +1298,39 @@ GT_STATUS gwdGetHistory
 
     DBG_INFO(("gwdSetSWResetOnWD Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the related bit. */
     retVal = hwReadGlobal2Reg(dev,QD_REG_WD_CONTROL,&data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	    return retVal;
-	}
-
-	if (data & (1 << 4))
-	{
-		history->egressEvent = GT_TRUE;
-	}
-	else
-	{
-		history->egressEvent = GT_FALSE;
-	}
-
-	if (data & (1 << 1))
-	{
-		history->wdEvent = GT_TRUE;
-	}
-	else
-	{
-		history->wdEvent = GT_FALSE;
-	}
-
-	DBG_INFO(("OK.\n"));
+        return retVal;
+    }
+
+    if (data & (1 << 4))
+    {
+        history->egressEvent = GT_TRUE;
+    }
+    else
+    {
+        history->egressEvent = GT_FALSE;
+    }
+
+    if (data & (1 << 1))
+    {
+        history->wdEvent = GT_TRUE;
+    }
+    else
+    {
+        history->wdEvent = GT_FALSE;
+    }
+
+    DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
@@ -1307,34 +1339,34 @@ GT_STATUS gwdGetHistory
 * gwdSetRMUTimeOut
 *
 * DESCRIPTION:
-*		Remote Management Timeout. When this bit is set to a one the Remote
-*		Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
-*		is being tested has not gone to the specified value after 1 sec. has elapsed
-*		the Wait on Bit command will be terminated and the Response frame will be
-*		sent without any further processing.
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
 *
-*		When this bit is cleared to a zero the Wait on Bit command will wait 
-*		until the bit that is being tested has changed to the specified value.
+*        When this bit is cleared to a zero the Wait on Bit command will wait 
+*        until the bit that is being tested has changed to the specified value.
 *
 * INPUTS:
-*		en   - GT_TRUE to enable RMU Timeout
-*			   GT_FALUSE to disable
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE to disable
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdSetRMUTimeOut
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL	    en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL        en
 )
 {
     GT_U16          data;           
@@ -1342,10 +1374,10 @@ GT_STATUS gwdSetRMUTimeOut
 
     DBG_INFO(("gwdSetRMUTimeOut Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -1354,13 +1386,13 @@ GT_STATUS gwdSetRMUTimeOut
     retVal = hwSetGlobal2RegField(dev,QD_REG_WD_CONTROL, 6, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1370,34 +1402,34 @@ GT_STATUS gwdSetRMUTimeOut
 * gwdGetRMUTimeOut
 *
 * DESCRIPTION:
-*		Remote Management Timeout. When this bit is set to a one the Remote
-*		Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
-*		is being tested has not gone to the specified value after 1 sec. has elapsed
-*		the Wait on Bit command will be terminated and the Response frame will be
-*		sent without any further processing.
+*        Remote Management Timeout. When this bit is set to a one the Remote
+*        Management Unit(RMU) will timeout on Wait on Bit commands. If the bit that
+*        is being tested has not gone to the specified value after 1 sec. has elapsed
+*        the Wait on Bit command will be terminated and the Response frame will be
+*        sent without any further processing.
 *
-*		When this bit is cleared to a zero the Wait on Bit command will wait 
-*		until the bit that is being tested has changed to the specified value.
+*        When this bit is cleared to a zero the Wait on Bit command will wait 
+*        until the bit that is being tested has changed to the specified value.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en   - GT_TRUE to enable RMU Timeout
-*			   GT_FALUSE, otherwise
+*        en   - GT_TRUE to enable RMU Timeout
+*               GT_FALUSE, otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdGetRMUTimeOut
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL	    *en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 )
 {
     GT_U16          data;           
@@ -1405,23 +1437,23 @@ GT_STATUS gwdGetRMUTimeOut
 
     DBG_INFO(("gwdGetRMUTimeOut Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the related bit. */
     retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 6, 1, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *en);
 
@@ -1433,30 +1465,30 @@ GT_STATUS gwdGetRMUTimeOut
 * gwdGetEgressWDEvent
 *
 * DESCRIPTION:
-*		If any port's egress logic detects an egress watch dog issue, this bit
-*		will be set to a one, regardless of the setting of the GT_WD_EGRESS in
-*		gwdSetEvent function.
-*		
+*        If any port's egress logic detects an egress watch dog issue, this bit
+*        will be set to a one, regardless of the setting of the GT_WD_EGRESS in
+*        gwdSetEvent function.
+*        
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		event - GT_TRUE, if egress logic has detected any egress watch dog issue
-*			    GT_FALUSE, otherwise
+*        event - GT_TRUE, if egress logic has detected any egress watch dog issue
+*                GT_FALUSE, otherwise
 *
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gwdGetEgressWDEvent
 (
-	IN  GT_QD_DEV		*dev,
-	OUT GT_BOOL			*event
+    IN  GT_QD_DEV        *dev,
+    OUT GT_BOOL            *event
 )
 {
     GT_U16          data;           
@@ -1464,22 +1496,22 @@ GT_STATUS gwdGetEgressWDEvent
 
     DBG_INFO(("gwdGetEgressWDEvent Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the related bit. */
     retVal = hwGetGlobal2RegField(dev,QD_REG_WD_CONTROL, 7, 1, &data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *event);
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c
old mode 100644
new mode 100755
index ec4e460..9880f4f
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtMisc.c
@@ -5,8 +5,8 @@
 *
 * DESCRIPTION:
 *       API definitions for Ip Mapping Table
-*							EEPROM access
-*							Scratch and Misc Control
+*                            EEPROM access
+*                            Scratch and Misc Control
 * DEPENDENCIES:
 *
 * FILE REVISION NUMBER:
@@ -22,295 +22,344 @@
 * gsysSetUseIpMappingTable
 *
 * DESCRIPTION:
-*       This API set to use IP Frame Priorities from this table. 
-*		Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
-*			initial IP_FPRI use Ip Mappingg table priorities.
-*		Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
-*			frames initial IP_FPRI is generated by using the frames IP_QPRI
-*			as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
-*			from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*        This API set to use IP Frame Priorities from this table. 
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
 *
 * INPUTS:
-*		en	- [GT_TRUE] / [GT_FALSE]
+*        en    - [GT_TRUE] / [GT_FALSE]
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetUseIpMappingTable
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_BOOL			en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            en
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
 
     DBG_INFO(("gsysSetUseIpMappingTable Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	data = (en==GT_TRUE)?1:0;
+    data = (en==GT_TRUE)?1:0;
 
     retVal = hwSetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
+
 /*******************************************************************************
 * gsysGetUseIpMappingTable
 *
 * DESCRIPTION:
-*       This API get to use IP Frame Priorities from this table. 
-*		Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
-*			initial IP_FPRI use Ip Mappingg table priorities.
-*		Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
-*			frames initial IP_FPRI is generated by using the frames IP_QPRI
-*			as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
-*			from bit 0 of the frames source ports Default PRI (Port offset 0x07).
+*        This API get to use IP Frame Priorities from this table. 
+*        Set GT_TRUE:  The IP_FPRI data in this table is used as the frames 
+*            initial IP_FPRI.
+*        Set GT_FALSE: The IP_FPRI data in this table is ignored. Instead the 
+*            frames initial IP_FPRI is generated by using the frames IP_QPRI
+*            as the IP_FPRIs upper two bits, and the IP_FPRIs lowest bit comes 
+*            from bit 0 of the frames source ports Default PRI (Port offset 0x07).
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		en	- [GT_TRUE] / [GT_FALSE]
+*        en    - [GT_TRUE] / [GT_FALSE]
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetUseIpMappingTable
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_BOOL			*en
+    IN  GT_QD_DEV         *dev,
+    IN  GT_BOOL            *en
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
 
     DBG_INFO(("gsysGetUseIpMappingTable Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
 
     retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,14,1,&data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	*en= (data==1)?GT_TRUE:GT_FALSE;
+    *en= (data==1)?GT_TRUE:GT_FALSE;
 
-	return GT_OK;
+    return GT_OK;
 }
 
+
+
 /*******************************************************************************
 * gsysSetIpMappingPrio
 *
 * DESCRIPTION:
-*       Set IPv4 and IPv6 Frame Priority Mapping, and 
-*			IPv4 and IPv6 Queue Priority Mapping.
-*           The ipFpri value is used as the frames initial FPRI when the frame is 
-*			an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
-*			is configured to use IP FPris.
-*           The ipQpri value is used as the frames initial QPRI when the frame is 
-*			an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
-*			registers (Port offset 0x04) are configured to use IP QPris.
+*        Set IPv4 and IPv6 Frame Priority Mapping, and 
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frame's initial FPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
+*        is configured to use IP FPris.
+*       The ipQpri value is used as the frames initial QPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
+*        registers (Port offset 0x04) are configured to use IP QPris.
 *
 * INPUTS:
-*       point - Pointer to the Ip Mapping Table.
-*				  0 - 0x3f;
-*       ipFpri -  The value is 0 - 7
-*       ipQpri -  The value is 0 - 3.
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetIpMappingPrio
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    IN  GT_U8			ipFpri,
-    IN  GT_U8			ipQpri
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            ipFpri,
+    IN  GT_U8            ipQpri
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
 
     DBG_INFO(("gsysSetIpMappingPrio Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if ((point>0x3f)||(ipFpri>7)||(ipQpri>3))
-	{
+    if ((point>0x3f)||(ipFpri>7)||(ipQpri>3))
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
     /* Wait until the Scratch and Misc control is ready. */
-   	data = 1;
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+       data = 1;
     while(data == 1)
-   	{
+       {
         retVal = hwGetGlobalRegField(dev,QD_REG_IP_MAPPING_TABLE,15,1,&data);
-   	    if(retVal != GT_OK)
-       	{
-			gtSemGive(dev,dev->tblRegsSem);
-   	        return retVal;
-       	}
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
     }
+#endif
 
-	data = (((ipFpri&7)<<4) | (ipQpri&3));
-	data |=  ((GT_U16)((1 << 15) | (point << 8)));
+    data = (((ipFpri&7)<<4) | (ipQpri&3));
+    data |=  ((GT_U16)((1 << 15) | (point << 8)));
 
-	retVal = hwWriteGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, data);
+    retVal = hwWriteGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
+       {
+           DBG_INFO(("Failed.\n"));
         gtSemGive(dev,dev->tblRegsSem);
-   	    return retVal;
+           return retVal;
     }
 
 
 
-	gtSemGive(dev,dev->tblRegsSem);
+    gtSemGive(dev,dev->tblRegsSem);
 
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
+
 /*******************************************************************************
 * gsysGetIpMappingPrio
 *
 * DESCRIPTION:
-*       get IPv4 and IPv6 Frame Priority Mapping, and 
-*			IPv4 and IPv6 Queue Priority Mapping.
-*           The ipFpri value is used as the frames initial FPRI when the frame is 
-*			an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
-*			is configured to use IP FPris.
-*           The ipQpri value is used as the frames initial QPRI when the frame is 
-*			an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
-*			registers (Port offset 0x04) are configured to use IP QPris.
+*        Get IPv4 and IPv6 Frame Priority Mapping, and 
+*        IPv4 and IPv6 Queue Priority Mapping.
+*       The ipFpri value is used as the frame's initial FPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri (Port offset 0x04) 
+*        is configured to use IP FPris.
+*        The ipQpri value is used as the frames initial QPRI when the frame is 
+*        an IPv4 or an IPv6 frame, and the ports InitialPri and TagIfBoth 
+*        registers (Port offset 0x04) are configured to use IP QPris.
 *
 * INPUTS:
-*       point - Pointer to the Ip Mapping Table.
-*				  0 - 0x3f;
+*        point - Pointer to the Ip Mapping Table.
+*                0 - 0x3f;
 *
 * OUTPUTS:
-*       ipFpri -  The value is 0 - 7
-*       ipQpri -  The value is 0 - 3.
+*        ipFpri -  The value is 0 - 7
+*        ipQpri -  The value is 0 - 3.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetIpMappingPrio
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    OUT  GT_U8			*ipFpri,
-    OUT  GT_U8			*ipQpri
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *ipFpri,
+    OUT  GT_U8            *ipQpri
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
 
     DBG_INFO(("gsysGetIpMappingPrio Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_IP_MAPPING_TABLE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (point > 0x3f)
-	{
+    if (point > 0x3f)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
-	do {
-		retVal = hwReadGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, &data);
-		if(retVal != GT_OK)
-   		{
-   			DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-   			return retVal;
-		}
-	} while (data&0x8000);
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_IP_MAPPING_TABLE;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do {
+        retVal = hwReadGlobalReg(dev, QD_REG_IP_MAPPING_TABLE, &data);
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+    } while (data&0x8000);
+#endif
 
 
-	*ipFpri = (data >> 4) & 7;
-	*ipQpri = (data) & 3;
+    *ipFpri = (data >> 4) & 7;
+    *ipQpri = (data) & 3;
 
-	gtSemGive(dev,dev->tblRegsSem);
+    gtSemGive(dev,dev->tblRegsSem);
 
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -320,14 +369,14 @@ GT_STATUS gsysGetIpMappingPrio
 * DESCRIPTION:
 *       This function accesses EEPROM Command Register and Data Register.
 *       The device supports the following EEPROM 
-*			operations
-*			GT_EEPROM_NO_OP = No Operation
-*			GT_EEPROM_WRITE_DATA = Write EEPROM at Addr.
-*			GT_EEPROM_READ_DATA = Read EEPROM from Addr.
-*			GT_EEPROM_RESTART = Restart Register Loader execution at Addr 
-*				(eepromData = dont care in this case)
-*			GT_EEPROM_HALT = Halt (stop executing the EEPROM if its not already 
-*				stopped)
+*            operations
+*            GT_EEPROM_NO_OP = No Operation
+*            GT_EEPROM_WRITE_DATA = Write EEPROM at Addr.
+*            GT_EEPROM_READ_DATA = Read EEPROM from Addr.
+*            GT_EEPROM_RESTART = Restart Register Loader execution at Addr 
+*                (eepromData = dont care in this case)
+*            GT_EEPROM_HALT = Halt (stop executing the EEPROM if its not already 
+*                stopped)
 *
 * INPUTS:
 *       eepromOp      - EEPROM Opcode.
@@ -348,32 +397,50 @@ Command register above.
 *******************************************************************************/
 static GT_STATUS eepromOperationPerform
 (
-    IN    GT_QD_DEV 			*dev,
-    IN    GT_EEPROM_OPERATION	eepromOp,
-    INOUT GT_EEPROM_OP_DATA		*opData
+    IN    GT_QD_DEV             *dev,
+    IN    GT_EEPROM_OPERATION    eepromOp,
+    INOUT GT_EEPROM_OP_DATA        *opData
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
     DBG_INFO(("eepromOperationPerform Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (eepromOp>GT_EEPROM_HALT)
-	{
+    if (eepromOp>GT_EEPROM_HALT)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     gtSemTake(dev,dev->eepromRegsSem,OS_WAIT_FOREVER);
 
 
     /* Wait until the eeprom in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -384,127 +451,147 @@ static GT_STATUS eepromOperationPerform
             return retVal;
         }
     }
+#endif
 
 
     /* Set the EEPROM Operation register */
-	switch (eepromOp)
-	{
-		case GT_EEPROM_WRITE_DATA:
-		    retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,10,1,&data);
-		    if(retVal != GT_OK)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-		        return retVal;
-			}
-			if (data==0)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-				DBG_INFO(("EEPROM is not writablen"));
-		        return GT_FAIL;
-			}
-
-		    retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
-		    if(retVal != GT_OK)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-		        return retVal;
-			}
-			if (data==1)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-				DBG_INFO(("EEPROM Loader is running"));
-		        return GT_FAIL;
-			}
-
-			data = (GT_U16)opData->eepromData;
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->eepromRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (GT_EEPROM_WRITE_DATA << 12) | 
-					(opData->eepromAddr & 0xFF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->eepromRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case GT_EEPROM_READ_DATA:
-		    retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
-		    if(retVal != GT_OK)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-		        return retVal;
-			}
-			if (data==1)
-		    {
-		        gtSemGive(dev,dev->eepromRegsSem);
-				DBG_INFO(("EEPROM Loader is running"));
-		        return GT_FAIL;
-			}
-
-			data = (GT_U16)((1 << 15) | (GT_EEPROM_READ_DATA << 12) | 
-					(opData->eepromAddr & 0xFF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->eepromRegsSem);
-            	return retVal;
-	        }
-
-			
-		    data = 1;
-		    while(data == 1)
-		    {
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->eepromRegsSem);
-		            return retVal;
-        		}
-		    }
-			
-
-			retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_DATA,&data);
-			opData->eepromData = (GT_U32)data;
-
-			break;
-
-		case GT_EEPROM_RESTART:
-			data = (GT_U16)((1 << 15) | (GT_EEPROM_RESTART << 12) | 
-					(opData->eepromAddr & 0xFF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->eepromRegsSem);
-            	return retVal;
-	        }
-
-
-			break;
-
-		case GT_EEPROM_HALT:
-			data = (GT_U16)((1 << 15) | (GT_EEPROM_HALT << 12) | 
-					(opData->eepromAddr & 0xFF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->eepromRegsSem);
-            	return retVal;
-	        }
-
-			break;
-		default:
-			gtSemGive(dev,dev->eepromRegsSem);
-			return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->eepromRegsSem);
+    switch (eepromOp)
+    {
+        case GT_EEPROM_WRITE_DATA:
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,10,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==0)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM is not writablen"));
+                return GT_FAIL;
+            }
+
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==1)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM Loader is running"));
+                return GT_FAIL;
+            }
+
+            data = (GT_U16)opData->eepromData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_WRITE_DATA << 12) | 
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            break;
+
+        case GT_EEPROM_READ_DATA:
+            retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,11,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+            if (data==1)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                DBG_INFO(("EEPROM Loader is running"));
+                return GT_FAIL;
+            }
+
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_READ_DATA << 12) | 
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+            
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+  
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_EEPROM_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->vtuRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_EEPROM_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->eepromRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+            
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_DATA,&data);
+            opData->eepromData = (GT_U32)data;
+
+            break;
+
+        case GT_EEPROM_RESTART:
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_RESTART << 12) | 
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+
+            break;
+
+        case GT_EEPROM_HALT:
+            data = (GT_U16)((1 << 15) | (GT_EEPROM_HALT << 12) | 
+                    (opData->eepromAddr & 0xFF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_EEPROM_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->eepromRegsSem);
+                return retVal;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->eepromRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->eepromRegsSem);
     return GT_OK;
 }
 
@@ -513,45 +600,45 @@ static GT_STATUS eepromOperationPerform
 * gsysReadEeprom
 *
 * DESCRIPTION:
-*       Read EEPROM from EEPROMs address where the EEOp is performed.
+*        Read EEPROM from EEPROMs address where the EEOp is performed.
 *
 * INPUTS:
-*       addr - EEPROM Address. 
+*        addr - EEPROM Address. 
 *
 * OUTPUTS:
-*       data -  Data that was read back from the EEPROM.
+*        data -  Data that was read back from the EEPROM.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysReadEeprom
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr,
-    OUT  GT_U8			*data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    OUT  GT_U8            *data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    GT_EEPROM_OPERATION	eepromOp;
-    GT_EEPROM_OP_DATA	opData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
  
-	eepromOp = GT_EEPROM_READ_DATA;
-	opData.eepromAddr = addr;
+    eepromOp = GT_EEPROM_READ_DATA;
+    opData.eepromAddr = addr;
 
-	retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
     if(retVal != GT_OK)
     {
       return retVal;
     }
-	*data = (GT_U8)opData.eepromData;
-	return GT_OK;
+    *data = (GT_U8)opData.eepromData;
+    return GT_OK;
 
 }
 
@@ -559,434 +646,483 @@ GT_STATUS gsysReadEeprom
 * gsysWriteEeprom
 *
 * DESCRIPTION:
-*       Write EEPROM at the EEPROMs address where the EEOp is performed.
-
+*        Write EEPROM at the EEPROMs address where the EEOp is performed.
 *
 * INPUTS:
-*       addr - EEPROM Address. 
-*       data - Data to be written to the EEPROM
+*        addr - EEPROM Address. 
+*        data - Data to be written to the EEPROM
 *
 * OUTPUTS:
-*		None
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysWriteEeprom
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr,
-    IN  GT_U8			data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr,
+    IN  GT_U8            data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    GT_EEPROM_OPERATION	eepromOp;
-    GT_EEPROM_OP_DATA	opData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
  
-	eepromOp = GT_EEPROM_WRITE_DATA;
-	opData.eepromAddr = addr;
-	opData.eepromData = data;
+    eepromOp = GT_EEPROM_WRITE_DATA;
+    opData.eepromAddr = addr;
+    opData.eepromData = data;
 
-	retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
     if(retVal != GT_OK)
     {
       return retVal;
     }
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysRestartEeprom
 *
 * DESCRIPTION:
-*       Restart Register Loader execution at the EEPROMs address where the EEOp 
-*		is performed
+*        Restart Register Loader execution at the EEPROMs address where the EEOp 
+*        is performed
 *
 * INPUTS:
-*       addr - EEPROM Address. .
+*        addr - EEPROM Address. .
 *
 * OUTPUTS:
-*       none   
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysRestartEeprom
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			addr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            addr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    GT_EEPROM_OPERATION	eepromOp;
-    GT_EEPROM_OP_DATA	opData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
  
-	eepromOp = GT_EEPROM_RESTART;
-	opData.eepromAddr = addr;
+    eepromOp = GT_EEPROM_RESTART;
+    opData.eepromAddr = addr;
 
-	retVal = eepromOperationPerform(dev,eepromOp,&opData);
+    retVal = eepromOperationPerform(dev,eepromOp,&opData);
     if(retVal != GT_OK)
     {
       return retVal;
     }
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysHaltEeprom
 *
 * DESCRIPTION:
-*       Halt (stop executing the EEPROM if its not already stopped)
-
+*        Halt (stop executing the EEPROM if its not already stopped)
 *
 * INPUTS:
-*       none  .
+*        None.
 *
 * OUTPUTS:
-*       none   
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysHaltEeprom
 (
-    IN  GT_QD_DEV 		*dev
+    IN  GT_QD_DEV         *dev
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    GT_EEPROM_OPERATION	eepromOp;
-    GT_EEPROM_OP_DATA	opData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_EEPROM_OPERATION    eepromOp;
+    GT_EEPROM_OP_DATA    opData;
  
-	eepromOp = GT_EEPROM_HALT;
+    eepromOp = GT_EEPROM_HALT;
 
-	retVal = eepromOperationPerform(dev,eepromOp,  &opData);
+    retVal = eepromOperationPerform(dev,eepromOp,  &opData);
     if(retVal != GT_OK)
     {
       return retVal;
     }
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysGetStEeprom
 *
 * DESCRIPTION:
-*       Get EEPROM status. They are Register Loader Running status and EEPROM 
-*		Write Enable status
-*       runSt is GT_TRUE: Register Loader Running, whenever the register loader 
-*			is busy executing the instructions contained in the EEPROM.
-*       writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to 
-*			the EEPROM is possible. 
-*		writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
-*			This reflects the value of the EE_WE configuration pin after Reset.
+*        Get EEPROM status. They are Register Loader Running status and EEPROM 
+*        Write Enable status
+*        runSt is GT_TRUE: Register Loader Running, whenever the register loader 
+*            is busy executing the instructions contained in the EEPROM.
+*        writeEn is GT_TRUE: EEPROM Write Enable, that indicates that writing to 
+*            the EEPROM is possible. 
+*        writeEn is GT_FALSE: the Write EEPROM EEOp above will not do anything.
+*            This reflects the value of the EE_WE configuration pin after Reset.
 *
 * INPUTS:
-*       none  .
+*        None.
 *
 * OUTPUTS:
-*       runSt   -   [GT_TRUE] / [GT_FALSE)
-*       writeEn -   [GT_TRUE] / [GT_FALSE)
+*        runSt   -   [GT_TRUE] / [GT_FALSE)
+*        writeEn -   [GT_TRUE] / [GT_FALSE)
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetStEeprom
 (
-    IN  GT_QD_DEV 		*dev,
-	OUT GT_BOOL			*writeEn,
-	OUT GT_BOOL			*runSt
+    IN  GT_QD_DEV         *dev,
+    OUT GT_BOOL            *writeEn,
+    OUT GT_BOOL            *runSt
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    GT_U16      data; 			/* temporary Data storage */
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16      data;             /* temporary Data storage */
  
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EEPROM))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_COMMAND, &data);
+    retVal = hwReadGlobal2Reg(dev,QD_REG_EEPROM_COMMAND, &data);
     if(retVal != GT_OK)
     {
-       	return retVal;
+           return retVal;
     }
 
 
-	*runSt   = (data&GT_EEPROM_OP_ST_RUNNING_MASK)?GT_TRUE:GT_FALSE;
-	*writeEn = (data&GT_EEPROM_OP_ST_WRITE_EN_MASK)?GT_TRUE:GT_FALSE;
+    *runSt   = (data&GT_EEPROM_OP_ST_RUNNING_MASK)?GT_TRUE:GT_FALSE;
+    *writeEn = (data&GT_EEPROM_OP_ST_WRITE_EN_MASK)?GT_TRUE:GT_FALSE;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysSetScratchMiscCtrl
 *
 * DESCRIPTION:
-*       Set Scratch and Misc control data to the Pointer to the Scratch and Misc. 
-*		Control register.
-*				Scratch Byte 0
-*				Scratch Byte 1
-*				GPIO Configuration
-*				Reserved for future use
-*				GPIO Direction
-*				GPIO Data
-*				CONFIG Data 0
-*				CONFIG Data 1
-*				CONFIG Data 2
-*				CONFIG Data 3
-*				SyncE & TAICLK125s Drive
-*				P5s & CLK125s Clock Drive
-*				P6s Clock Drive
-*				EEPROM Pad drive
+*        Set Scratch and Misc control data to the Scratch and Misc Control register. 
+*        The registers of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
 *
 * INPUTS:
-*       point - Pointer to the Scratch and Misc. Control register.
-*       data - Scratch and Misc. Control data written to the register 
-*				pointed to by the point above.
+*        point - Pointer to the Scratch and Misc. Control register.
+*        data  - Scratch and Misc. Control data written to the register 
+*                pointed to by the point above.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetScratchMiscCtrl
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    IN  GT_U8			data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    IN  GT_U8            data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    IN  GT_U16			tmpData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    IN  GT_U16            tmpData;
 
-	if (point > GT_SCRAT_MISC_REG_MAX)
-	{
+    if (point > GT_SCRAT_MISC_REG_MAX)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	if ((point>0x7f)||(data>0xff))
-	{
+    if (data &0xffffff00)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
-	/* program QoS Weight Table, 4 sequences at a time */
+    /* program QoS Weight Table, 4 sequences at a time */
 
     /* Wait until the Scratch and Misc control is ready. */
-   	tmpData = 1;
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+      }
+    }
+#else
+       tmpData = 1;
     while(tmpData == 1)
-   	{
+       {
         retVal = hwGetGlobal2RegField(dev,QD_REG_SCRATCH_MISC,15,1,&tmpData);
-   	    if(retVal != GT_OK)
-       	{
-			gtSemGive(dev,dev->tblRegsSem);
-   	        return retVal;
-       	}
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
     }
+#endif
 
-	tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);
+    tmpData =  (GT_U16)((1 << 15) | (point << 8) | data);
 
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_SCRATCH_MISC, tmpData);
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_SCRATCH_MISC, tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
+       {
+           DBG_INFO(("Failed.\n"));
            gtSemGive(dev,dev->tblRegsSem);
-   	    return retVal;
+           return retVal;
     }
 
 
 
-	gtSemGive(dev,dev->tblRegsSem);
+    gtSemGive(dev,dev->tblRegsSem);
 
-   	return retVal;
+       return retVal;
 
 }
 
 
+
 /*******************************************************************************
 * gsysGetScratchMiscCtrl
 *
 * DESCRIPTION:
-*       Get Scratch and Misc control data to the Pointer to the Scratch and Misc. 
-*		Control register.
-*				Scratch Byte 0
-*				Scratch Byte 1
-*				GPIO Configuration
-*				Reserved for future use
-*				GPIO Direction
-*				GPIO Data
-*				CONFIG Data 0
-*				CONFIG Data 1
-*				CONFIG Data 2
-*				CONFIG Data 3
-*				SyncE & TAICLK125s Drive
-*				P5s & CLK125s Clock Drive
-*				P6s Clock Drive
-*				EEPROM Pad drive
+*        Get Scratch and Misc control data from the Scratch and Misc Control register. 
+*        The register of Scratch and Misc control are.
+*                Scratch Byte 0
+*                Scratch Byte 1
+*                GPIO Configuration
+*                Reserved for future use
+*                GPIO Direction
+*                GPIO Data
+*                CONFIG Data 0
+*                CONFIG Data 1
+*                CONFIG Data 2
+*                CONFIG Data 3
+*                SyncE & TAICLK125s Drive
+*                P5s & CLK125s Clock Drive
+*                P6s Clock Drive
+*                EEPROM Pad drive
 
 *
 * INPUTS:
-*       point - Pointer to the Scratch and Misc. Control register.
+*        point - Pointer to the Scratch and Misc. Control register.
 *
 * OUTPUTS:
-*       data - Scratch and Misc. Control data read from the register 
-*				pointed to by the point above.
+*        data - Scratch and Misc. Control data read from the register 
+*                pointed to by the point above.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetScratchMiscCtrl
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			point,
-    OUT  GT_U8			*data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            point,
+    OUT  GT_U8            *data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-    OUT  GT_U16			tmpData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    OUT  GT_U16            tmpData;
 
-	if (point > GT_SCRAT_MISC_REG_MAX)
-	{
+    if (point > GT_SCRAT_MISC_REG_MAX)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	if (point>0x7f)
-	{
+    if (point>0x7f)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
-	/* program QoS Weight Table, 4 sequences at a time */
+    /* program QoS Weight Table, 4 sequences at a time */
 
-	do {
-		retVal = hwReadGlobal2Reg(dev, QD_REG_SCRATCH_MISC, &tmpData);
-		if(retVal != GT_OK)
-   		{
-   			DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-   			return retVal;
-		}
-	} while (tmpData&0x8000);
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SCRATCH_MISC;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->vtuRegsSem);
+        return retVal;
+     }
+     tmpData = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do {
+        retVal = hwReadGlobal2Reg(dev, QD_REG_SCRATCH_MISC, &tmpData);
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+    } while (tmpData&0x8000);
+#endif
 
     *data = tmpData&0xff;
 
-	gtSemGive(dev,dev->tblRegsSem);
+    gtSemGive(dev,dev->tblRegsSem);
 
 
-	return retVal;
+    return retVal;
 }
 
 
+
+
 /*******************************************************************************
 * gsysSetScratchBits
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <scratch byte 0 and 1> bits.
-*		Scratch bits. These bits are 100% available to software for whatever 
-*		purpose desired. These bits do not connect to any hardware function.
+*        Set bits to the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired. 
+*        These bits do not connect to any hardware function.
 *
 * INPUTS:
-*       scritch - written bits.
+*        scritch - written bits.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetScratchBits
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U16			scratch
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U16            scratch
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
+    GT_STATUS    retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetScratchBits Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, (GT_U8)(scratch&0xff));
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, (GT_U8)(scratch&0xff));
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, (GT_U8)((scratch>>8)&0xff));
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, (GT_U8)((scratch>>8)&0xff));
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -994,366 +1130,387 @@ GT_STATUS gsysSetScratchBits
 * gsysGetScratchBits
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <scratch byte 0 and 1> bits.
-*		Scratch bits. These bits are 100% available to software for whatever 
-*		purpose desired. These bits do not connect to any hardware function.
+*        Get bits from the Scratch and Misc Control register <scratch byte 0 and 1>.
+*        These bits are 100% available to software for whatever purpose desired. 
+*        These bits do not connect to any hardware function.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       scritch - read bits.
+*        scritch - read bits.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetScratchBits
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U16			*scratch
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U16            *scratch
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetScratchBits Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_1, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	*scratch = data;
-	*scratch = *scratch<<8;
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, &data);
+    *scratch = data;
+    *scratch = *scratch<<8;
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SCRAT_0, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*scratch |= data;
+    
+    *scratch |= data;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysSetGpioConfigMod
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <GPIO Configuration>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
-
+*        Set bits to the Scratch and Misc Control register <GPIO Configuration>
+*        to configure GPIO mode.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only. 
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
 *
 * INPUTS:
-*       mode - OR [GT_GPIO_BIT_x]
+*        mode - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetGpioConfigMod
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			mode
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            mode
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
+    GT_STATUS    retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetGpioConfigMod Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, (GT_U8)(mode&0x7f));
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, (GT_U8)(mode&0x7f));
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysGetGpioConfigMod
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <GPIO Configuration>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
-
+*        Get mode from the Scratch and Misc Control register <GPIO Configuration>.
+*        The bits are shared General Purpose Input Output mode Bits:
+*        Bit 6 - GT_GPIO_BIT_6:    1:GPIO[6]    0:SE_RCLK1
+*        Bit 5 - GT_GPIO_BIT_5:    1:GPIO[5]    0:SE_RCLK0
+*        Now, folloing bits are read only. 
+*        Bit 4 - GT_GPIO_BIT_4:    1:GPIO[4]    0:
+*        Bit 3 - GT_GPIO_BIT_3:    1:GPIO[3]    0:
+*        Bit 2 - GT_GPIO_BIT_2:    1:GPIO[2]    0:
+*        Bit 1 - GT_GPIO_BIT_1:    1:GPIO[1]    0:P6_COL
+*        Bit 0 - GT_GPIO_BIT_0:    1:GPIO[0]    0:P6_CRS
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       mode - OR [GT_GPIO_BIT_x]
+*        mode - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetGpioConfigMod
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			*mode
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *mode
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetGpioConfigMod Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_CFG, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*mode = 0x7f&data;
+    
+    *mode = 0x7f&data;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysSetGpioDirection
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <GPIO Direction>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*        Set Gpio direction to the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0]. 
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*       dir - OR [GT_GPIO_BIT_x]
+*        dir - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetGpioDirection
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			dir
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            dir
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
+    GT_STATUS    retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetGpioDirection Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, (GT_U8)(dir&0x7f));
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, (GT_U8)(dir&0x7f));
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysGetGpioDirection
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <GPIO Direction>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*        get Gpio direction from the Scratch and Misc Control register <GPIO Direction>.
+*        The bits are used to control the direction of GPIO[6:0]. 
+*        When a GPIOs bit is set to a one that GPIO will become an input. When a
+*        GPIOs bit is cleared to a zero that GPIO will become an output
+*        General Purpose Input Output direction bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       dir - OR [GT_GPIO_BIT_x]
+*        dir - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetGpioDirection
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U32			*dir
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U32            *dir
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetGpioDirection Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DIR, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	*dir = data;
+    *dir = data;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
 
+
 /*******************************************************************************
 * gsysSetGpioData
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <GPIO data>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*        Set Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go 
+*        to a holding register but will not appear on the pin nor in this register. 
+*        Reads of this register will return the actual, real-time, data that is 
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go 
+*        to a holding register and will appear on the GPIOs pin. Reads of this register 
+*        will return the actual, real-time, data that is appearing on the GPIOs pin 
+*        (which in this case should be the data written, but if its isnt that would 
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written 
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*       data - OR [GT_GPIO_BIT_x]
+*        data - OR [GT_GPIO_BIT_x]
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetGpioData
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
+    GT_STATUS    retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetGpioData Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, (GT_U8)(data&0x7f));
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, (GT_U8)(data&0x7f));
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -1361,294 +1518,311 @@ GT_STATUS gsysSetGpioData
 * gsysGetGpioData
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <GPIO data>.
-*		General Purpose Input Output Bits:
-*		Bit 6 - GT_GPIO_BIT_6:	1:GPIO[6]	0:SE_RCLK1
-*		Bit 5 - GT_GPIO_BIT_5:	1:GPIO[5]	0:SE_RCLK0
-*		Now, folloing bits are read only. 
-*		Bit 4 - GT_GPIO_BIT_4:	1:GPIO[4]	0:
-*		Bit 3 - GT_GPIO_BIT_3:	1:GPIO[3]	0:
-*		Bit 2 - GT_GPIO_BIT_2:	1:GPIO[2]	0:
-*		Bit 1 - GT_GPIO_BIT_1:	1:GPIO[1]	0:P6_COL
-*		Bit 0 - GT_GPIO_BIT_0:	1:GPIO[0]	0:P6_CRS
+*        get Gpio data to the Scratch and Misc Control register <GPIO data>.
+*        When a GPIOs bit is set to be an input, data written to this bit will go 
+*        to a holding register but will not appear on the pin nor in this register. 
+*        Reads of this register will return the actual, real-time, data that is 
+*        appearing on the GPIOs pin.
+*        When a GPIOs bit is set to be an output, data written to this bit will go 
+*        to a holding register and will appear on the GPIOs pin. Reads of this register 
+*        will return the actual, real-time, data that is appearing on the GPIOs pin 
+*        (which in this case should be the data written, but if its isnt that would 
+*        be an indication of a conflict).
+*        When a pins direction changes from input to output, the data last written 
+*        to the holding register appears on the GPIOs pin
+*        General Purpose Input Output data bits are:
+*        Bit 6 - GT_GPIO_BIT_6
+*        Bit 5 - GT_GPIO_BIT_5
+*        Bit 4 - GT_GPIO_BIT_4
+*        Bit 3 - GT_GPIO_BIT_3
+*        Bit 2 - GT_GPIO_BIT_2
+*        Bit 1 - GT_GPIO_BIT_1
+*        Bit 0 - GT_GPIO_BIT_0
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       data - OR [GT_GPIO_BIT_x]
+*        data - OR [GT_GPIO_BIT_x]
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetGpioData
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U32			*data
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U32            *data
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		tmpData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        tmpData;
 
     DBG_INFO(("gsysGetGpioData Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, &tmpData);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_GPIO_DAT, &tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	*data = tmpData;
+    *data = tmpData;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
 /*******************************************************************************
 * gsysGetConfigData
 *
 * DESCRIPTION:
-*       Get Reset Configuration pin data 0-3. 
-*		These registers return the values observed after a hardware Reset on the 
-*		listed CONFIG data listed below.
-*			Config data 0:
-*				0 USER[0] P6_OUTD[5]
-*				1 USER[1] P6_OUTD[6]
-*				2 USER[2] P6_OUTD[7]
-*				3 ADDR[0] P5_OUTD[0]
-*				4 ADDR[1] P5_OUTD[5]
-*				5 ADDR[2] P5_OUTD[6]
-*				6 ADDR]3] P5_OUTD[7]
-*				7 ADDR[4] P5_OUTD[1]
-*			Config data 1:
-*				0 LED_SEL[0] P1_LED
-*				1 LED_SEL[1] P2_LED
-*				2 4COL P3_LED
-*				3 NormCx P4_LED
-*				4 Jumbo P0_LED
-*				5 EE_WE EE_CS/C2_LED
-*				6 FD_FLOW EE_CLK/C1_LED
-*				7 HD_FLOW EE_DIN/C0_LED
-*			Config data 2:
-*				0 P5_MODE[0] P5_OUTD[2]
-*				1 P5_MODE[1] P5_OUTD[3]
-*				2 P5_MODE[2] P5_OUTD[4]
-*				3 Reserved for future useP5_HALFDPX P5_OUTEN
-*				4 P6_MODE[0] P6_OUTD[2]
-*				5 P6_MODE[1] P6_OUTD[3]
-*				6 P6_MODE[2] P6_OUTD[4]
-*				7 Reserved for future useP6_HALFDPX P6_OUTEN
-*			Config data 2:
-*				0 RMU_MODE[0] P6_OUTD[0]
-*				1 RMU_MODE[1] P6_OUTD[1]
-*				2 
-*				3
-*				4
-*				5
-*				6
-*				7
-
+*        Get Reset Configuration Pin Data 0-3. 
+*        These registers return the values observed after a hardware Reset on the 
+*        listed CONFIG data listed below.
+*            Config data 0:
+*              Bit    Config    Pin's Primary Name
+*                0    USER[0]        P6_OUTD[5]
+*                1    USER[1]        P6_OUTD[6]
+*                2    USER[2]        P6_OUTD[7]
+*                3    ADDR[0]        P5_OUTD[0]
+*                4    ADDR[1]        P5_OUTD[5]
+*                5    ADDR[2]        P5_OUTD[6]
+*                6    ADDR]3]        P5_OUTD[7]
+*                7    ADDR[4]        P5_OUTD[1]
+*            Config data 1:
+*                0    LED_SEL[0]    P1_LED
+*                1    LED_SEL[1]    P2_LED
+*                2    4COL P3_LED
+*                3    NormCx        P4_LED
+*                4    Jumbo        P0_LED
+*                5    EE_WE        EE_CS/C2_LED
+*                6    FD_FLOW        EE_CLK/C1_LED
+*                7    HD_FLOW        EE_DIN/C0_LED
+*            Config data 2:
+*                0    P5_MODE[0]    P5_OUTD[2]
+*                1    P5_MODE[1]    P5_OUTD[3]
+*                2    P5_MODE[2]    P5_OUTD[4]
+*                3    Reserved for future use
+*                4    P6_MODE[0]    P6_OUTD[2]
+*                5    P6_MODE[1]    P6_OUTD[3]
+*                6    P6_MODE[2]    P6_OUTD[4]
+*                7    Reserved for future use
+*            Config data 3:
+*                0    RMU_MODE[0] P6_OUTD[0]
+*                1    RMU_MODE[1] P6_OUTD[1]
+*                2    S_VDDOS[0]    PTP_TRIG 
+*                3    CLK125EN    CLK125
+*                4    P5_VDDOS[0] P5_GTXCLK
+*                5    P5_VDDOS[1] P5_OUTEN
+*                6    P6_VDDOS[0] P5_GTXCLK
+*                7    P6_VDDOS[1] P6_OUTEN
 * INPUTS:
-*       none.
+*        None.
 *
 * OUTPUTS:
 *       cfgDat - GT_CONFIG_DTTA
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetConfigData
 (
-    IN  GT_QD_DEV 			*dev,
-    OUT  GT_CONFIG_DATA		*cfgData
+    IN  GT_QD_DEV             *dev,
+    OUT  GT_CONFIG_DATA        *cfgData
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		tmpData;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        tmpData;
 
     DBG_INFO(("gsysGetConfigData Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT0, &tmpData);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT0, &tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	cfgData->cfgData0.Byte = tmpData;
+    cfgData->cfgData0.Byte = tmpData;
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT1, &tmpData);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT1, &tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	cfgData->cfgData1.Byte = tmpData;
+    cfgData->cfgData1.Byte = tmpData;
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT2, &tmpData);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT2, &tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	cfgData->cfgData2.Byte = tmpData;
+    cfgData->cfgData2.Byte = tmpData;
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT3, &tmpData);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_CFG_DAT3, &tmpData);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	cfgData->cfgData3.Byte = tmpData;
+    cfgData->cfgData3.Byte = tmpData;
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
 
+
 /*******************************************************************************
 * gsysSetSyncETai
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <SyncE and TAI pad>.
+*        Set SyncE and Tai to the Scratch and Misc. Control register <SyncE and TAI pad>.
 *
 * INPUTS:
-*       zpr - ZPR for SyncE and TAI
-*       znr - ZNR for SyncE and TAI
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetSyncETai
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysSetSyncETai Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if ((zpr>0x7) || (znr>0x7))
-	{
+    if ((zpr>0x7) || (znr>0x7))
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	data = ((zpr&0x7)<<3) | (znr&0x7);
+    data = ((zpr&0x7)<<3) | (znr&0x7);
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, data);
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
+
+
 /*******************************************************************************
 * gsysGetSyncETai
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <SyncE and TAI pad>.
+*        Get SyncE and Tai from the Scratch and Misc Control register <SyncE and TAI pad>.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       zpr - ZPR for SyncE and TAI
-*       znr - ZNR for SyncE and TAI*
+*        zpr - ZPR for SyncE and TAI
+*        znr - ZNR for SyncE and TAI*
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetSyncETai
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetSyncETai Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_SYNCE, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*zpr = 0x7 &(data>>3);
-	*znr = 0x7 &(data);
+    
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -1657,177 +1831,180 @@ GT_STATUS gsysGetSyncETai
 * gsysSetP6_Clock
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <P6_Clock pad>.
+*        Set P6_clock to the Scratch and Misc Control register <P6_Clock pad>.
 *
 * INPUTS:
-*       zpr - ZPR for P6_Clock
-*       znr - ZNR for P6_Clock
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetP6_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysSetP6_Clock Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if ((zpr>0x7) || (znr>0x7))
-	{
+    if ((zpr>0x7) || (znr>0x7))
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	data = ((zpr&0x7)<<3) | (znr&0x7);
+    data = ((zpr&0x7)<<3) | (znr&0x7);
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, data);
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
 /*******************************************************************************
 * gsysGetP6_Clock
 *
-*       Get the Scratch and Misc. Control register <P6_Clock pad>.
+* DESCRIPTION:
+*       Get P6_clock from the Scratch and Misc Control register <P6_Clock pad>.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       zpr - ZPR for P6_Clock
-*       znr - ZNR for P6_Clock*
+*        zpr - ZPR for P6_Clock
+*        znr - ZNR for P6_Clock
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetP6_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetP6_Clock Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P6_CLK, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*zpr = 0x7 &(data>>3);
-	*znr = 0x7 &(data);
+    
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
 
 
+
 /*******************************************************************************
 * gsysSetP5_Clock
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <P5_Clock pad>.
+*       Set P5_clock to the Scratch and Misc Control register <P5_Clock pad>.
 *
 * INPUTS:
-*       zpr - ZPR for P5_Clock
-*       znr - ZNR for P5_Clock
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetP5_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysSetP5_Clock Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if ((zpr>0x7) || (znr>0x7))
-	{
+    if ((zpr>0x7) || (znr>0x7))
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	data = ((zpr&0x7)<<3) | (znr&0x7);
+    data = ((zpr&0x7)<<3) | (znr&0x7);
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, data);
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -1835,119 +2012,119 @@ GT_STATUS gsysSetP5_Clock
 * gsysGetP5_Clock
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <P5_Clock pad>.
+*       Get P5_clock from the Scratch and Misc Control register <P5_Clock pad>.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       zpr - ZPR for P5_Clock
-*       znr - ZNR for P5_Clock
+*        zpr - ZPR for P5_Clock
+*        znr - ZNR for P5_Clock
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetP5_Clock
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetP6_Clock Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_P5_CLK, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*zpr = 0x7 &(data>>3);
-	*znr = 0x7 &(data);
+    
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
 
-
 /*******************************************************************************
 * gsysSetEEPROM
 *
 * DESCRIPTION:
-*       Set the Scratch and Misc. Control register <EEPROM pad>.
+*       Set EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
 *
 * INPUTS:
-*       dsm - DSM for EEPROM
-*       zpr - ZPR for EEPROM
-*       znr - ZNR for EEPROM
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysSetEEPROM
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8			dsm,
-    IN  GT_U8			zpr,
-    IN  GT_U8			znr
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            dsm,
+    IN  GT_U8            zpr,
+    IN  GT_U8            znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysSetEEPROM Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if ((zpr>0x7) || (znr>0x7))
-	{
+    if ((zpr>0x7) || (znr>0x7))
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	data = ((dsm&0x3)<<6) | ((zpr&0x7)<<3) | (znr&0x7);
+    data = ((dsm&0x3)<<6) | ((zpr&0x7)<<3) | (znr&0x7);
 
-	retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, data);
+    retVal = gsysSetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -1955,57 +2132,58 @@ GT_STATUS gsysSetEEPROM
 * gsysGetEEPROM
 *
 * DESCRIPTION:
-*       Get the Scratch and Misc. Control register <EEPROM pad>.
+*       Get EEPROM cycle to the Scratch and Misc Control register <EEPROM pad>.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*       dsm - DSM for EEPROM
-*       zpr - ZPR for EEPROM
-*       znr - ZNR for EEPROM
+*        dsm - DSM for EEPROM cycle
+*        zpr - ZPR for EEPROM cycle
+*        znr - ZNR for EEPROM cycle
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gsysGetEEPROM
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT  GT_U8			*dsm,
-    OUT  GT_U8			*zpr,
-    OUT  GT_U8			*znr
+    IN  GT_QD_DEV         *dev,
+    OUT  GT_U8            *dsm,
+    OUT  GT_U8            *zpr,
+    OUT  GT_U8            *znr
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8		data;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8        data;
 
     DBG_INFO(("gsysGetEEPROM Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SCRATCH_MISC_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, &data);
+    retVal = gsysGetScratchMiscCtrl(dev, GT_SCRAT_MISC_REG_EEPROM, &data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
-	
-	*dsm = 0x3 &(data>>6);
-	*zpr = 0x7 &(data>>3);
-	*znr = 0x7 &(data);
+    
+    *dsm = 0x3 &(data>>6);
+    *zpr = 0x7 &(data>>3);
+    *znr = 0x7 &(data);
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPCSCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPCSCtrl.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c
old mode 100644
new mode 100755
index 3132160..ac35c76
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL.c
@@ -28,62 +28,62 @@ static GT_STATUS pirlOperationPerform
 
 static GT_STATUS pirlInitialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 );
 
 static GT_STATUS pirlInitIRLUnit
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit
 );
 
 static GT_STATUS pirlDataToResource
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL_DATA		*pirlData,
-    OUT GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_DATA        *pirlData,
+    OUT GT_PIRL_RESOURCE    *res
 );
 
 static GT_STATUS pirlResourceToData
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL_RESOURCE	*res,
-    OUT GT_PIRL_DATA		*pirlData
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_RESOURCE    *res,
+    OUT GT_PIRL_DATA        *pirlData
 );
 
 static GT_STATUS pirlWriteResource
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit,
-    IN  GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN  GT_PIRL_RESOURCE    *res
 );
 
 static GT_STATUS pirlReadResource
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit,
-    OUT GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    OUT GT_PIRL_RESOURCE    *res
 );
 
 static GT_STATUS pirlSetPortVec
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
 );
 
 static GT_STATUS pirlGetPortVec
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_U32		*portVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
 );
 
 static GT_STATUS pirlSetFcMode
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_PIRL_FC_DEASSERT		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_FC_DEASSERT        mode
 );
 
 /*******************************************************************************
@@ -91,13 +91,13 @@ static GT_STATUS pirlSetFcMode
 *
 * DESCRIPTION:
 *       This routine activates Ingress Rate Limiting for the given ports by 
-*		initializing a resource bucket, assigning ports, and configuring
-*		Bucket Parameters.
+*        initializing a resource bucket, assigning ports, and configuring
+*        Bucket Parameters.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        irlUnit  - bucket to be used (0 ~ 11).
 *       portVec  - the list of ports that share the bucket.
-*		pirlData - PIRL resource parameters.
+*        pirlData - PIRL resource parameters.
 *
 * OUTPUTS:
 *       None.
@@ -105,7 +105,7 @@ static GT_STATUS pirlSetFcMode
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -114,139 +114,138 @@ static GT_STATUS pirlSetFcMode
 *******************************************************************************/
 GT_STATUS gpirlActivate
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec,
-	IN  GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec,
+    IN  GT_PIRL_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PORT_STP_STATE	pState[MAX_SWITCH_PORTS];
-	GT_LPORT			port;
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
-	GT_PIRL_RESOURCE	pirlRes;
-
-	DBG_INFO(("gpirlActivate Called.\n"));
-
+    GT_STATUS           retVal;
+    GT_PORT_STP_STATE    pState[MAX_SWITCH_PORTS];
+    GT_LPORT            port;
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    GT_PIRL_RESOURCE    pirlRes;
+
+    DBG_INFO(("gpirlActivate Called.\n"));
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM irlUnit\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
     /* check if the given portVec is valid */
-	if ((!portVec) || (portVec >= (GT_U32)(1<<dev->numOfPorts)))
+    if ((!portVec) || (portVec >= (GT_U32)(1<<dev->numOfPorts)))
     {
         DBG_INFO(("GT_BAD_PARAM portVec\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* set or reset port's ingress resource bit based on the portVec */
-	retVal = pirlSetPortVec(dev, irlUnit, portVec);
-	if(retVal != GT_OK)
-	{
+    /* set or reset port's ingress resource bit based on the portVec */
+    retVal = pirlSetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
-
-	/* Disable ports that share the bucket */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(!GT_IS_PORT_SET(portVec,port))
-			continue;
-
-		retVal = gstpGetPortState(dev, port, &pState[port]);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-
-		retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-	}
-
-	/* Program Tuning register */
-	op = PIRL_WRITE_RESOURCE;
-	opData.irlUnit = irlUnit;
-	opData.irlReg = 0xF;
-	opData.irlData = 0x7;
-	retVal = pirlOperationPerform(dev,op,&opData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
-
-	/* Program the Ingress Rate Resource Parameters */
-	retVal = pirlDataToResource(dev,pirlData,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
-    	return retVal;
-	}
-
-	retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	/* Initialize internal counters */
-	retVal = pirlInitIRLUnit(dev,irlUnit);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	/* Program PirlFCMode for each port that shares Bucket */
-	if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
-	{
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if(!GT_IS_PORT_SET(portVec,port))
-				continue;
-
-			retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
-			if(retVal != GT_OK)
-			{
-			    DBG_INFO(("PIRL FC Mode set failed.\n"));
-    			return retVal;
-			}
-		}
-	}
-
-	/* Set the ports in their original state */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(!GT_IS_PORT_SET(portVec,port))
-			continue;
-
-		retVal = gstpSetPortState(dev, port, pState[port]);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+        return retVal;
+    }
+
+    /* Disable ports that share the bucket */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpGetPortState(dev, port, &pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+
+        retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    /* Program Tuning register */
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlUnit = irlUnit;
+    opData.irlReg = 0xF;
+    opData.irlData = 0x7;
+    retVal = pirlOperationPerform(dev,op,&opData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirlDataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirlInitIRLUnit(dev,irlUnit);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+
+            retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode set failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the ports in their original state */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpSetPortState(dev, port, pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -256,12 +255,12 @@ GT_STATUS gpirlActivate
 *
 * DESCRIPTION:
 *       This routine deactivates Ingress Rate Limiting for the given bucket.
-*		It simply removes every ports from the Ingress Rate Resource.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the irlUnit before this function is called.
+*        It simply removes every ports from the Ingress Rate Resource.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the irlUnit before this function is called.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        irlUnit  - bucket to be used (0 ~ 11).
 *
 * OUTPUTS:
 *       None.
@@ -269,7 +268,7 @@ GT_STATUS gpirlActivate
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -278,38 +277,38 @@ GT_STATUS gpirlActivate
 *******************************************************************************/
 GT_STATUS gpirlDeactivate
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit
 )
 {
-	GT_STATUS       	retVal;
+    GT_STATUS           retVal;
 
-	DBG_INFO(("gpirlDectivate Called.\n"));
+    DBG_INFO(("gpirlDectivate Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* reset port's ingress resource bit */
-	retVal = pirlSetPortVec(dev, irlUnit, 0);
-	if(retVal != GT_OK)
-	{
+    /* reset port's ingress resource bit */
+    retVal = pirlSetPortVec(dev, irlUnit, 0);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -318,12 +317,12 @@ GT_STATUS gpirlDeactivate
 *
 * DESCRIPTION:
 *       This routine updates IRL Parameter.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
-*		pirlData - PIRL resource parameters.
+*        irlUnit  - bucket to be used (0 ~ 11).
+*        pirlData - PIRL resource parameters.
 *
 * OUTPUTS:
 *       None.
@@ -331,7 +330,7 @@ GT_STATUS gpirlDeactivate
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -340,125 +339,125 @@ GT_STATUS gpirlDeactivate
 *******************************************************************************/
 GT_STATUS gpirlUpdateParam
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_PIRL_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PORT_STP_STATE	pState[MAX_SWITCH_PORTS];
-	GT_LPORT			port;
-	GT_PIRL_RESOURCE	pirlRes;
-	GT_U32				portVec;
+    GT_STATUS           retVal;
+    GT_PORT_STP_STATE    pState[MAX_SWITCH_PORTS];
+    GT_LPORT            port;
+    GT_PIRL_RESOURCE    pirlRes;
+    GT_U32                portVec;
 
-	DBG_INFO(("gpirlUpdateParam Called.\n"));
+    DBG_INFO(("gpirlUpdateParam Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* get port list that share ingress resource */
-	retVal = pirlGetPortVec(dev, irlUnit, &portVec);
-	if(retVal != GT_OK)
-	{
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &portVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     /* check if the given portVec is valid */
-	if (!portVec)
+    if (!portVec)
     {
         DBG_INFO(("IRL Unit not Activated\n"));
-		return GT_FAIL;
-    }
-
-	/* Disable ports that share the bucket */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(!GT_IS_PORT_SET(portVec,port))
-			continue;
-
-		retVal = gstpGetPortState(dev, port, &pState[port]);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-
-		retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-	}
-
-	/* Program the Ingress Rate Resource Parameters */
-	retVal = pirlDataToResource(dev,pirlData,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
-    	return retVal;
-	}
-
-	retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	/* Initialize internal counrters for the bucket */
-	retVal = pirlInitIRLUnit(dev,irlUnit);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	/* Program PirlFCMode for each port that shares Bucket */
-	if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
-	{
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if(!GT_IS_PORT_SET(portVec,port))
-				continue;
-
-			retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
-			if(retVal != GT_OK)
-			{
-			    DBG_INFO(("PIRL FC Mode set failed.\n"));
-    			return retVal;
-			}
-		}
-	}
-
-	/* Set the ports in their original state */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(!GT_IS_PORT_SET(portVec,port))
-			continue;
-
-		retVal = gstpSetPortState(dev, port, pState[port]);
-		if(retVal != GT_OK)
-		{
-	        DBG_INFO(("Getting Port State failed\n"));
-			return retVal;
-		}
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+        return GT_FAIL;
+    }
+
+    /* Disable ports that share the bucket */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpGetPortState(dev, port, &pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+
+        retVal = gstpSetPortState(dev, port, GT_PORT_DISABLE);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirlDataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlWriteResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Initialize internal counrters for the bucket */
+    retVal = pirlInitIRLUnit(dev,irlUnit);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+
+            retVal = pirlSetFcMode(dev,port,pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode set failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    /* Set the ports in their original state */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(!GT_IS_PORT_SET(portVec,port))
+            continue;
+
+        retVal = gstpSetPortState(dev, port, pState[port]);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Getting Port State failed\n"));
+            return retVal;
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -468,19 +467,19 @@ GT_STATUS gpirlUpdateParam
 *
 * DESCRIPTION:
 *       This routine retrieves IRL Parameter.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        irlUnit  - bucket to be used (0 ~ 11).
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -489,81 +488,81 @@ GT_STATUS gpirlUpdateParam
 *******************************************************************************/
 GT_STATUS gpirlReadParam
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_PIRL_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_PIRL_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_LPORT			port;
-	GT_PIRL_RESOURCE	pirlRes;
-	GT_U32				portVec;
+    GT_STATUS           retVal;
+    GT_LPORT            port;
+    GT_PIRL_RESOURCE    pirlRes;
+    GT_U32                portVec;
 
-	DBG_INFO(("gpirlReadParam Called.\n"));
+    DBG_INFO(("gpirlReadParam Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* get port list that share ingress resource */
-	retVal = pirlGetPortVec(dev, irlUnit, &portVec);
-	if(retVal != GT_OK)
-	{
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &portVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     /* check if the given portVec is valid */
-	if (!portVec)
+    if (!portVec)
     {
         DBG_INFO(("IRL Unit not Activated\n"));
-		return GT_FAIL;
-    }
-
-	/* Read the Ingress Rate Resource Parameters */
-	retVal = pirlReadResource(dev,irlUnit,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Read Resource failed.\n"));
-    	return retVal;
-	}
-
-	retVal = pirlResourceToData(dev,&pirlRes,pirlData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
-    	return retVal;
-	}
-
-	/* Program PirlFCMode for each port that shares Bucket */
-	if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
-	{
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if(!GT_IS_PORT_SET(portVec,port))
-				continue;
-		
-			retVal = grcGetPirlFcMode(dev,port,&pirlData->fcDeassertMode[port]);
-			if(retVal != GT_OK)
-			{
-			    DBG_INFO(("PIRL FC Mode get failed.\n"));
-    			return retVal;
-			}
-		}
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+        return GT_FAIL;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirlReadResource(dev,irlUnit,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirlResourceToData(dev,&pirlRes,pirlData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
+        return retVal;
+    }
+
+    /* Program PirlFCMode for each port that shares Bucket */
+    if (pirlRes.ebsLimitAction == ESB_LIMIT_ACTION_FC)
+    {
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if(!GT_IS_PORT_SET(portVec,port))
+                continue;
+        
+            retVal = grcGetPirlFcMode(dev,port,&pirlData->fcDeassertMode[port]);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("PIRL FC Mode get failed.\n"));
+                return retVal;
+            }
+        }
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -574,11 +573,11 @@ GT_STATUS gpirlReadParam
 *
 * DESCRIPTION:
 *       This routine updates port list that share the bucket.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        irlUnit  - bucket to be used (0 ~ 11).
 *       portVec  - the list of ports that share the bucket.
 *
 * OUTPUTS:
@@ -587,7 +586,7 @@ GT_STATUS gpirlReadParam
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -596,62 +595,62 @@ GT_STATUS gpirlReadParam
 *******************************************************************************/
 GT_STATUS gpirlUpdatePortVec
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
 )
 {
-	GT_STATUS       retVal;
-	GT_U32			tmpVec;
+    GT_STATUS       retVal;
+    GT_U32            tmpVec;
 
-	DBG_INFO(("gpirlActivate Called.\n"));
+    DBG_INFO(("gpirlActivate Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
     /* check if the given portVec is valid */
-	if ((!portVec) || (portVec > (GT_U32)(1<<dev->numOfPorts)))
+    if ((!portVec) || (portVec > (GT_U32)(1<<dev->numOfPorts)))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* get port list that share ingress resource */
-	retVal = pirlGetPortVec(dev, irlUnit, &tmpVec);
-	if(retVal != GT_OK)
-	{
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, &tmpVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     /* check if the given portVec is valid */
-	if (!tmpVec)
+    if (!tmpVec)
     {
         DBG_INFO(("IRL Unit not Activated\n"));
-		return GT_FAIL;
+        return GT_FAIL;
     }
 
-	/* set or reset port's ingress resource bit based on the portVec */
-	retVal = pirlSetPortVec(dev, irlUnit, portVec);
-	if(retVal != GT_OK)
-	{
+    /* set or reset port's ingress resource bit based on the portVec */
+    retVal = pirlSetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -661,11 +660,11 @@ GT_STATUS gpirlUpdatePortVec
 *
 * DESCRIPTION:
 *       This routine retrieves port list that share the bucket.
-*		It is assumed that gpirlActivate has been successfully called with
-*		the given irlUnit before this function is called.
+*        It is assumed that gpirlActivate has been successfully called with
+*        the given irlUnit before this function is called.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used (0 ~ 11).
+*        irlUnit  - bucket to be used (0 ~ 11).
 *
 * OUTPUTS:
 *       portVec  - the list of ports that share the bucket.
@@ -673,7 +672,7 @@ GT_STATUS gpirlUpdatePortVec
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -682,46 +681,46 @@ GT_STATUS gpirlUpdatePortVec
 *******************************************************************************/
 GT_STATUS gpirlReadPortVec
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_U32		*portVec
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
 )
 {
-	GT_STATUS       retVal;
+    GT_STATUS       retVal;
 
-	DBG_INFO(("gpirlReadPortVec Called.\n"));
+    DBG_INFO(("gpirlReadPortVec Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if the given bucket number is valid */
-	if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
+    if (!GT_IS_IRLUNIT_VALID(dev,irlUnit))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	/* get port list that share ingress resource */
-	retVal = pirlGetPortVec(dev, irlUnit, portVec);
-	if(retVal != GT_OK)
-	{
+    /* get port list that share ingress resource */
+    retVal = pirlGetPortVec(dev, irlUnit, portVec);
+    if(retVal != GT_OK)
+    {
         DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     /* check if the given portVec is valid */
-	if (!*portVec)
+    if (!*portVec)
     {
         DBG_INFO(("IRL Unit not Activated\n"));
-		return GT_FAIL;
+        return GT_FAIL;
     }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -732,35 +731,35 @@ GT_STATUS gpirlReadPortVec
 *
 * DESCRIPTION:
 *       This routine gets Port Ingress Rate Limit Flow Control mode.
-*		When EBSLimitAction is programmed to generate a flow control message, 
-*		the deassertion of flow control is controlled by this mode.
-*			GT_PIRL_FC_DEASSERT_EMPTY:
-*				De-assert when the ingress rate resource has become empty
-*			GT_PIRL_FC_DEASSERT_CBS_LIMIT
-*				De-assert when the ingress rate resource has enough room as
-*				specified by the CBSLimit.
-*		Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
-*		CBSLimit.
+*        When EBSLimitAction is programmed to generate a flow control message, 
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
 *
 * INPUTS:
 *       port - logical port number
 *
 * OUTPUTS:
-*		mode - GT_PIRL_FC_DEASSERT enum type
+*        mode - GT_PIRL_FC_DEASSERT enum type
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcGetPirlFcMode
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_PIRL_FC_DEASSERT		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_FC_DEASSERT        *mode
 )
 {
     GT_U16          data;           
@@ -771,19 +770,19 @@ GT_STATUS grcGetPirlFcMode
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the PirlFcMode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,12,1,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     *mode = (GT_PIRL_FC_DEASSERT)data;
@@ -797,54 +796,54 @@ GT_STATUS grcGetPirlFcMode
 *
 * DESCRIPTION:
 *       This routine gets Ingress Rate Limiting Resources assigned to the port.
-*		This vector is used to attach specific counter resources to the physical
-*		port. And the same counter resource can be attached to more than one port.
+*        This vector is used to attach specific counter resources to the physical
+*        port. And the same counter resource can be attached to more than one port.
 *
 * INPUTS:
 *       port   - logical port number
 *
 * OUTPUTS:
-*		resVec - resource vector (bit 11:0, since there is 12 resources)
+*        resVec - resource vector (bit 11:0, since there is 12 resources)
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gpirlGetIngressRateResource
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_U32		*resVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U32        *resVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;        /* Physical port.               */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("grcGetIngressRateResource Called.\n"));
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the resource vector.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,0,12,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
-	*resVec = (GT_U32)data;
+    *resVec = (GT_U32)data;
 
     DBG_INFO(("OK.\n"));
 
@@ -856,7 +855,7 @@ GT_STATUS gpirlGetIngressRateResource
 *
 * DESCRIPTION:
 *       This function sets the current time update interval.
-*		Please contact FAE for detailed information.
+*        Please contact FAE for detailed information.
 *
 * INPUTS:
 *       upInt - updata interval (0 ~ 7)
@@ -867,7 +866,7 @@ GT_STATUS gpirlGetIngressRateResource
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -875,48 +874,48 @@ GT_STATUS gpirlGetIngressRateResource
 *******************************************************************************/
 GT_STATUS gpirlSetCurTimeUpInt
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				upInt
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
 )
 {
-    GT_STATUS       retVal;		/* Functions return value */
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (upInt > 0x7)
-		return GT_BAD_PARAM;
+    if (upInt > 0x7)
+        return GT_BAD_PARAM;
 
-	op = PIRL_READ_RESOURCE;
+    op = PIRL_READ_RESOURCE;
 
-	opData.irlUnit = 0xF;
-	opData.irlReg = 1;
-	opData.irlData = 0;
+    opData.irlUnit = 0xF;
+    opData.irlReg = 1;
+    opData.irlData = 0;
 
-	retVal = pirlOperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	op = PIRL_WRITE_RESOURCE;
-	opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
 
-	retVal = pirlOperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	return GT_OK;	
+    return GT_OK;    
 }
 
 /****************************************************************************/
@@ -944,35 +943,35 @@ GT_STATUS gpirlSetCurTimeUpInt
 *******************************************************************************/
 GT_STATUS gpirlInitialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 )
 {
-	GT_STATUS       	retVal;
-	GT_LPORT		port;
+    GT_STATUS           retVal;
+    GT_LPORT        port;
     GT_U8           hwPort;        /* Physical port.               */
 
-	/* reset port's ingress resource bit */
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-	    hwPort = GT_LPORT_2_PORT(port);
-
-	    /* Set the resource vector.            */
-    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,0,12,0);
-	    if(retVal != GT_OK)
-   		{
-	        DBG_INFO(("Failed.\n"));
-   		    return retVal;
-	    }
-	}
-
-	retVal = pirlInitialize(dev);
+    /* reset port's ingress resource bit */
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+
+        /* Set the resource vector.            */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,0,12,0);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+    }
+
+    retVal = pirlInitialize(dev);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	    return retVal;
+        return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -1005,12 +1004,30 @@ static GT_STATUS pirlOperationPerform
     INOUT GT_PIRL_OP_DATA     *opData
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
 
     gtSemTake(dev,dev->pirlRegsSem,OS_WAIT_FOREVER);
 
     /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -1021,87 +1038,125 @@ static GT_STATUS pirlOperationPerform
             return retVal;
         }
     }
+#endif
 
     /* Set the PIRL Operation register */
-	switch (pirlOp)
-	{
-		case PIRL_INIT_ALL_RESOURCE:
-			data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-		case PIRL_INIT_RESOURCE:
-			data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) | 
-					((opData->irlUnit&0xF)<< 4));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PIRL_WRITE_RESOURCE:
-			data = (GT_U16)opData->irlData;
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) | 
-					((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PIRL_READ_RESOURCE:
-			data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) | 
-					((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->pirlRegsSem);
-		            return retVal;
-        		}
-		    }
-
-			retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
-			opData->irlData = (GT_U32)data;
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-		    gtSemGive(dev,dev->pirlRegsSem);
-		    return retVal;
-
-		default:
-			
-			gtSemGive(dev,dev->pirlRegsSem);
-			return GT_FAIL;
-	}
+    switch (pirlOp)
+    {
+        case PIRL_INIT_ALL_RESOURCE:
+            data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+        case PIRL_INIT_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) | 
+                    ((opData->irlUnit&0xF)<< 4));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_WRITE_RESOURCE:
+            data = (GT_U16)opData->irlData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) | 
+                    ((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_READ_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) | 
+                    ((opData->irlUnit&0xF) << 4) | (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+  
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->pirlRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
+            opData->irlData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+
+        default:
+            
+            gtSemGive(dev,dev->pirlRegsSem);
+            return GT_FAIL;
+    }
 
     /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -1112,6 +1167,7 @@ static GT_STATUS pirlOperationPerform
             return retVal;
         }
     }
+#endif
 
     gtSemGive(dev,dev->pirlRegsSem);
     return retVal;
@@ -1122,28 +1178,28 @@ static GT_STATUS pirlOperationPerform
 */
 static GT_STATUS pirlInitialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-	GT_PIRL_OPERATION	op;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL_OPERATION    op;
 
-	op = PIRL_INIT_ALL_RESOURCE;
+    op = PIRL_INIT_ALL_RESOURCE;
 
-	retVal = pirlOperationPerform(dev, op, NULL);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirlOperationPerform(dev, op, NULL);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	retVal = gpirlSetCurTimeUpInt(dev,7);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-	}
+    retVal = gpirlSetCurTimeUpInt(dev,7);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*
@@ -1152,25 +1208,25 @@ static GT_STATUS pirlInitialize
 */
 static GT_STATUS pirlInitIRLUnit
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
 
-	op = PIRL_INIT_RESOURCE;
-	opData.irlUnit = irlUnit;
+    op = PIRL_INIT_RESOURCE;
+    opData.irlUnit = irlUnit;
 
-	retVal = pirlOperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirlOperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*
@@ -1179,136 +1235,136 @@ static GT_STATUS pirlInitIRLUnit
 */
 static GT_STATUS pirlDataToResource
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL_DATA		*pirlData,
-    OUT GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_DATA        *pirlData,
+    OUT GT_PIRL_RESOURCE    *res
 )
 {
-	GT_U16 typeMask;
-
-	switch(pirlData->accountQConf)
-	{
-		case GT_FALSE:
-		case GT_TRUE:
-			res->accountQConf = pirlData->accountQConf;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->accountFiltered)
-	{
-		case GT_FALSE:
-		case GT_TRUE:
-			res->accountFiltered = pirlData->accountFiltered;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->ebsLimitAction)
-	{
-		case ESB_LIMIT_ACTION_DROP:
-		case ESB_LIMIT_ACTION_FC:
-			res->ebsLimitAction = pirlData->ebsLimitAction;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	if(pirlData->customSetup.isValid == GT_TRUE)
-	{
-		res->ebsLimit = pirlData->customSetup.ebsLimit;
-		res->cbsLimit = pirlData->customSetup.cbsLimit;
-		res->bktIncrement = pirlData->customSetup.bktIncrement;
-		res->bktRateFactor = pirlData->customSetup.bktRateFactor;
-	}
-	else
-	{
-		if(pirlData->ingressRate == 0)
-			return GT_BAD_PARAM;
-
-		if(pirlData->ingressRate < 1000)	/* less than 1Mbps */
-		{
-			/* it should be divided by 64 */
-			if(pirlData->ingressRate % 64)
-				return GT_BAD_PARAM;
-			res->bktRateFactor = pirlData->ingressRate/64;
-		}
-		else if(pirlData->ingressRate <= 100000)	/* less than or equal to 100Mbps */
-		{
-			/* it should be divided by 1000 */
-			if(pirlData->ingressRate % 1000)
-				return GT_BAD_PARAM;
-			res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
-		}
-		else if(pirlData->ingressRate <= 200000)	/* less than or equal to 200Mbps */
-		{
-			/* it should be divided by 10000 */
-			if(pirlData->ingressRate % 10000)
-				return GT_BAD_PARAM;
-			res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
-		}
-		else
-			return GT_BAD_PARAM;
-
-		res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
-		res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
-		res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
-	}
-
-	switch(pirlData->bktRateType)
-	{
-		case BUCKET_TYPE_TRAFFIC_BASED:
-			res->bktRateType = pirlData->bktRateType;
-
-			if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
-			{
-				typeMask = 0xF;
-			}
-			else
-			{
-				typeMask = 0x7F;
-			}
-
-			if (pirlData->bktTypeMask > typeMask)
-			{
-				return GT_BAD_PARAM;
-			}
-			else
-			{
-				res->bktTypeMask = pirlData->bktTypeMask;
-			}
-
-			break;
-
-		case BUCKET_TYPE_RATE_BASED:
-			if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
-				return GT_BAD_PARAM;
-			res->bktRateType = pirlData->bktRateType;
-			res->bktTypeMask = 0;
-			break;
-
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->byteTobeCounted)
-	{
-		case GT_PIRL_COUNT_ALL_LAYER1:
-			res->byteTobeCounted = 1;
-			break;
-		case GT_PIRL_COUNT_ALL_LAYER2:
-			res->byteTobeCounted = 2;
-			break;
-		case GT_PIRL_COUNT_ALL_LAYER3:
-			res->byteTobeCounted = 6;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	return GT_OK;			
+    GT_U16 typeMask;
+ 
+    switch(pirlData->accountQConf)
+    {
+        case GT_FALSE:
+        case GT_TRUE:
+            res->accountQConf = pirlData->accountQConf;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->accountFiltered)
+    {
+        case GT_FALSE:
+        case GT_TRUE:
+            res->accountFiltered = pirlData->accountFiltered;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->ebsLimitAction)
+    {
+        case ESB_LIMIT_ACTION_DROP:
+        case ESB_LIMIT_ACTION_FC:
+            res->ebsLimitAction = pirlData->ebsLimitAction;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    if(pirlData->customSetup.isValid == GT_TRUE)
+    {
+        res->ebsLimit = pirlData->customSetup.ebsLimit;
+        res->cbsLimit = pirlData->customSetup.cbsLimit;
+        res->bktIncrement = pirlData->customSetup.bktIncrement;
+        res->bktRateFactor = pirlData->customSetup.bktRateFactor;
+    }
+    else
+    {
+        if(pirlData->ingressRate == 0)
+            return GT_BAD_PARAM;
+
+        if(pirlData->ingressRate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(pirlData->ingressRate % 64)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64;
+        }
+        else if(pirlData->ingressRate <= 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
+        }
+        else if(pirlData->ingressRate <= 200000)    /* less than or equal to 200Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(pirlData->ingressRate % 10000)
+                return GT_BAD_PARAM;
+            res->bktRateFactor = pirlData->ingressRate/64 + ((pirlData->ingressRate % 64)?1:0);
+        }
+        else
+            return GT_BAD_PARAM;
+
+        res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
+        res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
+        res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
+    }
+
+    switch(pirlData->bktRateType)
+    {
+        case BUCKET_TYPE_TRAFFIC_BASED:
+            res->bktRateType = pirlData->bktRateType;
+
+            if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
+            {
+                typeMask = 0xF;
+            }
+            else
+            {
+                typeMask = 0x7F;
+            }
+
+            if (pirlData->bktTypeMask > typeMask)
+            {
+                return GT_BAD_PARAM;
+            }
+            else
+            {
+                res->bktTypeMask = pirlData->bktTypeMask;
+            }
+
+            break;
+
+        case BUCKET_TYPE_RATE_BASED:
+            if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL_RESOURCE))
+                return GT_BAD_PARAM;
+            res->bktRateType = pirlData->bktRateType;
+            res->bktTypeMask = 0;
+            break;
+
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->byteTobeCounted)
+    {
+        case GT_PIRL_COUNT_ALL_LAYER1:
+            res->byteTobeCounted = 1;
+            break;
+        case GT_PIRL_COUNT_ALL_LAYER2:
+            res->byteTobeCounted = 2;
+            break;
+        case GT_PIRL_COUNT_ALL_LAYER3:
+            res->byteTobeCounted = 6;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;            
 }
 
 /*
@@ -1316,64 +1372,64 @@ static GT_STATUS pirlDataToResource
 */
 static GT_STATUS pirlResourceToData
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL_RESOURCE	*res,
-    OUT GT_PIRL_DATA		*pirlData
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL_RESOURCE    *res,
+    OUT GT_PIRL_DATA        *pirlData
 )
 {
-	GT_U32	rate;
-	GT_U32	factor;
-
-	pirlData->accountQConf = res->accountQConf;
-	pirlData->accountFiltered = res->accountFiltered;
-	pirlData->ebsLimitAction = res->ebsLimitAction;
-
-	pirlData->customSetup.isValid = GT_FALSE;
-
-	FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
-
-	rate = res->bktRateFactor * factor;
-	if(rate == 0)
-	{
-		pirlData->ingressRate = 0;
-		pirlData->customSetup.isValid = GT_TRUE;
-		pirlData->customSetup.ebsLimit = res->ebsLimit;
-		pirlData->customSetup.cbsLimit = res->cbsLimit;
-		pirlData->customSetup.bktIncrement = res->bktIncrement;
-		pirlData->customSetup.bktRateFactor = res->bktRateFactor;
-	}
-	else if(rate < 1000)
-	{
-		pirlData->ingressRate = rate;
-	}
-	else if(rate < 100000)
-	{
-		pirlData->ingressRate = rate - (rate % 1000);
-	}
-	else
-	{
-		pirlData->ingressRate = rate - (rate % 10000);
-	}
-
-	pirlData->bktRateType = res->bktRateType;
-	pirlData->bktTypeMask = res->bktTypeMask;
-
-	switch(res->byteTobeCounted)
-	{
-		case 1:
-			pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER1;
-			break;
-		case 2:
-			pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER2;
-			break;
-		case 6:
-			pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER3;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	return GT_OK;			
+    GT_U32    rate;
+    GT_U32    factor;
+
+    pirlData->accountQConf = res->accountQConf;
+    pirlData->accountFiltered = res->accountFiltered;
+    pirlData->ebsLimitAction = res->ebsLimitAction;
+
+    pirlData->customSetup.isValid = GT_FALSE;
+
+    FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
+
+    rate = res->bktRateFactor * factor;
+    if(rate == 0)
+    {
+        pirlData->ingressRate = 0;
+        pirlData->customSetup.isValid = GT_TRUE;
+        pirlData->customSetup.ebsLimit = res->ebsLimit;
+        pirlData->customSetup.cbsLimit = res->cbsLimit;
+        pirlData->customSetup.bktIncrement = res->bktIncrement;
+        pirlData->customSetup.bktRateFactor = res->bktRateFactor;
+    }
+    else if(rate < 1000)
+    {
+        pirlData->ingressRate = rate;
+    }
+    else if(rate < 100000)
+    {
+        pirlData->ingressRate = rate - (rate % 1000);
+    }
+    else
+    {
+        pirlData->ingressRate = rate - (rate % 10000);
+    }
+
+    pirlData->bktRateType = res->bktRateType;
+    pirlData->bktTypeMask = res->bktTypeMask;
+
+    switch(res->byteTobeCounted)
+    {
+        case 1:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER1;
+            break;
+        case 2:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER2;
+            break;
+        case 6:
+            pirlData->byteTobeCounted = GT_PIRL_COUNT_ALL_LAYER3;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;            
 }
 
 /*******************************************************************************
@@ -1383,8 +1439,8 @@ static GT_STATUS pirlResourceToData
 *       This function writes IRL Resource to BCM (Bucket Configuration Memory)
 *
 * INPUTS:
-*		irlUnit - resource unit to be accessed
-*       res 	- IRL Resource data
+*        irlUnit - resource unit to be accessed
+*       res     - IRL Resource data
 *
 * OUTPUTS:
 *       Nont.
@@ -1398,62 +1454,62 @@ static GT_STATUS pirlResourceToData
 *******************************************************************************/
 static GT_STATUS pirlWriteResource
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit,
-    IN  GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN  GT_PIRL_RESOURCE    *res
 )
 {
-    GT_STATUS       retVal;			/* Functions return value */
-    GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
-	int				i;
-
-	op = PIRL_WRITE_RESOURCE;
-
-	/* reg0 data */
-	data[0] = (GT_U16)((res->bktRateType << 15) |	/* Bit[15] : Bucket Rate Type */
-			  		(res->bktTypeMask << 4 ) |		/* Bit[14:4] : Traffic Type   */
-			  		res->byteTobeCounted );			/* Bit[3:0] : Bytes to be counted */
-
-	/* reg1 data */
-	data[1] = (GT_U16)res->bktIncrement;	/* Bit[11:0] : Bucket Increment */
-
-	/* reg2 data */
-	data[2] = (GT_U16)res->bktRateFactor;	/* Bit[15:0] : Bucket Rate Factor */
-
-	/* reg3 data */
-	data[3] = (GT_U16)(res->cbsLimit & 0xFFF) << 4;	/* Bit[15:4] : CBS Limit[11:0] */
-
-	/* reg4 data */
-	data[4] = (GT_U16)(res->cbsLimit >> 12);		/* Bit[11:0] : CBS Limit[23:12] */
-
-	/* reg5 data */
-	data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);		/* Bit[15:0] : EBS Limit[15:0] */
-
-	/* reg6 data */
-	data[6] = (GT_U16)((res->ebsLimit >> 16)	|	/* Bit[7:0] : EBS Limit[23:16] */
-					(res->ebsLimitAction << 12)	|	/* Bit[12] : EBS Limit Action */
-					(res->accountFiltered << 14)|	/* Bit[14] : Account Filtered */
-					(res->accountQConf << 15));		/* Bit[15] : Account QConf */
-	/* reg7 data */
-	data[7] = 0;	/* Reserved */
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlUnit = irlUnit;
-		opData.irlReg = i;
-		opData.irlData = data[i];
-
-		retVal = pirlOperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-	}
-
-	return GT_OK;	
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = (GT_U16)((res->bktRateType << 15) |    /* Bit[15] : Bucket Rate Type */
+                      (res->bktTypeMask << 4 ) |        /* Bit[14:4] : Traffic Type   */
+                      res->byteTobeCounted );            /* Bit[3:0] : Bytes to be counted */
+
+    /* reg1 data */
+    data[1] = (GT_U16)res->bktIncrement;    /* Bit[11:0] : Bucket Increment */
+
+    /* reg2 data */
+    data[2] = (GT_U16)res->bktRateFactor;    /* Bit[15:0] : Bucket Rate Factor */
+
+    /* reg3 data */
+    data[3] = (GT_U16)(res->cbsLimit & 0xFFF) << 4;    /* Bit[15:4] : CBS Limit[11:0] */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)((res->ebsLimit >> 16)    |    /* Bit[7:0] : EBS Limit[23:16] */
+                    (res->ebsLimitAction << 12)    |    /* Bit[12] : EBS Limit Action */
+                    (res->accountFiltered << 14)|    /* Bit[14] : Account Filtered */
+                    (res->accountQConf << 15));        /* Bit[15] : Account QConf */
+    /* reg7 data */
+    data[7] = 0;    /* Reserved */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;    
 }
 
 
@@ -1464,7 +1520,7 @@ static GT_STATUS pirlWriteResource
 *       This function reads IRL Resource from BCM (Bucket Configuration Memory)
 *
 * INPUTS:
-*		irlUnit - resource unit to be accessed
+*        irlUnit - resource unit to be accessed
 *
 * OUTPUTS:
 *       res - IRL Resource data
@@ -1478,60 +1534,60 @@ static GT_STATUS pirlWriteResource
 *******************************************************************************/
 static GT_STATUS pirlReadResource
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit,
-    OUT GT_PIRL_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    OUT GT_PIRL_RESOURCE    *res
 )
 {
-    GT_STATUS       retVal;			/* Functions return value */
-    GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
-	int				i;
-
-	op = PIRL_READ_RESOURCE;
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlUnit = irlUnit;
-		opData.irlReg = i;
-		opData.irlData = 0;
-
-		retVal = pirlOperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-
-		data[i] = (GT_U16)opData.irlData;
-	}
-	
-
-	/* reg0 data */
-	res->bktRateType = (data[0] >> 15) & 0x1;
-	res->bktTypeMask = (data[0] >> 4) & 0x7F;
-
-	res->byteTobeCounted = data[0] & 0xF;
-
-	/* reg1 data */
-	res->bktIncrement = data[1] & 0xFFF;
-
-	/* reg2 data */
-	res->bktRateFactor = data[2] & 0xFFFF;
-
-	/* reg3,4 data */
-	res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
-
-	/* reg5,6 data */
-	res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
-													   
-	/* reg6 data */
-	res->ebsLimitAction = (data[6] >> 12) & 0x1;
-	res->accountFiltered = (data[6] >> 14) & 0x1;
-	res->accountQConf = (data[6] >> 15) & 0x1;
-
-	return GT_OK;
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+    
+
+    /* reg0 data */
+    res->bktRateType = (data[0] >> 15) & 0x1;
+    res->bktTypeMask = (data[0] >> 4) & 0x7F;
+
+    res->byteTobeCounted = data[0] & 0xF;
+
+    /* reg1 data */
+    res->bktIncrement = data[1] & 0xFFF;
+
+    /* reg2 data */
+    res->bktRateFactor = data[2] & 0xFFFF;
+
+    /* reg3,4 data */
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
+                                                       
+    /* reg6 data */
+    res->ebsLimitAction = (data[6] >> 12) & 0x1;
+    res->accountFiltered = (data[6] >> 14) & 0x1;
+    res->accountQConf = (data[6] >> 15) & 0x1;
+
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -1539,10 +1595,10 @@ static GT_STATUS pirlReadResource
 *
 * DESCRIPTION:
 *       This routine sets port list that share the bucket and resets ports that
-*		do not share the bucket.
+*        do not share the bucket.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used.
+*        irlUnit  - bucket to be used.
 *       portVec  - the list of ports that share the bucket.
 *
 * OUTPUTS:
@@ -1557,33 +1613,33 @@ static GT_STATUS pirlReadResource
 *******************************************************************************/
 static GT_STATUS pirlSetPortVec
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_U32		irlUnit,
-	IN  GT_U32		portVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    IN  GT_U32        portVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_LPORT		port;
+    GT_LPORT        port;
     GT_U8           hwPort;        /* Physical port.               */
-	GT_U16			data;
-
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-		if(GT_IS_PORT_SET(portVec,port))
-			data = 1;
-		else
-			data = 0;
-
-	    hwPort = GT_LPORT_2_PORT(port);
-
-	    /* Set the resource vector.            */
-    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,data);
-	    if(retVal != GT_OK)
-   		{
-	        DBG_INFO(("Failed.\n"));
-   		    return retVal;
-	    }
-	}
+    GT_U16            data;
+
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        if(GT_IS_PORT_SET(portVec,port))
+            data = 1;
+        else
+            data = 0;
+
+        hwPort = GT_LPORT_2_PORT(port);
+
+        /* Set the resource vector.            */
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,data);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+    }
 
     DBG_INFO(("OK.\n"));
 
@@ -1598,7 +1654,7 @@ static GT_STATUS pirlSetPortVec
 *       This routine gets port list that share the bucket.
 *
 * INPUTS:
-*		irlUnit  - bucket to be used.
+*        irlUnit  - bucket to be used.
 *
 * OUTPUTS:
 *       portVec  - the list of ports that share the bucket.
@@ -1612,33 +1668,33 @@ static GT_STATUS pirlSetPortVec
 *******************************************************************************/
 static GT_STATUS pirlGetPortVec
 (
-    IN  GT_QD_DEV	*dev,
-	IN  GT_U32		irlUnit,
-	OUT GT_U32		*portVec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        irlUnit,
+    OUT GT_U32        *portVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_LPORT		port;
+    GT_LPORT        port;
     GT_U8           hwPort;        /* Physical port.               */
-	GT_U16			data;
+    GT_U16            data;
 
-	*portVec = 0;
+    *portVec = 0;
 
-	for(port=0; port<dev->numOfPorts; port++)
-	{
-	    hwPort = GT_LPORT_2_PORT(port);
+    for(port=0; port<dev->numOfPorts; port++)
+    {
+        hwPort = GT_LPORT_2_PORT(port);
 
-	    /* Set the resource vector.            */
-    	retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,&data);
-	    if(retVal != GT_OK)
-   		{
-	        DBG_INFO(("Failed.\n"));
-   		    return retVal;
-	    }
+        /* Set the resource vector.            */
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,(GT_U8)irlUnit,1,&data);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
 
-		if(data == 1)
-			*portVec |= (1 << port);
-	}
+        if(data == 1)
+            *portVec |= (1 << port);
+    }
 
     DBG_INFO(("OK.\n"));
 
@@ -1651,36 +1707,36 @@ static GT_STATUS pirlGetPortVec
 *
 * DESCRIPTION:
 *       This routine gets Port Ingress Rate Limit Flow Control mode.
-*		When EBSLimitAction is programmed to generate a flow control message, 
-*		the deassertion of flow control is controlled by this mode.
-*			GT_PIRL_FC_DEASSERT_EMPTY:
-*				De-assert when the ingress rate resource has become empty
-*			GT_PIRL_FC_DEASSERT_CBS_LIMIT
-*				De-assert when the ingress rate resource has enough room as
-*				specified by the CBSLimit.
-*		Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
-*		CBSLimit.
+*        When EBSLimitAction is programmed to generate a flow control message, 
+*        the deassertion of flow control is controlled by this mode.
+*            GT_PIRL_FC_DEASSERT_EMPTY:
+*                De-assert when the ingress rate resource has become empty
+*            GT_PIRL_FC_DEASSERT_CBS_LIMIT
+*                De-assert when the ingress rate resource has enough room as
+*                specified by the CBSLimit.
+*        Please refer to GT_PIRL_RESOURCE structure for EBSLimitAction and
+*        CBSLimit.
 *
 * INPUTS:
 *       port - logical port number
-*		mode - GT_PIRL_FC_DEASSERT enum type
+*        mode - GT_PIRL_FC_DEASSERT enum type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 static GT_STATUS pirlSetFcMode
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_PIRL_FC_DEASSERT		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_FC_DEASSERT        mode
 )
 {
     GT_U16          data;           
@@ -1691,14 +1747,14 @@ static GT_STATUS pirlSetFcMode
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	data = (GT_U16) mode;
+    data = (GT_U16) mode;
 
     /* Set the PirlFcMode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,12,1,data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -1715,8 +1771,8 @@ static GT_STATUS pirlSetFcMode
 *       This function dumps IRL Resource register values.
 *
 * INPUTS:
-*		irlUnit  - resource unit to be accessed
-*		dataLen  - data size.
+*        irlUnit  - resource unit to be accessed
+*        dataLen  - data size.
 *
 * OUTPUTS:
 *       data - IRL Resource data
@@ -1730,42 +1786,42 @@ static GT_STATUS pirlSetFcMode
 *******************************************************************************/
 GT_STATUS pirlDumpResource
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlUnit,
-	IN	GT_U32				dataLen,
-    OUT GT_U16				*data
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlUnit,
+    IN    GT_U32                dataLen,
+    OUT GT_U16                *data
 )
 {
-    GT_STATUS       retVal;		/* Functions return value */
-	GT_PIRL_OPERATION	op;
-	GT_PIRL_OP_DATA		opData;
-	GT_U32				i;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL_OPERATION    op;
+    GT_PIRL_OP_DATA        opData;
+    GT_U32                i;
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	op = PIRL_READ_RESOURCE;
+    op = PIRL_READ_RESOURCE;
 
-	for(i=0; i<dataLen; i++)
-	{
-		opData.irlUnit = irlUnit;
-		opData.irlReg = i;
-		opData.irlData = 0;
+    for(i=0; i<dataLen; i++)
+    {
+        opData.irlUnit = irlUnit;
+        opData.irlReg = i;
+        opData.irlData = 0;
 
-		retVal = pirlOperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
+        retVal = pirlOperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
 
-		data[i] = (GT_U16)opData.irlData;
-	}
+        data[i] = (GT_U16)opData.irlData;
+    }
 
-	return GT_OK;	
+    return GT_OK;    
 }
 #endif /* PIRL_DEBUG */
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c
old mode 100644
new mode 100755
index 04f3803..149a1d8
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPIRL2.c
@@ -21,171 +21,171 @@
 /****************************************************************************/
 static GT_STATUS pirl2OperationPerform
 (
-	IN   GT_QD_DEV            *dev,
-	IN   GT_PIRL2_OPERATION    pirlOp,
-	INOUT GT_PIRL2_OP_DATA     *opData
+    IN   GT_QD_DEV            *dev,
+    IN   GT_PIRL2_OPERATION    pirlOp,
+    INOUT GT_PIRL2_OP_DATA     *opData
 );
 
 static GT_STATUS pirl2Initialize
 (
-	IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 );
 
 static GT_STATUS pirl2InitIRLResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
 );
 
 static GT_STATUS pirl2DisableIRLResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
 );
 
 static GT_STATUS pirl2DataToResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN  GT_PIRL2_DATA		*pirlData,
-	OUT GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_DATA        *pirlData,
+    OUT GT_PIRL2_RESOURCE    *res
 );
 
 static GT_STATUS pirl2ResourceToData
 (
-	IN  GT_QD_DEV  			*dev,
-	IN  GT_PIRL2_RESOURCE	*res,
-	OUT GT_PIRL2_DATA		*pirlData
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_RESOURCE    *res,
+    OUT GT_PIRL2_DATA        *pirlData
 );
 
 static GT_STATUS pirl2WriteResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	IN  GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_RESOURCE    *res
 );
 
 static GT_STATUS pirl2ReadResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	OUT GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_RESOURCE    *res
 );
 
 static GT_STATUS pirl2WriteTSMResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	IN  GT_PIRL2_TSM_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_TSM_RESOURCE    *res
 );
 
 static GT_STATUS pirl2ReadTSMResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	OUT GT_PIRL2_TSM_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_TSM_RESOURCE    *res
 );
 
 /*******************************************************************************
 * gpirl2WriteResource
 *
 * DESCRIPTION:
-*		This routine writes resource bucket parameters to the given resource
-*		of the port.
+*        This routine writes resource bucket parameters to the given resource
+*        of the port.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
-*		pirlData - PIRL resource parameters.
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        pirlData - PIRL resource parameters.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gpirl2WriteResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	IN  GT_PIRL2_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PIRL2_RESOURCE	pirlRes;
-	GT_U32           	irlPort;         /* the physical port number     */
-	GT_U32				maxRes;
+    GT_STATUS           retVal;
+    GT_PIRL2_RESOURCE    pirlRes;
+    GT_U32               irlPort;         /* the physical port number     */
+    GT_U32                maxRes;
 
-	DBG_INFO(("gpirl2WriteResource Called.\n"));
+    DBG_INFO(("gpirl2WriteResource Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* check if the given bucket number is valid */
-	if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
-	{
-		maxRes = 2;
-	}
-	else
-	{
-		maxRes = 5;
-	}
-
-	if (irlRes >= maxRes)
-	{
-		DBG_INFO(("GT_BAD_PARAM irlRes\n"));
-		return GT_BAD_PARAM;
-	}
-
-	irlPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (irlPort == GT_INVALID_PORT)
-	{
-		DBG_INFO(("GT_BAD_PARAM port\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* Initialize internal counters */
-	retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	/* Program the Ingress Rate Resource Parameters */
-	retVal = pirl2DataToResource(dev,pirlData,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
-    	return retVal;
-	}
-
-	retVal = pirl2WriteResource(dev,irlPort,irlRes,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    /* Program the Ingress Rate Resource Parameters */
+    retVal = pirl2DataToResource(dev,pirlData,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Data to PIRL Resource conversion failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirl2WriteResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -193,87 +193,87 @@ GT_STATUS gpirl2WriteResource
 * gpirl2ReadResource
 *
 * DESCRIPTION:
-*		This routine retrieves IRL Parameter.
+*        This routine retrieves IRL Parameter.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 4).
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gpirl2ReadResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	OUT GT_PIRL2_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				irlPort;
-	GT_PIRL2_RESOURCE	pirlRes;
-	GT_U32				maxRes;
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_PIRL2_RESOURCE    pirlRes;
+    GT_U32                maxRes;
 
-	DBG_INFO(("gpirl2ReadResource Called.\n"));
+    DBG_INFO(("gpirl2ReadResource Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* check if the given bucket number is valid */
-	if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
-	{
-		maxRes = 2;
-	}
-	else
-	{
-		maxRes = 5;
-	}
-
-	if (irlRes >= maxRes)
-	{
-		DBG_INFO(("GT_BAD_PARAM irlRes\n"));
-		return GT_BAD_PARAM;
-	}
-
-	irlPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (irlPort == GT_INVALID_PORT)
-	{
-		DBG_INFO(("GT_BAD_PARAM port\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* Read the Ingress Rate Resource Parameters */
-	retVal = pirl2ReadResource(dev,irlPort,irlRes,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Read Resource failed.\n"));
-    	return retVal;
-	}
-
-	retVal = pirl2ResourceToData(dev,&pirlRes,pirlData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
-    	return retVal;
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirl2ReadResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    retVal = pirl2ResourceToData(dev,&pirlRes,pirlData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Resource to PIRL Data conversion failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -286,7 +286,7 @@ GT_STATUS gpirl2ReadResource
 *
 * INPUTS:
 *       port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
+*        irlRes   - bucket to be used (0 ~ 4).
 *
 * OUTPUTS:
 *       None.
@@ -294,7 +294,7 @@ GT_STATUS gpirl2ReadResource
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -303,57 +303,57 @@ GT_STATUS gpirl2ReadResource
 *******************************************************************************/
 GT_STATUS gpirl2DisableResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				irlPort;
-	GT_U32				maxRes;
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_U32                maxRes;
 
-	DBG_INFO(("gpirl2Dectivate Called.\n"));
+    DBG_INFO(("gpirl2Dectivate Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* check if the given bucket number is valid */
-	if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
-	{
-		maxRes = 2;
-	}
-	else
-	{
-		maxRes = 5;
-	}
-
-	if (irlRes >= maxRes)
-	{
-		DBG_INFO(("GT_BAD_PARAM irlRes\n"));
-		return GT_BAD_PARAM;
-	}
-
-	irlPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (irlPort == GT_INVALID_PORT)
-	{
-		DBG_INFO(("GT_BAD_PARAM port\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* disable irl resource */
-	retVal = pirl2DisableIRLResource(dev, irlPort, irlRes);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Getting Port State failed\n"));
-		return retVal;
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        maxRes = 2;
+    }
+    else
+    {
+        maxRes = 5;
+    }
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* disable irl resource */
+    retVal = pirl2DisableIRLResource(dev, irlPort, irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Getting Port State failed\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -361,7 +361,7 @@ GT_STATUS gpirl2DisableResource
 *
 * DESCRIPTION:
 *       This function sets the current time update interval.
-*		Please contact FAE for detailed information.
+*        Please contact FAE for detailed information.
 *
 * INPUTS:
 *       upInt - updata interval (0 ~ 7)
@@ -372,7 +372,7 @@ GT_STATUS gpirl2DisableResource
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -380,49 +380,49 @@ GT_STATUS gpirl2DisableResource
 *******************************************************************************/
 GT_STATUS gpirl2SetCurTimeUpInt
 (
-    IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				upInt
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                upInt
 )
 {
-    GT_STATUS       retVal;		/* Functions return value */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA	opData;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (upInt > 0x7)
-		return GT_BAD_PARAM;
+    if (upInt > 0x7)
+        return GT_BAD_PARAM;
 
-	op = PIRL_READ_RESOURCE;
+    op = PIRL_READ_RESOURCE;
 
-	opData.irlPort = 0xF;
-	opData.irlRes = 0;
-	opData.irlReg = 1;
-	opData.irlData = 0;
+    opData.irlPort = 0xF;
+    opData.irlRes = 0;
+    opData.irlReg = 1;
+    opData.irlData = 0;
 
-	retVal = pirl2OperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	op = PIRL_WRITE_RESOURCE;
-	opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
+    op = PIRL_WRITE_RESOURCE;
+    opData.irlData = (opData.irlData & 0xFFF8) | (GT_U16)upInt;
 
-	retVal = pirl2OperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-   	    DBG_INFO(("PIRL OP Failed.\n"));
-       	return retVal;
-	}
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+           DBG_INFO(("PIRL OP Failed.\n"));
+           return retVal;
+    }
 
-	return GT_OK;	
+    return GT_OK;    
 }
 
 
@@ -430,149 +430,149 @@ GT_STATUS gpirl2SetCurTimeUpInt
 * gpirl2WriteTSMResource
 *
 * DESCRIPTION:
-*		This routine writes rate resource bucket parameters in Time Slot Metering
-*		mode to the given resource of the port.
+*        This routine writes rate resource bucket parameters in Time Slot Metering
+*        mode to the given resource of the port.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 1).
-*		pirlData - PIRL TSM resource parameters.
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
+*        pirlData - PIRL TSM resource parameters.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Only Resource 0 and 1 can be supported for TSM Mode.
+*        Only Resource 0 and 1 can be supported for TSM Mode.
 *
 *******************************************************************************/
 GT_STATUS gpirl2WriteTSMResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	IN  GT_PIRL2_TSM_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    IN  GT_PIRL2_TSM_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PIRL2_TSM_RESOURCE	pirlRes;
-	GT_U32           	irlPort;         /* the physical port number     */
-	GT_U32				maxRes;
-	GT_U32				cbs, cts, i, rate;
+    GT_STATUS           retVal;
+    GT_PIRL2_TSM_RESOURCE    pirlRes;
+    GT_U32               irlPort;         /* the physical port number     */
+    GT_U32                maxRes;
+    GT_U32                cbs, cts, i, rate;
 
-	DBG_INFO(("gpirl2WriteTSMResource Called.\n"));
+    DBG_INFO(("gpirl2WriteTSMResource Called.\n"));
 
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* check if the given bucket number is valid */
-	maxRes = 2;
-
-	if (irlRes >= maxRes)
-	{
-		DBG_INFO(("GT_BAD_PARAM irlRes\n"));
-		return GT_BAD_PARAM;
-	}
-
-	irlPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (irlPort == GT_INVALID_PORT)
-	{
-		DBG_INFO(("GT_BAD_PARAM port\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* Initialize internal counters */
-	retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	if (pirlData->customSetup.isValid == GT_TRUE)
-	{
-		pirlRes.cbsLimit = pirlData->customSetup.cbsLimit;
-		pirlRes.ctsIntv = pirlData->customSetup.ctsIntv;
-		pirlRes.ebsLimit = pirlData->customSetup.ebsLimit;
-		pirlRes.actionMode = pirlData->customSetup.actionMode;
-	}
-	else
-	{
-		/* convert ingressRate to cbsLimit and ctsIntv */
-		cts = 1; 
-		cbs = 0;
-		i = 3;
-		rate = pirlData->ingressRate;
-		while(cts < 16)
-		{
-			cbs = TSM_GET_CBS(rate, cts);
-			if ((cbs == 0) || (cbs <= 0xFFFF))
-				break;
-			cts += i;
-			i = cts;
-		}
-
-		if (cts > 16)
-		{
-			return GT_BAD_PARAM;
-		}
-
-		switch (cts)
-		{
-			case 1:
-				pirlRes.ctsIntv = 3;
-				break;
-			case 4:
-				pirlRes.ctsIntv = 2;
-				break;
-			case 8:
-				pirlRes.ctsIntv = 1;
-				break;
-			case 16:
-				pirlRes.ctsIntv = 0;
-				break;
-			default:
-				return GT_FAIL;
-		}
-
-		pirlRes.cbsLimit = cbs;
-		pirlRes.ebsLimit = 0xFFFF;
-		pirlRes.actionMode = 1;
-	}
-
-	pirlRes.mgmtNrlEn = pirlData->mgmtNrlEn;
-	pirlRes.priMask = pirlData->priMask;
-	pirlRes.tsmMode = GT_TRUE;
-
-	if (pirlData->tsmMode == GT_FALSE)
-	{
-		pirlRes.tsmMode = 0;
-		pirlRes.cbsLimit = 0;
-		pirlRes.ctsIntv = 0;
-		pirlRes.ebsLimit = 0;
-		pirlRes.actionMode = 0;
-		pirlRes.mgmtNrlEn = 0;
-		pirlRes.priMask = 0;
-	}
-
-	retVal = pirl2WriteTSMResource(dev,irlPort,irlRes,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Write Resource failed.\n"));
-    	return retVal;
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    maxRes = 2;
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Initialize internal counters */
+    retVal = pirl2InitIRLResource(dev,irlPort,irlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    if (pirlData->customSetup.isValid == GT_TRUE)
+    {
+        pirlRes.cbsLimit = pirlData->customSetup.cbsLimit;
+        pirlRes.ctsIntv = pirlData->customSetup.ctsIntv;
+        pirlRes.ebsLimit = pirlData->customSetup.ebsLimit;
+        pirlRes.actionMode = pirlData->customSetup.actionMode;
+    }
+    else
+    {
+        /* convert ingressRate to cbsLimit and ctsIntv */
+        cts = 1; 
+        cbs = 0;
+        i = 3;
+        rate = pirlData->ingressRate;
+        while(cts < 16)
+        {
+            cbs = TSM_GET_CBS(rate, cts);
+            if ((cbs == 0) || (cbs <= 0xFFFF))
+                break;
+            cts += i;
+            i = cts;
+        }
+
+        if (cts > 16)
+        {
+            return GT_BAD_PARAM;
+        }
+
+        switch (cts)
+        {
+            case 1:
+                pirlRes.ctsIntv = 3;
+                break;
+            case 4:
+                pirlRes.ctsIntv = 2;
+                break;
+            case 8:
+                pirlRes.ctsIntv = 1;
+                break;
+            case 16:
+                pirlRes.ctsIntv = 0;
+                break;
+            default:
+                return GT_FAIL;
+        }
+
+        pirlRes.cbsLimit = cbs;
+        pirlRes.ebsLimit = 0xFFFF;
+        pirlRes.actionMode = 1;
+    }
+
+    pirlRes.mgmtNrlEn = pirlData->mgmtNrlEn;
+    pirlRes.priMask = pirlData->priMask;
+    pirlRes.tsmMode = GT_TRUE;
+
+    if (pirlData->tsmMode == GT_FALSE)
+    {
+        pirlRes.tsmMode = 0;
+        pirlRes.cbsLimit = 0;
+        pirlRes.ctsIntv = 0;
+        pirlRes.ebsLimit = 0;
+        pirlRes.actionMode = 0;
+        pirlRes.mgmtNrlEn = 0;
+        pirlRes.priMask = 0;
+    }
+
+    retVal = pirl2WriteTSMResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Write Resource failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -580,120 +580,120 @@ GT_STATUS gpirl2WriteTSMResource
 * gpirl2ReadTSMResource
 *
 * DESCRIPTION:
-*		This routine retrieves IRL Parameter.
-*		Returned ingressRate would be rough number. Instead, customSetup will
-*		have the exact configured value.
+*        This routine retrieves IRL Parameter.
+*        Returned ingressRate would be rough number. Instead, customSetup will
+*        have the exact configured value.
 *
 * INPUTS:
-*		port     - logical port number.
-*		irlRes   - bucket to be used (0 ~ 1).
+*        port     - logical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
 *
 * OUTPUTS:
-*		pirlData - PIRL resource parameters.
+*        pirlData - PIRL resource parameters.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Only Resource 0 and 1 can be supported for TSM Mode.
+*        Only Resource 0 and 1 can be supported for TSM Mode.
 *
 *******************************************************************************/
 GT_STATUS gpirl2ReadTSMResource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		irlRes,
-	OUT GT_PIRL2_TSM_DATA	*pirlData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        irlRes,
+    OUT GT_PIRL2_TSM_DATA    *pirlData
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				irlPort;
-	GT_PIRL2_TSM_RESOURCE	pirlRes;
-	GT_U32				maxRes, cbs, cts;
-
-	DBG_INFO(("gpirl2ReadTSMResource Called.\n"));
-
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the given bucket number is valid */
-	maxRes = 2;
-
-	if (irlRes >= maxRes)
-	{
-		DBG_INFO(("GT_BAD_PARAM irlRes\n"));
-		return GT_BAD_PARAM;
-	}
-
-	irlPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (irlPort == GT_INVALID_PORT)
-	{
-		DBG_INFO(("GT_BAD_PARAM port\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* Read the Ingress Rate Resource Parameters */
-	retVal = pirl2ReadTSMResource(dev,irlPort,irlRes,&pirlRes);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("PIRL Read Resource failed.\n"));
-    	return retVal;
-	}
-
-	if (pirlRes.tsmMode == 0)
-	{
-		/* TMS Mode is not enabled */
-		pirlData->tsmMode = GT_FALSE;
-		pirlData->ingressRate = 0;
-		pirlData->mgmtNrlEn = 0;
-		pirlData->priMask = 0;
-		pirlData->customSetup.isValid = 0;
-		pirlData->customSetup.cbsLimit = 0;
-		pirlData->customSetup.ctsIntv = 0;
-		pirlData->customSetup.ebsLimit = 0;
-		pirlData->customSetup.actionMode = 0;
-		return GT_OK;
-	}
-
-	cbs = pirlRes.cbsLimit;
-	switch (pirlRes.ctsIntv)
-	{
-		case 0:
-			cts = 16;
-			break;
-		case 1:
-			cts = 8;
-			break;
-		case 2:
-			cts = 4;
-			break;
-		case 3:
-			cts = 1;
-			break;
-		default:
-			return GT_FAIL;
-	}
-
-	pirlData->ingressRate = TSM_GET_RATE(cbs,cts);
-
-	pirlData->mgmtNrlEn = pirlRes.mgmtNrlEn;
-	pirlData->priMask = pirlRes.priMask;
-
-	pirlData->customSetup.isValid = GT_TRUE;
-	pirlData->customSetup.cbsLimit = pirlRes.cbsLimit;
-	pirlData->customSetup.ctsIntv = pirlRes.ctsIntv;
-	pirlData->customSetup.ebsLimit = pirlRes.ebsLimit;
-	pirlData->customSetup.actionMode = pirlRes.actionMode;
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    GT_STATUS           retVal;
+    GT_U32                irlPort;
+    GT_PIRL2_TSM_RESOURCE    pirlRes;
+    GT_U32                maxRes, cbs, cts;
+
+    DBG_INFO(("gpirl2ReadTSMResource Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TSM_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given bucket number is valid */
+    maxRes = 2;
+
+    if (irlRes >= maxRes)
+    {
+        DBG_INFO(("GT_BAD_PARAM irlRes\n"));
+        return GT_BAD_PARAM;
+    }
+
+    irlPort = (GT_U32)GT_LPORT_2_PORT(port);
+    if (irlPort == GT_INVALID_PORT)
+    {
+        DBG_INFO(("GT_BAD_PARAM port\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Read the Ingress Rate Resource Parameters */
+    retVal = pirl2ReadTSMResource(dev,irlPort,irlRes,&pirlRes);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL Read Resource failed.\n"));
+        return retVal;
+    }
+
+    if (pirlRes.tsmMode == 0)
+    {
+        /* TMS Mode is not enabled */
+        pirlData->tsmMode = GT_FALSE;
+        pirlData->ingressRate = 0;
+        pirlData->mgmtNrlEn = 0;
+        pirlData->priMask = 0;
+        pirlData->customSetup.isValid = 0;
+        pirlData->customSetup.cbsLimit = 0;
+        pirlData->customSetup.ctsIntv = 0;
+        pirlData->customSetup.ebsLimit = 0;
+        pirlData->customSetup.actionMode = 0;
+        return GT_OK;
+    }
+
+    cbs = pirlRes.cbsLimit;
+    switch (pirlRes.ctsIntv)
+    {
+        case 0:
+            cts = 16;
+            break;
+        case 1:
+            cts = 8;
+            break;
+        case 2:
+            cts = 4;
+            break;
+        case 3:
+            cts = 1;
+            break;
+        default:
+            return GT_FAIL;
+    }
+
+    pirlData->ingressRate = TSM_GET_RATE(cbs,cts);
+
+    pirlData->mgmtNrlEn = pirlRes.mgmtNrlEn;
+    pirlData->priMask = pirlRes.priMask;
+
+    pirlData->customSetup.isValid = GT_TRUE;
+    pirlData->customSetup.cbsLimit = pirlRes.cbsLimit;
+    pirlData->customSetup.ctsIntv = pirlRes.ctsIntv;
+    pirlData->customSetup.ebsLimit = pirlRes.ebsLimit;
+    pirlData->customSetup.actionMode = pirlRes.actionMode;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -724,26 +724,26 @@ GT_STATUS gpirl2ReadTSMResource
 *******************************************************************************/
 GT_STATUS gpirl2Initialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 )
 {
-	GT_STATUS       	retVal;
+    GT_STATUS           retVal;
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = pirl2Initialize(dev);
+    retVal = pirl2Initialize(dev);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	    return retVal;
+        return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -769,17 +769,35 @@ GT_STATUS gpirl2Initialize
 *******************************************************************************/
 static GT_STATUS pirl2OperationPerform
 (
-    IN    GT_QD_DEV 			*dev,
-    IN    GT_PIRL2_OPERATION	pirlOp,
-    INOUT GT_PIRL2_OP_DATA		*opData
+    IN    GT_QD_DEV             *dev,
+    IN    GT_PIRL2_OPERATION    pirlOp,
+    INOUT GT_PIRL2_OP_DATA        *opData
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
 
     gtSemTake(dev,dev->pirlRegsSem,OS_WAIT_FOREVER);
 
     /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -790,92 +808,129 @@ static GT_STATUS pirl2OperationPerform
             return retVal;
         }
     }
+#endif
 
     /* Set the PIRL Operation register */
-	switch (pirlOp)
-	{
-		case PIRL_INIT_ALL_RESOURCE:
-			data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-		case PIRL_INIT_RESOURCE:
-			data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) | 
-					(opData->irlPort << 8) |
-					(opData->irlRes << 5));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PIRL_WRITE_RESOURCE:
-			data = (GT_U16)opData->irlData;
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) | 
-					(opData->irlPort << 8)	|
-					(opData->irlRes << 5)	|
-					(opData->irlReg & 0xF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PIRL_READ_RESOURCE:
-			data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) | 
-					(opData->irlPort << 8)	|
-					(opData->irlRes << 5)	|
-					(opData->irlReg & 0xF));
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->pirlRegsSem);
-		            return retVal;
-        		}
-		    }
-
-			retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
-			opData->irlData = (GT_U32)data;
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->pirlRegsSem);
-            	return retVal;
-	        }
-		    gtSemGive(dev,dev->pirlRegsSem);
-		    return retVal;
-
-		default:
-			
-			gtSemGive(dev,dev->pirlRegsSem);
-			return GT_FAIL;
-	}
+    switch (pirlOp)
+    {
+        case PIRL_INIT_ALL_RESOURCE:
+            data = (1 << 15) | (PIRL_INIT_ALL_RESOURCE << 12);
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+        case PIRL_INIT_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_INIT_RESOURCE << 12) | 
+                    (opData->irlPort << 8) |
+                    (opData->irlRes << 5));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_WRITE_RESOURCE:
+            data = (GT_U16)opData->irlData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PIRL_WRITE_RESOURCE << 12) | 
+                    (opData->irlPort << 8)    |
+                    (opData->irlRes << 5)    |
+                    (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            break;
+
+        case PIRL_READ_RESOURCE:
+            data = (GT_U16)((1 << 15) | (PIRL_READ_RESOURCE << 12) | 
+                    (opData->irlPort << 8)    |
+                    (opData->irlRes << 5)    |
+                    (opData->irlReg & 0xF));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_INGRESS_RATE_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 1;
+  
+              regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+              regAccess.rw_reg_list[0].data = 15;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+              }
+            }
+#else
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_INGRESS_RATE_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->pirlRegsSem);
+                    return retVal;
+                }
+            }
+#endif
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_INGRESS_RATE_DATA,&data);
+            opData->irlData = (GT_U32)data;
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->pirlRegsSem);
+                return retVal;
+            }
+            gtSemGive(dev,dev->pirlRegsSem);
+            return retVal;
+
+        default:
+            
+            gtSemGive(dev,dev->pirlRegsSem);
+            return GT_FAIL;
+    }
 
     /* Wait until the pirl in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INGRESS_RATE_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->pirlRegsSem);
+        return retVal;
+      }
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -886,6 +941,7 @@ static GT_STATUS pirl2OperationPerform
             return retVal;
         }
     }
+#endif
 
     gtSemGive(dev,dev->pirlRegsSem);
     return retVal;
@@ -896,28 +952,30 @@ static GT_STATUS pirl2OperationPerform
 */
 static GT_STATUS pirl2Initialize
 (
-    IN  GT_QD_DEV  			*dev
+    IN  GT_QD_DEV              *dev
 )
 {
-	GT_STATUS       retVal;	/* Functions return value */
-	GT_PIRL2_OPERATION	op;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL2_OPERATION    op;
 
-	op = PIRL_INIT_ALL_RESOURCE;
+    op = PIRL_INIT_ALL_RESOURCE;
 
-	retVal = pirl2OperationPerform(dev, op, NULL);
-	if (retVal != GT_OK)
-	{
-		DBG_INFO(("PIRL OP Failed.\n"));
-		return retVal;
-	}
 
-	retVal = gpirl2SetCurTimeUpInt(dev,4);
-	if (retVal != GT_OK)
-	{
-		DBG_INFO(("PIRL OP Failed.\n"));
-	}
+    retVal = pirl2OperationPerform(dev, op, NULL);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+        return retVal;
+    }
+
+
+    retVal = gpirl2SetCurTimeUpInt(dev,4);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*
@@ -926,27 +984,27 @@ static GT_STATUS pirl2Initialize
 */
 static GT_STATUS pirl2InitIRLResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
 )
 {
-	GT_STATUS       retVal;	/* Functions return value */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA 	opData;
-
-	op = PIRL_INIT_RESOURCE;
-	opData.irlPort = irlPort;
-	opData.irlRes = irlRes;
-
-	retVal = pirl2OperationPerform(dev, op, &opData);
-	if (retVal != GT_OK)
-	{
-		DBG_INFO(("PIRL OP Failed.\n"));
-		return retVal;
-	}
-
-	return retVal;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+
+    op = PIRL_INIT_RESOURCE;
+    opData.irlPort = irlPort;
+    opData.irlRes = irlRes;
+
+    retVal = pirl2OperationPerform(dev, op, &opData);
+    if (retVal != GT_OK)
+    {
+        DBG_INFO(("PIRL OP Failed.\n"));
+        return retVal;
+    }
+
+    return retVal;
 }
 
 /*
@@ -954,34 +1012,34 @@ static GT_STATUS pirl2InitIRLResource
 */
 static GT_STATUS pirl2DisableIRLResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes
 )
 {
-    GT_STATUS       retVal;			/* Functions return value */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA	opData;
-	int				i;
-
-	op = PIRL_WRITE_RESOURCE;
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = 0;
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-	}
-
-	return GT_OK;	
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;    
 }
 
 /*
@@ -990,211 +1048,211 @@ static GT_STATUS pirl2DisableIRLResource
 */
 static GT_STATUS pirl2DataToResource
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL2_DATA		*pirlData,
-    OUT GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_DATA        *pirlData,
+    OUT GT_PIRL2_RESOURCE    *res
 )
 {
-	GT_U32 typeMask;
-	GT_U32 data;
-
-	gtMemSet((void*)res,0,sizeof(GT_PIRL2_RESOURCE));
-
-	data = (GT_U32)(pirlData->accountQConf|pirlData->accountFiltered|
-					pirlData->mgmtNrlEn|pirlData->saNrlEn|pirlData->daNrlEn|
-					pirlData->samplingMode);
-
-	if (data > 1)
-	{
-		DBG_INFO(("GT_BAD_PARAM (Boolean)\n"));
-		return GT_BAD_PARAM;
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
-	{
-		if (pirlData->samplingMode != GT_FALSE)
-		{
-			DBG_INFO(("GT_BAD_PARAM (sampling mode)\n"));
-			return GT_BAD_PARAM;
-		}
-	}
-
-	res->accountQConf = pirlData->accountQConf;
-	res->accountFiltered = pirlData->accountFiltered;
-	res->mgmtNrlEn = pirlData->mgmtNrlEn;
-	res->saNrlEn = pirlData->saNrlEn;
-	res->daNrlEn = pirlData->daNrlEn;
-	res->samplingMode = pirlData->samplingMode;
-
-	switch(pirlData->actionMode)
-	{
-		case PIRL_ACTION_ACCEPT:
-		case PIRL_ACTION_USE_LIMIT_ACTION:
-			res->actionMode = pirlData->actionMode;
-			break;
-		default:
-			DBG_INFO(("GT_BAD_PARAM actionMode\n"));
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->ebsLimitAction)
-	{
-		case ESB_LIMIT_ACTION_DROP:
-		case ESB_LIMIT_ACTION_FC:
-			res->ebsLimitAction = pirlData->ebsLimitAction;
-			break;
-		default:
-			DBG_INFO(("GT_BAD_PARAM ebsLimitAction\n"));
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->fcDeassertMode)
-	{
-		case GT_PIRL_FC_DEASSERT_EMPTY:
-		case GT_PIRL_FC_DEASSERT_CBS_LIMIT:
-			res->fcDeassertMode = pirlData->fcDeassertMode;
-			break;
-		default:
-			if(res->ebsLimitAction != ESB_LIMIT_ACTION_FC)
-			{
-				res->fcDeassertMode	= GT_PIRL_FC_DEASSERT_EMPTY;
-				break;
-			}
-			DBG_INFO(("GT_BAD_PARAM fcDeassertMode\n"));
-			return GT_BAD_PARAM;
-	}
-
-	if(pirlData->customSetup.isValid == GT_TRUE)
-	{
-		res->ebsLimit = pirlData->customSetup.ebsLimit;
-		res->cbsLimit = pirlData->customSetup.cbsLimit;
-		res->bktIncrement = pirlData->customSetup.bktIncrement;
-		res->bktRateFactor = pirlData->customSetup.bktRateFactor;
-	}
-	else
-	{
-		if(pirlData->ingressRate == 0)
-		{
-			DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-			return GT_BAD_PARAM;
-		}
-
-		if(pirlData->ingressRate < 1000)	/* less than 1Mbps */
-		{
-			/* it should be divided by 64 */
-			if(pirlData->ingressRate % 64)
-			{
-				DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-				return GT_BAD_PARAM;
-			}
-			res->bktRateFactor = pirlData->ingressRate/64;
-		}
-		else if(pirlData->ingressRate < 10000)	/* less than or equal to 10Mbps */
-		{
-			/* it should be divided by 1000 */
-			if(pirlData->ingressRate % 1000)
-			{
-				DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-				return GT_BAD_PARAM;
-			}
-			res->bktRateFactor = pirlData->ingressRate/128 + ((pirlData->ingressRate % 128)?1:0);
-		}
-		else if(pirlData->ingressRate < 100000)	/* less than or equal to 100Mbps */
-		{
-			/* it should be divided by 1000 */
-			if(pirlData->ingressRate % 1000)
-			{
-				DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-				return GT_BAD_PARAM;
-			}
-			res->bktRateFactor = pirlData->ingressRate/1000;
-		}
-		else if(pirlData->ingressRate <= 200000)	/* less than or equal to 200Mbps */
-		{
-			/* it should be divided by 10000 */
-			if(pirlData->ingressRate % 10000)
-			{
-				DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-				return GT_BAD_PARAM;
-			}
-			res->bktRateFactor = pirlData->ingressRate/1000;
-		}
-		else
-		{
-			DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
-			return GT_BAD_PARAM;
-		}
-
-		res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
-		res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
-		res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
-	}
-
-	switch(pirlData->bktRateType)
-	{
-		case BUCKET_TYPE_TRAFFIC_BASED:
-			res->bktRateType = pirlData->bktRateType;
-
-			typeMask = 0x7FFF;
-
-			if (pirlData->bktTypeMask > typeMask)
-			{
-				DBG_INFO(("GT_BAD_PARAM bktTypeMask(%#x)\n",pirlData->bktTypeMask));
-				return GT_BAD_PARAM;
-			}
-
-		   	res->bktTypeMask = pirlData->bktTypeMask;
-
-			if (pirlData->bktTypeMask & BUCKET_TRAFFIC_ARP)
-			{
-				res->bktTypeMask &= ~BUCKET_TRAFFIC_ARP;
-				res->bktTypeMask |= 0x80;
-			}
-			
-			if (pirlData->priORpt > 1)
-			{
-				DBG_INFO(("GT_BAD_PARAM rpiORpt\n"));
-				return GT_BAD_PARAM;
-			}
-
-			res->priORpt = pirlData->priORpt;
-
-			if (pirlData->priMask >= (1 << 4))
-			{
-				DBG_INFO(("GT_BAD_PARAM priMask(%#x)\n",pirlData->priMask));
-				return GT_BAD_PARAM;
-			}
-
-			res->priMask = pirlData->priMask;
-
-			break;
-
-		case BUCKET_TYPE_RATE_BASED:
-			res->bktRateType = pirlData->bktRateType;
-		   	res->bktTypeMask = pirlData->bktTypeMask;
-			res->priORpt = pirlData->priORpt;
-			res->priMask = pirlData->priMask;
-			break;
-
-		default:
-			DBG_INFO(("GT_BAD_PARAM bktRateType(%#x)\n",pirlData->bktRateType));
-			return GT_BAD_PARAM;
-	}
-
-	switch(pirlData->byteTobeCounted)
-	{
-		case GT_PIRL2_COUNT_FRAME:
-		case GT_PIRL2_COUNT_ALL_LAYER1:
-		case GT_PIRL2_COUNT_ALL_LAYER2:
-		case GT_PIRL2_COUNT_ALL_LAYER3:
-			res->byteTobeCounted = pirlData->byteTobeCounted;
-			break;
-		default:
-			DBG_INFO(("GT_BAD_PARAM byteTobeCounted(%#x)\n",pirlData->byteTobeCounted));
-			return GT_BAD_PARAM;
-	}
-
-	return GT_OK;			
+    GT_U32 typeMask;
+    GT_U32 data;
+
+    gtMemSet((void*)res,0,sizeof(GT_PIRL2_RESOURCE));
+
+    data = (GT_U32)(pirlData->accountQConf|pirlData->accountFiltered|
+                    pirlData->mgmtNrlEn|pirlData->saNrlEn|pirlData->daNrlEn|
+                    pirlData->samplingMode);
+
+    if (data > 1)
+    {
+        DBG_INFO(("GT_BAD_PARAM (Boolean)\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RESTRICTED_PIRL2_RESOURCE))
+    {
+        if (pirlData->samplingMode != GT_FALSE)
+        {
+            DBG_INFO(("GT_BAD_PARAM (sampling mode)\n"));
+            return GT_BAD_PARAM;
+        }
+    }
+
+    res->accountQConf = pirlData->accountQConf;
+    res->accountFiltered = pirlData->accountFiltered;
+    res->mgmtNrlEn = pirlData->mgmtNrlEn;
+    res->saNrlEn = pirlData->saNrlEn;
+    res->daNrlEn = pirlData->daNrlEn;
+    res->samplingMode = pirlData->samplingMode;
+
+    switch(pirlData->actionMode)
+    {
+        case PIRL_ACTION_ACCEPT:
+        case PIRL_ACTION_USE_LIMIT_ACTION:
+            res->actionMode = pirlData->actionMode;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM actionMode\n"));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->ebsLimitAction)
+    {
+        case ESB_LIMIT_ACTION_DROP:
+        case ESB_LIMIT_ACTION_FC:
+            res->ebsLimitAction = pirlData->ebsLimitAction;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM ebsLimitAction\n"));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->fcDeassertMode)
+    {
+        case GT_PIRL_FC_DEASSERT_EMPTY:
+        case GT_PIRL_FC_DEASSERT_CBS_LIMIT:
+            res->fcDeassertMode = pirlData->fcDeassertMode;
+            break;
+        default:
+            if(res->ebsLimitAction != ESB_LIMIT_ACTION_FC)
+            {
+                res->fcDeassertMode    = GT_PIRL_FC_DEASSERT_EMPTY;
+                break;
+            }
+            DBG_INFO(("GT_BAD_PARAM fcDeassertMode\n"));
+            return GT_BAD_PARAM;
+    }
+
+    if(pirlData->customSetup.isValid == GT_TRUE)
+    {
+        res->ebsLimit = pirlData->customSetup.ebsLimit;
+        res->cbsLimit = pirlData->customSetup.cbsLimit;
+        res->bktIncrement = pirlData->customSetup.bktIncrement;
+        res->bktRateFactor = pirlData->customSetup.bktRateFactor;
+    }
+    else
+    {
+        if(pirlData->ingressRate == 0)
+        {
+            DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+            return GT_BAD_PARAM;
+        }
+
+        if(pirlData->ingressRate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(pirlData->ingressRate % 64)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/64;
+        }
+        else if(pirlData->ingressRate < 10000)    /* less than or equal to 10Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/128 + ((pirlData->ingressRate % 128)?1:0);
+        }
+        else if(pirlData->ingressRate < 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(pirlData->ingressRate % 1000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/1000;
+        }
+        else if(pirlData->ingressRate <= 200000)    /* less than or equal to 200Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(pirlData->ingressRate % 10000)
+            {
+                DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+                return GT_BAD_PARAM;
+            }
+            res->bktRateFactor = pirlData->ingressRate/1000;
+        }
+        else
+        {
+            DBG_INFO(("GT_BAD_PARAM ingressRate(%i)\n",pirlData->ingressRate));
+            return GT_BAD_PARAM;
+        }
+
+        res->ebsLimit = RECOMMENDED_ESB_LIMIT(dev, pirlData->ingressRate);
+        res->cbsLimit = RECOMMENDED_CBS_LIMIT(dev, pirlData->ingressRate);
+        res->bktIncrement = RECOMMENDED_BUCKET_INCREMENT(dev, pirlData->ingressRate);
+    }
+
+    switch(pirlData->bktRateType)
+    {
+        case BUCKET_TYPE_TRAFFIC_BASED:
+            res->bktRateType = pirlData->bktRateType;
+
+            typeMask = 0x7FFF;
+
+            if (pirlData->bktTypeMask > typeMask)
+            {
+                DBG_INFO(("GT_BAD_PARAM bktTypeMask(%#x)\n",pirlData->bktTypeMask));
+                return GT_BAD_PARAM;
+            }
+
+               res->bktTypeMask = pirlData->bktTypeMask;
+
+            if (pirlData->bktTypeMask & BUCKET_TRAFFIC_ARP)
+            {
+                res->bktTypeMask &= ~BUCKET_TRAFFIC_ARP;
+                res->bktTypeMask |= 0x80;
+            }
+            
+            if (pirlData->priORpt > 1)
+            {
+                DBG_INFO(("GT_BAD_PARAM rpiORpt\n"));
+                return GT_BAD_PARAM;
+            }
+
+            res->priORpt = pirlData->priORpt;
+
+            if (pirlData->priMask >= (1 << 4))
+            {
+                DBG_INFO(("GT_BAD_PARAM priMask(%#x)\n",pirlData->priMask));
+                return GT_BAD_PARAM;
+            }
+
+            res->priMask = pirlData->priMask;
+
+            break;
+
+        case BUCKET_TYPE_RATE_BASED:
+            res->bktRateType = pirlData->bktRateType;
+               res->bktTypeMask = pirlData->bktTypeMask;
+            res->priORpt = pirlData->priORpt;
+            res->priMask = pirlData->priMask;
+            break;
+
+        default:
+            DBG_INFO(("GT_BAD_PARAM bktRateType(%#x)\n",pirlData->bktRateType));
+            return GT_BAD_PARAM;
+    }
+
+    switch(pirlData->byteTobeCounted)
+    {
+        case GT_PIRL2_COUNT_FRAME:
+        case GT_PIRL2_COUNT_ALL_LAYER1:
+        case GT_PIRL2_COUNT_ALL_LAYER2:
+        case GT_PIRL2_COUNT_ALL_LAYER3:
+            res->byteTobeCounted = pirlData->byteTobeCounted;
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM byteTobeCounted(%#x)\n",pirlData->byteTobeCounted));
+            return GT_BAD_PARAM;
+    }
+
+    return GT_OK;            
 }
 
 /*
@@ -1202,62 +1260,62 @@ static GT_STATUS pirl2DataToResource
 */
 static GT_STATUS pirl2ResourceToData
 (
-    IN  GT_QD_DEV  			*dev,
-    IN  GT_PIRL2_RESOURCE	*res,
-    OUT GT_PIRL2_DATA		*pirlData
+    IN  GT_QD_DEV              *dev,
+    IN  GT_PIRL2_RESOURCE    *res,
+    OUT GT_PIRL2_DATA        *pirlData
 )
 {
-	GT_U32	rate;
-	GT_U32	factor;
-
-	pirlData->accountQConf = res->accountQConf;
-	pirlData->accountFiltered = res->accountFiltered;
-	pirlData->mgmtNrlEn = res->mgmtNrlEn;
-	pirlData->saNrlEn = res->saNrlEn;
-	pirlData->daNrlEn = res->daNrlEn;
-	pirlData->samplingMode = res->samplingMode;
-	pirlData->ebsLimitAction = res->ebsLimitAction;
-	pirlData->actionMode = res->actionMode;
-	pirlData->fcDeassertMode = res->fcDeassertMode;
-
-	pirlData->customSetup.isValid = GT_FALSE;
-
-	FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
-
-	rate = res->bktRateFactor * factor;
-	if(factor == 128)
-	{
-		pirlData->ingressRate = rate - (rate % 1000);
-	}
-	else if (factor == 0)
-	{
-		pirlData->ingressRate = 0;
-		pirlData->customSetup.isValid = GT_TRUE;
-		pirlData->customSetup.ebsLimit = res->ebsLimit;
-		pirlData->customSetup.cbsLimit = res->cbsLimit;
-		pirlData->customSetup.bktIncrement = res->bktIncrement;
-		pirlData->customSetup.bktRateFactor = res->bktRateFactor;
-	}
-	else
-	{
-		pirlData->ingressRate = rate;
-	}
-
-	pirlData->bktRateType = res->bktRateType;
-	pirlData->bktTypeMask = res->bktTypeMask;
-
-	if (pirlData->bktTypeMask & 0x80)
-	{
-		res->bktTypeMask &= ~0x80;
-		res->bktTypeMask |= BUCKET_TRAFFIC_ARP;
-	}
-			
-	pirlData->priORpt = res->priORpt;
-	pirlData->priMask = res->priMask;
-
-	pirlData->byteTobeCounted = res->byteTobeCounted;
-
-	return GT_OK;			
+    GT_U32    rate;
+    GT_U32    factor;
+
+    pirlData->accountQConf = res->accountQConf;
+    pirlData->accountFiltered = res->accountFiltered;
+    pirlData->mgmtNrlEn = res->mgmtNrlEn;
+    pirlData->saNrlEn = res->saNrlEn;
+    pirlData->daNrlEn = res->daNrlEn;
+    pirlData->samplingMode = res->samplingMode;
+    pirlData->ebsLimitAction = res->ebsLimitAction;
+    pirlData->actionMode = res->actionMode;
+    pirlData->fcDeassertMode = res->fcDeassertMode;
+
+    pirlData->customSetup.isValid = GT_FALSE;
+
+    FACTOR_FROM_BUCKET_INCREMENT(dev,res->bktIncrement,factor);
+
+    rate = res->bktRateFactor * factor;
+    if(factor == 128)
+    {
+        pirlData->ingressRate = rate - (rate % 1000);
+    }
+    else if (factor == 0)
+    {
+        pirlData->ingressRate = 0;
+        pirlData->customSetup.isValid = GT_TRUE;
+        pirlData->customSetup.ebsLimit = res->ebsLimit;
+        pirlData->customSetup.cbsLimit = res->cbsLimit;
+        pirlData->customSetup.bktIncrement = res->bktIncrement;
+        pirlData->customSetup.bktRateFactor = res->bktRateFactor;
+    }
+    else
+    {
+        pirlData->ingressRate = rate;
+    }
+
+    pirlData->bktRateType = res->bktRateType;
+    pirlData->bktTypeMask = res->bktTypeMask;
+
+    if (pirlData->bktTypeMask & 0x80)
+    {
+        res->bktTypeMask &= ~0x80;
+        res->bktTypeMask |= BUCKET_TRAFFIC_ARP;
+    }
+            
+    pirlData->priORpt = res->priORpt;
+    pirlData->priMask = res->priMask;
+
+    pirlData->byteTobeCounted = res->byteTobeCounted;
+
+    return GT_OK;            
 }
 
 /*******************************************************************************
@@ -1268,8 +1326,8 @@ static GT_STATUS pirl2ResourceToData
 *
 * INPUTS:
 *       irlPort - physical port number.
-*		irlRes  - bucket to be used (0 ~ 4).
-*       res 	- IRL Resource data
+*        irlRes  - bucket to be used (0 ~ 4).
+*       res     - IRL Resource data
 *
 * OUTPUTS:
 *       Nont.
@@ -1283,72 +1341,72 @@ static GT_STATUS pirl2ResourceToData
 *******************************************************************************/
 static GT_STATUS pirl2WriteResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	IN  GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_RESOURCE    *res
 )
 {
-	GT_STATUS       retVal;			/* Functions return value */
-	GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA 	opData;
-	int				i;
-
-	op = PIRL_WRITE_RESOURCE;
-
-	/* reg0 data */
-	data[0] = (GT_U16)((res->bktRateType << 15) |	/* Bit[15] : Bucket Rate Type */
-			  		(res->bktTypeMask << 0 )); 		/* Bit[14:0] : Traffic Type   */
-
-	/* reg1 data */
-	data[1] = (GT_U16)res->bktIncrement;	/* Bit[11:0] : Bucket Increment */
-
-	/* reg2 data */
-	data[2] = (GT_U16)res->bktRateFactor;	/* Bit[15:0] : Bucket Rate Factor */
-
-	/* reg3 data */
-	data[3] = (GT_U16)((res->cbsLimit & 0xFFF) << 4)|	/* Bit[15:4] : CBS Limit[11:0] */
-					(res->byteTobeCounted << 2);		/* Bit[3:0] : Bytes to be counted */
-
-	/* reg4 data */
-	data[4] = (GT_U16)(res->cbsLimit >> 12);		/* Bit[11:0] : CBS Limit[23:12] */
-
-	/* reg5 data */
-	data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);		/* Bit[15:0] : EBS Limit[15:0] */
-
-	/* reg6 data */
-	data[6] = (GT_U16)((res->ebsLimit >> 16)	|	/* Bit[7:0] : EBS Limit[23:16] */
-					(res->samplingMode << 11)	|	/* Bit[11] : Sampling Mode */
-					(res->ebsLimitAction << 12)	|	/* Bit[12] : EBS Limit Action */
-					(res->actionMode << 13)		|	/* Bit[13] : Action Mode */
-					(res->fcDeassertMode << 14));	/* Bit[14] : Flow control mode */
-
-	/* reg7 data */
-	data[7] = (GT_U16)((res->daNrlEn)			|	/* Bit[0]  : DA Nrl En */
-					(res->saNrlEn << 1)			|	/* Bit[1]  : SA Nrl En */
-					(res->mgmtNrlEn << 2) 		|	/* Bit[2]  : MGMT Nrl En */
-					(res->priMask << 8) 		|	/* Bit[11:8] : Priority Queue Mask */
-					(res->priORpt << 12) 		|	/* Bit[12] : Priority OR PacketType */
-					(res->accountFiltered << 14)|	/* Bit[14] : Account Filtered */
-					(res->accountQConf << 15));		/* Bit[15] : Account QConf */
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = data[i];
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-	}
-
-	return GT_OK;	
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = (GT_U16)((res->bktRateType << 15) |    /* Bit[15] : Bucket Rate Type */
+                      (res->bktTypeMask << 0 ));         /* Bit[14:0] : Traffic Type   */
+
+    /* reg1 data */
+    data[1] = (GT_U16)res->bktIncrement;    /* Bit[11:0] : Bucket Increment */
+
+    /* reg2 data */
+    data[2] = (GT_U16)res->bktRateFactor;    /* Bit[15:0] : Bucket Rate Factor */
+
+    /* reg3 data */
+    data[3] = (GT_U16)((res->cbsLimit & 0xFFF) << 4)|    /* Bit[15:4] : CBS Limit[11:0] */
+                    (res->byteTobeCounted << 2);        /* Bit[3:0] : Bytes to be counted */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)((res->ebsLimit >> 16)    |    /* Bit[7:0] : EBS Limit[23:16] */
+                    (res->samplingMode << 11)    |    /* Bit[11] : Sampling Mode */
+                    (res->ebsLimitAction << 12)    |    /* Bit[12] : EBS Limit Action */
+                    (res->actionMode << 13)        |    /* Bit[13] : Action Mode */
+                    (res->fcDeassertMode << 14));    /* Bit[14] : Flow control mode */
+
+    /* reg7 data */
+    data[7] = (GT_U16)((res->daNrlEn)            |    /* Bit[0]  : DA Nrl En */
+                    (res->saNrlEn << 1)            |    /* Bit[1]  : SA Nrl En */
+                    (res->mgmtNrlEn << 2)         |    /* Bit[2]  : MGMT Nrl En */
+                    (res->priMask << 8)         |    /* Bit[11:8] : Priority Queue Mask */
+                    (res->priORpt << 12)         |    /* Bit[12] : Priority OR PacketType */
+                    (res->accountFiltered << 14)|    /* Bit[14] : Account Filtered */
+                    (res->accountQConf << 15));        /* Bit[15] : Account QConf */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;    
 }
 
 
@@ -1360,7 +1418,7 @@ static GT_STATUS pirl2WriteResource
 *
 * INPUTS:
 *       irlPort  - physical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
+*        irlRes   - bucket to be used (0 ~ 4).
 *
 * OUTPUTS:
 *       res - IRL Resource data
@@ -1374,71 +1432,71 @@ static GT_STATUS pirl2WriteResource
 *******************************************************************************/
 static GT_STATUS pirl2ReadResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	OUT GT_PIRL2_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_RESOURCE    *res
 )
 {
-	GT_STATUS       retVal;		/* Functions return value */
-	GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA	opData;
-	int				i;
-
-	op = PIRL_READ_RESOURCE;
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = 0;
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-
-		data[i] = (GT_U16)opData.irlData;
-	}
-	
-
-	/* reg0 data */
-	res->bktRateType = (data[0] >> 15) & 0x1;
-	res->bktTypeMask = (data[0] >> 0) & 0x7FFF;
-
-	/* reg1 data */
-	res->bktIncrement = data[1] & 0xFFF;
-
-	/* reg2 data */
-	res->bktRateFactor = data[2] & 0xFFFF;
-
-	/* reg3,4 data */
-	res->byteTobeCounted = (data[3] >> 2) & 0x3;
-	res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
-
-	/* reg5,6 data */
-	res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
-													   
-	/* reg6 data */
-	res->samplingMode = (data[6] >> 11) & 0x1;
-	res->ebsLimitAction = (data[6] >> 12) & 0x1;
-	res->actionMode = (data[6] >> 13) & 0x1;
-	res->fcDeassertMode = (data[6] >> 14) & 0x1;
-
-	/* reg7 data */
-	res->daNrlEn = (data[7] >> 0) & 0x1;
-	res->saNrlEn = (data[7] >> 1) & 0x1;
-	res->mgmtNrlEn = (data[7] >> 2) & 0x1;
-	res->priMask = (data[7] >> 8) & 0xF;
-	res->priORpt = (data[7] >> 12) & 0x1;
-	res->accountFiltered = (data[7] >> 14) & 0x1;
-	res->accountQConf = (data[7] >> 15) & 0x1;
-
-	return GT_OK;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+    
+
+    /* reg0 data */
+    res->bktRateType = (data[0] >> 15) & 0x1;
+    res->bktTypeMask = (data[0] >> 0) & 0x7FFF;
+
+    /* reg1 data */
+    res->bktIncrement = data[1] & 0xFFF;
+
+    /* reg2 data */
+    res->bktRateFactor = data[2] & 0xFFFF;
+
+    /* reg3,4 data */
+    res->byteTobeCounted = (data[3] >> 2) & 0x3;
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xFFF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5] | ((data[6] & 0xFF) << 16);
+                                                       
+    /* reg6 data */
+    res->samplingMode = (data[6] >> 11) & 0x1;
+    res->ebsLimitAction = (data[6] >> 12) & 0x1;
+    res->actionMode = (data[6] >> 13) & 0x1;
+    res->fcDeassertMode = (data[6] >> 14) & 0x1;
+
+    /* reg7 data */
+    res->daNrlEn = (data[7] >> 0) & 0x1;
+    res->saNrlEn = (data[7] >> 1) & 0x1;
+    res->mgmtNrlEn = (data[7] >> 2) & 0x1;
+    res->priMask = (data[7] >> 8) & 0xF;
+    res->priORpt = (data[7] >> 12) & 0x1;
+    res->accountFiltered = (data[7] >> 14) & 0x1;
+    res->accountQConf = (data[7] >> 15) & 0x1;
+
+    return GT_OK;
 }
 
 
@@ -1446,84 +1504,84 @@ static GT_STATUS pirl2ReadResource
 * pirl2WriteTSMResource
 *
 * DESCRIPTION:
-* 		This function writes IRL Resource to BCM (Bucket Configuration Memory)
-*		in Time Slot Metering Mode.
+*         This function writes IRL Resource to BCM (Bucket Configuration Memory)
+*        in Time Slot Metering Mode.
 *
 * INPUTS:
-*		irlPort - physical port number.
-*		irlRes  - bucket to be used (0 ~ 1).
-*		res 	- IRL Resource data
+*        irlPort - physical port number.
+*        irlRes  - bucket to be used (0 ~ 1).
+*        res     - IRL Resource data
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK on success,
-*		GT_FAIL otherwise.
+*        GT_OK on success,
+*        GT_FAIL otherwise.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 static GT_STATUS pirl2WriteTSMResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	IN  GT_PIRL2_TSM_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN  GT_PIRL2_TSM_RESOURCE    *res
 )
 {
-	GT_STATUS       retVal;			/* Functions return value */
-	GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA 	opData;
-	int				i;
-
-	op = PIRL_WRITE_RESOURCE;
-
-	/* reg0 data */
-	data[0] = 0;
-
-	/* reg1 data */
-	data[1] = 0;
-
-	/* reg2 data */
-	data[2] = 0;
-
-	/* reg3 data */
-	data[3] = (GT_U16)(((res->cbsLimit & 0xFFF) << 4)|	/* Bit[15:4] : CBS Limit[11:0] */
-					(0x2 << 2));						/* Bit[3:0] : Bytes to be counted */
-
-	/* reg4 data */
-	data[4] = (GT_U16)(res->cbsLimit >> 12);		/* Bit[11:0] : CBS Limit[23:12] */
-
-	/* reg5 data */
-	data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);		/* Bit[15:0] : EBS Limit[15:0] */
-
-	/* reg6 data */
-	data[6] = (GT_U16)(res->actionMode << 13);		/* Bit[13] : Action Mode */
-
-	/* reg7 data */
-	data[7] = (GT_U16)((res->tsmMode << 7)		|	/* Bit[7]  : TSM Mode */
-					(res->mgmtNrlEn << 2) 		|	/* Bit[2]  : MGMT Nrl En */
-					(res->priMask << 8) 		|	/* Bit[11:8] : Priority Queue Mask */
-					(res->ctsIntv << 4));			/* Bit[5:4] : Class Timer Slot Interval */
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = data[i];
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-	}
-
-	return GT_OK;	
+    GT_STATUS       retVal;            /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA     opData;
+    int                i;
+
+    op = PIRL_WRITE_RESOURCE;
+
+    /* reg0 data */
+    data[0] = 0;
+
+    /* reg1 data */
+    data[1] = 0;
+
+    /* reg2 data */
+    data[2] = 0;
+
+    /* reg3 data */
+    data[3] = (GT_U16)(((res->cbsLimit & 0xFFF) << 4)|    /* Bit[15:4] : CBS Limit[11:0] */
+                    (0x2 << 2));                            /* Bit[3:0] : Bytes to be counted */
+
+    /* reg4 data */
+    data[4] = (GT_U16)(res->cbsLimit >> 12);        /* Bit[11:0] : CBS Limit[23:12] */
+
+    /* reg5 data */
+    data[5] = (GT_U16)(res->ebsLimit & 0xFFFF);        /* Bit[15:0] : EBS Limit[15:0] */
+
+    /* reg6 data */
+    data[6] = (GT_U16)(res->actionMode << 13);        /* Bit[13] : Action Mode */
+
+    /* reg7 data */
+    data[7] = (GT_U16)((res->tsmMode << 7)        |    /* Bit[7]  : TSM Mode */
+                    (res->mgmtNrlEn << 2)         |    /* Bit[2]  : MGMT Nrl En */
+                    (res->priMask << 8)         |    /* Bit[11:8] : Priority Queue Mask */
+                    (res->ctsIntv << 4));            /* Bit[5:4] : Class Timer Slot Interval */
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = data[i];
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+    }
+
+    return GT_OK;    
 }
 
 
@@ -1531,86 +1589,86 @@ static GT_STATUS pirl2WriteTSMResource
 * pirl2ReadTSMResource
 *
 * DESCRIPTION:
-*		This function reads IRL Resource from BCM (Bucket Configuration Memory)
-*		in Time Slot Metering Mode.
+*        This function reads IRL Resource from BCM (Bucket Configuration Memory)
+*        in Time Slot Metering Mode.
 *
 * INPUTS:
-*		irlPort  - physical port number.
-*		irlRes   - bucket to be used (0 ~ 1).
+*        irlPort  - physical port number.
+*        irlRes   - bucket to be used (0 ~ 1).
 *
 * OUTPUTS:
-*		res - IRL Resource data
+*        res - IRL Resource data
 *
 * RETURNS:
-* 		GT_OK on success,
-* 		GT_FAIL otherwise.
+*         GT_OK on success,
+*         GT_FAIL otherwise.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 static GT_STATUS pirl2ReadTSMResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	OUT GT_PIRL2_TSM_RESOURCE	*res
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    OUT GT_PIRL2_TSM_RESOURCE    *res
 )
 {
-	GT_STATUS       retVal;		/* Functions return value */
-	GT_U16          data[8]; 	/* temporary Data storage */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA	opData;
-	int				i;
-
-	op = PIRL_READ_RESOURCE;
-
-	for(i=0; i<8; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = 0;
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-
-		data[i] = (GT_U16)opData.irlData;
-	}
-	
-	res->tsmMode = data[7] & (1<<7);
-
-	if(res->tsmMode == GT_FALSE)
-	{
-		/* TMS mode is not set */
-		res->cbsLimit = 0;
-		res->ebsLimit = 0;
-		res->actionMode = 0;
-		res->mgmtNrlEn = 0;
-		res->priMask = 0;
-		res->ctsIntv = 0;
-
-		return GT_OK;
-	}
-
-	/* reg3,4 data */
-	res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xF) << 12);
-
-	/* reg5,6 data */
-	res->ebsLimit = data[5];
-													   
-	/* reg6 data */
-	res->actionMode = (data[6] >> 13) & 0x1;
-
-	/* reg7 data */
-	res->mgmtNrlEn = (data[7] >> 2) & 0x1;
-	res->priMask = (data[7] >> 8) & 0xF;
-	res->ctsIntv = (data[7] >> 4) & 0x3;
-
-	return GT_OK;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_U16          data[8];     /* temporary Data storage */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    int                i;
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<8; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+    
+    res->tsmMode = data[7] & (1<<7);
+
+    if(res->tsmMode == GT_FALSE)
+    {
+        /* TMS mode is not set */
+        res->cbsLimit = 0;
+        res->ebsLimit = 0;
+        res->actionMode = 0;
+        res->mgmtNrlEn = 0;
+        res->priMask = 0;
+        res->ctsIntv = 0;
+
+        return GT_OK;
+    }
+
+    /* reg3,4 data */
+    res->cbsLimit = ((data[3] >> 4) & 0xFFF) | ((data[4] & 0xF) << 12);
+
+    /* reg5,6 data */
+    res->ebsLimit = data[5];
+                                                       
+    /* reg6 data */
+    res->actionMode = (data[6] >> 13) & 0x1;
+
+    /* reg7 data */
+    res->mgmtNrlEn = (data[7] >> 2) & 0x1;
+    res->priMask = (data[7] >> 8) & 0xF;
+    res->ctsIntv = (data[7] >> 4) & 0x3;
+
+    return GT_OK;
 }
 
 #define PIRL2_DEBUG
@@ -1623,8 +1681,8 @@ static GT_STATUS pirl2ReadTSMResource
 *
 * INPUTS:
 *       irlPort  - physical port number.
-*		irlRes   - bucket to be used (0 ~ 4).
-*		dataLen  - data size.
+*        irlRes   - bucket to be used (0 ~ 4).
+*        dataLen  - data size.
 *
 * OUTPUTS:
 *       data - IRL Resource data
@@ -1638,45 +1696,45 @@ static GT_STATUS pirl2ReadTSMResource
 *******************************************************************************/
 GT_STATUS pirl2DumpResource
 (
-	IN  GT_QD_DEV  			*dev,
-	IN	GT_U32				irlPort,
-	IN	GT_U32				irlRes,
-	IN	GT_U32				dataLen,
-	OUT GT_U16				*data
+    IN  GT_QD_DEV              *dev,
+    IN    GT_U32                irlPort,
+    IN    GT_U32                irlRes,
+    IN    GT_U32                dataLen,
+    OUT GT_U16                *data
 )
 {
-	GT_STATUS       retVal;		/* Functions return value */
-	GT_PIRL2_OPERATION	op;
-	GT_PIRL2_OP_DATA	opData;
-	GT_U32				i;
+    GT_STATUS       retVal;        /* Functions return value */
+    GT_PIRL2_OPERATION    op;
+    GT_PIRL2_OP_DATA    opData;
+    GT_U32                i;
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	op = PIRL_READ_RESOURCE;
-
-	for(i=0; i<dataLen; i++)
-	{
-		opData.irlPort = irlPort;
-		opData.irlRes = irlRes;
-		opData.irlReg = i;
-		opData.irlData = 0;
-
-		retVal = pirl2OperationPerform(dev, op, &opData);
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("PIRL OP Failed.\n"));
-        	return retVal;
-		}
-
-		data[i] = (GT_U16)opData.irlData;
-	}
-
-	return GT_OK;	
+    if (!IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    op = PIRL_READ_RESOURCE;
+
+    for(i=0; i<dataLen; i++)
+    {
+        opData.irlPort = irlPort;
+        opData.irlRes = irlRes;
+        opData.irlReg = i;
+        opData.irlData = 0;
+
+        retVal = pirl2OperationPerform(dev, op, &opData);
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("PIRL OP Failed.\n"));
+            return retVal;
+        }
+
+        data[i] = (GT_U16)opData.irlData;
+    }
+
+    return GT_OK;    
 }
 #endif /* PIRL2_DEBUG */
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c
old mode 100644
new mode 100755
index 0d14476..510a8a5
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTP.c
@@ -21,33 +21,46 @@
 
 #undef USE_SINGLE_READ
 
-#define AVB_SMI_ADDR		0xC
-
-#define QD_REG_PTP_INT_OFFSET		0
-#define QD_REG_PTP_INTEN_OFFSET		1
-#define QD_REG_PTP_FREQ_OFFSET		4
-#define QD_REG_PTP_PHASE_OFFSET		6
-#define QD_REG_PTP_CLK_CTRL_OFFSET	4
-#define QD_REG_PTP_CYCLE_INTERVAL_OFFSET		5
-#define QD_REG_PTP_CYCLE_ADJ_OFFSET				6
-#define QD_REG_PTP_PLL_CTRL_OFFSET	7
-#define QD_REG_PTP_CLK_SRC_OFFSET	0x9
-#define QD_REG_PTP_P9_MODE_OFFSET	0xA
-#define QD_REG_PTP_RESET_OFFSET		0xB
-
-#define GT_PTP_MERGE_32BIT(_high16,_low16)	(((_high16)<<16)|(_low16))
-#define GT_PTP_GET_HIGH16(_data)	((_data) >> 16) & 0xFFFF
-#define GT_PTP_GET_LOW16(_data)		(_data) & 0xFFFF
-
-#define AVB_FPGA_READ_REG	gsysReadMiiReg
-#define AVB_FPGA_WRITE_REG	gsysWriteMiiReg
+#define AVB_SMI_ADDR        0xC
+
+#define QD_REG_PTP_INT_OFFSET        0
+#define QD_REG_PTP_INTEN_OFFSET        1
+#define QD_REG_PTP_FREQ_OFFSET        4
+#define QD_REG_PTP_PHASE_OFFSET        6
+#define QD_REG_PTP_CLK_CTRL_OFFSET    4
+#define QD_REG_PTP_CYCLE_INTERVAL_OFFSET        5
+#define QD_REG_PTP_CYCLE_ADJ_OFFSET                6
+#define QD_REG_PTP_PLL_CTRL_OFFSET    7
+#define QD_REG_PTP_CLK_SRC_OFFSET    0x9
+#define QD_REG_PTP_P9_MODE_OFFSET    0xA
+#define QD_REG_PTP_RESET_OFFSET        0xB
+
+#define GT_PTP_MERGE_32BIT(_high16,_low16)    (((_high16)<<16)|(_low16))
+#define GT_PTP_GET_HIGH16(_data)    ((_data) >> 16) & 0xFFFF
+#define GT_PTP_GET_LOW16(_data)        (_data) & 0xFFFF
+
+#if 0
+
+#define AVB_FPGA_READ_REG       gprtGetPhyReg
+#define AVB_FPGA_WRITE_REG      gprtSetPhyReg
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, unsigned int* data);
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, unsigned int data);
+#else
+
+/* for RMGMT access  and can be controlled by <sw_apps -rmgmt 0/1> */
+unsigned int (*avbFpgaReadReg)(void* unused, unsigned int port, unsigned int reg, GT_U32* data)=gprtGetPhyReg;
+unsigned int (*avbFpgaWriteReg)(void* unused, unsigned int port, unsigned int reg, GT_U32 data)=gprtSetPhyReg;
+#define AVB_FPGA_READ_REG       avbFpgaReadReg  
+#define AVB_FPGA_WRITE_REG      avbFpgaWriteReg
+
+#endif /* 0 */
 
 #endif
 
 #if 0
-#define GT_PTP_BUILD_TIME(_time1, _time2)	(((_time1) << 16) | (_time2))
-#define GT_PTP_L16_TIME(_time1)	((_time1) & 0xFFFF)
-#define GT_PTP_H16_TIME(_time1)	(((_time1) >> 16) & 0xFFFF)
+#define GT_PTP_BUILD_TIME(_time1, _time2)    (((_time1) << 16) | (_time2))
+#define GT_PTP_L16_TIME(_time1)    ((_time1) & 0xFFFF)
+#define GT_PTP_H16_TIME(_time1)    (((_time1) >> 16) & 0xFFFF)
 #endif
 
 
@@ -56,9 +69,9 @@
 /****************************************************************************/
 static GT_STATUS ptpOperationPerform
 (
-    IN   GT_QD_DEV 			*dev,
-    IN   GT_PTP_OPERATION	ptpOp,
-    INOUT GT_PTP_OP_DATA 	*opData
+    IN   GT_QD_DEV             *dev,
+    IN   GT_PTP_OPERATION    ptpOp,
+    INOUT GT_PTP_OP_DATA     *opData
 );
 
 
@@ -69,7 +82,7 @@ static GT_STATUS ptpOperationPerform
 *       This routine writes PTP configuration parameters.
 *
 * INPUTS:
-*		ptpData  - PTP configuration parameters.
+*        ptpData  - PTP configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -77,7 +90,7 @@ static GT_STATUS ptpOperationPerform
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -86,133 +99,143 @@ static GT_STATUS ptpOperationPerform
 *******************************************************************************/
 GT_STATUS gptpSetConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_LPORT			port;
-	GT_PTP_PORT_CONFIG	ptpPortData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
 
-	DBG_INFO(("gptpSetConfig Called.\n"));
+    DBG_INFO(("gptpSetConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
 
-	/* setting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	opData.ptpData = ptpData->ptpEType;
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting MsgIDTSEn, offset 1 */
-	opData.ptpAddr = 1;
-	opData.ptpData = ptpData->msgIdTSEn;
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting TSArrPtr, offset 2 */
-	opData.ptpAddr = 2;
-	opData.ptpData = ptpData->tsArrPtr;
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing TSArrPtr.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
 #endif
     {
-		ptpPortData.transSpec = ptpData->transSpec;
-		ptpPortData.disTSpec = 1;	/* default value */
-		ptpPortData.disTSOverwrite = ptpData->disTSOverwrite;
-		ptpPortData.ipJump = 2;		/* default value */
-		ptpPortData.etJump = 12;	/* default value */
-
-		/* per port configuration */
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			ptpPortData.ptpArrIntEn = (ptpData->ptpArrIntEn & (1 << port))? GT_TRUE : GT_FALSE;
-			ptpPortData.ptpDepIntEn = (ptpData->ptpDepIntEn & (1 << port))? GT_TRUE : GT_FALSE;
-
-			if((retVal = gptpSetPortConfig(dev, port, &ptpPortData)) != GT_OK)
-			{
-        		DBG_INFO(("Failed gptpSetPortConfig.\n"));
-				return GT_FAIL;
-			}
-		}
+        ptpPortData.transSpec = ptpData->transSpec;
+        ptpPortData.disTSpec = 1;    /* default value */
+        ptpPortData.disTSOverwrite = ptpData->disTSOverwrite;
+        ptpPortData.ipJump = 2;        /* default value */
+        ptpPortData.etJump = 12;    /* default value */
+
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            ptpPortData.ptpArrIntEn = (ptpData->ptpArrIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+            ptpPortData.ptpDepIntEn = (ptpData->ptpDepIntEn & (1 << port))? GT_TRUE : GT_FALSE;
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+		  {
+/* 
+            ptpPortData.ptpArrIntEn = ptpData->ptpPortConfig[port].ptpArrIntEn? GT_TRUE : GT_FALSE;
+            ptpPortData.ptpDepIntEn = ptpData->ptpPortConfig[port].ptpDepIntEn? GT_TRUE : GT_FALSE;
+*/
+            ptpPortData.arrTSMode = ptpData->ptpPortConfig[port].arrTSMode;
+		  }
+
+            if((retVal = gptpSetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortConfig.\n"));
+                return GT_FAIL;
+            }
+        }
 
-		return GT_OK;
+        return GT_OK;
     }
 
-	/* setting PTPArrIntEn, offset 3 */
-	opData.ptpAddr = 3;
-	opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpArrIntEn);
+	/* old PTP block */
+    /* setting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpArrIntEn);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPArrIntEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting PTPDepIntEn, offset 4 */
-	opData.ptpAddr = 4;
-	opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpDepIntEn);
+    /* setting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    opData.ptpData = GT_LPORTVEC_2_PORTVEC(ptpData->ptpDepIntEn);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPDepIntEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* TransSpec, MsgIDStartBit, DisTSOverwrite bit, offset 5 */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 5;
+    /* TransSpec, MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
 
-	op = PTP_WRITE_DATA;
 #ifdef CONFIG_AVB_FPGA
-	opData.ptpData = ((ptpData->transSpec&0xF) << 12) | ((ptpData->msgIdStartBit&0x7) << 9) | 
-					(opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | ((ptpData->msgIdStartBit&0x7) << 9) | 
+                    (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
 #else
-	opData.ptpData = ((ptpData->transSpec&0xF) << 12) | (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
+    opData.ptpData = ((ptpData->transSpec&0xF) << 12) | (opData.ptpData & 0x1) | ((ptpData->disTSOverwrite?1:0) << 1);
 #endif
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -227,7 +250,7 @@ GT_STATUS gptpSetConfig
 *       None.
 *
 * OUTPUTS:
-*		ptpData  - PTP configuration parameters.
+*        ptpData  - PTP configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -240,131 +263,141 @@ GT_STATUS gptpSetConfig
 *******************************************************************************/
 GT_STATUS gptpGetConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_LPORT			port;
-	GT_PTP_PORT_CONFIG	ptpPortData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
+    GT_PTP_PORT_CONFIG    ptpPortData;
 
-	DBG_INFO(("gptpGetConfig Called.\n"));
+    DBG_INFO(("gptpGetConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->ptpEType = opData.ptpData;
+    ptpData->ptpEType = opData.ptpData;
 
-	/* getting MsgIDTSEn, offset 1 */
-	opData.ptpAddr = 1;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->msgIdTSEn = opData.ptpData;
+    ptpData->msgIdTSEn = opData.ptpData;
 
-	/* getting TSArrPtr, offset 2 */
-	opData.ptpAddr = 2;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading TSArrPtr.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->tsArrPtr = opData.ptpData;
+    ptpData->tsArrPtr = opData.ptpData;
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
 #endif
     {
-		ptpData->ptpArrIntEn = 0;
-		ptpData->ptpDepIntEn = 0;
-
-		/* per port configuration */
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if((retVal = gptpGetPortConfig(dev, port, &ptpPortData)) != GT_OK)
-			{
-        		DBG_INFO(("Failed gptpGetPortConfig.\n"));
-				return GT_FAIL;
-			}
+        ptpData->ptpArrIntEn = 0;
+        ptpData->ptpDepIntEn = 0;
 
-			ptpData->ptpArrIntEn |= (ptpPortData.ptpArrIntEn ? (1 << port) : 0);
-			ptpData->ptpDepIntEn |= (ptpPortData.ptpDepIntEn ? (1 << port) : 0);
-		}
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpGetPortConfig(dev, port, &ptpPortData)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpGetPortConfig.\n"));
+                return GT_FAIL;
+            }
+
+            ptpData->ptpArrIntEn |= (ptpPortData.ptpArrIntEn ? (1 << port) : 0);
+            ptpData->ptpDepIntEn |= (ptpPortData.ptpDepIntEn ? (1 << port) : 0);
+
+          if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+		  {
+            ptpData->ptpPortConfig[port].ptpArrIntEn = ptpPortData.ptpArrIntEn;
+            ptpData->ptpPortConfig[port].ptpDepIntEn = ptpPortData.ptpDepIntEn;
+			ptpData->ptpPortConfig[port].transSpec = ptpPortData.transSpec;
+			ptpData->ptpPortConfig[port].disTSOverwrite = ptpPortData.disTSOverwrite;
+            ptpData->ptpPortConfig[port].arrTSMode = ptpPortData.arrTSMode;
+		  }
+        }
 
-		ptpData->transSpec = ptpPortData.transSpec;
-		ptpData->disTSOverwrite = ptpPortData.disTSOverwrite;
+        ptpData->transSpec = ptpPortData.transSpec;
+        ptpData->disTSOverwrite = ptpPortData.disTSOverwrite;
 
-		ptpData->msgIdStartBit = 4;
+        ptpData->msgIdStartBit = 4;
 
-		return GT_OK;
+        return GT_OK;
     }
 
-	/* getting PTPArrIntEn, offset 3 */
-	opData.ptpAddr = 3;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+	/* old PTP block */
+    /* getting PTPArrIntEn, offset 3 */
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPArrIntEn.\n"));
-		return GT_FAIL;
-	}
-	opData.ptpData &= dev->validPortVec;
-	ptpData->ptpArrIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+        return GT_FAIL;
+    }
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpArrIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
 
 
-	/* getting PTPDepIntEn, offset 4 */
-	opData.ptpAddr = 4;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPDepIntEn, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPDepIntEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= dev->validPortVec;
-	ptpData->ptpDepIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+    opData.ptpData &= dev->validPortVec;
+    ptpData->ptpDepIntEn = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
 
-	/* MsgIDStartBit, DisTSOverwrite bit, offset 5 */
-	opData.ptpAddr = 5;
+    /* MsgIDStartBit, DisTSOverwrite bit, offset 5 */
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->transSpec = (opData.ptpData >> 12) & 0xF;
+    ptpData->transSpec = (opData.ptpData >> 12) & 0xF;
 #ifdef CONFIG_AVB_FPGA
-	ptpData->msgIdStartBit = (opData.ptpData >> 9) & 0x7;
+    ptpData->msgIdStartBit = (opData.ptpData >> 9) & 0x7;
 #else
-	ptpData->msgIdStartBit = 0;
+    ptpData->msgIdStartBit = 0;
 #endif
-	ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -375,7 +408,7 @@ GT_STATUS gptpGetConfig
 *       This routine writes PTP global configuration parameters.
 *
 * INPUTS:
-*		ptpData  - PTP global configuration parameters.
+*        ptpData  - PTP global configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -383,7 +416,7 @@ GT_STATUS gptpGetConfig
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -392,62 +425,62 @@ GT_STATUS gptpGetConfig
 *******************************************************************************/
 GT_STATUS gptpSetGlobalConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_GLOBAL_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_GLOBAL_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpSetGlobalConfig Called.\n"));
+    DBG_INFO(("gptpSetGlobalConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
 
-	/* setting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	opData.ptpData = ptpData->ptpEType;
+    /* setting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    opData.ptpData = ptpData->ptpEType;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting MsgIDTSEn, offset 1 */
-	opData.ptpAddr = 1;
-	opData.ptpData = ptpData->msgIdTSEn;
+    /* setting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = ptpData->msgIdTSEn;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting TSArrPtr, offset 2 */
-	opData.ptpAddr = 2;
-	opData.ptpData = ptpData->tsArrPtr;
+    /* setting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = ptpData->tsArrPtr;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing TSArrPtr.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -462,7 +495,7 @@ GT_STATUS gptpSetGlobalConfig
 *       None.
 *
 * OUTPUTS:
-*		ptpData  - PTP global configuration parameters.
+*        ptpData  - PTP global configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -475,62 +508,62 @@ GT_STATUS gptpSetGlobalConfig
 *******************************************************************************/
 GT_STATUS gptpGetGlobalConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_GLOBAL_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_GLOBAL_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpGetGlobalConfig Called.\n"));
+    DBG_INFO(("gptpGetGlobalConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->ptpEType = opData.ptpData;
+    ptpData->ptpEType = opData.ptpData;
 
-	/* getting MsgIDTSEn, offset 1 */
-	opData.ptpAddr = 1;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->msgIdTSEn = opData.ptpData;
+    ptpData->msgIdTSEn = opData.ptpData;
 
-	/* getting TSArrPtr, offset 2 */
-	opData.ptpAddr = 2;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading TSArrPtr.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->tsArrPtr = opData.ptpData;
+    ptpData->tsArrPtr = opData.ptpData;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -542,7 +575,7 @@ GT_STATUS gptpGetGlobalConfig
 *       This routine writes PTP port configuration parameters.
 *
 * INPUTS:
-*		ptpData  - PTP port configuration parameters.
+*        ptpData  - PTP port configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -550,7 +583,7 @@ GT_STATUS gptpGetGlobalConfig
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -559,88 +592,92 @@ GT_STATUS gptpGetGlobalConfig
 *******************************************************************************/
 GT_STATUS gptpSetPortConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_PTP_PORT_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_PTP_PORT_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
     GT_U32          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gptpSetPortConfig Called.\n"));
+    DBG_INFO(("gptpSetPortConfig Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	if (ptpData->transSpec > 0xF)	/* 4 bits */
-		return GT_BAD_PARAM;
+    if (ptpData->transSpec > 0xF)    /* 4 bits */
+        return GT_BAD_PARAM;
 
-	if (ptpData->etJump > 0x1F)	/* 5 bits */
-		return GT_BAD_PARAM;
+    if (ptpData->etJump > 0x1F)    /* 5 bits */
+        return GT_BAD_PARAM;
 
-	if (ptpData->ipJump > 0x3F)	/* 6 bits */
-		return GT_BAD_PARAM;
+    if (ptpData->ipJump > 0x3F)    /* 6 bits */
+        return GT_BAD_PARAM;
 
-	
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	/* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 0;
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
-	opData.ptpData = (ptpData->transSpec << 12) | (opData.ptpData & 0x1) |
-					((ptpData->disTSpec?1:0) << 11) |
-					((ptpData->disTSOverwrite?1:0) << 1);
+    op = PTP_WRITE_DATA;
+    opData.ptpData = (ptpData->transSpec << 12) | (opData.ptpData & 0x1) |
+                    ((ptpData->disTSpec?1:0) << 11) |
+                    ((ptpData->disTSOverwrite?1:0) << 1);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* setting etJump and ipJump, offset 1 */
-	opData.ptpAddr = 1;
-	opData.ptpData = (ptpData->ipJump << 8) | ptpData->etJump;
+    /* setting etJump and ipJump, offset 1 */
+    opData.ptpAddr = 1;
+    opData.ptpData = (ptpData->ipJump << 8) | ptpData->etJump;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
-
-	/* setting Int, offset 2 */
-	opData.ptpAddr = 2;
-	opData.ptpData = (ptpData->ptpArrIntEn?1:0) |
-					((ptpData->ptpDepIntEn?1:0) << 1);
+        return GT_FAIL;
+    }
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    /* setting Int, offset 2 */
+    opData.ptpAddr = 2;
+    opData.ptpData = (ptpData->ptpArrIntEn?1:0) |
+                    ((ptpData->ptpDepIntEn?1:0) << 1);
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
 	{
-        DBG_INFO(("Failed writing TSArrPtr.\n"));
-		return GT_FAIL;
+       opData.ptpData |= ((ptpData->arrTSMode&0xff) << 8);  /* from Agate to set ArrTSMode */
 	}
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TSArrPtr.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -655,7 +692,7 @@ GT_STATUS gptpSetPortConfig
 *       None.
 *
 * OUTPUTS:
-*		ptpData  - PTP port configuration parameters.
+*        ptpData  - PTP port configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -668,71 +705,75 @@ GT_STATUS gptpSetPortConfig
 *******************************************************************************/
 GT_STATUS gptpGetPortConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_PTP_PORT_CONFIG	*ptpData
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_PTP_PORT_CONFIG    *ptpData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
     GT_U32          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gptpGetPortConfig Called.\n"));
+    DBG_INFO(("gptpGetPortConfig Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = hwPort;
+    op = PTP_READ_DATA;
 
-	/* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* TransSpec, DisTSpecCheck, DisTSOverwrite bit, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->transSpec = opData.ptpData >> 12;
-	ptpData->disTSpec = ((opData.ptpData >> 11) & 0x1) ? GT_TRUE : GT_FALSE;
-	ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->transSpec = opData.ptpData >> 12;
+    ptpData->disTSpec = ((opData.ptpData >> 11) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->disTSOverwrite = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
 
-	/* getting MsgIDTSEn, offset 1 */
-	opData.ptpAddr = 1;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting MsgIDTSEn, offset 1 */
+    opData.ptpAddr = 1;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading MsgIDTSEn.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->ipJump = (opData.ptpData >> 8) & 0x3F;
-	ptpData->etJump = opData.ptpData & 0x1F;
+    ptpData->ipJump = (opData.ptpData >> 8) & 0x3F;
+    ptpData->etJump = opData.ptpData & 0x1F;
 
-	/* getting TSArrPtr, offset 2 */
-	opData.ptpAddr = 2;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting TSArrPtr, offset 2 */
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading TSArrPtr.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpData->ptpDepIntEn = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
-	ptpData->ptpArrIntEn = (opData.ptpData & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->ptpDepIntEn = ((opData.ptpData >> 1) & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpData->ptpArrIntEn = (opData.ptpData & 0x1) ? GT_TRUE : GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev, DEV_ARRV_TS_MODE))
+	{
+      ptpData->arrTSMode = (opData.ptpData &0xff00) >> 8;  /* from Agate to get ArrTSMode */
+	}
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -744,7 +785,7 @@ GT_STATUS gptpGetPortConfig
 *       This routine enables or disables PTP.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
 *
 * OUTPUTS:
 *       None.
@@ -760,67 +801,68 @@ GT_STATUS gptpGetPortConfig
 *******************************************************************************/
 GT_STATUS gptpSetPTPEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_LPORT			port;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_LPORT            port;
 
-	DBG_INFO(("gptpSetPTPEn Called.\n"));
+    DBG_INFO(("gptpSetPTPEn Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))  
 #endif
     {
-		/* per port configuration */
-		for(port=0; port<dev->numOfPorts; port++)
-		{
-			if((retVal = gptpSetPortPTPEn(dev, port, en)) != GT_OK)
-			{
-        		DBG_INFO(("Failed gptpSetPortPTPEn.\n"));
-				return GT_FAIL;
-			}
-		}
+        /* per port configuration */
+        for(port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gptpSetPortPTPEn(dev, port, en)) != GT_OK)
+            {
+                DBG_INFO(("Failed gptpSetPortPTPEn.\n"));
+                return GT_FAIL;
+            }
+        }
 
-		return GT_OK;
+        return GT_OK;
     }
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+	/* old PTP block */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 5;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
-	opData.ptpData &= ~0x1;
-	opData.ptpData |= (en ? 0 : 1);
+    op = PTP_WRITE_DATA;
+    opData.ptpData &= ~0x1;
+    opData.ptpData |= (en ? 0 : 1);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing MsgIDStartBit & DisTSOverwrite.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -835,7 +877,7 @@ GT_STATUS gptpSetPTPEn
 *       None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if enabled, GT_FALSE otherwise
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -848,54 +890,54 @@ GT_STATUS gptpSetPTPEn
 *******************************************************************************/
 GT_STATUS gptpGetPTPEn
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpGetPTPEn Called.\n"));
+    DBG_INFO(("gptpGetPTPEn Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
 #endif
     {
-		if((retVal = gptpGetPortPTPEn(dev, 0, en)) != GT_OK)
-		{
-       		DBG_INFO(("Failed gptpGetPortPTPEn.\n"));
-			return GT_FAIL;
-		}
+        if((retVal = gptpGetPortPTPEn(dev, 0, en)) != GT_OK)
+        {
+               DBG_INFO(("Failed gptpGetPortPTPEn.\n"));
+            return GT_FAIL;
+        }
 
-		return GT_OK;
+        return GT_OK;
     }
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 5;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -906,7 +948,7 @@ GT_STATUS gptpGetPTPEn
 *       This routine enables or disables PTP on a port.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
+*        en - GT_TRUE to enable PTP, GT_FALSE to disable PTP
 *
 * OUTPUTS:
 *       None.
@@ -922,57 +964,57 @@ GT_STATUS gptpGetPTPEn
 *******************************************************************************/
 GT_STATUS gptpSetPortPTPEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gptpSetPortPTPEn Called.\n"));
+    DBG_INFO(("gptpSetPortPTPEn Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
-	opData.ptpAddr = 0;
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpAddr = 0;
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if (en)
-		opData.ptpData &= ~0x1;
-	else
-		opData.ptpData |= 0x1;
+    if (en)
+        opData.ptpData &= ~0x1;
+    else
+        opData.ptpData |= 0x1;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing TransSpec,DisTSpecCheck,DisTSOverwrite.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -985,7 +1027,7 @@ GT_STATUS gptpSetPortPTPEn
 *       None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if enabled, GT_FALSE otherwise
+*        en - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -998,47 +1040,47 @@ GT_STATUS gptpSetPortPTPEn
 *******************************************************************************/
 GT_STATUS gptpGetPortPTPEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gptpGetPortPTPEn Called.\n"));
+    DBG_INFO(("gptpGetPortPTPEn Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpAddr = 0;
-	opData.ptpPort = hwPort;
+    opData.ptpAddr = 0;
+    opData.ptpPort = hwPort;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
+    *en = (opData.ptpData & 0x1) ? GT_FALSE : GT_TRUE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1048,18 +1090,18 @@ GT_STATUS gptpGetPortPTPEn
 *
 * DESCRIPTION:
 *       This routine gets PTP interrupt status for each port.
-*		The PTP Interrupt bit gets set for a given port when an incoming PTP 
-*		frame is time stamped and PTPArrIntEn for that port is set to 0x1.
-*		Similary PTP Interrupt bit gets set for a given port when an outgoing
-*		PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
-*		This bit gets cleared upon software reading and clearing the corresponding
-*		time counter valid bits that are valid for that port.
+*        The PTP Interrupt bit gets set for a given port when an incoming PTP 
+*        frame is time stamped and PTPArrIntEn for that port is set to 0x1.
+*        Similary PTP Interrupt bit gets set for a given port when an outgoing
+*        PTP frame is time stamped and PTPDepIntEn for that port is set to 0x1.
+*        This bit gets cleared upon software reading and clearing the corresponding
+*        time counter valid bits that are valid for that port.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		ptpInt 	- interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
+*        ptpInt     - interrupt status for each port (bit 0 for port 0, bit 1 for port 1, etc.)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1072,42 +1114,42 @@ GT_STATUS gptpGetPortPTPEn
 *******************************************************************************/
 GT_STATUS gptpGetPTPInt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*ptpInt
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpGetPTPInt Called.\n"));
+    DBG_INFO(("gptpGetPTPInt Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 8;
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= (1 << dev->maxPorts) - 1;
+    opData.ptpData &= (1 << dev->maxPorts) - 1;
 
-	*ptpInt = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
+    *ptpInt = GT_PORTVEC_2_LPORTVEC(opData.ptpData);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1117,13 +1159,13 @@ GT_STATUS gptpGetPTPInt
 *
 * DESCRIPTION:
 *       This routine gets the global timer value that is running off of the free
-*		running switch core clock.
+*        running switch core clock.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*		ptpTime	- PTP global time
+*        ptpTime    - PTP global time
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1136,74 +1178,74 @@ GT_STATUS gptpGetPTPInt
 *******************************************************************************/
 GT_STATUS gptpGetPTPGlobalTime
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*ptpTime
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpTime
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpGetPTPGlobalTime Called.\n"));
+    DBG_INFO(("gptpGetPTPGlobalTime Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
 #ifndef USE_SINGLE_READ
-	opData.ptpBlock = 0x0;	/* PTP register space */
-	opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;	/* Global register */
-	op = PTP_READ_MULTIPLE_DATA;
-	opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
-	opData.nData = 2;
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_MULTIPLE_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+    opData.nData = 2;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*ptpTime = GT_PTP_BUILD_TIME(opData.ptpMultiData[1],opData.ptpMultiData[0]);
+    *ptpTime = GT_PTP_BUILD_TIME(opData.ptpMultiData[1],opData.ptpMultiData[0]);
 #else
-	{
-	GT_U32 data[2];
+    {
+    GT_U32 data[2];
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
-	opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
+    opData.ptpBlock = 0x0;    /* PTP register space */
+    opData.ptpPort = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:0xF;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = IS_IN_DEV_GROUP(dev,DEV_TAI)?0xE:9;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	data[0] = opData.ptpData;
+    data[0] = opData.ptpData;
 
-	op = PTP_READ_DATA;
-	opData.ptpAddr++;
+    op = PTP_READ_DATA;
+    opData.ptpAddr++;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	data[1] = opData.ptpData;
+    data[1] = opData.ptpData;
 
-	*ptpTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+    *ptpTime = GT_PTP_BUILD_TIME(data[1],data[0]);
 
-	}
+    }
 #endif
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1212,21 +1254,21 @@ GT_STATUS gptpGetPTPGlobalTime
 * gptpGetTimeStamped
 *
 * DESCRIPTION:
-*		This routine retrieves the PTP port status that includes time stamp value 
-*		and sequce Id that are captured by PTP logic for a PTP frame that needs 
-*		to be time stamped.
+*        This routine retrieves the PTP port status that includes time stamp value 
+*        and sequce Id that are captured by PTP logic for a PTP frame that needs 
+*        to be time stamped.
 *
 * INPUTS:
-*       port 		- logical port number.
-*       timeToRead	- Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*       port         - logical port number.
+*       timeToRead    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
 *
 * OUTPUTS:
-*		ptpStatus	- PTP port status
+*        ptpStatus    - PTP port status
 *
 * RETURNS:
-*       GT_OK 		- on success
-*       GT_FAIL 	- on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1235,106 +1277,106 @@ GT_STATUS gptpGetPTPGlobalTime
 *******************************************************************************/
 GT_STATUS gptpGetTimeStamped
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN	GT_PTP_TIME	timeToRead,
-	OUT GT_PTP_TS_STATUS	*ptpStatus
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToRead,
+    OUT GT_PTP_TS_STATUS    *ptpStatus
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				hwPort;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32				baseReg;
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
 
-	DBG_INFO(("gptpGetTimeStamped Called.\n"));
+    DBG_INFO(("gptpGetTimeStamped Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-	{
+    if (hwPort == GT_INVALID_PORT)
+    {
         DBG_INFO(("Invalid port number\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
-		baseReg = 8;
-	else
-		baseReg = 0;
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
 #else
-	baseReg = 8;
+    baseReg = 8;
 #endif
 
-	switch (timeToRead)
-	{
-		case PTP_ARR0_TIME:
-			opData.ptpAddr = baseReg + 0;
-			break;
-		case PTP_ARR1_TIME:
-			opData.ptpAddr = baseReg + 4;
-			break;
-		case PTP_DEP_TIME:
-			opData.ptpAddr = baseReg + 8;
-			break;
-		default:
-        	DBG_INFO(("Invalid time to be read\n"));
-			return GT_BAD_PARAM;
-	}
+    switch (timeToRead)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to be read\n"));
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpPort = hwPort;
-	opData.ptpBlock = 0;
+    opData.ptpPort = hwPort;
+    opData.ptpBlock = 0;
 
 #ifndef USE_SINGLE_READ
-	op = PTP_READ_TIMESTAMP_DATA;
-	opData.nData = 4;
+    op = PTP_READ_TIMESTAMP_DATA;
+    opData.nData = 4;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	ptpStatus->isValid = (opData.ptpMultiData[0] & 0x1) ? GT_TRUE : GT_FALSE;
-	ptpStatus->status = (GT_PTP_INT_STATUS)((opData.ptpMultiData[0] >> 1) & 0x3);
-	ptpStatus->timeStamped = GT_PTP_BUILD_TIME(opData.ptpMultiData[2],opData.ptpMultiData[1]);
-	ptpStatus->ptpSeqId = opData.ptpMultiData[3];
+    ptpStatus->isValid = (opData.ptpMultiData[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((opData.ptpMultiData[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(opData.ptpMultiData[2],opData.ptpMultiData[1]);
+    ptpStatus->ptpSeqId = opData.ptpMultiData[3];
 #else
-	{
-	GT_U32 data[4], i;
+    {
+    GT_U32 data[4], i;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	for (i=0; i<4; i++)
-	{
-		if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-		{
-        	DBG_INFO(("Failed reading DisPTP.\n"));
-			return GT_FAIL;
-		}
-	
-		data[i] = opData.ptpData;
-		opData.ptpAddr++;
-	}
+    for (i=0; i<4; i++)
+    {
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed reading DisPTP.\n"));
+            return GT_FAIL;
+        }
+    
+        data[i] = opData.ptpData;
+        opData.ptpAddr++;
+    }
 
-	ptpStatus->isValid = (data[0] & 0x1) ? GT_TRUE : GT_FALSE;
-	ptpStatus->status = (GT_PTP_INT_STATUS)((data[0] >> 1) & 0x3);
-	ptpStatus->timeStamped = GT_PTP_BUILD_TIME(data[2],data[1]);
-	ptpStatus->ptpSeqId = data[3];
+    ptpStatus->isValid = (data[0] & 0x1) ? GT_TRUE : GT_FALSE;
+    ptpStatus->status = (GT_PTP_INT_STATUS)((data[0] >> 1) & 0x3);
+    ptpStatus->timeStamped = GT_PTP_BUILD_TIME(data[2],data[1]);
+    ptpStatus->ptpSeqId = data[3];
 
-	}
+    }
 #endif
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1343,20 +1385,20 @@ GT_STATUS gptpGetTimeStamped
 * gptpResetTimeStamp
 *
 * DESCRIPTION:
-*		This routine resets PTP Time valid bit so that PTP logic can time stamp
-*		a next PTP frame that needs to be time stamped.
+*        This routine resets PTP Time valid bit so that PTP logic can time stamp
+*        a next PTP frame that needs to be time stamped.
 *
 * INPUTS:
-*       port 		- logical port number.
-*       timeToReset	- Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
+*       port         - logical port number.
+*       timeToReset    - Arr0, Arr1, or Dep time (GT_PTP_TIME enum type)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*       GT_OK 		- on success
-*       GT_FAIL 	- on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*       GT_OK         - on success
+*       GT_FAIL     - on error
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1365,73 +1407,73 @@ GT_STATUS gptpGetTimeStamped
 *******************************************************************************/
 GT_STATUS gptpResetTimeStamp
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN	GT_PTP_TIME	timeToReset
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN    GT_PTP_TIME    timeToReset
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				hwPort;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32				baseReg;
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                baseReg;
 
-	DBG_INFO(("gptpResetTimeStamp Called.\n"));
+    DBG_INFO(("gptpResetTimeStamp Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-	{
+    if (hwPort == GT_INVALID_PORT)
+    {
         DBG_INFO(("Invalid port number\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
 #ifndef CONFIG_AVB_FPGA
-	if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
-		baseReg = 8;
-	else
-		baseReg = 0;
+    if (IS_IN_DEV_GROUP(dev,DEV_PTP_2))
+        baseReg = 8;
+    else
+        baseReg = 0;
 #else
-	baseReg = 8;
+    baseReg = 8;
 #endif
 
-	switch (timeToReset)
-	{
-		case PTP_ARR0_TIME:
-			opData.ptpAddr = baseReg + 0;
-			break;
-		case PTP_ARR1_TIME:
-			opData.ptpAddr = baseReg + 4;
-			break;
-		case PTP_DEP_TIME:
-			opData.ptpAddr = baseReg + 8;
-			break;
-		default:
-        	DBG_INFO(("Invalid time to reset\n"));
-			return GT_BAD_PARAM;
-	}
+    switch (timeToReset)
+    {
+        case PTP_ARR0_TIME:
+            opData.ptpAddr = baseReg + 0;
+            break;
+        case PTP_ARR1_TIME:
+            opData.ptpAddr = baseReg + 4;
+            break;
+        case PTP_DEP_TIME:
+            opData.ptpAddr = baseReg + 8;
+            break;
+        default:
+            DBG_INFO(("Invalid time to reset\n"));
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpPort = hwPort;
-	opData.ptpData = 0;
-	opData.ptpBlock = 0;
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpData = 0;
+    opData.ptpBlock = 0;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Port Status.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1443,11 +1485,11 @@ GT_STATUS gptpResetTimeStamp
 *       This routine reads PTP register.
 *
 * INPUTS:
-*       port 		- logical port number.
-*       regOffset	- register to read
+*       port         - logical port number.
+*       regOffset    - register to read
 *
 * OUTPUTS:
-*		data		- register data
+*        data        - register data
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1460,51 +1502,51 @@ GT_STATUS gptpResetTimeStamp
 *******************************************************************************/
 GT_STATUS gptpGetReg
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		regOffset,
-	OUT GT_U32		*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    OUT GT_U32        *data
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				hwPort;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpGetReg Called.\n"));
+    DBG_INFO(("gptpGetReg Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
     hwPort = (GT_U32)port;
 
-	if (regOffset > 0x1F)
-	{
+    if (regOffset > 0x1F)
+    {
         DBG_INFO(("Invalid reg offset\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	op = PTP_READ_DATA;
-	opData.ptpPort = hwPort;
-	opData.ptpAddr = regOffset;
-	opData.ptpBlock = 0;
+    op = PTP_READ_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpBlock = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*data = opData.ptpData;
+    *data = opData.ptpData;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1515,12 +1557,12 @@ GT_STATUS gptpGetReg
 *       This routine writes data to PTP register.
 *
 * INPUTS:
-*       port 		- logical port number
-*       regOffset	- register to be written
-*		data		- data to be written
+*       port         - logical port number
+*       regOffset    - register to be written
+*        data        - data to be written
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1533,55 +1575,55 @@ GT_STATUS gptpGetReg
 *******************************************************************************/
 GT_STATUS gptpSetReg
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U32		regOffset,
-	IN  GT_U32		data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U32        regOffset,
+    IN  GT_U32        data
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				hwPort;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_U32                hwPort;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gptpSetReg Called.\n"));
+    DBG_INFO(("gptpSetReg Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PTP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
     hwPort = (GT_U32)port;
 
-	if ((regOffset > 0x1F) || (data > 0xFFFF))
-	{
+    if ((regOffset > 0x1F) || (data > 0xFFFF))
+    {
         DBG_INFO(("Invalid reg offset/data\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
-	op = PTP_WRITE_DATA;
-	opData.ptpPort = hwPort;
-	opData.ptpAddr = regOffset;
-	opData.ptpData = data;
-	opData.ptpBlock = 0;
+    op = PTP_WRITE_DATA;
+    opData.ptpPort = hwPort;
+    opData.ptpAddr = regOffset;
+    opData.ptpData = data;
+    opData.ptpBlock = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
-
+/* TAI functions */
 /*******************************************************************************
 * gtaiSetEventConfig
 *
@@ -1589,7 +1631,7 @@ GT_STATUS gptpSetReg
 *       This routine sets TAI Event Capture configuration parameters.
 *
 * INPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * OUTPUTS:
 *       None.
@@ -1597,7 +1639,7 @@ GT_STATUS gptpSetReg
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1606,58 +1648,63 @@ GT_STATUS gptpSetReg
 *******************************************************************************/
 GT_STATUS gtaiSetEventConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_TAI_EVENT_CONFIG	*eventData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_EVENT_CONFIG    *eventData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetEventConfig Called.\n"));
+    DBG_INFO(("gtaiSetEventConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~((3<<14)|(1<<8));
-	if (eventData->intEn)
-		opData.ptpData |= (1 << 8);
-	if (eventData->eventOverwrite)
-		opData.ptpData |= (1 << 15);
-	if (eventData->eventCtrStart)
-		opData.ptpData |= (1 << 14);
+    opData.ptpData &= ~((3<<14)|(1<<8));
+    if (eventData->intEn)
+        opData.ptpData |= (1 << 8);
+    if (eventData->eventOverwrite)
+        opData.ptpData |= (1 << 15);
+    if (eventData->eventCtrStart)
+        opData.ptpData |= (1 << 14);
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      if (eventData->eventPhase)
+        opData.ptpData |= (1 << 13);
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1672,7 +1719,7 @@ GT_STATUS gtaiSetEventConfig
 *       None.
 *
 * OUTPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1685,48 +1732,51 @@ GT_STATUS gtaiSetEventConfig
 *******************************************************************************/
 GT_STATUS gtaiGetEventConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_TAI_EVENT_CONFIG	*eventData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_CONFIG    *eventData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiGetEventConfig Called.\n"));
+    DBG_INFO(("gtaiGetEventConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	eventData->intEn = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
-	eventData->eventOverwrite = (opData.ptpData & (1<<15))?GT_TRUE:GT_FALSE;
-	eventData->eventCtrStart = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+    eventData->intEn = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    eventData->eventOverwrite = (opData.ptpData & (1<<15))?GT_TRUE:GT_FALSE;
+    eventData->eventCtrStart = (opData.ptpData & (1<<14))?GT_TRUE:GT_FALSE;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      eventData->eventPhase = (opData.ptpData & (1<<13))?GT_TRUE:GT_FALSE;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
-
 /*******************************************************************************
 * gtaiGetEventStatus
 *
@@ -1737,7 +1787,7 @@ GT_STATUS gtaiGetEventConfig
 *       None.
 *
 * OUTPUTS:
-*		eventData  - TAI Event Capture configuration parameters.
+*        eventData  - TAI Event Capture configuration parameters.
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1750,67 +1800,67 @@ GT_STATUS gtaiGetEventConfig
 *******************************************************************************/
 GT_STATUS gtaiGetEventStatus
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_TAI_EVENT_STATUS	*status
+    IN  GT_QD_DEV     *dev,
+    OUT GT_TAI_EVENT_STATUS    *status
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32 				data[2];
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
 
-	DBG_INFO(("gtaiGetEventStatus Called.\n"));
+    DBG_INFO(("gtaiGetEventStatus Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 9;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 9;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	status->isValid = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
-	status->eventCtr = opData.ptpData & 0xFF;
-	status->eventErr = (opData.ptpData & (1<<9))?GT_TRUE:GT_FALSE;
+    status->isValid = (opData.ptpData & (1<<8))?GT_TRUE:GT_FALSE;
+    status->eventCtr = opData.ptpData & 0xFF;
+    status->eventErr = (opData.ptpData & (1<<9))?GT_TRUE:GT_FALSE;
 
-	if (status->isValid == GT_FALSE)
-	{
-		return GT_OK;
-	}
+    if (status->isValid == GT_FALSE)
+    {
+        return GT_OK;
+    }
 
-	opData.ptpAddr = 10;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 10;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
-	data[0] = opData.ptpData;
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
 
-	opData.ptpAddr = 11;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 11;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
-	data[1] = opData.ptpData;
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
 
-	status->eventTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+    status->eventTime = GT_PTP_BUILD_TIME(data[1],data[0]);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -1825,7 +1875,7 @@ GT_STATUS gtaiGetEventStatus
 *       None.
 *
 * OUTPUTS:
-*		intStatus 	- interrupt status for TAI Event capture
+*        intStatus     - interrupt status for TAI Event capture
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1838,42 +1888,178 @@ GT_STATUS gtaiGetEventStatus
 *******************************************************************************/
 GT_STATUS gtaiGetEventInt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*intStatus
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiGetEventInt Called.\n"));
+    DBG_INFO(("gtaiGetEventInt Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpPort = 0xE;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 9;
-	opData.ptpBlock = 0;
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 9;
+    opData.ptpBlock = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gtaiSetClockSelect
+*
+* DESCRIPTION:
+*       This routine sets several clock select in TAI.
+*
+* INPUTS:
+*        clkSelect  - TAI clock select configuration parameters.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
 
-	*intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+    opData.ptpData &= ~(0x4077);
+    opData.ptpData |= (((clkSelect->priRecClkSel)&7) << 0);
+    opData.ptpData |= (((clkSelect->syncRecClkSel)&7) << 4);
+    opData.ptpData |= (((clkSelect->ptpExtClk)&1) << 14);
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 8;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
 }
 
+/*******************************************************************************
+* gtaiGetClockSelect
+*
+* DESCRIPTION:
+*       This routine gets several clock select in TAI.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       clkSelect  - TAI clock select configuration parameters.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetClockSelect
+(
+    IN  GT_QD_DEV     *dev,
+    OUT  GT_TAI_CLOCK_SELECT    *clkSelect
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA      opData;
+
+    DBG_INFO(("gtaiGetClockSelect Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    /* getting Tai clock select, offset 8 */
+    opData.ptpAddr = 8;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    clkSelect->priRecClkSel = opData.ptpData&7;
+    clkSelect->syncRecClkSel = (opData.ptpData >> 4) & 7;
+    clkSelect->ptpExtClk = (opData.ptpData>> 14) & 1;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
 
 /*******************************************************************************
 * gtaiGetTrigInt
@@ -1885,7 +2071,7 @@ GT_STATUS gtaiGetEventInt
 *       None.
 *
 * OUTPUTS:
-*		intStatus 	- interrupt status for TAI Trigger
+*        intStatus     - interrupt status for TAI Trigger
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -1898,40 +2084,106 @@ GT_STATUS gtaiGetEventInt
 *******************************************************************************/
 GT_STATUS gtaiGetTrigInt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*intStatus
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *intStatus
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiGetTrigInt Called.\n"));
+    DBG_INFO(("gtaiGetTrigInt Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpPort = 0xE;	/* Global register */
-	op = PTP_READ_DATA;
-	opData.ptpAddr = 8;
-	opData.ptpBlock = 0;
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
+
+    *intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiClearTrigInt
+*
+* DESCRIPTION:
+*       This routine clear TAI Trigger Interrupt status.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtaiClearTrigInt
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiClearTrigInt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpPort = 0xE;    /* Global register */
+    op = PTP_READ_DATA;
+    opData.ptpAddr = 8;
+    opData.ptpBlock = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
 
-	*intStatus = (opData.ptpData & 0x8000)?GT_TRUE:GT_FALSE;
+    opData.ptpData &= 0x7fff;
+    op = PTP_WRITE_DATA;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -1942,8 +2194,8 @@ GT_STATUS gtaiGetTrigInt
 *       This routine sets TAI Trigger configuration parameters.
 *
 * INPUTS:
-*		trigEn    - enable/disable TAI Trigger.
-*		trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
 *
 * OUTPUTS:
 *       None.
@@ -1951,7 +2203,7 @@ GT_STATUS gtaiGetTrigInt
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1960,130 +2212,137 @@ GT_STATUS gtaiGetTrigInt
 *******************************************************************************/
 GT_STATUS gtaiSetTrigConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL 	trigEn,
-	IN  GT_TAI_TRIGGER_CONFIG	*trigData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     trigEn,
+    IN  GT_TAI_TRIGGER_CONFIG    *trigData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetTrigConfig Called.\n"));
+    DBG_INFO(("gtaiSetTrigConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(3|(1<<9));
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      if (trigData->trigPhase)
+        opData.ptpData |= (1 << 12);
+    }
 
-	if (trigEn == GT_FALSE)
-	{
-		op = PTP_WRITE_DATA;
+    opData.ptpData &= ~(3|(1<<9));
+
+    if (trigEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
 
-		if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-		{
-        	DBG_INFO(("Failed writing PTPEType.\n"));
-			return GT_FAIL;
-		}
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
 
-		return GT_OK;
-	}
+        return GT_OK;
+    }
 
-	opData.ptpData |= 1;
+    opData.ptpData |= 1;
 
-	if (trigData->intEn)
-		opData.ptpData |= (1 << 9);
+    if (trigData->intEn)
+        opData.ptpData |= (1 << 9);
 
-	if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
-		opData.ptpData |= (1 << 1);
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+        opData.ptpData |= (1 << 1);
 
-	op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 0;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpAddr = 2;
-	opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenAmt);
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(trigData->trigGenAmt);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpAddr = 3;
-	opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenAmt);
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(trigData->trigGenAmt);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
-	{
-		if ((trigData->pulseWidth >= 0) && (trigData->pulseWidth <= 0xF))
-		{			
-			op = PTP_READ_DATA;
-			opData.ptpAddr = 5;		/* PulseWidth */
-
-			if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-			{
-				DBG_INFO(("Failed writing PTPEType.\n"));
-				return GT_FAIL;
-			}
-
-			op = PTP_WRITE_DATA;
-			opData.ptpAddr = 5;		/* PulseWidth */
-			opData.ptpData &= (~0xF000);
-			opData.ptpData |= (GT_U16)(trigData->pulseWidth << 12);
-
-			if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-			{
-				DBG_INFO(("Failed writing PTPEType.\n"));
-				return GT_FAIL;
-			}
-		}
-	}
-	else
-	{
-		op = PTP_WRITE_DATA;
-		opData.ptpAddr = 4;		/* TrigClkComp */
-		opData.ptpData = (GT_U16)trigData->trigClkComp;
-
-		if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-		{
-			DBG_INFO(("Failed writing PTPEType.\n"));
-			return GT_FAIL;
-		}
-	}
+    if (trigData->mode == GT_TAI_TRIG_ON_GIVEN_TIME)
+    {
+        if ((trigData->pulseWidth >= 0) && (trigData->pulseWidth <= 0xF))
+        {            
+            op = PTP_READ_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+
+            op = PTP_WRITE_DATA;
+            opData.ptpAddr = 5;        /* PulseWidth */
+            opData.ptpData &= (~0xF000);
+            opData.ptpData |= (GT_U16)(trigData->pulseWidth << 12);
+
+            if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+            {
+                DBG_INFO(("Failed writing PTPEType.\n"));
+                return GT_FAIL;
+            }
+        }
+    }
+    else
+    {
+        op = PTP_WRITE_DATA;
+        opData.ptpAddr = 4;        /* TrigClkComp */
+        opData.ptpData = (GT_U16)trigData->trigClkComp;
+
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing PTPEType.\n"));
+            return GT_FAIL;
+        }
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -2097,13 +2356,13 @@ GT_STATUS gtaiSetTrigConfig
 *       None.
 *
 * OUTPUTS:
-*		trigEn    - enable/disable TAI Trigger.
-*		trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
+*        trigEn    - enable/disable TAI Trigger.
+*        trigData  - TAI Trigger configuration parameters (valid only if trigEn is GT_TRUE).
 *
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -2112,94 +2371,99 @@ GT_STATUS gtaiSetTrigConfig
 *******************************************************************************/
 GT_STATUS gtaiGetTrigConfig
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL 	*trigEn,
-	OUT GT_TAI_TRIGGER_CONFIG	*trigData
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *trigEn,
+    OUT GT_TAI_TRIGGER_CONFIG    *trigData
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32 				data[2];
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
 
-	DBG_INFO(("gtaiGetTrigConfig Called.\n"));
+    DBG_INFO(("gtaiGetTrigConfig Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	if (!(opData.ptpData & 1))
-	{
-		*trigEn = GT_FALSE;
-		return GT_OK;
-	}
+    if (!(opData.ptpData & 1))
+    {
+        *trigEn = GT_FALSE;
+        return GT_OK;
+    }
 
-	if (trigData == NULL)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (trigData == NULL)
+    {
+        return GT_BAD_PARAM;
+    }
+
+    *trigEn = GT_TRUE;
+    trigData->mode = (opData.ptpData >> 1) & 1;
+    trigData->intEn = (opData.ptpData >> 9) & 1;
+    if (IS_IN_DEV_GROUP(dev,DEV_TAI_EXT_CLK))
+    {
+      trigData->trigPhase = (opData.ptpData >>12) & 1;
+    }
 
-	*trigEn = GT_TRUE;
-	trigData->mode = (opData.ptpData >> 1) & 1;
-	trigData->intEn = (opData.ptpData >> 9) & 1;
 
-	opData.ptpAddr = 2;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
-	data[0] = opData.ptpData;
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
 
-	opData.ptpAddr = 3;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
-	data[1] = opData.ptpData;
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
 
-	trigData->trigGenAmt = GT_PTP_BUILD_TIME(data[1],data[0]);
+    trigData->trigGenAmt = GT_PTP_BUILD_TIME(data[1],data[0]);
 
-	opData.ptpAddr = 5;		/* PulseWidth */
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing PTPEType.\n"));
-		return GT_FAIL;
-	}
+    opData.ptpAddr = 5;        /* PulseWidth */
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing PTPEType.\n"));
+        return GT_FAIL;
+    }
 
-	trigData->pulseWidth = (GT_U32)((opData.ptpData >> 12) & 0xF);
+    trigData->pulseWidth = (GT_U32)((opData.ptpData >> 12) & 0xF);
 
-	/* getting TrigClkComp, offset 4 */
-	opData.ptpAddr = 4;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading PTPEType.\n"));
-		return GT_FAIL;
-	}
+    /* getting TrigClkComp, offset 4 */
+    opData.ptpAddr = 4;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading PTPEType.\n"));
+        return GT_FAIL;
+    }
 
-	trigData->trigClkComp = (GT_U32)opData.ptpData;
+    trigData->trigClkComp = (GT_U32)opData.ptpData;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -2208,65 +2472,65 @@ GT_STATUS gtaiGetTrigConfig
 * gtaiGetTSClkPer
 *
 * DESCRIPTION:
-* 		Time Stamping Clock Period in pico seconds.
-*		This routine specifies the clock period for the time stamping clock supplied 
-*		to the PTP hardware logic.
-*		This is the clock that is used by the hardware logic to update the PTP 
-*		Global Time Counter.
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied 
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP 
+*        Global Time Counter.
 *
 * INPUTS:
-* 		None.
+*         None.
 *
 * OUTPUTS:
-*		clk		- time stamping clock period
+*        clk        - time stamping clock period
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gtaiGetTSClkPer
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*clk
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clk
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiGetTSClkPer Called.\n"));
+    DBG_INFO(("gtaiGetTSClkPer Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 1;
+    opData.ptpAddr = 1;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*clk = (GT_U32)opData.ptpData;
+    *clk = (GT_U32)opData.ptpData;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2274,65 +2538,65 @@ GT_STATUS gtaiGetTSClkPer
 * gtaiSetTSClkPer
 *
 * DESCRIPTION:
-* 		Time Stamping Clock Period in pico seconds.
-*		This routine specifies the clock period for the time stamping clock supplied 
-*		to the PTP hardware logic.
-*		This is the clock that is used by the hardware logic to update the PTP 
-*		Global Time Counter.
+*         Time Stamping Clock Period in pico seconds.
+*        This routine specifies the clock period for the time stamping clock supplied 
+*        to the PTP hardware logic.
+*        This is the clock that is used by the hardware logic to update the PTP 
+*        Global Time Counter.
 *
 * INPUTS:
-*		clk		- time stamping clock period
+*        clk        - time stamping clock period
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gtaiSetTSClkPer
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		clk
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clk
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetTSClkPer Called.\n"));
+    DBG_INFO(("gtaiSetTSClkPer Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 1;
+    opData.ptpAddr = 1;
 
-	opData.ptpData = (GT_U16)clk; 
+    opData.ptpData = (GT_U16)clk; 
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2340,111 +2604,111 @@ GT_STATUS gtaiSetTSClkPer
 * gtaiSetMultiPTPSync
 *
 * DESCRIPTION:
-* 		This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
-*		When enabled, the hardware logic detects a low to high transition on the 
-*		EventRequest(GPIO) and transfers the sync time into the PTP Global Time
-*		register. The EventCapTime is also updated at that instant.
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the 
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
 *
 * INPUTS:
-*		multiEn		- enable/disable Multiple PTP device sync mode
-*		syncTime	- sync time (valid only if multiEn is GT_TRUE)
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
-*		and gtaiSetTimeDec APIs are not operational.
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
 *
 *******************************************************************************/
 GT_STATUS gtaiSetMultiPTPSync
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL 	multiEn,
-	IN  GT_32		syncTime
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL     multiEn,
+    IN  GT_32        syncTime
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetMultiPTPSync Called.\n"));
+    DBG_INFO(("gtaiSetMultiPTPSync Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
     {
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(1 << 2);
+    opData.ptpData &= ~(1 << 2);
 
-	if (multiEn == GT_FALSE)
-	{
-		op = PTP_WRITE_DATA;
+    if (multiEn == GT_FALSE)
+    {
+        op = PTP_WRITE_DATA;
 
-		if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-		{
-			DBG_INFO(("Failed writing TAI register.\n"));
-			return GT_FAIL;
-		}
+        if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+        {
+            DBG_INFO(("Failed writing TAI register.\n"));
+            return GT_FAIL;
+        }
 
-		return GT_OK;
-	}
+        return GT_OK;
+    }
 
-	opData.ptpData |= (1 << 2);
+    opData.ptpData |= (1 << 2);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpAddr = 2;
-	opData.ptpData = GT_PTP_L16_TIME(syncTime);
+    opData.ptpAddr = 2;
+    opData.ptpData = GT_PTP_L16_TIME(syncTime);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpAddr = 3;
-	opData.ptpData = GT_PTP_H16_TIME(syncTime);
+    opData.ptpAddr = 3;
+    opData.ptpData = GT_PTP_H16_TIME(syncTime);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -2453,92 +2717,92 @@ GT_STATUS gtaiSetMultiPTPSync
 * gtaiGetMultiPTPSync
 *
 * DESCRIPTION:
-* 		This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
-*		When enabled, the hardware logic detects a low to high transition on the 
-*		EventRequest(GPIO) and transfers the sync time into the PTP Global Time
-*		register. The EventCapTime is also updated at that instant.
+*         This routine sets Multiple PTP device sync mode and sync time (TrigGenAmt).
+*        When enabled, the hardware logic detects a low to high transition on the 
+*        EventRequest(GPIO) and transfers the sync time into the PTP Global Time
+*        register. The EventCapTime is also updated at that instant.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		multiEn		- enable/disable Multiple PTP device sync mode
-*		syncTime	- sync time (valid only if multiEn is GT_TRUE)
+*        multiEn        - enable/disable Multiple PTP device sync mode
+*        syncTime    - sync time (valid only if multiEn is GT_TRUE)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM - if invalid parameter is given
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
-*		and gtaiSetTimeDec APIs are not operational.
+*         When enabled, gtaiSetTrigConfig, gtaiSetEventConfig, gtaiSetTimeInc,
+*        and gtaiSetTimeDec APIs are not operational.
 *
 *******************************************************************************/
 GT_STATUS gtaiGetMultiPTPSync
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL 	*multiEn,
-	OUT GT_32		*syncTime
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL     *multiEn,
+    OUT GT_32        *syncTime
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32 				data[2];
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32                 data[2];
 
-	DBG_INFO(("gtaiGetMultiPTPSync Called.\n"));
+    DBG_INFO(("gtaiGetMultiPTPSync Called.\n"));
 
     /* check if device supports this feature */
 #ifndef CONFIG_AVB_FPGA
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI_MULTI_PTP_SYNC))
     {
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	/* getting PTPEType, offset 0 */
-	opData.ptpAddr = 0;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    /* getting PTPEType, offset 0 */
+    opData.ptpAddr = 0;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	if(!(opData.ptpData & (1 << 2)))
-	{
-		*multiEn = GT_FALSE;
-		*syncTime = 0;
-		return GT_OK;
-	}
+    if(!(opData.ptpData & (1 << 2)))
+    {
+        *multiEn = GT_FALSE;
+        *syncTime = 0;
+        return GT_OK;
+    }
 
-	opData.ptpAddr = 2;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
-	data[0] = opData.ptpData;
+    opData.ptpAddr = 2;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[0] = opData.ptpData;
 
-	opData.ptpAddr = 3;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
-	data[1] = opData.ptpData;
+    opData.ptpAddr = 3;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+    data[1] = opData.ptpData;
 
-	*syncTime = GT_PTP_BUILD_TIME(data[1],data[0]);
+    *syncTime = GT_PTP_BUILD_TIME(data[1],data[0]);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -2547,79 +2811,79 @@ GT_STATUS gtaiGetMultiPTPSync
 * gtaiGetTimeIncDec
 *
 * DESCRIPTION:
-* 		This routine retrieves Time increment/decrement setup.
-*		This amount specifies the number of units of PTP Global Time that need to be 
-*		incremented or decremented. This is used for adjusting the PTP Global Time 
-*		counter value by a certain amount.
+*         This routine retrieves Time increment/decrement setup.
+*        This amount specifies the number of units of PTP Global Time that need to be 
+*        incremented or decremented. This is used for adjusting the PTP Global Time 
+*        counter value by a certain amount.
 *
 * INPUTS:
-* 		None.
+*         None.
 *
 * OUTPUTS:
-*		expired	- GT_TRUE if inc/dec occurred, GT_FALSE otherwise
-*		inc		- GT_TRUE if increment, GT_FALSE if decrement
-*		amount	- increment/decrement amount
+*        expired    - GT_TRUE if inc/dec occurred, GT_FALSE otherwise
+*        inc        - GT_TRUE if increment, GT_FALSE if decrement
+*        amount    - increment/decrement amount
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		Time increment or decrement will be excuted once.
+*         Time increment or decrement will be excuted once.
 *
 *******************************************************************************/
 GT_STATUS gtaiGetTimeIncDec
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*expired,
-	OUT GT_BOOL		*inc,
-	OUT GT_U32		*amount
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *expired,
+    OUT GT_BOOL        *inc,
+    OUT GT_U32        *amount
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiGetTimeIncDec Called.\n"));
+    DBG_INFO(("gtaiGetTimeIncDec Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 5;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*inc = (opData.ptpData & 0x800)?GT_FALSE:GT_TRUE;
-	*amount = (GT_U32)(opData.ptpData & 0x7FF);
+    *inc = (opData.ptpData & 0x800)?GT_FALSE:GT_TRUE;
+    *amount = (GT_U32)(opData.ptpData & 0x7FF);
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*expired = (opData.ptpData & 0x8)?GT_FALSE:GT_TRUE;
+    *expired = (opData.ptpData & 0x8)?GT_FALSE:GT_TRUE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2627,99 +2891,99 @@ GT_STATUS gtaiGetTimeIncDec
 * gtaiSetTimeInc
 *
 * DESCRIPTION:
-* 		This routine enables time increment by the specifed time increment amount.
-*		The amount specifies the number of units of PTP Global Time that need to be 
-*		incremented. This is used for adjusting the PTP Global Time counter value by
-*		a certain amount.
-*		Increment occurs just once.
+*         This routine enables time increment by the specifed time increment amount.
+*        The amount specifies the number of units of PTP Global Time that need to be 
+*        incremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Increment occurs just once.
 *
 * INPUTS:
-*		amount	- time increment amount (0 ~ 0x7FF)
+*        amount    - time increment amount (0 ~ 0x7FF)
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gtaiSetTimeInc
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		amount
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetTimeInc Called.\n"));
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 #endif
 
-	/* set TimeIncAmt */
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 5;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= 0xF000;
-	opData.ptpData |= amount;
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	/* set TimeIncEn */
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	opData.ptpData |= 0x8;
+    opData.ptpData |= 0x8;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2727,100 +2991,100 @@ GT_STATUS gtaiSetTimeInc
 * gtaiSetTimeDec
 *
 * DESCRIPTION:
-* 		This routine enables time decrement by the specifed time decrement amount.
-*		The amount specifies the number of units of PTP Global Time that need to be 
-*		decremented. This is used for adjusting the PTP Global Time counter value by
-*		a certain amount.
-*		Decrement occurs just once.
+*         This routine enables time decrement by the specifed time decrement amount.
+*        The amount specifies the number of units of PTP Global Time that need to be 
+*        decremented. This is used for adjusting the PTP Global Time counter value by
+*        a certain amount.
+*        Decrement occurs just once.
 *
 * INPUTS:
-*		amount	- time decrement amount (0 ~ 0x7FF)
+*        amount    - time decrement amount (0 ~ 0x7FF)
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gtaiSetTimeDec
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		amount
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gtaiSetTimeInc Called.\n"));
+    DBG_INFO(("gtaiSetTimeInc Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* set TimeIncAmt */
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    /* set TimeIncAmt */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 5;
+    opData.ptpAddr = 5;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= 0xF000;
-	opData.ptpData |= amount;
-	opData.ptpData |= 0x800;	/* decrement */
+    opData.ptpData &= 0xF000;
+    opData.ptpData |= amount;
+    opData.ptpData |= 0x800;    /* decrement */
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	/* set TimeIncEn */
-	opData.ptpBlock = 0x0;	/* PTP register space */
+    /* set TimeIncEn */
+    opData.ptpBlock = 0x0;    /* PTP register space */
 
-	opData.ptpPort = 0xE;	/* TAI register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData |= 0x8;
+    opData.ptpData |= 0x8;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2828,119 +3092,119 @@ GT_STATUS gtaiSetTimeDec
 * gavbGetPriority
 *
 * DESCRIPTION:
-*		Priority overwrite.
-*		Supported priority type is defined as GT_AVB_PRI_TYPE.
-*		Priority is either 3 bits or 2 bits depending on priority type.
-*			GT_AVB_HI_FPRI		- priority is 0 ~ 7
-*			GT_AVB_HI_QPRI		- priority is 0 ~ 3
-*			GT_AVB_LO_FPRI		- priority is 0 ~ 7
-*			GT_AVB_LO_QPRI		- priority is 0 ~ 3
-*			GT_LEGACY_HI_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_HI_QPRI	- priority is 0 ~ 3
-*			GT_LEGACY_LO_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_LO_QPRI	- priority is 0 ~ 3
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
 *
 * INPUTS:
-* 		priType	- GT_AVB_PRI_TYPE
+*         priType    - GT_AVB_PRI_TYPE
 *
 * OUTPUTS:
-*		pri	- priority
+*        pri    - priority
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetPriority
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_PRI_TYPE		priType,
-	OUT GT_U32		*pri
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    OUT GT_U32        *pri
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U16		mask, reg, bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        mask, reg, bitPos;
 
-	DBG_INFO(("gavbGetPriority Called.\n"));
+    DBG_INFO(("gavbGetPriority Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	switch (priType)
-	{
-		case GT_AVB_HI_FPRI:
-			mask = 0x7;
-			reg = 0;
-			bitPos = 12;
-			break;
-		case GT_AVB_HI_QPRI:
-			mask = 0x3;
-			reg = 0;
-			bitPos = 8;
-			break;
-		case GT_AVB_LO_FPRI:
-			mask = 0x7;
-			reg = 0;
-			bitPos = 4;
-			break;
-		case GT_AVB_LO_QPRI:
-			mask = 0x3;
-			reg = 0;
-			bitPos = 0;
-			break;
-		case GT_LEGACY_HI_FPRI:
-			mask = 0x7;
-			reg = 4;
-			bitPos = 12;
-			break;
-		case GT_LEGACY_HI_QPRI:
-			mask = 0x3;
-			reg = 4;
-			bitPos = 8;
-			break;
-		case GT_LEGACY_LO_FPRI:
-			mask = 0x7;
-			reg = 4;
-			bitPos = 4;
-			break;
-		case GT_LEGACY_LO_QPRI:
-			mask = 0x3;
-			reg = 4;
-			bitPos = 0;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (priType)
+    {
+        case GT_AVB_HI_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 12;
+            break;
+        case GT_AVB_HI_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 8;
+            break;
+        case GT_AVB_LO_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 4;
+            break;
+        case GT_AVB_LO_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 0;
+            break;
+        case GT_LEGACY_HI_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 12;
+            break;
+        case GT_LEGACY_HI_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 8;
+            break;
+        case GT_LEGACY_LO_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 4;
+            break;
+        case GT_LEGACY_LO_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = reg;
+    opData.ptpAddr = reg;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	*pri = (GT_U32)(opData.ptpData >> bitPos) & mask;
+    *pri = (GT_U32)(opData.ptpData >> bitPos) & mask;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -2948,134 +3212,134 @@ GT_STATUS gavbGetPriority
 * gavbSetPriority
 *
 * DESCRIPTION:
-*		Priority overwrite.
-*		Supported priority type is defined as GT_AVB_PRI_TYPE.
-*		Priority is either 3 bits or 2 bits depending on priority type.
-*			GT_AVB_HI_FPRI		- priority is 0 ~ 7
-*			GT_AVB_HI_QPRI		- priority is 0 ~ 3
-*			GT_AVB_LO_FPRI		- priority is 0 ~ 7
-*			GT_AVB_LO_QPRI		- priority is 0 ~ 3
-*			GT_LEGACY_HI_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_HI_QPRI	- priority is 0 ~ 3
-*			GT_LEGACY_LO_FPRI	- priority is 0 ~ 7
-*			GT_LEGACY_LO_QPRI	- priority is 0 ~ 3
+*        Priority overwrite.
+*        Supported priority type is defined as GT_AVB_PRI_TYPE.
+*        Priority is either 3 bits or 2 bits depending on priority type.
+*            GT_AVB_HI_FPRI        - priority is 0 ~ 7
+*            GT_AVB_HI_QPRI        - priority is 0 ~ 3
+*            GT_AVB_LO_FPRI        - priority is 0 ~ 7
+*            GT_AVB_LO_QPRI        - priority is 0 ~ 3
+*            GT_LEGACY_HI_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_HI_QPRI    - priority is 0 ~ 3
+*            GT_LEGACY_LO_FPRI    - priority is 0 ~ 7
+*            GT_LEGACY_LO_QPRI    - priority is 0 ~ 3
 *
 * INPUTS:
-* 		priType	- GT_AVB_PRI_TYPE
-*		pri	- priority
+*         priType    - GT_AVB_PRI_TYPE
+*        pri    - priority
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetPriority
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_PRI_TYPE		priType,
-	IN  GT_U32		pri
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_PRI_TYPE        priType,
+    IN  GT_U32        pri
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U16		mask, reg, bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        mask, reg, bitPos;
 
-	DBG_INFO(("gavbSetPriority Called.\n"));
+    DBG_INFO(("gavbSetPriority Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	switch (priType)
-	{
-		case GT_AVB_HI_FPRI:
-			mask = 0x7;
-			reg = 0;
-			bitPos = 12;
-			break;
-		case GT_AVB_HI_QPRI:
-			mask = 0x3;
-			reg = 0;
-			bitPos = 8;
-			break;
-		case GT_AVB_LO_FPRI:
-			mask = 0x7;
-			reg = 0;
-			bitPos = 4;
-			break;
-		case GT_AVB_LO_QPRI:
-			mask = 0x3;
-			reg = 0;
-			bitPos = 0;
-			break;
-		case GT_LEGACY_HI_FPRI:
-			mask = 0x7;
-			reg = 4;
-			bitPos = 12;
-			break;
-		case GT_LEGACY_HI_QPRI:
-			mask = 0x3;
-			reg = 4;
-			bitPos = 8;
-			break;
-		case GT_LEGACY_LO_FPRI:
-			mask = 0x7;
-			reg = 4;
-			bitPos = 4;
-			break;
-		case GT_LEGACY_LO_QPRI:
-			mask = 0x3;
-			reg = 4;
-			bitPos = 0;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (priType)
+    {
+        case GT_AVB_HI_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 12;
+            break;
+        case GT_AVB_HI_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 8;
+            break;
+        case GT_AVB_LO_FPRI:
+            mask = 0x7;
+            reg = 0;
+            bitPos = 4;
+            break;
+        case GT_AVB_LO_QPRI:
+            mask = 0x3;
+            reg = 0;
+            bitPos = 0;
+            break;
+        case GT_LEGACY_HI_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 12;
+            break;
+        case GT_LEGACY_HI_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 8;
+            break;
+        case GT_LEGACY_LO_FPRI:
+            mask = 0x7;
+            reg = 4;
+            bitPos = 4;
+            break;
+        case GT_LEGACY_LO_QPRI:
+            mask = 0x3;
+            reg = 4;
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	if (pri & (~mask))
-	{
-		return GT_BAD_PARAM;
-	}
+    if (pri & (~mask))
+    {
+        return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = reg;
+    opData.ptpAddr = reg;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(mask << bitPos);
-	opData.ptpData |= (pri << bitPos);
+    opData.ptpData &= ~(mask << bitPos);
+    opData.ptpData |= (pri << bitPos);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed writing TAI register.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3084,67 +3348,67 @@ GT_STATUS gavbSetPriority
 * gavbGetAVBHiLimit
 *
 * DESCRIPTION:
-*		AVB Hi Frame Limit.
-*		When these bits are zero, normal frame processing occurs. 
-*		When it's non-zero, they are used to define the maximum frame size allowed
-*		for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
-*		that are over this size limit are filtered. The only exception to this 
-*		is non-AVB frames that get their QPriAvb assigned by the Priority Override 
-*		Table
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs. 
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this 
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override 
+*        Table
 *
 * INPUTS:
-* 		None
+*         None
 *
 * OUTPUTS:
-*		limit	- Hi Frame Limit
+*        limit    - Hi Frame Limit
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAVBHiLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*limit
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *limit
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbGetAVBHiLimit Called.\n"));
+    DBG_INFO(("gavbGetAVBHiLimit Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 8;
+    opData.ptpAddr = 8;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	*limit = (GT_U32)(opData.ptpData & 0x7FF);
+    *limit = (GT_U32)(opData.ptpData & 0x7FF);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3152,67 +3416,67 @@ GT_STATUS gavbGetAVBHiLimit
 * gavbSetAVBHiLimit
 *
 * DESCRIPTION:
-*		AVB Hi Frame Limit.
-*		When these bits are zero, normal frame processing occurs. 
-*		When it's non-zero, they are used to define the maximum frame size allowed
-*		for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
-*		that are over this size limit are filtered. The only exception to this 
-*		is non-AVB frames that get their QPriAvb assigned by the Priority Override 
-*		Table
+*        AVB Hi Frame Limit.
+*        When these bits are zero, normal frame processing occurs. 
+*        When it's non-zero, they are used to define the maximum frame size allowed
+*        for AVB frames that can be placed into the GT_AVB_HI_QPRI queue. Frames
+*        that are over this size limit are filtered. The only exception to this 
+*        is non-AVB frames that get their QPriAvb assigned by the Priority Override 
+*        Table
 *
 * INPUTS:
-*		limit	- Hi Frame Limit
+*        limit    - Hi Frame Limit
 *
 * OUTPUTS:
-* 		None
+*         None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAVBHiLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        limit
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbSetAVBHiLimit Called.\n"));
+    DBG_INFO(("gavbSetAVBHiLimit Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 8;
-	opData.ptpData = (GT_U16)limit;
+    opData.ptpAddr = 8;
+    opData.ptpData = (GT_U16)limit;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3220,65 +3484,65 @@ GT_STATUS gavbSetAVBHiLimit
 * gavbGetPtpExtClk
 *
 * DESCRIPTION:
-*		PTP external clock select.
-*		When this bit is cleared to a zero, the PTP core gets its clock from 
-*		an internal 125MHz clock based on the device's XTAL_IN input. 
-*		When this bit is set to a one, the PTP core gets its clock from the device's
-*		PTP_EXTCLK pin.
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from 
+*        an internal 125MHz clock based on the device's XTAL_IN input. 
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
 *
 * INPUTS:
-* 		None
+*         None
 *
 * OUTPUTS:
-*		extClk	- GT_TRUE if external clock is selected, GT_FALSE otherwise
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetPtpExtClk
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*extClk
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *extClk
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbGetPtpExtClk Called.\n"));
+    DBG_INFO(("gavbGetPtpExtClk Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0xB;
+    opData.ptpAddr = 0xB;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	*extClk = (GT_U32)(opData.ptpData >> 15) & 0x1;
+    *extClk = (GT_U32)(opData.ptpData >> 15) & 0x1;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3287,76 +3551,76 @@ GT_STATUS gavbGetPtpExtClk
 * gavbSetPtpExtClk
 *
 * DESCRIPTION:
-*		PTP external clock select.
-*		When this bit is cleared to a zero, the PTP core gets its clock from 
-*		an internal 125MHz clock based on the device's XTAL_IN input. 
-*		When this bit is set to a one, the PTP core gets its clock from the device's
-*		PTP_EXTCLK pin.
+*        PTP external clock select.
+*        When this bit is cleared to a zero, the PTP core gets its clock from 
+*        an internal 125MHz clock based on the device's XTAL_IN input. 
+*        When this bit is set to a one, the PTP core gets its clock from the device's
+*        PTP_EXTCLK pin.
 *
 * INPUTS:
-*		extClk	- GT_TRUE if external clock is selected, GT_FALSE otherwise
+*        extClk    - GT_TRUE if external clock is selected, GT_FALSE otherwise
 *
 * OUTPUTS:
-* 		None
+*         None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetPtpExtClk
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		extClk
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        extClk
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbSetPtpExtClk Called.\n"));
+    DBG_INFO(("gavbSetPtpExtClk Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0xB;
+    opData.ptpAddr = 0xB;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	if(extClk)
-		opData.ptpData |= 0x8000;
-	else
-		opData.ptpData &= ~0x8000;
+    if(extClk)
+        opData.ptpData |= 0x8000;
+    else
+        opData.ptpData &= ~0x8000;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3364,77 +3628,82 @@ GT_STATUS gavbSetPtpExtClk
 * gavbGetRecClkSel
 *
 * DESCRIPTION:
-*		Synchronous Ethernet Recovered Clock Select.
-*		This field indicate the internal PHY number whose recovered clock will
-*		be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
 *
 * INPUTS:
-*		recClk	- GT_AVB_RECOVERED_CLOCK type
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
 *
 * OUTPUTS:
-*		clkSel	- recovered clock selection
+*        clkSel    - recovered clock selection
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetRecClkSel
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_RECOVERED_CLOCK	recClk,
-	OUT GT_U32		*clkSel
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    OUT GT_U32        *clkSel
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U16		bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        bitPos;
 
-	DBG_INFO(("gavbGetRecClkSel Called.\n"));
+    DBG_INFO(("gavbGetRecClkSel Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	switch (recClk)
-	{
-		case GT_PRIMARY_RECOVERED_CLOCK:
-			bitPos = 0;
-			break;
-		case GT_SECONDARY_RECOVERED_CLOCK:
-			bitPos = 4;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (recClk)
+    {
+        case GT_PRIMARY_RECOVERED_CLOCK:
+            bitPos = 0;
+            break;
+        case GT_SECONDARY_RECOVERED_CLOCK:
+            bitPos = 4;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0xB;
+    opData.ptpAddr = 0xB;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	*clkSel = (GT_U32)(opData.ptpData >> bitPos) & 0x7;
+    *clkSel = (GT_U32)(opData.ptpData >> bitPos) & 0x7;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3442,90 +3711,95 @@ GT_STATUS gavbGetRecClkSel
 * gavbSetRecClkSel
 *
 * DESCRIPTION:
-*		Synchronous Ethernet Recovered Clock Select.
-*		This field indicate the internal PHY number whose recovered clock will
-*		be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
+*        Synchronous Ethernet Recovered Clock Select.
+*        This field indicate the internal PHY number whose recovered clock will
+*        be presented on the SE_RCLK0 or SE_RCLK1 pin depending on the recClk selection.
 *
 * INPUTS:
-*		recClk	- GT_AVB_RECOVERED_CLOCK type
-*		clkSel	- recovered clock selection (should be less than 8)
+*        recClk    - GT_AVB_RECOVERED_CLOCK type
+*        clkSel    - recovered clock selection (should be less than 8)
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetRecClkSel
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_AVB_RECOVERED_CLOCK	recClk,
-	IN  GT_U32		clkSel
+    IN  GT_QD_DEV     *dev,
+    IN  GT_AVB_RECOVERED_CLOCK    recClk,
+    IN  GT_U32        clkSel
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U16		bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U16        bitPos;
 
-	DBG_INFO(("gavbSetRecClkSel Called.\n"));
+    DBG_INFO(("gavbSetRecClkSel Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY_RECOVER_CLK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	if (clkSel > 0x7)
-		return GT_BAD_PARAM;
+    if (clkSel > 0x7)
+        return GT_BAD_PARAM;
 
-	switch (recClk)
-	{
-		case GT_PRIMARY_RECOVERED_CLOCK:
-			bitPos = 0;
-			break;
-		case GT_SECONDARY_RECOVERED_CLOCK:
-			bitPos = 4;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (recClk)
+    {
+        case GT_PRIMARY_RECOVERED_CLOCK:
+            bitPos = 0;
+            break;
+        case GT_SECONDARY_RECOVERED_CLOCK:
+            bitPos = 4;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0xB;
+    opData.ptpAddr = 0xB;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(0x7 << bitPos);
-	opData.ptpData |= clkSel << bitPos;
+    opData.ptpData &= ~(0x7 << bitPos);
+    opData.ptpData |= clkSel << bitPos;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3533,150 +3807,150 @@ GT_STATUS gavbSetRecClkSel
 * gavbGetAvbOuiBytes
 *
 * DESCRIPTION:
-*		AVB OUI Limit Filter bytes(0 ~ 2).
-*		When all three of the AvbOui Bytes are zero, normal frame processing occurs.
-*		When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
-*		destination address whose 1st three bytes of the DA match these three 
-*		AvbOui Bytes or the frame will be filtered.
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three 
+*        AvbOui Bytes or the frame will be filtered.
 *
 * INPUTS:
-* 		None
+*         None
 *
 * OUTPUTS:
-*		ouiBytes	- 3 bytes of OUI field in Ethernet address format
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAvbOuiBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*obiBytes
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *obiBytes
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbGetAvbOuiBytes Called.\n"));
+    DBG_INFO(("gavbGetAvbOuiBytes Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_READ_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0xC;
+    opData.ptpAddr = 0xC;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	obiBytes[0] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
-	obiBytes[1] = (GT_U8)(opData.ptpData & 0xFF);
+    obiBytes[0] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
+    obiBytes[1] = (GT_U8)(opData.ptpData & 0xFF);
 
-	opData.ptpAddr = 0xD;
+    opData.ptpAddr = 0xD;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	obiBytes[2] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
+    obiBytes[2] = (GT_U8)((opData.ptpData >> 8) & 0xFF);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gavbSetAvbOuiBytes
 *
 * DESCRIPTION:
-*		AVB OUI Limit Filter bytes(0 ~ 2).
-*		When all three of the AvbOui Bytes are zero, normal frame processing occurs.
-*		When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
-*		destination address whose 1st three bytes of the DA match these three 
-*		AvbOui Bytes or the frame will be filtered.
+*        AVB OUI Limit Filter bytes(0 ~ 2).
+*        When all three of the AvbOui Bytes are zero, normal frame processing occurs.
+*        When any of the three AvbOui Bytes are non-zero, all AVB frames must have a
+*        destination address whose 1st three bytes of the DA match these three 
+*        AvbOui Bytes or the frame will be filtered.
 *
 * INPUTS:
-*		ouiBytes	- 3 bytes of OUI field in Ethernet address format
+*        ouiBytes    - 3 bytes of OUI field in Ethernet address format
 *
 * OUTPUTS:
-* 		None
+*         None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAvbOuiBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		*obiBytes
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        *obiBytes
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gavbSetAvbOuiBytes Called.\n"));
+    DBG_INFO(("gavbSetAvbOuiBytes Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = 0xF;	/* Global register */
-	op = PTP_WRITE_DATA;
+    opData.ptpPort = 0xF;    /* Global register */
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0xC;
+    opData.ptpAddr = 0xC;
 
-	opData.ptpData = (obiBytes[0] << 8) | obiBytes[1];
+    opData.ptpData = (obiBytes[0] << 8) | obiBytes[1];
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpAddr = 0xD;
-	opData.ptpData = (obiBytes[2] << 8);
+    opData.ptpAddr = 0xD;
+    opData.ptpData = (obiBytes[2] << 8);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3684,68 +3958,68 @@ GT_STATUS gavbSetAvbOuiBytes
 * gavbGetAvbMode
 *
 * DESCRIPTION:
-*		Port's AVB Mode.
+*        Port's AVB Mode.
 *
 * INPUTS:
-*		port	- the logical port number
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		mode	- GT_AVB_MODE type
+*        mode    - GT_AVB_MODE type
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAvbMode
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_AVB_MODE	*mode
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_AVB_MODE    *mode
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbGetAvbMode Called.\n"));
+    DBG_INFO(("gavbGetAvbMode Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	*mode = (GT_AVB_MODE)((opData.ptpData >> 14) & 0x3);
+    *mode = (GT_AVB_MODE)((opData.ptpData >> 14) & 0x3);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3753,151 +4027,151 @@ GT_STATUS gavbGetAvbMode
 * gavbSetAvbMode
 *
 * DESCRIPTION:
-*		Port's AVB Mode.
+*        Port's AVB Mode.
 *
 * INPUTS:
-*		port	- the logical port number
-*		mode	- GT_AVB_MODE type
+*        port    - the logical port number
+*        mode    - GT_AVB_MODE type
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAvbMode
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_AVB_MODE	mode
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_AVB_MODE    mode
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbSetAvbMode Called.\n"));
+    DBG_INFO(("gavbSetAvbMode Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(0x3 << 14);
-	opData.ptpData |= (mode << 14);
+    opData.ptpData &= ~(0x3 << 14);
+    opData.ptpData |= (mode << 14);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading DisPTP.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading DisPTP.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gavbGetAvbOverride
 *
 * DESCRIPTION:
-*		AVB Override.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the egress portion of this port is considered AVB even if 
-*		the ingress portion is not.
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if 
+*        the ingress portion is not.
 *
 * INPUTS:
-*		port	- the logical port number
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAvbOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbGetAvbOverride Called.\n"));
+    DBG_INFO(("gavbGetAvbOverride Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	*en = (opData.ptpData >> 13) & 0x1;
+    *en = (opData.ptpData >> 13) & 0x1;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3905,85 +4179,85 @@ GT_STATUS gavbGetAvbOverride
 * gavbSetAvbOverride
 *
 * DESCRIPTION:
-*		AVB Override.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the egress portion of this port is considered AVB even if 
-*		the ingress portion is not.
+*        AVB Override.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the egress portion of this port is considered AVB even if 
+*        the ingress portion is not.
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAvbOverride
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbSetAvbOverride Called.\n"));
+    DBG_INFO(("gavbSetAvbOverride Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	if (en)
-		opData.ptpData |= (0x1 << 13);
-	else
-		opData.ptpData &= ~(0x1 << 13);
+    if (en)
+        opData.ptpData |= (0x1 << 13);
+    else
+        opData.ptpData &= ~(0x1 << 13);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -3991,70 +4265,70 @@ GT_STATUS gavbSetAvbOverride
 * gavbGetFilterBadAvb
 *
 * DESCRIPTION:
-*		Filter Bad AVB frames.
-*		When disabled, normal frame processing occurs.
-*		When enabled, frames that are considered Bad AVB frames are filtered.
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
 *
 * INPUTS:
-*		port	- the logical port number
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetFilterBadAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbGetFilterBadAvb Called.\n"));
+    DBG_INFO(("gavbGetFilterBadAvb Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	*en = (opData.ptpData >> 12) & 0x1;
+    *en = (opData.ptpData >> 12) & 0x1;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -4062,84 +4336,84 @@ GT_STATUS gavbGetFilterBadAvb
 * gavbSetFilterBadAvb
 *
 * DESCRIPTION:
-*		Filter Bad AVB frames.
-*		When disabled, normal frame processing occurs.
-*		When enabled, frames that are considered Bad AVB frames are filtered.
+*        Filter Bad AVB frames.
+*        When disabled, normal frame processing occurs.
+*        When enabled, frames that are considered Bad AVB frames are filtered.
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetFilterBadAvb
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbSetFilterBadAvb Called.\n"));
+    DBG_INFO(("gavbSetFilterBadAvb Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	if (en)
-		opData.ptpData |= (0x1 << 12);
-	else
-		opData.ptpData &= ~(0x1 << 12);
+    if (en)
+        opData.ptpData |= (0x1 << 12);
+    else
+        opData.ptpData &= ~(0x1 << 12);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -4147,73 +4421,73 @@ GT_STATUS gavbSetFilterBadAvb
 * gavbGetAvbTunnel
 *
 * DESCRIPTION:
-*		AVB Tunnel.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
-*		masking and the Trunk Masking is bypassed for any frame entering this port
-*		that is considered AVB by DA. This includes unicast as well as multicast
-*		frame
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
 *
 * INPUTS:
-*		port	- the logical port number
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAvbTunnel
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gavbGetAvbTunnel Called.\n"));
+    DBG_INFO(("gavbGetAvbTunnel Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	*en = (opData.ptpData >> 11) & 0x1;
+    *en = (opData.ptpData >> 11) & 0x1;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -4221,87 +4495,87 @@ GT_STATUS gavbGetAvbTunnel
 * gavbSetAvbTunnel
 *
 * DESCRIPTION:
-*		AVB Tunnel.
-*		When disabled, normal frame processing occurs.
-*		When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
-*		masking and the Trunk Masking is bypassed for any frame entering this port
-*		that is considered AVB by DA. This includes unicast as well as multicast
-*		frame
+*        AVB Tunnel.
+*        When disabled, normal frame processing occurs.
+*        When enabled, the port based VLAN Table masking, 802.1Q VLAN membership 
+*        masking and the Trunk Masking is bypassed for any frame entering this port
+*        that is considered AVB by DA. This includes unicast as well as multicast
+*        frame
 *
 * INPUTS:
-*		port	- the logical port number
-*		en		- GT_TRUE to enable, GT_FALSE otherwise
+*        port    - the logical port number
+*        en        - GT_TRUE to enable, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAvbTunnel
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8          hwPort;         /* the physical port number     */
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8          hwPort;         /* the physical port number     */
 
-	DBG_INFO(("GT_STATUS gavbGetAvbTunnel Called.\n"));
+    DBG_INFO(("GT_STATUS gavbGetAvbTunnel Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	if (en)
-		opData.ptpData |= (0x1 << 11);
-	else
-		opData.ptpData &= ~(0x1 << 11);
+    if (en)
+        opData.ptpData |= (0x1 << 11);
+    else
+        opData.ptpData &= ~(0x1 << 11);
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -4309,180 +4583,180 @@ GT_STATUS gavbSetAvbTunnel
 * gavbGetAvbFramePolicy
 *
 * DESCRIPTION:
-*		AVB Hi or Lo frame policy mapping.
-*		Supported policies are defined in GT_AVB_FRAME_POLICY.
-*			
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
+*            
 * INPUTS:
-*		port	- the logical port number
-*		fType	- GT_AVB_FRAME_TYPE 
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE 
 *
 * OUTPUTS:
-*		policy	- GT_AVB_FRAME_POLICY
+*        policy    - GT_AVB_FRAME_POLICY
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbGetAvbFramePolicy
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN	GT_AVB_FRAME_TYPE	fType,
-	OUT GT_AVB_FRAME_POLICY		*policy
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    OUT GT_AVB_FRAME_POLICY        *policy
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8 		hwPort;         /* the physical port number     */
-	GT_U16		bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8         hwPort;         /* the physical port number     */
+    GT_U16        bitPos;
 
-	DBG_INFO(("gavbGetAvbFramePolicy Called.\n"));
+    DBG_INFO(("gavbGetAvbFramePolicy Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	switch (fType)
-	{
-		case AVB_HI_FRAME:
-			bitPos = 2;
-			break;
-		case AVB_LO_FRAME:
-			bitPos = 0;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (fType)
+    {
+        case AVB_HI_FRAME:
+            bitPos = 2;
+            break;
+        case AVB_LO_FRAME:
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	*policy = (opData.ptpData >> bitPos) & 0x3;
+    *policy = (opData.ptpData >> bitPos) & 0x3;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gavbSetAvbFramePolicy
 *
 * DESCRIPTION:
-*		AVB Hi or Lo frame policy mapping.
-*		Supported policies are defined in GT_AVB_FRAME_POLICY.
+*        AVB Hi or Lo frame policy mapping.
+*        Supported policies are defined in GT_AVB_FRAME_POLICY.
 *
 * INPUTS:
-*		port	- the logical port number
-*		fType	- GT_AVB_FRAME_TYPE 
-*		policy	- GT_AVB_FRAME_POLICY
+*        port    - the logical port number
+*        fType    - GT_AVB_FRAME_TYPE 
+*        policy    - GT_AVB_FRAME_POLICY
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-* 		GT_OK      - on success
-* 		GT_FAIL    - on error
-* 		GT_NOT_SUPPORTED - if current device does not support this feature.
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-* 		None
+*         None
 *
 *******************************************************************************/
 GT_STATUS gavbSetAvbFramePolicy
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN	GT_AVB_FRAME_TYPE	fType,
-	IN  GT_AVB_FRAME_POLICY		policy
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN    GT_AVB_FRAME_TYPE    fType,
+    IN  GT_AVB_FRAME_POLICY        policy
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U8 		hwPort;         /* the physical port number     */
-	GT_U16		bitPos;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U8         hwPort;         /* the physical port number     */
+    GT_U16        bitPos;
 
-	DBG_INFO(("gavbSetAvbFramePolicy Called.\n"));
+    DBG_INFO(("gavbSetAvbFramePolicy Called.\n"));
 
 #ifndef CONFIG_AVB_FPGA
-	/* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AVB_POLICY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 #endif
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort == GT_INVALID_PORT)
-		return GT_BAD_PARAM;
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+    if (hwPort == GT_INVALID_PORT)
+        return GT_BAD_PARAM;
 
-	switch (fType)
-	{
-		case AVB_HI_FRAME:
-			bitPos = 2;
-			break;
-		case AVB_LO_FRAME:
-			bitPos = 0;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (fType)
+    {
+        case AVB_HI_FRAME:
+            bitPos = 2;
+            break;
+        case AVB_LO_FRAME:
+            bitPos = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	opData.ptpBlock = 0x1;	/* AVB Policy register space */
+    opData.ptpBlock = 0x1;    /* AVB Policy register space */
 
-	opData.ptpPort = (GT_U16)hwPort;
-	op = PTP_READ_DATA;
+    opData.ptpPort = (GT_U16)hwPort;
+    op = PTP_READ_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	opData.ptpData &= ~(0x3 << bitPos);
-	opData.ptpData |= (policy & 0x3) << bitPos;
+    opData.ptpData &= ~(0x3 << bitPos);
+    opData.ptpData |= (policy & 0x3) << bitPos;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpAddr = 0;
+    opData.ptpAddr = 0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed AVB operation.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed AVB operation.\n"));
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -4513,294 +4787,659 @@ GT_STATUS gavbSetAvbFramePolicy
 *******************************************************************************/
 static GT_STATUS ptpOperationPerform
 (
-    IN    GT_QD_DEV 			*dev,
-    IN    GT_PTP_OPERATION		ptpOp,
-    INOUT GT_PTP_OP_DATA		*opData
+    IN    GT_QD_DEV             *dev,
+    IN    GT_PTP_OPERATION        ptpOp,
+    INOUT GT_PTP_OP_DATA        *opData
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
-	GT_U32 			i;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U32             i;
 
 #ifdef CONFIG_AVB_FPGA
-	GT_U32 			tmpData;
+    GT_U32             tmpData;
 #endif
 
+
     gtSemTake(dev,dev->ptpRegsSem,OS_WAIT_FOREVER);
 
     /* Wait until the ptp in ready. */
-    data = 1;
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data = 1;
     while(data == 1)
     {
-#ifndef CONFIG_AVB_FPGA
         retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
-#else
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
+#endif 
+#else /* CONFIG_AVB_FPGA */ 
+    {
+    GT_U16 data = 1;
+    while(data == 1)
+    {
         retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
-		data = (GT_U16)tmpData;
-		data = (data >> 15) & 0x1;
-#endif
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
         if(retVal != GT_OK)
         {
             gtSemGive(dev,dev->ptpRegsSem);
             return retVal;
         }
     }
+    }
+#endif 
 
     /* Set the PTP Operation register */
-	switch (ptpOp)
-	{
-		case PTP_WRITE_DATA:
-			data = (GT_U16)opData->ptpData;
-#ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,data);
-#else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,tmpData);
-#endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
-					(opData->ptpPort << 8)	|
-					(opData->ptpBlock << 5)	|
-					(opData->ptpAddr & 0x1F));
-#ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
-#else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
-#endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-			break;
-
-		case PTP_READ_DATA:
-			data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) | 
-					(opData->ptpPort << 8)	|
-					(opData->ptpBlock << 5)	|
-					(opData->ptpAddr & 0x1F));
+    switch (ptpOp)
+    {
+        case PTP_WRITE_DATA:
 #ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)opData->ptpData;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
 #else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
 #endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
-#ifndef CONFIG_AVB_FPGA
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
-#else
-        		retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
-				data = (GT_U32)tmpData;
-				data = (data >> 15) & 0x1;
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)opData->ptpData;
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
 #endif
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->ptpRegsSem);
-		            return retVal;
-        		}
-		    }
+            break;
 
+        case PTP_READ_DATA:
 #ifndef CONFIG_AVB_FPGA
-			retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
-#else
-	        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
-			data = (GT_U32)tmpData;
-#endif
-			opData->ptpData = (GT_U32)data;
-		    gtSemGive(dev,dev->ptpRegsSem);
-		    return retVal;
-
-		case PTP_READ_MULTIPLE_DATA:
-			data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
-					(opData->ptpPort << 8)	|
-					(opData->ptpBlock << 5)	|
-					(opData->ptpAddr & 0x1F));
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
 #ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
 #else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+              regAccess.rw_reg_list[0].addr = AVB_SMI_ADDR;
 #endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
 #ifndef CONFIG_AVB_FPGA
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
 #else
-        		retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
-				data = (GT_U32)tmpData;
-				data = (data >> 15) & 0x1;
+              regAccess.rw_reg_list[1].addr = AVB_SMI_ADDR;
 #endif
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->ptpRegsSem);
-		            return retVal;
-        		}
-		    }
-
-			for(i=0; i<opData->nData; i++)
-			{
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
 #ifndef CONFIG_AVB_FPGA
-				retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
 #else
-		        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
-				data = (GT_U32)tmpData;
+              regAccess.rw_reg_list[2].addr = AVB_SMI_ADDR;
 #endif
-				opData->ptpMultiData[i] = (GT_U32)data;
-	    	    if(retVal != GT_OK)
-    	    	{
-        	    	gtSemGive(dev,dev->ptpRegsSem);
-	            	return retVal;
-		        }
-			}
-
-		    gtSemGive(dev,dev->ptpRegsSem);
-		    return retVal;
-
-		case PTP_READ_TIMESTAMP_DATA:
-			data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
-					(opData->ptpPort << 8)	|
-					(opData->ptpBlock << 5)	|
-					(opData->ptpAddr & 0x1F));
-#ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpData = (GT_U32)    regAccess.rw_reg_list[2].data;
+            }
 #else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpData = (GT_U32)data;
+    }
 #endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-		    data = 1;
-		    while(data == 1)
-		    {
-#ifndef CONFIG_AVB_FPGA
-		        retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
-#else
-        		retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
-				data = (GT_U32)tmpData;
-				data = (data >> 15) & 0x1;
+#else /*CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpData = (GT_U32)data;
+    }
 #endif
-		        if(retVal != GT_OK)
-		        {
-		            gtSemGive(dev,dev->ptpRegsSem);
-		            return retVal;
-        		}
-		    }
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
 
+        case PTP_READ_MULTIPLE_DATA:
 #ifndef CONFIG_AVB_FPGA
-			retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              for(i=0; i<opData->nData; i++)
+              {
+                regAccess.rw_reg_list[2+i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[2+i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[2+i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[2+i].data = 0;
+              }
+              regAccess.entries = 2+i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<opData->nData; i++)
+              {
+                opData->ptpMultiData[i] = (GT_U32)    regAccess.rw_reg_list[2+i].data;
+              }
+            }
 #else
-	        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
-			data = (GT_U32)tmpData;
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
 #endif
-			opData->ptpMultiData[0] = (GT_U32)data;
-    	    if(retVal != GT_OK)
-   	    	{
-       	    	gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-			if (!(data & 0x1))
-			{
-				/* valid bit is not set */
-       	    	gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-			}
-
-			for(i=1; i<opData->nData; i++)
-			{
-#ifndef CONFIG_AVB_FPGA
-				retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
-#else
-		        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
-				data = (GT_U32)tmpData;
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            for(i=0; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+    }
 #endif
-				opData->ptpMultiData[i] = (GT_U32)data;
-	    	    if(retVal != GT_OK)
-    	    	{
-        	    	gtSemGive(dev,dev->ptpRegsSem);
-	            	return retVal;
-		        }
-			}
 
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+
+        case PTP_READ_TIMESTAMP_DATA:
 #ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,0);
+#ifdef GT_RMGMT_ACCESS
+            {
+              HW_DEV_REG_ACCESS regAccess;
+
+              regAccess.entries = 3;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[0].data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              regAccess.rw_reg_list[1].cmd = HW_REG_WAIT_TILL_0;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = 15;
+              regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+              regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[2].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[2].data = 0;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              opData->ptpMultiData[0] = (GT_U32)    regAccess.rw_reg_list[2].data;
+
+              if (!(opData->ptpMultiData[0] & 0x1))
+              {
+                /* valid bit is not set */
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+              }
+
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                regAccess.rw_reg_list[i].cmd = HW_REG_READ;
+                regAccess.rw_reg_list[i].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+                regAccess.rw_reg_list[i].reg = QD_REG_PTP_DATA;
+                regAccess.rw_reg_list[i].data = 0;
+              }
+              regAccess.entries = i;
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+              for(i=0; i<(opData->nData-1); i++)
+              {
+                opData->ptpMultiData[i+1] = (GT_U32)    regAccess.rw_reg_list[i].data;
+              }
+
+
+              regAccess.entries = 2;
+
+              regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[0].reg = QD_REG_PTP_DATA;
+              regAccess.rw_reg_list[0].data = (GT_U16)0;
+              regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+              regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+              regAccess.rw_reg_list[1].reg = QD_REG_PTP_COMMAND;
+              regAccess.rw_reg_list[1].data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) |
+                                (opData->ptpPort << 8)  |
+                                (opData->ptpBlock << 5) |
+                                (opData->ptpAddr & 0x1F));
+              retVal = hwAccessMultiRegs(dev, &regAccess);
+              if(retVal != GT_OK)
+              {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+              }
+            }
 #else
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,0);
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = hwReadGlobal2Reg(dev,QD_REG_PTP_DATA,&data);
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
 #endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-			data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
-					(opData->ptpPort << 8)	|
-					(opData->ptpBlock << 5)	|
-					(opData->ptpAddr & 0x1F));
-#ifndef CONFIG_AVB_FPGA
-			retVal = hwWriteGlobal2Reg(dev,QD_REG_PTP_COMMAND,data);
-#else
-			tmpData = (GT_U32)data;
-	        retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+            data = (GT_U16)((1 << 15) | (PTP_READ_MULTIPLE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = 1;
+            while(data == 1)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+                data = (GT_U32)tmpData;
+                data = (data >> 15) & 0x1;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+            data = (GT_U32)tmpData;
+            opData->ptpMultiData[0] = (GT_U32)data;
+            if(retVal != GT_OK)
+               {
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            if (!(data & 0x1))
+            {
+                /* valid bit is not set */
+                   gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            for(i=1; i<opData->nData; i++)
+            {
+                retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,&tmpData);
+                data = (GT_U32)tmpData;
+                opData->ptpMultiData[i] = (GT_U32)data;
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->ptpRegsSem);
+                    return retVal;
+                }
+            }
+
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_DATA,0);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+
+            data = (GT_U16)((1 << 15) | (PTP_WRITE_DATA << 12) | 
+                    (opData->ptpPort << 8)    |
+                    (opData->ptpBlock << 5)    |
+                    (opData->ptpAddr & 0x1F));
+            tmpData = (GT_U32)data;
+            retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,tmpData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->ptpRegsSem);
+                return retVal;
+            }
+    }
 #endif
-	        if(retVal != GT_OK)
-    	    {
-        	    gtSemGive(dev,dev->ptpRegsSem);
-            	return retVal;
-	        }
-
-
-		    gtSemGive(dev,dev->ptpRegsSem);
-			break;
+            gtSemGive(dev,dev->ptpRegsSem);
+            break;
 
-		default:
-			
-			gtSemGive(dev,dev->ptpRegsSem);
-			return GT_FAIL;
-	}
+        default:
+            
+            gtSemGive(dev,dev->ptpRegsSem);
+            return GT_FAIL;
+    }
 
     /* Wait until the ptp is ready. */
+#ifndef CONFIG_AVB_FPGA
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PTP_COMMAND;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    {
+    GT_U16 data;
     data = 1;
     while(data == 1)
     {
-#ifndef CONFIG_AVB_FPGA
         retVal = hwGetGlobal2RegField(dev,QD_REG_PTP_COMMAND,15,1,&data);
-#else
-        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
-		data = (GT_U16)tmpData;
-		data = (data >> 15) & 0x1;
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->ptpRegsSem);
+            return retVal;
+        }
+    }
+    }
 #endif
+#else /* CONFIG_AVB_FPGA */
+    {
+    GT_U16 data;
+    data = 1;
+    while(data == 1)
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_COMMAND,&tmpData);
+        data = (GT_U16)tmpData;
+        data = (data >> 15) & 0x1;
         if(retVal != GT_OK)
         {
             gtSemGive(dev,dev->ptpRegsSem);
             return retVal;
         }
     }
+    }
+#endif
 
     gtSemGive(dev,dev->ptpRegsSem);
     return retVal;
@@ -4809,7 +5448,6 @@ static GT_STATUS ptpOperationPerform
 
 #ifdef CONFIG_AVB_FPGA
 
-
 /*******************************************************************************
 * gptpGetFPGAIntStatus
 *
@@ -4820,7 +5458,7 @@ static GT_STATUS ptpOperationPerform
 *       None.
 *
 * OUTPUTS:
-*		ptpInt	- PTP Int Status
+*        ptpInt    - PTP Int Status
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -4833,25 +5471,25 @@ static GT_STATUS ptpOperationPerform
 *******************************************************************************/
 GT_STATUS gptpGetFPGAIntStatus
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32		*ptpInt
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *ptpInt
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetPTPIntStatus Called.\n"));
+    DBG_INFO(("gptpGetPTPIntStatus Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*ptpInt = (GT_U32)data & 0x1;
+    *ptpInt = (GT_U32)data & 0x1;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -4862,7 +5500,7 @@ GT_STATUS gptpGetFPGAIntStatus
 *       This routine sets interrupt status of PTP logic.
 *
 * INPUTS:
-*	ptpInt	- PTP Int Status
+*    ptpInt    - PTP Int Status
 *
 * OUTPUTS:
 *       None.
@@ -4878,25 +5516,25 @@ GT_STATUS gptpGetFPGAIntStatus
 *******************************************************************************/
 GT_STATUS gptpSetFPGAIntStatus
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U32	ptpInt
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32    ptpInt
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpSetPTPIntStatus Called.\n"));
+    DBG_INFO(("gptpSetPTPIntStatus Called.\n"));
 
-	data = ptpInt?1:0;
+    data = ptpInt?1:0;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,ptpInt);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INT_OFFSET,ptpInt);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -4906,7 +5544,7 @@ GT_STATUS gptpSetFPGAIntStatus
 *       This routine enables PTP interrupt.
 *
 * INPUTS:
-*		ptpInt	- PTP Int Status (1 to enable, 0 to disable)
+*        ptpInt    - PTP Int Status (1 to enable, 0 to disable)
 *
 * OUTPUTS:
 *       None.
@@ -4922,26 +5560,26 @@ GT_STATUS gptpSetFPGAIntStatus
 *******************************************************************************/
 GT_STATUS gptpSetFPGAIntEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32		ptpInt
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        ptpInt
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetPTPIntEn Called.\n"));
+    DBG_INFO(("gptpGetPTPIntEn Called.\n"));
 
-	data = (ptpInt == 0)?0:1;
+    data = (ptpInt == 0)?0:1;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INTEN_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_INTEN_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -4955,7 +5593,7 @@ GT_STATUS gptpSetFPGAIntEn
 *       None.
 *
 * OUTPUTS:
-*		clkSrc	- PTP clock source (A/D Device or FPGA)
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -4968,25 +5606,25 @@ GT_STATUS gptpSetFPGAIntEn
 *******************************************************************************/
 GT_STATUS gptpGetClockSource
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CLOCK_SRC 	*clkSrc
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_SRC     *clkSrc
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetClockSource Called.\n"));
+    DBG_INFO(("gptpGetClockSource Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*clkSrc = (GT_PTP_CLOCK_SRC)(data & 0x1);
+    *clkSrc = (GT_PTP_CLOCK_SRC)(data & 0x1);
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -4997,7 +5635,7 @@ GT_STATUS gptpGetClockSource
 *       This routine sets PTP Clock source setup.
 *
 * INPUTS:
-*		clkSrc	- PTP clock source (A/D Device or FPGA)
+*        clkSrc    - PTP clock source (A/D Device or FPGA)
 *
 * OUTPUTS:
 *       None.
@@ -5013,25 +5651,25 @@ GT_STATUS gptpGetClockSource
 *******************************************************************************/
 GT_STATUS gptpSetClockSource
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CLOCK_SRC 	clkSrc
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_SRC     clkSrc
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpSetClockSource Called.\n"));
+    DBG_INFO(("gptpSetClockSource Called.\n"));
 
-	data = (GT_U32)clkSrc;
+    data = (GT_U32)clkSrc;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_SRC_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5045,7 +5683,7 @@ GT_STATUS gptpSetClockSource
 *       None.
 *
 * OUTPUTS:
-*		mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5058,45 +5696,45 @@ GT_STATUS gptpSetClockSource
 *******************************************************************************/
 GT_STATUS gptpGetP9Mode
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_P9_MODE 	*mode
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_P9_MODE     *mode
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetP9Mode Called.\n"));
+    DBG_INFO(("gptpGetP9Mode Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	if (data & 0x1)
-	{
-		switch (data & 0x6)
-		{
-			case 0:
-				*mode = PTP_P9_MODE_GMII;
-				break;
-			case 2:
-				*mode = PTP_P9_MODE_MII;
-				break;
-			case 4:
-				*mode = PTP_P9_MODE_MII_CONNECTOR;
-				break;
-			default:
-				return GT_BAD_PARAM;
-		}
-	}
-	else
-	{
-		*mode = PTP_P9_MODE_JUMPER;
-	}
+    if (data & 0x1)
+    {
+        switch (data & 0x6)
+        {
+            case 0:
+                *mode = PTP_P9_MODE_GMII;
+                break;
+            case 2:
+                *mode = PTP_P9_MODE_MII;
+                break;
+            case 4:
+                *mode = PTP_P9_MODE_MII_CONNECTOR;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+    }
+    else
+    {
+        *mode = PTP_P9_MODE_JUMPER;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5108,7 +5746,7 @@ GT_STATUS gptpGetP9Mode
 *       This routine sets Port 9 Mode.
 *
 * INPUTS:
-*		mode - Port 9 mode (GT_PTP_P9_MODE enum type)
+*        mode - Port 9 mode (GT_PTP_P9_MODE enum type)
 *
 * OUTPUTS:
 *       None.
@@ -5124,41 +5762,41 @@ GT_STATUS gptpGetP9Mode
 *******************************************************************************/
 GT_STATUS gptpSetP9Mode
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_P9_MODE 	mode
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_P9_MODE     mode
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpSetP9Mode Called.\n"));
+    DBG_INFO(("gptpSetP9Mode Called.\n"));
 
-	switch (mode)
-	{
-		case PTP_P9_MODE_GMII:
-			data = 1;
-			break;
-		case PTP_P9_MODE_MII:
-			data = 3;
-			break;
-		case PTP_P9_MODE_MII_CONNECTOR:
-			data = 5;
-			break;
-		case PTP_P9_MODE_JUMPER:
-			data = 0;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
+    switch (mode)
+    {
+        case PTP_P9_MODE_GMII:
+            data = 1;
+            break;
+        case PTP_P9_MODE_MII:
+            data = 3;
+            break;
+        case PTP_P9_MODE_MII_CONNECTOR:
+            data = 5;
+            break;
+        case PTP_P9_MODE_JUMPER:
+            data = 0;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_P9_MODE_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5169,7 +5807,7 @@ GT_STATUS gptpSetP9Mode
 *       This routine performs software reset for PTP logic.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
 *       None.
@@ -5185,25 +5823,25 @@ GT_STATUS gptpSetP9Mode
 *******************************************************************************/
 GT_STATUS gptpReset
 (
-	IN  GT_QD_DEV 	*dev
+    IN  GT_QD_DEV     *dev
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpReset Called.\n"));
+    DBG_INFO(("gptpReset Called.\n"));
 
-	data = 1;
+    data = 1;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_RESET_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_RESET_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5218,7 +5856,7 @@ GT_STATUS gptpReset
 *       None.
 *
 * OUTPUTS:
-*		adjEn	- GT_TRUE if enabled, GT_FALSE otherwise
+*        adjEn    - GT_TRUE if enabled, GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5231,25 +5869,25 @@ GT_STATUS gptpReset
 *******************************************************************************/
 GT_STATUS gptpGetCycleAdjustEn
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*adjEn
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *adjEn
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*adjEn = (data & 0x2)?GT_TRUE:GT_FALSE;
+    *adjEn = (data & 0x2)?GT_TRUE:GT_FALSE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5261,7 +5899,7 @@ GT_STATUS gptpGetCycleAdjustEn
 *       This routine enables/disables PTP Duty Cycle Adjustment.
 *
 * INPUTS:
-*		adjEn	- GT_TRUE to enable, GT_FALSE to disable
+*        adjEn    - GT_TRUE to enable, GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
@@ -5277,34 +5915,34 @@ GT_STATUS gptpGetCycleAdjustEn
 *******************************************************************************/
 GT_STATUS gptpSetCycleAdjustEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		adjEn
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        adjEn
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
+    DBG_INFO(("gptpGetCycleAdjustEn Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	if (adjEn == GT_FALSE)
-		data &= ~0x3;	/* clear both Enable bit and Valid bit */
-	else
-		data |= 0x2;
+    if (adjEn == GT_FALSE)
+        data &= ~0x3;    /* clear both Enable bit and Valid bit */
+    else
+        data |= 0x2;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5319,7 +5957,7 @@ GT_STATUS gptpSetCycleAdjustEn
 *       None.
 *
 * OUTPUTS:
-*		adj	- adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5332,42 +5970,42 @@ GT_STATUS gptpSetCycleAdjustEn
 *******************************************************************************/
 GT_STATUS gptpGetCycleAdjust
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_PTP_CLOCK_ADJUSTMENT	*adj
+    IN  GT_QD_DEV     *dev,
+    OUT GT_PTP_CLOCK_ADJUSTMENT    *adj
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetCycleAdjust Called.\n"));
+    DBG_INFO(("gptpGetCycleAdjust Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	adj->adjSign = (data & 0x4)?GT_PTP_SIGN_PLUS:GT_PTP_SIGN_NEGATIVE;
-	adj->cycleStep = (data >> 3) & 0x7;
+    adj->adjSign = (data & 0x4)?GT_PTP_SIGN_PLUS:GT_PTP_SIGN_NEGATIVE;
+    adj->cycleStep = (data >> 3) & 0x7;
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	adj->cycleInterval = data;
+    adj->cycleInterval = data;
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	adj->cycleAdjust = data;
+    adj->cycleAdjust = data;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5378,7 +6016,7 @@ GT_STATUS gptpGetCycleAdjust
 *       This routine sets clock duty cycle adjustment value.
 *
 * INPUTS:
-*		adj	- adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
+*        adj    - adjustment value (GT_PTP_CLOCK_ADJUSTMENT structure)
 *
 * OUTPUTS:
 *       None.
@@ -5394,73 +6032,75 @@ GT_STATUS gptpGetCycleAdjust
 *******************************************************************************/
 GT_STATUS gptpSetCycleAdjust
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PTP_CLOCK_ADJUSTMENT	*adj
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PTP_CLOCK_ADJUSTMENT    *adj
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data, data1;
+    GT_STATUS           retVal;
+    GT_U32                data;
+    GT_U32                data1;
 
-	DBG_INFO(("gptpSetCycleAdjust Called.\n"));
+    DBG_INFO(("gptpSetCycleAdjust Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	data &= ~0x1;	/* clear Valid bit */
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data &= ~0x1;    /* clear Valid bit */
 
-	/* Setup the Cycle Interval */
-	data1 = adj->cycleInterval & 0xFFFF;
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,data1);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    /* Setup the Cycle Interval */
+    data1 = adj->cycleInterval & 0xFFFF;
 
-	/* Setup the Cycle Adjustment */
-	data1 = adj->cycleAdjust & 0xFFFF;
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_INTERVAL_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,data1);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    /* Setup the Cycle Adjustment */
+    data1 = adj->cycleAdjust & 0xFFFF;
 
-	/* clear Sign bit and Cycle Step bits on QD_REG_PTP_CLK_CTRL_OFFSET value */
-	data &= ~0x3C;
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CYCLE_ADJ_OFFSET,data1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	switch (adj->adjSign)
-	{
-		case GT_PTP_SIGN_PLUS:
-			data |= 0x4;
-			break;
-			
-		case GT_PTP_SIGN_NEGATIVE:
-			break;
-
-		default:
-			return GT_BAD_PARAM;
-	}
+    /* clear Sign bit and Cycle Step bits on QD_REG_PTP_CLK_CTRL_OFFSET value */
+    data &= ~0x3C;
 
-	data |= ((adj->cycleStep & 0x7) << 3);	/* setup Step bits */
-	data |= 0x1;							/* set Valid bit */
+    switch (adj->adjSign)
+    {
+        case GT_PTP_SIGN_PLUS:
+            data |= 0x4;
+            break;
+            
+        case GT_PTP_SIGN_NEGATIVE:
+            break;
+
+        default:
+            return GT_BAD_PARAM;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data |= ((adj->cycleStep & 0x7) << 3);    /* setup Step bits */
+    data |= 0x1;                            /* set Valid bit */
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_CLK_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5475,8 +6115,8 @@ GT_STATUS gptpSetCycleAdjust
 *       None.
 *
 * OUTPUTS:
-*		en		- GT_TRUE if enabled, GT_FALSE otherwise
-*		freqSel	- PLL Frequency Selection (default 0x3 - 22.368MHz)
+*        en        - GT_TRUE if enabled, GT_FALSE otherwise
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5485,33 +6125,33 @@ GT_STATUS gptpSetCycleAdjust
 *
 * COMMENTS:
 *       PLL Frequence selection is based on the Clock Recovery PLL device.
-*		IDT MK1575-01 is the default PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
 GT_STATUS gptpGetPLLEn
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en,
-	OUT GT_U32		*freqSel
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en,
+    OUT GT_U32        *freqSel
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpGetPLLEn Called.\n"));
+    DBG_INFO(("gptpGetPLLEn Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*en = (data & 0x1)?GT_TRUE:GT_FALSE;
+    *en = (data & 0x1)?GT_TRUE:GT_FALSE;
 
-	*freqSel = (data >> 1) & 0x7;
+    *freqSel = (data >> 1) & 0x7;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5523,9 +6163,9 @@ GT_STATUS gptpGetPLLEn
 *       This routine enables/disables PLL device.
 *
 * INPUTS:
-*		en		- GT_TRUE to enable, GT_FALSE to disable
-*		freqSel	- PLL Frequency Selection (default 0x3 - 22.368MHz)
-*				  Meaningful only when enabling PLL device
+*        en        - GT_TRUE to enable, GT_FALSE to disable
+*        freqSel    - PLL Frequency Selection (default 0x3 - 22.368MHz)
+*                  Meaningful only when enabling PLL device
 *
 * OUTPUTS:
 *       None.
@@ -5537,45 +6177,45 @@ GT_STATUS gptpGetPLLEn
 *
 * COMMENTS:
 *       PLL Frequence selection is based on the Clock Recovery PLL device.
-*		IDT MK1575-01 is the default PLL device.
+*        IDT MK1575-01 is the default PLL device.
 *
 *******************************************************************************/
 GT_STATUS gptpSetPLLEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en,
-	IN  GT_U32		freqSel
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en,
+    IN  GT_U32        freqSel
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32				data;
+    GT_STATUS           retVal;
+    GT_U32                data;
 
-	DBG_INFO(("gptpSetPPLEn Called.\n"));
+    DBG_INFO(("gptpSetPPLEn Called.\n"));
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	if(en == GT_FALSE)
-	{
-		data |= 0x1;
-	}
-	else
-	{
-		data &= ~0x1;
-		data |= (freqSel & 0x7) << 1;
-	}
+    if(en == GT_FALSE)
+    {
+        data |= 0x1;
+    }
+    else
+    {
+        data &= ~0x1;
+        data |= (freqSel & 0x7) << 1;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,QD_REG_PTP_PLL_CTRL_OFFSET,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -5587,10 +6227,10 @@ GT_STATUS gptpSetPLLEn
 *       This routine gets DDS register data.
 *
 * INPUTS:
-*	ddsReg	- DDS Register
+*    ddsReg    - DDS Register
 *
 * OUTPUTS:
-*	ddsData	- register data
+*    ddsData    - register data
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5603,50 +6243,50 @@ GT_STATUS gptpSetPLLEn
 *******************************************************************************/
 GT_STATUS gptpGetDDSReg
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	ddsReg,
-	OUT GT_U32	*ddsData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    OUT GT_U32    *ddsData
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32			data;
-	GT_U32			timeout = 0x100000;
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
 
-	DBG_INFO(("gptpGetDDSReg Called.\n"));
+    DBG_INFO(("gptpGetDDSReg Called.\n"));
 
-	if (ddsReg > 0x3f)
-		return GT_BAD_PARAM;
-	do 
-	{
-		retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
-		if (retVal != GT_OK)
-			return retVal;
-		timeout--;
-		if (timeout == 0)
-			return GT_FAIL;
-	} while (data & 0x8000);
-
-	data = 0x8000 | 0x4000 | (ddsReg << 8);
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    if (ddsReg > 0x3f)
+        return GT_BAD_PARAM;
+    do 
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | 0x4000 | (ddsReg << 8);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
-	if (retVal != GT_OK)
-		return retVal;
+    retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+    if (retVal != GT_OK)
+        return retVal;
 
-	*ddsData = data & 0xFF;
+    *ddsData = data & 0xFF;
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -5654,14 +6294,14 @@ GT_STATUS gptpGetDDSReg
 *
 * DESCRIPTION:
 *       This routine sets DDS register data.
-*	DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
+*    DDS register data written by this API are not affected until gptpUpdateDDSReg API is called.
 *
 * INPUTS:
-*	ddsReg	- DDS Register
-*	ddsData	- register data
+*    ddsReg    - DDS Register
+*    ddsData    - register data
 *
 * OUTPUTS:
-*	none
+*    none
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5674,45 +6314,45 @@ GT_STATUS gptpGetDDSReg
 *******************************************************************************/
 GT_STATUS gptpSetDDSReg
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	ddsReg,
-	IN  GT_U32	ddsData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    ddsReg,
+    IN  GT_U32    ddsData
 )
 {
-	GT_STATUS       	retVal;
-	GT_U32			data;
-	GT_U32			timeout = 0x100000;
+    GT_STATUS           retVal;
+        GT_U32                  data;
+        GT_U32                  timeout = 0x100000;
 
-	DBG_INFO(("gptpSetDDSReg Called.\n"));
+    DBG_INFO(("gptpSetDDSReg Called.\n"));
 
-	if ((ddsReg > 0x3f) || (ddsData > 0xff))
-		return GT_BAD_PARAM;
+    if ((ddsReg > 0x3f) || (ddsData > 0xff))
+        return GT_BAD_PARAM;
 
-	do 
-	{
-		retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
-		if (retVal != GT_OK)
-			return retVal;
-		timeout--;
-		if (timeout == 0)
-			return GT_FAIL;
-	} while (data & 0x8000);
-
-	data = 0x8000 | (ddsReg << 8) | (ddsData);
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    do 
+    {
+        retVal = AVB_FPGA_READ_REG(dev,AVB_SMI_ADDR,12,&data);
+        if (retVal != GT_OK)
+            return retVal;
+        timeout--;
+        if (timeout == 0)
+            return GT_FAIL;
+    } while (data & 0x8000);
+
+    data = 0x8000 | (ddsReg << 8) | (ddsData);
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,12,0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -5720,13 +6360,13 @@ GT_STATUS gptpSetDDSReg
 *
 * DESCRIPTION:
 *       This routine updates DDS register data.
-*	DDS register data written by gptpSetDDSReg are not affected until this API is called.
+*    DDS register data written by gptpSetDDSReg are not affected until this API is called.
 *
 * INPUTS:
-*	none
+*    none
 *
 * OUTPUTS:
-*	none
+*    none
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5739,27 +6379,27 @@ GT_STATUS gptpSetDDSReg
 *******************************************************************************/
 GT_STATUS gptpUpdateDDSReg
 (
-	IN  GT_QD_DEV 	*dev
+    IN  GT_QD_DEV     *dev
 )
 {
-	GT_STATUS       	retVal;
+    GT_STATUS           retVal;
 
-	DBG_INFO(("gptpUpdateDDSReg Called.\n"));
+    DBG_INFO(("gptpUpdateDDSReg Called.\n"));
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x0);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x1);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,13,0x1);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -5769,10 +6409,10 @@ GT_STATUS gptpUpdateDDSReg
 *       This routine sets ADF4156 register data.
 *
 * INPUTS:
-*	adfData	- register data
+*    adfData    - register data
 *
 * OUTPUTS:
-*	none
+*    none
 *
 * RETURNS:
 *       GT_OK      - on success
@@ -5785,31 +6425,31 @@ GT_STATUS gptpUpdateDDSReg
 *******************************************************************************/
 GT_STATUS gptpSetADFReg
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U32	adfData
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32    adfData
 )
 {
-	GT_STATUS       	retVal;
+    GT_STATUS           retVal;
 
-	DBG_INFO(("gptpSetADFReg Called.\n"));
+    DBG_INFO(("gptpSetADFReg Called.\n"));
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,14,(adfData & 0xFFFF));
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,14,(adfData & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,15,((adfData>>16) & 0xFFFF));
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = AVB_FPGA_WRITE_REG(dev,AVB_SMI_ADDR,15,((adfData>>16) & 0xFFFF));
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
-#endif
+#endif  /*  CONFIG_AVB_FPGA */
 
 
 /******************************************************************************
@@ -5817,325 +6457,677 @@ GT_STATUS gptpSetADFReg
 *
 *******************************************************************************/
 /* Amber QAV API */
-
 /*******************************************************************************
 * gqavSetPortQpriXQTSToken
 *
 * DESCRIPTION:
-*       This routine set Priority Queue 0-3 time slot tokens on a port.
-*		The setting value is number of tokens that need to be subtracted at each 
-*		QTS interval boundary.
+*        This routine set Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each 
+*        QTS interval boundary.
 *
 * INPUTS:
-*		queue	 - 0 - 3
-*		qtsToken - number of tokens.
+*        port    - the logical port number
+*        queue     - 0 - 3
+*        qtsToken - number of tokens.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gqavSetPortQpriXQTSToken
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	IN  GT_U16		qtsToken
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        qtsToken
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavSetPortQpriXQTSToken Called.\n"));
+    DBG_INFO(("gqavSetPortQpriXQTSToken Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if queue is beyond range */
-	if (queue>0x3)
+    if (queue>0x3)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
     /* check if qtsToken is beyond range */
-	if (qtsToken>0x7fff)
+    if (qtsToken>0x7fff)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = queue*2;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2;
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData = qtsToken&0x7fff;
+    opData.ptpData = qtsToken&0x7fff;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing QTS token for port %d queue %d.\n", port, queue));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetPortQpriXQTSToken
 *
 * DESCRIPTION:
-*       This routine get Priority Queue 0-3 time slot tokens on a port.
-*		The setting value is number of tokens that need to be subtracted at each 
-*		QTS interval boundary.
+*        This routine get Priority Queue 0-3 time slot tokens on a port.
+*        The setting value is number of tokens that need to be subtracted at each 
+*        QTS interval boundary.
 *
 * INPUTS:
-*		queue - 0 - 3
+*        port    - the logical port number
+*        queue - 0 - 3
 *
 * OUTPUTS:
-*		qtsToken - number of tokens
+*        qtsToken - number of tokens
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gqavGetPortQpriXQTSToken
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	OUT GT_U16		*qtsToken
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *qtsToken
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavGetPortQpriXQTSToken Called.\n"));
+    DBG_INFO(("gqavGetPortQpriXQTSToken Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if queue is beyond range */
-	if (queue>0x3)
+    if (queue>0x3)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
+    opData.ptpBlock = 0x2;    /* QAV register space */
 
-	opData.ptpAddr = queue*2;
-	opData.ptpPort = hwPort;
+    opData.ptpAddr = queue*2;
+    opData.ptpPort = hwPort;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading QTS token for port %d queue %d.\n", port, queue));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*qtsToken =	(GT_U16)(opData.ptpData&0x7fff);
+    *qtsToken =(GT_U16)opData.ptpData&0x7fff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
-
 /*******************************************************************************
 * gqavSetPortQpriXBurstBytes
 *
 * DESCRIPTION:
-*       This routine set Priority Queue 0-3 Burst Bytes on a port.
-*		This value specifies the number of credits in bytes that can be 
-*		accumulated when the queue is blocked from sending out a frame due to 
-*		higher priority queue frames being sent out.
+*        This routine set Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be 
+*        accumulated when the queue is blocked from sending out a frame due to 
+*        higher priority queue frames being sent out.
 *
 * INPUTS:
-*		queue - 0 - 3
-*		burst - number of credits in bytes .
+*        port    - the logical port number
+*        queue - 0 - 3
+*        burst - number of credits in bytes .
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetPortQpriXBurstBytes
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	IN  GT_U16		burst
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        burst
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavSetPortQpriXBurstBytes Called.\n"));
+    DBG_INFO(("gqavSetPortQpriXBurstBytes Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if queue is beyond range */
-	if (queue>0x3)
+    if (queue>0x3)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
     /* check if burst is beyond range */
-	if (burst>0x7fff)
+    if (burst>0x7fff)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = queue*2+1;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData = burst&0x7fff;
+    opData.ptpData = burst&0x7fff;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Burst bytes for port %d queue %d.\n", port, queue));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
-
 /*******************************************************************************
 * gqavGetPortQpriXBurstBytes
 *
 * DESCRIPTION:
-*       This routine get Priority Queue 0-3 Burst Bytes on a port.
-*		This value specifies the number of credits in bytes that can be 
-*		accumulated when the queue is blocked from sending out a frame due to 
-*		higher priority queue frames being sent out.
+*        This routine get Priority Queue 0-3 Burst Bytes on a port.
+*        This value specifies the number of credits in bytes that can be 
+*        accumulated when the queue is blocked from sending out a frame due to 
+*        higher priority queue frames being sent out.
 *
 * INPUTS:
-*		queue - 0 - 3
+*        port    - the logical port number
+*        queue    - 0 - 3
 *
 * OUTPUTS:
-*		burst - number of credits in bytes .
+*        burst - number of credits in bytes .
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXBurstBytes
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *burst
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavgetPortQpriXBurstBytes Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_QTS_TOKEN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    /* check if queue is beyond range */
+    if (queue>0x3)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Burst bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    *burst = (GT_U16)opData.ptpData&0x7fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gqavSetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 rate on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        rate - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        rate
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXRate Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev, DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if ((queue>0x3)||(queue<2))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if rate  is beyond range */
+    if (rate>0x0fff)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = rate&0x0fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing rate bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+/*******************************************************************************
+* gqavGetPortQpriXRate
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 rate Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        rate - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavGetPortQpriXRate
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *rate
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavgetPortQpriXRate Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    /* check if queue is beyond range */
+    if ((queue>0x3)||(queue<2))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
+
+    op = PTP_READ_DATA;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Rate bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    *rate = (GT_U16)opData.ptpData&0x0fff;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+/*******************************************************************************
+* gqavSetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine set Priority Queue 2-3 HiLimit on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue - 2 - 3
+*        hiLimit - number of credits in bytes .
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None
+*
+*******************************************************************************/
+GT_STATUS gqavSetPortQpriXHiLimit
+(
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    IN  GT_U16        hiLimit
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
+
+    DBG_INFO(("gqavSetPortQpriXHiLimit Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = (GT_U32)GT_LPORT_2_PORT(port);
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev, DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if queue is beyond range */
+    if ((queue>0x3)||(queue<2))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* check if rate  is beyond range */
+    if (hiLimit>0x0fff)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = queue*2+1;
+
+    opData.ptpPort = hwPort;
+
+    op = PTP_WRITE_DATA;
+
+    opData.ptpData = hiLimit&0x0fff;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing Burst bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+/*******************************************************************************
+* gqavGetPortQpriXHiLimit
+*
+* DESCRIPTION:
+*        This routine get Priority Queue 2-3 HiLimit Bytes on a port.
+*
+* INPUTS:
+*        port    - the logical port number
+*        queue    - 2 - 3
+*
+* OUTPUTS:
+*        hiLimit - number of credits in bytes .
+*
+* RETURNS:
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
-GT_STATUS gqavGetPortQpriXBurstBytes
+GT_STATUS gqavGetPortQpriXHiLimit
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_U8		queue,
-	OUT GT_U16		*burst
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_U8        queue,
+    OUT GT_U16        *hiLimit
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavgetPortQpriXBurstBytes Called.\n"));
+    DBG_INFO(("gqavgetPortQpriXHiLimit Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_QPRI_RATE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
 
+    }
     /* check if queue is beyond range */
-	if (queue>0x3)
+    if ((queue>0x3)||(queue<2))
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
+    opData.ptpBlock = 0x2;    /* QAV register space */
 
-	opData.ptpAddr = queue*2+1;
-	opData.ptpPort = hwPort;
+    opData.ptpAddr = queue*2+1;
+    opData.ptpPort = hwPort;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-        DBG_INFO(("Failed reading Burst bytes for port %d queue %d.\n", port, queue));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Hi Limit bytes for port %d queue %d.\n", port, queue));
+        return GT_FAIL;
+    }
 
-	*burst = (GT_U16)opData.ptpData&0x7fff;
+    *hiLimit = (GT_U16)opData.ptpData&0x7fff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -6143,265 +7135,268 @@ GT_STATUS gqavGetPortQpriXBurstBytes
 * gqavSetPortQavEnable
 *
 * DESCRIPTION:
-*       This routine set QAV enable status on a port.
+*        This routine set QAV enable status on a port.
 *
 * INPUTS:
-*		en - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*        port    - the logical port number
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetPortQavEnable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavSetPortQavEnable Called.\n"));
+    DBG_INFO(("gqavSetPortQavEnable Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 8;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData = (en==GT_TRUE)?0x8000:0;
+    opData.ptpData = (en==GT_TRUE)?0x8000:0;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing QAV enable for port %d.\n", port));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
+
 /*******************************************************************************
 * gqavGetPortQavEnable
 *
 * DESCRIPTION:
-*       This routine get QAV enable status on a port.
+*        This routine get QAV enable status on a port.
 *
 * INPUTS:
-*       None.
+*        port    - the logical port number
 *
 * OUTPUTS:
-*		en - GT_TRUE: QAV enable, GT_FALSE: QAV disable
+*        en        - GT_TRUE: QAV enable, GT_FALSE: QAV disable
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetPortQavEnable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN	GT_LPORT	port,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN    GT_LPORT    port,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
-	GT_U32			hwPort;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+    GT_U32            hwPort;
 
-	DBG_INFO(("gqavGetPortQavEnable Called.\n"));
+    DBG_INFO(("gqavGetPortQavEnable Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = (GT_U32)GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 8;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
 
-	opData.ptpPort = hwPort;
+    opData.ptpPort = hwPort;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed reading QAV enable for port %d.\n", port));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	*en = ((opData.ptpData&0x8000)==0)?GT_FALSE:GT_TRUE;
+    *en = ((opData.ptpData&0x8000)==0)?GT_FALSE:GT_TRUE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
+
 /*******************************************************************************/
 /* QAV Global resters processing */
 /*******************************************************************************
 * gqavSetGlobalAdminMGMT
 *
 * DESCRIPTION:
-*       This routine set to accept Admit Management Frames always.
+*        This routine set to accept Admit Management Frames always.
 *
 * INPUTS:
-*		en - GT_TRUE to set MGMT frame accepted always, 
-*			 GT_FALSE do not set MGMT frame accepted always
+*        en - GT_TRUE to set MGMT frame accepted always, 
+*             GT_FALSE do not set MGMT frame accepted always
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalAdminMGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalAdminMGMT Called.\n"));
+    DBG_INFO(("gqavSetGlobalAdminMGMT Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 0;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0x8000;
-	if (en)
-		opData.ptpData |= 0x8000;
+    opData.ptpData &= ~0x8000;
+    if (en)
+        opData.ptpData |= 0x8000;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing QAV global config admin MGMT.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalAdminMGMT
 *
 * DESCRIPTION:
-*       This routine get setting of Admit Management Frames always.
+*        This routine get setting of Admit Management Frames always.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to set MGMT frame accepted always, 
-*			 GT_FALSE do not set MGMT frame accepted always
+*        en - GT_TRUE to set MGMT frame accepted always, 
+*             GT_FALSE do not set MGMT frame accepted always
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalAdminMGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalAdminMGMT Called.\n"));
+    DBG_INFO(("gqavGetGlobalAdminMGMT Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 0;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config admin MGMT.\n"));
+        return GT_FAIL;
+    }
 
-	if (opData.ptpData&0x8000)
-	  *en = GT_TRUE;
-	else
-	  *en = GT_FALSE;
+    if (opData.ptpData&0x8000)
+      *en = GT_TRUE;
+    else
+      *en = GT_FALSE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -6409,79 +7404,93 @@ GT_STATUS gqavGetGlobalAdminMGMT
 * gqavSetGlobalIsoPtrThreshold
 *
 * DESCRIPTION:
-*       This routine set Global Isochronous Queue Pointer Threshold.
-*		This field indicates the total number of isochronous pointers 
-*		that are reserved for isochronous streams. The value is expected to be 
-*		computed in SRP software and programmed into hardware based on the total 
-*		aggregate isochronous streams configured to go through this device..
+*        This routine set Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers 
+*        that are reserved for isochronous streams. The value is expected to be 
+*        computed in SRP software and programmed into hardware based on the total 
+*        aggregate isochronous streams configured to go through this device..
 *
 * INPUTS:
-*		isoPtrs -  total number of isochronous pointers 
+*        isoPtrs -  total number of isochronous pointers 
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoPtrThreshold
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		isoPtrs
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        isoPtrs
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoPtrThreshold Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoPtrThreshold Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if isoPtrs is beyond range */
-	if (isoPtrs>0x3ff)
-    {
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_FAMILY))
+	{
+      if (isoPtrs>0x3ff)
+      {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-    }
+        return GT_BAD_PARAM;
+      }
+	}
+    else
+	{
+      if (isoPtrs>0x1ff)
+      {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+      }
+	}
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 0;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading QAV global config Isochronous Queue Pointer Threshold.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading QAV global config Isochronous Queue Pointer Threshold.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0x3ff;
-	opData.ptpData |= isoPtrs;
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_FAMILY))
+      opData.ptpData &= ~0x3ff;
+    else
+      opData.ptpData &= ~0x1ff;
+    opData.ptpData |= isoPtrs;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing QAV global config Isochronous Queue Pointer Threshold.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -6489,63 +7498,66 @@ GT_STATUS gqavSetGlobalIsoPtrThreshold
 * gqavGetGlobalIsoPtrThreshold
 *
 * DESCRIPTION:
-*       This routine get Global Isochronous Queue Pointer Threshold.
-*		This field indicates the total number of isochronous pointers 
-*		that are reserved for isochronous streams. The value is expected to be 
-*		computed in SRP software and programmed into hardware based on the total 
-*		aggregate isochronous streams configured to go through this device..
+*        This routine get Global Isochronous Queue Pointer Threshold.
+*        This field indicates the total number of isochronous pointers 
+*        that are reserved for isochronous streams. The value is expected to be 
+*        computed in SRP software and programmed into hardware based on the total 
+*        aggregate isochronous streams configured to go through this device..
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		isoPtrs -  total number of isochronous pointers 
+*        isoPtrs -  total number of isochronous pointers 
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoPtrThreshold
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*isoPtrs
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *isoPtrs
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoPtrThreshold Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoPtrThreshold Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 0;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 0;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous Queue Pointer Threshold.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous Queue Pointer Threshold.\n"));
+        return GT_FAIL;
+    }
 
-	*isoPtrs = (GT_U16)opData.ptpData&0x3ff;
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_FAMILY))
+      *isoPtrs = (GT_U16)opData.ptpData&0x3ff;
+    else
+      *isoPtrs = (GT_U16)opData.ptpData&0x1ff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -6553,358 +7565,366 @@ GT_STATUS gqavGetGlobalIsoPtrThreshold
 * gqavSetGlobalDisQSD4MGMT
 *
 * DESCRIPTION:
-*       This routine set Disable Queue Scheduler Delays for Management frames..
+*        This routine set Disable Queue Scheduler Delays for Management frames..
 *
 * INPUTS:
-*		en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
-*		Scheduler Delays and the corresponding rate regulator does not account
-*		for MGMT frames through this queue.
-*			 GT_FALSE, the MGMT frames follow similar rate regulation and delay
-*		regulation envelope as specified for the isochronous queue that the
-*		MGMT frames are sharing with.
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalDisQSD4MGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalDisQSD4MGMT Called.\n"));
+    DBG_INFO(("gqavSetGlobalDisQSD4MGMT Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 3;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 3;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0x4000;
-	if (en==GT_TRUE)
-		opData.ptpData |= 0x4000;
+    opData.ptpData &= ~0x4000;
+    if (en==GT_TRUE)
+        opData.ptpData |= 0x4000;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Disable Queue Scheduler Delay for MGMT frames.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalDisQSD4MGMT
 *
 * DESCRIPTION:
-*       This routine Get Disable Queue Scheduler Delays for Management frames..
+*        This routine Get Disable Queue Scheduler Delays for Management frames..
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
-*		Scheduler Delays and the corresponding rate regulator does not account
-*		for MGMT frames through this queue.
-*			 GT_FALSE, the MGMT frames follow similar rate regulation and delay
-*		regulation envelope as specified for the isochronous queue that the
-*		MGMT frames are sharing with.
-*       None.
+*        en - GT_TRUE, it indicates to the Queue Controller to disable applying Queue
+*            Scheduler Delays and the corresponding rate regulator does not account
+*            for MGMT frames through this queue.
+*            GT_FALSE, the MGMT frames follow similar rate regulation and delay
+*            regulation envelope as specified for the isochronous queue that the
+*            MGMT frames are sharing with.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalDisQSD4MGMT
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalDisQSD4MGMT Called.\n"));
+    DBG_INFO(("gqavGetGlobalDisQSD4MGMT Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 3;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 3;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Disable Queue Scheduler Delay for MGMT frames.\n"));
+        return GT_FAIL;
+    }
 
-	if (opData.ptpData&0x4000)
-	  *en = GT_TRUE;
-	else
-	  *en = GT_FALSE;
+    if (opData.ptpData&0x4000)
+      *en = GT_TRUE;
+    else
+      *en = GT_FALSE;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
-
 /*******************************************************************************
 * gqavSetGlobalInterrupt
 *
 * DESCRIPTION:
-*       This routine set QAV interrupt enable, The QAV interrypts include:
-*		 [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
-*		 [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   # Iso Packet Memory Exceeded 
-*												  Interrupt Enable 
+*        This routine set QAV interrupt enable, 
+*        The QAV interrypts include:
+*        [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
+*        [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
+*        [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
+*        [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                              Interrupt Enable 
 *
 * INPUTS:
-*		intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
-*				[GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
+*        intEn - [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalInterrupt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		intEn
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        intEn
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalInterrupt Called.\n"));
+    DBG_INFO(("gqavSetGlobalInterrupt Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 8;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
+    op = PTP_READ_DATA;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Interrupt enable status.\n"));
-		return GT_FAIL;
-	}
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Interrupt enable status.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0xff;
-	opData.ptpData |= (intEn&0xff);
+    opData.ptpData &= ~0xffff;
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_FAMILY))
+      opData.ptpData |= (intEn&0x83);
+    else
+      opData.ptpData |= (intEn&0x03);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Interrupt enable status.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalInterrupt
 *
 * DESCRIPTION:
-*       This routine get QAV interrupt enable, The QAV interrypts include:
-*		 [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status   
-*		 [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status 
-*		 [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT]   # Iso Packet Memory Exceeded 
-*												  Interrupt Status 
-*		 [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
-*		 [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
-*		 [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   # Iso Packet Memory Exceeded 
-*												  Interrupt Enable 
+*       This routine get QAV interrupt status and enable status, 
+*        The QAV interrypt status include:
+*         [GT_QAV_INT_STATUS_ENQ_LMT_BIT]      # Enqueue Delay Limit exceeded  
+*         [GT_QAV_INT_STATUS_ISO_DEL_BIT]      # Iso Delay Interrupt Status   
+*         [GT_QAV_INT_STATUS_ISO_DIS_BIT]      # Iso Discard Interrupt Status 
+*         [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                                Interrupt Status 
+*        The QAV interrypt enable status include:
+*         [GT_QAV_INT_ENABLE_ENQ_LMT_BIT]      # EnQ Limit Interrupt Enable 
+*         [GT_QAV_INT_ENABLE_ISO_DEL_BIT]      # Iso Delay Interrupt Enable   
+*         [GT_QAV_INT_ENABLE_ISO_DIS_BIT]      # Iso Discard Interrupt Enable 
+*         [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT] # Iso Packet Memory Exceeded 
+*                                                  Interrupt Enable 
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-* INPUTS:
-*		intEn - [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR     
-*				[GT_QAV_INT_STATUS_ISO_DIS_BIT] OR   
-*				[GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
-*				[GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
-*				[GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
-*				[GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
+*        intEnSt - [GT_QAV_INT_STATUS_ENQ_LMT_BIT] OR     
+*                [GT_QAV_INT_STATUS_ISO_DEL_BIT] OR   
+*                [GT_QAV_INT_STATUS_ISO_DIS_BIT] OR   
+*                [GT_QAV_INT_STATUS_ISO_LIMIT_EX_BIT] OR
+*                [GT_QAV_INT_ENABLE_ENQ_LMT_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_DEL_BIT] OR    
+*                [GT_QAV_INT_ENABLE_ISO_DIS_BIT] OR  
+*                [GT_QAV_INT_ENABLE_ISO_LIMIT_EX_BIT]   
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalInterrupt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*intSt
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *intEnSt
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalInterrupt Called.\n"));
+    DBG_INFO(("gqavGetGlobalInterrupt Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 8;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 8;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Interrupt status.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Interrupt status.\n"));
+        return GT_FAIL;
+    }
 
-	*intSt = (GT_U16)opData.ptpData;
+    if (IS_IN_DEV_GROUP(dev,DEV_AVB_FAMILY))
+      *intEnSt = (GT_U16)opData.ptpData & 0x8783;
+    else
+      *intEnSt = (GT_U16)opData.ptpData & 0x0303;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalIsoInterruptPort
 *
 * DESCRIPTION:
-*       This routine get Isochronous interrupt port.
-*		This field indicates the port number for IsoDisInt or IsoLimitExInt 
-*		bits. Only one such interrupt condition can be detected by hardware at one 
-*		time. Once an interrupt bit has been set along with the IsoIntPort, the 
-*		software would have to come and clear the bits before hardware records 
-*		another interrupt event.
+*        This routine get Isochronous interrupt port.
+*        This field indicates the port number for IsoDisInt or IsoLimitExInt 
+*        bits. Only one such interrupt condition can be detected by hardware at one 
+*        time. Once an interrupt bit has been set along with the IsoIntPort, the 
+*        software would have to come and clear the bits before hardware records 
+*        another interrupt event.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		port - port number for IsoDisInt or IsoLimitExInt bits.
+*        port - port number for IsoDisInt or IsoLimitExInt bits.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoInterruptPort
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*port
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *port
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoInterruptPort Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoInterruptPort Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 9;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 9;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous interrupt port..\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous interrupt port..\n"));
+        return GT_FAIL;
+    }
 
-	*port = (GT_U8)opData.ptpData&0xf;
+    *port = (GT_U8)opData.ptpData&0xf;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -6912,137 +7932,147 @@ GT_STATUS gqavGetGlobalIsoInterruptPort
 * gqavSetGlobalIsoDelayLmt
 *
 * DESCRIPTION:
-*       This routine set Isochronous queue delay Limit
-*		This field represents a per-port isochronous delay limit that 
-*		will be checked by the queue controller logic to ensure no isochronous 
-*		packets suffer more than this delay w.r.t to their eligibility time slot.
-*		This represents the number of Queue Time Slots. The interval for the QTS 
-*		can be configured using the register in Qav Global Configuration, Offset 0x2.
+*        This routine set Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that 
+*        will be checked by the queue controller logic to ensure no isochronous 
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS 
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
 *
 * INPUTS:
-*		limit - per-port isochronous delay limit.
+*        limit - per-port isochronous delay limit.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoDelayLmt
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		limit
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        limit
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoDelayLmt Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoDelayLmt Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_ISO_DELAY_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 10;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 10;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0xff;
-	opData.ptpData |= (limit&0xff);
+    opData.ptpData &= ~0xff;
+    opData.ptpData |= (limit&0xff);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Isochronous queue delay Limit.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalIsoDelayLmt
 *
 * DESCRIPTION:
-*       This routine get Isochronous queue delay Limit
-*		This field represents a per-port isochronous delay limit that 
-*		will be checked by the queue controller logic to ensure no isochronous 
-*		packets suffer more than this delay w.r.t to their eligibility time slot.
-*		This represents the number of Queue Time Slots. The interval for the QTS 
-*		can be configured using the register in Qav Global Configuration, Offset 0x2.
+*        This routine get Isochronous queue delay Limit
+*        This field represents a per-port isochronous delay limit that 
+*        will be checked by the queue controller logic to ensure no isochronous 
+*        packets suffer more than this delay w.r.t to their eligibility time slot.
+*        This represents the number of Queue Time Slots. The interval for the QTS 
+*        can be configured using the register in Qav Global Configuration, Offset 0x2.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		limit - per-port isochronous delay limit.
+*        limit - per-port isochronous delay limit.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoDelayLmt
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*limit
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *limit
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoDelayLmt Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoDelayLmt Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV_ISO_DELAY_LIMIT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 10;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 10;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous queue delay Limit.\n"));
+        return GT_FAIL;
+    }
 
-	*limit = (GT_U8)(opData.ptpData)&0xff;
+    *limit = (GT_U8)(opData.ptpData)&0xff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -7050,227 +8080,226 @@ GT_STATUS gqavGetGlobalIsoDelayLmt
 *
 * DESCRIPTION:
 *       This routine set Isochronous monitor enable
-*		Set 1: this bit enables the statistics gathering capabilities stated
-*		in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
-*		software is expected to program the IsoMonPort (PTP Global Status Offset
-*		0xD) indicating which port of the device does the software wants to monitor.
-*		Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
-*		IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
-*		set to a zero.
-*		Set 0: this bit disables the statistics gathering capabilities.
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
 *
 * INPUTS:
-*		en - [1]/[0].
+*        en - GT_TRUE / GT_FALSE.
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoMonEn
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoMonEn Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoMonEn Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 12;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0x8000;
-	if (en)
-		opData.ptpData |= 0x8000;
+    opData.ptpData &= ~0x8000;
+    if (en)
+        opData.ptpData |= 0x8000;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Isochronous monitor enable.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalIsoMonEn
 *
 * DESCRIPTION:
-*       This routine get Isochronous monitor enable
-*		Set 1: this bit enables the statistics gathering capabilities stated
-*		in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
-*		software is expected to program the IsoMonPort (PTP Global Status Offset
-*		0xD) indicating which port of the device does the software wants to monitor.
-*		Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
-*		IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
-*		set to a zero.
-*		Set 0: this bit disables the statistics gathering capabilities.
+*        This routine get Isochronous monitor enable
+*        Set GT_TRUE: this bit enables the statistics gathering capabilities stated
+*        in PTP Global Status Registers Offset 0xD, 0xE and 0xF. Once enabled, the
+*        software is expected to program the IsoMonPort (PTP Global Status Offset
+*        0xD) indicating which port of the device does the software wants to monitor.
+*        Upon setting this bit, the hardware collects IsoHiDisCtr, IsoLoDisCtr and
+*        IsoSchMissCtr values for the port indicated by IsoMonPort till this bit is 
+*        set to a zero.
+*        Set GT_FALSE: this bit disables the statistics gathering capabilities.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		en - [1]/[0].
-
+*        en - GT_TRUE / GT_FALSE.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoMonEn
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    OUT GT_BOOL        *en
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoMonEn Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoMonEn Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 12;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitor enable.\n"));
+        return GT_FAIL;
+    }
 
-	if (opData.ptpData&0x8000)
-	  *en = 1;
-	else
-	  *en = 0;
+    if (opData.ptpData&0x8000)
+      *en = 1;
+    else
+      *en = 0;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavSetGlobalIsoMonPort
 *
 * DESCRIPTION:
-*       This routine set Isochronous monitoring port.
-*		This field is updated by software along with Iso Mon En bit 
-*		(Qav Global Status, offset 0xD) and it indicates the port number that 
-*		the software wants the hardware to start monitoring i.e., start updating 
-*		IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
-*		the above stats when IsoMonPort is changed..
+*        This routine set Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit 
+*        (Qav Global Status, offset 0xD) and it indicates the port number that 
+*        the software wants the hardware to start monitoring i.e., start updating 
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
+*        the above stats when IsoMonPort is changed..
 *
 * INPUTS:
-*		port -  port number .
+*        port -  port number .
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoMonPort
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U16		port
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U16        port
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoMonPort Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoMonPort Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if port is beyond range */
-	if (port>0xf)
+    if (port>0xf)
     {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
+        return GT_BAD_PARAM;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 12;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0xf;
-	opData.ptpData |= port;
+    opData.ptpData &= ~0xf;
+    opData.ptpData |= port;
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Isochronous monitoring port.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -7278,200 +8307,200 @@ GT_STATUS gqavSetGlobalIsoMonPort
 * gqavGetGlobalIsoMonPort
 *
 * DESCRIPTION:
-*       This routine get Isochronous monitoring port.
-*		This field is updated by software along with Iso Mon En bit 
-*		(Qav Global Status, offset 0xD) and it indicates the port number that 
-*		the software wants the hardware to start monitoring i.e., start updating 
-*		IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
-*		the above stats when IsoMonPort is changed..
+*        This routine get Isochronous monitoring port.
+*        This field is updated by software along with Iso Mon En bit 
+*        (Qav Global Status, offset 0xD) and it indicates the port number that 
+*        the software wants the hardware to start monitoring i.e., start updating 
+*        IsoHiDisCtr, IsoLoDisCtr and IsoSchMissCtr. The queue controller clears 
+*        the above stats when IsoMonPort is changed..
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		port -  port number .
+*        port -  port number.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoMonPort
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U16		*port
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U16        *port
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoMonPort Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoMonPort Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 12;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 12;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous monitoring port.\n"));
+        return GT_FAIL;
+    }
 
-	*port = (GT_U16)opData.ptpData&0xf;
+    *port = (GT_U16)opData.ptpData&0xf;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavSetGlobalIsoHiDisCtr
 *
 * DESCRIPTION:
-*       This routine set Isochronous hi queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous hi packets discarded 
-*		by Queue Controller.
+*        This routine set Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous hi packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		disCtr - upcounter of number of isochronous hi packets discarded 
+*        disCtr - upcounter of number of isochronous hi packets discarded 
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoHiDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		disCtr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoHiDisCtr Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoHiDisCtr Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 13;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous hi queue discard counter..\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous hi queue discard counter..\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0xff00;
-	if (disCtr)
-		opData.ptpData |= (disCtr<<8);
+    opData.ptpData &= ~0xff00;
+    if (disCtr)
+        opData.ptpData |= (disCtr<<8);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Isochronous hi queue discard counter..\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gqavGetGlobalIsoHiDisCtr
 *
 * DESCRIPTION:
-*       This routine get Isochronous hi queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous hi packets discarded 
-*		by Queue Controller.
+*        This routine get Isochronous hi queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous hi packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*       None.
+*        None.
 *
 * OUTPUTS:
-*		disCtr - upcounter of number of isochronous hi packets discarded 
+*        disCtr - upcounter of number of isochronous hi packets discarded 
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoHiDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*disCtr
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoHiDisCtr Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoHiDisCtr Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 13;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous hi queue discard counter.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous hi queue discard counter.\n"));
+        return GT_FAIL;
+    }
 
-	*disCtr = (GT_U8)(opData.ptpData>>8)&0xff;
+    *disCtr = (GT_U8)(opData.ptpData>>8)&0xff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -7479,135 +8508,136 @@ GT_STATUS gqavGetGlobalIsoHiDisCtr
 * gqavSetGlobalIsoLoDisCtr
 *
 * DESCRIPTION:
-*       This routine set Isochronous Lo queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous lo packets discarded 
-*		by Queue Controller.
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous lo packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		disCtr - upcounter of number of isochronous lo packets discarded 
+*        disCtr - upcounter of number of isochronous lo packets discarded 
 *
 * OUTPUTS:
-*       None.
+*        None.
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavSetGlobalIsoLoDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_U8		disCtr
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U8        disCtr
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavSetGlobalIsoLoDisCtr Called.\n"));
+    DBG_INFO(("gqavSetGlobalIsoLoDisCtr Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 13;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
+        return GT_FAIL;
+    }
 
-	op = PTP_WRITE_DATA;
+    op = PTP_WRITE_DATA;
 
-	opData.ptpData &= ~0xff;
-	opData.ptpData |= (disCtr&0xff);
+    opData.ptpData &= ~0xff;
+    opData.ptpData |= (disCtr&0xff);
 
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
         DBG_INFO(("Failed writing Isochronous lo queue discard counter.\n"));
-		return GT_FAIL;
-	}
+        return GT_FAIL;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
+
 /*******************************************************************************
 * gqavGetGlobalIsoLoDisCtr
 *
 * DESCRIPTION:
-*       This routine set Isochronous Lo queue discard counter.
-*		This field is updated by hardware when instructed to do so by 
-*		enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
-*		This is an upcounter of number of isochronous lo packets discarded 
-*		by Queue Controller.
+*        This routine set Isochronous Lo queue discard counter.
+*        This field is updated by hardware when instructed to do so by 
+*        enabling the IsoMonEn bit in Qav Global Status Register Offset 0xD. 
+*        This is an upcounter of number of isochronous lo packets discarded 
+*        by Queue Controller.
 *
 * INPUTS:
-*		None
+*        None.
 *
 * OUTPUTS:
-*		disCtr - upcounter of number of isochronous lo packets discarded 
+*        disCtr - upcounter of number of isochronous lo packets discarded 
 *
 * RETURNS:
-*       GT_OK      - on success
-*       GT_FAIL    - on error
-*       GT_BAD_PARAM - if input parameters are beyond range.
-*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM - if input parameters are beyond range.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*       None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gqavGetGlobalIsoLoDisCtr
 (
-	IN  GT_QD_DEV 	*dev,
-	OUT GT_U8		*disCtr
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U8        *disCtr
 )
 {
-	GT_STATUS       	retVal;
-	GT_PTP_OPERATION	op;
-	GT_PTP_OP_DATA		opData;
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
 
-	DBG_INFO(("gqavGetGlobalIsoLoDisCtr Called.\n"));
+    DBG_INFO(("gqavGetGlobalIsoLoDisCtr Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAV))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	opData.ptpBlock = 0x2;	/* QAV register space */
-	opData.ptpAddr = 13;
+    opData.ptpBlock = 0x2;    /* QAV register space */
+    opData.ptpAddr = 13;
 
-	opData.ptpPort = 0xF;
+    opData.ptpPort = 0xF;
 
-	op = PTP_READ_DATA;
-	if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
-	{
-		DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
-		return GT_FAIL;
-	}
+    op = PTP_READ_DATA;
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading Isochronous lo queue discard counter.\n"));
+        return GT_FAIL;
+    }
 
-	*disCtr = (GT_U8)(opData.ptpData)&0xff;
+    *disCtr = (GT_U8)(opData.ptpData)&0xff;
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTPHidden.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTPHidden.c
new file mode 100755
index 0000000..2931a94
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPTPHidden.c
@@ -0,0 +1,271 @@
+/* Hidden APIs */
+
+
+/*******************************************************************************
+* gtaiGetSocClkPer
+*
+* DESCRIPTION:
+*         SoC clock period
+*        This specifies clock period for the clock that gets generated from the 
+*        PTP block to the reset of the SoC. The period is specified in TSClkPer 
+*        increments
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        clkPer    - clock period
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetSocClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *clkPer
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetTimeIncAmt Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 6;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    *clkPer = (GT_U32)(opData.ptpData & 0x1FF);
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetSocClkPer
+*
+* DESCRIPTION:
+*         SoC clock period
+*        This specifies clock period for the clock that gets generated from the 
+*        PTP block to the reset of the SoC. The period is specified in TSClkPer 
+*        increments
+*
+* INPUTS:
+*        clkPer    - clock period
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetSocClkPer
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        clkPer
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetSocClkPer Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 6;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    op = PTP_WRITE_DATA;
+    opData.ptpData &= ~0x1FF;
+    opData.ptpData |= (clkPer & 0x1FF);
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiGetSocClkComp
+*
+* DESCRIPTION:
+*        Soc clock compensation amount in pico seconds.
+*        This field specifies the remainder amount for when the clock is being 
+*        generated with a period specifed by the clkPer. The hardware logic keeps 
+*        track of the remainder for every clock tick generation and compensates for it.
+*
+* INPUTS:
+*         None.
+*
+* OUTPUTS:
+*        amount    - clock compensation amount in pico seconds
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiGetSocClkComp
+(
+    IN  GT_QD_DEV     *dev,
+    OUT GT_U32        *amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiGetSocClkComp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_READ_DATA;
+
+    opData.ptpAddr = 7;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed reading TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    *amount = (GT_U32)opData.ptpData;
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gtaiSetSocClkComp
+*
+* DESCRIPTION:
+*        Soc clock compensation amount in pico seconds.
+*        This field specifies the remainder amount for when the clock is being 
+*        generated with a period specifed by the clkPer. The hardware logic keeps 
+*        track of the remainder for every clock tick generation and compensates for it.
+*
+* INPUTS:
+*        amount    - clock compensation amount in pico seconds
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK      - on success
+*         GT_FAIL    - on error
+*         GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*         None
+*
+*******************************************************************************/
+GT_STATUS gtaiSetSocClkComp
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        amount
+)
+{
+    GT_STATUS           retVal;
+    GT_PTP_OPERATION    op;
+    GT_PTP_OP_DATA        opData;
+
+    DBG_INFO(("gtaiSetSocClkComp Called.\n"));
+
+#ifndef CONFIG_AVB_FPGA
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAI))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+#endif
+
+    opData.ptpBlock = 0x0;    /* PTP register space */
+
+    opData.ptpPort = 0xE;    /* TAI register */
+    op = PTP_WRITE_DATA;
+
+    opData.ptpAddr = 7;
+
+    opData.ptpData = (GT_U16)amount;
+
+    if((retVal = ptpOperationPerform(dev, op, &opData)) != GT_OK)
+    {
+        DBG_INFO(("Failed writing TAI register.\n"));
+        return GT_FAIL;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c
old mode 100644
new mode 100755
index 23085de..cca6be3
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl.c
@@ -19,6 +19,9 @@
 #include <gtDrvSwRegs.h>
 #include <gtVct.h>
 #include <gtSem.h>
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
 
 /*
  * This routine set Auto-Negotiation Ad Register for Fast Ethernet Phy
@@ -26,69 +29,69 @@
 static 
 GT_STATUS feSetAutoMode
 (
-	IN GT_QD_DEV *dev,
-	IN GT_U8 	 hwPort,
-	IN GT_PHY_INFO	 *phyInfo,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV *dev,
+    IN GT_U8      hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
 )
 {
-    GT_U16 			u16Data;
+    GT_U16             u16Data;
 
-	GT_UNUSED_PARAM(phyInfo);
+    GT_UNUSED_PARAM(phyInfo);
 
     DBG_INFO(("feSetAutoMode Called.\n"));
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-   	    return GT_FAIL;
-	}
-
-	/* Mask out all auto mode related bits. */
-	u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
-
-	switch(mode)
-	{
-		case SPEED_AUTO_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_AUTO_AUTO;
-				break;
-		case SPEED_100_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_100_AUTO;
-				break;
-		case SPEED_10_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_10_AUTO;
-				break;
-		case SPEED_AUTO_DUPLEX_FULL:
-				u16Data |= QD_PHY_MODE_AUTO_FULL;
-				break;
-		case SPEED_AUTO_DUPLEX_HALF:
-				u16Data |= QD_PHY_MODE_AUTO_HALF;
-				break;
-		case SPEED_100_DUPLEX_FULL:
-				u16Data |= QD_PHY_100_FULL;
-				break;
-		case SPEED_100_DUPLEX_HALF:
-				u16Data |= QD_PHY_100_HALF;
-				break;
-		case SPEED_10_DUPLEX_FULL:
-				u16Data |= QD_PHY_10_FULL;
-				break;
-		case SPEED_10_DUPLEX_HALF:
-				u16Data |= QD_PHY_10_HALF;
-				break;
-		default:
-	 	        DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
-				return GT_BAD_PARAM;
-	}
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_AUTO_AUTO;
+                break;
+        case SPEED_100_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_100_AUTO;
+                break;
+        case SPEED_10_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_10_AUTO;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+                u16Data |= QD_PHY_MODE_AUTO_FULL;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+                u16Data |= QD_PHY_MODE_AUTO_HALF;
+                break;
+        case SPEED_100_DUPLEX_FULL:
+                u16Data |= QD_PHY_100_FULL;
+                break;
+        case SPEED_100_DUPLEX_HALF:
+                u16Data |= QD_PHY_100_HALF;
+                break;
+        case SPEED_10_DUPLEX_FULL:
+                u16Data |= QD_PHY_10_FULL;
+                break;
+        case SPEED_10_DUPLEX_HALF:
+                u16Data |= QD_PHY_10_HALF;
+                break;
+        default:
+                 DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
 
     /* Write to Phy AutoNegotiation Advertisement Register.  */
     if(hwWritePhyReg(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
-   	    return GT_FAIL;
-	}
+           return GT_FAIL;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*
@@ -97,93 +100,93 @@ GT_STATUS feSetAutoMode
 static 
 GT_STATUS gigCopperSetAutoMode
 (
-	IN GT_QD_DEV *dev,
-	IN GT_U8 hwPort,
-	IN GT_PHY_INFO	 *phyInfo,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
 )
 {
-    GT_U16 			u16Data,u16Data1;
+    GT_U16             u16Data,u16Data1;
 
     DBG_INFO(("gigCopperSetAutoMode Called.\n"));
 
     if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-   	    return GT_FAIL;
-	}
+           return GT_FAIL;
+    }
 
-	/* Mask out all auto mode related bits. */
-	u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~QD_PHY_MODE_AUTO_AUTO;
 
     if(hwReadPagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_1000AD_REG,phyInfo->anyPage,&u16Data1) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-   	    return GT_FAIL;
-	}
-
-	/* Mask out all auto mode related bits. */
-	u16Data1 &= ~(QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF);
-
-	switch(mode)
-	{
-		case SPEED_AUTO_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_AUTO_AUTO;
-		case SPEED_1000_DUPLEX_AUTO:
-				u16Data1 |= QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF;
-				break;
-		case SPEED_AUTO_DUPLEX_FULL:
-				u16Data  |= QD_PHY_MODE_AUTO_FULL;
-				u16Data1 |= QD_GIGPHY_1000T_FULL;
-				break;
-		case SPEED_1000_DUPLEX_FULL:
-				u16Data1 |= QD_GIGPHY_1000T_FULL;
-				break;
-		case SPEED_1000_DUPLEX_HALF:
-				u16Data1 |= QD_GIGPHY_1000T_HALF;
-				break;
-		case SPEED_AUTO_DUPLEX_HALF:
-				u16Data  |= QD_PHY_MODE_AUTO_HALF;
-				u16Data1 |= QD_GIGPHY_1000T_HALF;
-				break;
-		case SPEED_100_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_100_AUTO;
-				break;
-		case SPEED_10_DUPLEX_AUTO:
-				u16Data |= QD_PHY_MODE_10_AUTO;
-				break;
-		case SPEED_100_DUPLEX_FULL:
-				u16Data |= QD_PHY_100_FULL;
-				break;
-		case SPEED_100_DUPLEX_HALF:
-				u16Data |= QD_PHY_100_HALF;
-				break;
-		case SPEED_10_DUPLEX_FULL:
-				u16Data |= QD_PHY_10_FULL;
-				break;
-		case SPEED_10_DUPLEX_HALF:
-				u16Data |= QD_PHY_10_HALF;
-				break;
-		default:
-				DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
-				return GT_BAD_PARAM;
-	}
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data1 &= ~(QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF);
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_AUTO_AUTO;
+        case SPEED_1000_DUPLEX_AUTO:
+                u16Data1 |= QD_GIGPHY_1000T_FULL|QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+                u16Data  |= QD_PHY_MODE_AUTO_FULL;
+                u16Data1 |= QD_GIGPHY_1000T_FULL;
+                break;
+        case SPEED_1000_DUPLEX_FULL:
+                u16Data1 |= QD_GIGPHY_1000T_FULL;
+                break;
+        case SPEED_1000_DUPLEX_HALF:
+                u16Data1 |= QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+                u16Data  |= QD_PHY_MODE_AUTO_HALF;
+                u16Data1 |= QD_GIGPHY_1000T_HALF;
+                break;
+        case SPEED_100_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_100_AUTO;
+                break;
+        case SPEED_10_DUPLEX_AUTO:
+                u16Data |= QD_PHY_MODE_10_AUTO;
+                break;
+        case SPEED_100_DUPLEX_FULL:
+                u16Data |= QD_PHY_100_FULL;
+                break;
+        case SPEED_100_DUPLEX_HALF:
+                u16Data |= QD_PHY_100_HALF;
+                break;
+        case SPEED_10_DUPLEX_FULL:
+                u16Data |= QD_PHY_10_FULL;
+                break;
+        case SPEED_10_DUPLEX_HALF:
+                u16Data |= QD_PHY_10_HALF;
+                break;
+        default:
+                DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
 
     /* Write to Phy AutoNegotiation Advertisement Register.  */
     if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
-   	    return GT_FAIL;
-	}
+           return GT_FAIL;
+    }
 
     /* Write to Phy AutoNegotiation 1000B Advertisement Register.  */
     if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_AUTONEGO_1000AD_REG,phyInfo->anyPage,u16Data1) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-   	    return GT_FAIL;
-	}
+           return GT_FAIL;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*
@@ -192,52 +195,52 @@ GT_STATUS gigCopperSetAutoMode
 static 
 GT_STATUS gigFiberSetAutoMode
 (
-	IN GT_QD_DEV *dev,
-	IN GT_U8 hwPort,
-	IN GT_PHY_INFO	 *phyInfo,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO     *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
 )
 {
-    GT_U16 			u16Data;
+    GT_U16             u16Data;
 
     DBG_INFO(("gigPhySetAutoMode Called.\n"));
 
     if(hwReadPagedPhyReg(dev,hwPort,1,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-   	    return GT_FAIL;
-	}
-
-	/* Mask out all auto mode related bits. */
-	u16Data &= ~(QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF);
-
-	switch(mode)
-	{
-		case SPEED_AUTO_DUPLEX_AUTO:
-		case SPEED_1000_DUPLEX_AUTO:
-				u16Data |= QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF;
-				break;
-		case SPEED_AUTO_DUPLEX_FULL:
-		case SPEED_1000_DUPLEX_FULL:
-				u16Data |= QD_GIGPHY_1000X_FULL;
-				break;
-		case SPEED_AUTO_DUPLEX_HALF:
-		case SPEED_1000_DUPLEX_HALF:
-				u16Data |= QD_GIGPHY_1000X_HALF;
-				break;
-		default:
-	 	       	DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
-				return GT_BAD_PARAM;
-	}
+           return GT_FAIL;
+    }
+
+    /* Mask out all auto mode related bits. */
+    u16Data &= ~(QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF);
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+        case SPEED_1000_DUPLEX_AUTO:
+                u16Data |= QD_GIGPHY_1000X_FULL|QD_GIGPHY_1000X_HALF;
+                break;
+        case SPEED_AUTO_DUPLEX_FULL:
+        case SPEED_1000_DUPLEX_FULL:
+                u16Data |= QD_GIGPHY_1000X_FULL;
+                break;
+        case SPEED_AUTO_DUPLEX_HALF:
+        case SPEED_1000_DUPLEX_HALF:
+                u16Data |= QD_GIGPHY_1000X_HALF;
+                break;
+        default:
+                    DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+                return GT_BAD_PARAM;
+    }
 
     /* Write to Phy AutoNegotiation Advertisement Register.  */
     if(hwWritePagedPhyReg(dev,hwPort,1,QD_PHY_AUTONEGO_AD_REG,phyInfo->anyPage,u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
-   	    return GT_FAIL;
-	}
+           return GT_FAIL;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*
@@ -246,78 +249,78 @@ GT_STATUS gigFiberSetAutoMode
 static 
 GT_STATUS phySetAutoMode
 (
-	IN GT_QD_DEV *dev,
-	IN GT_U8 hwPort,
-	IN GT_PHY_INFO *phyInfo,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
 )
 {
-    GT_U16 		u16Data;
-	GT_STATUS	status;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
+    GT_U16         u16Data;
+    GT_STATUS    status;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
 
     DBG_INFO(("phySetAutoMode Called.\n"));
 
-	if (!(phyInfo->flag & GT_PHY_GIGABIT))
-	{
-		if((status=feSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
-		{
-   		    return status;
-		}
-
-		u16Data = QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
-
-    	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
-        	      hwPort,QD_PHY_CONTROL_REG,u16Data));
-
-		/* soft reset */
-		return hwPhyReset(dev,hwPort,u16Data);
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo->pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		return GT_FAIL;
-	}
-
-	if(phyInfo->flag & GT_PHY_COPPER)
-	{
-		if((status=gigCopperSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
-		{
-   		    return status;
-		}
-
-		u16Data = QD_PHY_AUTONEGO;
-
-    	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
-        	      hwPort,QD_PHY_CONTROL_REG,u16Data));
-
-	    /* Write to Phy Control Register.  */
-	    if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
-    		return GT_FAIL;
-	}
-	else if(phyInfo->flag & GT_PHY_FIBER)
-	{
-		if((status=gigFiberSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
-		{
-   		    return status;
-		}
-		u16Data = QD_PHY_AUTONEGO;
-
-    	DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
-        	      hwPort,QD_PHY_CONTROL_REG,u16Data));
-
-	    /* Write to Phy Control Register.  */
-	    if(hwWritePagedPhyReg(dev,hwPort,1,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
-    		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo->pageType,autoOn,pageReg) != GT_OK)
-	{
-		return GT_FAIL;
-	}
-
-	return hwPhyReset(dev,hwPort,0xFF);
+    if (!(phyInfo->flag & GT_PHY_GIGABIT))
+    {
+        if((status=feSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+
+        u16Data = QD_PHY_SPEED | QD_PHY_DUPLEX | QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* soft reset */
+        return hwPhyReset(dev,hwPort,u16Data);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo->pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    if(phyInfo->flag & GT_PHY_COPPER)
+    {
+        if((status=gigCopperSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+
+        u16Data = QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* Write to Phy Control Register.  */
+        if(hwWritePagedPhyReg(dev,hwPort,0,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
+            return GT_FAIL;
+    }
+    else if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((status=gigFiberSetAutoMode(dev,hwPort,phyInfo,mode)) != GT_OK)
+        {
+               return status;
+        }
+        u16Data = QD_PHY_AUTONEGO;
+
+        DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+                  hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+        /* Write to Phy Control Register.  */
+        if(hwWritePagedPhyReg(dev,hwPort,1,QD_PHY_CONTROL_REG,phyInfo->anyPage,u16Data) != GT_OK)
+            return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo->pageType,autoOn,pageReg) != GT_OK)
+    {
+        return GT_FAIL;
+    }
+
+    return hwPhyReset(dev,hwPort,0xFF);
 }
 
 
@@ -326,7 +329,7 @@ GT_STATUS phySetAutoMode
 *
 * DESCRIPTION:
 *       This routine preforms PHY reset.
-*		After reset, phy will be in Autonegotiation mode.
+*        After reset, phy will be in Autonegotiation mode.
 *
 * INPUTS:
 * port - The logical port number, unless SERDES device is accessed
@@ -347,49 +350,54 @@ GT_STATUS phySetAutoMode
 
 GT_STATUS gprtPhyReset
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
 )
 {
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_PHY_INFO		phyInfo;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtPhyReset_mad(dev, port);
+#endif
 
     DBG_INFO(("gprtPhyReset Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
 
-	/* set Auto Negotiation AD Register */
-	retVal = phySetAutoMode(dev,hwPort,&phyInfo,SPEED_AUTO_DUPLEX_AUTO);
+    /* set Auto Negotiation AD Register */
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,SPEED_AUTO_DUPLEX_AUTO);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	gtSemGive(dev,dev->phyRegsSem);
+    gtSemGive(dev,dev->phyRegsSem);
 
     return retVal;
 }
@@ -434,77 +442,82 @@ GT_STATUS gprtPhyReset
 
 GT_STATUS gprtSetPortLoopback
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-	IN GT_BOOL   enable
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
-	GT_PHY_INFO		phyInfo;
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPortLoopback_mad(dev, port, enable);
+#endif
 
     DBG_INFO(("gprtSetPortLoopback Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
-	}
-
-	/* is this Fast Ethernet Phy? */
-	if (!(phyInfo.flag & GT_PHY_GIGABIT))
-	{
-		if(enable)
-		{
-			if(u16Data & QD_PHY_AUTONEGO)
-			{
-				/* disable Auto-Neg and force speed to be 10Mbps */
-				u16Data = u16Data & QD_PHY_DUPLEX;
-
-				if((retVal=hwPhyReset(dev,hwPort,u16Data)) != GT_OK)
-				{
-					DBG_INFO(("Softreset failed.\n"));
-					gtSemGive(dev,dev->phyRegsSem);
-					return retVal;
-				}
-			}
-		}
-	}
-
-	BOOL_2_BIT(enable,u16Data);
+    }
+
+    /* is this Fast Ethernet Phy? */
+    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if(enable)
+        {
+            if(u16Data & QD_PHY_AUTONEGO)
+            {
+                /* disable Auto-Neg and force speed to be 10Mbps */
+                u16Data = u16Data & QD_PHY_DUPLEX;
+
+                if((retVal=hwPhyReset(dev,hwPort,u16Data)) != GT_OK)
+                {
+                    DBG_INFO(("Softreset failed.\n"));
+                    gtSemGive(dev,dev->phyRegsSem);
+                    return retVal;
+                }
+            }
+        }
+    }
+
+    BOOL_2_BIT(enable,u16Data);
 
     /* Write to Phy Control Register.  */
     retVal = hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,14,1,u16Data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
-	gtSemGive(dev,dev->phyRegsSem);
+    }
+    gtSemGive(dev,dev->phyRegsSem);
     return retVal;
 }
 
@@ -513,17 +526,17 @@ GT_STATUS gprtSetPortLoopback
 * gprtSetPortSpeed
 *
 * DESCRIPTION:
-* 		Sets speed for a specific logical port. This function will keep the duplex 
-*		mode and loopback mode to the previous value, but disable others, such as 
-*		Autonegotiation.
+*         Sets speed for a specific logical port. This function will keep the duplex 
+*        mode and loopback mode to the previous value, but disable others, such as 
+*        Autonegotiation.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-*		speed - port speed.
-*				PHY_SPEED_10_MBPS for 10Mbps
-*				PHY_SPEED_100_MBPS for 100Mbps
-*				PHY_SPEED_1000_MBPS for 1000Mbps
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
 *
 * OUTPUTS:
 * None.
@@ -546,70 +559,75 @@ IN GT_PHY_SPEED speed
 )
 {
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
-	GT_PHY_INFO		phyInfo;
-	GT_STATUS		retVal;
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPortSpeed_mad(dev, port, speed);
+#endif
 
     DBG_INFO(("gprtSetPortSpeed Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
-	}
-
-	switch(speed)
-	{
-		case PHY_SPEED_10_MBPS:
-			if ((phyInfo.flag & GT_PHY_GIGABIT) && !(phyInfo.flag & GT_PHY_COPPER))
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_BAD_PARAM;
-			}
-			u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX);
-			break;
-		case PHY_SPEED_100_MBPS:
-			u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED;
-			break;
-		case PHY_SPEED_1000_MBPS:
-			if (!(phyInfo.flag & GT_PHY_GIGABIT))
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_BAD_PARAM;
-			}
-			u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED_MSB;
-			break;
-		default:
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-	}
+    }
+
+    switch(speed)
+    {
+        case PHY_SPEED_10_MBPS:
+            if ((phyInfo.flag & GT_PHY_GIGABIT) && !(phyInfo.flag & GT_PHY_COPPER))
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+            }
+            u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX);
+            break;
+        case PHY_SPEED_100_MBPS:
+            u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED;
+            break;
+        case PHY_SPEED_1000_MBPS:
+            if (!(phyInfo.flag & GT_PHY_GIGABIT))
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+            }
+            u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_DUPLEX)) | QD_PHY_SPEED_MSB;
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+    }
 
     DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
               hwPort,QD_PHY_CONTROL_REG,u16Data));
 
-	retVal = hwPhyReset(dev,hwPort,u16Data);
-  	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+      gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -617,101 +635,106 @@ IN GT_PHY_SPEED speed
 * gprtPortAutoNegEnable
 *
 * DESCRIPTION:
-* 		Enable/disable an Auto-Negotiation.
-*		This routine simply sets Auto Negotiation bit (bit 12) of Control 
-*		Register and reset the phy.
-*		For Speed and Duplex selection, please use gprtSetPortAutoMode.
+*         Enable/disable an Auto-Negotiation.
+*        This routine simply sets Auto Negotiation bit (bit 12) of Control 
+*        Register and reset the phy.
+*        For Speed and Duplex selection, please use gprtSetPortAutoMode.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-* 		state - GT_TRUE for enable Auto-Negotiation,
-*				GT_FALSE otherwise
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state - GT_TRUE for enable Auto-Negotiation,
+*                GT_FALSE otherwise
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.12 - Auto-Negotiation Enable
-* 		data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
 *
 *******************************************************************************/
 GT_STATUS gprtPortAutoNegEnable
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-	IN GT_BOOL   state
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
 )
 {
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
-	GT_STATUS		retVal;
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtPortAutoNegEnable_mad(dev, port, state);
+#endif
 
     DBG_INFO(("gprtPortAutoNegEnable Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
-	}
+    }
 
-	if(state)
-	{
-		u16Data = (u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX)) | QD_PHY_AUTONEGO;
-	}
-	else
-	{
-		u16Data = u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX);
-	}
+    if(state)
+    {
+        u16Data = (u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX)) | QD_PHY_AUTONEGO;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_SPEED | QD_PHY_DUPLEX);
+    }
 
 
     DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
               hwPort,QD_PHY_CONTROL_REG,u16Data));
 
-	retVal = hwPhyReset(dev,hwPort,u16Data);
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 /*******************************************************************************
 * gprtPortPowerDown
 *
 * DESCRIPTION:
-* 		Enable/disable (power down) on specific logical port.
-*		Phy configuration remains unchanged after Power down.
+*         Enable/disable (power down) on specific logical port.
+*        Phy configuration remains unchanged after Power down.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-* 		state -	GT_TRUE: power down
-* 				GT_FALSE: normal operation
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state -    GT_TRUE: power down
+*                 GT_FALSE: normal operation
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.11 - Power Down
+*         data sheet register 0.11 - Power Down
 *
 *******************************************************************************/
 
@@ -724,55 +747,60 @@ IN GT_BOOL   state
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
+    GT_U16             u16Data;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtPortPowerDown_mad(dev, port, state);
+#endif
 
     DBG_INFO(("gprtPortPowerDown Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
-	BOOL_2_BIT(state,u16Data);
+    BOOL_2_BIT(state,u16Data);
 
-	if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,11,1,u16Data)) != GT_OK)
-	{
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,11,1,u16Data)) != GT_OK)
+    {
         DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return retVal;
-	}
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
 
-	gtSemGive(dev,dev->phyRegsSem);
-	return GT_OK;
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gprtPortRestartAutoNeg
 *
 * DESCRIPTION:
-* 		Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
-*		it. Loopback and Power Down will be disabled by this routine.
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+*        it. Loopback and Power Down will be disabled by this routine.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.9 - Restart Auto-Negotiation
+*         data sheet register 0.9 - Restart Auto-Negotiation
 *
 *******************************************************************************/
 
@@ -784,47 +812,52 @@ IN GT_LPORT  port
 {
     GT_STATUS       retVal;      
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
+    GT_U16             u16Data;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtPortRestartAutoNeg_mad(dev, port);
+#endif
 
     DBG_INFO(("gprtPortRestartAutoNeg Called.\n"));
   
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
-	}
+    }
 
-	u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
-	u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+    u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+    u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
 
     DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
               hwPort,QD_PHY_CONTROL_REG,u16Data));
 
     /* Write to Phy Control Register.  */
     retVal = hwWritePhyReg(dev,hwPort,QD_PHY_CONTROL_REG,u16Data);
-	gtSemGive(dev,dev->phyRegsSem);
+    gtSemGive(dev,dev->phyRegsSem);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -832,24 +865,24 @@ IN GT_LPORT  port
 * gprtSetPortDuplexMode
 *
 * DESCRIPTION:
-* 		Sets duplex mode for a specific logical port. This function will keep 
-*		the speed and loopback mode to the previous value, but disable others,
-*		such as Autonegotiation.
+*         Sets duplex mode for a specific logical port. This function will keep 
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-* 		dMode	- dulpex mode
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         dMode    - dulpex mode
 *
 * OUTPUTS:
-* 		None.
+*         None.
 *
 * RETURNS:
-* 		GT_OK 	- on success
-* 		GT_FAIL 	- on error
+*         GT_OK     - on success
+*         GT_FAIL     - on error
 *
 * COMMENTS:
-* 		data sheet register 0.8 - Duplex Mode
+*         data sheet register 0.8 - Duplex Mode
 *
 *******************************************************************************/
 GT_STATUS gprtSetPortDuplexMode
@@ -860,47 +893,52 @@ IN GT_BOOL   dMode
 )
 {
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
-	GT_STATUS		retVal;
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPortDuplexMode_mad(dev, port, dMode);
+#endif
 
     DBG_INFO(("gprtSetPortDuplexMode Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
     if(hwReadPhyReg(dev,hwPort,QD_PHY_CONTROL_REG,&u16Data) != GT_OK)
-	{
+    {
         DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
-	}
+    }
 
-	if(dMode)
-	{
-		u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB)) | QD_PHY_DUPLEX;
-	}
-	else
-	{
-		u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB);
-	}
+    if(dMode)
+    {
+        u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB)) | QD_PHY_DUPLEX;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB);
+    }
 
 
     DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
               hwPort,QD_PHY_CONTROL_REG,u16Data));
 
     /* Write to Phy Control Register.  */
-	retVal = hwPhyReset(dev,hwPort,u16Data);
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    retVal = hwPhyReset(dev,hwPort,u16Data);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -908,80 +946,85 @@ IN GT_BOOL   dMode
 * gprtSetPortAutoMode
 *
 * DESCRIPTION:
-* 		This routine sets up the port with given Auto Mode.
-*		Supported mode is as follows:
-*		- Auto for both speed and duplex.
-*		- Auto for speed only and Full duplex.
-*		- Auto for speed only and Half duplex.
-*		- Auto for duplex only and speed 1000Mbps.
-*		- Auto for duplex only and speed 100Mbps.
-*		- Auto for duplex only and speed 10Mbps.
-*		- Speed 1000Mbps and Full duplex.
-*		- Speed 1000Mbps and Half duplex.
-*		- Speed 100Mbps and Full duplex.
-*		- Speed 100Mbps and Half duplex.
-*		- Speed 10Mbps and Full duplex.
-*		- Speed 10Mbps and Half duplex.
-*		
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*        
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-* 		mode - Auto Mode to be written
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         mode - Auto Mode to be written
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - on device without copper
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
 *
 * COMMENTS:
-* 		data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
-* 		data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
-* 		data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
 *******************************************************************************/
 
 GT_STATUS gprtSetPortAutoMode
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-	IN GT_PHY_AUTO_MODE mode
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
 )
 {
 
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_PHY_INFO		phyInfo;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
 
-	DBG_INFO(("gprtSetPortAutoMode Called.\n"));
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPortAutoMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSetPortAutoMode Called.\n"));
     
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
 
-	retVal = GT_NOT_SUPPORTED;
+    retVal = GT_NOT_SUPPORTED;
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
 
-	retVal = phySetAutoMode(dev,hwPort,&phyInfo,mode);
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,mode);
 
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 
 }
 
@@ -991,16 +1034,16 @@ GT_STATUS gprtSetPortAutoMode
 *
 * DESCRIPTION:
 *       This routine will set the pause bit in Autonegotiation Advertisement
-*		Register. And restart the autonegotiation.
+*        Register. And restart the autonegotiation.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
-*		state - GT_PHY_PAUSE_MODE enum value.
-*				GT_PHY_NO_PAUSE		- disable pause
-* 				GT_PHY_PAUSE		- support pause
-*				GT_PHY_ASYMMETRIC_PAUSE	- support asymmetric pause
-*				GT_PHY_BOTH_PAUSE	- support both pause and asymmetric pause
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE        - disable pause
+*                 GT_PHY_PAUSE        - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
 *
 * OUTPUTS:
 *       None.
@@ -1019,70 +1062,75 @@ IN GT_LPORT  port,
 IN GT_PHY_PAUSE_MODE state
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data,regStart;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO		phyInfo;
-
-	DBG_INFO(("phySetPause Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	regStart = 10;
-
-	if(state & GT_PHY_ASYMMETRIC_PAUSE)
-	{
-		if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-		{
-	    	DBG_INFO(("Unknown PHY device.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-
-		if (!(phyInfo.flag & GT_PHY_GIGABIT))
-		{
-			DBG_INFO(("Not Supported\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_BAD_PARAM;
-		}
-
-		if(!(phyInfo.flag & GT_PHY_COPPER))
-		{
-			regStart = 7;
-		}
-
-	}
-
-	u16Data = state;
-
-	/* Write to Phy AutoNegotiation Advertisement Register.  */
-	if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,(GT_U8)regStart,2,u16Data)) != GT_OK)
-	{
-		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	/* Restart Auto Negotiation */
-	if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
-	{
-		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data,regStart;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPause_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("phySetPause Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    regStart = 10;
+
+    if(state & GT_PHY_ASYMMETRIC_PAUSE)
+    {
+        if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+        {
+            DBG_INFO(("Unknown PHY device.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if (!(phyInfo.flag & GT_PHY_GIGABIT))
+        {
+            DBG_INFO(("Not Supported\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_BAD_PARAM;
+        }
+
+        if(!(phyInfo.flag & GT_PHY_COPPER))
+        {
+            regStart = 7;
+        }
+
+    }
+
+    u16Data = state;
+
+    /* Write to Phy AutoNegotiation Advertisement Register.  */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_AUTONEGO_AD_REG,(GT_U8)regStart,2,u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_AUTONEGO_AD_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Restart Auto Negotiation */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_AUTONEGO_AD_REG,u16Data));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -1093,86 +1141,86 @@ GT_STATUS dteWorkAround_Phy100M
     IN  GT_U8            hwPort
 )
 {
-	GT_STATUS status = GT_OK;
-	GT_U32 threshold[] = {0x000B,0x0000,0x8780,0x0000,0x8F80,0x0000,
-						  0x9780,0x0000,0x9F80,0x0000,0xA780,0x0000,
-						  0xAF80,0x0000,0xB780,0x0000,0xBF80,0x0000,
-						  0xC780,0x0000,0xCF80,0x0000,0xD780,0x0000,
-						  0xDF80,0x0000,0xE780,0x0000,0xEF80,0x0000,
-						  0xF780,0x0000,0xFF80,0x0000};
-	int i, thresholdSize;
-
-	/* force r125 clock */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x807f)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* write thresholds */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000B)) != GT_OK)
-	{
-		return status;
-	}
-
-	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
-
-	for(i=0; i<thresholdSize; i++)
-	{
-		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
-		{
-			return status;
-		}
-	}
-
-	/* setting adc Masking */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0001)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4000)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* setting noise level */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0005)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xA000)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* 
-		offseting cable length measurement by 6.72m(2*4*0.84m)
-		set 30_10.14:11 to 0x1001 for cable length measure.
-	*/ 
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000a)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4840)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* release force r125 clock */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x0000)) != GT_OK)
-	{
-		return status;
-	}
-
-
-	return status;
+    GT_STATUS status = GT_OK;
+    GT_U32 threshold[] = {0x000B,0x0000,0x8780,0x0000,0x8F80,0x0000,
+                          0x9780,0x0000,0x9F80,0x0000,0xA780,0x0000,
+                          0xAF80,0x0000,0xB780,0x0000,0xBF80,0x0000,
+                          0xC780,0x0000,0xCF80,0x0000,0xD780,0x0000,
+                          0xDF80,0x0000,0xE780,0x0000,0xEF80,0x0000,
+                          0xF780,0x0000,0xFF80,0x0000};
+    int i, thresholdSize;
+
+    /* force r125 clock */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x807f)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* write thresholds */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000B)) != GT_OK)
+    {
+        return status;
+    }
+
+    thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+    for(i=0; i<thresholdSize; i++)
+    {
+        if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    /* setting adc Masking */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0001)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4000)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* setting noise level */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0005)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xA000)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* 
+        offseting cable length measurement by 6.72m(2*4*0.84m)
+        set 30_10.14:11 to 0x1001 for cable length measure.
+    */ 
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x000a)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x4840)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* release force r125 clock */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0003)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x0000)) != GT_OK)
+    {
+        return status;
+    }
+
+
+    return status;
 }
 
 static
@@ -1182,72 +1230,72 @@ GT_STATUS dteWorkAround_Phy1000M
     IN  GT_U8            hwPort
 )
 {
-	GT_STATUS status = GT_OK;
-	GT_U32 threshold[] = {0x0000,0x8780,0x0000,0x8F80,0x0000,0x9780,
-						  0x0000,0x9F80,0x0000,0xA780,0x0000,0xAF80,
-						  0x0000,0xB780,0x0000,0xBF80,0x0000,0xC780,
-						  0x0000,0xCF80,0x0000,0xD780,0x0000,0xDF80,
-						  0x0000,0xE780,0x0000,0xEF80,0x0000,0xF780,
-						  0x0000,0xFF80,0x0000};
-	int i, thresholdSize;
-
-	/*  */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001B)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x43FF)) != GT_OK)
-	{
-		return status;
-	}
-
-	/*  */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001C)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0x9999)) != GT_OK)
-	{
-		return status;
-	}
-
-	/*  */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001F)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xE00C)) != GT_OK)
-	{
-		return status;
-	}
-
-	/*  */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0018)) != GT_OK)
-	{
-		return status;
-	}
-	if((status= hwWritePhyReg(dev,hwPort,0x1E,0xFFA1)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* write thresholds */
-	if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0010)) != GT_OK)
-	{
-		return status;
-	}
-
-	thresholdSize = sizeof(threshold)/sizeof(GT_U32);
-
-	for(i=0; i<thresholdSize; i++)
-	{
-		if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
-		{
-			return status;
-		}
-	}
-
-	return status;
+    GT_STATUS status = GT_OK;
+    GT_U32 threshold[] = {0x0000,0x8780,0x0000,0x8F80,0x0000,0x9780,
+                          0x0000,0x9F80,0x0000,0xA780,0x0000,0xAF80,
+                          0x0000,0xB780,0x0000,0xBF80,0x0000,0xC780,
+                          0x0000,0xCF80,0x0000,0xD780,0x0000,0xDF80,
+                          0x0000,0xE780,0x0000,0xEF80,0x0000,0xF780,
+                          0x0000,0xFF80,0x0000};
+    int i, thresholdSize;
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001B)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x43FF)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001C)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0x9999)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x001F)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xE00C)) != GT_OK)
+    {
+        return status;
+    }
+
+    /*  */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0018)) != GT_OK)
+    {
+        return status;
+    }
+    if((status= hwWritePhyReg(dev,hwPort,0x1E,0xFFA1)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* write thresholds */
+    if((status= hwWritePhyReg(dev,hwPort,0x1D,0x0010)) != GT_OK)
+    {
+        return status;
+    }
+
+    thresholdSize = sizeof(threshold)/sizeof(GT_U32);
+
+    for(i=0; i<thresholdSize; i++)
+    {
+        if((status= hwWritePhyReg(dev,hwPort,0x1E,(GT_U16)threshold[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return status;
 }
 
 static
@@ -1255,31 +1303,31 @@ GT_STATUS feSetDTE
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8     hwPort,
-	IN  GT_BOOL   state
+    IN  GT_BOOL   state
 )
 {
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
 
-	if((retVal = hwReadPhyReg(dev,hwPort,0x10,&u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwReadPhyReg(dev,hwPort,0x10,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	u16Data = state?(u16Data|0x8000):(u16Data&(~0x8000));
+    u16Data = state?(u16Data|0x8000):(u16Data&(~0x8000));
 
-	if((retVal = hwWritePhyReg(dev,hwPort,0x10,u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwWritePhyReg(dev,hwPort,0x10,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* soft reset */
-	if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-	{
-		return retVal;
-	}
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	return retVal;
+    return retVal;
 }
 
 static
@@ -1287,31 +1335,31 @@ GT_STATUS gigSetDTE
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8     hwPort,
-	IN  GT_BOOL   state
+    IN  GT_BOOL   state
 )
 {
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
 
-	if((retVal = hwReadPhyReg(dev,hwPort,20,&u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwReadPhyReg(dev,hwPort,20,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	u16Data = state?(u16Data|0x4):(u16Data&(~0x4));
+    u16Data = state?(u16Data|0x4):(u16Data&(~0x4));
 
-	if((retVal = hwWritePhyReg(dev,hwPort,20,u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwWritePhyReg(dev,hwPort,20,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* soft reset */
-	if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-	{
-		return retVal;
-	}
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	return retVal;
+    return retVal;
 }
 
 static
@@ -1319,31 +1367,31 @@ GT_STATUS gigMPSetDTE
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U8     hwPort,
-	IN  GT_BOOL   state
+    IN  GT_BOOL   state
 )
 {
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
 
-	if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,0,&u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,0,&u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	u16Data = state?(u16Data|0x100):(u16Data&(~0x100));
+    u16Data = state?(u16Data|0x100):(u16Data&(~0x100));
 
-	if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,0,u16Data)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,0,u16Data)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* soft reset */
-	if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-	{
-		return retVal;
-	}
+    /* soft reset */
+    if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	return retVal;
+    return retVal;
 }
 
 /*******************************************************************************
@@ -1353,8 +1401,8 @@ GT_STATUS gigMPSetDTE
 *       This routine enables/disables DTE.
 *
 * INPUTS:
-* 		port - The logical port number
-* 		mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*         port - The logical port number
+*         mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
 *
 * OUTPUTS:
 *       None.
@@ -1369,143 +1417,148 @@ GT_STATUS gigMPSetDTE
 
 GT_STATUS gprtSetDTEDetect
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-	IN GT_BOOL   state
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("phySetDTE Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports DTE */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch(phyInfo.dteType)
-	{
-		case GT_PHY_DTE_TYPE1:
-			/* FE Phy needs work-around */
-			if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-
-			if(state == GT_FALSE)
-				break;
-
-			if((retVal = dteWorkAround_Phy100M(dev,hwPort)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			break;
-		case GT_PHY_DTE_TYPE3:
-			/* Gigabit Phy with work-around required */
-			if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-
-			if(state == GT_FALSE)
-				break;
-
-			if((retVal = dteWorkAround_Phy1000M(dev,hwPort)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			break;
-
-		case GT_PHY_DTE_TYPE2:
-			/* no workaround required */
-			if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-
-			break;
-		case GT_PHY_DTE_TYPE4:
-			/* no workaround required */
-			if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-
-			if((retVal = gigMPSetDTE(dev,hwPort,state)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-
-			if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-			break;
-		case GT_PHY_DTE_TYPE5:
-			/* FE Phy */
-			if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			break;
-
-		default:
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_NOT_SUPPORTED;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
-}
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
 
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetDTEDetect_mad(dev, port, state);
+#endif
 
-/*******************************************************************************
-* gprtGetDTEDetectStatus
-*
-* DESCRIPTION:
-*       This routine gets DTE status.
-*
+    DBG_INFO(("phySetDTE Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            /* FE Phy needs work-around */
+            if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(state == GT_FALSE)
+                break;
+
+            if((retVal = dteWorkAround_Phy100M(dev,hwPort)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+        case GT_PHY_DTE_TYPE3:
+            /* Gigabit Phy with work-around required */
+            if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(state == GT_FALSE)
+                break;
+
+            if((retVal = dteWorkAround_Phy1000M(dev,hwPort)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+
+        case GT_PHY_DTE_TYPE2:
+            /* no workaround required */
+            if((retVal = gigSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            /* no workaround required */
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = gigMPSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+            break;
+        case GT_PHY_DTE_TYPE5:
+            /* FE Phy */
+            if((retVal = feSetDTE(dev,hwPort,state)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *
 * OUTPUTS:
 *       status - GT_TRUE, if link partner needs DTE power.
-*				 GT_FALSE, otherwise.
+*                 GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1517,96 +1570,101 @@ GT_STATUS gprtSetDTEDetect
 
 GT_STATUS gprtGetDTEDetectStatus
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	OUT GT_BOOL   *state
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data,pageReg;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-
-	DBG_INFO(("gprtGetDTEStatus Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports DTE */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch(phyInfo.dteType)
-	{
-		case GT_PHY_DTE_TYPE1:
-			/* FE Phy needs work-around */
-			if((retVal = hwReadPhyReg(dev,hwPort,17,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			*state = (u16Data & 0x8000)?GT_TRUE:GT_FALSE;
-
-			break;
-		case GT_PHY_DTE_TYPE2:
-		case GT_PHY_DTE_TYPE3:
-			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			*state = (u16Data & 0x10)?GT_TRUE:GT_FALSE;
-			
-			break;
-		case GT_PHY_DTE_TYPE4:
-			if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-				
-			if((retVal = hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			*state = (u16Data & 0x4)?GT_TRUE:GT_FALSE;
-
-			if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-
-			break;
-		default:
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_NOT_SUPPORTED;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data,pageReg;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetDTEDetectStatus_mad(dev, port, state);
+#endif
+
+    DBG_INFO(("gprtGetDTEStatus Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            /* FE Phy needs work-around */
+            if((retVal = hwReadPhyReg(dev,hwPort,17,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x8000)?GT_TRUE:GT_FALSE;
+
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x10)?GT_TRUE:GT_FALSE;
+            
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+                
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            *state = (u16Data & 0x4)?GT_TRUE:GT_FALSE;
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -1615,16 +1673,16 @@ GT_STATUS gprtGetDTEDetectStatus
 *
 * DESCRIPTION:
 *       Once the PHY no longer detects that the link partner filter, the PHY
-*		will wait a period of time before clearing the power over Ethernet 
-*		detection status bit. The wait time is 5 seconds multiplied by the 
-*		given value.
+*        will wait a period of time before clearing the power over Ethernet 
+*        detection status bit. The wait time is 5 seconds multiplied by the 
+*        given value.
 *
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *       waitTime - 0 ~ 15 (unit of 4 sec.)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1636,112 +1694,117 @@ GT_STATUS gprtGetDTEDetectStatus
 
 GT_STATUS gprtSetDTEDetectDropWait
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	IN  GT_U16    waitTime
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports DTE */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch(phyInfo.dteType)
-	{
-		case GT_PHY_DTE_TYPE1:
-			if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data & ~(0xF<<12)) | ((waitTime & 0xF) << 12);
-
-			if((retVal = hwWritePhyReg(dev,hwPort,22,u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			break;
-		case GT_PHY_DTE_TYPE2:
-		case GT_PHY_DTE_TYPE3:
-			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data & ~(0xF<<5)) | ((waitTime & 0xF) << 5);
-
-			if((retVal = hwWritePhyReg(dev,hwPort,27,u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			
-			break;
-		case GT_PHY_DTE_TYPE4:
-			if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-
-			if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data & ~(0xF<<4)) | ((waitTime & 0xF) << 4);
-			if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-
-			if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-
-			break;
-		default:
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_NOT_SUPPORTED;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetDTEDetectDropWait_mad(dev, port, waitTime);
+#endif
+
+    DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<12)) | ((waitTime & 0xF) << 12);
+
+            if((retVal = hwWritePhyReg(dev,hwPort,22,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<5)) | ((waitTime & 0xF) << 5);
+
+            if((retVal = hwWritePhyReg(dev,hwPort,27,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data & ~(0xF<<4)) | ((waitTime & 0xF) << 4);
+            if((retVal = hwWritePagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -1750,12 +1813,12 @@ GT_STATUS gprtSetDTEDetectDropWait
 *
 * DESCRIPTION:
 *       Once the PHY no longer detects that the link partner filter, the PHY
-*		will wait a period of time before clearing the power over Ethernet 
-*		detection status bit. The wait time is 5 seconds multiplied by the 
-*		returned value.
+*        will wait a period of time before clearing the power over Ethernet 
+*        detection status bit. The wait time is 5 seconds multiplied by the 
+*        returned value.
 *
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *
 * OUTPUTS:
 *       waitTime - 0 ~ 15 (unit of 4 sec.)
@@ -1770,96 +1833,101 @@ GT_STATUS gprtSetDTEDetectDropWait
 
 GT_STATUS gprtGetDTEDetectDropWait
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	OUT GT_U16    *waitTime
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtSetDTEDropWait Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch(phyInfo.dteType)
-	{
-		case GT_PHY_DTE_TYPE1:
-			if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data >> 12) & 0xF;
-
-			break;
-		case GT_PHY_DTE_TYPE2:
-		case GT_PHY_DTE_TYPE3:
-			if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data >> 5) & 0xF;
-
-			break;
-		case GT_PHY_DTE_TYPE4:
-			if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-
-			if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return retVal;
-			}
-			u16Data = (u16Data >> 4) & 0xF;
-
-			if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-			{
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-			}
-			break;
-		default:
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_NOT_SUPPORTED;
-	}
-
-	*waitTime = u16Data;
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetDTEDetectDropWait_mad(dev, port, waitTime);
+#endif
+
+    DBG_INFO(("gprtSetDTEDropWait Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch(phyInfo.dteType)
+    {
+        case GT_PHY_DTE_TYPE1:
+            if((retVal = hwReadPhyReg(dev,hwPort,22,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 12) & 0xF;
+
+            break;
+        case GT_PHY_DTE_TYPE2:
+        case GT_PHY_DTE_TYPE3:
+            if((retVal = hwReadPhyReg(dev,hwPort,27,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 5) & 0xF;
+
+            break;
+        case GT_PHY_DTE_TYPE4:
+            if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+
+            if((retVal = hwReadPagedPhyReg(dev,hwPort,0,26,phyInfo.anyPage,&u16Data)) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return retVal;
+            }
+            u16Data = (u16Data >> 4) & 0xF;
+
+            if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+            {
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+            }
+            break;
+        default:
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_NOT_SUPPORTED;
+    }
+
+    *waitTime = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -1868,19 +1936,19 @@ GT_STATUS gprtGetDTEDetectDropWait
 *
 * DESCRIPTION:
 *       Energy Detect power down mode enables or disables the PHY to wake up on
-*		its own by detecting activity on the CAT 5 cable. 
+*        its own by detecting activity on the CAT 5 cable. 
 *
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *       mode - GT_EDETECT_MODE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if invalid parameter is given
+*        GT_BAD_PARAM - if invalid parameter is given
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1889,116 +1957,121 @@ GT_STATUS gprtGetDTEDetectDropWait
 
 GT_STATUS gprtSetEnergyDetect
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	IN  GT_EDETECT_MODE   mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtSetEnergyDetect Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (phyInfo.flag & GT_PHY_SERDES_CORE)
-	{
-	    DBG_INFO(("Not Supported.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-	else if (phyInfo.flag & GT_PHY_GIGABIT)
-	{
-		/* check if the mode is valid */
-		switch (mode)
-		{
-			case GT_EDETECT_OFF:
-				u16Data = 0;
-				break;
-			case GT_EDETECT_SENSE_PULSE:
-				u16Data = 3;
-				break;
-			case GT_EDETECT_SENSE:
-				u16Data = 2;
-				break;
-			default:
-			    DBG_INFO(("Invalid paramerter.\n"));
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_BAD_PARAM;
-		}
-
-		if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-
-		if((retVal = hwSetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,u16Data)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-
-		if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-
-		if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-	}
-	else	/* it's a Fast Ethernet device */
-	{
-		/* check if the mode is valid */
-		switch (mode)
-		{
-			case GT_EDETECT_OFF:
-				u16Data = 0;
-				break;
-			case GT_EDETECT_SENSE_PULSE:
-				u16Data = 1;
-				break;
-			case GT_EDETECT_SENSE:
-			default:
-			    DBG_INFO(("Invalid paramerter.\n"));
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_BAD_PARAM;
-		}
-
-		if((retVal = hwSetPhyRegField(dev,hwPort,0x10,14,1,u16Data)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetEnergyDetect_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSetEnergyDetect Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 3;
+                break;
+            case GT_EDETECT_SENSE:
+                u16Data = 2;
+                break;
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if((retVal = hwSetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if((retVal = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 1;
+                break;
+            case GT_EDETECT_SENSE:
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+        if((retVal = hwSetPhyRegField(dev,hwPort,0x10,14,1,u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -2007,10 +2080,10 @@ GT_STATUS gprtSetEnergyDetect
 *
 * DESCRIPTION:
 *       Energy Detect power down mode enables or disables the PHY to wake up on
-*		its own by detecting activity on the CAT 5 cable. 
+*        its own by detecting activity on the CAT 5 cable. 
 *
 * INPUTS:
-* 		port - The logical port number
+*         port - The logical port number
 *
 * OUTPUTS:
 *       mode - GT_EDETECT_MODE type
@@ -2026,114 +2099,119 @@ GT_STATUS gprtSetEnergyDetect
 
 GT_STATUS gprtGetEnergyDetect
 (
-	IN  GT_QD_DEV *dev,
-	IN  GT_LPORT  port,
-	OUT GT_EDETECT_MODE   *mode
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
 )
 {
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16 			u16Data;
-	GT_STATUS		retVal = GT_OK;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtGetEnergyDetect Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (phyInfo.flag & GT_PHY_SERDES_CORE)
-	{
-	    DBG_INFO(("Not Supported.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-	else if (phyInfo.flag & GT_PHY_GIGABIT)
-	{
-		/* read the mode */
-
-		if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-
-		if((retVal = hwGetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,&u16Data)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-
-		if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-
-		switch (u16Data)
-		{
-			case 0:
-			case 1:
-				*mode = GT_EDETECT_OFF;
-				break;
-			case 2:
-				*mode = GT_EDETECT_SENSE;
-				break;
-			case 3:
-				*mode = GT_EDETECT_SENSE_PULSE;
-				break;
-			default:
-			    DBG_INFO(("Unknown value (shouldn't happen).\n"));
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-		}
-
-	}
-	else	/* it's a Fast Ethernet device */
-	{
-		/* read the mode */
-		if((retVal = hwGetPhyRegField(dev,hwPort,0x10,14,1,&u16Data)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return retVal;
-		}
-
-		switch (u16Data)
-		{
-			case 0:
-				*mode = GT_EDETECT_OFF;
-				break;
-			case 1:
-				*mode = GT_EDETECT_SENSE_PULSE;
-				break;
-			default:
-			    DBG_INFO(("Unknown value (shouldn't happen).\n"));
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-		}
-
-	}
-
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetEnergyDetect_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtGetEnergyDetect Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* read the mode */
+
+        if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if((retVal = hwGetPagedPhyRegField(dev,hwPort,0,0x10,8,2,phyInfo.anyPage,&u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        switch (u16Data)
+        {
+            case 0:
+            case 1:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 2:
+                *mode = GT_EDETECT_SENSE;
+                break;
+            case 3:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn't happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        /* read the mode */
+        if((retVal = hwGetPhyRegField(dev,hwPort,0x10,14,1,&u16Data)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return retVal;
+        }
+
+        switch (u16Data)
+        {
+            case 0:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 1:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn't happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -2142,13 +2220,13 @@ GT_STATUS gprtGetEnergyDetect
 *
 * DESCRIPTION:
 *       This routine sets the ports 1000Base-T Master mode and restart the Auto
-*		negotiation.
+*        negotiation.
 *
 * INPUTS:
 *       port - the logical port number.
 *       mode - GT_1000T_MASTER_SLAVE structure
-*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
-*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
 *
 * OUTPUTS:
 *       None.
@@ -2170,104 +2248,109 @@ GT_STATUS gprtSet1000TMasterMode
     IN  GT_1000T_MASTER_SLAVE   *mode
 )
 {
-	GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8			hwPort;         /* the physical port number     */
-	GT_U16		data;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtSet1000TMasterMode Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		return GT_NOT_SUPPORTED;
-	}
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(mode->autoConfig == GT_TRUE)
-	{
-		if(mode->masterPrefer == GT_TRUE)
-		{
-			data = 0x1;
-		}
-		else
-		{
-			data = 0x0;
-		}
-	}
-	else
-	{
-		if(mode->masterPrefer == GT_TRUE)
-		{
-			data = 0x6;
-		}
-		else
-		{
-			data = 0x4;
-		}
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	/* Set the Master Mode.    */
-	retVal = hwSetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return retVal;
-	}
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_U16        data;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSet1000TMasterMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtSet1000TMasterMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mode->autoConfig == GT_TRUE)
+    {
+        if(mode->masterPrefer == GT_TRUE)
+        {
+            data = 0x1;
+        }
+        else
+        {
+            data = 0x0;
+        }
+    }
+    else
+    {
+        if(mode->masterPrefer == GT_TRUE)
+        {
+            data = 0x6;
+        }
+        else
+        {
+            data = 0x4;
+        }
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Set the Master Mode.    */
+    retVal = hwSetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
     else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	/* Restart Auto Negotiation */
-	if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
-	{
-		DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_CONTROL_REG,1));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* Restart Auto Negotiation */
+    if((retVal=hwSetPhyRegField(dev,hwPort,QD_PHY_CONTROL_REG,9,1,1)) != GT_OK)
+    {
+        DBG_INFO(("Not able to write Phy Reg(port:%d,offset:%d,data:%#x).\n",hwPort,QD_PHY_CONTROL_REG,1));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -2282,8 +2365,8 @@ GT_STATUS gprtSet1000TMasterMode
 *
 * OUTPUTS:
 *       mode - GT_1000T_MASTER_SLAVE structure
-*				autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
-*				masterPrefer - GT_TRUE if Master configuration is preferred.
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -2302,100 +2385,105 @@ GT_STATUS gprtGet1000TMasterMode
     OUT GT_1000T_MASTER_SLAVE   *mode
 )
 {
-	GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U8			hwPort;         /* the physical port number     */
-	GT_U16		data;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-
-	DBG_INFO(("gprtGet1000TMasterMode Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		return GT_NOT_SUPPORTED;
-	}
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	/* Set the Master Mode.    */
-	retVal = hwGetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return retVal;
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(data & 0x4)	/* Manual Mode */
-	{
-		mode->autoConfig = GT_FALSE;
-
-		if(data & 0x2)
-		{
-			mode->masterPrefer = GT_TRUE;
-		}
-		else
-		{
-			mode->masterPrefer = GT_FALSE;
-		}
-	}
-	else	/* Auto Mode */
-	{
-		mode->autoConfig = GT_TRUE;
-
-		if(data & 0x1)
-		{
-			mode->masterPrefer = GT_TRUE;
-		}
-		else
-		{
-			mode->masterPrefer = GT_FALSE;
-		}
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_U16        data;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGet1000TMasterMode_mad(dev, port, mode);
+#endif
+
+    DBG_INFO(("gprtGet1000TMasterMode Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* Set the Master Mode.    */
+    retVal = hwGetPagedPhyRegField(dev,hwPort,0,9,10,3,phyInfo.anyPage,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(data & 0x4)    /* Manual Mode */
+    {
+        mode->autoConfig = GT_FALSE;
+
+        if(data & 0x2)
+        {
+            mode->masterPrefer = GT_TRUE;
+        }
+        else
+        {
+            mode->masterPrefer = GT_FALSE;
+        }
+    }
+    else    /* Auto Mode */
+    {
+        mode->autoConfig = GT_TRUE;
+
+        if(data & 0x1)
+        {
+            mode->masterPrefer = GT_TRUE;
+        }
+        else
+        {
+            mode->masterPrefer = GT_FALSE;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 /*******************************************************************************
@@ -2405,57 +2493,62 @@ GT_STATUS gprtGet1000TMasterMode
 *       This routine retrieves the Link status.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
 *
 * OUTPUTS:
 *       linkStatus - GT_FALSE if link is not established,
-*				     GT_TRUE if link is established.
+*                     GT_TRUE if link is established.
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		
+*        
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtGetPhyLinkStatus
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
-    IN GT_BOOL 	 *linkStatus
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
 )
 {
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			u16Data;
-	GT_PHY_INFO		phyInfo;
+    GT_U16             u16Data;
+    GT_PHY_INFO        phyInfo;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetPhyLinkStatus_mad(dev, port, linkStatus);
+#endif
 
     DBG_INFO(("gprtGetPhyLinkStatus Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-	 	return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+         return GT_NOT_SUPPORTED;
+    }
 
-	if((retVal=hwGetPhyRegField(dev,hwPort,17,10,1,&u16Data)) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return retVal;
-	}
+    if((retVal=hwGetPhyRegField(dev,hwPort,17,10,1,&u16Data)) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
 
-	BIT_2_BOOL(u16Data,*linkStatus);
+    BIT_2_BOOL(u16Data,*linkStatus);
 
-	gtSemGive(dev,dev->phyRegsSem);
+    gtSemGive(dev,dev->phyRegsSem);
     return retVal;
 }
 
@@ -2467,15 +2560,15 @@ GT_STATUS gprtGetPhyLinkStatus
 *       This routine enables or disables Packet Generator.
 *       Link should be established first prior to enabling the packet generator,
 *       and generator will generate packets at the speed of the established link.
-*		When enables packet generator, the following information should be 
+*        When enables packet generator, the following information should be 
 *       provided:
 *           Payload Type:  either Random or 5AA55AA5
 *           Packet Length: either 64 or 1514 bytes
 *           Error Packet:  either Error packet or normal packet
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
 *       en      - GT_TRUE to enable, GT_FALSE to disable
 *       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
 *                 ignored, if en is GT_FALSE
@@ -2486,15 +2579,15 @@ GT_STATUS gprtGetPhyLinkStatus
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		
+*        
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtSetPktGenEnable
 (
-	IN GT_QD_DEV *dev,
-	IN GT_LPORT  port,
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
     IN GT_BOOL   en,
     IN GT_PG     *pktInfo
 )
@@ -2502,80 +2595,85 @@ GT_STATUS gprtSetPktGenEnable
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-    GT_U16 			data;
-	GT_BOOL			link;
-	GT_PHY_INFO		phyInfo;
-	GT_U8			page,reg, offset, len;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
+    GT_U16             data;
+    GT_BOOL            link;
+    GT_PHY_INFO        phyInfo;
+    GT_U8            page,reg, offset, len;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPktGenEnable_mad(dev, port, en, pktInfo);
+#endif
 
     DBG_INFO(("gprtSetPktGenEnable Called.\n"));
     
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(!(phyInfo.flag & GT_PHY_PKT_GENERATOR))
-	{
-	    DBG_INFO(("Not Supported.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (phyInfo.pktGenType)
-	{
-		case GT_PHY_PKTGEN_TYPE1:	/* 30_18.5:2 */
-				page = 18;
-				reg = 30;
-				offset = 2;
-				break;
-		case GT_PHY_PKTGEN_TYPE2:	/* 16_6.3:0 */
-				page = 6;
-				reg = 16;
-				offset = 0;
-				break;
-		case GT_PHY_PKTGEN_TYPE3:	/* 25.3:0 */
-				page = 0;
-				reg = 25;
-				offset = 0;
-				break;
-		default:
-			    DBG_INFO(("Unknown PKTGEN Type.\n"));
-				gtSemGive(dev,dev->phyRegsSem);
-				return GT_FAIL;
-	}
-
-	if (en)
-	{
-		if((retVal = gprtGetPhyLinkStatus(dev,port,&link)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-	
-		if (link == GT_FALSE)
-		{
-		    DBG_INFO(("Link should be on to run Packet Generator.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return GT_FAIL;
-		}
-
-		data = 0x8;
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(!(phyInfo.flag & GT_PHY_PKT_GENERATOR))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (phyInfo.pktGenType)
+    {
+        case GT_PHY_PKTGEN_TYPE1:    /* 30_18.5:2 */
+                page = 18;
+                reg = 30;
+                offset = 2;
+                break;
+        case GT_PHY_PKTGEN_TYPE2:    /* 16_6.3:0 */
+                page = 6;
+                reg = 16;
+                offset = 0;
+                break;
+        case GT_PHY_PKTGEN_TYPE3:    /* 25.3:0 */
+                page = 0;
+                reg = 25;
+                offset = 0;
+                break;
+        default:
+                DBG_INFO(("Unknown PKTGEN Type.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+    }
+
+    if (en)
+    {
+        if((retVal = gprtGetPhyLinkStatus(dev,port,&link)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+    
+        if (link == GT_FALSE)
+        {
+            DBG_INFO(("Link should be on to run Packet Generator.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        data = 0x8;
 
         if (pktInfo->payload == GT_PG_PAYLOAD_5AA5)
             data |= 0x4;
@@ -2587,34 +2685,34 @@ GT_STATUS gprtSetPktGenEnable
             data |= 0x1;
 
         len = 4;
-	}
-	else
-	{
-		data = 0;
-		len = 1;
-		offset += 3;
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if((retVal=hwSetPagedPhyRegField(dev,hwPort,
-				page,reg,offset,len,phyInfo.anyPage,data)) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return retVal;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
+    }
+    else
+    {
+        data = 0;
+        len = 1;
+        offset += 3;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if((retVal=hwSetPagedPhyRegField(dev,hwPort,
+                page,reg,offset,len,phyInfo.anyPage,data)) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return retVal;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
     return retVal;
 }
 
@@ -2626,8 +2724,8 @@ GT_STATUS gprtSetPktGenEnable
 *       This routine reads Serdes Interface Mode.
 *
 * INPUTS:
-*		port -	The physical SERDES device address
-*				(logical port number is also supported for backward comparibility)
+*        port -    The physical SERDES device address
+*                (logical port number is also supported for backward comparibility)
 *
 * OUTPUTS:
 *       mode    - Serdes Interface Mode
@@ -2638,54 +2736,59 @@ GT_STATUS gprtSetPktGenEnable
 *
 * COMMENTS:
 *       logical port number is supported only for the devices made production 
-*		before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
+*        before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
 *
 *******************************************************************************/
 GT_STATUS gprtGetSerdesMode
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-	IN  GT_SERDES_MODE *mode
+    IN  GT_SERDES_MODE *mode
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
     GT_U8           hwPort;         /* the physical port number     */
 
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetSerdesMode_mad(dev, port, mode);
+#endif
+
     DBG_INFO(("gprtGetSerdesMode Called.\n"));
 
-	if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* check if input is logical port number */	
+    /* check if input is logical port number */    
     hwPort = GT_LPORT_2_PORT(port);
-	GT_GET_SERDES_PORT(dev,&hwPort);
+    GT_GET_SERDES_PORT(dev,&hwPort);
 
-	if(hwPort > dev->maxPhyNum)
-	{
-		/* check if input is physical serdes address */	
-		if(dev->validSerdesVec & (1<<port))
-		{
-			hwPort = (GT_U8)port;
-		}
-		else
-			return GT_NOT_SUPPORTED;
-	}
+    if(hwPort > dev->maxPhyNum)
+    {
+        /* check if input is physical serdes address */    
+        if(dev->validSerdesVec & (1<<port))
+        {
+            hwPort = (GT_U8)port;
+        }
+        else
+            return GT_NOT_SUPPORTED;
+    }
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
     /* Get Phy Register. */
     if(hwGetPhyRegField(dev,hwPort,16,0,2,&u16Data) != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
     }
 
-	*mode = u16Data;
+    *mode = u16Data;
 
-	gtSemGive(dev,dev->phyRegsSem);
+    gtSemGive(dev,dev->phyRegsSem);
     return GT_OK;
 }
 
@@ -2697,12 +2800,12 @@ GT_STATUS gprtGetSerdesMode
 *       This routine sets Serdes Interface Mode.
 *
 * INPUTS:
-*		port -	The physical SERDES device address
-*				(logical port number is also supported for backward comparibility)
+*        port -    The physical SERDES device address
+*                (logical port number is also supported for backward comparibility)
 *       mode    - Serdes Interface Mode
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK           - on success
@@ -2710,57 +2813,62 @@ GT_STATUS gprtGetSerdesMode
 *
 * COMMENTS:
 *       logical port number is supported only for the devices made production 
-*		before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
+*        before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
 *
 *******************************************************************************/
 GT_STATUS gprtSetSerdesMode
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-	IN  GT_SERDES_MODE mode
+    IN  GT_SERDES_MODE mode
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_STATUS		retVal;
+    GT_STATUS        retVal;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetSerdesMode_mad(dev, port, mode);
+#endif
 
     DBG_INFO(("gprtSetSerdesMode Called.\n"));
 
-	if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
-	{
-		return GT_NOT_SUPPORTED;
-	}
-	
-	/* check if input is logical port number */	
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+    
+    /* check if input is logical port number */    
     hwPort = GT_LPORT_2_PORT(port);
-	GT_GET_SERDES_PORT(dev,&hwPort);
+    GT_GET_SERDES_PORT(dev,&hwPort);
 
-	if(hwPort > dev->maxPhyNum)
-	{
-		/* check if input is physical serdes address */	
-		if(dev->validSerdesVec & (1<<port))
-		{
-			hwPort = (GT_U8)port;
-		}
-		else
-			return GT_NOT_SUPPORTED;
-	}
+    if(hwPort > dev->maxPhyNum)
+    {
+        /* check if input is physical serdes address */    
+        if(dev->validSerdesVec & (1<<port))
+        {
+            hwPort = (GT_U8)port;
+        }
+        else
+            return GT_NOT_SUPPORTED;
+    }
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
-	u16Data = mode;
+    u16Data = mode;
 
     /* Get Phy Register. */
     if(hwSetPhyRegField(dev,hwPort,16,0,2,u16Data) != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
     }
 
-	retVal = hwPhyReset(dev,hwPort,0xFF);
-	gtSemGive(dev,dev->phyRegsSem);
-	return retVal;
+    retVal = hwPhyReset(dev,hwPort,0xFF);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
 }
 
 
@@ -2771,8 +2879,8 @@ GT_STATUS gprtSetSerdesMode
 *       This routine reads Phy Registers.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
 *       regAddr - The register's address.
 *
 * OUTPUTS:
@@ -2792,30 +2900,36 @@ GT_STATUS gprtGetPhyReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
     GT_U8           hwPort;         /* the physical port number     */
 
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetPhyReg_mad(dev, port, regAddr, data);
+#endif
+
     DBG_INFO(("gprtGetPhyReg Called.\n"));
 
-    hwPort = GT_LPORT_2_PHY(port);
+/*    hwPort = GT_LPORT_2_PHY(port); */
+    hwPort = qdLong2Char(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
     /* Get Phy Register. */
     if(hwReadPhyReg(dev,hwPort,(GT_U8)regAddr,&u16Data) != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
     }
 
-	*data = u16Data;
+    *data = u16Data;
 
-	gtSemGive(dev,dev->phyRegsSem);
+    gtSemGive(dev,dev->phyRegsSem);
     return GT_OK;
 }
 
@@ -2826,8 +2940,8 @@ GT_STATUS gprtGetPhyReg
 *       This routine writes Phy Registers.
 *
 * INPUTS:
-*		port -	The logical port number, unless SERDES device is accessed
-*				The physical address, if SERDES device is accessed
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
 *       regAddr - The register's address.
 *
 * OUTPUTS:
@@ -2845,30 +2959,36 @@ GT_STATUS gprtGetPhyReg
 *******************************************************************************/
 GT_STATUS gprtSetPhyReg
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_LPORT		port,
-    IN  GT_U32			regAddr,
-    IN  GT_U16			data
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
 )
 {
     GT_U8           hwPort;         /* the physical port number     */
     
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPhyReg_mad(dev, port, regAddr, data);
+#endif
+
     DBG_INFO(("gprtSetPhyReg Called.\n"));
 
-    hwPort = GT_LPORT_2_PHY(port);
+/*    hwPort = GT_LPORT_2_PHY(port); */
+    hwPort = qdLong2Char(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
 
     /* Write to Phy Register */
     if(hwWritePhyReg(dev,hwPort,(GT_U8)regAddr,data) != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
+        gtSemGive(dev,dev->phyRegsSem);
         return GT_FAIL;
     }
 
-	gtSemGive(dev,dev->phyRegsSem);
-	return GT_OK;
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
 }
 
 
@@ -2880,16 +3000,16 @@ GT_STATUS gprtSetPhyReg
 *       This routine reads phy register of the given page
 *
 * INPUTS:
-*		port 	- logical port to be read
-*		regAddr	- register offset to be read
-*		page	- page number to be read
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
 *
 * OUTPUTS:
-*		data	- value of the read register
+*        data    - value of the read register
 *
 * RETURNS:
-*       GT_OK   			- if read successed
-*       GT_FAIL   			- if read failed
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
 *
 * COMMENTS:
 *       None.
@@ -2899,55 +3019,60 @@ GT_STATUS gprtGetPagedPhyReg
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U32  port,
-	IN	GT_U32  regAddr,
-	IN	GT_U32  page,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
     OUT GT_U16* data
 )
 {
-	GT_PHY_INFO		phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-	GT_U8			hwPort;
+    GT_PHY_INFO        phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+    GT_U8            hwPort;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetPagedPhyReg_mad(dev, port, regAddr, page, data);
+#endif
 
     hwPort = GT_LPORT_2_PHY(port);
-	
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(hwReadPagedPhyReg(dev,hwPort,(GT_U8)page,
-								(GT_U8)regAddr,0,data) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return GT_OK;
+    
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwReadPagedPhyReg(dev,hwPort,(GT_U8)page,
+                                (GT_U8)regAddr,0,data) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -2957,17 +3082,17 @@ GT_STATUS gprtGetPagedPhyReg
 *       This routine writes a value to phy register of the given page
 *
 * INPUTS:
-*		port 	- logical port to be read
-*		regAddr	- register offset to be read
-*		page	- page number to be read
-*		data	- value of the read register
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-*       GT_OK   			- if read successed
-*       GT_FAIL   			- if read failed
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
 *
 * COMMENTS:
 *       None.
@@ -2977,55 +3102,60 @@ GT_STATUS gprtSetPagedPhyReg
 (
     IN  GT_QD_DEV *dev,
     IN  GT_U32 port,
-	IN	GT_U32 regAddr,
-	IN	GT_U32 page,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
     IN  GT_U16 data
 )
 {
-	GT_PHY_INFO		phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
-	GT_U8			hwPort;
+    GT_PHY_INFO        phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+    GT_U8            hwPort;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtSetPagedPhyReg_mad(dev, port, regAddr, page, data);
+#endif
 
     hwPort = GT_LPORT_2_PHY(port);
 
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(hwWritePagedPhyReg(dev,hwPort,(GT_U8)page,
-								(GT_U8)regAddr,0,data) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return GT_OK;
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(hwWritePagedPhyReg(dev,hwPort,(GT_U8)page,
+                                (GT_U8)regAddr,0,data) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl_mad.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl_mad.c
new file mode 100755
index 0000000..b5d4fad
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyCtrl_mad.c
@@ -0,0 +1,2189 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyCtrl.h
+* 
+* DESCRIPTION:
+* API definitions for PHY control facility.
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtVct.h>
+#include <gtSem.h>
+
+
+#ifdef GT_USE_MAD
+#include <madApi.h>
+#include <madHwCntl.h>
+#endif
+
+
+/*
+ * This routine set Auto-Negotiation Ad Register for Copper
+*/
+static 
+GT_STATUS translateAutoMode
+(
+    IN    GT_PHY_INFO  *phyInfo,
+    IN    GT_PHY_AUTO_MODE mode,
+	OUT	  MAD_BOOL	   *autoEn,
+    OUT   MAD_U32      *autoMode
+)
+{
+  MAD_BOOL        autoNegoEn; 
+  MAD_SPEED_MODE    speedMode; 
+  MAD_DUPLEX_MODE duplexMode;
+
+    switch(mode)
+    {
+        case SPEED_AUTO_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE; 
+          speedMode  = MAD_SPEED_AUTO; 
+          duplexMode = MAD_AUTO_DUPLEX; 
+        case SPEED_1000_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE; 
+          speedMode  = MAD_SPEED_1000M; 
+          duplexMode = MAD_AUTO_DUPLEX; 
+          break;
+        case SPEED_AUTO_DUPLEX_FULL:
+          autoNegoEn = MAD_TRUE; 
+          speedMode  = MAD_SPEED_AUTO; 
+          duplexMode = MAD_FULL_DUPLEX; 
+          break;
+        case SPEED_1000_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_1000M; 
+          duplexMode = MAD_FULL_DUPLEX; 
+          break;
+        case SPEED_1000_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_1000M; 
+          duplexMode = MAD_HALF_DUPLEX; 
+          break;
+        case SPEED_AUTO_DUPLEX_HALF:
+          autoNegoEn = MAD_TRUE; 
+          speedMode  = MAD_SPEED_AUTO; 
+          duplexMode = MAD_HALF_DUPLEX; 
+          break;
+        case SPEED_100_DUPLEX_AUTO:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_100M; 
+          duplexMode = MAD_FULL_DUPLEX; 
+          break;
+        case SPEED_10_DUPLEX_AUTO:
+          autoNegoEn = MAD_TRUE; 
+          speedMode  = MAD_SPEED_10M; 
+          duplexMode = MAD_AUTO_DUPLEX; 
+          break;
+        case SPEED_100_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_100M; 
+          duplexMode = MAD_FULL_DUPLEX; 
+          break;
+        case SPEED_100_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_100M; 
+          duplexMode = MAD_HALF_DUPLEX; 
+          break;
+        case SPEED_10_DUPLEX_FULL:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_10M; 
+          duplexMode = MAD_FULL_DUPLEX; 
+          break;
+        case SPEED_10_DUPLEX_HALF:
+          autoNegoEn = MAD_FALSE; 
+          speedMode  = MAD_SPEED_10M; 
+          duplexMode = MAD_HALF_DUPLEX; 
+          break;
+        default:
+          DBG_INFO(("Unknown Auto Mode (%d)\n",mode));
+          return GT_BAD_PARAM;
+    }
+
+    *autoEn = autoNegoEn;
+    if (mdGetAutoNegoMode(autoNegoEn, speedMode, duplexMode, autoMode) != MAD_OK)
+	  return GT_FAIL;
+
+
+    return GT_OK;
+}
+
+/*
+ * This routine sets Auto Mode and Reset the phy
+*/
+static 
+GT_STATUS phySetAutoMode
+(
+    IN GT_QD_DEV *dev,
+    IN GT_U8 hwPort,
+    IN GT_PHY_INFO *phyInfo,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+    MAD_STATUS    status;
+	MAD_U32 autoMode;
+    MAD_BOOL  autoEn;
+
+    DBG_INFO(("phySetAutoMode Called.\n"));
+
+    status = translateAutoMode(phyInfo,mode, &autoEn, &autoMode);
+    if(status != GT_OK)
+    {
+       return status;
+    }
+
+
+    if(phyInfo->flag & GT_PHY_COPPER)
+    {
+        if((mdCopperSetAutoNeg(&(dev->mad_dev),hwPort,autoEn, autoMode)) != MAD_OK)
+        {
+               return GT_FAIL;
+        }
+
+    }
+    else if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((mdFiberSetAutoNeg(&(dev->mad_dev),hwPort,autoEn, autoMode)) != MAD_OK)
+        {
+               return GT_FAIL;
+        }
+
+    }
+
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtPhyReset_mad
+*
+* DESCRIPTION:
+*       This routine preforms PHY reset.
+*        After reset, phy will be in Autonegotiation mode.
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 0.15 - Reset
+* data sheet register 0.13 - Speed
+* data sheet register 0.12 - Autonegotiation
+* data sheet register 0.8  - Duplex Mode
+*******************************************************************************/
+
+GT_STATUS gprtPhyReset_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+    DBG_INFO(("gprtPhyReset Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /* set Auto Negotiation AD Register */
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,SPEED_AUTO_DUPLEX_AUTO);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetPortLoopback_mad
+*
+* DESCRIPTION:
+* Enable/Disable Internal Port Loopback. 
+* For 10/100 Fast Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled, this routine disables Auto-Negotiation and 
+*   forces speed to be 10Mbps.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   Disabling Loopback simply clears bit 14 of control register(0.14). Therefore,
+*   it is recommended to call gprtSetPortAutoMode for PHY configuration after 
+*   Loopback test.
+* For 10/100/1000 Gigagbit Ethernet PHY, speed of Loopback is determined as follows:
+*   If Auto-Negotiation is enabled and Link is active, the current speed is used.
+*   If Auto-Negotiation is disabled, the forced speed is used.
+*   All other cases, default MAC Interface speed is used. Please refer to the data
+*   sheet for the information of the default MAC Interface speed.
+*   
+*
+* INPUTS:
+* port - The logical port number, unless SERDES device is accessed
+*        The physical address, if SERDES device is accessed
+* enable - If GT_TRUE, enable loopback mode
+* If GT_FALSE, disable loopback mode
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.14 - Loop_back
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortLoopback_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   enable
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS status;
+
+    DBG_INFO(("gprtSetPortLoopback_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if((status = mdDiagSetLineLoopback(&(dev->mad_dev),port,enable)) != MAD_OK)
+    {
+        DBG_INFO(("mdDiagSetLineLoopback failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPortSpeed_mad
+*
+* DESCRIPTION:
+*         Sets speed for a specific logical port. This function will keep the duplex 
+*        mode and loopback mode to the previous value, but disable others, such as 
+*        Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        speed - port speed.
+*                PHY_SPEED_10_MBPS for 10Mbps
+*                PHY_SPEED_100_MBPS for 100Mbps
+*                PHY_SPEED_1000_MBPS for 1000Mbps
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* data sheet register 0.13 - Speed Selection (LSB)
+* data sheet register 0.6  - Speed Selection (MSB)
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetPortSpeed_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_SPEED speed
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS status;
+	MAD_U32 mspeed;
+    MAD_DUPLEX_MODE mDuplexmod;
+
+    DBG_INFO(("gprtSetPortSpeed_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+    switch (speed)
+	{ 
+      case PHY_SPEED_10_MBPS:
+        mspeed = 10;
+        break;
+      case PHY_SPEED_100_MBPS:
+        mspeed = 100;
+        break;
+      case PHY_SPEED_1000_MBPS:
+      default:
+        mspeed = 1000;
+        break;
+	}
+
+    if((status = mdGetDuplexStatus(&(dev->mad_dev),port,&mDuplexmod)) != MAD_OK)
+    {
+        DBG_INFO(("mdGetDuplexStatus failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+
+    if((status = mdCopperSetSpeedDuplex(&(dev->mad_dev),port,mspeed,((mDuplexmod)?MAD_TRUE:MAD_FALSE))) != MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetSpeedDuplex failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtPortAutoNegEnable_mad
+*
+* DESCRIPTION:
+*         Enable/disable an Auto-Negotiation.
+*        This routine simply sets Auto Negotiation bit (bit 12) of Control 
+*        Register and reset the phy.
+*        For Speed and Duplex selection, please use gprtSetPortAutoMode.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state - GT_TRUE for enable Auto-Negotiation,
+*                GT_FALSE otherwise
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.12 - Auto-Negotiation Enable
+*         data sheet register 4.8, 4.7, 4.6, 4.5 - Auto-Negotiation Advertisement
+*
+*******************************************************************************/
+GT_STATUS gprtPortAutoNegEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_STATUS retVal;
+    MAD_SPEED_MODE speedMode;
+    MAD_DUPLEX_MODE duplexMode;
+	MAD_BOOL autoNegoEn;
+    MAD_U32            autoMode;
+
+    DBG_INFO(("gprtPortAutoNegEnable_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+	if ((retVal=mdGetSpeedStatus(&(dev->mad_dev), hwPort, &speedMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdGetSpeedStatus Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+ 	if ((retVal=mdGetDuplexStatus(&(dev->mad_dev), hwPort, &duplexMode))!=MAD_OK)
+    {
+       DBG_INFO(("mdGetDuplexStatus Failed.\n"));
+       gtSemGive(dev,dev->phyRegsSem);
+       return GT_FAIL;
+	}
+
+    autoNegoEn = (state==GT_TRUE)?MAD_TRUE:MAD_FALSE;
+    if ((mdGetAutoNegoMode(autoNegoEn, speedMode, duplexMode, &autoMode)) != MAD_OK)
+    {
+        DBG_INFO(("mdGetAutoNegoMode Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+ 	if ((retVal=mdCopperSetAutoNeg(&(dev->mad_dev), hwPort, autoNegoEn, autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+	gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtPortPowerDown_mad
+*
+* DESCRIPTION:
+*         Enable/disable (power down) on specific logical port.
+*        Phy configuration remains unchanged after Power down.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         state -    GT_TRUE: power down
+*                 GT_FALSE: normal operation
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.11 - Power Down
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortPowerDown_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_STATUS retVal;
+    MAD_BOOL pwMode
+
+    DBG_INFO(("gprtPortPowerDown_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+	if (state==GT_TRUE)
+	  pwMode = MAD_TRUE;
+	else
+	  pwMode = MAD_FALSE;
+
+ 	if ((retVal=mdSysSetPhyEnable(&(dev->mad_dev), hwPort, pwMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdSysSetPhyEnable Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtPortRestartAutoNeg_mad
+*
+* DESCRIPTION:
+*         Restart AutoNegotiation. If AutoNegotiation is not enabled, it'll enable 
+*        it. Loopback and Power Down will be disabled by this routine.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.9 - Restart Auto-Negotiation
+*
+*******************************************************************************/
+
+GT_STATUS gprtPortRestartAutoNeg_mad
+( 
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          u16Data;
+    MAD_U32         u32Data;
+
+    DBG_INFO(("gprtPortRestartAutoNeg_mad Called.\n"));
+  
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=mdSysGetPhyReg(&(dev->mad_dev),hwPort,QD_PHY_CONTROL_REG,&u32Data)) != MAD_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+	u16Data = u32Data;
+    u16Data &= (QD_PHY_DUPLEX | QD_PHY_SPEED);
+    u16Data |= (QD_PHY_RESTART_AUTONEGO | QD_PHY_AUTONEGO);
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    if((retVal=madHwPagedSetCtrlPara(&(dev->mad_dev),hwPort,0,u16Data)) != MAD_OK)
+    {
+        DBG_INFO(("CallmadHwPagedSetCtrlPara failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+
+    if(retVal != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+		return GT_FAIL;
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPortDuplexMode_mad
+*
+* DESCRIPTION:
+*         Sets duplex mode for a specific logical port. This function will keep 
+*        the speed and loopback mode to the previous value, but disable others,
+*        such as Autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         dMode    - dulpex mode
+*
+* OUTPUTS:
+*         None.
+*
+* RETURNS:
+*         GT_OK     - on success
+*         GT_FAIL     - on error
+*
+* COMMENTS:
+*         data sheet register 0.8 - Duplex Mode
+*
+*******************************************************************************/
+GT_STATUS gprtSetPortDuplexMode_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_BOOL   dMode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal;
+    MAD_U32         u32Data;
+
+    DBG_INFO(("gprtSetPortDuplexMode_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if((retVal=mdSysGetPhyReg(&(dev->mad_dev),hwPort,QD_PHY_CONTROL_REG,&u32Data)) != MAD_OK)
+    {
+        DBG_INFO(("Not able to read Phy Reg(port:%d,offset:%d).\n",hwPort,QD_PHY_CONTROL_REG));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+	u16Data = u32Data;
+
+    if(dMode)
+    {
+        u16Data = (u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB)) | QD_PHY_DUPLEX;
+    }
+    else
+    {
+        u16Data = u16Data & (QD_PHY_LOOPBACK | QD_PHY_SPEED | QD_PHY_SPEED_MSB);
+    }
+
+
+    DBG_INFO(("Write to phy(%d) register: regAddr 0x%x, data %#x",
+              hwPort,QD_PHY_CONTROL_REG,u16Data));
+
+    /* Write to Phy Control Register.  */
+    if((retVal=madHwPagedSetCtrlPara(&(dev->mad_dev),hwPort,0,u16Data)) != MAD_OK)
+    {
+        DBG_INFO(("CallmadHwPagedSetCtrlPara failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetPortAutoMode_mad
+*
+* DESCRIPTION:
+*         This routine sets up the port with given Auto Mode.
+*        Supported mode is as follows:
+*        - Auto for both speed and duplex.
+*        - Auto for speed only and Full duplex.
+*        - Auto for speed only and Half duplex.
+*        - Auto for duplex only and speed 1000Mbps.
+*        - Auto for duplex only and speed 100Mbps.
+*        - Auto for duplex only and speed 10Mbps.
+*        - Speed 1000Mbps and Full duplex.
+*        - Speed 1000Mbps and Half duplex.
+*        - Speed 100Mbps and Full duplex.
+*        - Speed 100Mbps and Half duplex.
+*        - Speed 10Mbps and Full duplex.
+*        - Speed 10Mbps and Half duplex.
+*        
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*         mode - Auto Mode to be written
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - on device without copper
+*
+* COMMENTS:
+*         data sheet register 4.8, 4.7, 4.6, and 4.5 Autonegotiation Advertisement
+*         data sheet register 4.6, 4.5 Autonegotiation Advertisement for 1000BX
+*         data sheet register 9.9, 9.8 Autonegotiation Advertisement for 1000BT
+*******************************************************************************/
+
+GT_STATUS gprtSetPortAutoMode_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_PHY_AUTO_MODE mode
+)
+{
+
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+
+    DBG_INFO(("gprtSetPortAutoMode_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    retVal = GT_NOT_SUPPORTED;
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    retVal = phySetAutoMode(dev,hwPort,&phyInfo,mode);
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+
+}
+
+
+/*******************************************************************************
+* gprtSetPause_mad
+*
+* DESCRIPTION:
+*       This routine will set the pause bit in Autonegotiation Advertisement
+*        Register. And restart the autonegotiation.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*        state - GT_PHY_PAUSE_MODE enum value.
+*                GT_PHY_NO_PAUSE        - disable pause
+*                 GT_PHY_PAUSE        - support pause
+*                GT_PHY_ASYMMETRIC_PAUSE    - support asymmetric pause
+*                GT_PHY_BOTH_PAUSE    - support both pause and asymmetric pause
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+* COMMENTS:
+* data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+
+GT_STATUS gprtSetPause_mad
+(
+IN GT_QD_DEV *dev,
+IN GT_LPORT  port,
+IN GT_PHY_PAUSE_MODE state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_STATUS retVal;
+	MAD_BOOL autoNegoEn;
+    MAD_U32            autoMode
+
+    DBG_INFO(("phySetPause_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(state & GT_PHY_ASYMMETRIC_PAUSE)
+    {
+        if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+        {
+            DBG_INFO(("Unknown PHY device.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_FAIL;
+        }
+
+        if (!(phyInfo.flag & GT_PHY_GIGABIT))
+        {
+            DBG_INFO(("Not Supported\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return GT_BAD_PARAM;
+        }
+
+    }
+
+ 	if ((retVal=mdCopperGetAutoNeg(&(dev->mad_dev), hwPort, &autoNegoEn, &autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+	if (state==GT_TRUE)
+	  autoMode |= MAD_AUTO_AD_ASYM_PAUSE;
+	else
+	  autoMode &= ~MAD_AUTO_AD_ASYM_PAUSE;
+
+
+ 	if ((retVal=mdCopperSetAutoNeg(&(dev->mad_dev), hwPort, autoNegoEn, autoMode))!=MAD_OK)
+    {
+        DBG_INFO(("mdCopperSetAutoNeg Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+	}
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+/*******************************************************************************
+* gprtSetDTEDetect_mad
+*
+* DESCRIPTION:
+*       This routine enables/disables DTE.
+*
+* INPUTS:
+*         port - The logical port number
+*         mode - either GT_TRUE(for enable) or GT_FALSE(for disable)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetect_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL            en;
+
+    DBG_INFO(("phySetDTE_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+	if (state==GT_TRUE)
+	  en = MAD_TRUE;
+	else
+	  en = MAD_FALSE;
+
+    if(mdCopperSetDTEDetectEnable(&(dev->mad_dev),hwPort,en,0) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectStatus_mad
+*
+* DESCRIPTION:
+*       This routine gets DTE status.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       status - GT_TRUE, if link partner needs DTE power.
+*                 GT_FALSE, otherwise.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectStatus_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_BOOL   *state
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+    DBG_INFO(("gprtGetDTEStatus_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+
+ 	if (en==MAD_TRUE)
+	  *state = GT_TRUE;
+	else
+	  *state = GT_FALSE;
+
+   
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetDTEDetectDropWait_mad
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet 
+*        detection status bit. The wait time is 5 seconds multiplied by the 
+*        given value.
+*
+* INPUTS:
+*         port - The logical port number
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_U16    waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+
+    DBG_INFO(("gprtSetDTEDropWait_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports DTE */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    dropHys = waitTime;
+    if(mdCopperSetDTEDetectEnable(&(dev->mad_dev),hwPort,en,dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetDTEDetectDropWait_mad
+*
+* DESCRIPTION:
+*       Once the PHY no longer detects that the link partner filter, the PHY
+*        will wait a period of time before clearing the power over Ethernet 
+*        detection status bit. The wait time is 5 seconds multiplied by the 
+*        returned value.
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       waitTime - 0 ~ 15 (unit of 4 sec.)
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetDTEDetectDropWait_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_U16    *waitTime
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+    MAD_BOOL    en;
+    MAD_U16     dropHys;
+
+    DBG_INFO(("gprtSetDTEDropWait_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_DTE_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetDTEDetectEnable(&(dev->mad_dev),hwPort,&en,&dropHys) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperSetDTEDetectEnable failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *waitTime = dropHys;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSetEnergyDetect_mad
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable. 
+*
+* INPUTS:
+*         port - The logical port number
+*       mode - GT_EDETECT_MODE type
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtSetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    IN  GT_EDETECT_MODE   mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtSetEnergyDetect_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 3;
+                break;
+            case GT_EDETECT_SENSE:
+                u16Data = 2;
+                break;
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+	}
+    else    /* it's a Fast Ethernet device */
+    {
+        /* check if the mode is valid */
+        switch (mode)
+        {
+            case GT_EDETECT_OFF:
+                u16Data = 0;
+                break;
+            case GT_EDETECT_SENSE_PULSE:
+                u16Data = 1;
+                break;
+            case GT_EDETECT_SENSE:
+            default:
+                DBG_INFO(("Invalid paramerter.\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_BAD_PARAM;
+        }
+
+    }
+
+    if(mdSysSetDetectPowerDownMode(&(dev->mad_dev),hwPort,u16Data) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetEnergyDetect_mad
+*
+* DESCRIPTION:
+*       Energy Detect power down mode enables or disables the PHY to wake up on
+*        its own by detecting activity on the CAT 5 cable. 
+*
+* INPUTS:
+*         port - The logical port number
+*
+* OUTPUTS:
+*       mode - GT_EDETECT_MODE type
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetEnergyDetect_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT  port,
+    OUT GT_EDETECT_MODE   *mode
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16             u16Data;
+    GT_STATUS        retVal = GT_OK;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gprtGetEnergyDetect_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysGetDetectPowerDownMode(&(dev->mad_dev),hwPort,&u16Data) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (phyInfo.flag & GT_PHY_SERDES_CORE)
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+    else if (phyInfo.flag & GT_PHY_GIGABIT)
+    {
+        /* read the mode */
+
+        switch (u16Data)
+        {
+            case 0:
+            case 1:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 2:
+                *mode = GT_EDETECT_SENSE;
+                break;
+            case 3:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (should not happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+    else    /* it's a Fast Ethernet device */
+    {
+        switch (u16Data)
+        {
+            case 0:
+                *mode = GT_EDETECT_OFF;
+                break;
+            case 1:
+                *mode = GT_EDETECT_SENSE_PULSE;
+                break;
+            default:
+                DBG_INFO(("Unknown value (shouldn not happen).\n"));
+                gtSemGive(dev,dev->phyRegsSem);
+                return GT_FAIL;
+        }
+
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtSet1000TMasterMode_mad
+*
+* DESCRIPTION:
+*       This routine sets the ports 1000Base-T Master mode and restart the Auto
+*        negotiation.
+*
+* INPUTS:
+*       port - the logical port number.
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    IN  GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_PHY_INFO    phyInfo;
+    MAD_1000T_MASTER_SLAVE    msmode
+
+    DBG_INFO(("gprtSet1000TMasterMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    msmode.autoConfig = mode->autoConfig;
+    msmode.masterPrefer = mode->masterPrefer;
+
+    if(mdCopperSet1000TMasterMode(&(dev->mad_dev),hwPort,&msmode) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGet1000TMasterMode_mad
+*
+* DESCRIPTION:
+*       This routine retrieves 1000Base-T Master Mode
+*
+* INPUTS:
+*       port - the logical port number.
+*
+* OUTPUTS:
+*       mode - GT_1000T_MASTER_SLAVE structure
+*                autoConfig   - GT_TRUE for auto, GT_FALSE for manual setup.
+*                masterPrefer - GT_TRUE if Master configuration is preferred.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGet1000TMasterMode_mad
+(
+    IN  GT_QD_DEV   *dev,
+    IN  GT_LPORT     port,
+    OUT GT_1000T_MASTER_SLAVE   *mode
+)
+{
+    GT_U8            hwPort;         /* the physical port number     */
+    GT_PHY_INFO    phyInfo;
+    MAD_1000T_MASTER_SLAVE    msmode
+
+    DBG_INFO(("gprtGet1000TMasterMode_mad Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_GIGABIT) || !(phyInfo.flag & GT_PHY_COPPER))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGet1000TMasterMode(&(dev->mad_dev),hwPort,&msmode) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperGet1000TMasterMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+    mode->autoConfig = msmode.autoConfig;
+    mode->masterPrefer = msmode.masterPrefer;
+
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetPhyLinkStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves the Link status.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*
+* OUTPUTS:
+*       linkStatus - GT_FALSE if link is not established,
+*                     GT_TRUE if link is established.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyLinkStatus_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL      *linkStatus
+)
+{
+
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    OUT MAD_BOOL    linkOn;
+
+    DBG_INFO(("gprtGetPhyLinkStatus_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+         return GT_NOT_SUPPORTED;
+    }
+
+    if(mdCopperGetLinkStatus(&(dev->mad_dev),hwPort,&linkOn) != MAD_OK)
+    {
+        DBG_INFO(("Call mdCopperGetLinkStatus failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+	*linkStatus = (linkOn==MAD_TRUE)?GT_TRUE:GT_FAIL;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetPktGenEnable_mad
+*
+* DESCRIPTION:
+*       This routine enables or disables Packet Generator.
+*       Link should be established first prior to enabling the packet generator,
+*       and generator will generate packets at the speed of the established link.
+*        When enables packet generator, the following information should be 
+*       provided:
+*           Payload Type:  either Random or 5AA55AA5
+*           Packet Length: either 64 or 1514 bytes
+*           Error Packet:  either Error packet or normal packet
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       en      - GT_TRUE to enable, GT_FALSE to disable
+*       pktInfo - packet information(GT_PG structure pointer), if en is GT_TRUE.
+*                 ignored, if en is GT_FALSE
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*        
+*
+* COMMENTS:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPktGenEnable_mad
+(
+    IN GT_QD_DEV *dev,
+    IN GT_LPORT  port,
+    IN GT_BOOL   en,
+    IN GT_PG     *pktInfo
+)
+{
+
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_PHY_INFO        phyInfo;
+    MAD_U32   men;
+    MAD_PG    mpktInfo;
+
+    DBG_INFO(("gprtSetPktGenEnable_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(!(phyInfo.flag & GT_PHY_PKT_GENERATOR))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    mpktInfo.payload = pktInfo->payload;
+    mpktInfo.length = pktInfo->length;
+    mpktInfo.tx = pktInfo->tx;
+	if (en==GT_TRUE)
+	{
+	  men =1;
+      mpktInfo.en_type = MAD_PG_EN_COPPER;
+	}
+	else
+	{
+	  men =0;
+      mpktInfo.en_type = MAD_PG_DISABLE;
+	}
+
+	if(mdDiagSetPktGenEnable(&(dev->mad_dev),hwPort, men, &mpktInfo) != MAD_OK)
+    {
+        DBG_INFO(("Call mdSysSetDetectPowerDownMode failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtGetSerdesMode_mad
+*
+* DESCRIPTION:
+*       This routine reads Serdes Interface Mode.
+*
+* INPUTS:
+*        port -    The physical SERDES device address
+*                (logical port number is also supported for backward comparibility)
+*
+* OUTPUTS:
+*       mode    - Serdes Interface Mode
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production 
+*        before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
+*
+*******************************************************************************/
+GT_STATUS gprtGetSerdesMode_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE *mode
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetSerdesMode_mad Called.\n"));
+
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if input is logical port number */    
+    hwPort = GT_LPORT_2_PORT(port);
+    GT_GET_SERDES_PORT(dev,&hwPort);
+
+    if(hwPort > dev->maxPhyNum)
+    {
+        /* check if input is physical serdes address */    
+        if(dev->validSerdesVec & (1<<port))
+        {
+            hwPort = (GT_U8)port;
+        }
+        else
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(hwGetPhyRegField(dev,hwPort,16,0,2,&u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *mode = u16Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gprtSetSerdesMode_mad
+*
+* DESCRIPTION:
+*       This routine sets Serdes Interface Mode.
+*
+* INPUTS:
+*        port -    The physical SERDES device address
+*                (logical port number is also supported for backward comparibility)
+*       mode    - Serdes Interface Mode
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       logical port number is supported only for the devices made production 
+*        before 2009. (88E6131, 88E6122, 88E6108, 88E6161, and 88E6165)
+*
+*******************************************************************************/
+GT_STATUS gprtSetSerdesMode_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_SERDES_MODE mode
+)
+{
+    GT_U16          u16Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_STATUS        retVal;
+
+    DBG_INFO(("gprtSetSerdesMode_mad Called.\n"));
+
+    if(!IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+    
+    /* check if input is logical port number */    
+    hwPort = GT_LPORT_2_PORT(port);
+    GT_GET_SERDES_PORT(dev,&hwPort);
+
+    if(hwPort > dev->maxPhyNum)
+    {
+        /* check if input is physical serdes address */    
+        if(dev->validSerdesVec & (1<<port))
+        {
+            hwPort = (GT_U8)port;
+        }
+        else
+            return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    u16Data = mode;
+
+    /* Get Phy Register. */
+    if(hwSetPhyRegField(dev,hwPort,16,0,2,u16Data) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    retVal = hwPhyReset(dev,hwPort,0xFF);
+    gtSemGive(dev,dev->phyRegsSem);
+    return retVal;
+}
+
+
+/*******************************************************************************
+* gprtGetPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine reads Phy Registers.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtGetPhyReg_mad
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
+)
+{
+    MAD_U32          u32Data;           /* The register's read data.    */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtGetPhyReg_mad Called.\n"));
+
+    hwPort = GT_LPORT_2_PHY(port); 
+    /* hwPort = port; */
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Get Phy Register. */
+    if(mdSysGetPhyReg(&(dev->mad_dev),hwPort,regAddr,&u32Data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *data = u32Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine writes Phy Registers.
+*
+* INPUTS:
+*        port -    The logical port number, unless SERDES device is accessed
+*                The physical address, if SERDES device is accessed
+*       regAddr - The register's address.
+*
+* OUTPUTS:
+*       data    - The read register's data.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gprtSetPhyReg_mad
+(
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            inData
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+	MAD_U32		data = inData;
+    
+    DBG_INFO(("gprtSetPhyReg_mad Called.\n"));
+
+    hwPort = GT_LPORT_2_PHY(port); 
+    /* hwPort = port;  */
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* Write to Phy Register */
+    if(mdSysSetPhyReg(&(dev->mad_dev),hwPort,regAddr,data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+
+/*******************************************************************************
+* gprtGetPagedPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine reads phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*
+* OUTPUTS:
+*        data    - value of the read register
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtGetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32  port,
+    IN    GT_U32  regAddr,
+    IN    GT_U32  page,
+    OUT GT_U16* data
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_U8            hwPort;
+	MAD_U32		u32Data;
+
+    hwPort = GT_LPORT_2_PHY(port);
+    
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysGetPagedPhyReg(&(dev->mad_dev),hwPort,page, regAddr,&u32Data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    *data = u32Data;
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtSetPagedPhyReg_mad
+*
+* DESCRIPTION:
+*       This routine writes a value to phy register of the given page
+*
+* INPUTS:
+*        port     - logical port to be read
+*        regAddr    - register offset to be read
+*        page    - page number to be read
+*        data    - value of the read register
+*
+* OUTPUTS:
+*        None
+*
+* RETURNS:
+*       GT_OK               - if read successed
+*       GT_FAIL               - if read failed
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gprtSetPagedPhyReg_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_U32 port,
+    IN    GT_U32 regAddr,
+    IN    GT_U32 page,
+    IN  GT_U16 inData
+)
+{
+    GT_PHY_INFO        phyInfo;
+    GT_U8            hwPort;
+    MAD_U32 data = inData;
+
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(mdSysSetPagedPhyReg(&(dev->mad_dev),hwPort,page, regAddr, data) != MAD_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return GT_OK;
+}
+
+
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt.c
old mode 100644
new mode 100755
index 26819f9..5dfc467
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt.c
@@ -17,6 +17,9 @@
 #include <gtHwCntl.h>
 #include <gtDrvSwRegs.h>
 #include <gtDrvConfig.h>
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
 
 /*******************************************************************************
 * gprtPhyIntEnable
@@ -34,19 +37,19 @@
 * port -   The logical port number, unless SERDES device is accessed
 *          The physical address, if SERDES device is accessed
 * intType - the type of interrupt to enable/disable. any combination of 
-*			GT_SPEED_CHANGED,
-*			GT_DUPLEX_CHANGED,
-*			GT_PAGE_RECEIVED,
-*			GT_AUTO_NEG_COMPLETED,
-*			GT_LINK_STATUS_CHANGED,
-*			GT_SYMBOL_ERROR,
-*			GT_FALSE_CARRIER,
-*			GT_FIFO_FLOW,
-*			GT_CROSSOVER_CHANGED,	( Copper only )
-*			GT_DOWNSHIFT_DETECT,	( for 1000M Copper only )
-*			GT_ENERGY_DETECT,		( for 1000M Copper only )
-*			GT_POLARITY_CHANGED, and ( Copper only )
-*			GT_JABBER				(Copper only )
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
 *
 *
 * OUTPUTS:
@@ -68,47 +71,51 @@
 GT_STATUS gprtPhyIntEnable
 (
 IN GT_QD_DEV    *dev,
-IN GT_LPORT	port,
-IN GT_U16	intType
+IN GT_LPORT    port,
+IN GT_U16    intType
 )
 {
     GT_STATUS       retVal;      
     GT_U8           hwPort;         /* the physical port number     */
 
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtPhyIntEnable_mad(dev, port, intType);
+#endif
     DBG_INFO(("gprtPhyIntEnable Called.\n"));
     
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PHY(port);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
 
-	if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
-	{
-		if(!(dev->validSerdesVec & (1 << hwPort)))
-		{
-			if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
-				GT_GET_SERDES_PORT(dev,&hwPort);
-		}
-		if(hwPort >= dev->maxPhyNum)
-		{
-			return GT_NOT_SUPPORTED;
-		}
-	}
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	retVal = hwWritePhyReg(dev,hwPort, QD_PHY_INT_ENABLE_REG, intType);
+    retVal = hwWritePhyReg(dev,hwPort, QD_PHY_INT_ENABLE_REG, intType);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     
     return retVal;
 
@@ -124,20 +131,20 @@ IN GT_U16	intType
 * port -   The logical port number, unless SERDES device is accessed
 *          The physical address, if SERDES device is accessed
 * intType - the type of interrupt which causes an interrupt.
-*			any combination of 
-*			GT_SPEED_CHANGED,
-*			GT_DUPLEX_CHANGED,
-*			GT_PAGE_RECEIVED,
-*			GT_AUTO_NEG_COMPLETED,
-*			GT_LINK_STATUS_CHANGED,
-*			GT_SYMBOL_ERROR,
-*			GT_FALSE_CARRIER,
-*			GT_FIFO_FLOW,
-*			GT_CROSSOVER_CHANGED,	( Copper only )
-*			GT_DOWNSHIFT_DETECT,	( for 1000M Copper only )
-*			GT_ENERGY_DETECT,		( for 1000M Copper only )
-*			GT_POLARITY_CHANGED, and ( Copper only )
-*			GT_JABBER				(Copper only )
+*            any combination of 
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
 *
 * OUTPUTS:
 * None.
@@ -165,38 +172,43 @@ OUT  GT_U16*    intType
     GT_STATUS       retVal;      
     GT_U8           hwPort;         /* the physical port number     */
 
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetPhyIntStatus_mad(dev, port, intType);
+#endif
+
     DBG_INFO(("gprtGetPhyIntStatus Called.\n"));
    
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PHY(port);
-	if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
-	{
-		if(!(dev->validSerdesVec & (1 << hwPort)))
-		{
-			if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
-				GT_GET_SERDES_PORT(dev,&hwPort);
-		}
-		if(hwPort >= dev->maxPhyNum)
-		{
-			return GT_NOT_SUPPORTED;
-		}
-	}
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
-	/* check if the port is configurable */
-	if(!IS_CONFIGURABLE_PHY(dev,hwPort))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_STATUS_REG, intType);
+    retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_STATUS_REG, intType);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     
     return retVal;
 }
@@ -236,7 +248,12 @@ OUT GT_U16     *intPortMask
 {
     GT_STATUS       retVal;      
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			portVec;
+    GT_U16            portVec;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gprtGetPhyIntPortSummary_mad(dev, intPortMask);
+#endif
 
     DBG_INFO(("gprtGetPhyIntPortSummary Called.\n"));
    
@@ -245,35 +262,35 @@ OUT GT_U16     *intPortMask
 
     *intPortMask=0;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_INTERNAL_GPHY))
-	{
-	    /* get the interrupt port summary from global register */
-	    retVal = hwGetGlobal2RegField(dev,QD_REG_PHYINT_SOURCE,0,dev->maxPorts,&portVec);
-		GT_GIG_PHY_INT_MASK(dev,portVec);
-		*intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
-	}
-	else
-	{
-	    /* get the interrupt port summary from phy */
-		retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_PORT_SUMMARY_REG, &portVec);
-		*intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_INTERNAL_GPHY))
+    {
+        /* get the interrupt port summary from global register */
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PHYINT_SOURCE,0,dev->maxPorts,&portVec);
+        GT_GIG_PHY_INT_MASK(dev,portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+    else
+    {
+        /* get the interrupt port summary from phy */
+        retVal = hwReadPhyReg(dev,hwPort, QD_PHY_INT_PORT_SUMMARY_REG, &portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	return retVal;
+    return retVal;
 
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt_mad.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt_mad.c
new file mode 100755
index 0000000..f794783
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPhyInt_mad.c
@@ -0,0 +1,273 @@
+#include <Copyright.h>
+
+/********************************************************************************
+* gtPhyInt.h
+* 
+* DESCRIPTION:
+* API definitions for PHY interrupt handling 
+*
+* DEPENDENCIES:
+* None.
+*
+* FILE REVISION NUMBER:
+* $Revision: 10 $
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+#include <gtDrvConfig.h>
+#include <madApi.h>
+
+/*******************************************************************************
+* gprtPhyIntEnable_mad
+*
+* DESCRIPTION:
+* Enable/Disable one PHY Interrupt
+* This register determines whether the INT# pin is asserted when an interrupt 
+* event occurs. When an interrupt occurs, the corresponding bit is set and
+* remains set until register 19 is read via the SMI. When interrupt enable
+* bits are not set in register 18, interrupt status bits in register 19 are 
+* still set when the corresponding interrupt events occur. However, the INT# 
+* is not asserted.
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt to enable/disable. any combination of 
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using  
+* logical port number.
+* For 88E6161 and 88E6165 devices, Serdes port 5 (address 0xD) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal 
+* PHY.)
+*******************************************************************************/
+
+
+GT_STATUS gprtPhyIntEnable_mad
+(
+IN GT_QD_DEV    *dev,
+IN GT_LPORT    port,
+IN GT_U16    intType
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_INT_TYPE    mintType;
+
+    DBG_INFO(("gprtPhyIntEnable_mad Called.\n"));
+    
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+	mintType.intGroup0 = 0;
+	mintType.intGroup1 = 0;
+	mintType.intGroup0 = intType;
+    if(mdIntSetEnable(&(dev->mad_dev),hwPort,&mintType) != MAD_OK)
+    {
+        DBG_INFO(("Call mdIntSetEnable failed.\n"));
+        return GT_FAIL;
+    }
+
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gprtGetPhyIntStatus_mad
+*
+* DESCRIPTION:
+* Check to see if a specific type of interrupt occured
+*
+* INPUTS:
+* port -   The logical port number, unless SERDES device is accessed
+*          The physical address, if SERDES device is accessed
+* intType - the type of interrupt which causes an interrupt.
+*            any combination of 
+*            GT_SPEED_CHANGED,
+*            GT_DUPLEX_CHANGED,
+*            GT_PAGE_RECEIVED,
+*            GT_AUTO_NEG_COMPLETED,
+*            GT_LINK_STATUS_CHANGED,
+*            GT_SYMBOL_ERROR,
+*            GT_FALSE_CARRIER,
+*            GT_FIFO_FLOW,
+*            GT_CROSSOVER_CHANGED,    ( Copper only )
+*            GT_DOWNSHIFT_DETECT,    ( for 1000M Copper only )
+*            GT_ENERGY_DETECT,        ( for 1000M Copper only )
+*            GT_POLARITY_CHANGED, and ( Copper only )
+*            GT_JABBER                (Copper only )
+*
+* OUTPUTS:
+* None.
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* For 88E6131, 88E6122, and 88E6108 devices, Serdes port can be accessed using  
+* logical port number.
+* For 88E6161 and 88E6165 devices, Serdes port 5 (address 0xD) can be accessed
+* using logical port number, but not port 4 (since port 4 could be an internal 
+* PHY.)
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntStatus_mad
+(
+IN   GT_QD_DEV  *dev,
+IN   GT_LPORT   port,
+OUT  GT_U16*    intType
+)
+{
+    GT_U8           hwPort;         /* the physical port number     */
+    MAD_INT_TYPE    mintType;
+
+    DBG_INFO(("gprtGetPhyIntStatus_mad Called.\n"));
+   
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PHY(port);
+    if((IS_IN_DEV_GROUP(dev,DEV_SERDES_CORE)) && (hwPort > 3))
+    {
+        if(!(dev->validSerdesVec & (1 << hwPort)))
+        {
+            if(!((IS_IN_DEV_GROUP(dev,DEV_88E6165_FAMILY)) && (hwPort == 4)))
+                GT_GET_SERDES_PORT(dev,&hwPort);
+        }
+        if(hwPort >= dev->maxPhyNum)
+        {
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    /* check if the port is configurable */
+    if(!IS_CONFIGURABLE_PHY(dev,hwPort))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if(mdIntGetStatus(&(dev->mad_dev),hwPort,&mintType) != MAD_OK)
+    {
+        DBG_INFO(("Call mdIntGetStatus failed.\n"));
+        return GT_FAIL;
+    }
+	
+	*intType = mintType.intGroup0;
+
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gprtGetPhyIntPortSummary_mad
+*
+* DESCRIPTION:
+* Lists the ports that have active interrupts. It provides a quick way to 
+* isolate the interrupt so that the MAC or switch does not have to poll the
+* interrupt status register (19) for all ports. Reading this register does not
+* de-assert the INT# pin
+*
+* INPUTS:
+* none
+*
+* OUTPUTS:
+* GT_U8 *intPortMask - bit Mask with the bits set for the corresponding 
+* phys with active interrupt. E.g., the bit number 0 and 2 are set when 
+* port number 0 and 2 have active interrupt
+*
+* RETURNS:
+* GT_OK - on success
+* GT_FAIL - on error
+*
+* COMMENTS:
+* 88E3081 data sheet register 20
+* For 88E6165, 88E6375 devices, geventGetDevIntStatus should be used instead.
+*
+*******************************************************************************/
+
+GT_STATUS gprtGetPhyIntPortSummary_mad
+(
+IN  GT_QD_DEV  *dev,
+OUT GT_U16     *intPortMask
+)
+{
+    GT_STATUS       retVal;      
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          portVec;
+    MAD_U32         mportVec;
+
+    DBG_INFO(("gprtGetPhyIntPortSummary_mad Called.\n"));
+   
+    /* translate LPORT 0 to hardware port */
+    hwPort = GT_LPORT_2_PORT(0);
+
+    *intPortMask=0;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DEV_PHY_INTERRUPT))
+    {
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_INTERNAL_GPHY))
+    {
+        /* get the interrupt port summary from global register */
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PHYINT_SOURCE,0,dev->maxPorts,&portVec);
+        GT_GIG_PHY_INT_MASK(dev,portVec);
+        *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+    }
+    else
+    {
+        /* get the interrupt port summary from phy */
+      if(mdIntGetPortSummary(&(dev->mad_dev), &mportVec) != MAD_OK)
+	  {
+        DBG_INFO(("Call mdIntGetPortSummary failed.\n"));
+        return GT_FAIL;
+	  }
+      portVec = mportVec;
+      *intPortMask = (GT_U16)GT_PORTVEC_2_LPORTVEC(portVec);
+	}
+
+    return GT_OK;
+
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPolicy.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPolicy.c
old mode 100644
new mode 100755
index 4db5745..2e63ec2
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPolicy.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPolicy.c
@@ -21,40 +21,40 @@
 *
 * DESCRIPTION:
 *       This routine sets the Policy for ports.
-*		Supported Policies are defined as GT_FRAME_POLICY as follows:
-*			FRAME_POLICY_NONE    - normal frame switching
-*			FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
-*			FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
-*			FRAME_POLICY_DISCARD - discard(filter) the frame
-*		Supported Policy types are defined as GT_POLICY_TYPE:
-*			POLICY_TYPE_DA - DA Policy Mapping
-*				DA Policy Mapping occurs when the DA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_SA - SA Policy Mapping
-*				SA Policy Mapping occurs when the SA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_VTU - VTU Policy Mapping
-*				VTU Policy Mapping occurs when the VID of a frame is contained in
-*				the VTU database with the VidPolicy is enabled.
-*			POLICY_TYPE_ETYPE - EtherType Policy Mapping
-*				EType Policy Mapping occurs when the EtherType of a frame matches
-*				the PortEType (see gprtSetPortEType API)
-*			POLICY_TYPE_PPPoE - PPPoE Policy Mapping
-*				PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
-*			POLICY_TYPE_VBAS - VBAS Policy Mapping
-*				VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
-*			POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
-*				DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
-*				IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
-*				IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
-*			POLICY_TYPE_UDP - UDP Policy Mapping
-*				UDP Policy Mapping occurs when the ingressing frame is
-*				a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
 *
 * INPUTS:
-*       port	- logical port number.
-*       type 	- policy type (GT_POLICY_TYPE)
-*       policy 	- policy (GT_FRAME_POLICY)
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
+*       policy     - policy (GT_FRAME_POLICY)
 *
 * OUTPUTS:
 *       None.
@@ -63,7 +63,7 @@
 *       GT_OK            - on success
 *       GT_FAIL          - on error
 *       GT_BAD_PARAM     - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -72,16 +72,16 @@
 *******************************************************************************/
 GT_STATUS gprtSetPolicy
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT 	port,
-    IN  GT_POLICY_TYPE	type,
-	IN	GT_FRAME_POLICY	policy
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    IN    GT_FRAME_POLICY    policy
 )
 {
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* Physical port.               */
-    GT_U8	    	offset;
+    GT_U8            offset;
 
     DBG_INFO(("gprtSetPolicy Called.\n"));
 
@@ -89,54 +89,60 @@ GT_STATUS gprtSetPolicy
     hwPort = GT_LPORT_2_PORT(port);
     
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
-	{
+    if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+        return GT_NOT_SUPPORTED;
+    }
 
-	switch (policy)
-	{
-		case FRAME_POLICY_NONE:
-		case FRAME_POLICY_MIRROR:
-		case FRAME_POLICY_TRAP:
-		case FRAME_POLICY_DISCARD:
-			break;
-		default:
-	        DBG_INFO(("Bad Policy\n"));
-			return GT_BAD_PARAM;
-	}
-		
-	switch (type)
-	{
-		case POLICY_TYPE_DA:
-			offset = 14;
-			break;
-		case POLICY_TYPE_SA:
-			offset = 12;
-			break;
-		case POLICY_TYPE_VTU:
-			offset = 10;
-			break;
-		case POLICY_TYPE_ETYPE:
-			offset = 8;
-			break;
-		case POLICY_TYPE_PPPoE:
-			offset = 6;
-			break;
-		case POLICY_TYPE_VBAS:
-			offset = 4;
-			break;
-		case POLICY_TYPE_OPT82:
-			offset = 2;
-			break;
-		case POLICY_TYPE_UDP:
-			offset = 0;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+    switch (policy)
+    {
+        case FRAME_POLICY_NONE:
+        case FRAME_POLICY_MIRROR:
+        case FRAME_POLICY_TRAP:
+        case FRAME_POLICY_DISCARD:
+            break;
+        default:
+            DBG_INFO(("Bad Policy\n"));
+            return GT_BAD_PARAM;
+    }
+        
+    switch (type)
+    {
+        case POLICY_TYPE_DA:
+            offset = 14;
+            break;
+        case POLICY_TYPE_SA:
+            offset = 12;
+            break;
+        case POLICY_TYPE_VTU:
+            offset = 10;
+            break;
+        case POLICY_TYPE_ETYPE:
+            offset = 8;
+            break;
+        case POLICY_TYPE_PPPoE:
+            offset = 6;
+            break;
+        case POLICY_TYPE_VBAS:
+            offset = 4;
+            break;
+        case POLICY_TYPE_OPT82:
+            if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+            {
+              DBG_INFO(("GT_NOT_SUPPORTED\n"));
+              return GT_NOT_SUPPORTED;
+            }
+            else 
+              offset = 2;
+            break;
+        case POLICY_TYPE_UDP:
+            offset = 0;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_POLICY_CONTROL, offset, 2, (GT_U16)policy);
     if(retVal != GT_OK)
@@ -154,48 +160,48 @@ GT_STATUS gprtSetPolicy
 *
 * DESCRIPTION:
 *       This routine gets the Policy of the given policy type.
-*		Supported Policies are defined as GT_FRAME_POLICY as follows:
-*			FRAME_POLICY_NONE    - normal frame switching
-*			FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
-*			FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
-*			FRAME_POLICY_DISCARD - discard(filter) the frame
-*		Supported Policy types are defined as GT_POLICY_TYPE:
-*			POLICY_TYPE_DA - DA Policy Mapping
-*				DA Policy Mapping occurs when the DA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_SA - SA Policy Mapping
-*				SA Policy Mapping occurs when the SA of a frame is contained in 
-*				the ATU address database with an Entry State that indicates Policy.
-*			POLICY_TYPE_VTU - VTU Policy Mapping
-*				VTU Policy Mapping occurs when the VID of a frame is contained in
-*				the VTU database with the VidPolicy is enabled.
-*			POLICY_TYPE_ETYPE - EtherType Policy Mapping
-*				EType Policy Mapping occurs when the EtherType of a frame matches
-*				the PortEType (see gprtSetPortEType API)
-*			POLICY_TYPE_PPPoE - PPPoE Policy Mapping
-*				PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
-*			POLICY_TYPE_VBAS - VBAS Policy Mapping
-*				VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
-*			POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
-*				DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
-*				IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
-*				IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
-*			POLICY_TYPE_UDP - UDP Policy Mapping
-*				UDP Policy Mapping occurs when the ingressing frame is
-*				a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
+*        Supported Policies are defined as GT_FRAME_POLICY as follows:
+*            FRAME_POLICY_NONE    - normal frame switching
+*            FRAME_POLICY_MIRROR  - mirror (copy) frame to MirrorDest port
+*            FRAME_POLICY_TRAP    - trap(re-direct) frame to the CPUDest port
+*            FRAME_POLICY_DISCARD - discard(filter) the frame
+*        Supported Policy types are defined as GT_POLICY_TYPE:
+*            POLICY_TYPE_DA - DA Policy Mapping
+*                DA Policy Mapping occurs when the DA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_SA - SA Policy Mapping
+*                SA Policy Mapping occurs when the SA of a frame is contained in 
+*                the ATU address database with an Entry State that indicates Policy.
+*            POLICY_TYPE_VTU - VTU Policy Mapping
+*                VTU Policy Mapping occurs when the VID of a frame is contained in
+*                the VTU database with the VidPolicy is enabled.
+*            POLICY_TYPE_ETYPE - EtherType Policy Mapping
+*                EType Policy Mapping occurs when the EtherType of a frame matches
+*                the PortEType (see gprtSetPortEType API)
+*            POLICY_TYPE_PPPoE - PPPoE Policy Mapping
+*                PPPoE Policy Mapping occurs when the EtherType of a frame matches 0x8863
+*            POLICY_TYPE_VBAS - VBAS Policy Mapping
+*                VBAS Policy Mapping occurs when the EtherType of a frame matches 0x8200
+*            POLICY_TYPE_OPT82 - DHCP Option 82 Policy Mapping
+*                DHCP Option 82 Policy Mapping occurs when the ingressing frame is an
+*                IPv4 UDP with a UDP Destination port = 0x0043 or 0x0044, or an
+*                IPv6 UDP with a UDP Destination port = 0x0223 or 0x0222
+*            POLICY_TYPE_UDP - UDP Policy Mapping
+*                UDP Policy Mapping occurs when the ingressing frame is
+*                a Broadcast IPv4 UDP or a Multicast IPv6 UDP.
 *
 * INPUTS:
-*       port	- logical port number.
-*       type 	- policy type (GT_POLICY_TYPE)
+*       port    - logical port number.
+*       type     - policy type (GT_POLICY_TYPE)
 *
 * OUTPUTS:
-*       policy 	- policy (GT_FRAME_POLICY)
+*       policy     - policy (GT_FRAME_POLICY)
 *
 * RETURNS:
 *       GT_OK            - on success
 *       GT_FAIL          - on error
 *       GT_BAD_PARAM     - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -204,17 +210,17 @@ GT_STATUS gprtSetPolicy
 *******************************************************************************/
 GT_STATUS gprtGetPolicy
 (
-    IN  GT_QD_DEV 	*dev,
-    IN  GT_LPORT 	port,
-    IN  GT_POLICY_TYPE	type,
-	OUT GT_FRAME_POLICY	*policy
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT     port,
+    IN  GT_POLICY_TYPE    type,
+    OUT GT_FRAME_POLICY    *policy
 )
 {
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* Physical port.               */
-    GT_U8	    	offset;
-	GT_U16			data;
+    GT_U8            offset;
+    GT_U16            data;
 
     DBG_INFO(("gprtGetPolicy Called.\n"));
 
@@ -222,42 +228,42 @@ GT_STATUS gprtGetPolicy
     hwPort = GT_LPORT_2_PORT(port);
     
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
-	{
+    if (!IS_IN_DEV_GROUP(dev,DEV_POLICY))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-	
-	switch (type)
-	{
-		case POLICY_TYPE_DA:
-			offset = 14;
-			break;
-		case POLICY_TYPE_SA:
-			offset = 12;
-			break;
-		case POLICY_TYPE_VTU:
-			offset = 10;
-			break;
-		case POLICY_TYPE_ETYPE:
-			offset = 8;
-			break;
-		case POLICY_TYPE_PPPoE:
-			offset = 6;
-			break;
-		case POLICY_TYPE_VBAS:
-			offset = 4;
-			break;
-		case POLICY_TYPE_OPT82:
-			offset = 2;
-			break;
-		case POLICY_TYPE_UDP:
-			offset = 0;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+        return GT_NOT_SUPPORTED;
+    }
+    
+    switch (type)
+    {
+        case POLICY_TYPE_DA:
+            offset = 14;
+            break;
+        case POLICY_TYPE_SA:
+            offset = 12;
+            break;
+        case POLICY_TYPE_VTU:
+            offset = 10;
+            break;
+        case POLICY_TYPE_ETYPE:
+            offset = 8;
+            break;
+        case POLICY_TYPE_PPPoE:
+            offset = 6;
+            break;
+        case POLICY_TYPE_VBAS:
+            offset = 4;
+            break;
+        case POLICY_TYPE_OPT82:
+            offset = 2;
+            break;
+        case POLICY_TYPE_UDP:
+            offset = 0;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_POLICY_CONTROL, offset, 2, &data);
     if(retVal != GT_OK)
@@ -266,7 +272,7 @@ GT_STATUS gprtGetPolicy
         return retVal;
     }
 
-	*policy = (GT_FRAME_POLICY)data;
+    *policy = (GT_FRAME_POLICY)data;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c
old mode 100644
new mode 100755
index 332f150..cab9e4a
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortCtrl.c
@@ -56,40 +56,40 @@ GT_STATUS gprtSetForceFc
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
-	{
-		if(force)
-			data = 3;
-		else
-			data = 0;
-			
-		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,data);
-		if(retVal != GT_OK)
-		{
-			DBG_INFO(("Failed.\n"));
-		}
-		else
-		{
-			DBG_INFO(("OK.\n"));
-		}
-		return retVal;		
-	}
-
-	/* Port should be disabled before Set Force Flow Control bit */
-	retVal = gstpGetPortState(dev,port, &state);
+    /* check if device allows to force a flowcontrol disabled */
+    if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        if(force)
+            data = 3;
+        else
+            data = 0;
+            
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+        return retVal;        
+    }
+
+    /* Port should be disabled before Set Force Flow Control bit */
+    retVal = gstpGetPortState(dev,port, &state);
     if(retVal != GT_OK)
-	{
-	    DBG_INFO(("gstpGetPortState failed.\n"));
-		return retVal;
-	}
+    {
+        DBG_INFO(("gstpGetPortState failed.\n"));
+        return retVal;
+    }
 
-	retVal = gstpSetPortState(dev,port, GT_PORT_DISABLE);
+    retVal = gstpSetPortState(dev,port, GT_PORT_DISABLE);
     if(retVal != GT_OK)
-	{
-	    DBG_INFO(("gstpSetPortState failed.\n"));
-		return retVal;
-	}
+    {
+        DBG_INFO(("gstpSetPortState failed.\n"));
+        return retVal;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(force, data);
@@ -97,20 +97,20 @@ GT_STATUS gprtSetForceFc
     /* Set the force flow control bit.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	/* Restore original stp state. */
-	if(gstpSetPortState(dev,port, state) != GT_OK)
-	{
-	    DBG_INFO(("gstpSetPortState failed.\n"));
-		return GT_FAIL;
-	}
+    /* Restore original stp state. */
+    if(gstpSetPortState(dev,port, state) != GT_OK)
+    {
+        DBG_INFO(("gstpSetPortState failed.\n"));
+        return GT_FAIL;
+    }
 
     return retVal;
 }
@@ -154,39 +154,39 @@ GT_STATUS gprtGetForceFc
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
-	{
-		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,&data);
-		if(retVal != GT_OK)
-		{
-			DBG_INFO(("Failed.\n"));
-		}
-		else
-		{
-			DBG_INFO(("OK.\n"));
-		}
-
-		if(data & 0x1)
-			*force = GT_TRUE;
-		else
-			*force = GT_FALSE;
-			
-		return retVal;		
-	}
+    /* check if device allows to force a flowcontrol disabled */
+    if (IS_IN_DEV_GROUP(dev,DEV_FC_WITH_VALUE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PCS_CONTROL,6,2,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+
+        if(data & 0x1)
+            *force = GT_TRUE;
+        else
+            *force = GT_FALSE;
+            
+        return retVal;        
+    }
 
     /* Get the force flow control bit.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *force);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -196,12 +196,12 @@ GT_STATUS gprtGetForceFc
 * gprtSetUseCoreTag
 *
 * DESCRIPTION:
-*		This routine set the UseCoreTag bit in Port Control Register.
-*		When this bit is cleared to a zero, ingressing frames are considered
-*		Tagged if the 16-bits following the frame's Source Address is 0x8100.
-*		When this bit is set to a one, ingressing frames are considered Tagged
-*		if the 16-bits following the frame's Source Address is equal to the 
-*		CoreTag register value.
+*        This routine set the UseCoreTag bit in Port Control Register.
+*        When this bit is cleared to a zero, ingressing frames are considered
+*        Tagged if the 16-bits following the frame's Source Address is 0x8100.
+*        When this bit is set to a one, ingressing frames are considered Tagged
+*        if the 16-bits following the frame's Source Address is equal to the 
+*        CoreTag register value.
 *
 * INPUTS:
 *       port  - the logical port number.
@@ -236,12 +236,12 @@ GT_STATUS gprtSetUseCoreTag
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(force, data);
@@ -249,13 +249,13 @@ GT_STATUS gprtSetUseCoreTag
     /* Set the UseCoreTag bit.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -299,24 +299,24 @@ GT_STATUS gprtGetUseCoreTag
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the UseCoreTag bit.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,15,1,&data);
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *force);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -359,47 +359,50 @@ GT_STATUS gprtSetTrailerMode
     DBG_INFO(("gprtSetTrailerMode Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
-	{
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if(hwPort < 4)
-	{
-	    /* check if device supports this feature for this port */
-		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
-	else if(hwPort == 4)
-	{
-	    /* check if device supports this feature for this port*/
-		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
+    if(hwPort < 4)
+    {
+        /* check if device supports this feature for this port */
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        /* check if device supports this feature for this port*/
+        if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     /* Set the trailer mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -441,46 +444,49 @@ GT_STATUS gprtGetTrailerMode
     DBG_INFO(("gprtGetTrailerMode Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5))
-	{
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+          (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if(hwPort < 4)
-	{
-	    /* check if device supports this feature for this port */
-		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5|DEV_TRAILER_P4P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
-	else if(hwPort == 4)
-	{
-	    /* check if device supports this feature for this port */
-		if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
+    if(hwPort < 4)
+    {
+        /* check if device supports this feature for this port */
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        /* check if device supports this feature for this port */
+        if (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     /* Get the Trailer mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,&data);
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -526,11 +532,11 @@ GT_STATUS gprtSetIngressMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Gigabit Switch does not support this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    /* Gigabit Switch does not support this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* check if device supports this feature */
@@ -540,33 +546,35 @@ GT_STATUS gprtSetIngressMode
             break;
 
         case (GT_TRAILER_INGRESS):
-		    if(!(IS_IN_DEV_GROUP(dev,DEV_TRAILER|DEV_TRAILER_P5|DEV_TRAILER_P4P5)))
-			{
-			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
-				return GT_NOT_SUPPORTED;
-			}
+            if (!((IS_IN_DEV_GROUP(dev,DEV_TRAILER)) ||
+                  (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+                  (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5))))
+	 {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
             break;
 
         case (GT_UNTAGGED_INGRESS):
-		    if(!(IS_IN_DEV_GROUP(dev,DEV_TAGGING)))
-			{
-			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
-				return GT_NOT_SUPPORTED;
-			}
+            if(!(IS_IN_DEV_GROUP(dev,DEV_TAGGING)))
+            {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
             break;
 
         case (GT_CPUPORT_INGRESS):
-		    if(!(IS_IN_DEV_GROUP(dev,DEV_IGMP_SNOOPING)))
-			{
-			    DBG_INFO(("Given ingress mode is not supported by this device\n"));
-				return GT_NOT_SUPPORTED;
-			}
-
-			if(hwPort != GT_LPORT_2_PORT(dev->cpuPortNum))
-			{
-			    DBG_INFO(("Given ingress mode is supported by CPU port only\n"));
-				return GT_NOT_SUPPORTED;
-			}
+            if(!(IS_IN_DEV_GROUP(dev,DEV_IGMP_SNOOPING)))
+            {
+                DBG_INFO(("Given ingress mode is not supported by this device\n"));
+                return GT_NOT_SUPPORTED;
+            }
+
+            if(hwPort != GT_LPORT_2_PORT(dev->cpuPortNum))
+            {
+                DBG_INFO(("Given ingress mode is supported by CPU port only\n"));
+                return GT_NOT_SUPPORTED;
+            }
 
             break;
 
@@ -578,13 +586,13 @@ GT_STATUS gprtSetIngressMode
     /* Set the Ingress Mode.        */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,2,(GT_U16)mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -627,11 +635,11 @@ GT_STATUS gprtGetIngressMode
 
     DBG_INFO(("gprtGetIngressMode Called.\n"));
 
-	/* Gigabit Switch does not support this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    /* Gigabit Switch does not support this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate LPORT to hardware port */
@@ -640,13 +648,13 @@ GT_STATUS gprtGetIngressMode
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2,&data);
     *mode = data;
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -699,13 +707,13 @@ GT_STATUS gprtSetMcRateLimit
     /* Set the multicast rate limit.    */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,(GT_U16)rate);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -760,13 +768,13 @@ GT_STATUS gprtGetMcRateLimit
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 2, 2,&data);
     *rate = data;
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -777,23 +785,23 @@ GT_STATUS gprtGetMcRateLimit
 * gprtSetIGMPSnoop
 *
 * DESCRIPTION:
-* 		This routine set the IGMP Snoop. When set to one and this port receives
-*		IGMP frame, the frame is switched to the CPU port, overriding all other 
-*		switching decisions, with exception for CPU's Trailer.
-*		CPU port is determined by the Ingress Mode bits. A port is considered 
-*		the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
-*		GT_CPUPORT_INGRESS.
+*         This routine set the IGMP Snoop. When set to one and this port receives
+*        IGMP frame, the frame is switched to the CPU port, overriding all other 
+*        switching decisions, with exception for CPU's Trailer.
+*        CPU port is determined by the Ingress Mode bits. A port is considered 
+*        the CPU port if its Ingress Mode are either GT_TRAILER_INGRESS or 
+*        GT_CPUPORT_INGRESS.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for IGMP Snoop or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS: 
 *
@@ -827,13 +835,13 @@ GT_STATUS gprtSetIGMPSnoop
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,10,1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -850,7 +858,7 @@ GT_STATUS gprtSetIGMPSnoop
 *
 * OUTPUTS:
 *       mode - GT_TRUE: IGMP Snoop enabled
-*	       GT_FALSE otherwise
+*           GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -887,13 +895,13 @@ GT_STATUS gprtGetIGMPSnoop
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -938,10 +946,10 @@ GT_STATUS gprtSetHeaderMode
     /* only devices beyond quarterdeck (6052) has this feature */
     /* Fullsail (DEV_QD_88E6502) is an exception, and does not support this feature */
     if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -949,34 +957,35 @@ GT_STATUS gprtSetHeaderMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if(hwPort < 4)
-	{
-		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
-	else if(hwPort == 4)
-	{
-		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
+    if(hwPort < 4)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     /* Set the header mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,11,1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -993,7 +1002,7 @@ GT_STATUS gprtSetHeaderMode
 *
 * OUTPUTS:
 *       mode - GT_TRUE: header mode enabled
-*	       GT_FALSE otherwise
+*           GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1020,30 +1029,31 @@ GT_STATUS gprtGetHeaderMode
     /* only devices beyond quarterdeck (6052) has this feature */
     /* Fullsail (DEV_QD_88E602) is an exception, and does not support this feature */
     if(IS_VALID_API_CALL(dev,port, DEV_HEADER|DEV_HEADER_P5|DEV_HEADER_P4P5) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if(hwPort < 4)
-	{
-		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5|DEV_HEADER_P4P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
-	else if(hwPort == 4)
-	{
-		if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
-		{
-	        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-    	    return GT_NOT_SUPPORTED;
-		}
-	}
+    if(hwPort < 4)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_TRAILER_P5)) ||
+            (IS_IN_DEV_GROUP(dev,DEV_TRAILER_P4P5)))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+    else if(hwPort == 4)
+    {
+        if (IS_IN_DEV_GROUP(dev,DEV_HEADER_P5))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     /* Get the Header Mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 11, 1, &data);
@@ -1051,13 +1061,13 @@ GT_STATUS gprtGetHeaderMode
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1069,10 +1079,10 @@ GT_STATUS gprtGetHeaderMode
 *
 * DESCRIPTION:
 *       This routine set protected mode of a switch port. 
-*		When this mode is set to GT_TRUE, frames are allowed to egress port
-*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
-*		allow the frame to Egress.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
 *
 * INPUTS:
 *       port - the logical port number.
@@ -1103,18 +1113,18 @@ GT_STATUS gprtSetProtectedMode
 
     DBG_INFO(("gprtSetProtectedMode Called.\n"));
 
-	/* Check if this feature is supported */
+    /* Check if this feature is supported */
     if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -1126,13 +1136,13 @@ GT_STATUS gprtSetProtectedMode
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,3,1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1141,17 +1151,17 @@ GT_STATUS gprtSetProtectedMode
 *
 * DESCRIPTION:
 *       This routine gets protected mode of a switch port. 
-*		When this mode is set to GT_TRUE, frames are allowed to egress port
-*		defined by the 802.1Q VLAN membership for the frame's VID 'AND'
-*		by the port's VLANTable if 802.1Q is enabled on the port. Both must
-*		allow the frame to Egress.
+*        When this mode is set to GT_TRUE, frames are allowed to egress port
+*        defined by the 802.1Q VLAN membership for the frame's VID 'AND'
+*        by the port's VLANTable if 802.1Q is enabled on the port. Both must
+*        allow the frame to Egress.
 *
 * INPUTS:
 *       port  - the logical port number.
 *
 * OUTPUTS:
 *       mode - GT_TRUE: header mode enabled
-*	       GT_FALSE otherwise
+*           GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1176,16 +1186,16 @@ GT_STATUS gprtGetProtectedMode
     DBG_INFO(("gprtGetProtectedMode Called.\n"));
 
     if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_CROSS_CHIP_VLAN))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
@@ -1196,13 +1206,13 @@ GT_STATUS gprtGetProtectedMode
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1212,9 +1222,9 @@ GT_STATUS gprtGetProtectedMode
 *
 * DESCRIPTION:
 *       This routine set Forward Unknown mode of a switch port. 
-*		When this mode is set to GT_TRUE, normal switch operation occurs.
-*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
-*		will not egress out this port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
 *
 * INPUTS:
 *       port - the logical port number.
@@ -1246,10 +1256,10 @@ GT_STATUS gprtSetForwardUnknown
     DBG_INFO(("gprtSetForwardUnknown Called.\n"));
 
     if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY|DEV_EGRESS_FLOOD) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -1261,13 +1271,13 @@ GT_STATUS gprtSetForwardUnknown
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1276,16 +1286,16 @@ GT_STATUS gprtSetForwardUnknown
 *
 * DESCRIPTION:
 *       This routine gets Forward Unknown mode of a switch port. 
-*		When this mode is set to GT_TRUE, normal switch operation occurs.
-*		When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
-*		will not egress out this port.
+*        When this mode is set to GT_TRUE, normal switch operation occurs.
+*        When this mode is set to GT_FALSE, unicast frame with unknown DA addresses
+*        will not egress out this port.
 *
 * INPUTS:
 *       port  - the logical port number.
 *
 * OUTPUTS:
 *       mode - GT_TRUE: header mode enabled
-*	       GT_FALSE otherwise
+*           GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1310,10 +1320,10 @@ GT_STATUS gprtGetForwardUnknown
     DBG_INFO(("gprtGetForwardUnknown Called.\n"));
 
     if(IS_VALID_API_CALL(dev,port, DEV_PORT_SECURITY|DEV_EGRESS_FLOOD) != GT_OK)
-	{
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
@@ -1324,13 +1334,13 @@ GT_STATUS gprtGetForwardUnknown
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1340,20 +1350,20 @@ GT_STATUS gprtGetForwardUnknown
 * gprtSetDropOnLock
 *
 * DESCRIPTION:
-*		This routine set the Drop on Lock. When set to one, Ingress frames will
-*		be discarded if their SA field is not in the ATU's address database.
+*        This routine set the Drop on Lock. When set to one, Ingress frames will
+*        be discarded if their SA field is not in the ATU's address database.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for Unknown SA drop or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1362,42 +1372,42 @@ GT_STATUS gprtGetForwardUnknown
 *******************************************************************************/
 GT_STATUS gprtSetDropOnLock
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSetDropOnLock Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the DropOnLock mode.            */
-	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDropOnLock Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DropOnLock mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -1406,19 +1416,19 @@ GT_STATUS gprtSetDropOnLock
 * gprtGetDropOnLock
 *
 * DESCRIPTION:
-*		This routine gets DropOnLock mode.
+*        This routine gets DropOnLock mode.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: DropOnLock enabled,
-*				 GT_FALSE otherwise
+*        mode - GT_TRUE: DropOnLock enabled,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -1427,66 +1437,66 @@ GT_STATUS gprtSetDropOnLock
 *******************************************************************************/
 GT_STATUS gprtGetDropOnLock
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16          data;           /* to keep the read valve       */
-
-	DBG_INFO(("gprtGetDropOnLock Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Get the DropOnLock Mode.            */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 14, 1, &data);
-
-	/* translate binary to BOOL  */
-	BIT_2_BOOL(data, *mode);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDropOnLock Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DropOnLock Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 14, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
 }
 
 /*******************************************************************************
 * gprtSetDoubleTag
 *
 * DESCRIPTION:
-*		This routine set the Ingress Double Tag Mode. When set to one, 
-*		ingressing frames are examined to see if they contain an 802.3ac tag.
-*		If they do, the tag is removed and then the frame is processed from
-*		there (i.e., removed tag is ignored). Essentially, untagged frames
-*		remain untagged, single tagged frames become untagged and double tagged
-*		frames become single tagged.
+*        This routine set the Ingress Double Tag Mode. When set to one, 
+*        ingressing frames are examined to see if they contain an 802.3ac tag.
+*        If they do, the tag is removed and then the frame is processed from
+*        there (i.e., removed tag is ignored). Essentially, untagged frames
+*        remain untagged, single tagged frames become untagged and double tagged
+*        frames become single tagged.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for DoulbeTag mode or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1495,42 +1505,42 @@ GT_STATUS gprtGetDropOnLock
 *******************************************************************************/
 GT_STATUS gprtSetDoubleTag
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSetDoubleTag Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the DoubleTag mode.            */
-	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,9,1,data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetDoubleTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the DoubleTag mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,9,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -1539,19 +1549,19 @@ GT_STATUS gprtSetDoubleTag
 * gprtGetDoubleTag
 *
 * DESCRIPTION:
-*		This routine gets DoubleTag mode.
+*        This routine gets DoubleTag mode.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: DoubleTag enabled,
-*				 GT_FALSE otherwise
+*        mode - GT_TRUE: DoubleTag enabled,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -1560,42 +1570,42 @@ GT_STATUS gprtSetDoubleTag
 *******************************************************************************/
 GT_STATUS gprtGetDoubleTag
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16          data;           /* to keep the read valve       */
-
-	DBG_INFO(("gprtGetDoubleTag Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Get the DoubleTag Mode.            */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 9, 1, &data);
-
-	/* translate binary to BOOL  */
-	BIT_2_BOOL(data, *mode);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetDoubleTag Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_INGRESS_DOUBLE_TAGGING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DoubleTag Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 9, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
 }
 
 
@@ -1603,21 +1613,21 @@ GT_STATUS gprtGetDoubleTag
 * gprtSetInterswitchPort
 *
 * DESCRIPTION:
-*		This routine set Interswitch Port. When set to one, 
-*		it indicates this port is a interswitch port used to communicated with
-*		CPU or to cascade with another switch device.
+*        This routine set Interswitch Port. When set to one, 
+*        it indicates this port is a interswitch port used to communicated with
+*        CPU or to cascade with another switch device.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for Interswitch port or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1626,43 +1636,43 @@ GT_STATUS gprtGetDoubleTag
 *******************************************************************************/
 GT_STATUS gprtSetInterswitchPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSetInterswitchPort Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the InterswitchPort.            */
-	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
-}
+    GT_U16          data;           
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetInterswitchPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the InterswitchPort.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
+}
 
 
 
@@ -1670,19 +1680,19 @@ GT_STATUS gprtSetInterswitchPort
 * gprtGetInterswithPort
 *
 * DESCRIPTION:
-*		This routine gets InterswitchPort.
+*        This routine gets InterswitchPort.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: This port is interswitch port,
-*				 GT_FALSE otherwise
+*        mode - GT_TRUE: This port is interswitch port,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -1691,62 +1701,62 @@ GT_STATUS gprtSetInterswitchPort
 *******************************************************************************/
 GT_STATUS gprtGetInterswitchPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16          data;           /* to keep the read valve       */
-
-	DBG_INFO(("gprtGetInterswitchPort Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Get the InterswitchPort Mode.            */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 1, &data);
-
-	/* translate binary to BOOL  */
-	BIT_2_BOOL(data, *mode);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetInterswitchPort Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the InterswitchPort Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
 }
 
 /*******************************************************************************
 * gprtSetLearnDisable
 *
 * DESCRIPTION:
-*		This routine enables/disables automatic learning of new source MAC
-*		addresses on the given port ingress
+*        This routine enables/disables automatic learning of new source MAC
+*        addresses on the given port ingress
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for disable or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for disable or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1755,42 +1765,42 @@ GT_STATUS gprtGetInterswitchPort
 *******************************************************************************/
 GT_STATUS gprtSetLearnDisable
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
-	GT_U16          data;           
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSetLearnDisable Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the LearnDisable mode.            */
-	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,11,1,data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetLearnDisable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the LearnDisable mode.            */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,11,1,data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -1798,19 +1808,19 @@ GT_STATUS gprtSetLearnDisable
 * gprtGetLearnDisable
 *
 * DESCRIPTION:
-*		This routine gets LearnDisable setup
+*        This routine gets LearnDisable setup
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: Learning disabled on the given port ingress frames,
-*				 GT_FALSE otherwise
+*        mode - GT_TRUE: Learning disabled on the given port ingress frames,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -1819,63 +1829,63 @@ GT_STATUS gprtSetLearnDisable
 *******************************************************************************/
 GT_STATUS gprtGetLearnDisable
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16          data;           /* to keep the read valve       */
-
-	DBG_INFO(("gprtGetLearnDisable Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Get the LearnDisable Mode.            */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 11, 1, &data);
-
-	/* translate binary to BOOL  */
-	BIT_2_BOOL(data, *mode);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
+
+    DBG_INFO(("gprtGetLearnDisable Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the LearnDisable Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 11, 1, &data);
+
+    /* translate binary to BOOL  */
+    BIT_2_BOOL(data, *mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    return retVal;
 }
 
 /*******************************************************************************
 * gprtSetIgnoreFCS
 *
 * DESCRIPTION:
-*		This routine sets FCS Ignore mode. When this bit is set to a one,
-*		the last four bytes of frames received on this port are overwritten with
-*		a good CRC and the frames will be accepted by the switch.
+*        This routine sets FCS Ignore mode. When this bit is set to a one,
+*        the last four bytes of frames received on this port are overwritten with
+*        a good CRC and the frames will be accepted by the switch.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for ignore FCS or GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1884,49 +1894,53 @@ GT_STATUS gprtGetLearnDisable
 *******************************************************************************/
 GT_STATUS gprtSetIgnoreFCS
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL 		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL         mode
 )
 {
-	GT_U16          data;           
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSetIgnoreFCS Called.\n"));
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate BOOL to binary */
-	BOOL_2_BIT(mode, data);
-
-	/* Set the IgnoreFCS mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
-	{
-		retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,data );
-	}
-	else
-	{
-		retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,10,1,data);
-	}
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-	return retVal;
+    GT_U16          data;           
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSetIgnoreFCS Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate BOOL to binary */
+    BOOL_2_BIT(mode, data);
+
+    /* Set the IgnoreFCS mode.            */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP,10,1,data);
+    }
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+    return retVal;
 }
 
 
@@ -1934,19 +1948,19 @@ GT_STATUS gprtSetIgnoreFCS
 * gprtGetIgnoreFCS
 *
 * DESCRIPTION:
-*		This routine gets Ignore FCS setup
+*        This routine gets Ignore FCS setup
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
-*				 GT_FALSE otherwise
+*        mode - GT_TRUE: Ignore FCS on the given port's ingress frames,
+*                 GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -1955,9 +1969,9 @@ GT_STATUS gprtSetIgnoreFCS
 *******************************************************************************/
 GT_STATUS gprtGetIgnoreFCS
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1969,33 +1983,37 @@ GT_STATUS gprtGetIgnoreFCS
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the IgnoreFCS Mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
-	{
-		retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,&data );
-	}
-	else
-	{
-		retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 1, &data);
-	}
+    if ((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,15,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 1, &data);
+    }
 
     /* translate binary to BOOL  */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -2005,45 +2023,45 @@ GT_STATUS gprtGetIgnoreFCS
 * gprtSetVTUPriOverride
 *
 * DESCRIPTION:
-*		VTU Priority Override. The following modes are supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtSetVTUPriOverride
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_PRI_OVERRIDE		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_PRI_OVERRIDE        mode
 )
 {
     GT_U16          data;           
@@ -2055,66 +2073,66 @@ GT_STATUS gprtSetVTUPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	switch (mode)
-	{
-		case PRI_OVERRIDE_NONE:
-			data = 0;
-			break;
-		case PRI_OVERRIDE_FRAME_QUEUE:
-			if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-				data = 3;
-			}
-			else
-			{
-				data = 1;
-			}
-			break;
-		case PRI_OVERRIDE_FRAME:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 1;
-			break;
-		case PRI_OVERRIDE_QUEUE:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 2;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     /* Set the VTUPri Override mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,data);
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2123,43 +2141,43 @@ GT_STATUS gprtSetVTUPriOverride
 * gprtGetVTUPriOverride
 *
 * DESCRIPTION:
-*		VTU Priority Override. The following modes are supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's VID (in the VTU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        VTU Priority Override. The following modes are supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's VID (in the VTU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtGetVTUPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PRI_OVERRIDE        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2171,52 +2189,52 @@ GT_STATUS gprtGetVTUPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the VTUPriOverride Mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,&data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 14, 1, &data);
-		if(data == 1) 
-			data = 3;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,10,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 14, 1, &data);
+        if(data == 1) 
+            data = 3;
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
-
-	switch (data)
-	{
-		case 0:
-			*mode = PRI_OVERRIDE_NONE;
-			break;
-		case 3:
-			*mode = PRI_OVERRIDE_FRAME_QUEUE;
-			break;
-		case 1:
-			*mode = PRI_OVERRIDE_FRAME;
-			break;
-		case 2:
-			*mode = PRI_OVERRIDE_QUEUE;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     return GT_OK;
 }
@@ -2226,45 +2244,45 @@ GT_STATUS gprtGetVTUPriOverride
 * gprtSetSAPriOverride
 *
 * DESCRIPTION:
-*		SA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtSetSAPriOverride
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2276,66 +2294,66 @@ GT_STATUS gprtSetSAPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	switch (mode)
-	{
-		case PRI_OVERRIDE_NONE:
-			data = 0;
-			break;
-		case PRI_OVERRIDE_FRAME_QUEUE:
-			if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-				data = 3;
-			}
-			else
-			{
-				data = 1;
-			}
-			break;
-		case PRI_OVERRIDE_FRAME:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 1;
-			break;
-		case PRI_OVERRIDE_QUEUE:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 2;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     /* Set the SAPriOverride mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,data);
-	}
-	else
-	{
-    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2344,43 +2362,43 @@ GT_STATUS gprtSetSAPriOverride
 * gprtGetSAPriOverride
 *
 * DESCRIPTION:
-*		SA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's SA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
+*        SA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's SA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtGetSAPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2392,52 +2410,52 @@ GT_STATUS gprtGetSAPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the SAPriOverride Mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,&data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 13, 1, &data);
-		if(data == 1) 
-			data = 3;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,12,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 13, 1, &data);
+        if(data == 1) 
+            data = 3;
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
-
-	switch (data)
-	{
-		case 0:
-			*mode = PRI_OVERRIDE_NONE;
-			break;
-		case 3:
-			*mode = PRI_OVERRIDE_FRAME_QUEUE;
-			break;
-		case 1:
-			*mode = PRI_OVERRIDE_FRAME;
-			break;
-		case 2:
-			*mode = PRI_OVERRIDE_QUEUE;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     return GT_OK;
 }
@@ -2446,45 +2464,45 @@ GT_STATUS gprtGetSAPriOverride
 * gprtSetDAPriOverride
 *
 * DESCRIPTION:
-*		DA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_PRI_OVERRIDE type
+*        port - the logical port number.
+*        mode - GT_PRI_OVERRIDE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtSetDAPriOverride
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_PRI_OVERRIDE		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_PRI_OVERRIDE        mode
 )
 {
     GT_U16          data;           
@@ -2496,66 +2514,66 @@ GT_STATUS gprtSetDAPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	switch (mode)
-	{
-		case PRI_OVERRIDE_NONE:
-			data = 0;
-			break;
-		case PRI_OVERRIDE_FRAME_QUEUE:
-			if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-				data = 3;
-			}
-			else
-			{
-				data = 1;
-			}
-			break;
-		case PRI_OVERRIDE_FRAME:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 1;
-			break;
-		case PRI_OVERRIDE_QUEUE:
-			if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-			{
-		        DBG_INFO(("Bad Parameter\n"));
-				return GT_BAD_PARAM;
-			}
-			data = 2;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (mode)
+    {
+        case PRI_OVERRIDE_NONE:
+            data = 0;
+            break;
+        case PRI_OVERRIDE_FRAME_QUEUE:
+            if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                data = 3;
+            }
+            else
+            {
+                data = 1;
+            }
+            break;
+        case PRI_OVERRIDE_FRAME:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 1;
+            break;
+        case PRI_OVERRIDE_QUEUE:
+            if (!IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+            {
+                DBG_INFO(("Bad Parameter\n"));
+                return GT_BAD_PARAM;
+            }
+            data = 2;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     /* Set the DAPriOverride mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,data);
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2564,43 +2582,43 @@ GT_STATUS gprtSetDAPriOverride
 * gprtGetDAPriOverride
 *
 * DESCRIPTION:
-*		DA Priority Override. The following mode is supported:
-*			PRI_OVERRIDE_NONE -
-*				Normal frame priority processing occurs.
-*			PRI_OVERRIDE_FRAME -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's FPri (frame priority).
-*				If the frame egresses tagged, the priority in the frame will be
-*				this new priority value.
-*			PRI_OVERRIDE_QUEUE -
-*				Priority assigned to the frame's DA (in the ATU table) is used
-*				to overwite the frame's QPri (queue priority).
-*				QPri is used internally to map the frame to one of the egress
-*				queues inside the switch.
-*			PRI_OVERRIDE_FRAME_QUEUE -
-*				Both frame and queue overrides take place on the frame.
+*        DA Priority Override. The following mode is supported:
+*            PRI_OVERRIDE_NONE -
+*                Normal frame priority processing occurs.
+*            PRI_OVERRIDE_FRAME -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's FPri (frame priority).
+*                If the frame egresses tagged, the priority in the frame will be
+*                this new priority value.
+*            PRI_OVERRIDE_QUEUE -
+*                Priority assigned to the frame's DA (in the ATU table) is used
+*                to overwite the frame's QPri (queue priority).
+*                QPri is used internally to map the frame to one of the egress
+*                queues inside the switch.
+*            PRI_OVERRIDE_FRAME_QUEUE -
+*                Both frame and queue overrides take place on the frame.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_PRI_OVERRIDE type
+*        mode - GT_PRI_OVERRIDE type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
-*		certain switch device. Please refer to the device datasheet.
+*        PRI_OVERRIDE_FRAME and PRI_OVERRIDE_QUEUE modes are supported only on
+*        certain switch device. Please refer to the device datasheet.
 *
 *******************************************************************************/
 GT_STATUS gprtGetDAPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_PRI_OVERRIDE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_PRI_OVERRIDE        *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2612,52 +2630,52 @@ GT_STATUS gprtGetDAPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DAPriOverride Mode.            */
-	if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,&data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 12, 1, &data);
-		if(data == 1) 
-			data = 3;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_EXT_PRIORITY_OVERRIDE))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PRI_OVERRIDE,14,2,&data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 12, 1, &data);
+        if(data == 1) 
+            data = 3;
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
-
-	switch (data)
-	{
-		case 0:
-			*mode = PRI_OVERRIDE_NONE;
-			break;
-		case 3:
-			*mode = PRI_OVERRIDE_FRAME_QUEUE;
-			break;
-		case 1:
-			*mode = PRI_OVERRIDE_FRAME;
-			break;
-		case 2:
-			*mode = PRI_OVERRIDE_QUEUE;
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+    }
+
+    switch (data)
+    {
+        case 0:
+            *mode = PRI_OVERRIDE_NONE;
+            break;
+        case 3:
+            *mode = PRI_OVERRIDE_FRAME_QUEUE;
+            break;
+        case 1:
+            *mode = PRI_OVERRIDE_FRAME;
+            break;
+        case 2:
+            *mode = PRI_OVERRIDE_QUEUE;
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     return GT_OK;
 }
@@ -2667,22 +2685,22 @@ GT_STATUS gprtGetDAPriOverride
 * gprtSetCPUPort
 *
 * DESCRIPTION:
-*		This routine sets CPU Port number. When Snooping is enabled on this port
-*		or when this port is configured as an Interswitch Port and it receives a 
-*		To_CPU frame, the switch needs to know what port on this device the frame 
-*		should egress.
+*        This routine sets CPU Port number. When Snooping is enabled on this port
+*        or when this port is configured as an Interswitch Port and it receives a 
+*        To_CPU frame, the switch needs to know what port on this device the frame 
+*        should egress.
 *
 * INPUTS:
-*		port - the logical port number.
-*		cpuPort - CPU Port number or interswitch port where CPU Port is connected
+*        port - the logical port number.
+*        cpuPort - CPU Port number or interswitch port where CPU Port is connected
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2691,9 +2709,9 @@ GT_STATUS gprtGetDAPriOverride
 *******************************************************************************/
 GT_STATUS gprtSetCPUPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_LPORT 	cpuPort
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_LPORT     cpuPort
 )
 {
     GT_U16          data;           
@@ -2706,24 +2724,24 @@ GT_STATUS gprtSetCPUPort
     hwPort = GT_LPORT_2_PORT(port);
     data = (GT_U16)GT_LPORT_2_PORT(cpuPort);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Set the CPU Port.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,4,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2732,18 +2750,18 @@ GT_STATUS gprtSetCPUPort
 * gprtGetCPUPort
 *
 * DESCRIPTION:
-*		This routine gets CPU Logical Port
+*        This routine gets CPU Logical Port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		cpuPort - CPU Port's logical number
+*        cpuPort - CPU Port's logical number
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -2752,9 +2770,9 @@ GT_STATUS gprtSetCPUPort
 *******************************************************************************/
 GT_STATUS gprtGetCPUPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_LPORT 	*cpuLPort
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_LPORT     *cpuLPort
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2766,11 +2784,11 @@ GT_STATUS gprtGetCPUPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the CPUPort.            */
@@ -2779,13 +2797,13 @@ GT_STATUS gprtGetCPUPort
     *cpuLPort = GT_PORT_2_LPORT((GT_U8)data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -2795,23 +2813,23 @@ GT_STATUS gprtGetCPUPort
 * gprtSetLockedPort
 *
 * DESCRIPTION:
-*		This routine sets LockedPort. When it's set to one, CPU directed 
-*		learning for 802.1x MAC authentication is enabled on this port. In this
-*		mode, an ATU Miss Violation interrupt will occur when a new SA address
-*		is received in a frame on this port. Automatically SA learning and 
-*		refreshing is disabled in this mode.
+*        This routine sets LockedPort. When it's set to one, CPU directed 
+*        learning for 802.1x MAC authentication is enabled on this port. In this
+*        mode, an ATU Miss Violation interrupt will occur when a new SA address
+*        is received in a frame on this port. Automatically SA learning and 
+*        refreshing is disabled in this mode.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for Locked Port, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for Locked Port, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2820,9 +2838,9 @@ GT_STATUS gprtGetCPUPort
 *******************************************************************************/
 GT_STATUS gprtSetLockedPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2834,11 +2852,13 @@ GT_STATUS gprtSetLockedPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -2848,13 +2868,13 @@ GT_STATUS gprtSetLockedPort
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 13, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2863,18 +2883,18 @@ GT_STATUS gprtSetLockedPort
 * gprtGetLockedPort
 *
 * DESCRIPTION:
-*		This routine gets Locked Port mode for the given port
+*        This routine gets Locked Port mode for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
+*        mode  - GT_TRUE if LockedPort, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -2883,9 +2903,9 @@ GT_STATUS gprtSetLockedPort
 *******************************************************************************/
 GT_STATUS gprtGetLockedPort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -2897,11 +2917,13 @@ GT_STATUS gprtGetLockedPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the LockedPort. */
@@ -2910,13 +2932,13 @@ GT_STATUS gprtGetLockedPort
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -2926,25 +2948,25 @@ GT_STATUS gprtGetLockedPort
 * gprtSetIgnoreWrongData
 *
 * DESCRIPTION:
-*		This routine sets Ignore Wrong Data. If the frame's SA address is found 
-*		in the database and if the entry is 'static' or if the port is 'locked'
-*		the source port's bit is checked to insure the SA has been assigned to 
-*		this port. If the SA is NOT assigned to this port, it is considered an 
-*		ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
-*		Member Violation interrupt will be generated. If it's set to GT_TRUE,
-*		the ATU Member Violation error will be masked and ignored.
+*        This routine sets Ignore Wrong Data. If the frame's SA address is found 
+*        in the database and if the entry is 'static' or if the port is 'locked'
+*        the source port's bit is checked to insure the SA has been assigned to 
+*        this port. If the SA is NOT assigned to this port, it is considered an 
+*        ATU Member Violation. If the IgnoreWrongData is set to GT_FALSE, an ATU
+*        Member Violation interrupt will be generated. If it's set to GT_TRUE,
+*        the ATU Member Violation error will be masked and ignored.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for IgnoreWrongData, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2953,9 +2975,9 @@ GT_STATUS gprtGetLockedPort
 *******************************************************************************/
 GT_STATUS gprtSetIgnoreWrongData
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2967,11 +2989,13 @@ GT_STATUS gprtSetIgnoreWrongData
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -2981,13 +3005,13 @@ GT_STATUS gprtSetIgnoreWrongData
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 12, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2996,18 +3020,18 @@ GT_STATUS gprtSetIgnoreWrongData
 * gprtGetIgnoreWrongData
 *
 * DESCRIPTION:
-*		This routine gets Ignore Wrong Data mode for the given port
+*        This routine gets Ignore Wrong Data mode for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
+*        mode  - GT_TRUE if IgnoreWrongData, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3016,9 +3040,9 @@ GT_STATUS gprtSetIgnoreWrongData
 *******************************************************************************/
 GT_STATUS gprtGetIgnoreWrongData
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3030,11 +3054,13 @@ GT_STATUS gprtGetIgnoreWrongData
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the IgnoreWrongData. */
@@ -3043,13 +3069,13 @@ GT_STATUS gprtGetIgnoreWrongData
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3059,21 +3085,21 @@ GT_STATUS gprtGetIgnoreWrongData
 * gprtSetDiscardTagged
 *
 * DESCRIPTION:
-*		When this bit is set to a one, all non-MGMT frames that are processed as 
-*		Tagged will be discarded as they enter this switch port. Priority only 
-*		tagged frames (with a VID of 0x000) are considered tagged.
+*        When this bit is set to a one, all non-MGMT frames that are processed as 
+*        Tagged will be discarded as they enter this switch port. Priority only 
+*        tagged frames (with a VID of 0x000) are considered tagged.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to discard tagged frame, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -3082,9 +3108,9 @@ GT_STATUS gprtGetIgnoreWrongData
 *******************************************************************************/
 GT_STATUS gprtSetDiscardTagged
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3096,11 +3122,13 @@ GT_STATUS gprtSetDiscardTagged
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3110,13 +3138,13 @@ GT_STATUS gprtSetDiscardTagged
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 9, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3125,18 +3153,18 @@ GT_STATUS gprtSetDiscardTagged
 * gprtGetDiscardTagged
 *
 * DESCRIPTION:
-*		This routine gets DiscardTagged bit for the given port
+*        This routine gets DiscardTagged bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if DiscardTagged bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3145,9 +3173,9 @@ GT_STATUS gprtSetDiscardTagged
 *******************************************************************************/
 GT_STATUS gprtGetDiscardTagged
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3159,11 +3187,13 @@ GT_STATUS gprtGetDiscardTagged
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+ 		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DiscardTagged. */
@@ -3172,13 +3202,13 @@ GT_STATUS gprtGetDiscardTagged
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3188,21 +3218,21 @@ GT_STATUS gprtGetDiscardTagged
 * gprtSetDiscardUntagged
 *
 * DESCRIPTION:
-*		When this bit is set to a one, all non-MGMT frames that are processed as 
-*		Untagged will be discarded as they enter this switch port. Priority only 
-*		tagged frames (with a VID of 0x000) are considered tagged.
+*        When this bit is set to a one, all non-MGMT frames that are processed as 
+*        Untagged will be discarded as they enter this switch port. Priority only 
+*        tagged frames (with a VID of 0x000) are considered tagged.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to discard untagged frame, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -3211,9 +3241,9 @@ GT_STATUS gprtGetDiscardTagged
 *******************************************************************************/
 GT_STATUS gprtSetDiscardUntagged
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3225,11 +3255,13 @@ GT_STATUS gprtSetDiscardUntagged
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3239,13 +3271,13 @@ GT_STATUS gprtSetDiscardUntagged
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 8, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3254,18 +3286,18 @@ GT_STATUS gprtSetDiscardUntagged
 * gprtGetDiscardUntagged
 *
 * DESCRIPTION:
-*		This routine gets DiscardUntagged bit for the given port
+*        This routine gets DiscardUntagged bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if DiscardUntagged bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3274,9 +3306,9 @@ GT_STATUS gprtSetDiscardUntagged
 *******************************************************************************/
 GT_STATUS gprtGetDiscardUntagged
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3288,11 +3320,13 @@ GT_STATUS gprtGetDiscardUntagged
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DiscardUnTagged. */
@@ -3301,13 +3335,13 @@ GT_STATUS gprtGetDiscardUntagged
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3316,23 +3350,23 @@ GT_STATUS gprtGetDiscardUntagged
 * gprtSetMapDA
 *
 * DESCRIPTION:
-*		When this bit is set to a one, normal switch operation will occur where a 
-*		frame's DA address is used to direct the frame out the correct port.
-*		When this be is cleared to a zero, the frame will be sent out the port(s) 
-*		defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
-*		is ound in the address database.
+*        When this bit is set to a one, normal switch operation will occur where a 
+*        frame's DA address is used to direct the frame out the correct port.
+*        When this be is cleared to a zero, the frame will be sent out the port(s) 
+*        defined by ForwardUnknown bits or the DefaultForward bits even if the DA 
+*        is ound in the address database.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to use MapDA, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to use MapDA, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -3341,9 +3375,9 @@ GT_STATUS gprtGetDiscardUntagged
 *******************************************************************************/
 GT_STATUS gprtSetMapDA
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3355,11 +3389,13 @@ GT_STATUS gprtSetMapDA
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3369,13 +3405,13 @@ GT_STATUS gprtSetMapDA
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 7, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3384,18 +3420,18 @@ GT_STATUS gprtSetMapDA
 * gprtGetMapDA
 *
 * DESCRIPTION:
-*		This routine gets MapDA bit for the given port
+*        This routine gets MapDA bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if MapDA bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3404,9 +3440,9 @@ GT_STATUS gprtSetMapDA
 *******************************************************************************/
 GT_STATUS gprtGetMapDA
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3418,11 +3454,13 @@ GT_STATUS gprtGetMapDA
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY|DEV_ENHANCED_FE_SWITCH))
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the MapDA. */
@@ -3431,13 +3469,13 @@ GT_STATUS gprtGetMapDA
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3447,32 +3485,32 @@ GT_STATUS gprtGetMapDA
 * gprtSetDefaultForward
 *
 * DESCRIPTION:
-*		When this bit is set to a one, normal switch operation will occurs and 
-*		multicast frames with unknown DA addresses are allowed to egress out this 
-*		port (assuming the VLAN settings allow the frame to egress this port too).
-*		When this bit is cleared to a zero, multicast frames with unknown DA 
-*		addresses will not egress out this port.
+*        When this bit is set to a one, normal switch operation will occurs and 
+*        multicast frames with unknown DA addresses are allowed to egress out this 
+*        port (assuming the VLAN settings allow the frame to egress this port too).
+*        When this bit is cleared to a zero, multicast frames with unknown DA 
+*        addresses will not egress out this port.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to use DefaultForward, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetDefaultForward
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3484,34 +3522,34 @@ GT_STATUS gprtSetDefaultForward
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
 
     /* Set DefaultForward. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, data);
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, data);
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, data);
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, data);
+    }
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3520,18 +3558,18 @@ GT_STATUS gprtSetDefaultForward
 * gprtGetDefaultForward
 *
 * DESCRIPTION:
-*		This routine gets DefaultForward bit for the given port
+*        This routine gets DefaultForward bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if DefaultForward bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3540,9 +3578,9 @@ GT_STATUS gprtSetDefaultForward
 *******************************************************************************/
 GT_STATUS gprtGetDefaultForward
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3554,33 +3592,33 @@ GT_STATUS gprtGetDefaultForward
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DefaultForward. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, &data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 6, 1, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 3, 1, &data);
+    }
 
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3589,21 +3627,21 @@ GT_STATUS gprtGetDefaultForward
 * gprtSetEgressMonitorSource
 *
 * DESCRIPTION:
-*		When this be is cleared to a zero, normal network switching occurs.
-*		When this bit is set to a one, any frame that egresses out this port will
-*		also be sent to the EgressMonitorDest Port
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -3612,9 +3650,9 @@ GT_STATUS gprtGetDefaultForward
 *******************************************************************************/
 GT_STATUS gprtSetEgressMonitorSource
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3626,11 +3664,11 @@ GT_STATUS gprtSetEgressMonitorSource
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3640,13 +3678,13 @@ GT_STATUS gprtSetEgressMonitorSource
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 5, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3655,18 +3693,18 @@ GT_STATUS gprtSetEgressMonitorSource
 * gprtGetEgressMonitorSource
 *
 * DESCRIPTION:
-*		This routine gets EgressMonitorSource bit for the given port
+*        This routine gets EgressMonitorSource bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if EgressMonitorSource bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3675,9 +3713,9 @@ GT_STATUS gprtSetEgressMonitorSource
 *******************************************************************************/
 GT_STATUS gprtGetEgressMonitorSource
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3689,11 +3727,11 @@ GT_STATUS gprtGetEgressMonitorSource
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the EgressMonitorSource. */
@@ -3702,13 +3740,13 @@ GT_STATUS gprtGetEgressMonitorSource
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3718,21 +3756,21 @@ GT_STATUS gprtGetEgressMonitorSource
 * gprtSetIngressMonitorSource
 *
 * DESCRIPTION:
-*		When this be is cleared to a zero, normal network switching occurs.
-*		When this bit is set to a one, any frame that egresses out this port will
-*		also be sent to the EgressMonitorDest Port
+*        When this be is cleared to a zero, normal network switching occurs.
+*        When this bit is set to a one, any frame that egresses out this port will
+*        also be sent to the EgressMonitorDest Port
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to set EgressMonitorSource, GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -3741,9 +3779,9 @@ GT_STATUS gprtGetEgressMonitorSource
 *******************************************************************************/
 GT_STATUS gprtSetIngressMonitorSource
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3755,11 +3793,11 @@ GT_STATUS gprtSetIngressMonitorSource
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3769,13 +3807,13 @@ GT_STATUS gprtSetIngressMonitorSource
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2, 4, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3784,18 +3822,18 @@ GT_STATUS gprtSetIngressMonitorSource
 * gprtGetIngressMonitorSource
 *
 * DESCRIPTION:
-*		This routine gets IngressMonitorSource bit for the given port
+*        This routine gets IngressMonitorSource bit for the given port
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
+*        mode  - GT_TRUE if IngressMonitorSource bit is set, GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
@@ -3804,9 +3842,9 @@ GT_STATUS gprtSetIngressMonitorSource
 *******************************************************************************/
 GT_STATUS gprtGetIngressMonitorSource
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3818,11 +3856,11 @@ GT_STATUS gprtGetIngressMonitorSource
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the IngressMonitorSource. */
@@ -3831,13 +3869,13 @@ GT_STATUS gprtGetIngressMonitorSource
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3847,35 +3885,35 @@ GT_STATUS gprtGetIngressMonitorSource
 * gprtSetMessagePort
 *
 * DESCRIPTION:
-*		When the Learn2All bit is set to one, learning message frames are 
-*		generated. These frames will be sent out all ports whose Message Port is 
-*		set to one.
-* 		If this feature is used, it is recommended that all Marvell Tag ports, 
-*		except for the CPU's port, have their MessagePort bit set to one. 
-*		Ports that are not Marvell Tag ports should not have their Message Port
-*		bit set to one.
-*		
+*        When the Learn2All bit is set to one, learning message frames are 
+*        generated. These frames will be sent out all ports whose Message Port is 
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports, 
+*        except for the CPU's port, have their MessagePort bit set to one. 
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*        
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*        port - the logical port number.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetMessagePort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -3887,11 +3925,11 @@ GT_STATUS gprtSetMessagePort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -3901,13 +3939,13 @@ GT_STATUS gprtSetMessagePort
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 15, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -3916,34 +3954,34 @@ GT_STATUS gprtSetMessagePort
 * gprtGetMessagePort
 *
 * DESCRIPTION:
-*		When the Learn2All bit is set to one, learning message frames are 
-*		generated. These frames will be sent out all ports whose Message Port is 
-*		set to one.
-* 		If this feature is used, it is recommended that all Marvell Tag ports, 
-*		except for the CPU's port, have their MessagePort bit set to one. 
-*		Ports that are not Marvell Tag ports should not have their Message Port
-*		bit set to one.
-*
-*		
+*        When the Learn2All bit is set to one, learning message frames are 
+*        generated. These frames will be sent out all ports whose Message Port is 
+*        set to one.
+*         If this feature is used, it is recommended that all Marvell Tag ports, 
+*        except for the CPU's port, have their MessagePort bit set to one. 
+*        Ports that are not Marvell Tag ports should not have their Message Port
+*        bit set to one.
+*
+*        
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
+*        mode - GT_TRUE to make this port a Message Port. GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtGetMessagePort
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL 	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL     *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -3955,11 +3993,11 @@ GT_STATUS gprtGetMessagePort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the IngressMonitorSource. */
@@ -3968,13 +4006,13 @@ GT_STATUS gprtGetMessagePort
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -3984,32 +4022,32 @@ GT_STATUS gprtGetMessagePort
 * gprtSetTrunkPort
 *
 * DESCRIPTION:
-*		This function enables/disables and sets the trunk ID.
-*		
+*        This function enables/disables and sets the trunk ID.
+*        
 * INPUTS:
-*		port - the logical port number.
-*		en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
-*			 GT_FALSE, otherwise.
-*		trunkId - valid ID is 0 ~ 15.
+*        port - the logical port number.
+*        en - GT_TRUE to make the port be a member of a trunk with the given trunkId.
+*             GT_FALSE, otherwise.
+*        trunkId - valid ID is 0 ~ 15.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId is neither valid nor INVALID_TRUNK_ID
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetTrunkPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL 		en,
-	IN GT_U32		trunkId
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL         en,
+    IN GT_U32        trunkId
 )
 {
     GT_U16          data;           
@@ -4021,73 +4059,73 @@ GT_STATUS gprtSetTrunkPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(en, data);
 
-	if(en == GT_TRUE)
-	{
-		/* need to enable trunk. so check the trunkId */
-		if (!IS_TRUNK_ID_VALID(dev, trunkId))
-		{
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-		}
-
-	    /* Set TrunkId. */
-		if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
-		{
-	    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, (GT_U16)trunkId);
-		}
-		else
-		{
-	    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
-		}
-
-	    if(retVal != GT_OK)
-		{
-	       	DBG_INFO(("Failed.\n"));
-			return retVal;	
-		}
-
-	}
-	else
-	{
-		/* 
-		   Need to reset trunkId for 88E6095 rev0.
-		*/
-		if (IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) &&
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-		{
-			trunkId = 0;
-		
-	    	/* Set TrunkId. */
-	    	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
-		    if(retVal != GT_OK)
-			{
-		       	DBG_INFO(("Failed.\n"));
-				return retVal;	
-			}
-		}
-	}
+    if(en == GT_TRUE)
+    {
+        /* need to enable trunk. so check the trunkId */
+        if (!IS_TRUNK_ID_VALID(dev, trunkId))
+        {
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+        }
+
+        /* Set TrunkId. */
+        if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
+        {
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, (GT_U16)trunkId);
+        }
+        else
+        {
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+        }
+
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            return retVal;    
+        }
+
+    }
+    else
+    {
+        /* 
+           Need to reset trunkId for 88E6095 rev0.
+        */
+        if (IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) &&
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            trunkId = 0;
+        
+            /* Set TrunkId. */
+            retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, (GT_U16)trunkId);
+            if(retVal != GT_OK)
+            {
+                   DBG_INFO(("Failed.\n"));
+                return retVal;    
+            }
+        }
+    }
 
     /* Set TrunkPort bit. */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -4095,31 +4133,31 @@ GT_STATUS gprtSetTrunkPort
 * gprtGetTrunkPort
 *
 * DESCRIPTION:
-*		This function returns trunk state of the port.
-*		When trunk is disabled, trunkId field won't have valid value.
-*		
+*        This function returns trunk state of the port.
+*        When trunk is disabled, trunkId field won't have valid value.
+*        
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		en - GT_TRUE, if the port is a member of a trunk,
-*			 GT_FALSE, otherwise.
-*		trunkId - 0 ~ 15, valid only if en is GT_TRUE
+*        en - GT_TRUE, if the port is a member of a trunk,
+*             GT_FALSE, otherwise.
+*        trunkId - 0 ~ 15, valid only if en is GT_TRUE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetTrunkPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	OUT GT_BOOL 	*en,
-	OUT GT_U32		*trunkId
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    OUT GT_BOOL     *en,
+    OUT GT_U32        *trunkId
 )
 {
     GT_U16          data;           
@@ -4131,44 +4169,45 @@ GT_STATUS gprtGetTrunkPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	data = 0;
+    data = 0;
 
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 14, 1, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     BIT_2_BOOL(data, *en);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, &data);
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, &data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_TRUNK_NEW_ID_LOCATION))
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 8, 4, &data);
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL1, 4, 4, &data);
+    }
+
+    *trunkId = (GT_U32)data;
 
-	*trunkId = (GT_U32)data;
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -4178,19 +4217,19 @@ GT_STATUS gprtGetTrunkPort
 *
 * DESCRIPTION:
 *       This routine gets the Discard Broadcast Mode. If the mode is enabled,
-*		all the broadcast frames to the given port will be discarded.
+*        all the broadcast frames to the given port will be discarded.
 *
 * INPUTS:
 *       port - logical port number
 *
 * OUTPUTS:
-*		en - GT_TRUE, if enabled,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -4200,9 +4239,9 @@ GT_STATUS gprtGetTrunkPort
 *******************************************************************************/
 GT_STATUS gprtGetDiscardBCastMode
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	OUT GT_BOOL 	 *en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
 )
 {
     GT_U16          data;           
@@ -4214,26 +4253,26 @@ GT_STATUS gprtGetDiscardBCastMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
-	data = 0;
+    data = 0;
 
     retVal = hwGetPortRegField(dev,hwPort, 0x15, 6, 1, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     BIT_2_BOOL(data, *en);
 
@@ -4246,21 +4285,21 @@ GT_STATUS gprtGetDiscardBCastMode
 *
 * DESCRIPTION:
 *       This routine sets the Discard Broadcast mode.
-*		If the mode is enabled, all the broadcast frames to the given port will 
-*		be discarded.
+*        If the mode is enabled, all the broadcast frames to the given port will 
+*        be discarded.
 *
 * INPUTS:
 *       port - logical port number
-*		en - GT_TRUE, to enable the mode,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -4270,9 +4309,9 @@ GT_STATUS gprtGetDiscardBCastMode
 *******************************************************************************/
 GT_STATUS gprtSetDiscardBCastMode
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	IN  GT_BOOL 	 en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
 )
 {
     GT_U16          data;           /* Used to poll the data */
@@ -4284,16 +4323,16 @@ GT_STATUS gprtSetDiscardBCastMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_DROP_BCAST))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(en, data);
@@ -4301,10 +4340,10 @@ GT_STATUS gprtSetDiscardBCastMode
     retVal = hwSetPortRegField(dev,hwPort, 0x15, 6, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     return GT_OK;
 }
@@ -4314,34 +4353,34 @@ GT_STATUS gprtSetDiscardBCastMode
 *
 * DESCRIPTION:
 *       This routine returns mode that tells if ingress rate limiting uses Flow 
-*		Control. When this mode is enabled and the port receives frames over the 
-*		limit, Ingress Rate Limiting will be performed by stalling the 
-*		link partner using flow control, instead of discarding frames.
+*        Control. When this mode is enabled and the port receives frames over the 
+*        limit, Ingress Rate Limiting will be performed by stalling the 
+*        link partner using flow control, instead of discarding frames.
 *
 * INPUTS:
 *       port - logical port number
 *
 * OUTPUTS:
-*		en - GT_TRUE, if the mode is enabled,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, if the mode is enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		In order for this mode to work, Flow Control and Rate Limiting
-*		should be configured properly.
+*        In order for this mode to work, Flow Control and Rate Limiting
+*        should be configured properly.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gprtGetFCOnRateLimitMode
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	OUT GT_BOOL 	 *en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_BOOL      *en
 )
 {
     GT_U16          data;           
@@ -4353,27 +4392,27 @@ GT_STATUS gprtGetFCOnRateLimitMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+    }
 
-	data = 0;
+    data = 0;
 
     retVal = hwGetPortRegField(dev,hwPort, 0x15, 4, 2, &data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
-	if (data == 0x3)
-		*en = GT_TRUE;
-	else
-		*en = GT_FALSE;
+    if (data == 0x3)
+        *en = GT_TRUE;
+    else
+        *en = GT_FALSE;
 
     return GT_OK;
 }
@@ -4384,36 +4423,36 @@ GT_STATUS gprtGetFCOnRateLimitMode
 *
 * DESCRIPTION:
 *       This routine sets the mode that tells if ingress rate limiting uses Flow 
-*		Control. When this mode is enabled and the port receives frames over the 
-*		limit, Ingress Rate Limiting will be performed by stalling the 
-*		link partner using flow control, instead of discarding frames.
+*        Control. When this mode is enabled and the port receives frames over the 
+*        limit, Ingress Rate Limiting will be performed by stalling the 
+*        link partner using flow control, instead of discarding frames.
 *
 * INPUTS:
 *       port - logical port number
-*		en - GT_TRUE, to enable the mode,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, to enable the mode,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       This routine won't configure Flow Control or Rate Limiting.
-*		In order for this mode to work, Flow Control and Rate Limiting
-*		should be configured properly.
+*        In order for this mode to work, Flow Control and Rate Limiting
+*        should be configured properly.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gprtSetFCOnRateLimitMode
 (
-	IN  GT_QD_DEV    *dev,
-	IN  GT_LPORT     port,
-	IN  GT_BOOL 	 en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_BOOL      en
 )
 {
     GT_U16          data;           
@@ -4425,26 +4464,26 @@ GT_STATUS gprtSetFCOnRateLimitMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
-	if (en)
-		data = 0x3;
-	else
-		data = 0;
+    if (en)
+        data = 0x3;
+    else
+        data = 0;
 
     retVal = hwSetPortRegField(dev,hwPort, 0x15, 4, 2, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+        return retVal;
+    }
 
     return GT_OK;
 }
@@ -4454,21 +4493,21 @@ GT_STATUS gprtSetFCOnRateLimitMode
 * gprtSetSAFiltering
 *
 * DESCRIPTION:
-*		This routine set the Source Address(SA) fitering method.
-*			GT_SA_FILTERING_DISABLE :
-*				no frame will be filtered.
-*			GT_SA_DROP_ON_LOCK :
-*				discard if SA field is not in the ATU's address database.
-*			GT_SA_DROP_ON_UNLOCK : 
-*				discard if SA field is in the ATU's address database as Static 
-*				entry with a PortVec of all zeros.
-*			GT_SA_DROP_TO_CPU : 
-*				Ingressing frames will be mapped to the CPU Port if their SA 
-*				field is in the ATU's address database as Static entry with a 
-*				PortVec of all zeros. Otherwise, the frames will be discarded 
-*				if their SA field is not in the ATU's address database or if this
-*				port's bit is not set in the PortVec bits for the frame's SA.
-*		
+*        This routine set the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOCK : 
+*                discard if SA field is in the ATU's address database as Static 
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU : 
+*                Ingressing frames will be mapped to the CPU Port if their SA 
+*                field is in the ATU's address database as Static entry with a 
+*                PortVec of all zeros. Otherwise, the frames will be discarded 
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*        
 * INPUTS:
 *       port - the logical port number.
 *       mode - GT_SA_FILTERING structure
@@ -4493,32 +4532,32 @@ GT_STATUS gprtSetSAFiltering
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gprtSetSAFiltering Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	data = (GT_U16) mode;
+    data = (GT_U16) mode;
 
     /* Set the SA Filtering bits.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,2,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -4528,21 +4567,21 @@ GT_STATUS gprtSetSAFiltering
 * gprtGetSAFiltering
 *
 * DESCRIPTION:
-*		This routine gets the Source Address(SA) fitering method.
-*			GT_SA_FILTERING_DISABLE :
-*				no frame will be filtered.
-*			GT_SA_DROP_ON_LOCK :
-*				discard if SA field is not in the ATU's address database.
-*			GT_SA_DROP_ON_UNLOCK : 
-*				discard if SA field is in the ATU's address database as Static 
-*				entry with a PortVec of all zeros.
-*			GT_SA_DROP_TO_CPU : 
-*				Ingressing frames will be mapped to the CPU Port if their SA 
-*				field is in the ATU's address database as Static entry with a 
-*				PortVec of all zeros. Otherwise, the frames will be discarded 
-*				if their SA field is not in the ATU's address database or if this
-*				port's bit is not set in the PortVec bits for the frame's SA.
-*		
+*        This routine gets the Source Address(SA) fitering method.
+*            GT_SA_FILTERING_DISABLE :
+*                no frame will be filtered.
+*            GT_SA_DROP_ON_LOCK :
+*                discard if SA field is not in the ATU's address database.
+*            GT_SA_DROP_ON_UNLOCK : 
+*                discard if SA field is in the ATU's address database as Static 
+*                entry with a PortVec of all zeros.
+*            GT_SA_DROP_TO_CPU : 
+*                Ingressing frames will be mapped to the CPU Port if their SA 
+*                field is in the ATU's address database as Static entry with a 
+*                PortVec of all zeros. Otherwise, the frames will be discarded 
+*                if their SA field is not in the ATU's address database or if this
+*                port's bit is not set in the PortVec bits for the frame's SA.
+*        
 * INPUTS:
 *       port - the logical port number.
 *
@@ -4566,32 +4605,32 @@ GT_STATUS gprtGetSAFiltering
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gprtSetSAFiltering Called.\n"));
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SA_FILTERING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the SA Filtering bits.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,14,2,&data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*mode = (GT_SA_FILTERING)data;
+    *mode = (GT_SA_FILTERING)data;
 
     return retVal;
 }
@@ -4601,13 +4640,13 @@ GT_STATUS gprtGetSAFiltering
 * gprtSetARPtoCPU
 *
 * DESCRIPTION:
-*		When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored 
-*		to the CPU port.
-*		
+*        When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored 
+*        to the CPU port.
+*        
 * INPUTS:
 *       port - the logical port number.
 *       mode - GT_TRUE, to map ARP frames to CPU Port,
-*			   GT_FALSE, otherwise.
+*               GT_FALSE, otherwise.
 *
 * OUTPUTS:
 *       None.
@@ -4627,7 +4666,7 @@ GT_STATUS gprtSetARPtoCPU
     IN GT_BOOL    mode
 )
 {
-	GT_U16			data;
+    GT_U16            data;
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
 
@@ -4636,29 +4675,29 @@ GT_STATUS gprtSetARPtoCPU
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
 
     /* Set the ARPtoCPU bits.  */
-	if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
-	else
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,data);
+    if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,data);
+    else
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -4668,15 +4707,15 @@ GT_STATUS gprtSetARPtoCPU
 * gprtGetARPtoCPU
 *
 * DESCRIPTION:
-*		When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored 
-*		to the CPU port.
-*		
+*        When ARPtoCPU (or ARP Mirror) is set to GT_TRUE, ARP frames are mirrored 
+*        to the CPU port.
+*        
 * INPUTS:
 *       port - the logical port number.
 *
 * OUTPUTS:
 *       mode - GT_TRUE, to map ARP frames to CPU Port,
-*			   GT_FALSE, otherwise.
+*               GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -4693,7 +4732,7 @@ GT_STATUS gprtGetARPtoCPU
     OUT GT_BOOL    *mode
 )
 {
-	GT_U16			data;
+    GT_U16            data;
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
 
@@ -4702,26 +4741,26 @@ GT_STATUS gprtGetARPtoCPU
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device supports the feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_TO_CPU))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the ARPtoCPU bits.  */
-	if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,&data);
-	else
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,&data);
+    if (IS_IN_DEV_GROUP(dev,DEV_FASTETH_SWITCH))
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,8,1,&data);
+    else
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,6,1,&data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -4734,17 +4773,17 @@ GT_STATUS gprtGetARPtoCPU
 *
 * DESCRIPTION:
 *       This routine set Egress Flooding Mode.
-*		Frames with unknown DA (Destination Address that is not in ATU database)
-*		generally flood out all the ports. This mode can be used to prevent
-*		those frames from egressing this port as follows:
-*			GT_BLOCK_EGRESS_UNKNOWN
-*				do not egress frame with unknown DA (both unicast and multicast)
-*			GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
-*				do not egress frame with unknown multicast DA
-*			GT_BLOCK_EGRESS_UNKNOWN_UNICAST
-*				do not egress frame with unknown unicast DA
-*			GT_BLOCK_EGRESS_NONE
-*				egress all frames with unknown DA
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
 *
 * INPUTS:
 *       port - the logical port number.
@@ -4769,33 +4808,33 @@ GT_STATUS gprtSetEgressFlood
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gprtSetEgressFlood Called.\n"));
 
-	/* check if device supports the feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
-	{
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	data = (GT_U16) mode;
+    data = (GT_U16) mode;
 
     /* Set the Egress Flood mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -4804,17 +4843,17 @@ GT_STATUS gprtSetEgressFlood
 *
 * DESCRIPTION:
 *       This routine gets Egress Flooding Mode.
-*		Frames with unknown DA (Destination Address that is not in ATU database)
-*		generally flood out all the ports. This mode can be used to prevent
-*		those frames from egressing this port as follows:
-*			GT_BLOCK_EGRESS_UNKNOWN
-*				do not egress frame with unknown DA (both unicast and multicast)
-*			GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
-*				do not egress frame with unknown multicast DA
-*			GT_BLOCK_EGRESS_UNKNOWN_UNICAST
-*				do not egress frame with unknown unicast DA
-*			GT_BLOCK_EGRESS_NONE
-*				egress all frames with unknown DA
+*        Frames with unknown DA (Destination Address that is not in ATU database)
+*        generally flood out all the ports. This mode can be used to prevent
+*        those frames from egressing this port as follows:
+*            GT_BLOCK_EGRESS_UNKNOWN
+*                do not egress frame with unknown DA (both unicast and multicast)
+*            GT_BLOCK_EGRESS_UNKNOWN_MULTICAST
+*                do not egress frame with unknown multicast DA
+*            GT_BLOCK_EGRESS_UNKNOWN_UNICAST
+*                do not egress frame with unknown unicast DA
+*            GT_BLOCK_EGRESS_NONE
+*                egress all frames with unknown DA
 *
 * INPUTS:
 *       port - the logical port number.
@@ -4842,12 +4881,12 @@ GT_STATUS gprtGetEgressFlood
 
     DBG_INFO(("gprtGetEgressFlood Called.\n"));
 
-	/* check if device supports the feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
-	{
+    /* check if device supports the feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_EGRESS_FLOOD))
+    {
         DBG_INFO(("GT_NOT_SUPPORTED.\n"));
         return GT_NOT_SUPPORTED;
-	}
+    }
 
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
@@ -4856,15 +4895,15 @@ GT_STATUS gprtGetEgressFlood
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,2,2,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*mode = (GT_EGRESS_FLOOD) data;
+    *mode = (GT_EGRESS_FLOOD) data;
 
     return retVal;
 }
@@ -4874,32 +4913,32 @@ GT_STATUS gprtGetEgressFlood
 * gprtSetPortSched
 *
 * DESCRIPTION:
-*		This routine sets Port Scheduling Mode.
-*		When usePortSched is enablied, this mode is used to select the Queue
-*		controller's scheduling on the port as follows:
-*			GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
-*			GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*        This routine sets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
 *
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_PORT_SCHED_MODE enum type
+*        port - the logical port number
+*        mode - GT_PORT_SCHED_MODE enum type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetPortSched
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_PORT_SCHED_MODE		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PORT_SCHED_MODE        mode
 )
 {
     GT_U16          data;           
@@ -4911,60 +4950,61 @@ GT_STATUS gprtSetPortSched
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE|DEV_PORT_MIXED_SCHEDULE))
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
-    {
-		switch(mode)
-		{
-			case GT_PORT_SCHED_WEIGHTED_RRB:
-				data = 0;
-				break;
-			case GT_PORT_SCHED_STRICT_PRI:
-				data = 3;
-				break;
-			case GT_PORT_SCHED_STRICT_PRI3:
-				data = 1;
-				break;
-			case GT_PORT_SCHED_STRICT_PRI2_3:
-				data = 2;
-				break;
-			default:
-				return GT_BAD_PARAM;
-		}
-
-	    retVal = hwSetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,data);
-		
-	    if(retVal != GT_OK)
-		{
-        	DBG_INFO(("Failed.\n"));
-		}
-    	else
-		{
-    	    DBG_INFO(("OK.\n"));
-		}
-    	return retVal;
-
-    }
-
-
-	data = mode;
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    {
+        switch(mode)
+        {
+            case GT_PORT_SCHED_WEIGHTED_RRB:
+                data = 0;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI:
+                data = 3;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI3:
+                data = 1;
+                break;
+            case GT_PORT_SCHED_STRICT_PRI2_3:
+                data = 2;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+
+        retVal = hwSetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,data);
+        
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+        }
+        else
+        {
+            DBG_INFO(("OK.\n"));
+        }
+        return retVal;
+
+    }
+
+
+    data = mode;
 
     /* Set the gprtSetPortSched mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -4972,31 +5012,31 @@ GT_STATUS gprtSetPortSched
 * gprtGetPortSched
 *
 * DESCRIPTION:
-*		This routine gets Port Scheduling Mode.
-*		When usePortSched is enablied, this mode is used to select the Queue
-*		controller's scheduling on the port as follows:
-*			GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
-*			GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
+*        This routine gets Port Scheduling Mode.
+*        When usePortSched is enablied, this mode is used to select the Queue
+*        controller's scheduling on the port as follows:
+*            GT_PORT_SCHED_WEIGHTED_RRB - use 8,4,2,1 weighted fair scheduling
+*            GT_PORT_SCHED_STRICT_PRI - use a strict priority scheme
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		mode - GT_PORT_SCHED_MODE enum type
+*        mode - GT_PORT_SCHED_MODE enum type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetPortSched
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_PORT_SCHED_MODE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PORT_SCHED_MODE        *mode
 )
 {
     GT_U16          data;           
@@ -5008,40 +5048,41 @@ GT_STATUS gprtGetPortSched
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE|DEV_PORT_MIXED_SCHEDULE))
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
     {
-	    retVal = hwGetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,&data);
-	    if(retVal != GT_OK)
-		{
-        	DBG_INFO(("Failed.\n"));
-	    	return retVal;
-		}
-
-		switch(data)
-		{
-			case 0:
-				*mode = GT_PORT_SCHED_WEIGHTED_RRB;
-				break;
-			case 1:
-				*mode = GT_PORT_SCHED_STRICT_PRI3;
-				break;
-			case 2:
-				*mode = GT_PORT_SCHED_STRICT_PRI2_3;
-				break;
-			case 3:
-				*mode = GT_PORT_SCHED_STRICT_PRI;
-				break;
-			default:
-				return GT_BAD_PARAM;
-		}
-
-    	return GT_OK;
+        retVal = hwGetPortRegField(dev,hwPort, QD_REG_RATE_CTRL, 12,2,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        switch(data)
+        {
+            case 0:
+                *mode = GT_PORT_SCHED_WEIGHTED_RRB;
+                break;
+            case 1:
+                *mode = GT_PORT_SCHED_STRICT_PRI3;
+                break;
+            case 2:
+                *mode = GT_PORT_SCHED_STRICT_PRI2_3;
+                break;
+            case 3:
+                *mode = GT_PORT_SCHED_STRICT_PRI;
+                break;
+            default:
+                return GT_BAD_PARAM;
+        }
+
+        return GT_OK;
 
     }
 
@@ -5049,15 +5090,15 @@ GT_STATUS gprtGetPortSched
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION,14,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*mode = (GT_PORT_SCHED_MODE)data;
+    *mode = (GT_PORT_SCHED_MODE)data;
 
     return retVal;
 }
@@ -5067,30 +5108,30 @@ GT_STATUS gprtGetPortSched
 * gprtSetProviderTag
 *
 * DESCRIPTION:
-*		This routine sets Provider Tag which indicates the provider tag (Ether 
-*		Type) value that needs to be matched to in ingress to determine if a
-*		frame is Provider tagged or not.
+*        This routine sets Provider Tag which indicates the provider tag (Ether 
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
 *
 * INPUTS:
-*		port - the logical port number
-*		tag  - Provider Tag (Ether Type)
+*        port - the logical port number
+*        tag  - Provider Tag (Ether Type)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetProviderTag
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		tag
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        tag
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5101,23 +5142,23 @@ GT_STATUS gprtSetProviderTag
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Set Provider Tag.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PROVIDER_TAG, 0, 16, tag);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5125,29 +5166,29 @@ GT_STATUS gprtSetProviderTag
 * gprtGetProviderTag
 *
 * DESCRIPTION:
-*		This routine gets Provider Tag which indicates the provider tag (Ether 
-*		Type) value that needs to be matched to in ingress to determine if a
-*		frame is Provider tagged or not.
+*        This routine gets Provider Tag which indicates the provider tag (Ether 
+*        Type) value that needs to be matched to in ingress to determine if a
+*        frame is Provider tagged or not.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		tag  - Provider Tag (Ether Type)
+*        tag  - Provider Tag (Ether Type)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetProviderTag
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*tag
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *tag
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5158,23 +5199,23 @@ GT_STATUS gprtGetProviderTag
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PROVIDER_TAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Provider Tag.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PROVIDER_TAG, 0, 16, tag);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5183,40 +5224,40 @@ GT_STATUS gprtGetProviderTag
 * gprtSetPauseLimitOut
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be transmitted
-*		from this port. When full duplex Flow Control is enabled on this port,
-*		these bits are used to limit the number of Pause refresh frames that can 
-*		be generated from this port to keep this port's link partner from sending
-*		any data.
-*		Setting this value to 0 will allow continuous Pause frame refreshes to 
-*		egress this port as long as this port remains congested.
-*		Setting this value to 1 will allow 1 Pause frame to egress from this port
-*		for each congestion situation.
-*		Setting this value to 2 will allow 2 Pause frames to egress from this port
-*		for each congestion situation, etc.
-*		
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can 
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to 
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
+*        
 * INPUTS:
-*		port - the logical port number
-*		limit - the max number of Pause refresh frames for each congestion situation
-*				( 0 ~ 0xFF)
+*        port - the logical port number
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetPauseLimitOut
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		limit
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5227,29 +5268,29 @@ GT_STATUS gprtSetPauseLimitOut
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (limit > 0xFF)
-	{
+    if (limit > 0xFF)
+    {
         DBG_INFO(("Bad Parameter\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     /* Set Pause Limit.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 8, 8, limit);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5257,38 +5298,38 @@ GT_STATUS gprtSetPauseLimitOut
 * gprtGetPauseLimitOut
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be transmitted
-*		from this port. When full duplex Flow Control is enabled on this port,
-*		these bits are used to limit the number of Pause refresh frames that can 
-*		be generated from this port to keep this port's link partner from sending
-*		any data.
-*		Setting this value to 0 will allow continuous Pause frame refreshes to 
-*		egress this port as long as this port remains congested.
-*		Setting this value to 1 will allow 1 Pause frame to egress from this port
-*		for each congestion situation.
-*		Setting this value to 2 will allow 2 Pause frames to egress from this port
-*		for each congestion situation, etc.
+*        Limit the number of continuous Pause refresh frames that can be transmitted
+*        from this port. When full duplex Flow Control is enabled on this port,
+*        these bits are used to limit the number of Pause refresh frames that can 
+*        be generated from this port to keep this port's link partner from sending
+*        any data.
+*        Setting this value to 0 will allow continuous Pause frame refreshes to 
+*        egress this port as long as this port remains congested.
+*        Setting this value to 1 will allow 1 Pause frame to egress from this port
+*        for each congestion situation.
+*        Setting this value to 2 will allow 2 Pause frames to egress from this port
+*        for each congestion situation, etc.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		limit - the max number of Pause refresh frames for each congestion situation
-*				( 0 ~ 0xFF)
+*        limit - the max number of Pause refresh frames for each congestion situation
+*                ( 0 ~ 0xFF)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetPauseLimitOut
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*limit
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5299,23 +5340,23 @@ GT_STATUS gprtGetPauseLimitOut
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Pause Limit.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 8, 8, limit);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5324,51 +5365,51 @@ GT_STATUS gprtGetPauseLimitOut
 * gprtSetPauseLimitIn
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be received
-*		on this port. When a port has flow Control enabled, this value can be 
-*		used to limit how long this port can be Paused off to prevent a port stall
-*		through jamming.
-*		When this value is in the range of 0x01 to 0xFF, and a frame is ready to
-*		be transmitted out this port, but it cannot be transmitted due to the port
-*		being jammed, this limit mechanism starts. The limit mechanism starts 
-*		counting new Pause refresh frames or counts of 16 consecutive collisions.
-*		If the counter reaches the value set through this API, the following event
-*		will occur:
-*			1) Port's ForceFC is enabled,
-*			2) Port's FCValue is cleared to a zero, and
-*			3) Jam Limit Interrupt is asserted.
-*		This effectively disables Flow Control on the port once the Pause timer 
-*		expires. If a frame gets transmitted out this port before the counter
-*		reaches this limit, then this limit mechanism counter resets back to zero.
-*
-*		Setting this value to 0 will allow continuous jamming to be received on 
-*		this port without the Port's ForceFC and FCValue getting modified.
-*
-*		The modification of Port's ForceFC and FCValue is the only indication that 
-*		the limit was reached on this port.
-*		
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be 
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts 
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer 
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on 
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that 
+*        the limit was reached on this port.
+*        
 * INPUTS:
-*		port - the logical port number
-*		limit - the max number of continuous Pause refresh frames for each trasmition
-*				( 0 ~ 0xFF)
+*        port - the logical port number
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if limit > 0xFF
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if limit > 0xFF
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetPauseLimitIn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_U16		limit
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_U16        limit
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5379,29 +5420,29 @@ GT_STATUS gprtSetPauseLimitIn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (limit > 0xFF)
-	{
+    if (limit > 0xFF)
+    {
         DBG_INFO(("Bad Parameter\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     /* Set Pause Limit.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 0, 8, limit);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5409,49 +5450,49 @@ GT_STATUS gprtSetPauseLimitIn
 * gprtGetPauseLimitIn
 *
 * DESCRIPTION:
-*		Limit the number of continuous Pause refresh frames that can be received
-*		on this port. When a port has flow Control enabled, this value can be 
-*		used to limit how long this port can be Paused off to prevent a port stall
-*		through jamming.
-*		When this value is in the range of 0x01 to 0xFF, and a frame is ready to
-*		be transmitted out this port, but it cannot be transmitted due to the port
-*		being jammed, this limit mechanism starts. The limit mechanism starts 
-*		counting new Pause refresh frames or counts of 16 consecutive collisions.
-*		If the counter reaches the value set through this API, the following event
-*		will occur:
-*			1) Port's ForceFC is enabled,
-*			2) Port's FCValue is cleared to a zero, and
-*			3) Jam Limit Interrupt is asserted.
-*		This effectively disables Flow Control on the port once the Pause timer 
-*		expires. If a frame gets transmitted out this port before the counter
-*		reaches this limit, then this limit mechanism counter resets back to zero.
-*
-*		Setting this value to 0 will allow continuous jamming to be received on 
-*		this port without the Port's ForceFC and FCValue getting modified.
-*
-*		The modification of Port's ForceFC and FCValue is the only indication that 
-*		the limit was reached on this port.
+*        Limit the number of continuous Pause refresh frames that can be received
+*        on this port. When a port has flow Control enabled, this value can be 
+*        used to limit how long this port can be Paused off to prevent a port stall
+*        through jamming.
+*        When this value is in the range of 0x01 to 0xFF, and a frame is ready to
+*        be transmitted out this port, but it cannot be transmitted due to the port
+*        being jammed, this limit mechanism starts. The limit mechanism starts 
+*        counting new Pause refresh frames or counts of 16 consecutive collisions.
+*        If the counter reaches the value set through this API, the following event
+*        will occur:
+*            1) Port's ForceFC is enabled,
+*            2) Port's FCValue is cleared to a zero, and
+*            3) Jam Limit Interrupt is asserted.
+*        This effectively disables Flow Control on the port once the Pause timer 
+*        expires. If a frame gets transmitted out this port before the counter
+*        reaches this limit, then this limit mechanism counter resets back to zero.
+*
+*        Setting this value to 0 will allow continuous jamming to be received on 
+*        this port without the Port's ForceFC and FCValue getting modified.
+*
+*        The modification of Port's ForceFC and FCValue is the only indication that 
+*        the limit was reached on this port.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		limit - the max number of continuous Pause refresh frames for each trasmition
-*				( 0 ~ 0xFF)
+*        limit - the max number of continuous Pause refresh frames for each trasmition
+*                ( 0 ~ 0xFF)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetPauseLimitIn
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_U16		*limit
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_U16        *limit
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5462,23 +5503,23 @@ GT_STATUS gprtGetPauseLimitIn
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PAUSE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Pause Limit.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_LIMIT_PAUSE_CONTROL, 0, 8, limit);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5487,44 +5528,44 @@ GT_STATUS gprtGetPauseLimitIn
 * gprtSetFrameMode
 *
 * DESCRIPTION:
-*		Frmae Mode is used to define the expected Ingress and the generated Egress
-*		tagging frame format for this port as follows:
-*			GT_FRAME_MODE_NORMAL -
-*				Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
-*				Untagged frames. Tagged frames use an Ether Type of 0x8100.
-*			GT_FRAME_MODE_DSA -
-*				DSA mode uses a Marvell defined tagged frame format for 
-*				Chip-to-Chip and Chip-to-CPU connections.
-*			GT_FRAME_MODE_PROVIDER -
-*				Provider mode uses user definable Ether Types per port 
-*				(see gprtSetPortEType/gprtGetPortEType API).
-*			GT_FRAME_MODE_ETHER_TYPE_DSA -
-*				Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
-*				flowing a user definable Ether Type. This mode allows the mixture
-*				of Normal Network frames with DSA Tagged frames and is useful to 
-*				be used on ports that connect to a CPU.
-*		
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for 
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port 
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to 
+*                be used on ports that connect to a CPU.
+*        
 * INPUTS:
-*		port - the logical port number
-*		mode - GT_FRAME_MODE type
+*        port - the logical port number
+*        mode - GT_FRAME_MODE type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if mode is unknown
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if mode is unknown
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetFrameMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_FRAME_MODE	mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_FRAME_MODE    mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5535,35 +5576,35 @@ GT_STATUS gprtSetFrameMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     switch (mode)
     {
-		case GT_FRAME_MODE_NORMAL:
-		case GT_FRAME_MODE_DSA:
-		case GT_FRAME_MODE_PROVIDER:
-		case GT_FRAME_MODE_ETHER_TYPE_DSA:
-			break;
-		default:
-	        DBG_INFO(("Bad Parameter\n"));
-			return GT_BAD_PARAM;
-	}
+        case GT_FRAME_MODE_NORMAL:
+        case GT_FRAME_MODE_DSA:
+        case GT_FRAME_MODE_PROVIDER:
+        case GT_FRAME_MODE_ETHER_TYPE_DSA:
+            break;
+        default:
+            DBG_INFO(("Bad Parameter\n"));
+            return GT_BAD_PARAM;
+    }
 
     /* Set Frame Mode.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2, (GT_U16)mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5571,42 +5612,42 @@ GT_STATUS gprtSetFrameMode
 * gprtGetFrameMode
 *
 * DESCRIPTION:
-*		Frmae Mode is used to define the expected Ingress and the generated Egress
-*		tagging frame format for this port as follows:
-*			GT_FRAME_MODE_NORMAL -
-*				Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
-*				Untagged frames. Tagged frames use an Ether Type of 0x8100.
-*			GT_FRAME_MODE_DSA -
-*				DSA mode uses a Marvell defined tagged frame format for 
-*				Chip-to-Chip and Chip-to-CPU connections.
-*			GT_FRAME_MODE_PROVIDER -
-*				Provider mode uses user definable Ether Types per port 
-*				(see gprtSetPortEType/gprtGetPortEType API).
-*			GT_FRAME_MODE_ETHER_TYPE_DSA -
-*				Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
-*				flowing a user definable Ether Type. This mode allows the mixture
-*				of Normal Network frames with DSA Tagged frames and is useful to 
-*				be used on ports that connect to a CPU.
+*        Frmae Mode is used to define the expected Ingress and the generated Egress
+*        tagging frame format for this port as follows:
+*            GT_FRAME_MODE_NORMAL -
+*                Normal Network mode uses industry standard IEEE 802.3ac Tagged or 
+*                Untagged frames. Tagged frames use an Ether Type of 0x8100.
+*            GT_FRAME_MODE_DSA -
+*                DSA mode uses a Marvell defined tagged frame format for 
+*                Chip-to-Chip and Chip-to-CPU connections.
+*            GT_FRAME_MODE_PROVIDER -
+*                Provider mode uses user definable Ether Types per port 
+*                (see gprtSetPortEType/gprtGetPortEType API).
+*            GT_FRAME_MODE_ETHER_TYPE_DSA -
+*                Ether Type DSA mode uses standard Marvell DSA Tagged frame info 
+*                flowing a user definable Ether Type. This mode allows the mixture
+*                of Normal Network frames with DSA Tagged frames and is useful to 
+*                be used on ports that connect to a CPU.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *
 * OUTPUTS:
-*		mode - GT_FRAME_MODE type
+*        mode - GT_FRAME_MODE type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetFrameMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_FRAME_MODE	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_FRAME_MODE    *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5618,23 +5659,23 @@ GT_STATUS gprtGetFrameMode
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_MODE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get Pause Limit.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL, 8, 2, &data);
     *mode = data;
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5643,32 +5684,32 @@ GT_STATUS gprtGetFrameMode
 * gprtSetHoldAt1
 *
 * DESCRIPTION:
-*		Hold Aging ATU Entries at an Entry State value of 1. When this feature
-*		is set to GT_TRUE, ATU entries associated with this port will age down 
-*		to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
-*		entry)
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down 
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetHoldAt1
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -5680,11 +5721,11 @@ GT_STATUS gprtSetHoldAt1
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -5694,13 +5735,13 @@ GT_STATUS gprtSetHoldAt1
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 15, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5709,31 +5750,31 @@ GT_STATUS gprtSetHoldAt1
 * gprtGetHoldAt1
 *
 * DESCRIPTION:
-*		Hold Aging ATU Entries at an Entry State value of 1. When this feature
-*		is set to GT_TRUE, ATU entries associated with this port will age down 
-*		to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
-*		entry)
+*        Hold Aging ATU Entries at an Entry State value of 1. When this feature
+*        is set to GT_TRUE, ATU entries associated with this port will age down 
+*        to an Entry State of 0x1, but will not go to 0x0 (0x0 would purge the
+*        entry)
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to hold aging ATU entry with Entry State of 1, 
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtGetHoldAt1
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5745,11 +5786,11 @@ GT_STATUS gprtGetHoldAt1
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_HOLD))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get HoldAt1 */
@@ -5758,13 +5799,13 @@ GT_STATUS gprtGetHoldAt1
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -5774,32 +5815,32 @@ GT_STATUS gprtGetHoldAt1
 * gprtSetIntOnAgeOut
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to enable AgeOutViloation interrupt
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetIntOnAgeOut
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -5811,11 +5852,11 @@ GT_STATUS gprtSetIntOnAgeOut
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -5825,13 +5866,13 @@ GT_STATUS gprtSetIntOnAgeOut
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 14, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5840,31 +5881,31 @@ GT_STATUS gprtSetIntOnAgeOut
 * gprtGetIntOnAgeOut
 *
 * DESCRIPTION:
-*		Interrupt on Age Out. When aging is enabled, all non-static address 
-*		entries in the ATU's address database are periodically aged.
-*		When this feature is set to GT_TRUE and an entry associated with this 
-*		port is aged out, an AgeOutViolation will be captured for that entry.
+*        Interrupt on Age Out. When aging is enabled, all non-static address 
+*        entries in the ATU's address database are periodically aged.
+*        When this feature is set to GT_TRUE and an entry associated with this 
+*        port is aged out, an AgeOutViolation will be captured for that entry.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable AgeOutViloation interrupt
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable AgeOutViloation interrupt
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtGetIntOnAgeOut
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5876,11 +5917,11 @@ GT_STATUS gprtGetIntOnAgeOut
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_OUT_INT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get IntOnAgeOut */
@@ -5889,13 +5930,13 @@ GT_STATUS gprtGetIntOnAgeOut
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -5905,31 +5946,31 @@ GT_STATUS gprtGetIntOnAgeOut
 * gprtSetRefreshLocked
 *
 * DESCRIPTION:
-*		Auto Refresh known addresses when port is Locked. Already known addresses 
-*		will be auto refreshed when this feature is enabled. When this feature
-*		is disabled, auto refreshing will not occur on Locked ports.
+*        Auto Refresh known addresses when port is Locked. Already known addresses 
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE to enable Auto Refresh known addresses on locked port
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetRefreshLocked
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -5941,11 +5982,11 @@ GT_STATUS gprtSetRefreshLocked
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -5955,13 +5996,13 @@ GT_STATUS gprtSetRefreshLocked
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_ASSOCIATION, 11, 1, data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -5970,30 +6011,30 @@ GT_STATUS gprtSetRefreshLocked
 * gprtGetRefreshLocked
 *
 * DESCRIPTION:
-*		Auto Refresh known addresses when port is Locked. Already known addresses 
-*		will be auto refreshed when this feature is enabled. When this feature
-*		is disabled, auto refreshing will not occur on Locked ports.
+*        Auto Refresh known addresses when port is Locked. Already known addresses 
+*        will be auto refreshed when this feature is enabled. When this feature
+*        is disabled, auto refreshing will not occur on Locked ports.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable Auto Refresh known addresses on locked port
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable Auto Refresh known addresses on locked port
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gprtGetRefreshLocked
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL      *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -6005,11 +6046,11 @@ GT_STATUS gprtGetRefreshLocked
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if device allows to force a flowcontrol disabled */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
+    /* check if device allows to force a flowcontrol disabled */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AUTO_REFRESH_LOCKED))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get RefreshLocked */
@@ -6018,13 +6059,13 @@ GT_STATUS gprtGetRefreshLocked
     BIT_2_BOOL(data, *mode);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -6034,29 +6075,29 @@ GT_STATUS gprtGetRefreshLocked
 * gprtSetPortEType
 *
 * DESCRIPTION:
-*		This routine sets the port's special Ether Type. This Ether Type is used
-*		for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*        This routine sets the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
 *
 * INPUTS:
-*		port  - the logical port number
-*		etype - port's special ether type
+*        port  - the logical port number
+*        etype - port's special ether type
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtSetPortEType
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_ETYPE		etype
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_ETYPE        etype
 )
 {
     GT_U16          data;           
@@ -6068,10 +6109,10 @@ GT_STATUS gprtSetPortEType
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     data = (GT_U16)etype;
@@ -6080,13 +6121,13 @@ GT_STATUS gprtSetPortEType
     retVal = hwWritePortReg(dev,hwPort, QD_REG_PORT_ETH_TYPE,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -6095,28 +6136,28 @@ GT_STATUS gprtSetPortEType
 * gprtGetPortEType
 *
 * DESCRIPTION:
-*		This routine retrieves the port's special Ether Type. This Ether Type is used
-*		for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
+*        This routine retrieves the port's special Ether Type. This Ether Type is used
+*        for Policy (see gprtSetPolicy API) and FrameMode (see gprtSetFrameMode API).
 *
 * INPUTS:
-*		port  - the logical port number
+*        port  - the logical port number
 *
 * OUTPUTS:
-*		etype - port's special ether type
+*        etype - port's special ether type
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS gprtGetPortEType
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_ETYPE	*etype
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_ETYPE    *etype
 )
 {
     GT_U16          data;           
@@ -6128,25 +6169,25 @@ GT_STATUS gprtGetPortEType
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_ETYPE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the EtherType.            */
     retVal = hwReadPortReg(dev,hwPort, QD_REG_PORT_ETH_TYPE,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*etype = (GT_ETYPE) data;
+    *etype = (GT_ETYPE) data;
 
     return retVal;
 }
@@ -6157,10 +6198,10 @@ GT_STATUS gprtGetPortEType
 *
 * DESCRIPTION:
 *       This routine Set the max frame size allowed to be received and transmitted
-*		from or to a given port.
+*        from or to a given port.
 *
 * INPUTS:
-*		port - the logical port number
+*        port - the logical port number
 *       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
 *
 * OUTPUTS:
@@ -6169,48 +6210,48 @@ GT_STATUS gprtGetPortEType
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gsysSetJumboMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_JUMBO_MODE   mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_JUMBO_MODE   mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gsysSetJumboMode Called.\n"));
-
-	if (mode > GT_JUMBO_MODE_10240)
-	{
-		DBG_INFO(("Bad Parameter\n"));
-		return GT_BAD_PARAM;
-	}
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	/* Set the Jumbo Fram Size bit.               */
-	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,(GT_U16)mode);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gsysSetJumboMode Called.\n"));
+
+    if (mode > GT_JUMBO_MODE_10240)
+    {
+        DBG_INFO(("Bad Parameter\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    /* Set the Jumbo Fram Size bit.               */
+    retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,(GT_U16)mode);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -6218,59 +6259,59 @@ GT_STATUS gsysSetJumboMode
 *
 * DESCRIPTION:
 *       This routine gets the max frame size allowed to be received and transmitted
-*		from or to a given port.
+*        from or to a given port.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
 *       mode - GT_JUMBO_MODE (1522, 2048, or 10240)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gsysGetJumboMode
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_JUMBO_MODE   *mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_JUMBO_MODE   *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16          data;           /* to keep the read valve       */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* to keep the read valve       */
 
-	DBG_INFO(("gsysGetJumboMode Called.\n"));
+    DBG_INFO(("gsysGetJumboMode Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
 
-	/* Get Jumbo Frame Mode.            */
-	retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,&data );
+    /* Get Jumbo Frame Mode.            */
+    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL2,12,2,&data );
 
-	*mode = (GT_JUMBO_MODE)data;
+    *mode = (GT_JUMBO_MODE)data;
 
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
 
-	return retVal;
+    return retVal;
 }
  
 
@@ -6278,138 +6319,138 @@ GT_STATUS gsysGetJumboMode
 * gprtGet200Base
 *
 * DESCRIPTION:
-*		200 Base mode. This bit can be used to change the port's Px_GTXCLK
-*		frequency to 50MHz to support 200 BASE mode as follows:
-*		0 = 25MHz Px_GTXCLK
-*		1 = 50MHz Px_GTXCLK
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - 0 for 100Mbps, 1 for 200Mbps
+*        mode - 0 for 100Mbps, 1 for 200Mbps
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		C_Mode should be set to 0x2 in order for this API to work
+*        C_Mode should be set to 0x2 in order for this API to work
 *
 *******************************************************************************/
 GT_STATUS gprtGet200Base
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	OUT GT_U32  	*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    OUT GT_U32      *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
-
-	DBG_INFO(("gprtGet200Base Called.\n"));
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	if (hwPort < (dev->maxPorts - 2))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Get the high error rate bit.  */
-	retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,&data);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	*mode = (GT_U32)data;
-
-	/* return */
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16        data;
+
+    DBG_INFO(("gprtGet200Base Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the high error rate bit.  */
+    retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1, &data);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    *mode = data;
+
+    /* return */
+    return retVal;
 }
 
 /*******************************************************************************
 * gprtSet200Base
 *
 * DESCRIPTION:
-*		200 Base mode. This bit can be used to change the port's Px_GTXCLK
-*		frequency to 50MHz to support 200 BASE mode as follows:
-*		0 = 25MHz Px_GTXCLK
-*		1 = 50MHz Px_GTXCLK
+*        200 Base mode. This bit can be used to change the port's Px_GTXCLK
+*        frequency to 50MHz to support 200 BASE mode as follows:
+*        0 = 25MHz Px_GTXCLK
+*        1 = 50MHz Px_GTXCLK
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - 0 for 100Mbps, 1 for 200Mbps
+*        port - the logical port number.
+*        mode - 0 for 100Mbps, 1 for 200Mbps
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		C_Mode should be set to 0x2 in order for this API to work
+*        C_Mode should be set to 0x2 in order for this API to work
 *
 *******************************************************************************/
 GT_STATUS gprtSet200Base
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U32  	mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U32      mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8           hwPort;         /* the physical port number     */
-
-	DBG_INFO(("gprtSet200Base Called.\n"));
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* translate LPORT to hardware port */
-	hwPort = GT_LPORT_2_PORT(port);
-
-	if (hwPort < (dev->maxPorts - 2))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_BAD_PARAM;
-	}
-
-	/* Get the high error rate bit.  */
-	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,(GT_U16)(mode&0x1));
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-	}
-	else
-	{
-		DBG_INFO(("OK.\n"));
-	}
-
-	/* return */
-	return retVal;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+
+    DBG_INFO(("gprtSet200Base Called.\n"));
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_200BASE_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
+
+    if (hwPort < (dev->maxPorts - 2))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Get the high error rate bit.  */
+    retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_STATUS,6,1,(GT_U16)mode&0x1);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+    }
+    else
+    {
+        DBG_INFO(("OK.\n"));
+    }
+
+    /* return */
+    return retVal;
 }
 
 
@@ -6440,8 +6481,8 @@ GT_STATUS gprtGetSwitchReg
 (
     IN  GT_QD_DEV    *dev,
     IN  GT_LPORT     port,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
@@ -6458,7 +6499,7 @@ GT_STATUS gprtGetSwitchReg
         return GT_FAIL;
     }
 
-	*data = u16Data;
+    *data = u16Data;
 
     return GT_OK;
 }
@@ -6488,10 +6529,10 @@ GT_STATUS gprtGetSwitchReg
 *******************************************************************************/
 GT_STATUS gprtSetSwitchReg
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_LPORT		port,
-    IN  GT_U32			regAddr,
-    IN  GT_U16			data
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
 )
 {
     GT_U8           hwPort;         /* the physical port number     */
@@ -6507,7 +6548,7 @@ GT_STATUS gprtSetSwitchReg
         return GT_FAIL;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -6536,8 +6577,8 @@ GT_STATUS gprtSetSwitchReg
 GT_STATUS gprtGetGlobalReg
 (
     IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
@@ -6551,7 +6592,7 @@ GT_STATUS gprtGetGlobalReg
         return GT_FAIL;
     }
 
-	*data = u16Data;
+    *data = u16Data;
 
     return GT_OK;
 }
@@ -6580,9 +6621,9 @@ GT_STATUS gprtGetGlobalReg
 *******************************************************************************/
 GT_STATUS gprtSetGlobalReg
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_U32			regAddr,
-    IN  GT_U16			data
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
 )
 {
     DBG_INFO(("gprtSetGlobalReg Called.\n"));
@@ -6594,7 +6635,7 @@ GT_STATUS gprtSetGlobalReg
         return GT_FAIL;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -6622,8 +6663,8 @@ GT_STATUS gprtSetGlobalReg
 GT_STATUS gprtGetGlobal2Reg
 (
     IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     regAddr,
-    OUT GT_U16	     *data
+    IN  GT_U32         regAddr,
+    OUT GT_U16         *data
 )
 {
     GT_U16          u16Data;           /* The register's read data.    */
@@ -6637,7 +6678,7 @@ GT_STATUS gprtGetGlobal2Reg
         return GT_FAIL;
     }
 
-	*data = u16Data;
+    *data = u16Data;
 
     return GT_OK;
 }
@@ -6666,9 +6707,9 @@ GT_STATUS gprtGetGlobal2Reg
 *******************************************************************************/
 GT_STATUS gprtSetGlobal2Reg
 (
-    IN  GT_QD_DEV		*dev,
-    IN  GT_U32			regAddr,
-    IN  GT_U16			data
+    IN  GT_QD_DEV        *dev,
+    IN  GT_U32            regAddr,
+    IN  GT_U16            data
 )
 {
     DBG_INFO(("gprtSetGlobal2Reg Called.\n"));
@@ -6680,5 +6721,5 @@ GT_STATUS gprtSetGlobal2Reg
         return GT_FAIL;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortLed.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortLed.c
old mode 100644
new mode 100755
index aa4b542..254f74b
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortLed.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortLed.c
@@ -20,21 +20,21 @@
 
 static GT_STATUS convertLED2APP
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value,
-	OUT GT_U32		*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
 );
 
 
 static GT_STATUS convertAPP2LED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value,
-	OUT GT_U32		*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
 );
 
 
@@ -42,138 +42,157 @@ static GT_STATUS convertAPP2LED
 * gprtSetLED
 *
 * DESCRIPTION:
-*		This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
-*		and special controls.
+*        This API allows to configure 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
 *
 * INPUTS:
-*		port	- the logical port number
-*		cfg 	- GT_LED_CFG value
-*		value 	- value to be configured
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
+*        value     - value to be configured
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gprtSetLED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value
 )
 {
-	GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
-	GT_U32		ptr, conv, mask;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        ptr, conv, mask;
     GT_U8           hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gprtSetLED Called.\n"));
+    DBG_INFO(("gprtSetLED Called.\n"));
 
     hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort >= 5)
-		return GT_BAD_PARAM;
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (cfg)
-	{
-		case GT_LED_CFG_LED0: 
-			ptr = 0;
-			mask = 0xF;
-			break;
-		case GT_LED_CFG_LED1: 
-			ptr = 0;
-			mask = 0xF0;
-			break;
-		case GT_LED_CFG_LED2: 
-			ptr = 1;
-			mask = 0xF;
-			break;
-		case GT_LED_CFG_LED3: 
-			ptr = 1;
-			mask = 0xF0;
-			break;
-		case GT_LED_CFG_PULSE_STRETCH: 
-			ptr = 6;
-			mask = 0x70;
-			break;
-		case GT_LED_CFG_BLINK_RATE: 
-			ptr = 6;
-			mask = 0x7;
-			break;
-		case GT_LED_CFG_SPECIAL_CONTROL: 
-			ptr = 7;
-			mask = (1 << dev->maxPorts) - 1;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	retVal = convertAPP2LED(dev,port,cfg,value,&conv);
-	if (retVal != GT_OK)
-	{
-		return retVal;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Table is ready. */
-	do	
-	{
-		retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-
-	} while(data == 1);
-
-	/* read the current data */
-	data = (GT_U16)(ptr << 12);
-
-	retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
-	if(retVal != GT_OK)
-  	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
-	if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	/* overwrite the data */
-	data = (GT_U16)((1 << 15) | (ptr << 12) | (conv | (data & ~mask)));
-
-	retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
-	if(retVal != GT_OK)
-  	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    if (hwPort >= 5)
+        return GT_BAD_PARAM;
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0: 
+            ptr = 0;
+            mask = 0xF;
+            break;
+        case GT_LED_CFG_LED1: 
+            ptr = 0;
+            mask = 0xF0;
+            break;
+        case GT_LED_CFG_LED2: 
+            ptr = 1;
+            mask = 0xF;
+            break;
+        case GT_LED_CFG_LED3: 
+            ptr = 1;
+            mask = 0xF0;
+            break;
+        case GT_LED_CFG_PULSE_STRETCH: 
+            ptr = 6;
+            mask = 0x70;
+            break;
+        case GT_LED_CFG_BLINK_RATE: 
+            ptr = 6;
+            mask = 0x7;
+            break;
+        case GT_LED_CFG_SPECIAL_CONTROL: 
+            ptr = 7;
+            mask = (1 << dev->maxPorts) - 1;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+    conv = 0;
+    retVal = convertAPP2LED(dev,port,cfg,value,&conv);
+    if (retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_LED_CONTROL;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do    
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+    } while(data == 1);
+#endif
+
+    /* read the current data */
+    data = (GT_U16)(ptr << 12);
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    /* overwrite the data */
+    data = (GT_U16)((1 << 15) | (ptr << 12) | (conv | (data & ~mask)));
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
 
@@ -181,621 +200,640 @@ GT_STATUS gprtSetLED
 * gprtGetLED
 *
 * DESCRIPTION:
-*		This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
-*		and special controls.
+*        This API allows to retrieve 4 LED sections, Pulse stretch, Blink rate,
+*        and special controls.
 *
 * INPUTS:
-*		port	- the logical port number
-*		cfg 	- GT_LED_CFG value
+*        port    - the logical port number
+*        cfg     - GT_LED_CFG value
 *
 * OUTPUTS:
-*		value 	- value to be configured
+*        value     - value to be configured
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None
+*        None
 *
 *******************************************************************************/
 GT_STATUS gprtGetLED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	OUT GT_U32		*value
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    OUT GT_U32        *value
 )
 {
-	GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
-	GT_U32		ptr;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        ptr;
     GT_U8           hwPort;         /* the physical port number     */
 
-	DBG_INFO(("gprtGetLED Called.\n"));
+    DBG_INFO(("gprtGetLED Called.\n"));
 
     hwPort = GT_LPORT_2_PORT(port);
-	if (hwPort >= 5)
-		return GT_BAD_PARAM;
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (cfg)
-	{
-		case GT_LED_CFG_LED0: 
-			ptr = 0;
-			break;
-		case GT_LED_CFG_LED1: 
-			ptr = 0;
-			break;
-		case GT_LED_CFG_LED2: 
-			ptr = 1;
-			break;
-		case GT_LED_CFG_LED3: 
-			ptr = 1;
-			break;
-		case GT_LED_CFG_PULSE_STRETCH: 
-			ptr = 6;
-			break;
-		case GT_LED_CFG_BLINK_RATE: 
-			ptr = 6;
-			break;
-		case GT_LED_CFG_SPECIAL_CONTROL: 
-			ptr = 7;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Table is ready. */
-	do	
-	{
-		retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-
-	} while(data == 1);
-
-	/* read the current data */
-	data = (GT_U16)(ptr << 12);
-
-	retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
-	if(retVal != GT_OK)
-  	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
-	if(retVal != GT_OK)
-	{
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	retVal = convertLED2APP(dev,port,cfg,data,value);
-	if (retVal != GT_OK)
-	{
-		return retVal;
-	}
-
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    if (hwPort >= 5)
+        return GT_BAD_PARAM;
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LED_CFG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0: 
+            ptr = 0;
+            break;
+        case GT_LED_CFG_LED1: 
+            ptr = 0;
+            break;
+        case GT_LED_CFG_LED2: 
+            ptr = 1;
+            break;
+        case GT_LED_CFG_LED3: 
+            ptr = 1;
+            break;
+        case GT_LED_CFG_PULSE_STRETCH: 
+            ptr = 6;
+            break;
+        case GT_LED_CFG_BLINK_RATE: 
+            ptr = 6;
+            break;
+        case GT_LED_CFG_SPECIAL_CONTROL: 
+            ptr = 7;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_LED_CONTROL;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do    
+    {
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_LED_CONTROL,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+    } while(data == 1);
+#endif
+
+    /* read the current data */
+    data = (GT_U16)(ptr << 12);
+
+    retVal = hwWritePortReg(dev, hwPort, QD_REG_LED_CONTROL, data);
+    if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = hwGetPortRegField(dev, hwPort, QD_REG_LED_CONTROL,0,11,&data);
+    if(retVal != GT_OK)
+    {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    retVal = convertLED2APP(dev,port,cfg,data,value);
+    if (retVal != GT_OK)
+    {
+        return retVal;
+    }
+
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
 
 static GT_STATUS convertAPP2LED
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value,
-	OUT GT_U32		*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
 )
 {
-	GT_STATUS	retVal = GT_OK;
-
-	switch (cfg)
-	{
-		case GT_LED_CFG_LED0:
-			switch (value)
-			{
-				case GT_LED_LINK_ACT:
-					*data = 3;
-					break;
-				case GT_LED_LINK:
-					*data = 8;
-					break;
-				case GT_LED_10_LINK_ACT:
-					*data = 10;
-					break;
-				case GT_LED_10_LINK:
-					*data = 9;
-					break;
-				case GT_LED_1000_LINK_ACT:
-					*data = 2;
-					break;
-				case GT_LED_100_1000_LINK_ACT:
-					*data = 1;
-					break;
-				case GT_LED_100_1000_LINK:
-					*data = 11;
-					break;
-				case GT_LED_SPECIAL:
-					*data = 7;
-					break;
-				case GT_LED_DUPLEX_COL:
-					*data = 6;
-					break;
-				case GT_LED_PTP_ACT:
-					*data = 0;
-					break;
-				case GT_LED_FORCE_BLINK:
-					*data = 13;
-					break;
-				case GT_LED_FORCE_OFF:
-					*data = 14;
-					break;
-				case GT_LED_FORCE_ON:
-					*data = 15;
-					break;
-				default:
-					retVal = GT_BAD_PARAM;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_LED1:
-			switch (value)
-			{
-				case GT_LED_LINK_ACT_SPEED:
-					*data = 0;
-					break;
-				case GT_LED_100_LINK_ACT:
-					*data = 10;
-					break;
-				case GT_LED_100_LINK:
-					*data = 9;
-					break;
-				case GT_LED_1000_LINK:
-					*data = 3;
-					break;
-				case GT_LED_10_100_LINK_ACT:
-					*data = 1;
-					break;
-				case GT_LED_10_100_LINK:
-					*data = 11;
-					break;
-				case GT_LED_SPECIAL:
-					*data = 6;
-					break;
-				case GT_LED_DUPLEX_COL:
-					*data = 7;
-					break;
-				case GT_LED_ACTIVITY:
-					*data = 8;
-					break;
-				case GT_LED_PTP_ACT:
-					*data = 12;
-					break;
-				case GT_LED_FORCE_BLINK:
-					*data = 13;
-					break;
-				case GT_LED_FORCE_OFF:
-					*data = 14;
-					break;
-				case GT_LED_FORCE_ON:
-					*data = 15;
-					break;
-				default:
-					retVal = GT_BAD_PARAM;
-					break;
-			}
-			*data <<= 4;
-			break;
-
-		case GT_LED_CFG_LED2:
-			switch (value)
-			{
-				case GT_LED_10_LINK_ACT:
-					*data = 6;
-					break;
-				case GT_LED_100_LINK:
-					*data = 8;
-					break;
-				case GT_LED_1000_LINK_ACT:
-					*data = 10;
-					break;
-				case GT_LED_1000_LINK:
-					*data = 9;
-					break;
-				case GT_LED_10_1000_LINK_ACT:
-					*data = 1;
-					break;
-				case GT_LED_10_1000_LINK:
-					*data = 11;
-					break;
-				case GT_LED_100_1000_LINK_ACT:
-					*data = 7;
-					break;
-				case GT_LED_100_1000_LINK:
-					*data = 3;
-					break;
-				case GT_LED_SPECIAL:
-					*data = 2;
-					break;
-				case GT_LED_DUPLEX_COL:
-					*data = 0;
-					break;
-				case GT_LED_PTP_ACT:
-					*data = 12;
-					break;
-				case GT_LED_FORCE_BLINK:
-					*data = 13;
-					break;
-				case GT_LED_FORCE_OFF:
-					*data = 14;
-					break;
-				case GT_LED_FORCE_ON:
-					*data = 15;
-					break;
-				default:
-					retVal = GT_BAD_PARAM;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_LED3:
-			switch (value)
-			{
-				case GT_LED_LINK_ACT:
-					*data = 10;
-					break;
-				case GT_LED_LINK:
-					*data = 9;
-					break;
-				case GT_LED_10_LINK:
-					*data = 8;
-					break;
-				case GT_LED_100_LINK_ACT:
-					*data = 6;
-					break;
-				case GT_LED_10_1000_LINK_ACT:
-					*data = 7;
-					break;
-				case GT_LED_SPECIAL:
-					*data = 0;
-					break;
-				case GT_LED_DUPLEX_COL:
-					*data = 1;
-					break;
-				case GT_LED_ACTIVITY:
-					*data = 11;
-					break;
-				case GT_LED_PTP_ACT:
-					*data = 12;
-					break;
-				case GT_LED_FORCE_BLINK:
-					*data = 13;
-					break;
-				case GT_LED_FORCE_OFF:
-					*data = 14;
-					break;
-				case GT_LED_FORCE_ON:
-					*data = 15;
-					break;
-				default:
-					retVal = GT_BAD_PARAM;
-					break;
-			}
-			*data <<= 4;
-			break;
-
-		case GT_LED_CFG_PULSE_STRETCH:
-			if (value > 0x4)
-				retVal = GT_BAD_PARAM;
-			*data = value << 4;
-			break;
-		case GT_LED_CFG_BLINK_RATE:
-			if (value > 0x5)
-				retVal = GT_BAD_PARAM;
-			*data = value;
-			break;
-
-		case GT_LED_CFG_SPECIAL_CONTROL:
-			if (value >= (GT_U32)(1 << dev->maxPorts))
-				retVal = GT_BAD_PARAM;
-			*data = value;
-			break;
-			
-		default:
-			retVal = GT_BAD_PARAM;
-			break;
-	}
-
-	return retVal;
+    GT_STATUS    retVal = GT_OK;
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT:
+                    *data = 3;
+                    break;
+                case GT_LED_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_10_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_10_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_1000_LINK_ACT:
+                    *data = 2;
+                    break;
+                case GT_LED_100_1000_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_100_1000_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 7;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 6;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 0;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED1:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT_SPEED:
+                    *data = 0;
+                    break;
+                case GT_LED_100_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_100_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_1000_LINK:
+                    *data = 3;
+                    break;
+                case GT_LED_10_100_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_10_100_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 6;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 7;
+                    break;
+                case GT_LED_ACTIVITY:
+                    *data = 8;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            *data <<= 4;
+            break;
+
+        case GT_LED_CFG_LED2:
+            switch (value)
+            {
+                case GT_LED_10_LINK_ACT:
+                    *data = 6;
+                    break;
+                case GT_LED_100_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_1000_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_1000_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_10_1000_LINK_ACT:
+                    *data = 1;
+                    break;
+                case GT_LED_10_1000_LINK:
+                    *data = 11;
+                    break;
+                case GT_LED_100_1000_LINK_ACT:
+                    *data = 7;
+                    break;
+                case GT_LED_100_1000_LINK:
+                    *data = 3;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 2;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 0;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED3:
+            switch (value)
+            {
+                case GT_LED_LINK_ACT:
+                    *data = 10;
+                    break;
+                case GT_LED_LINK:
+                    *data = 9;
+                    break;
+                case GT_LED_10_LINK:
+                    *data = 8;
+                    break;
+                case GT_LED_100_LINK_ACT:
+                    *data = 6;
+                    break;
+                case GT_LED_10_1000_LINK_ACT:
+                    *data = 7;
+                    break;
+                case GT_LED_SPECIAL:
+                    *data = 0;
+                    break;
+                case GT_LED_DUPLEX_COL:
+                    *data = 1;
+                    break;
+                case GT_LED_ACTIVITY:
+                    *data = 11;
+                    break;
+                case GT_LED_PTP_ACT:
+                    *data = 12;
+                    break;
+                case GT_LED_FORCE_BLINK:
+                    *data = 13;
+                    break;
+                case GT_LED_FORCE_OFF:
+                    *data = 14;
+                    break;
+                case GT_LED_FORCE_ON:
+                    *data = 15;
+                    break;
+                default:
+                    retVal = GT_BAD_PARAM;
+                    break;
+            }
+            *data <<= 4;
+            break;
+
+        case GT_LED_CFG_PULSE_STRETCH:
+            if (value > 0x4)
+                retVal = GT_BAD_PARAM;
+            *data = value << 4;
+            break;
+        case GT_LED_CFG_BLINK_RATE:
+            if (value > 0x5)
+                retVal = GT_BAD_PARAM;
+            *data = value;
+            break;
+
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            if (value >= (GT_U32)(1 << dev->maxPorts))
+                retVal = GT_BAD_PARAM;
+            *data = value;
+            break;
+            
+        default:
+            retVal = GT_BAD_PARAM;
+            break;
+    }
+
+    return retVal;
 
 }
 
 
 static GT_STATUS convertLED2APP
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_LED_CFG	cfg,
-	IN  GT_U32		value,
-	OUT GT_U32		*data
+    IN  GT_QD_DEV     *dev,
+    IN  GT_LPORT    port,
+    IN  GT_LED_CFG    cfg,
+    IN  GT_U32        value,
+    OUT GT_U32        *data
 )
 {
-	GT_STATUS retVal = GT_OK;
-
-	switch (cfg)
-	{
-		case GT_LED_CFG_LED0:
-			value &= 0xF;
-			switch (value)
-			{
-				case 0:
-					*data = GT_LED_PTP_ACT;
-					break;
-				case 1:
-					*data = GT_LED_100_1000_LINK_ACT;
-					break;
-				case 2:
-					*data = GT_LED_1000_LINK_ACT;
-					break;
-				case 3:
-					*data = GT_LED_LINK_ACT;
-					break;
-				case 4:
-					*data = GT_LED_RESERVE;
-					break;
-				case 5:
-					*data = GT_LED_RESERVE;
-					break;
-				case 6:
-					*data = GT_LED_DUPLEX_COL;
-					break;
-				case 7:
-					*data = GT_LED_SPECIAL;
-					break;
-				case 8:
-					*data = GT_LED_LINK;
-					break;
-				case 9:
-					*data = GT_LED_10_LINK;
-					break;
-				case 10:
-					*data = GT_LED_10_LINK_ACT;
-					break;
-				case 11:
-					*data = GT_LED_100_1000_LINK;
-					break;
-				case 12:
-					*data = GT_LED_PTP_ACT;
-					break;
-				case 13:
-					*data = GT_LED_FORCE_BLINK;
-					break;
-				case 14:
-					*data = GT_LED_FORCE_OFF;
-					break;
-				case 15:
-					*data = GT_LED_FORCE_ON;
-					break;
-				default:
-					retVal = GT_FAIL;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_LED1:
-			value >>= 4;
-			value &= 0xF;
-			switch (value)
-			{
-				case 0:
-					*data = GT_LED_LINK_ACT_SPEED;
-					break;
-				case 1:
-					*data = GT_LED_10_100_LINK_ACT;
-					break;
-				case 2:
-					*data = GT_LED_10_100_LINK_ACT;
-					break;
-				case 3:
-					*data = GT_LED_1000_LINK;
-					break;
-				case 4:
-					*data = GT_LED_RESERVE;
-					break;
-				case 5:
-					*data = GT_LED_RESERVE;
-					break;
-				case 6:
-					*data = GT_LED_SPECIAL;
-					break;
-				case 7:
-					*data = GT_LED_DUPLEX_COL;
-					break;
-				case 8:
-					*data = GT_LED_ACTIVITY;
-					break;
-				case 9:
-					*data = GT_LED_100_LINK;
-					break;
-				case 10:
-					*data = GT_LED_100_LINK_ACT;
-					break;
-				case 11:
-					*data = GT_LED_10_100_LINK;
-					break;
-				case 12:
-					*data = GT_LED_PTP_ACT;
-					break;
-				case 13:
-					*data = GT_LED_FORCE_BLINK;
-					break;
-				case 14:
-					*data = GT_LED_FORCE_OFF;
-					break;
-				case 15:
-					*data = GT_LED_FORCE_ON;
-					break;
-				default:
-					retVal = GT_FAIL;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_LED2:
-			value &= 0xF;
-			switch (value)
-			{
-				case 0:
-					*data = GT_LED_DUPLEX_COL;
-					break;
-				case 1:
-					*data = GT_LED_10_1000_LINK_ACT;
-					break;
-				case 2:
-					*data = GT_LED_SPECIAL;
-					break;
-				case 3:
-					*data = GT_LED_100_1000_LINK;
-					break;
-				case 4:
-					*data = GT_LED_RESERVE;
-					break;
-				case 5:
-					*data = GT_LED_RESERVE;
-					break;
-				case 6:
-					*data = GT_LED_10_LINK_ACT;
-					break;
-				case 7:
-					*data = GT_LED_100_1000_LINK_ACT;
-					break;
-				case 8:
-					*data = GT_LED_100_LINK;
-					break;
-				case 9:
-					*data = GT_LED_1000_LINK;
-					break;
-				case 10:
-					*data = GT_LED_1000_LINK_ACT;
-					break;
-				case 11:
-					*data = GT_LED_10_1000_LINK;
-					break;
-				case 12:
-					*data = GT_LED_PTP_ACT;
-					break;
-				case 13:
-					*data = GT_LED_FORCE_BLINK;
-					break;
-				case 14:
-					*data = GT_LED_FORCE_OFF;
-					break;
-				case 15:
-					*data = GT_LED_FORCE_ON;
-					break;
-				default:
-					retVal = GT_FAIL;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_LED3:
-			value >>= 4;
-			value &= 0xF;
-			switch (value)
-			{
-				case 0:
-					*data = GT_LED_SPECIAL;
-					break;
-				case 1:
-					*data = GT_LED_DUPLEX_COL;
-					break;
-				case 2:
-					*data = GT_LED_DUPLEX_COL;
-					break;
-				case 3:
-					*data = GT_LED_SPECIAL;
-					break;
-				case 4:
-					*data = GT_LED_RESERVE;
-					break;
-				case 5:
-					*data = GT_LED_RESERVE;
-					break;
-				case 6:
-					*data = GT_LED_100_LINK_ACT;
-					break;
-				case 7:
-					*data = GT_LED_10_1000_LINK_ACT;
-					break;
-				case 8:
-					*data = GT_LED_10_LINK;
-					break;
-				case 9:
-					*data = GT_LED_LINK;
-					break;
-				case 10:
-					*data = GT_LED_LINK_ACT;
-					break;
-				case 11:
-					*data = GT_LED_ACTIVITY;
-					break;
-				case 12:
-					*data = GT_LED_PTP_ACT;
-					break;
-				case 13:
-					*data = GT_LED_FORCE_BLINK;
-					break;
-				case 14:
-					*data = GT_LED_FORCE_OFF;
-					break;
-				case 15:
-					*data = GT_LED_FORCE_ON;
-					break;
-				default:
-					retVal = GT_FAIL;
-					break;
-			}
-			break;
-
-		case GT_LED_CFG_PULSE_STRETCH:
-			*data = (value >> 4) & 0x7;
-			break;
-
-		case GT_LED_CFG_BLINK_RATE:
-			*data = value & 0x7;
-			break;
-
-		case GT_LED_CFG_SPECIAL_CONTROL:
-			*data = value & ((1 << dev->maxPorts) - 1);
-			break;
-
-		default:
-			retVal = GT_BAD_PARAM;
-			break;
-	}
-
-	return retVal;
+    GT_STATUS retVal = GT_OK;
+
+    switch (cfg)
+    {
+        case GT_LED_CFG_LED0:
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 1:
+                    *data = GT_LED_100_1000_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_1000_LINK_ACT;
+                    break;
+                case 3:
+                    *data = GT_LED_LINK_ACT;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 7:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 8:
+                    *data = GT_LED_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_10_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_10_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_100_1000_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED1:
+            value >>= 4;
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_LINK_ACT_SPEED;
+                    break;
+                case 1:
+                    *data = GT_LED_10_100_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_10_100_LINK_ACT;
+                    break;
+                case 3:
+                    *data = GT_LED_1000_LINK;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 7:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 8:
+                    *data = GT_LED_ACTIVITY;
+                    break;
+                case 9:
+                    *data = GT_LED_100_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_100_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_10_100_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED2:
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 1:
+                    *data = GT_LED_10_1000_LINK_ACT;
+                    break;
+                case 2:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 3:
+                    *data = GT_LED_100_1000_LINK;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_10_LINK_ACT;
+                    break;
+                case 7:
+                    *data = GT_LED_100_1000_LINK_ACT;
+                    break;
+                case 8:
+                    *data = GT_LED_100_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_1000_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_1000_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_10_1000_LINK;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_LED3:
+            value >>= 4;
+            value &= 0xF;
+            switch (value)
+            {
+                case 0:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 1:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 2:
+                    *data = GT_LED_DUPLEX_COL;
+                    break;
+                case 3:
+                    *data = GT_LED_SPECIAL;
+                    break;
+                case 4:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 5:
+                    *data = GT_LED_RESERVE;
+                    break;
+                case 6:
+                    *data = GT_LED_100_LINK_ACT;
+                    break;
+                case 7:
+                    *data = GT_LED_10_1000_LINK_ACT;
+                    break;
+                case 8:
+                    *data = GT_LED_10_LINK;
+                    break;
+                case 9:
+                    *data = GT_LED_LINK;
+                    break;
+                case 10:
+                    *data = GT_LED_LINK_ACT;
+                    break;
+                case 11:
+                    *data = GT_LED_ACTIVITY;
+                    break;
+                case 12:
+                    *data = GT_LED_PTP_ACT;
+                    break;
+                case 13:
+                    *data = GT_LED_FORCE_BLINK;
+                    break;
+                case 14:
+                    *data = GT_LED_FORCE_OFF;
+                    break;
+                case 15:
+                    *data = GT_LED_FORCE_ON;
+                    break;
+                default:
+                    retVal = GT_FAIL;
+                    break;
+            }
+            break;
+
+        case GT_LED_CFG_PULSE_STRETCH:
+            *data = (value >> 4) & 0x7;
+            break;
+
+        case GT_LED_CFG_BLINK_RATE:
+            *data = value & 0x7;
+            break;
+
+        case GT_LED_CFG_SPECIAL_CONTROL:
+            *data = value & ((1 << dev->maxPorts) - 1);
+            break;
+
+        default:
+            retVal = GT_BAD_PARAM;
+            break;
+    }
+
+    return retVal;
 
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortPav.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortPav.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c
old mode 100644
new mode 100755
index a1c67d3..64c41ae
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRateCtrl.c
@@ -24,72 +24,76 @@
 */
 static GT_STATUS cRateLimit(GT_QD_DEV *dev, GT_U32 hwLimit, GT_U32* swLimit)
 {
-	GT_U32 sLimit, hLimit, startLimit, endLimit, i;
-
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-		*swLimit = hwLimit;
-		return GT_OK;
-	}
-
-	if(hwLimit == 0)
-	{
-		*swLimit = GT_NO_LIMIT;
-		return GT_OK;
-	}
-		
-	sLimit = 1000;
-
-	if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-		hLimit = GT_GET_RATE_LIMIT3(sLimit);
-	else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-		hLimit = GT_GET_RATE_LIMIT2(sLimit);
-	else
-		hLimit = GT_GET_RATE_LIMIT(sLimit);
-	if(hLimit == hwLimit)
-	{
-		*swLimit = GT_1M;
-		return GT_OK;
-	}
-	
-	if(hLimit > hwLimit)
-	{
-		startLimit = 2000;
-		endLimit = 256000;
-		*swLimit = GT_2M;
-	}
-	else
-	{
-		startLimit = 128;
-		endLimit = 512;
-		*swLimit = GT_128K;
-	}
-	
-	i = 0;
-	for(sLimit=startLimit;sLimit<=endLimit;sLimit *= 2, i++)
-	{
-		if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-			hLimit = GT_GET_RATE_LIMIT3(sLimit);
-		else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-			hLimit = GT_GET_RATE_LIMIT2(sLimit);
-		else
-			hLimit = GT_GET_RATE_LIMIT(sLimit);
-
-		if(hLimit == 0)
-			hLimit = 1;
-
-		if(hLimit == hwLimit)
-		{
-			*swLimit += i;
-			return GT_OK;
-		}
-
-		if(hLimit < hwLimit)
-			break;
-	}
-
-	*swLimit = hwLimit;
-	return GT_OK;
+    GT_U32 sLimit, hLimit, startLimit, endLimit, i;
+
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
+        *swLimit = hwLimit;
+        return GT_OK;
+    }
+
+    if(hwLimit == 0)
+    {
+        *swLimit = GT_NO_LIMIT;
+        return GT_OK;
+    }
+        
+    sLimit = 1000;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+        hLimit = GT_GET_RATE_LIMIT3(sLimit);
+    else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+        hLimit = GT_GET_RATE_LIMIT2(sLimit);
+    else
+        hLimit = GT_GET_RATE_LIMIT(sLimit);
+    if(hLimit == hwLimit)
+    {
+        *swLimit = GT_1M;
+        return GT_OK;
+    }
+    
+    if(hLimit > hwLimit)
+    {
+        startLimit = 2000;
+        endLimit = 256000;
+        *swLimit = GT_2M;
+    }
+    else
+    {
+        startLimit = 128;
+        endLimit = 512;
+        *swLimit = GT_128K;
+    }
+    
+    i = 0;
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit *= 2, i++)
+    {
+        if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+	    	(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+            hLimit = GT_GET_RATE_LIMIT3(sLimit);
+        else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            hLimit = GT_GET_RATE_LIMIT2(sLimit);
+        else
+            hLimit = GT_GET_RATE_LIMIT(sLimit);
+
+        if(hLimit == 0)
+            hLimit = 1;
+
+        if(hLimit == hwLimit)
+        {
+            *swLimit += i;
+            return GT_OK;
+        }
+
+        if(hLimit < hwLimit)
+            break;
+    }
+
+    *swLimit = hwLimit;
+    return GT_OK;
 }
 
 
@@ -98,75 +102,75 @@ static GT_STATUS cRateLimit(GT_QD_DEV *dev, GT_U32 hwLimit, GT_U32* swLimit)
 */
 static GT_STATUS cBurstEnum2Number(GT_QD_DEV *dev, GT_BURST_RATE rate, GT_U32 *rLimit)
 {
-	GT_U32 rateLimit;
-
-	GT_UNUSED_PARAM(dev);
-
-	switch(rate)
-	{
-		case GT_BURST_NO_LIMIT :
-				rateLimit = 0; /* MAX_RATE_LIMIT; */
-				break;
-		case GT_BURST_64K :
-				rateLimit = 64;
-				break;
-		case GT_BURST_128K :
-				rateLimit = 128;
-				break;
-		case GT_BURST_256K :
-				rateLimit = 256;
-				break;
-		case GT_BURST_384K :
-				rateLimit = 384;
-				break;
-		case GT_BURST_512K :
-				rateLimit = 512;
-				break;
-		case GT_BURST_640K :
-				rateLimit = 640;
-				break;
-		case GT_BURST_768K :
-				rateLimit = 768;
-				break;
-		case GT_BURST_896K :
-				rateLimit = 896;
-				break;
-		case GT_BURST_1M :
-				rateLimit = 1000;
-				break;
-		case GT_BURST_1500K :
-				rateLimit = 1500;
-				break;
-		case GT_BURST_2M :
-				rateLimit = 2000;
-				break;
-		case GT_BURST_4M :
-				rateLimit = 4000;
-				break;
-		case GT_BURST_8M :
-				rateLimit = 8000;
-				break;
-		case GT_BURST_16M :
-				rateLimit = 16000;
-				break;
-		case GT_BURST_32M :
-				rateLimit = 32000;
-				break;
-		case GT_BURST_64M :
-				rateLimit = 64000;
-				break;
-		case GT_BURST_128M :
-				rateLimit = 128000;
-				break;
-		case GT_BURST_256M :
-				rateLimit = 256000;
-				break;
-		default :
-				return GT_BAD_PARAM;
-	}
-
-	*rLimit = rateLimit;
-	return GT_OK;
+    GT_U32 rateLimit;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch(rate)
+    {
+        case GT_BURST_NO_LIMIT :
+                rateLimit = 0; /* MAX_RATE_LIMIT; */
+                break;
+        case GT_BURST_64K :
+                rateLimit = 64;
+                break;
+        case GT_BURST_128K :
+                rateLimit = 128;
+                break;
+        case GT_BURST_256K :
+                rateLimit = 256;
+                break;
+        case GT_BURST_384K :
+                rateLimit = 384;
+                break;
+        case GT_BURST_512K :
+                rateLimit = 512;
+                break;
+        case GT_BURST_640K :
+                rateLimit = 640;
+                break;
+        case GT_BURST_768K :
+                rateLimit = 768;
+                break;
+        case GT_BURST_896K :
+                rateLimit = 896;
+                break;
+        case GT_BURST_1M :
+                rateLimit = 1000;
+                break;
+        case GT_BURST_1500K :
+                rateLimit = 1500;
+                break;
+        case GT_BURST_2M :
+                rateLimit = 2000;
+                break;
+        case GT_BURST_4M :
+                rateLimit = 4000;
+                break;
+        case GT_BURST_8M :
+                rateLimit = 8000;
+                break;
+        case GT_BURST_16M :
+                rateLimit = 16000;
+                break;
+        case GT_BURST_32M :
+                rateLimit = 32000;
+                break;
+        case GT_BURST_64M :
+                rateLimit = 64000;
+                break;
+        case GT_BURST_128M :
+                rateLimit = 128000;
+                break;
+        case GT_BURST_256M :
+                rateLimit = 256000;
+                break;
+        default :
+                return GT_BAD_PARAM;
+    }
+
+    *rLimit = rateLimit;
+    return GT_OK;
 }
 
 
@@ -175,37 +179,37 @@ static GT_STATUS cBurstEnum2Number(GT_QD_DEV *dev, GT_BURST_RATE rate, GT_U32 *r
 */
 static GT_STATUS cBurstRateLimit(GT_QD_DEV *dev, GT_U32 burstSize, GT_U32 hwLimit, GT_BURST_RATE* swLimit)
 {
-	GT_BURST_RATE sLimit, startLimit, endLimit;
-	GT_U32 rLimit, tmpLimit;
+    GT_BURST_RATE sLimit, startLimit, endLimit;
+    GT_U32 rLimit, tmpLimit;
     GT_STATUS       retVal;         /* Functions return value.      */
 
-	if(hwLimit == 0)
-	{
-		*swLimit = GT_BURST_NO_LIMIT;
-		return GT_OK;
-	}
-		
-	startLimit = GT_BURST_64K;
-	endLimit = GT_BURST_256M;
-	
-	for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
-	{
-		if((retVal = cBurstEnum2Number(dev, sLimit, &rLimit)) != GT_OK)
-		{
-        	DBG_INFO(("Failed.\n"));
-	   	    return retVal;
-		}
-
-		tmpLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rLimit);
-
-		if(hwLimit == tmpLimit)
-		{
-			*swLimit = sLimit;
-			return GT_OK;
-		}
-	}
-
-	return GT_FAIL;
+    if(hwLimit == 0)
+    {
+        *swLimit = GT_BURST_NO_LIMIT;
+        return GT_OK;
+    }
+        
+    startLimit = GT_BURST_64K;
+    endLimit = GT_BURST_256M;
+    
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
+    {
+        if((retVal = cBurstEnum2Number(dev, sLimit, &rLimit)) != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+               return retVal;
+        }
+
+        tmpLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rLimit);
+
+        if(hwLimit == tmpLimit)
+        {
+            *swLimit = sLimit;
+            return GT_OK;
+        }
+    }
+
+    return GT_FAIL;
 }
 
 
@@ -214,140 +218,140 @@ static GT_STATUS cBurstRateLimit(GT_QD_DEV *dev, GT_U32 burstSize, GT_U32 hwLimi
 */
 static GT_STATUS cTCPBurstRate(GT_QD_DEV *dev, GT_BURST_RATE rate, GT_U32 *data)
 {
-	GT_UNUSED_PARAM(dev);
-
-	switch(rate)
-	{
-		case GT_BURST_NO_LIMIT :
-				*data = 0; /* MAX_RATE_LIMIT; */
-				break;
-		case GT_BURST_64K :
-				*data = 0x1D00;
-				break;
-		case GT_BURST_128K :
-				*data = 0x3FFF;
-				break;
-		case GT_BURST_256K :
-				*data = 0x7FFF;
-				break;
-		case GT_BURST_384K :
-				*data = 0x7DE0;
-				break;
-		case GT_BURST_512K :
-				*data = 0x76F0;
-				break;
-		case GT_BURST_640K :
-				*data = 0x7660;
-				break;
-		case GT_BURST_768K :
-				*data = 0x7600;
-				break;
-		case GT_BURST_896K :
-				*data = 0x74EF;
-				break;
-		case GT_BURST_1M :
-				*data = 0x7340;
-				break;
-		case GT_BURST_1500K :
-				*data = 0x7300;
-				break;
-		default :
-				return GT_BAD_PARAM;
-	}
-
-	return GT_OK;
+    GT_UNUSED_PARAM(dev);
+
+    switch(rate)
+    {
+        case GT_BURST_NO_LIMIT :
+                *data = 0; /* MAX_RATE_LIMIT; */
+                break;
+        case GT_BURST_64K :
+                *data = 0x1D00;
+                break;
+        case GT_BURST_128K :
+                *data = 0x3FFF;
+                break;
+        case GT_BURST_256K :
+                *data = 0x7FFF;
+                break;
+        case GT_BURST_384K :
+                *data = 0x7DE0;
+                break;
+        case GT_BURST_512K :
+                *data = 0x76F0;
+                break;
+        case GT_BURST_640K :
+                *data = 0x7660;
+                break;
+        case GT_BURST_768K :
+                *data = 0x7600;
+                break;
+        case GT_BURST_896K :
+                *data = 0x74EF;
+                break;
+        case GT_BURST_1M :
+                *data = 0x7340;
+                break;
+        case GT_BURST_1500K :
+                *data = 0x7300;
+                break;
+        default :
+                return GT_BAD_PARAM;
+    }
+
+    return GT_OK;
 }
 
 static GT_STATUS setEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *rateType)
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
-	GT_U32		rate, eDec;
-	GT_PIRL_ELIMIT_MODE		mode;
-    GT_U8		phyPort;        /* Physical port.               */
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        rate, eDec;
+    GT_PIRL_ELIMIT_MODE        mode;
+    GT_U8        phyPort;        /* Physical port.               */
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
-	{
-		return retVal;
-	}
-
-	if (mode == GT_PIRL_ELIMIT_FRAME)	
-	{
-		/* Count Per Frame */
-		rate = rateType->fRate;
-
-		if (rate == 0) /* disable egress rate limit */
-		{
-			eDec = 0;
-			data = 0;
-		}
-		else if((rate < 7600)  || (rate > 1488000))
-		{
-			return GT_BAD_PARAM;
-		}
-		else
-		{
-			eDec = 1;
-			data = (GT_U16)GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
-		}
-	}
-	else
-	{
-		/* Count Per Byte */
-		rate = rateType->kbRate;
-
-		if(rate == 0)
-		{
-			eDec = 0;
-		}
-		else if(rate < 1000)	/* less than 1Mbps */
-		{
-			/* it should be divided by 64 */
-			if(rate % 64)
-				return GT_BAD_PARAM;
-			eDec = rate/64;
-		}
-		else if(rate <= 100000)	/* less than or equal to 100Mbps */
-		{
-			/* it should be divided by 1000 */
-			if(rate % 1000)
-				return GT_BAD_PARAM;
-			eDec = rate/1000;
-		}
-		else if(rate <= 1000000)	/* less than or equal to 1000Mbps */
-		{
-			/* it should be divided by 10000 */
-			if(rate % 10000)
-				return GT_BAD_PARAM;
-			eDec = rate/10000;
-		}
-		else
-			return GT_BAD_PARAM;
-
-		if(rate == 0)
-		{
-			data = 0;
-		}
-		else
-		{
-			data = (GT_U16)GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
-		}
-	}
+    if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
+    {
+        return retVal;
+    }
+
+    if (mode == GT_PIRL_ELIMIT_FRAME)    
+    {
+        /* Count Per Frame */
+        rate = rateType->fRate;
+
+        if (rate == 0) /* disable egress rate limit */
+        {
+            eDec = 0;
+            data = 0;
+        }
+        else if((rate < 7600)  || (rate > 1488000))
+        {
+            return GT_BAD_PARAM;
+        }
+        else
+        {
+            eDec = 1;
+            data = (GT_U16)GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
+        }
+    }
+    else
+    {
+        /* Count Per Byte */
+        rate = rateType->kbRate;
+
+        if(rate == 0)
+        {
+            eDec = 0;
+        }
+        else if(rate < 1000)    /* less than 1Mbps */
+        {
+            /* it should be divided by 64 */
+            if(rate % 64)
+                return GT_BAD_PARAM;
+            eDec = rate/64;
+        }
+        else if(rate <= 100000)    /* less than or equal to 100Mbps */
+        {
+            /* it should be divided by 1000 */
+            if(rate % 1000)
+                return GT_BAD_PARAM;
+            eDec = rate/1000;
+        }
+        else if(rate <= 1000000)    /* less than or equal to 1000Mbps */
+        {
+            /* it should be divided by 10000 */
+            if(rate % 10000)
+                return GT_BAD_PARAM;
+            eDec = rate/10000;
+        }
+        else
+            return GT_BAD_PARAM;
+
+        if(rate == 0)
+        {
+            data = 0;
+        }
+        else
+        {
+            data = (GT_U16)GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
+        }
+    }
 
     retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,0,7,(GT_U16)eDec);
-	if(retVal != GT_OK)
-	{
-    	DBG_INFO(("Failed.\n"));
-    	return retVal;
-	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
     retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)data );
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -357,41 +361,41 @@ static GT_STATUS setEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *
 
 static GT_STATUS getEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *rateType)
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		rate, eDec;
-	GT_PIRL_ELIMIT_MODE		mode;
-    GT_U8		phyPort;        /* Physical port.               */
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        rate, eDec;
+    GT_PIRL_ELIMIT_MODE        mode;
+    GT_U8        phyPort;        /* Physical port.               */
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = grcGetELimitMode(dev,port,&mode)) != GT_OK)
+    {
+        return retVal;
+    }
 
     retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,0,7,&eDec);
-	if(retVal != GT_OK)
-	{
-    	DBG_INFO(("Failed.\n"));
-    	return retVal;
-	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
     retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,&rate );
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
-	if (mode == GT_PIRL_ELIMIT_FRAME)	
-	{
-		rateType->fRate = GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
-	}
-	else
-	{
-		/* Count Per Byte */
-		rateType->kbRate = GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
-	}
+    if (mode == GT_PIRL_ELIMIT_FRAME)    
+    {
+        rateType->fRate = GT_GET_RATE_LIMIT_PER_FRAME(rate,eDec);
+    }
+    else
+    {
+        /* Count Per Byte */
+        rateType->kbRate = GT_GET_RATE_LIMIT_PER_BYTE(rate,eDec);
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -405,8 +409,8 @@ static GT_STATUS getEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *
 *       This routine sets the port's rate control ingress limit mode.
 *
 * INPUTS:
-*       port	- logical port number.
-*       mode 	- rate control ingress limit mode. 
+*       port    - logical port number.
+*       mode     - rate control ingress limit mode. 
 *
 * OUTPUTS:
 *       None.
@@ -424,7 +428,7 @@ static GT_STATUS getEnhancedERate(GT_QD_DEV *dev, GT_LPORT port, GT_ERATE_TYPE *
 GT_STATUS grcSetLimitMode
 (
     IN GT_QD_DEV             *dev,
-    IN GT_LPORT 	     port,
+    IN GT_LPORT          port,
     IN GT_RATE_LIMIT_MODE    mode
 )
 {
@@ -440,14 +444,14 @@ GT_STATUS grcSetLimitMode
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,(GT_U16)mode );
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,(GT_U16)mode );
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,(GT_U16)mode );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,(GT_U16)mode );
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -466,10 +470,10 @@ GT_STATUS grcSetLimitMode
 *       This routine gets the port's rate control ingress limit mode.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *
 * OUTPUTS:
-*       mode 	- rate control ingress limit mode. 
+*       mode     - rate control ingress limit mode. 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -497,21 +501,21 @@ GT_STATUS grcGetLimitMode
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
+    
     if(mode == NULL)
     {
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,&data );
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,&data );
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,14,2,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,14,2,&data );
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -569,17 +573,17 @@ GT_STATUS grcSetPri3Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
+    
     BOOL_2_BIT(mode,data);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,data );
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -642,15 +646,15 @@ GT_STATUS grcGetPri3Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,&data );
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,&data);
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,14,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,13,1,&data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -709,17 +713,17 @@ GT_STATUS grcSetPri2Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
+    
     BOOL_2_BIT(mode,data);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,data );
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -782,15 +786,15 @@ GT_STATUS grcGetPri2Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,&data );
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,&data);
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,13,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,12,1,&data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -848,17 +852,17 @@ GT_STATUS grcSetPri1Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
+    
     BOOL_2_BIT(mode,data);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,data );
-	}
-	else
-	{
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,data );
+    }
+    else
+    {
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -920,15 +924,15 @@ GT_STATUS grcGetPri1Rate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS)) != GT_OK ) 
       return retVal;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,&data );
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,&data);
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,12,1,&data );
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,11,1,&data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -948,10 +952,10 @@ GT_STATUS grcGetPri1Rate
 *       This routine sets the port's ingress data limit for priority 0 frames.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *       rate    - ingress data rate limit for priority 0 frames. These frames
-*       	  will be discarded after the ingress rate selected is reached 
-*       	  or exceeded. 
+*             will be discarded after the ingress rate selected is reached 
+*             or exceeded. 
 *
 * OUTPUTS:
 *       None.
@@ -962,8 +966,8 @@ GT_STATUS grcGetPri1Rate
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS: 
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
 *
 * GalTis:
 *
@@ -978,7 +982,7 @@ GT_STATUS grcSetPri0Rate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit, tmpLimit;
+    GT_U32            rateLimit, tmpLimit;
 
     DBG_INFO(("grcSetPri0Rate Called.\n"));
 
@@ -988,96 +992,96 @@ GT_STATUS grcSetPri0Rate
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
       return retVal;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
-	{
-		dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
-		switch(rate)
-		{
-			case GT_NO_LIMIT :
-					rateLimit = 0; /* MAX_RATE_LIMIT; */
-					break;
-			case GT_128K :
-					rateLimit = 128;
-					break;
-			case GT_256K :
-					rateLimit = 256;
-					break;
-			case GT_512K :
-					rateLimit = 512;
-					break;
-			case GT_1M :
-					rateLimit = 1000;
-					break;
-			case GT_2M :
-					rateLimit = 2000;
-					break;
-			case GT_4M :
-					rateLimit = 4000;
-					break;
-			case GT_8M :
-					rateLimit = 8000;
-					break;
-			case GT_16M :
-					rateLimit = 16000;
-					break;
-			case GT_32M :
-					rateLimit = 32000;
-					break;
-			case GT_64M :
-					rateLimit = 64000;
-					break;
-			case GT_128M :
-					rateLimit = 128000;
-					break;
-			case GT_256M :
-					rateLimit = 256000;
-					break;
-			default :
-					rateLimit = (GT_U32)rate;
-					dev->devStorage |= GT_RATE_ENUM_NOT_USED;
-					break;					
-		}
-
-		if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
-		else
-			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
-
-		if((tmpLimit == 0) && (rateLimit != 0))
-			rateLimit = 1;
-		else
-			rateLimit = tmpLimit;
-
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}
-	else
-	{
-		switch(rate)
-		{
-			case GT_NO_LIMIT :
-			case GT_128K :
-			case GT_256K :
-			case GT_512K :
-			case GT_1M :
-			case GT_2M :
-			case GT_4M :
-			case GT_8M :
-					break;
-			default :
-					return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,(GT_U16)rate );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH))
+    {
+        dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+                    rateLimit = 0; /* MAX_RATE_LIMIT; */
+                    break;
+            case GT_128K :
+                    rateLimit = 128;
+                    break;
+            case GT_256K :
+                    rateLimit = 256;
+                    break;
+            case GT_512K :
+                    rateLimit = 512;
+                    break;
+            case GT_1M :
+                    rateLimit = 1000;
+                    break;
+            case GT_2M :
+                    rateLimit = 2000;
+                    break;
+            case GT_4M :
+                    rateLimit = 4000;
+                    break;
+            case GT_8M :
+                    rateLimit = 8000;
+                    break;
+            case GT_16M :
+                    rateLimit = 16000;
+                    break;
+            case GT_32M :
+                    rateLimit = 32000;
+                    break;
+            case GT_64M :
+                    rateLimit = 64000;
+                    break;
+            case GT_128M :
+                    rateLimit = 128000;
+                    break;
+            case GT_256M :
+                    rateLimit = 256000;
+                    break;
+            default :
+                    rateLimit = (GT_U32)rate;
+                    dev->devStorage |= GT_RATE_ENUM_NOT_USED;
+                    break;                    
+        }
+
+        if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+        else
+            tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+        if((tmpLimit == 0) && (rateLimit != 0))
+            rateLimit = 1;
+        else
+            rateLimit = tmpLimit;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    else
+    {
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+            case GT_128K :
+            case GT_256K :
+            case GT_512K :
+            case GT_1M :
+            case GT_2M :
+            case GT_4M :
+            case GT_8M :
+                    break;
+            default :
+                    return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,(GT_U16)rate );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -1091,12 +1095,12 @@ GT_STATUS grcSetPri0Rate
 *       This routine gets the port's ingress data limit for priority 0 frames.
 *
 * INPUTS:
-*       port	- logical port number to set.
+*       port    - logical port number to set.
 *
 * OUTPUTS:
 *       rate    - ingress data rate limit for priority 0 frames. These frames
-*       	  will be discarded after the ingress rate selected is reached 
-*       	  or exceeded. 
+*             will be discarded after the ingress rate selected is reached 
+*             or exceeded. 
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1104,8 +1108,8 @@ GT_STATUS grcSetPri0Rate
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS: 
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_PRI0_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
 *
 * GalTis:
 *
@@ -1120,7 +1124,7 @@ GT_STATUS grcGetPri0Rate
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			tmpLimit;
+    GT_U32            tmpLimit;
 
     DBG_INFO(("grcGetPri0Rate Called.\n"));
 
@@ -1136,39 +1140,39 @@ GT_STATUS grcGetPri0Rate
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
       return retVal;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,&data);
-		tmpLimit = (GT_U32)data;
-
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-
-		if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
-		{
-			if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-				*rate = GT_GET_RATE_LIMIT2(tmpLimit);
-			else
-				*rate = GT_GET_RATE_LIMIT(tmpLimit);
-		}
-		else
-		{
-			cRateLimit(dev, tmpLimit, (GT_U32*)rate);
-		}
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,&data );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	    *rate = data;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,12,&data);
+        tmpLimit = (GT_U32)data;
+
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
+        {
+            if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+                *rate = GT_GET_RATE_LIMIT2(tmpLimit);
+            else
+                *rate = GT_GET_RATE_LIMIT(tmpLimit);
+        }
+        else
+        {
+            cRateLimit(dev, tmpLimit, (GT_U32*)rate);
+        }
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,8,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+        *rate = data;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -1181,13 +1185,13 @@ GT_STATUS grcGetPri0Rate
 *       This routine sets the byets to count for limiting needs to be determined
 *
 * INPUTS:
-*       port	  - logical port number to set.
-*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
-*    		    GT_FALSE: otherwise
-*    	countIFG  - GT_TRUE: To count IFG bytes
-*    		    GT_FALSE: otherwise
-*    	countPre  - GT_TRUE: To count Preamble bytes
-*    		    GT_FALSE: otherwise
+*       port      - logical port number to set.
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
 *
 * OUTPUTS:
 *       None.
@@ -1206,9 +1210,9 @@ GT_STATUS grcSetBytesCount
 (
     IN GT_QD_DEV *dev,
     IN GT_LPORT  port,
-    IN GT_BOOL 	 limitMGMT,
-    IN GT_BOOL 	 countIFG,
-    IN GT_BOOL 	 countPre
+    IN GT_BOOL      limitMGMT,
+    IN GT_BOOL      countIFG,
+    IN GT_BOOL      countPre
 )
 {
 
@@ -1224,30 +1228,30 @@ GT_STATUS grcSetBytesCount
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_INGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
       return retVal;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-	    BOOL_2_BIT(limitMGMT,data);
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,data );
-		if (retVal != GT_OK)
-			return retVal;
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        BOOL_2_BIT(limitMGMT,data);
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,data );
+        if (retVal != GT_OK)
+            return retVal;
 
-		data = 0;
-		if( countIFG == GT_TRUE ) data |= 2;
-		if( countPre == GT_TRUE ) data |= 1;
+        data = 0;
+        if( countIFG == GT_TRUE ) data |= 2;
+        if( countPre == GT_TRUE ) data |= 1;
 
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,data );
-	}
-	else
-	{
-		data = 0;
-	    if(	limitMGMT == GT_TRUE ) data |=4;
-    	if(	 countIFG == GT_TRUE ) data |=2;
-	    if(	 countPre == GT_TRUE ) data |=1;
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,data );
+    }
+    else
+    {
+        data = 0;
+        if(    limitMGMT == GT_TRUE ) data |=4;
+        if(     countIFG == GT_TRUE ) data |=2;
+        if(     countPre == GT_TRUE ) data |=1;
 
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,data );
-	}
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,data );
+    }
 
-   	if(retVal != GT_OK)
+       if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
@@ -1265,15 +1269,15 @@ GT_STATUS grcSetBytesCount
 *       This routine gets the byets to count for limiting needs to be determined
 *
 * INPUTS:
-*       port	- logical port number 
+*       port    - logical port number 
 *
 * OUTPUTS:
-*    	limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
-*    		    GT_FALSE: otherwise
-*    	countIFG  - GT_TRUE: To count IFG bytes
-*    		    GT_FALSE: otherwise
-*    	countPre  - GT_TRUE: To count Preamble bytes
-*    		    GT_FALSE: otherwise
+*        limitMGMT - GT_TRUE: To limit and count MGMT frame bytes
+*                GT_FALSE: otherwise
+*        countIFG  - GT_TRUE: To count IFG bytes
+*                GT_FALSE: otherwise
+*        countPre  - GT_TRUE: To count Preamble bytes
+*                GT_FALSE: otherwise
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1284,12 +1288,12 @@ GT_STATUS grcSetBytesCount
 *
 *******************************************************************************/
 GT_STATUS grcGetBytesCount
-(	
+(    
     IN GT_QD_DEV *dev,
     IN GT_LPORT  port,
-    IN GT_BOOL 	 *limitMGMT,
-    IN GT_BOOL 	 *countIFG,
-    IN GT_BOOL 	 *countPre
+    IN GT_BOOL      *limitMGMT,
+    IN GT_BOOL      *countIFG,
+    IN GT_BOOL      *countPre
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -1309,45 +1313,45 @@ GT_STATUS grcGetBytesCount
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
-   	*limitMGMT = *countIFG = *countPre = GT_FALSE;
-
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,&data );
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("Failed.\n"));
-			return retVal;
-		}
-
-	    BIT_2_BOOL(data,*limitMGMT);
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,&data );
-		if (retVal != GT_OK)
-		{
-    	    DBG_INFO(("Failed.\n"));
-			return retVal;
-		}
-
-		if( data & 0x2 ) *countIFG = GT_TRUE;
-		if( data & 0x1 ) *countPre = GT_TRUE;
-
-	}
-	else
-	{
-
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,&data );
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-        	return retVal;
-	    }
-
-	    if ( data & 4 ) *limitMGMT = GT_TRUE;
-    	if ( data & 2 ) *countIFG  = GT_TRUE;
-	    if ( data & 1 ) *countPre  = GT_TRUE;
-	
-	}
-	    
+       *limitMGMT = *countIFG = *countPre = GT_FALSE;
+
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,15,1,&data );
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        BIT_2_BOOL(data,*limitMGMT);
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,12,2,&data );
+        if (retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if( data & 0x2 ) *countIFG = GT_TRUE;
+        if( data & 0x1 ) *countPre = GT_TRUE;
+
+    }
+    else
+    {
+
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,4,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if ( data & 4 ) *limitMGMT = GT_TRUE;
+        if ( data & 2 ) *countIFG  = GT_TRUE;
+        if ( data & 1 ) *countPre  = GT_TRUE;
+    
+    }
+        
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -1357,37 +1361,37 @@ GT_STATUS grcGetBytesCount
 *
 * DESCRIPTION:
 *       This routine sets the port's egress data limit.
-*		
+*        
 *
 * INPUTS:
 *       port      - logical port number.
 *       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
-*					union type is used to support multiple devices with the
-*					different formats of egress rate.
-*					GT_ERATE_TYPE has the following fields:
-*						definedRate - GT_EGRESS_RATE enum type should used for the 
-*							following devices:
-*							88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
-*							88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
-*							and their variations
-*						kbRate - rate in kbps that should used for the following 
-*							devices:
-*							88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_LAYER1,
-*								GT_PIRL_ELIMIT_LAYER2, or 
-*								GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
-*							64kbps ~ 1Mbps    : increments of 64kbps,
-*							1Mbps ~ 100Mbps   : increments of 1Mbps, and
-*							100Mbps ~ 1000Mbps: increments of 10Mbps
-*							Therefore, the valid values are:
-*								64, 128, 192, 256, 320, 384,..., 960,
-*								1000, 2000, 3000, 4000, ..., 100000,
-*								110000, 120000, 130000, ..., 1000000.
-*						fRate - frame per second that should used for the following
-*							devices:
-*							88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_FRAME
-*							Valid values are between 7600 and 1488000
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the 
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following 
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or 
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
 *
 * OUTPUTS:
 *       None.
@@ -1398,8 +1402,8 @@ GT_STATUS grcGetBytesCount
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS: 
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
 *
 *******************************************************************************/
 GT_STATUS grcSetEgressRate
@@ -1412,7 +1416,7 @@ GT_STATUS grcSetEgressRate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit, tmpLimit;
+    GT_U32            rateLimit, tmpLimit;
     GT_EGRESS_RATE  rate;
 
     DBG_INFO(("grcSetEgressRate Called.\n"));
@@ -1422,106 +1426,109 @@ GT_STATUS grcSetEgressRate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
       return retVal;
-	
-	if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
-	{
-		return setEnhancedERate(dev,port,rateType);
-	}
-
-	rate = rateType->definedRate;
-
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-		dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
-		switch(rate)
-		{
-			case GT_NO_LIMIT :
-					rateLimit = 0; /* MAX_RATE_LIMIT; */
-					break;
-			case GT_128K :
-					rateLimit = 128;
-					break;
-			case GT_256K :
-					rateLimit = 256;
-					break;
-			case GT_512K :
-					rateLimit = 512;
-					break;
-			case GT_1M :
-					rateLimit = 1000;
-					break;
-			case GT_2M :
-					rateLimit = 2000;
-					break;
-			case GT_4M :
-					rateLimit = 4000;
-					break;
-			case GT_8M :
-					rateLimit = 8000;
-					break;
-			case GT_16M :
-					rateLimit = 16000;
-					break;
-			case GT_32M :
-					rateLimit = 32000;
-					break;
-			case GT_64M :
-					rateLimit = 64000;
-					break;
-			case GT_128M :
-					rateLimit = 128000;
-					break;
-			case GT_256M :
-					rateLimit = 256000;
-					break;
-			default :
-					rateLimit = (GT_U32)rate;
-					dev->devStorage |= GT_RATE_ENUM_NOT_USED;
-					break;					
-		}
-
-		if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-			tmpLimit = GT_GET_RATE_LIMIT3(rateLimit);
-		else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-			tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
-		else
-			tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
-
-		if((tmpLimit == 0) && (rateLimit != 0))
-			rateLimit = 1;
-		else
-			rateLimit = tmpLimit;
-
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}
-	else
-	{
-		switch(rate)
-		{
-			case GT_NO_LIMIT :
-			case GT_128K :
-			case GT_256K :
-			case GT_512K :
-			case GT_1M :
-			case GT_2M :
-			case GT_4M :
-			case GT_8M :
-					break;
-			default :
-					return GT_BAD_PARAM;
-		}
-	    retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,(GT_U16)rate );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-	}
+    
+    if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        return setEnhancedERate(dev,port,rateType);
+    }
+
+    rate = rateType->definedRate;
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        dev->devStorage &= ~(GT_RATE_ENUM_NOT_USED);
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+                    rateLimit = 0; /* MAX_RATE_LIMIT; */
+                    break;
+            case GT_128K :
+                    rateLimit = 128;
+                    break;
+            case GT_256K :
+                    rateLimit = 256;
+                    break;
+            case GT_512K :
+                    rateLimit = 512;
+                    break;
+            case GT_1M :
+                    rateLimit = 1000;
+                    break;
+            case GT_2M :
+                    rateLimit = 2000;
+                    break;
+            case GT_4M :
+                    rateLimit = 4000;
+                    break;
+            case GT_8M :
+                    rateLimit = 8000;
+                    break;
+            case GT_16M :
+                    rateLimit = 16000;
+                    break;
+            case GT_32M :
+                    rateLimit = 32000;
+                    break;
+            case GT_64M :
+                    rateLimit = 64000;
+                    break;
+            case GT_128M :
+                    rateLimit = 128000;
+                    break;
+            case GT_256M :
+                    rateLimit = 256000;
+                    break;
+            default :
+                    rateLimit = (GT_U32)rate;
+                    dev->devStorage |= GT_RATE_ENUM_NOT_USED;
+                    break;                    
+        }
+
+        if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+	    	(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+            tmpLimit = GT_GET_RATE_LIMIT3(rateLimit);
+        else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+            tmpLimit = GT_GET_RATE_LIMIT2(rateLimit);
+        else
+            tmpLimit = GT_GET_RATE_LIMIT(rateLimit);
+
+        if((tmpLimit == 0) && (rateLimit != 0))
+            rateLimit = 1;
+        else
+            rateLimit = tmpLimit;
+
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,(GT_U16)rateLimit );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
+    else
+    {
+        switch(rate)
+        {
+            case GT_NO_LIMIT :
+            case GT_128K :
+            case GT_256K :
+            case GT_512K :
+            case GT_1M :
+            case GT_2M :
+            case GT_4M :
+            case GT_8M :
+                    break;
+            default :
+                    return GT_BAD_PARAM;
+        }
+        retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,(GT_U16)rate );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -1536,36 +1543,36 @@ GT_STATUS grcSetEgressRate
 *       This routine gets the port's egress data limit.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *
 * OUTPUTS:
 *       rateType  - egress data rate limit (GT_ERATE_TYPE union type). 
-*					union type is used to support multiple devices with the
-*					different formats of egress rate.
-*					GT_ERATE_TYPE has the following fields:
-*						definedRate - GT_EGRESS_RATE enum type should used for the 
-*							following devices:
-*							88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
-*							88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
-*							and their variations
-*						kbRate - rate in kbps that should used for the following 
-*							devices:
-*							88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_LAYER1,
-*								GT_PIRL_ELIMIT_LAYER2, or 
-*								GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
-*							64kbps ~ 1Mbps    : increments of 64kbps,
-*							1Mbps ~ 100Mbps   : increments of 1Mbps, and
-*							100Mbps ~ 1000Mbps: increments of 10Mbps
-*							Therefore, the valid values are:
-*								64, 128, 192, 256, 320, 384,..., 960,
-*								1000, 2000, 3000, 4000, ..., 100000,
-*								110000, 120000, 130000, ..., 1000000.
-*						fRate - frame per second that should used for the following
-*							devices:
-*							88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
-*								GT_PIRL_ELIMIT_FRAME
-*							Valid values are between 7600 and 1488000
+*                    union type is used to support multiple devices with the
+*                    different formats of egress rate.
+*                    GT_ERATE_TYPE has the following fields:
+*                        definedRate - GT_EGRESS_RATE enum type should used for the 
+*                            following devices:
+*                            88E6218, 88E6318, 88E6063, 88E6083, 88E6181, 88E6183,
+*                            88E6093, 88E6095, 88E6185, 88E6108, 88E6065, 88E6061, 
+*                            and their variations
+*                        kbRate - rate in kbps that should used for the following 
+*                            devices:
+*                            88E6097, 88E6096 with the GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_LAYER1,
+*                                GT_PIRL_ELIMIT_LAYER2, or 
+*                                GT_PIRL_ELIMIT_LAYER3 (see grcSetELimitMode)
+*                            64kbps ~ 1Mbps    : increments of 64kbps,
+*                            1Mbps ~ 100Mbps   : increments of 1Mbps, and
+*                            100Mbps ~ 1000Mbps: increments of 10Mbps
+*                            Therefore, the valid values are:
+*                                64, 128, 192, 256, 320, 384,..., 960,
+*                                1000, 2000, 3000, 4000, ..., 100000,
+*                                110000, 120000, 130000, ..., 1000000.
+*                        fRate - frame per second that should used for the following
+*                            devices:
+*                            88E6097, 88E6096 with GT_PIRL_ELIMIT_MODE of 
+*                                GT_PIRL_ELIMIT_FRAME
+*                            Valid values are between 7600 and 1488000
 *
 * RETURNS:
 *       GT_OK               - on success
@@ -1573,8 +1580,8 @@ GT_STATUS grcSetEgressRate
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS:
-*			GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
-*			are supported only by Gigabit Ethernet Switch.
+*            GT_16M, GT_32M, GT_64M, GT_128M, and GT_256M in GT_EGRESS_RATE enum
+*            are supported only by Gigabit Ethernet Switch.
 *
 *******************************************************************************/
 GT_STATUS grcGetEgressRate
@@ -1587,7 +1594,7 @@ GT_STATUS grcGetEgressRate
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			tmpLimit,tmpRate;
+    GT_U32            tmpLimit,tmpRate;
 
     DBG_INFO(("grcGetEgressRate Called.\n"));
 
@@ -1596,55 +1603,58 @@ GT_STATUS grcGetEgressRate
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,phyPort, DEV_EGRESS_RATE_KBPS|DEV_UNMANAGED_SWITCH)) != GT_OK ) 
       return retVal;
-	
+    
     if(rateType == NULL)
     {
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
-	{
-		return getEnhancedERate(dev,port,rateType);
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,&data );
-		tmpLimit = (GT_U32)data;
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-
-		if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
-		{
-			if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-				tmpRate = GT_GET_RATE_LIMIT3(tmpLimit);
-			else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
-				tmpRate = GT_GET_RATE_LIMIT2(tmpLimit);
-			else
-				tmpRate = GT_GET_RATE_LIMIT(tmpLimit);
-			rateType->kbRate = tmpRate;
-		}
-		else
-		{
-			cRateLimit(dev, tmpLimit, &tmpRate);
-			rateType->definedRate = (GT_EGRESS_RATE)tmpRate;
-		}
-	}
-	else
-	{
-	    retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,&data );
-	    if(retVal != GT_OK)
-    	{
-	        DBG_INFO(("Failed.\n"));
-    	    return retVal;
-	    }
-		
-		rateType->definedRate = (GT_EGRESS_RATE)data;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        return getEnhancedERate(dev,port,rateType);
+    }
+
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_EGRESS_RATE_CTRL,0,12,&data );
+        tmpLimit = (GT_U32)data;
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+
+        if(dev->devStorage & GT_RATE_ENUM_NOT_USED)
+        {
+            if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+	        	(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+                tmpRate = GT_GET_RATE_LIMIT3(tmpLimit);
+            else if (!IS_IN_DEV_GROUP(dev,DEV_88E6183_FAMILY))
+                tmpRate = GT_GET_RATE_LIMIT2(tmpLimit);
+            else
+                tmpRate = GT_GET_RATE_LIMIT(tmpLimit);
+            rateType->kbRate = tmpRate;
+        }
+        else
+        {
+            cRateLimit(dev, tmpLimit, &tmpRate);
+            rateType->definedRate = (GT_EGRESS_RATE)tmpRate;
+        }
+    }
+    else
+    {
+        retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL,0,3,&data );
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+        
+        rateType->definedRate = (GT_EGRESS_RATE)data;
+    }
 
 
     DBG_INFO(("OK.\n"));
@@ -1659,10 +1669,10 @@ GT_STATUS grcGetEgressRate
 *       This routine sets the port's ingress data limit based on burst size.
 *
 * INPUTS:
-*       port	- logical port number.
-*       bsize	- burst size.
+*       port    - logical port number.
+*       bsize    - burst size.
 *       rate    - ingress data rate limit. These frames will be discarded after 
-*				the ingress rate selected is reached or exceeded. 
+*                the ingress rate selected is reached or exceeded. 
 *
 * OUTPUTS:
 *       None.
@@ -1671,15 +1681,15 @@ GT_STATUS grcGetEgressRate
 *       GT_OK               - on success
 *       GT_FAIL             - on error
 *       GT_BAD_PARAM        - on bad parameters 
-*								Minimum rate for Burst Size 24K byte is 128Kbps
-*								Minimum rate for Burst Size 48K byte is 256Kbps
-*								Minimum rate for Burst Size 96K byte is 512Kbps
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*                                Minimum rate for Burst Size 24K byte is 128Kbps
+*                                Minimum rate for Burst Size 48K byte is 256Kbps
+*                                Minimum rate for Burst Size 96K byte is 512Kbps
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
@@ -1695,63 +1705,63 @@ GT_STATUS grcSetBurstRate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit;
-	GT_U32			burstSize =0;
+    GT_U32            rateLimit;
+    GT_U32            burstSize =0;
 
     DBG_INFO(("grcSetBurstRate Called.\n"));
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
-
-	switch (bsize)
-	{
-		case GT_BURST_SIZE_12K:
-			burstSize = 0;
-			break;
-		case GT_BURST_SIZE_24K:
-			if ((rate < GT_BURST_128K) && (rate != GT_BURST_NO_LIMIT))
-				return GT_BAD_PARAM;
-			burstSize = 1;
-			break;
-		case GT_BURST_SIZE_48K:
-			if ((rate < GT_BURST_256K) && (rate != GT_BURST_NO_LIMIT))
-				return GT_BAD_PARAM;
-			burstSize = 3;
-			break;
-		case GT_BURST_SIZE_96K:
-			if ((rate < GT_BURST_512K) && (rate != GT_BURST_NO_LIMIT))
-				return GT_BAD_PARAM;
-			burstSize = 7;
-			break;
-		default:
-			return GT_BAD_PARAM;
-	}
-
-	if((retVal = cBurstEnum2Number(dev, rate, &rateLimit)) != GT_OK)
-	{
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    switch (bsize)
+    {
+        case GT_BURST_SIZE_12K:
+            burstSize = 0;
+            break;
+        case GT_BURST_SIZE_24K:
+            if ((rate < GT_BURST_128K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 1;
+            break;
+        case GT_BURST_SIZE_48K:
+            if ((rate < GT_BURST_256K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 3;
+            break;
+        case GT_BURST_SIZE_96K:
+            if ((rate < GT_BURST_512K) && (rate != GT_BURST_NO_LIMIT))
+                return GT_BAD_PARAM;
+            burstSize = 7;
+            break;
+        default:
+            return GT_BAD_PARAM;
+    }
+
+    if((retVal = cBurstEnum2Number(dev, rate, &rateLimit)) != GT_OK)
+    {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
-	}
+           return retVal;
+    }
 
-	rateLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rateLimit);
+    rateLimit = GT_GET_BURST_RATE_LIMIT(burstSize,rateLimit);
 
-	rateLimit |= (GT_U32)(burstSize << 12);
+    rateLimit |= (GT_U32)(burstSize << 12);
 
     retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,(GT_U16)rateLimit );
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -1765,17 +1775,17 @@ GT_STATUS grcSetBurstRate
 *       This routine retrieves the port's ingress data limit based on burst size.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *
 * OUTPUTS:
-*       bsize	- burst size.
+*       bsize    - burst size.
 *       rate    - ingress data rate limit. These frames will be discarded after 
-*				the ingress rate selected is reached or exceeded. 
+*                the ingress rate selected is reached or exceeded. 
 *
 * RETURNS:
 *       GT_OK            - on success
 *       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1793,59 +1803,59 @@ GT_STATUS grcGetBurstRate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit, burstSize;
-	GT_U16			data;
+    GT_U32            rateLimit, burstSize;
+    GT_U16            data;
 
     DBG_INFO(("grcGetBurstRate Called.\n"));
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-    	{
-        	DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-    	}
-	}
-		
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+        
     retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,&data);
-	rateLimit = (GT_U32)data;
+    rateLimit = (GT_U32)data;
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
-	burstSize = rateLimit >> 12;
-	rateLimit &= 0x0FFF;
+    burstSize = rateLimit >> 12;
+    rateLimit &= 0x0FFF;
 
-	retVal = cBurstRateLimit(dev, burstSize, rateLimit, rate);
+    retVal = cBurstRateLimit(dev, burstSize, rateLimit, rate);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
-    }
-
-	switch (burstSize)
-	{
-		case 0:
-			*bsize = GT_BURST_SIZE_12K;
-			break;
-		case 1:
-			*bsize = GT_BURST_SIZE_24K;
-			break;
-		case 3:
-			*bsize = GT_BURST_SIZE_48K;
-			break;
-		case 7:
-			*bsize = GT_BURST_SIZE_96K;
-			break;
-		default:
-			return GT_BAD_VALUE;
-	}
+           return retVal;
+    }
+
+    switch (burstSize)
+    {
+        case 0:
+            *bsize = GT_BURST_SIZE_12K;
+            break;
+        case 1:
+            *bsize = GT_BURST_SIZE_24K;
+            break;
+        case 3:
+            *bsize = GT_BURST_SIZE_48K;
+            break;
+        case 7:
+            *bsize = GT_BURST_SIZE_96K;
+            break;
+        default:
+            return GT_BAD_VALUE;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -1859,9 +1869,9 @@ GT_STATUS grcGetBurstRate
 *       This routine sets the port's TCP/IP ingress data limit based on burst size.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *       rate    - ingress data rate limit for TCP/IP packets. These frames will 
-*				be discarded after the ingress rate selected is reached or exceeded. 
+*                be discarded after the ingress rate selected is reached or exceeded. 
 *
 * OUTPUTS:
 *       None.
@@ -1870,14 +1880,14 @@ GT_STATUS grcGetBurstRate
 *       GT_OK               - on success
 *       GT_FAIL             - on error
 *       GT_BAD_PARAM        - on bad parameters 
-*								Valid rate is GT_BURST_NO_LIMIT, or between
-*								64Kbps and 1500Kbps.
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*                                Valid rate is GT_BURST_NO_LIMIT, or between
+*                                64Kbps and 1500Kbps.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
@@ -1892,34 +1902,34 @@ GT_STATUS grcSetTCPBurstRate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit;
+    GT_U32            rateLimit;
 
     DBG_INFO(("grcSetTCPBurstRate Called.\n"));
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
-
-	if((retVal = cTCPBurstRate(dev, rate, &rateLimit)) != GT_OK)
-	{
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
+
+    if((retVal = cTCPBurstRate(dev, rate, &rateLimit)) != GT_OK)
+    {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
-	}
+           return retVal;
+    }
 
     retVal = hwSetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,(GT_U16)rateLimit );
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -1934,22 +1944,22 @@ GT_STATUS grcSetTCPBurstRate
 *       This routine sets the port's TCP/IP ingress data limit based on burst size.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *
 * OUTPUTS:
 *       rate    - ingress data rate limit for TCP/IP packets. These frames will 
-*				be discarded after the ingress rate selected is reached or exceeded. 
+*                be discarded after the ingress rate selected is reached or exceeded. 
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
 *       GT_BAD_VALUE        - register value is not known
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
-*		If the device supports both priority based Rate Limiting and burst size
-*		based Rate limiting, user has to manually change the mode to burst size
-*		based Rate limiting by calling gsysSetRateLimitMode.
+*        If the device supports both priority based Rate Limiting and burst size
+*        based Rate limiting, user has to manually change the mode to burst size
+*        based Rate limiting by calling gsysSetRateLimitMode.
 *
 * GalTis:
 *
@@ -1964,56 +1974,56 @@ GT_STATUS grcGetTCPBurstRate
 
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
-	GT_U32			rateLimit;
-	GT_U32			data;
-	GT_U16			u16Data;
-	GT_BURST_RATE sLimit, startLimit, endLimit;
+    GT_U32            rateLimit;
+    GT_U32            data;
+    GT_U16            u16Data;
+    GT_BURST_RATE sLimit, startLimit, endLimit;
 
     DBG_INFO(("grcGetTCPBurstRate Called.\n"));
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_1))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_1))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     retVal = hwGetPortRegField(dev,phyPort,QD_REG_INGRESS_RATE_CTRL,0,15,&u16Data);
-	data = (GT_U32)u16Data;
+    data = (GT_U32)u16Data;
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
-	if ((data & 0xFFF) == 0)
-	{
-		*rate = GT_BURST_NO_LIMIT;
-		return GT_OK;
-	}
-
-	startLimit = GT_BURST_64K;
-	endLimit = GT_BURST_1500K;
+    if ((data & 0xFFF) == 0)
+    {
+        *rate = GT_BURST_NO_LIMIT;
+        return GT_OK;
+    }
 
-	for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
-	{
-		if((retVal = cTCPBurstRate(dev, sLimit, &rateLimit)) != GT_OK)
-		{
-        	break;
-		}
+    startLimit = GT_BURST_64K;
+    endLimit = GT_BURST_1500K;
 
-		if(rateLimit == data)
-		{
-			*rate = sLimit;
-			return GT_OK;
-		}
-	}
+    for(sLimit=startLimit;sLimit<=endLimit;sLimit++)
+    {
+        if((retVal = cTCPBurstRate(dev, sLimit, &rateLimit)) != GT_OK)
+        {
+            break;
+        }
+
+        if(rateLimit == data)
+        {
+            *rate = sLimit;
+            return GT_OK;
+        }
+    }
 
     DBG_INFO(("Fail to find TCP Rate.\n"));
     return GT_BAD_VALUE;
@@ -2025,14 +2035,14 @@ GT_STATUS grcGetTCPBurstRate
 *
 * DESCRIPTION:
 *       This routine enables/disables VID None Rate Limit (NRL).
-*		When VID NRL is enabled and the determined VID of a frame results in a VID
-*		whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
-*		will not be ingress nor egress rate limited.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
 *
 * INPUTS:
 *       port - logical port number.
-*		mode - GT_TRUE to enable VID None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
 *       None.
@@ -2040,16 +2050,16 @@ GT_STATUS grcGetTCPBurstRate
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcSetVidNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2060,12 +2070,12 @@ GT_STATUS grcSetVidNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -2073,9 +2083,9 @@ GT_STATUS grcSetVidNrlEn
     /* Set the VidNrlEn mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,15,1,data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -2088,30 +2098,30 @@ GT_STATUS grcSetVidNrlEn
 *
 * DESCRIPTION:
 *       This routine gets VID None Rate Limit (NRL) mode.
-*		When VID NRL is enabled and the determined VID of a frame results in a VID
-*		whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
-*		will not be ingress nor egress rate limited.
+*        When VID NRL is enabled and the determined VID of a frame results in a VID
+*        whose VIDNonRateLimit in the VTU Table is set to GT_TURE, then the frame
+*        will not be ingress nor egress rate limited.
 *
 * INPUTS:
 *       port - logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable VID None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable VID None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcGetVidNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -2122,19 +2132,19 @@ GT_STATUS grcGetVidNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the VidNrlEn mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,15,1,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     BIT_2_BOOL(data, *mode);
@@ -2150,14 +2160,14 @@ GT_STATUS grcGetVidNrlEn
 *
 * DESCRIPTION:
 *       This routine enables/disables SA None Rate Limit (NRL).
-*		When SA NRL is enabled and the source address of a frame results in a ATU
-*		hit where the SA's MAC address returns an EntryState that indicates Non
-*		Rate Limited, then the frame will not be ingress nor egress rate limited.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
 *
 * INPUTS:
 *       port - logical port number.
-*		mode - GT_TRUE to enable SA None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
 *       None.
@@ -2165,16 +2175,16 @@ GT_STATUS grcGetVidNrlEn
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcSetSaNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2185,12 +2195,12 @@ GT_STATUS grcSetSaNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -2198,9 +2208,9 @@ GT_STATUS grcSetSaNrlEn
     /* Set the SaNrlEn mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,14,1,data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -2213,30 +2223,30 @@ GT_STATUS grcSetSaNrlEn
 *
 * DESCRIPTION:
 *       This routine gets SA None Rate Limit (NRL) mode.
-*		When SA NRL is enabled and the source address of a frame results in a ATU
-*		hit where the SA's MAC address returns an EntryState that indicates Non
-*		Rate Limited, then the frame will not be ingress nor egress rate limited.
+*        When SA NRL is enabled and the source address of a frame results in a ATU
+*        hit where the SA's MAC address returns an EntryState that indicates Non
+*        Rate Limited, then the frame will not be ingress nor egress rate limited.
 *
 * INPUTS:
 *       port - logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable SA None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable SA None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcGetSaNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -2247,19 +2257,19 @@ GT_STATUS grcGetSaNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the SaNrlEn mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,14,1,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     BIT_2_BOOL(data, *mode);
@@ -2274,15 +2284,15 @@ GT_STATUS grcGetSaNrlEn
 *
 * DESCRIPTION:
 *       This routine enables/disables DA None Rate Limit (NRL).
-*		When DA NRL is enabled and the destination address of a frame results in 
-*		a ATU hit where the DA's MAC address returns an EntryState that indicates 
-*		Non Rate Limited, then the frame will not be ingress nor egress rate 
-*		limited.
+*        When DA NRL is enabled and the destination address of a frame results in 
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates 
+*        Non Rate Limited, then the frame will not be ingress nor egress rate 
+*        limited.
 *
 * INPUTS:
 *       port - logical port number.
-*		mode - GT_TRUE to enable DA None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
 *       None.
@@ -2290,16 +2300,16 @@ GT_STATUS grcGetSaNrlEn
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcSetDaNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2310,12 +2320,12 @@ GT_STATUS grcSetDaNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
@@ -2323,9 +2333,9 @@ GT_STATUS grcSetDaNrlEn
     /* Set the DaNrlEn mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,13,1,data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -2338,31 +2348,31 @@ GT_STATUS grcSetDaNrlEn
 *
 * DESCRIPTION:
 *       This routine gets SA None Rate Limit (NRL) mode.
-*		When DA NRL is enabled and the destination address of a frame results in 
-*		a ATU hit where the DA's MAC address returns an EntryState that indicates 
-*		Non Rate Limited, then the frame will not be ingress nor egress rate 
-*		limited.
+*        When DA NRL is enabled and the destination address of a frame results in 
+*        a ATU hit where the DA's MAC address returns an EntryState that indicates 
+*        Non Rate Limited, then the frame will not be ingress nor egress rate 
+*        limited.
 *
 * INPUTS:
 *       port - logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE to enable DA None Rate Limit
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE to enable DA None Rate Limit
+*               GT_FALSE otherwise
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcGetDaNrlEn
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -2373,19 +2383,19 @@ GT_STATUS grcGetDaNrlEn
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the DaNrlEn mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_INGRESS_RATE_CTRL,13,1,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     BIT_2_BOOL(data, *mode);
@@ -2401,21 +2411,21 @@ GT_STATUS grcGetDaNrlEn
 *
 * DESCRIPTION:
 *       This routine sets Egress Rate Limit counting mode.
-*		The supported modes are as follows:
-*			GT_PIRL_ELIMIT_FRAME -
-*				Count the number of frames
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
-*			GT_PIRL_ELIMIT_LAYER2 -
-*				Count all Layer 2 bytes: Frame's DA to CRC
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
 *
 * INPUTS:
 *       port - logical port number
-*		mode - GT_PIRL_ELIMIT_MODE enum type
+*        mode - GT_PIRL_ELIMIT_MODE enum type
 *
 * OUTPUTS:
 *       None.
@@ -2423,19 +2433,19 @@ GT_STATUS grcGetDaNrlEn
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcSetELimitMode
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	IN  GT_PIRL_ELIMIT_MODE		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_PIRL_ELIMIT_MODE        mode
 )
 {
-	GT_U16			data;
+    GT_U16            data;
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;        /* Physical port.               */
 
@@ -2443,27 +2453,28 @@ GT_STATUS grcSetELimitMode
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE|DEV_ELIMIT_FRAME_BASED))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
-	{
-		if(mode == GT_PIRL_ELIMIT_FRAME)
-			return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    {
+        if(mode == GT_PIRL_ELIMIT_FRAME)
+            return GT_NOT_SUPPORTED;
+    }
 
-	data = (GT_U16)mode & 0x3;
+    data = (GT_U16)mode & 0x3;
 
     /* Set the Elimit mode.            */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_EGRESS_RATE_CTRL,14,2,data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
     DBG_INFO(("OK.\n"));
@@ -2477,40 +2488,40 @@ GT_STATUS grcSetELimitMode
 *
 * DESCRIPTION:
 *       This routine gets Egress Rate Limit counting mode.
-*		The supported modes are as follows:
-*			GT_PIRL_ELIMIT_FRAME -
-*				Count the number of frames
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
-*			GT_PIRL_ELIMIT_LAYER2 -
-*				Count all Layer 2 bytes: Frame's DA to CRC
-*			GT_PIRL_ELIMIT_LAYER1 -
-*				Count all Layer 1 bytes: 
-*				Frame's DA to CRC - 18 - 4 (if frame is tagged)
+*        The supported modes are as follows:
+*            GT_PIRL_ELIMIT_FRAME -
+*                Count the number of frames
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Preamble (8bytes) + Frame's DA to CRC + IFG (12bytes)
+*            GT_PIRL_ELIMIT_LAYER2 -
+*                Count all Layer 2 bytes: Frame's DA to CRC
+*            GT_PIRL_ELIMIT_LAYER1 -
+*                Count all Layer 1 bytes: 
+*                Frame's DA to CRC - 18 - 4 (if frame is tagged)
 *
 * INPUTS:
 *       port - logical port number
 *
 * OUTPUTS:
-*		mode - GT_PIRL_ELIMIT_MODE enum type
+*        mode - GT_PIRL_ELIMIT_MODE enum type
 *
 * RETURNS:
 *       GT_OK               - on success
 *       GT_FAIL             - on error
-*		GT_NOT_SUPPORTED    - if current device does not support this feature.
+*        GT_NOT_SUPPORTED    - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcGetELimitMode
 (
-    IN  GT_QD_DEV	*dev,
-    IN  GT_LPORT	port,
-	OUT GT_PIRL_ELIMIT_MODE		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_PIRL_ELIMIT_MODE        *mode
 )
 {
-	GT_U16			data;
+    GT_U16            data;
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;        /* Physical port.               */
 
@@ -2518,22 +2529,23 @@ GT_STATUS grcGetELimitMode
 
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* check if the given Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE|DEV_ELIMIT_FRAME_BASED))
-	{
-   	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* check if the given Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))))
+    {
+           DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the Elimit mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_EGRESS_RATE_CTRL,14,2,&data);
     if(retVal != GT_OK)
-   	{
+       {
         DBG_INFO(("Failed.\n"));
-   	    return retVal;
+           return retVal;
     }
 
-	*mode = data;
+    *mode = data;
 
     DBG_INFO(("OK.\n"));
 
@@ -2545,13 +2557,13 @@ GT_STATUS grcGetELimitMode
 *
 * DESCRIPTION:
 *       This routine sets Reserved Non Rate Limit.
-*		When this feature is enabled, frames that match the requirements of the 
-*		Rsvd2Cpu bit below will also be considered to be ingress and egress non 
-*		rate limited.
+*        When this feature is enabled, frames that match the requirements of the 
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non 
+*        rate limited.
 *
 * INPUTS:
 *       en - GT_TRUE to enable Reserved Non Rate Limit,
-*			 GT_FALSE to disable
+*             GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
@@ -2559,7 +2571,7 @@ GT_STATUS grcGetELimitMode
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -2572,14 +2584,14 @@ GT_STATUS grcSetRsvdNrlEn
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("grcSetRsvdNrlEn Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -2601,13 +2613,13 @@ GT_STATUS grcSetRsvdNrlEn
 *
 * DESCRIPTION:
 *       This routine gets Reserved Non Rate Limit.
-*		When this feature is enabled, frames that match the requirements of the 
-*		Rsvd2Cpu bit below will also be considered to be ingress and egress non 
-*		rate limited.
+*        When this feature is enabled, frames that match the requirements of the 
+*        Rsvd2Cpu bit below will also be considered to be ingress and egress non 
+*        rate limited.
 *
 * INPUTS:
 *       en - GT_TRUE to enable Reserved Non Rate Limit,
-*			 GT_FALSE to disable
+*             GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
@@ -2615,7 +2627,7 @@ GT_STATUS grcSetRsvdNrlEn
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -2628,14 +2640,14 @@ GT_STATUS grcGetRsvdNrlEn
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("grcGetRsvdNrlEn Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_NONE_RATE_LIMIT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the RsvdNrl bit.            */
@@ -2658,28 +2670,28 @@ GT_STATUS grcGetRsvdNrlEn
 *
 * DESCRIPTION:
 *       Egress rate frame overhead adjustment.
-*		This field is used to adjust the number of bytes that need to be added to a
-*		frame's IFG on a per frame basis.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
 *
-*		The egress rate limiter multiplies the value programmed in this field by four
-*		for computing the frame byte offset adjustment value (i.e., the amount the
-*		IPG is increased for every frame). This adjustment, if enabled, is made to
-*		every egressing frame's IPG and it is made in addition to any other IPG
-*		adjustments due to other Egress Rate Control settings.
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
 *
-*		The egress overhead adjustment can add the following number of byte times
-*		to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
-*		56 and 60.
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
 *
-*		Example:
-*		If FrameOverhead = 11, the egress rate limiter would increase the IPG
-*		between every frame by an additional 44 bytes.
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
 *
-*		Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
-*		shaping mode, these Frame Overhead bits must be 0x0.
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
 *
 * INPUTS:
-*       port	 - logical port number.
+*       port     - logical port number.
 *       overhead - Frame overhead (0 ~ 15)
 *
 * OUTPUTS:
@@ -2689,16 +2701,16 @@ GT_STATUS grcGetRsvdNrlEn
 *       GT_OK               - on success
 *       GT_FAIL             - on error
 *       GT_BAD_PARAM        - on bad parameters
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
 *******************************************************************************/
 GT_STATUS grcSetFrameOverhead
 (
-    IN GT_QD_DEV		*dev,
-    IN GT_LPORT			port,
-    IN GT_32			overhead
+    IN GT_QD_DEV        *dev,
+    IN GT_LPORT            port,
+    IN GT_32            overhead
 )
 {
 
@@ -2710,17 +2722,17 @@ GT_STATUS grcSetFrameOverhead
     phyPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (overhead > 15)
-	{
+    if (overhead > 15)
+    {
         DBG_INFO(("GT_BAD_PARAM \n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     retVal = hwSetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,8,4,(GT_U16)overhead );
     if(retVal != GT_OK)
@@ -2739,28 +2751,28 @@ GT_STATUS grcSetFrameOverhead
 *
 * DESCRIPTION:
 *       Egress rate frame overhead adjustment.
-*		This field is used to adjust the number of bytes that need to be added to a
-*		frame's IFG on a per frame basis.
+*        This field is used to adjust the number of bytes that need to be added to a
+*        frame's IFG on a per frame basis.
 *
-*		The egress rate limiter multiplies the value programmed in this field by four
-*		for computing the frame byte offset adjustment value (i.e., the amount the
-*		IPG is increased for every frame). This adjustment, if enabled, is made to
-*		every egressing frame's IPG and it is made in addition to any other IPG
-*		adjustments due to other Egress Rate Control settings.
+*        The egress rate limiter multiplies the value programmed in this field by four
+*        for computing the frame byte offset adjustment value (i.e., the amount the
+*        IPG is increased for every frame). This adjustment, if enabled, is made to
+*        every egressing frame's IPG and it is made in addition to any other IPG
+*        adjustments due to other Egress Rate Control settings.
 *
-*		The egress overhead adjustment can add the following number of byte times
-*		to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
-*		56 and 60.
+*        The egress overhead adjustment can add the following number of byte times
+*        to each frame's IPG: 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52,
+*        56 and 60.
 *
-*		Example:
-*		If FrameOverhead = 11, the egress rate limiter would increase the IPG
-*		between every frame by an additional 44 bytes.
+*        Example:
+*        If FrameOverhead = 11, the egress rate limiter would increase the IPG
+*        between every frame by an additional 44 bytes.
 *
-*		Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
-*		shaping mode, these Frame Overhead bits must be 0x0.
+*        Note: When the Count Mode (port offset 0x0A) is in Frame based egress rate
+*        shaping mode, these Frame Overhead bits must be 0x0.
 *
 * INPUTS:
-*       port	- logical port number.
+*       port    - logical port number.
 *
 * OUTPUTS:
 *       overhead - Frame overhead (0 ~ 15)
@@ -2768,7 +2780,7 @@ GT_STATUS grcSetFrameOverhead
 * RETURNS:
 *       GT_OK            - on success
 *       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 *******************************************************************************/
 GT_STATUS grcGetFrameOverhead
@@ -2787,12 +2799,12 @@ GT_STATUS grcGetFrameOverhead
     phyPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
+    if (!IS_IN_DEV_GROUP(dev,DEV_ELIMIT_FRAME_BASED))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
-	
+    
     retVal = hwGetPortRegField(dev,phyPort,QD_REG_RATE_CTRL0,8,4,&data);
     if(retVal != GT_OK)
     {
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRmon.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRmon.c
old mode 100644
new mode 100755
index ddeacf6..0defd6b
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRmon.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortRmon.c
@@ -36,17 +36,17 @@ static GT_STATUS statsCapture
 
 static GT_STATUS statsReadCounter
 (
-    IN   GT_QD_DEV		*dev,
-    IN   GT_U32			counter,
-    OUT  GT_U32			*statsData
+    IN   GT_QD_DEV        *dev,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
 );
 
 static GT_STATUS statsReadRealtimeCounter
 (
     IN   GT_QD_DEV      *dev,
-    IN   GT_U8 		    port,
-    IN   GT_U32			counter,
-    OUT  GT_U32		    *statsData
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
 );
 
 
@@ -77,25 +77,25 @@ GT_STATUS gstatsFlushAll
         IN GT_QD_DEV  *dev
 )
 {
-	GT_STATUS       	retVal;
+    GT_STATUS           retVal;
 
-	DBG_INFO(("gstatsFlushAll Called.\n"));
+    DBG_INFO(("gstatsFlushAll Called.\n"));
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,1, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,1, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = statsOperationPerform(dev,STATS_FLUSH_ALL,0,0,NULL);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_FLUSH_ALL,0,0,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -125,32 +125,32 @@ GT_STATUS gstatsFlushAll
 GT_STATUS gstatsFlushPort
 (
     IN GT_QD_DEV  *dev,
-    IN GT_LPORT	  port
+    IN GT_LPORT      port
 )
 {
-	GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsFlushPort Called.\n"));
+    DBG_INFO(("gstatsFlushPort Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = statsOperationPerform(dev,STATS_FLUSH_PORT,hwPort,0,NULL);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_FLUSH_PORT,hwPort,0,NULL);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -158,63 +158,63 @@ GT_STATUS gstatsFlushPort
 * gstatsGetPortCounter
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*        This routine gets a specific counter of the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
-*		None
+*        None
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gstatsGetPortCounter
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS    counter,
+    OUT GT_U32            *statsData
 )
 {
-    GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsFlushPort Called.\n"));
+    DBG_INFO(("gstatsFlushPort Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Gigabit Switch does not support this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -244,40 +244,40 @@ GT_STATUS gstatsGetPortCounter
 GT_STATUS gstatsGetPortAllCounters
 (
     IN  GT_QD_DEV               *dev,
-    IN  GT_LPORT		port,
-    OUT GT_STATS_COUNTER_SET	*statsCounterSet
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET    *statsCounterSet
 )
 {
-	GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsFlushPort Called.\n"));
+    DBG_INFO(("gstatsFlushPort Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Gigabit Switch does not support this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
+    /* Gigabit Switch does not support this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_1))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -285,60 +285,60 @@ GT_STATUS gstatsGetPortAllCounters
 * gstatsGetPortCounter2
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*        This routine gets a specific counter of the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gstatsGetPortCounter2
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS2	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS2    counter,
+    OUT GT_U32            *statsData
 )
 {
-    GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsGetPortCounters2 Called.\n"));
+    DBG_INFO(("gstatsGetPortCounters2 Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -347,58 +347,58 @@ GT_STATUS gstatsGetPortCounter2
 * gstatsGetPortAllCounters2
 *
 * DESCRIPTION:
-*		This routine gets all counters of the given port
+*        This routine gets all counters of the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gstatsGetPortAllCounters2
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	OUT GT_STATS_COUNTER_SET2	*statsCounterSet
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET2    *statsCounterSet
 )
 {
-	GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsGetPortAllCounters2 Called.\n"));
+    DBG_INFO(("gstatsGetPortAllCounters2 Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_2))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -406,61 +406,61 @@ GT_STATUS gstatsGetPortAllCounters2
 * gstatsGetPortCounter3
 *
 * DESCRIPTION:
-*		This routine gets a specific counter of the given port
+*        This routine gets a specific counter of the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
-*		This function supports Gigabit Switch and Spinnaker family
+*        This function supports Gigabit Switch and Spinnaker family
 *
 *******************************************************************************/
 GT_STATUS gstatsGetPortCounter3
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS3	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
 )
 {
-    GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsGetPortCounters3 Called.\n"));
+    DBG_INFO(("gstatsGetPortCounters3 Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Only 88E6093 Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    /* Only 88E6093 Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -469,59 +469,59 @@ GT_STATUS gstatsGetPortCounter3
 * gstatsGetPortAllCounters3
 *
 * DESCRIPTION:
-*		This routine gets all counters of the given port
+*        This routine gets all counters of the given port
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
+*        statsCounterSet - points to GT_STATS_COUNTER_SET for the MIB counters
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
-*		This function supports Gigabit Switch and Spinnaker family
+*        This function supports Gigabit Switch and Spinnaker family
 *
 *******************************************************************************/
 GT_STATUS gstatsGetPortAllCounters3
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	OUT GT_STATS_COUNTER_SET3	*statsCounterSet
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    OUT GT_STATS_COUNTER_SET3    *statsCounterSet
 )
 {
-	GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsGetPortAllCounters3 Called.\n"));
+    DBG_INFO(("gstatsGetPortAllCounters3 Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_TYPE_3))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_ALL,hwPort,0,(GT_VOID*)statsCounterSet);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -529,39 +529,40 @@ GT_STATUS gstatsGetPortAllCounters3
 * gstatsGetHistogramMode
 *
 * DESCRIPTION:
-*		This routine gets the Histogram Counters Mode.
+*        This routine gets the Histogram Counters Mode.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
-*					and GT_COUNT_RX_TX)
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*                    and GT_COUNT_RX_TX)
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gstatsGetHistogramMode
 (
-	IN  GT_QD_DEV				*dev,
-	OUT GT_HISTOGRAM_MODE	*mode
+    IN  GT_QD_DEV                *dev,
+    OUT GT_HISTOGRAM_MODE    *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
     DBG_INFO(("gstatsGetHistogramMode Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_RMON_REALTIME_SUPPORT))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     if(mode == NULL)
@@ -578,8 +579,8 @@ GT_STATUS gstatsGetHistogramMode
         return retVal;
     }
 
-	*mode = data - 1; /* Software definition starts from 0 ~ 2, 
-						while hardware supports the values from 1 to 3 */
+    *mode = data - 1; /* Software definition starts from 0 ~ 2, 
+                        while hardware supports the values from 1 to 3 */
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -589,53 +590,54 @@ GT_STATUS gstatsGetHistogramMode
 * gstatsSetHistogramMode
 *
 * DESCRIPTION:
-*		This routine sets the Histogram Counters Mode.
+*        This routine sets the Histogram Counters Mode.
 *
 * INPUTS:
-*		mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
-*					and GT_COUNT_RX_TX)
+*        mode - Histogram Mode (GT_COUNT_RX_ONLY, GT_COUNT_TX_ONLY, 
+*                    and GT_COUNT_RX_TX)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gstatsSetHistogramMode
 (
-	IN GT_QD_DEV 				*dev,
-	IN GT_HISTOGRAM_MODE		mode
+    IN GT_QD_DEV                 *dev,
+    IN GT_HISTOGRAM_MODE        mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
     DBG_INFO(("gstatsSetHistogramMode Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH|DEV_RMON_REALTIME_SUPPORT))
+    /* Only Gigabit Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_MANAGED_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	switch (mode)
-	{
-		case GT_COUNT_RX_ONLY:
-		case GT_COUNT_TX_ONLY:
-		case GT_COUNT_RX_TX:
-			break;
-		default:
-	        DBG_INFO(("Failed.\n"));
-    	    return GT_BAD_PARAM;
+    switch (mode)
+    {
+        case GT_COUNT_RX_ONLY:
+        case GT_COUNT_TX_ONLY:
+        case GT_COUNT_RX_TX:
+            break;
+        default:
+            DBG_INFO(("Failed.\n"));
+            return GT_BAD_PARAM;
     }
 
-	data = (GT_U16)mode + 1;
+    data = (GT_U16)mode + 1;
 
     /* Set the Histogram mode bit.                */
     retVal = hwSetGlobalRegField(dev,QD_REG_STATS_OPERATION,10,2,data);
@@ -654,60 +656,60 @@ GT_STATUS gstatsSetHistogramMode
 * gstatsGetRealtimePortCounter
 *
 * DESCRIPTION:
-*		This routine gets a specific realtime counter of the given port
+*        This routine gets a specific realtime counter of the given port
 *
 * INPUTS:
-*		port - the logical port number.
-*		counter - the counter which will be read
+*        port - the logical port number.
+*        counter - the counter which will be read
 *
 * OUTPUTS:
-*		statsData - points to 32bit data storage for the MIB counter
+*        statsData - points to 32bit data storage for the MIB counter
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
+*        GT_OK      - on success
+*        GT_FAIL    - on error
 *
 * COMMENTS:
 *
 *******************************************************************************/
 GT_STATUS gstatsGetRealtimePortCounter
 (
-	IN  GT_QD_DEV		*dev,
-	IN  GT_LPORT		port,
-	IN  GT_STATS_COUNTERS3	counter,
-	OUT GT_U32			*statsData
+    IN  GT_QD_DEV        *dev,
+    IN  GT_LPORT        port,
+    IN  GT_STATS_COUNTERS3    counter,
+    OUT GT_U32            *statsData
 )
 {
-    GT_STATUS	retVal;
-    GT_U8		hwPort;         /* physical port number         */
+    GT_STATUS    retVal;
+    GT_U8        hwPort;         /* physical port number         */
 
-	DBG_INFO(("gstatsGetRealtimePortCounter Called.\n"));
+    DBG_INFO(("gstatsGetRealtimePortCounter Called.\n"));
 
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
-	{
-		return retVal;
-	}
+    if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_RMON)) != GT_OK)
+    {
+        return retVal;
+    }
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	retVal = statsOperationPerform(dev,STATS_READ_REALTIME_COUNTER,hwPort,counter,(GT_VOID*)statsData);
-	if(retVal != GT_OK)
-	{
-	    DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
-    	return retVal;
-	}
+    retVal = statsOperationPerform(dev,STATS_READ_REALTIME_COUNTER,hwPort,counter,(GT_VOID*)statsData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (statsOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 
 }
 
@@ -752,31 +754,58 @@ static GT_STATUS statsOperationPerform
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data,histoData; /* Data to be set into the      */
                                     /* register.                    */
-	GT_U32 statsCounter;
-	GT_U32 lastCounter;
-	GT_U16			portNum;
+    GT_U32 statsCounter;
+    GT_U32 lastCounter;
+    GT_U16            portNum;
 
     gtSemTake(dev,dev->statsRegsSem,OS_WAIT_FOREVER);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_RMON_REALTIME_SUPPORT))
+    if (!((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_RMON_REALTIME_SUPPORT))))
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        lastCounter = (GT_U32)STATS2_Late;
+      else
+        lastCounter = (GT_U32)STATS_OutDiscards;
+    }
+    else
+    {
+        lastCounter = (GT_U32)STATS2_Late;
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
     {
-		lastCounter = (GT_U32)STATS_OutDiscards;
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
     }
-	else
-	{
-		lastCounter = (GT_U32)STATS2_Late;
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
-	{
-		portNum = (port + 1) << 5;
-	}
-	else
-	{
-		portNum = (GT_U16)port;
-	}
 
     /* Wait until the stats in ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->statsRegsSem);
+        return retVal;
+      }
+      histoData = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
     data = 1;
     while(data == 1)
     {
@@ -789,80 +818,81 @@ static GT_STATUS statsOperationPerform
     }
 
     /* Get the Histogram mode bit.                */
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
     if(retVal != GT_OK)
     {
         gtSemGive(dev,dev->statsRegsSem);
         return retVal;
     }
-	
-	histoData &= 0xC00;
+    
+#endif
+    histoData &= 0xC00;
 
     /* Set the STAT Operation register */
-	switch (statsOp)
-	{
-		case STATS_FLUSH_ALL:
-			data = (1 << 15) | (GT_STATS_FLUSH_ALL << 12) | histoData;
-			retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
-			gtSemGive(dev,dev->statsRegsSem);
-			return retVal;
-
-		case STATS_FLUSH_PORT:
-			data = (1 << 15) | (GT_STATS_FLUSH_PORT << 12) | portNum | histoData;
-			retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
-			gtSemGive(dev,dev->statsRegsSem);
-			return retVal;
-
-		case STATS_READ_COUNTER:
-			retVal = statsCapture(dev,port);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->statsRegsSem);
-				return retVal;
-			}
-
-			retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->statsRegsSem);
-				return retVal;
-			}
-			break;
-
-		case STATS_READ_REALTIME_COUNTER:
-			retVal = statsReadRealtimeCounter(dev,port,counter,(GT_U32*)statsData);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->statsRegsSem);
-				return retVal;
-			}
-
-			break;
-
-		case STATS_READ_ALL:
-			retVal = statsCapture(dev,port);
-			if(retVal != GT_OK)
-			{
-				gtSemGive(dev,dev->statsRegsSem);
-				return retVal;
-			}
-
-			for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
-			{
-				retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
-				if(retVal != GT_OK)
-				{
-					gtSemGive(dev,dev->statsRegsSem);
-					return retVal;
-				}
-			}
-			break;
-
-		default:
-			
-			gtSemGive(dev,dev->statsRegsSem);
-			return GT_FAIL;
-	}
+    switch (statsOp)
+    {
+        case STATS_FLUSH_ALL:
+            data = (1 << 15) | (GT_STATS_FLUSH_ALL << 12) | histoData;
+            retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+
+        case STATS_FLUSH_PORT:
+            data = (1 << 15) | (GT_STATS_FLUSH_PORT << 12) | portNum | histoData;
+            retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+            gtSemGive(dev,dev->statsRegsSem);
+            return retVal;
+
+        case STATS_READ_COUNTER:
+            retVal = statsCapture(dev,port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            retVal = statsReadCounter(dev,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+            break;
+
+        case STATS_READ_REALTIME_COUNTER:
+            retVal = statsReadRealtimeCounter(dev,port,counter,(GT_U32*)statsData);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            break;
+
+        case STATS_READ_ALL:
+            retVal = statsCapture(dev,port);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->statsRegsSem);
+                return retVal;
+            }
+
+            for(statsCounter=0; statsCounter<=lastCounter; statsCounter++)
+            {
+                retVal = statsReadCounter(dev,statsCounter,((GT_U32*)statsData + statsCounter));
+                if(retVal != GT_OK)
+                {
+                    gtSemGive(dev,dev->statsRegsSem);
+                    return retVal;
+                }
+            }
+            break;
+
+        default:
+            
+            gtSemGive(dev,dev->statsRegsSem);
+            return GT_FAIL;
+    }
 
     gtSemGive(dev,dev->statsRegsSem);
     return GT_OK;
@@ -879,62 +909,80 @@ static GT_STATUS statsOperationPerform
 *       port        - port number
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_OK on success,
 *       GT_FAIL otherwise.
 *
 * COMMENTS:
-*		If Semaphore is used, Semaphore should be acquired before this function call.
+*        If Semaphore is used, Semaphore should be acquired before this function call.
 *******************************************************************************/
 static GT_STATUS statsCapture
 (
     IN GT_QD_DEV            *dev,
-    IN GT_U8 		    port
+    IN GT_U8             port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data, histoData;/* Data to be set into the      */
                                     /* register.                    */
-	GT_U16			portNum;
+    GT_U16            portNum;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
-	{
-		portNum = (port + 1) << 5;
-	}
-	else
-	{
-		portNum = (GT_U16)port;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_RMON_PORT_BITS))
+    {
+        portNum = (port + 1) << 5;
+    }
+    else
+    {
+        portNum = (GT_U16)port;
+    }
 
     /* Get the Histogram mode bit.                */
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
     if(retVal != GT_OK)
     {
         return retVal;
     }
-	
-	histoData &= 0xC00;
+    
+    histoData &= 0xC00;
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
         retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-   	}
+       }
+#endif
 
-	data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | portNum | histoData;
-	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data = (1 << 15) | (GT_STATS_CAPTURE_PORT << 12) | portNum | histoData;
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -956,71 +1004,118 @@ static GT_STATUS statsCapture
 *       GT_FAIL otherwise.
 *
 * COMMENTS:
-*		If Semaphore is used, Semaphore should be acquired before this function call.
+*        If Semaphore is used, Semaphore should be acquired before this function call.
 *******************************************************************************/
 static GT_STATUS statsReadCounter
 (
     IN   GT_QD_DEV      *dev,
-    IN   GT_U32			counter,
-    OUT  GT_U32		    *statsData
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
 )
 {
     GT_STATUS   retVal;         /* Functions return value.            */
     GT_U16      data, histoData;/* Data to be set into the  register. */ 
-    GT_U16	counter3_2;     /* Counter Register Bytes 3 & 2       */
-    GT_U16	counter1_0;     /* Counter Register Bytes 1 & 0       */
+#ifndef GT_RMGMT_ACCESS
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
+#endif
 
     /* Get the Histogram mode bit.                */
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
     if(retVal != GT_OK)
     {
         return retVal;
     }
-	
-	histoData &= 0xC00;
+    
+    histoData &= 0xC00;
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
         retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-   	}
+       }
+#endif
 
-	data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | histoData);
-	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | counter | histoData);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_STATS_COUNTER3_2;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_STATS_COUNTER1_0;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      *statsData = (regAccess.rw_reg_list[1].data << 16) | regAccess.rw_reg_list[2].data;
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
-   	 retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-   	}
+       }
 
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*statsData = (counter3_2 << 16) | counter1_0;
+    *statsData = (counter3_2 << 16) | counter1_0;
+#endif
 
-	return GT_OK;
+    return GT_OK;
 
 }
 
@@ -1043,71 +1138,107 @@ static GT_STATUS statsReadCounter
 *       GT_FAIL otherwise.
 *
 * COMMENTS:
-*		If Semaphore is used, Semaphore should be acquired before this function call.
+*        If Semaphore is used, Semaphore should be acquired before this function call.
 *******************************************************************************/
 static GT_STATUS statsReadRealtimeCounter
 (
     IN   GT_QD_DEV      *dev,
-    IN   GT_U8 		    port,
-    IN   GT_U32			counter,
-    OUT  GT_U32		    *statsData
+    IN   GT_U8             port,
+    IN   GT_U32            counter,
+    OUT  GT_U32            *statsData
 )
 {
     GT_STATUS   retVal;         /* Functions return value.            */
     GT_U16      data, histoData;/* Data to be set into the  register. */ 
-    GT_U16	counter3_2;     /* Counter Register Bytes 3 & 2       */
-    GT_U16	counter1_0;     /* Counter Register Bytes 1 & 0       */
+    GT_U16    counter3_2;     /* Counter Register Bytes 3 & 2       */
+    GT_U16    counter1_0;     /* Counter Register Bytes 1 & 0       */
 
     /* Get the Histogram mode bit.                */
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_OPERATION,&histoData);
     if(retVal != GT_OK)
     {
         return retVal;
     }
-	
-	histoData &= 0xC00;
+    
+    histoData &= 0xC00;
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
         retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-   	}
+       }
+#endif
 
-	data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | ((port+1) << 5) | counter | histoData);
-	retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data = (GT_U16)((1 << 15) | (GT_STATS_READ_COUNTER << 12) | ((port+1) << 5) | counter | histoData);
+    retVal = hwWriteGlobalReg(dev,QD_REG_STATS_OPERATION,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_STATS_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
-   	 retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
+        retVal = hwGetGlobalRegField(dev,QD_REG_STATS_OPERATION,15,1,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-   	}
+       }
+#endif
 
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER3_2,&counter3_2);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobalReg(dev,QD_REG_STATS_COUNTER1_0,&counter1_0);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	*statsData = (counter3_2 << 16) | counter1_0;
+    *statsData = (counter3_2 << 16) | counter1_0;
 
-	return GT_OK;
+    return GT_OK;
 
 }
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStat.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStat.c
old mode 100644
new mode 100755
index 57d9488..c6cfba0
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStat.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStat.c
@@ -48,11 +48,11 @@ GT_STATUS gprtSetCtrMode
 
     DBG_INFO(("gprtSetCtrMode Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,(GT_U16)mode);
     if(retVal != GT_OK)
@@ -99,11 +99,11 @@ GT_STATUS gprtClearAllCtr
 
     DBG_INFO(("gprtClearAllCtr Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* get counter current mode  */
     if(hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,8,1,&mode) != GT_OK)
@@ -160,11 +160,11 @@ GT_STATUS gprtGetPortCtr
 
     DBG_INFO(("gprtGetPortCtr Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     if(ctr  == NULL)
     {
@@ -189,18 +189,19 @@ GT_STATUS gprtGetPortCtr
     }
     ctr->txCtr = count;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
-	{
-	    /* get dropped counter value  */
-    	if(hwReadPortReg(dev,hwPort, QD_REG_DROPPED_COUNTER, &count) != GT_OK)
-	    {
-    	    DBG_INFO(("Failed (Read Tx).\n"));
-        	return GT_FAIL;
-	    }
-		ctr->dropped = count;
-	}
-	else
-		ctr->dropped = 0;
+    if ((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
+    {
+        /* get dropped counter value  */
+        if(hwReadPortReg(dev,hwPort, QD_REG_DROPPED_COUNTER, &count) != GT_OK)
+        {
+            DBG_INFO(("Failed (Read Tx).\n"));
+            return GT_FAIL;
+        }
+        ctr->dropped = count;
+    }
+    else
+        ctr->dropped = 0;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -236,16 +237,18 @@ GT_STATUS gprtGetPortCtr2
     OUT GT_PORT_STAT2   *ctr
 )
 {
+#ifndef GT_RMGMT_ACCESS
     GT_U16          count;          /* counters current value       */
+#endif
     GT_U8           hwPort;         /* physical port number         */
 
     DBG_INFO(("gprtGetPortCtr2 Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     if(ctr  == NULL)
     {
@@ -256,6 +259,38 @@ GT_STATUS gprtGetPortCtr2
     /* translate logical port to physical port */
     hwPort = GT_LPORT_2_PORT(port);
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 4;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_INDISCARD_LO_COUNTER;
+      regAccess.rw_reg_list[0].data = 0;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_INDISCARD_HI_COUNTER;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_INFILTERED_COUNTER;
+      regAccess.rw_reg_list[2].data = 0;
+      regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[3].addr = CALC_SMI_DEV_ADDR(dev, hwPort, PORT_ACCESS);
+      regAccess.rw_reg_list[3].reg = QD_REG_OUTFILTERED_COUNTER;
+      regAccess.rw_reg_list[3].data = 0;
+      if(hwAccessMultiRegs(dev, &regAccess) != GT_OK)
+      {
+        return GT_FAIL;
+      }
+        ctr->inDiscardLo = qdLong2Short(regAccess.rw_reg_list[0].data);
+        ctr->inDiscardHi = qdLong2Short(regAccess.rw_reg_list[1].data);
+        ctr->inFiltered = qdLong2Short(regAccess.rw_reg_list[2].data);
+        ctr->outFiltered = qdLong2Short(regAccess.rw_reg_list[3].data);
+    }
+#else
     /* get InDiscard Low counter value  */
     if(hwReadPortReg(dev,hwPort, QD_REG_INDISCARD_LO_COUNTER, &count) != GT_OK)
     {
@@ -286,6 +321,7 @@ GT_STATUS gprtGetPortCtr2
         return GT_FAIL;
     }
     ctr->outFiltered = count;
+#endif
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStatus.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPortStatus.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPriTable.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPriTable.c
old mode 100644
new mode 100755
index 171e85f..5a36e20
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPriTable.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtPriTable.c
@@ -23,59 +23,59 @@
 *
 * DESCRIPTION:
 *       Queue Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -87,8 +87,8 @@
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -96,104 +96,123 @@
 *******************************************************************************/
 GT_STATUS gsysSetQPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	IN  GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data,qPri;
-
-	DBG_INFO(("gsysSetQPriOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Priority Override Table is ready. */
-	data = 1;
-	while(data == 1)
-	{
-		retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
-	{
-		data = fType << 8;
-
-		retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-		if(retVal != GT_OK)
-		{
-			DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	
-		retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
-		if(retVal != GT_OK)
-		{		
-			DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-
-		data &= ((1 << 7) | (3 << 4));	/* keep QPriAvb information */
-	}
-	else
-		data = 0;
-
-	if (entry->qPriEn)
-		qPri = (GT_U16)((1 << 3) | (entry->qPriority & 0x3));
-	else
-		qPri = 0;
-
-	data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-	
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,qPri;
+
+    DBG_INFO(("gsysSetQPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    if (IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        data = fType << 8;
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    
+        retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+        if(retVal != GT_OK)
+        {        
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        data &= ((1 << 7) | (3 << 4));    /* keep QPriAvb information */
+    }
+    else
+        data = 0;
+
+    if (entry->qPriEn)
+        qPri = (GT_U16)((1 << 3) | (entry->qPriority & 0x3));
+    else
+        qPri = 0;
+
+    data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    
+    return GT_OK;
 }
 
 
@@ -202,59 +221,59 @@ GT_STATUS gsysSetQPriOverrideTable
 *
 * DESCRIPTION:
 *       Queue Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -265,8 +284,8 @@ GT_STATUS gsysSetQPriOverrideTable
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -274,93 +293,112 @@ GT_STATUS gsysSetQPriOverrideTable
 *******************************************************************************/
 GT_STATUS gsysGetQPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	OUT GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
-
-	DBG_INFO(("gsysGetQPriOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Priority Override Table is ready. */
-	data = 1;
-	while(data == 1)
-	{
-		retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	}
-
-	data = fType << 8;
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-	
-	retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	if (data & (1 << 3))
-	{
-		entry->qPriEn = GT_TRUE;
-		entry->qPriority = data & 0x3;
-	}
-	else
-	{
-		entry->qPriEn = GT_FALSE;
-		entry->qPriority = data & 0x3; /* no meaning, but just in case */
-	}
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetQPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+    
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 3))
+    {
+        entry->qPriEn = GT_TRUE;
+        entry->qPriority = data & 0x3;
+    }
+    else
+    {
+        entry->qPriEn = GT_FALSE;
+        entry->qPriority = data & 0x3; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
 
@@ -369,60 +407,60 @@ GT_STATUS gsysGetQPriOverrideTable
 * gsysSetFPriOverrideTable
 *
 * DESCRIPTION:
-* 		Frame Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Frame Priority will be overridden
-*		with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -434,8 +472,8 @@ GT_STATUS gsysGetQPriOverrideTable
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -443,79 +481,98 @@ GT_STATUS gsysGetQPriOverrideTable
 *******************************************************************************/
 GT_STATUS gsysSetFPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	IN  GT_FPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_FPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data,fPri;
-
-	DBG_INFO(("gsysSetFPriOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}		
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Priority Override Table is ready. */
-	data = 1;
-	while(data == 1)
-	{
-		retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	}
-
-	if (entry->fPriEn)
-		fPri = (GT_U16)((1 << 3) | (entry->fPriority & 0x7));
-	else
-		fPri = 0;
-
-	data = (GT_U16)((1 << 15) | (fType << 8) | fPri | 0x1000);
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-	
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,fPri;
+
+    DBG_INFO(("gsysSetFPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }        
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    if (entry->fPriEn)
+        fPri = (GT_U16)((1 << 3) | (entry->fPriority & 0x7));
+    else
+        fPri = 0;
+
+    data = (GT_U16)((1 << 15) | (fType << 8) | fPri | 0x1000);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    
+    return GT_OK;
 }
 
 
@@ -523,60 +580,60 @@ GT_STATUS gsysSetFPriOverrideTable
 * gsysGetQPriOverrideTable
 *
 * DESCRIPTION:
-* 		Frame Priority Override.
-*		When a frame enters a port, its type is determined and the type is used 
-*		to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Frame Priority will be overridden
-*		with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*         Frame Priority Override.
+*        When a frame enters a port, its type is determined and the type is used 
+*        to access the Frame Priority Table. If the type's fPriEn (in GT_FPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Frame Priority will be overridden
+*        with the value written in fPriority (in GT_FPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -596,93 +653,112 @@ GT_STATUS gsysSetFPriOverrideTable
 *******************************************************************************/
 GT_STATUS gsysGetFPriOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	OUT GT_FPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_FPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
-
-	DBG_INFO(("gsysGetFPriOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Priority Override Table is ready. */
-	data = 1;
-	while(data == 1)
-	{
-		retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	}
-
-	data = (fType << 8) | 0x1000;
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-	
-	retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	if (data & (1 << 3))
-	{
-		entry->fPriEn = GT_TRUE;
-		entry->fPriority = data & 0x7;
-	}
-	else
-	{
-		entry->fPriEn = GT_FALSE;
-		entry->fPriority = data & 0x7; /* no meaning, but just in case */
-	}
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetFPriOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = (fType << 8) | 0x1000;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+    
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 3))
+    {
+        entry->fPriEn = GT_TRUE;
+        entry->fPriority = data & 0x7;
+    }
+    else
+    {
+        entry->fPriEn = GT_FALSE;
+        entry->fPriority = data & 0x7; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
 
@@ -690,60 +766,60 @@ GT_STATUS gsysGetFPriOverrideTable
 * gsysSetQPriAvbOverrideTable
 *
 * DESCRIPTION:
-* 		Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
-*		When a frame enters a AVB port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -753,10 +829,10 @@ GT_STATUS gsysGetFPriOverrideTable
 *       None.
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -764,87 +840,87 @@ GT_STATUS gsysGetFPriOverrideTable
 *******************************************************************************/
 GT_STATUS gsysSetQPriAvbOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	IN  GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    IN  GT_QPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data,qPri;
-
-	DBG_INFO(("gsysSetQPriAvbOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	data = fType << 8;
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-	
-	retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
-	if(retVal != GT_OK)
-	{		
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	data &= ((1 << 3) | (3 << 0));	/* keep QPri information */
-
-	if (entry->qPriEn)
-		qPri = (GT_U16)((1 << 7) | ((entry->qPriority & 0x3) << 4));
-	else
-		qPri = 0;
-
-	data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-	
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data,qPri;
+
+    DBG_INFO(("gsysSetQPriAvbOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+    
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {        
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    data &= ((1 << 3) | (3 << 0));    /* keep QPri information */
+
+    if (entry->qPriEn)
+        qPri = (GT_U16)((1 << 7) | ((entry->qPriority & 0x3) << 4));
+    else
+        qPri = 0;
+
+    data |= (GT_U16)((1 << 15) | (fType << 8) | qPri);
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    
+    return GT_OK;
 }
 
 
@@ -852,60 +928,60 @@ GT_STATUS gsysSetQPriAvbOverrideTable
 * gsysGetQPriOverrideTable
 *
 * DESCRIPTION:
-* 		Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
-*		When a frame enters a AVB port, its type is determined and the type is used 
-*		to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
-*		structure) is enabled, then the frame's Queue Priority will be overridden
-*		with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
-*		Frame Types supported are:
-*			FTYPE_DSA_TO_CPU_BPDU -
-*				Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_F2R -
-*				Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
-*				Reply). Not used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_IGMP -
-*				Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
-*				and on non-DSA Control frames that are IGMP or MLD trapped
-*			FTYPE_DSA_TO_CPU_TRAP -
-*				Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
-*				on non-DSA Control frames that are Policy Trapped
-*			FTYPE_DSA_TO_CPU_ARP -
-*				Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
-*				on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
-*			FTYPE_DSA_TO_CPU_MIRROR -
-*				Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
-*				on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
-*			FTYPE_DSA_TO_CPU_RESERVED -
-*				Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
-*				used on non-DSA Control frames.
-*			FTYPE_DSA_TO_CPU_UCAST_MGMT -
-*				Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
-*				MGMT). Not used on non-DSA Control frames.
-*			FTYPE_DSA_FROM_CPU -
-*				Used on DSA From_CPU frames. Not used on non-DSA Control frame
-*			FTYPE_DSA_CROSS_CHIP_FC -
-*				Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
-*				Control). Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
-*				Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
-*				Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
-*				Not used on non-DSA Control frames.
-*			FTYPE_PORT_ETYPE_MATCH -
-*				Used on normal network ports (see gprtSetFrameMode API)
-*				on frames whose Ethertype matches the port's PortEType register.
-*				Not used on non-DSA Control frames.
-*			FTYPE_BCAST_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain a Broadcast
-*				destination address. Not used on DSA Control frames.
-*			FTYPE_PPPoE_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an Ether Type 0x8863
-*				(i.e., PPPoE frames). Not used on DSA Control frames.
-*			FTYPE_IP_NON_DSA_CONTROL -
-*				Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
-*				Type. Not used on DSA Control frames.
+*         Queue Priority Override for AVB enabled ports or AvbOverride enabled ports.
+*        When a frame enters a AVB port, its type is determined and the type is used 
+*        to access the Queue Priority Table. If the type's qPriEn (in GT_QPRI_TBL_ENTRY
+*        structure) is enabled, then the frame's Queue Priority will be overridden
+*        with the value written in qPriority (in GT_QPRI_TBL_ENTRY structure).
+*        Frame Types supported are:
+*            FTYPE_DSA_TO_CPU_BPDU -
+*                Used on multicast DSA To_CPU frames with a Code of 0x0 (BPDU/MGMT).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_F2R -
+*                Used on DSA To_CPU frames with a Code of 0x1 (Frame to Register
+*                Reply). Not used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_IGMP -
+*                Used on DSA To_CPU frames with a Code of 0x2 (IGMP/MLD Trap)
+*                and on non-DSA Control frames that are IGMP or MLD trapped
+*            FTYPE_DSA_TO_CPU_TRAP -
+*                Used on DSA To_CPU frames with a Code of 0x3 (Policy Trap) and
+*                on non-DSA Control frames that are Policy Trapped
+*            FTYPE_DSA_TO_CPU_ARP -
+*                Used on DSA To_CPU frames with a Code of 0x4 (ARP Mirror) and
+*                on non-DSA Control frames that are ARP Mirrored (see gprtSetARPtoCPU API).
+*            FTYPE_DSA_TO_CPU_MIRROR -
+*                Used on DSA To_CPU frames with a Code of 0x5 (Policy Mirror) and
+*                on non-DSA Control frames that are Policy Mirrored (see gprtSetPolicy API).
+*            FTYPE_DSA_TO_CPU_RESERVED -
+*                Used on DSA To_CPU frames with a Code of 0x6 (Reserved). Not
+*                used on non-DSA Control frames.
+*            FTYPE_DSA_TO_CPU_UCAST_MGMT -
+*                Used on unicast DSA To_CPU frames with a Code of 0x0 (unicast
+*                MGMT). Not used on non-DSA Control frames.
+*            FTYPE_DSA_FROM_CPU -
+*                Used on DSA From_CPU frames. Not used on non-DSA Control frame
+*            FTYPE_DSA_CROSS_CHIP_FC -
+*                Used on DSA Cross Chip Flow Control frames (To_Sniffer Flow
+*                Control). Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_EGRESS_MON -
+*                Used on DSA Cross Chip Egress Monitor frames (To_Sniffer Tx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_DSA_CROSS_CHIP_INGRESS_MON -
+*                Used on DSA Cross Chip Ingress Monitor frames (To_Sniffer Rx).
+*                Not used on non-DSA Control frames.
+*            FTYPE_PORT_ETYPE_MATCH -
+*                Used on normal network ports (see gprtSetFrameMode API)
+*                on frames whose Ethertype matches the port's PortEType register.
+*                Not used on non-DSA Control frames.
+*            FTYPE_BCAST_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain a Broadcast
+*                destination address. Not used on DSA Control frames.
+*            FTYPE_PPPoE_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an Ether Type 0x8863
+*                (i.e., PPPoE frames). Not used on DSA Control frames.
+*            FTYPE_IP_NON_DSA_CONTROL -
+*                Used on Non-DSA Control frames that contain an IPv4 or IPv6 Ether
+*                Type. Not used on DSA Control frames.
 *
 * INPUTS:
 *       fType - frame type (GT_PRI_OVERRIDE_FTYPE)
@@ -914,10 +990,10 @@ GT_STATUS gsysSetQPriAvbOverrideTable
 *       entry - Q Priority Override Table entry (GT_QPRI_TBL_ENTRY)
 *
 * RETURNS:
-*		GT_OK      - on success
-*		GT_FAIL    - on error
-*		GT_BAD_PARAM     - on unknown frame type
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK      - on success
+*        GT_FAIL    - on error
+*        GT_BAD_PARAM     - on unknown frame type
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -925,93 +1001,112 @@ GT_STATUS gsysSetQPriAvbOverrideTable
 *******************************************************************************/
 GT_STATUS gsysGetQPriAvbOverrideTable
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_PRI_OVERRIDE_FTYPE	fType,
-	OUT GT_QPRI_TBL_ENTRY	*entry
+    IN  GT_QD_DEV     *dev,
+    IN  GT_PRI_OVERRIDE_FTYPE    fType,
+    OUT GT_QPRI_TBL_ENTRY    *entry
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
-
-	DBG_INFO(("gsysGetQPriAvbOverrideTable Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-
-	switch (fType)
-	{
-		case FTYPE_DSA_TO_CPU_BPDU:
-		case FTYPE_DSA_TO_CPU_F2R:
-		case FTYPE_DSA_TO_CPU_IGMP:
-		case FTYPE_DSA_TO_CPU_TRAP:
-		case FTYPE_DSA_TO_CPU_ARP:
-		case FTYPE_DSA_TO_CPU_MIRROR:
-		case FTYPE_DSA_TO_CPU_RESERVED:
-		case FTYPE_DSA_TO_CPU_UCAST_MGMT:
-		case FTYPE_DSA_FROM_CPU:
-		case FTYPE_DSA_CROSS_CHIP_FC:
-		case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
-		case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
-		case FTYPE_PORT_ETYPE_MATCH:
-		case FTYPE_BCAST_NON_DSA_CONTROL:
-		case FTYPE_PPPoE_NON_DSA_CONTROL:
-		case FTYPE_IP_NON_DSA_CONTROL:
-			break;
-		default:
-	        DBG_INFO(("GT_BAD_PARAM\n"));
-			return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Wait until the Priority Override Table is ready. */
-	data = 1;
-	while(data == 1)
-	{
-		retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
-		if(retVal != GT_OK)
-		{
-			gtSemGive(dev,dev->tblRegsSem);
-			return retVal;
-		}
-	}
-
-	data = fType << 8;
-
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-	
-	retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return retVal;
-	}
-
-	if (data & (1 << 7))
-	{
-		entry->qPriEn = GT_TRUE;
-		entry->qPriority = (data >> 4) & 0x3;
-	}
-	else
-	{
-		entry->qPriEn = GT_FALSE;
-		entry->qPriority = (data >> 4) & 0x3; /* no meaning, but just in case */
-	}
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysGetQPriAvbOverrideTable Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QAVB_PRIORITY_OVERRIDE_TABLE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    switch (fType)
+    {
+        case FTYPE_DSA_TO_CPU_BPDU:
+        case FTYPE_DSA_TO_CPU_F2R:
+        case FTYPE_DSA_TO_CPU_IGMP:
+        case FTYPE_DSA_TO_CPU_TRAP:
+        case FTYPE_DSA_TO_CPU_ARP:
+        case FTYPE_DSA_TO_CPU_MIRROR:
+        case FTYPE_DSA_TO_CPU_RESERVED:
+        case FTYPE_DSA_TO_CPU_UCAST_MGMT:
+        case FTYPE_DSA_FROM_CPU:
+        case FTYPE_DSA_CROSS_CHIP_FC:
+        case FTYPE_DSA_CROSS_CHIP_EGRESS_MON:
+        case FTYPE_DSA_CROSS_CHIP_INGRESS_MON:
+        case FTYPE_PORT_ETYPE_MATCH:
+        case FTYPE_BCAST_NON_DSA_CONTROL:
+        case FTYPE_PPPoE_NON_DSA_CONTROL:
+        case FTYPE_IP_NON_DSA_CONTROL:
+            break;
+        default:
+            DBG_INFO(("GT_BAD_PARAM\n"));
+            return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the Priority Override Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_PRIORITY_OVERRIDE;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+
+    data = fType << 8;
+
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+    
+    retVal = hwReadGlobal2Reg(dev, QD_REG_PRIORITY_OVERRIDE, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+    }
+
+    if (data & (1 << 7))
+    {
+        entry->qPriEn = GT_TRUE;
+        entry->qPriority = (data >> 4) & 0x3;
+    }
+    else
+    {
+        entry->qPriEn = GT_FALSE;
+        entry->qPriority = (data >> 4) & 0x3; /* no meaning, but just in case */
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtQosMap.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtQosMap.c
old mode 100644
new mode 100755
index 0ee3fbf..0f73236
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtQosMap.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtQosMap.c
@@ -35,7 +35,7 @@
 *
 * COMMENTS:
 *       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
-*		family supports 3 bits (0 ~ 7)
+*        family supports 3 bits (0 ~ 7)
 *
 * GalTis:
 *
@@ -57,27 +57,29 @@ GT_STATUS gcosSetPortDefaultTc
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
     {
-	    /* Set the default port pri.  */
-    	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,13,3,trafClass);
+        /* Set the default port pri.  */
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,13,3,trafClass);
+    }
+    else
+    {
+        /* Set the default port pri.  */
+        retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,14,2,trafClass);
     }
-	else
-	{
-	    /* Set the default port pri.  */
-    	retVal = hwSetPortRegField(dev,hwPort,QD_REG_PVID,14,2,trafClass);
-	}
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -100,7 +102,7 @@ GT_STATUS gcosSetPortDefaultTc
 *
 * COMMENTS:
 *       Fast Ethernet switch family supports 2 bits (0 ~ 3) while Gigabit Switch
-*		family supports 3 bits (0 ~ 7)
+*        family supports 3 bits (0 ~ 7)
 *
 * GalTis:
 *
@@ -112,7 +114,7 @@ GT_STATUS gcosGetPortDefaultTc
     OUT GT_U8     *trafClass
 )
 {
-	GT_U16			data;
+    GT_U16            data;
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
 
@@ -123,29 +125,31 @@ GT_STATUS gcosGetPortDefaultTc
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH|DEV_ENHANCED_FE_SWITCH))
+    
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY)))
     {
-	    /* Get the default port pri.  */
-	    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,13,3,&data);
+        /* Get the default port pri.  */
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,13,3,&data);
+    }
+    else
+    {
+        /* Get the default port pri.  */
+        retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,14,2,&data);
     }
-	else
-	{
-	    /* Get the default port pri.  */
-	    retVal = hwGetPortRegField(dev,hwPort,QD_REG_PVID,14,2,&data);
-	}
 
-	*trafClass = (GT_U8)data;
-	
+    *trafClass = (GT_U8)data;
+    
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -156,11 +160,11 @@ GT_STATUS gcosGetPortDefaultTc
 *
 * DESCRIPTION:
 *       This routine sets priority mapping rule.
-*		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
-*		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
-*		enabled, then priority selection is made based on this setup.
-*		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
-*		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*        If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+*        and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+*        enabled, then priority selection is made based on this setup.
+*        If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*        If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
 *
 * INPUTS:
 *       port - the logical port number.
@@ -199,17 +203,17 @@ GT_STATUS gqosSetPrioMapRule
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* Set the TagIfBoth.  */
     retVal = hwSetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,6,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -220,11 +224,11 @@ GT_STATUS gqosSetPrioMapRule
 *
 * DESCRIPTION:
 *       This routine gets priority mapping rule.
-*		If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
-*		and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
-*		enabled, then priority selection is made based on this setup.
-*		If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
-*		If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
+*        If the current frame is both IEEE 802.3ac tagged and an IPv4 or IPv6, 
+*        and UserPrioMap (for IEEE 802.3ac) and IPPrioMap (for IP frame) are 
+*        enabled, then priority selection is made based on this setup.
+*        If PrioMapRule is set to GT_TRUE, UserPrioMap is used.
+*        If PrioMapRule is reset to GT_FALSE, IPPrioMap is used.
 *
 * INPUTS:
 *       port  - the logical port number.
@@ -260,19 +264,19 @@ GT_STATUS gqosGetPrioMapRule
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* get the TagIfBoth.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,6,1,&data);
     /* translate bool to binary */
     BIT_2_BOOL(data, *mode);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -322,17 +326,17 @@ GT_STATUS gqosIpPrioMapEn
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* Set the useIp.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,5,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -380,19 +384,19 @@ GT_STATUS gqosGetIpPrioMapEn
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* Get the UseIp.  */
     retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,5,1,&data);
     /* translate bool to binary */
     BIT_2_BOOL(data, *en);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -443,17 +447,17 @@ GT_STATUS gqosUserPrioMapEn
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* Set the useTag.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL,4,1,data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -501,19 +505,19 @@ GT_STATUS gqosGetUserPrioMapEn
     /* check if device supports this feature */
     if((retVal = IS_VALID_API_CALL(dev,hwPort, DEV_QoS)) != GT_OK ) 
       return retVal;
-	
+    
     /* Get the UseTag.  */
     retVal = hwGetPortRegField(dev,hwPort,QD_REG_PORT_CONTROL,4,1,&data);
     /* translate bool to binary */
     BIT_2_BOOL(data, *en);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -556,21 +560,21 @@ GT_STATUS gcosGetUserPrio2Tc
 
     /* check if device supports this feature */
     if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
-		return GT_NOT_SUPPORTED;
-	
+        return GT_NOT_SUPPORTED;
+    
     /* calc the bit offset */
     bitOffset = ((userPrior & 0x7) * 2);
     /* Get the traffic class for the VPT.  */
     retVal = hwGetGlobalRegField(dev,QD_REG_IEEE_PRI,bitOffset,2,&data);
     *trClass = (GT_U8)data;
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -613,20 +617,20 @@ GT_STATUS gcosSetUserPrio2Tc
     DBG_INFO(("gcosSetUserPrio2Tc Called.\n"));
     /* check if device supports this feature */
     if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
-		return GT_NOT_SUPPORTED;
-	
+        return GT_NOT_SUPPORTED;
+    
     /* calc the bit offset */
     bitOffset = ((userPrior & 0x7) * 2);
     /* Set the traffic class for the VPT.  */
     retVal = hwSetGlobalRegField(dev,QD_REG_IEEE_PRI, bitOffset,2,trClass);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -671,8 +675,8 @@ GT_STATUS gcosGetDscp2Tc
     DBG_INFO(("gcosGetDscp2Tc Called.\n"));
     /* check if device supports this feature */
     if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
-		return GT_NOT_SUPPORTED;
-	
+        return GT_NOT_SUPPORTED;
+    
     /* calc the bit offset */
     bitOffset = (((dscp & 0x3f) % 8) * 2);
     regOffset = ((dscp & 0x3f) / 8);
@@ -681,13 +685,13 @@ GT_STATUS gcosGetDscp2Tc
                                  bitOffset, 2, &data);
     *trClass = (GT_U8)data;
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -732,8 +736,8 @@ GT_STATUS gcosSetDscp2Tc
     DBG_INFO(("gcosSetDscp2Tc Called.\n"));
     /* check if device supports this feature */
     if(!IS_IN_DEV_GROUP(dev,DEV_QoS))
-		return GT_NOT_SUPPORTED;
-	
+        return GT_NOT_SUPPORTED;
+    
     /* calc the bit offset */
     bitOffset = (((dscp & 0x3f) % 8) * 2);
     regOffset = ((dscp & 0x3f) / 8);
@@ -741,13 +745,13 @@ GT_STATUS gcosSetDscp2Tc
     retVal = hwSetGlobalRegField(dev,(GT_U8)(QD_REG_IP_PRI_BASE+regOffset),
                                  bitOffset, 2, trClass);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -758,32 +762,32 @@ GT_STATUS gcosSetDscp2Tc
 * gqosGetTagRemap
 *
 * DESCRIPTION:
-*		Gets the remapped priority value for a specific 802.1p priority on a
-*		given port.
+*        Gets the remapped priority value for a specific 802.1p priority on a
+*        given port.
 *
 * INPUTS:
-*		port  - the logical port number.
-*		pri   - 802.1p priority
+*        port  - the logical port number.
+*        pri   - 802.1p priority
 *
 * OUTPUTS:
-*		remappedPri - remapped Priority
+*        remappedPri - remapped Priority
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gqosGetTagRemap
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT 	port,
-	IN  GT_U8    	pri,
-	OUT GT_U8   	*remappedPri
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT     port,
+    IN  GT_U8        pri,
+    OUT GT_U8       *remappedPri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -791,41 +795,41 @@ GT_STATUS gqosGetTagRemap
     GT_U8           phyPort;        /* Physical port.               */
     GT_U8           regAddr;        /* register address.            */
     GT_U8           bitOffset;      /* the bit offset in the reg    */
-	
+    
     DBG_INFO(("gqosGetTagRemap Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if (pri <= 3)
-	{
-		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
-	}
-	else
-	{
-		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
-	}
+    if (pri <= 3)
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+    }
+    else
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+    }
 
     /* calc the bit offset */
     bitOffset = 4 * (pri % 4);
-	
+    
     retVal = hwGetPortRegField(dev,phyPort,regAddr,bitOffset,3,&data );
 
     *remappedPri = (GT_U8)data;
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -835,72 +839,72 @@ GT_STATUS gqosGetTagRemap
 * gqosSetTagRemap
 *
 * DESCRIPTION:
-*		Sets the remapped priority value for a specific 802.1p priority on a
-*		given port.
+*        Sets the remapped priority value for a specific 802.1p priority on a
+*        given port.
 *
 * INPUTS:
-*		port  - the logical port number.
-*		pri   - 802.1p priority
-*		remappedPri - remapped Priority
+*        port  - the logical port number.
+*        pri   - 802.1p priority
+*        remappedPri - remapped Priority
 *
 * OUTPUTS:
-*		None
+*        None
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gqosSetTagRemap
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port,
-	IN GT_U8    	pri,
-	IN GT_U8    	remappedPri
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port,
+    IN GT_U8        pri,
+    IN GT_U8        remappedPri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           phyPort;        /* Physical port.               */
     GT_U8           regAddr;        /* register address.            */
     GT_U8           bitOffset;      /* the bit offset in the reg    */
-	
+    
     DBG_INFO(("gqosSetTagRemap Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_PRIORITY_REMAPPING))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     phyPort = GT_LPORT_2_PORT(port);
 
-	if (pri <= 3)
-	{
-		regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
-	}
-	else
-	{
-		regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
-	}
+    if (pri <= 3)
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_3_0;
+    }
+    else
+    {
+        regAddr = QD_REG_IEEE_PRI_REMAP_7_4;
+    }
 
     /* calc the bit offset */
     bitOffset = 4 * (pri % 4);
-	
+    
     retVal = hwSetPortRegField(dev,phyPort,regAddr,bitOffset,3,remappedPri);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -911,10 +915,10 @@ GT_STATUS gqosSetTagRemap
 *
 * DESCRIPTION:
 *       This routine sets Queue priority value to used when forced.
-*		When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
-*		are mapped to the priority queue defined in this value, unless a VTU, SA,
-*		DA or ARP priority override occurs. The Frame's priority (FPri) is not
-*		effected by this value.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
 *
 * INPUTS:
 *       port - the logical port number.
@@ -926,7 +930,7 @@ GT_STATUS gqosSetTagRemap
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 3
+*        GT_BAD_PARAM - if pri > 3
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -948,26 +952,26 @@ GT_STATUS gqosSetQPriValue
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (pri > 3)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (pri > 3)
+    {
+        return GT_BAD_PARAM;
+    }
 
     /* Set the QPriValue.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 2, (GT_U16)pri);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -977,10 +981,10 @@ GT_STATUS gqosSetQPriValue
 *
 * DESCRIPTION:
 *       This routine gets Queue priority value to used when forced.
-*		When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
-*		are mapped to the priority queue defined in this value, unless a VTU, SA,
-*		DA or ARP priority override occurs. The Frame's priority (FPri) is not
-*		effected by this value.
+*        When ForceQPri is enabled (gqosSetForceQPri), all frames entering this port
+*        are mapped to the priority queue defined in this value, unless a VTU, SA,
+*        DA or ARP priority override occurs. The Frame's priority (FPri) is not
+*        effected by this value.
 *
 * INPUTS:
 *       port - the logical port number.
@@ -1005,7 +1009,7 @@ GT_STATUS gqosGetQPriValue
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gqosGetQPriValue Called.\n"));
 
@@ -1013,23 +1017,23 @@ GT_STATUS gqosGetQPriValue
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the QPriValue.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 10, 2, &data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*pri = (GT_U8)data;
+    *pri = (GT_U8)data;
 
     return retVal;
 }
@@ -1040,16 +1044,16 @@ GT_STATUS gqosGetQPriValue
 *
 * DESCRIPTION:
 *       This routine enables/disables forcing Queue priority.
-*		When ForceQPri is disabled, normal priority queue mapping is used on all 
-*		ingressing frames entering this port. When it's enabled, all frames
-*		entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
-*		a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
-*		is not effected by this feature.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all 
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
 *
 * INPUTS:
 *       port - the logical port number.
 *       en   - GT_TRUE, to force Queue Priority,
-*			   GT_FALSE, otherwise.
+*               GT_FALSE, otherwise.
 *
 * OUTPUTS:
 *       None.
@@ -1082,21 +1086,21 @@ GT_STATUS gqosSetForceQPri
     BOOL_2_BIT(en, data);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Set the ForceQPri.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 9, 1, data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1106,18 +1110,18 @@ GT_STATUS gqosSetForceQPri
 *
 * DESCRIPTION:
 *       This routine checks if forcing Queue priority is enabled.
-*		When ForceQPri is disabled, normal priority queue mapping is used on all 
-*		ingressing frames entering this port. When it's enabled, all frames
-*		entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
-*		a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
-*		is not effected by this feature.
+*        When ForceQPri is disabled, normal priority queue mapping is used on all 
+*        ingressing frames entering this port. When it's enabled, all frames
+*        entering this port are mapped to the QPriValue (gqosSetQPriValue), unless
+*        a VTU, SA, DA or ARP priority override occurs. The frame's priorty (FPri)
+*        is not effected by this feature.
 *
 * INPUTS:
 *       port - the logical port number.
 *
 * OUTPUTS:
 *       en   - GT_TRUE, to force Queue Priority,
-*			   GT_FALSE, otherwise.
+*               GT_FALSE, otherwise.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1144,21 +1148,21 @@ GT_STATUS gqosGetForceQPri
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the ForceQPri.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_VLAN_MAP, 9, 1, &data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *en);
 
@@ -1171,8 +1175,8 @@ GT_STATUS gqosGetForceQPri
 *
 * DESCRIPTION:
 *       This routine sets the default frame priority (0 ~ 7).
-*		This priority is used as the default frame priority (FPri) to use when 
-*		no other priority information is available.
+*        This priority is used as the default frame priority (FPri) to use when 
+*        no other priority information is available.
 *
 * INPUTS:
 *       port - the logical port number
@@ -1184,7 +1188,7 @@ GT_STATUS gqosGetForceQPri
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 7
+*        GT_BAD_PARAM - if pri > 7
 *       GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
@@ -1206,26 +1210,26 @@ GT_STATUS gqosSetDefFPri
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (pri > 7)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (pri > 7)
+    {
+        return GT_BAD_PARAM;
+    }
 
     /* Set the DefFPri.  */
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PVID, 13, 3, (GT_U16)pri);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     return retVal;
 }
@@ -1236,8 +1240,8 @@ GT_STATUS gqosSetDefFPri
 *
 * DESCRIPTION:
 *       This routine gets the default frame priority (0 ~ 7).
-*		This priority is used as the default frame priority (FPri) to use when 
-*		no other priority information is available.
+*        This priority is used as the default frame priority (FPri) to use when 
+*        no other priority information is available.
 *
 * INPUTS:
 *       port - the logical port number
@@ -1262,7 +1266,7 @@ GT_STATUS gqosGetDefFPri
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U8           hwPort;         /* the physical port number     */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gqosGetDefFPri Called.\n"));
 
@@ -1270,23 +1274,23 @@ GT_STATUS gqosGetDefFPri
     hwPort = GT_LPORT_2_PORT(port);
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
-	{
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_FPRI_QPRI))
+    {
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the DefFPri.  */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PVID, 13, 3, &data);
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
-	*pri = (GT_U8)data;
+    *pri = (GT_U8)data;
     return retVal;
 }
 
@@ -1295,28 +1299,28 @@ GT_STATUS gqosGetDefFPri
 * gqosSetVIDFPriOverride
 *
 * DESCRIPTION:
-*		This routine sets VID Frame Priority Override. When this feature is enabled,
-*		VID Frame priority overrides can occur on this port.
-*		VID Frame priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
-*		When this occurs the VIDFPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new VIDFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine sets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for VID Frame Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1325,9 +1329,9 @@ GT_STATUS gqosGetDefFPri
 *******************************************************************************/
 GT_STATUS gqosSetVIDFPriOverride
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -1339,26 +1343,26 @@ GT_STATUS gqosSetVIDFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
     BOOL_2_BIT(mode, data);
 
     /* Set the VIDFPriOverride mode.            */
-   	retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
+       retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1367,27 +1371,27 @@ GT_STATUS gqosSetVIDFPriOverride
 * gqosGetVIDFPriOverride
 *
 * DESCRIPTION:
-*		This routine gets VID Frame Priority Override. When this feature is enabled,
-*		VID Frame priority overrides can occur on this port.
-*		VID Frame priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
-*		When this occurs the VIDFPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new VIDFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine gets VID Frame Priority Override. When this feature is enabled,
+*        VID Frame priority overrides can occur on this port.
+*        VID Frame priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDFPri override field is set to GT_TRUE.
+*        When this occurs the VIDFPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new VIDFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for VID Frame Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for VID Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1396,9 +1400,9 @@ GT_STATUS gqosSetVIDFPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetVIDFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -1410,23 +1414,23 @@ GT_STATUS gqosGetVIDFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the VIDFPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,14,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -1438,30 +1442,30 @@ GT_STATUS gqosGetVIDFPriOverride
 * gqosSetSAFPriOverride
 *
 * DESCRIPTION:
-*		This routine sets Source Address(SA) Frame Priority Override. 
-*		When this feature is enabled, SA Frame priority overrides can occur on 
-*		this port.
-*		SA ATU Frame priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine sets Source Address(SA) Frame Priority Override. 
+*        When this feature is enabled, SA Frame priority overrides can occur on 
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for SA Frame Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1470,9 +1474,9 @@ GT_STATUS gqosGetVIDFPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetSAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -1484,10 +1488,10 @@ GT_STATUS gqosSetSAFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -1497,13 +1501,13 @@ GT_STATUS gqosSetSAFPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1511,29 +1515,29 @@ GT_STATUS gqosSetSAFPriOverride
 * gqosGetSAFPriOverride
 *
 * DESCRIPTION:
-*		This routine gets Source Address(SA) Frame Priority Override. 
-*		When this feature is enabled, SA Frame priority overrides can occur on 
-*		this port.
-*		SA ATU Frame priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine gets Source Address(SA) Frame Priority Override. 
+*        When this feature is enabled, SA Frame priority overrides can occur on 
+*        this port.
+*        SA ATU Frame priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for SA Frame Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for SA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1542,9 +1546,9 @@ GT_STATUS gqosSetSAFPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetSAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -1556,23 +1560,23 @@ GT_STATUS gqosGetSAFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the SAFPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,13,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -1583,30 +1587,30 @@ GT_STATUS gqosGetSAFPriOverride
 * gqosSetDAFPriOverride
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Frame Priority Override. 
-*		When this feature is enabled, DA Frame priority overrides can occur on 
-*		this port.
-*		DA ATU Frame priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine sets Destination Address(DA) Frame Priority Override. 
+*        When this feature is enabled, DA Frame priority overrides can occur on 
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DA Frame Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1615,9 +1619,9 @@ GT_STATUS gqosGetSAFPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetDAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -1629,10 +1633,10 @@ GT_STATUS gqosSetDAFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -1642,13 +1646,13 @@ GT_STATUS gqosSetDAFPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1656,29 +1660,29 @@ GT_STATUS gqosSetDAFPriOverride
 * gqosGetDAFPriOverride
 *
 * DESCRIPTION:
-*		This routine gets Destination Address(DA) Frame Priority Override. 
-*		When this feature is enabled, DA Frame priority overrides can occur on 
-*		this port.
-*		DA ATU Frame priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUFPri field set to GT_TRUE.
-*		When this occurs the ATUFPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined frame 
-*		priority. If the frame egresses tagged the priority in the frame will be
-*		this new ATUFPri value. This function does not affect the egress queue
-*		priority (QPri) the frame is switched into.
+*        This routine gets Destination Address(DA) Frame Priority Override. 
+*        When this feature is enabled, DA Frame priority overrides can occur on 
+*        this port.
+*        DA ATU Frame priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUFPri field set to GT_TRUE.
+*        When this occurs the ATUFPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined frame 
+*        priority. If the frame egresses tagged the priority in the frame will be
+*        this new ATUFPri value. This function does not affect the egress queue
+*        priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for DA Frame Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for DA Frame Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1687,9 +1691,9 @@ GT_STATUS gqosSetDAFPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetDAFPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -1701,23 +1705,23 @@ GT_STATUS gqosGetDAFPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DAFPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,12,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -1729,28 +1733,28 @@ GT_STATUS gqosGetDAFPriOverride
 * gqosSetVIDQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets VID Queue Priority Override. When this feature is enabled,
-*		VID Queue priority overrides can occur on this port.
-*		VID Queue priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
-*		When this occurs the VIDQPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new VIDQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine sets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for VID Queue Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1759,9 +1763,9 @@ GT_STATUS gqosGetDAFPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetVIDQPriOverride
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port,
-	IN GT_BOOL		mode
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port,
+    IN GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -1773,10 +1777,10 @@ GT_STATUS gqosSetVIDQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -1786,13 +1790,13 @@ GT_STATUS gqosSetVIDQPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,3,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1801,27 +1805,27 @@ GT_STATUS gqosSetVIDQPriOverride
 * gqosGetVIDQPriOverride
 *
 * DESCRIPTION:
-*		This routine gets VID Queue Priority Override. When this feature is enabled,
-*		VID Queue priority overrides can occur on this port.
-*		VID Queue priority override occurs when the determined VID of a frame 
-*		results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
-*		When this occurs the VIDQPri value assigned to the frame's VID (in the 
-*		VTU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new VIDQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine gets VID Queue Priority Override. When this feature is enabled,
+*        VID Queue priority overrides can occur on this port.
+*        VID Queue priority override occurs when the determined VID of a frame 
+*        results in a VTU entry whose useVIDQPri override field is set to GT_TRUE.
+*        When this occurs the VIDQPri value assigned to the frame's VID (in the 
+*        VTU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new VIDQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for VID Queue Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for VID Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1830,9 +1834,9 @@ GT_STATUS gqosSetVIDQPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetVIDQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -1844,23 +1848,23 @@ GT_STATUS gqosGetVIDQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the VIDQPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,3,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -1872,30 +1876,30 @@ GT_STATUS gqosGetVIDQPriOverride
 * gqosSetSAQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets Source Address(SA) Queue Priority Override. 
-*		When this feature is enabled, SA Queue priority overrides can occur on 
-*		this port.
-*		SA ATU Queue priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine sets Source Address(SA) Queue Priority Override. 
+*        When this feature is enabled, SA Queue priority overrides can occur on 
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for SA Queue Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1904,9 +1908,9 @@ GT_STATUS gqosGetVIDQPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetSAQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -1918,10 +1922,10 @@ GT_STATUS gqosSetSAQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -1931,13 +1935,13 @@ GT_STATUS gqosSetSAQPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,2,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -1945,29 +1949,29 @@ GT_STATUS gqosSetSAQPriOverride
 * gqosGetSAQPriOverride
 *
 * DESCRIPTION:
-*		This routine gets Source Address(SA) Queue Priority Override. 
-*		When this feature is enabled, SA Queue priority overrides can occur on 
-*		this port.
-*		SA ATU Queue priority override occurs when the determined source address
-*		of a frame results in an ATU hit where the SA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's SA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue 
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine gets Source Address(SA) Queue Priority Override. 
+*        When this feature is enabled, SA Queue priority overrides can occur on 
+*        this port.
+*        SA ATU Queue priority override occurs when the determined source address
+*        of a frame results in an ATU hit where the SA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's SA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue 
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for SA Queue Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for SA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -1976,9 +1980,9 @@ GT_STATUS gqosSetSAQPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetSAQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -1990,23 +1994,23 @@ GT_STATUS gqosGetSAQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the SAQPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,2,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -2017,30 +2021,30 @@ GT_STATUS gqosGetSAQPriOverride
 * gqosSetDAQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Queue Priority Override. 
-*		When this feature is enabled, DA Queue priority overrides can occur on 
-*		this port.
-*		DA ATU Queue priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine sets Destination Address(DA) Queue Priority Override. 
+*        When this feature is enabled, DA Queue priority overrides can occur on 
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for DA Queue Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2049,9 +2053,9 @@ GT_STATUS gqosGetSAQPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetDAQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2063,10 +2067,10 @@ GT_STATUS gqosSetDAQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -2076,13 +2080,13 @@ GT_STATUS gqosSetDAQPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,1,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2090,29 +2094,29 @@ GT_STATUS gqosSetDAQPriOverride
 * gqosGetDAQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets Destination Address(DA) Queue Priority Override. 
-*		When this feature is enabled, DA Queue priority overrides can occur on 
-*		this port.
-*		DA ATU Queue priority override occurs when the determined destination address
-*		of a frame results in an ATU hit where the DA's MAC address entry contains 
-*		the useATUQPri field set to GT_TRUE.
-*		When this occurs the ATUQPri value assigned to the frame's DA (in the 
-*		ATU Table) is used to overwrite the frame's previously determined queue
-*		priority. If the frame egresses tagged the priority in the frame will not
-*		be modified by this new ATUQPri value. This function affects the egress
-*		queue priority (QPri) the frame is switched into.
+*        This routine sets Destination Address(DA) Queue Priority Override. 
+*        When this feature is enabled, DA Queue priority overrides can occur on 
+*        this port.
+*        DA ATU Queue priority override occurs when the determined destination address
+*        of a frame results in an ATU hit where the DA's MAC address entry contains 
+*        the useATUQPri field set to GT_TRUE.
+*        When this occurs the ATUQPri value assigned to the frame's DA (in the 
+*        ATU Table) is used to overwrite the frame's previously determined queue
+*        priority. If the frame egresses tagged the priority in the frame will not
+*        be modified by this new ATUQPri value. This function affects the egress
+*        queue priority (QPri) the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for DA Queue Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for DA Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2121,9 +2125,9 @@ GT_STATUS gqosSetDAQPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetDAQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -2135,23 +2139,23 @@ GT_STATUS gqosGetDAQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the DAQPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,1,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -2162,28 +2166,28 @@ GT_STATUS gqosGetDAQPriOverride
 * gqosSetARPQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets ARP Queue Priority Override. 
-*		When this feature is enabled, ARP Queue priority overrides can occur on 
-*		this port.
-*		ARP Queue priority override occurs for all ARP frames.
-*		When this occurs, the frame's previously determined egress queue priority
-*		will be overwritten with ArpQPri.
-*		If the frame egresses tagged the priority in the frame will not
-*		be modified. When used, the two bits of the ArpQPri priority determine the
-*		egress queue the frame is switched into.
+*        This routine sets ARP Queue Priority Override. 
+*        When this feature is enabled, ARP Queue priority overrides can occur on 
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
-*		mode - GT_TRUE for ARP Queue Priority Override,
-*			   GT_FALSE otherwise
+*        port - the logical port number.
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2192,9 +2196,9 @@ GT_STATUS gqosGetDAQPriOverride
 *******************************************************************************/
 GT_STATUS gqosSetARPQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	IN  GT_BOOL		mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    IN  GT_BOOL        mode
 )
 {
     GT_U16          data;           
@@ -2206,10 +2210,10 @@ GT_STATUS gqosSetARPQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate BOOL to binary */
@@ -2219,13 +2223,13 @@ GT_STATUS gqosSetARPQPriOverride
     retVal = hwSetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,1,data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
     return retVal;
 }
 
@@ -2233,27 +2237,27 @@ GT_STATUS gqosSetARPQPriOverride
 * gqosGetARPQPriOverride
 *
 * DESCRIPTION:
-*		This routine sets ARP Queue Priority Override. 
-*		When this feature is enabled, ARP Queue priority overrides can occur on 
-*		this port.
-*		ARP Queue priority override occurs for all ARP frames.
-*		When this occurs, the frame's previously determined egress queue priority
-*		will be overwritten with ArpQPri.
-*		If the frame egresses tagged the priority in the frame will not
-*		be modified. When used, the two bits of the ArpQPri priority determine the
-*		egress queue the frame is switched into.
+*        This routine sets ARP Queue Priority Override. 
+*        When this feature is enabled, ARP Queue priority overrides can occur on 
+*        this port.
+*        ARP Queue priority override occurs for all ARP frames.
+*        When this occurs, the frame's previously determined egress queue priority
+*        will be overwritten with ArpQPri.
+*        If the frame egresses tagged the priority in the frame will not
+*        be modified. When used, the two bits of the ArpQPri priority determine the
+*        egress queue the frame is switched into.
 *
 * INPUTS:
-*		port - the logical port number.
+*        port - the logical port number.
 *
 * OUTPUTS:
-*		mode - GT_TRUE for ARP Queue Priority Override,
-*			   GT_FALSE otherwise
+*        mode - GT_TRUE for ARP Queue Priority Override,
+*               GT_FALSE otherwise
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS: 
 *
@@ -2262,9 +2266,9 @@ GT_STATUS gqosSetARPQPriOverride
 *******************************************************************************/
 GT_STATUS gqosGetARPQPriOverride
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	port,
-	OUT GT_BOOL		*mode
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    port,
+    OUT GT_BOOL        *mode
 )
 {
     GT_U16          data;           
@@ -2276,23 +2280,23 @@ GT_STATUS gqosGetARPQPriOverride
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the ARPQPriOverride mode.            */
     retVal = hwGetPortRegField(dev,hwPort, QD_REG_PORT_CONTROL2,0,1,&data);
 
     if(retVal != GT_OK)
-	{
+    {
         DBG_INFO(("Failed.\n"));
-	}
+    }
     else
-	{
+    {
         DBG_INFO(("OK.\n"));
-	}
+    }
 
     BIT_2_BOOL(data, *mode);
 
@@ -2305,9 +2309,9 @@ GT_STATUS gqosGetARPQPriOverride
 *
 * DESCRIPTION:
 *       This routine sets ARP queue Priority to use for ARP QPri Overridden 
-*		frames. When a ARP frame is received on a por tthat has its ARP 
-*		QPriOVerride is enabled, the QPri assigned to the frame comes from
-*		this value
+*        frames. When a ARP frame is received on a por tthat has its ARP 
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
 *
 * INPUTS:
 *       pri - ARP Queue Priority (0 ~ 3)
@@ -2318,8 +2322,8 @@ GT_STATUS gqosGetARPQPriOverride
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_BAD_PARAM - if pri > 3
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_BAD_PARAM - if pri > 3
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -2332,23 +2336,23 @@ GT_STATUS gqosSetArpQPri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gqosSetArpQPri Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (pri > 3)
-	{
-		DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+    if (pri > 3)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
 
-	data = (GT_U16)pri;
+    data = (GT_U16)pri;
 
     /* Set the ArpQPri bit.            */
     retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,6,2,data);
@@ -2368,9 +2372,9 @@ GT_STATUS gqosSetArpQPri
 *
 * DESCRIPTION:
 *       This routine gets ARP queue Priority to use for ARP QPri Overridden 
-*		frames. When a ARP frame is received on a por tthat has its ARP 
-*		QPriOVerride is enabled, the QPri assigned to the frame comes from
-*		this value
+*        frames. When a ARP frame is received on a por tthat has its ARP 
+*        QPriOVerride is enabled, the QPri assigned to the frame comes from
+*        this value
 *
 * INPUTS:
 *       None.
@@ -2381,7 +2385,7 @@ GT_STATUS gqosSetArpQPri
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -2394,14 +2398,14 @@ GT_STATUS gqosGetArpQPri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gqosGetArpQPri Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_FQPRI_OVERRIDE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the ArpQPri bit.            */
@@ -2412,7 +2416,7 @@ GT_STATUS gqosGetArpQPri
         return retVal;
     }
 
-	*pri = (GT_U8)data;
+    *pri = (GT_U8)data;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysConfig.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysConfig.c
old mode 100644
new mode 100755
index 8372ba3..ab0dd25
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysConfig.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysConfig.c
@@ -15,11 +15,158 @@
 *******************************************************************************/
 
 #include <msApi.h>
+#include <msApiPrototype.h>
 #include <gtDrvConfig.h>
 #include <gtSem.h>
 #include <platformDeps.h>
+#ifdef GT_USE_MAD
+#include <madApi.h>
+#include <madApiDefs.h>
+#endif
+#include <gtHwCntl.h>
+
+extern GT_U8 lport2port(IN GT_U16 portVec, IN GT_LPORT  port);
+extern GT_LPORT port2lport(IN GT_U16 portVec, IN GT_U8  hwPort);
+extern GT_U32 lportvec2portvec(IN GT_U16 portVec, IN GT_U32  lVec);
+extern GT_U32 portvec2lportvec(IN GT_U16 portVec, IN GT_U32  pVec);
+static GT_BOOL gtRegister(GT_QD_DEV *qd_dev, BSP_FUNCTIONS* pBSPFunctions);
+
+#ifdef GT_USE_MAD
+static MAD_BOOL madSMIRead(MAD_DEV* dev, unsigned int smiAddr, 
+              unsigned int reg, unsigned int* value)
+{
+  GT_STATUS  status;
+  GT_U16 data;
+
+  status = 	hwReadPhyReg((GT_QD_DEV *)(dev->appData), smiAddr, reg, &data);
+
+  if(status == GT_OK)
+  {
+	*value = data;
+	return MAD_TRUE;
+  }
+  else
+	return MAD_FALSE;
+}
+
+static MAD_BOOL madSMIWrite(MAD_DEV* dev, unsigned int smiAddr, 
+              unsigned int reg, unsigned int value)
+{
+  GT_STATUS  status;
+  GT_U16 data;
+
+  data = value;
+  status = 	hwWritePhyReg((GT_QD_DEV *)(dev->appData), smiAddr, reg, data);
+
+  if(status == GT_OK)
+	return MAD_TRUE;
+  else
+	return MAD_FALSE;
+}
 
-static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions);
+static char * madGetDeviceName ( MAD_DEVICE_ID deviceId)
+{
+
+    switch (deviceId)
+    {
+        case MAD_88E10X0: return ("MAD_88E10X0 ");   
+        case MAD_88E10X0S: return ("MAD_88E10X0S ");   
+        case MAD_88E1011: return ("MAD_88E1011 ");   
+        case MAD_88E104X: return ("MAD_88E104X ");
+        case MAD_88E1111: return ("MAD_88E1111/MAD_88E1115 ");
+        case MAD_88E1112: return ("MAD_88E1112 ");
+        case MAD_88E1116: return ("MAD_88E1116/MAD_88E1116R ");
+        case MAD_88E114X: return ("MAD_88E114X ");
+        case MAD_88E1149: return ("MAD_88E1149 ");
+        case MAD_88E1149R: return ("MAD_88E1149R ");
+        case MAD_SWG65G : return ("MAD_SWG65G ");
+        case MAD_88E1181: return ("MAD_88E1181 ");
+        case MAD_88E3016: return ("MAD_88E3015/MAD_88E3016/MAD_88E3018/MAD_88E3019 ");
+/*        case MAD_88E3019: return ("MAD_88E3019 "); */
+        case MAD_88E1121: return ("MAD_88E1121/MAD_88E1121R ");
+        case MAD_88E3082: return ("MAD_88E3082/MAD_88E3083 ");
+        case MAD_88E1240: return ("MAD_88E1240 ");
+        case MAD_88E1340S: return ("MAD_88E1340S ");
+        case MAD_88E1340: return ("MAD_88E1340 ");
+        case MAD_88E1340M: return ("MAD_88E1340M ");
+        case MAD_88E1119R: return ("MAD_88E1119R ");
+        case MAD_88E1310:  return ("MAD_88E1310 ");
+        case MAD_MELODY:  return ("MAD_MELODY_PHY ");
+        default : return (" No-name ");
+    }
+} ;
+
+
+static MAD_STATUS madStart(GT_QD_DEV* qd_dev,  int smiPair)
+{
+    MAD_STATUS status = MAD_FAIL;
+    MAD_DEV* dev = (MAD_DEV*)&(qd_dev->mad_dev);
+    MAD_SYS_CONFIG   cfg;
+
+
+    cfg.BSPFunctions.readMii   = (FMAD_READ_MII )madSMIRead;
+    cfg.BSPFunctions.writeMii  = (FMAD_WRITE_MII )madSMIWrite;
+    cfg.BSPFunctions.semCreate = NULL;
+    cfg.BSPFunctions.semDelete = NULL;
+    cfg.BSPFunctions.semTake   = NULL;
+    cfg.BSPFunctions.semGive   = NULL;
+
+    dev->appData = (void *)qd_dev;
+    cfg.smiBaseAddr = 0;  /* Set SMI Address */
+
+    if((status=mdLoadDriver(&cfg, dev)) != MAD_OK)
+    {
+        return status;
+    }
+
+    DBG_INFO(("Device Name   : %s\n", madGetDeviceName(dev->deviceId)));
+    DBG_INFO(("Device ID     : 0x%x\n",dev->deviceId));
+    DBG_INFO(("Revision      : 0x%x\n",dev->revision));
+    DBG_INFO(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
+    DBG_INFO(("No of Ports   : %d\n",dev->numOfPorts));
+    DBG_INFO(("QD dev        : %x\n",dev->appData));
+
+    DBG_INFO(("MAD has been started.\n"));
+
+#ifdef KERNEL_DBG
+#else
+    DBG_INFO(("Device Name   : %s\n", madGetDeviceName(dev->deviceId)));
+    DBG_INFO(("Device ID     : 0x%x\n",dev->deviceId));
+    DBG_INFO(("Revision      : 0x%x\n",dev->revision));
+    DBG_INFO(("Base Reg Addr : 0x%x\n",dev->baseRegAddr));
+    DBG_INFO(("No of Ports   : %d\n",dev->numOfPorts));
+    DBG_INFO(("QD dev        : %x\n",dev->appData));
+
+    DBG_INFO(("MAD has been started.\n"));
+#endif
+	qd_dev->use_mad = GT_TRUE;
+    return MAD_OK;
+}
+
+/*
+static void madClose(MAD_DEV* dev) 
+{
+    if (dev->devEnabled)
+        mdUnloadDriver(dev);
+}
+*/
+
+ GT_STATUS qd_madInit(GT_QD_DEV    *dev)
+{
+  MAD_STATUS    status;
+
+  status = madStart(dev, 0);
+  if (MAD_OK != status)
+  {
+        DBG_INFO(("sMAD Initialization Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+  }
+
+  return GT_OK;
+}
+
+#endif /* GT_USE_MAD */
 
 /*******************************************************************************
 * qdLoadDriver
@@ -44,17 +191,17 @@ static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions);
 *       GT_BAD_PARAM        - on bad parameters
 *
 * COMMENTS:
-* 	qdUnloadDriver is also provided to do driver cleanup.
+*     qdUnloadDriver is also provided to do driver cleanup.
 *
 *******************************************************************************/
 GT_STATUS qdLoadDriver
 (
     IN  GT_SYS_CONFIG   *cfg,
-    OUT GT_QD_DEV	*dev
+    OUT GT_QD_DEV    *dev
 )
 {
     GT_STATUS   retVal;
-	GT_LPORT	port;
+    GT_LPORT    port;
 
     DBG_INFO(("qdLoadDriver Called.\n"));
 
@@ -79,22 +226,43 @@ GT_STATUS qdLoadDriver
         return GT_ALREADY_EXIST;
     }
 
+#ifdef GT_PORT_MAP_IN_DEV
+    /* Modified to add port mapping functions into device ssystem configuration. */
+
+    if (dev->lport2port == NULL) {
+      dev->lport2port = lport2port;
+    }
+
+    if (dev->port2lport == NULL) {
+      dev->port2lport = port2lport;
+    }
+
+    if (dev->lportvec2portvec == NULL) {
+      dev->lportvec2portvec = lportvec2portvec;
+    }
+
+    if (dev->portvec2lportvec == NULL) {
+      dev->portvec2lportvec = portvec2lportvec;
+    }
+#endif
+  
     if(gtRegister(dev,&(cfg->BSPFunctions)) != GT_TRUE)
     {
        DBG_INFO(("gtRegister Failed.\n"));
        return GT_FAIL;
     }
-	dev->accessMode = (GT_U8)cfg->mode.scanMode;
-	if (dev->accessMode == SMI_MULTI_ADDR_MODE)
-	{
-		dev->baseRegAddr = 0;
-		dev->phyAddr = (GT_U8)cfg->mode.baseAddr;
-	}
-	else
-	{
-		dev->baseRegAddr = (GT_U8)cfg->mode.baseAddr;
-		dev->phyAddr = 0;
-	}
+    dev->accessMode = (GT_U8)cfg->mode.scanMode;
+    if (dev->accessMode == SMI_MULTI_ADDR_MODE)
+    {
+        dev->baseRegAddr = 0;
+        dev->phyAddr = (GT_U8)cfg->mode.baseAddr;
+    }
+    else
+    {
+        dev->baseRegAddr = (GT_U8)cfg->mode.baseAddr;
+        dev->phyAddr = 0;
+    }
+
 
     /* Initialize the driver    */
     retVal = driverConfig(dev);
@@ -109,435 +277,533 @@ GT_STATUS qdLoadDriver
     dev->maxPhyNum = 5;
     dev->devGroup = 0;
     dev->devStorage = 0;
-
     /* Assign Device Name */
+    dev->devName = 0;
+    dev->devName1 = 0;
+
+    if((dev->deviceId&0xfff8)==GT_88EC000) /* device id 0xc00 - 0xc07 are GT_88EC0XX */
+      dev->deviceId=GT_88EC000;
+
     switch(dev->deviceId)
     {
-		case GT_88E6021:
-				dev->numOfPorts = 3;
-				dev->maxPorts = 3;
-				dev->maxPhyNum = 2;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6021;
-				break;
-
-		case GT_88E6051:
-				dev->numOfPorts = 5;
-				dev->maxPorts = 5;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6051;
-				break;
-
-		case GT_88E6052:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6052;
-				break;
-
-		case GT_88E6060:
-				if((dev->cpuPortNum != 4)&&(dev->cpuPortNum != 5))
-				{
-					return GT_FAIL;
-				}
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6060;
-				break;
-
-		case GT_88E6031:
-				dev->numOfPorts = 3;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 3;
-				dev->validPortVec = 0x31;	/* port 0, 4, and 5 */
-				dev->validPhyVec = 0x31;	/* port 0, 4, and 5 */
-				dev->devName = DEV_88E6061;
-				break;
-
-		case GT_88E6061:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 6;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6061;
-				break;
-
-		case GT_88E6035:
-				dev->numOfPorts = 3;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 3;
-				dev->validPortVec = 0x31;	/* port 0, 4, and 5 */
-				dev->validPhyVec = 0x31;	/* port 0, 4, and 5 */
-				dev->devName = DEV_88E6065;
-				break;
-
-		case GT_88E6055:
-				dev->numOfPorts = 5;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = 0x2F;	/* port 0,1,2,3, and 5 */
-				dev->validPhyVec = 0x2F;	/* port 0,1,2,3, and 5 */
-				dev->devName = DEV_88E6065;
-				break;
-
-		case GT_88E6065:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 6;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6065;
-				break;
-
-		case GT_88E6063:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6063;
-				break;
-
-		case GT_FH_VPN:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_FH_VPN;
-				break;
-
-		case GT_FF_EG:
-				if(dev->cpuPortNum != 5)
-				{
-					return GT_FAIL;
-				}
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_FF_EG;
-				break;
-
-		case GT_FF_HG:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 5;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_FF_HG;
-				break;
-
-		case GT_88E6083:
-				dev->numOfPorts = 10;
-				dev->maxPorts = 10;
-				dev->maxPhyNum = 8;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6083;
-				break;
-
-		case GT_88E6153:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 6;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6183;
-				break;
-
-		case GT_88E6181:
-				dev->numOfPorts = 8;
-				dev->maxPorts = 8;
-				dev->maxPhyNum = 8;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6181;
-				break;
-
-		case GT_88E6183:
-				dev->numOfPorts = 10;
-				dev->maxPorts = 10;
-				dev->maxPhyNum = 10;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6183;
-				break;
-
-		case GT_88E6093:
-				dev->numOfPorts = 11;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6093;
-				break;
-
-		case GT_88E6092:
-				dev->numOfPorts = 11;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6092;
-				break;
-
-		case GT_88E6095:
-				dev->numOfPorts = 11;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6095;
-				break;
-
-		case GT_88E6045:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = 0x60F;
-				dev->validPhyVec = 0x60F;
-				dev->devName = DEV_88E6095;
-				break;
-
-		case GT_88E6097:
-				dev->numOfPorts = 11;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6097;
-				break;
-
-		case GT_88E6096:
-				dev->numOfPorts = 11;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6096;
-				break;
-
-		case GT_88E6047:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = 0x60F;
-				dev->validPhyVec = 0x60F;
-				dev->devName = DEV_88E6097;
-				break;
-
-		case GT_88E6046:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = 0x60F;
-				dev->validPhyVec = 0x60F;
-				dev->devName = DEV_88E6096;
-				break;
-
-		case GT_88E6085:
-				dev->numOfPorts = 10;
-				dev->maxPorts = 11;
-				dev->maxPhyNum = 11;
-				dev->validPortVec = 0x6FF;
-				dev->validPhyVec = 0x6FF;
-				dev->devName = DEV_88E6096;
-				break;
-
-		case GT_88E6152:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 6;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6182;
-				break;
-
-		case GT_88E6155:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 6;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6185;
-				break;
-
-		case GT_88E6182:
-				dev->numOfPorts = 10;
-				dev->maxPorts = 10;
-				dev->maxPhyNum = 10;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6182;
-				break;
-
-		case GT_88E6185:
-				dev->numOfPorts = 10;
-				dev->maxPorts = 10;
-				dev->maxPhyNum = 10;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->devName = DEV_88E6185;
-				break;
-
-		case GT_88E6121:
-				dev->numOfPorts = 3;
-				dev->maxPorts = 8;
-				dev->maxPhyNum = 3;
-				dev->validPortVec = 0xE;	/* port 1, 2, and 3 */
-				dev->validPhyVec = 0xE;		/* port 1, 2, and 3 */
-				dev->devName = DEV_88E6108;
-				break;
-
-		case GT_88E6122:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 8;
-				dev->maxPhyNum = 16;
-				dev->validPortVec = 0x7E;	/* port 1 ~ 6 */
-				dev->validPhyVec = 0xF07E;	/* port 1 ~ 6, 12 ~ 15 (serdes) */
-				dev->validSerdesVec = 0xF000;
-				dev->devName = DEV_88E6108;
-				break;
-
-		case GT_88E6131:
-		case GT_88E6108:
-				dev->numOfPorts = 8;
-				dev->maxPorts = 8;
-				dev->maxPhyNum = 16;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
-				dev->validSerdesVec = 0xF000;
-				dev->devName = DEV_88E6108;
-				break;
-
-		case GT_88E6123:
-				dev->numOfPorts = 3;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 14;
-				dev->validPortVec = 0x23;
-				dev->validPhyVec = 0x303F;
-				dev->validSerdesVec = 0x3000;
-				dev->devName = DEV_88E6161;
-				break;
-
-		case GT_88E6140:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 14;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x303F;
-				dev->validSerdesVec = 0x3000;
-				dev->devName = DEV_88E6165;
-				break;
-
-		case GT_88E6161:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 14;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x303F;
-				dev->validSerdesVec = 0x3000;
-				dev->devName = DEV_88E6161;
-				break;
-
-		case GT_88E6165:
-				dev->numOfPorts = 6;
-				dev->maxPorts = 6;
-				dev->maxPhyNum = 14;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x303F;
-				dev->validSerdesVec = 0x3000;
-				dev->devName = DEV_88E6165;
-				break;
+        case GT_88E6021:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 3;
+                dev->maxPhyNum = 2;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6021;
+                break;
+
+        case GT_88E6051:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 5;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6051;
+                break;
+
+        case GT_88E6052:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6052;
+                break;
+
+        case GT_88E6060:
+                if((dev->cpuPortNum != 4)&&(dev->cpuPortNum != 5))
+                {
+                    return GT_FAIL;
+                }
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6060;
+                break;
+
+        case GT_88E6031:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0x31;    /* port 0, 4, and 5 */
+                dev->validPhyVec = 0x31;    /* port 0, 4, and 5 */
+                dev->devName = DEV_88E6061;
+                break;
+
+        case GT_88E6061:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6061;
+                break;
+
+        case GT_88E6035:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0x31;    /* port 0, 4, and 5 */
+                dev->validPhyVec = 0x31;    /* port 0, 4, and 5 */
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6055:
+                dev->numOfPorts = 5;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = 0x2F;    /* port 0,1,2,3, and 5 */
+                dev->validPhyVec = 0x2F;    /* port 0,1,2,3, and 5 */
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6065:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6065;
+                break;
+
+        case GT_88E6063:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6063;
+                break;
+
+        case GT_FH_VPN:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FH_VPN;
+                break;
+
+        case GT_FF_EG:
+                if(dev->cpuPortNum != 5)
+                {
+                    return GT_FAIL;
+                }
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FF_EG;
+                break;
+
+        case GT_FF_HG:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 5;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_FF_HG;
+                break;
+
+        case GT_88E6083:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 8;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6083;
+                break;
+
+        case GT_88E6153:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6183;
+                break;
+
+        case GT_88E6181:
+                dev->numOfPorts = 8;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 8;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6181;
+                break;
+
+        case GT_88E6183:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6183;
+                break;
+
+        case GT_88E6093:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6093;
+                break;
+
+        case GT_88E6092:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6092;
+                break;
+
+        case GT_88E6095:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6095;
+                break;
+
+        case GT_88E6045:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6095;
+                break;
+
+        case GT_88E6097:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6097;
+                break;
+
+        case GT_88E6096:
+                dev->numOfPorts = 11;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6047:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6097;
+                break;
+
+        case GT_88E6046:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x60F;
+                dev->validPhyVec = 0x60F;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6085:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 11;
+                dev->maxPhyNum = 11;
+                dev->validPortVec = 0x6FF;
+                dev->validPhyVec = 0x6FF;
+                dev->devName = DEV_88E6096;
+                break;
+
+        case GT_88E6152:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = 0x28F;
+                dev->validPhyVec = 0x28F;
+                dev->devName = DEV_88E6182;
+                break;
+
+        case GT_88E6155:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 6;
+                dev->validPortVec = 0x28F;
+                dev->validPhyVec = 0x28F;
+                dev->devName = DEV_88E6185;
+                break;
+
+        case GT_88E6182:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6182;
+                break;
+
+        case GT_88E6185:
+                dev->numOfPorts = 10;
+                dev->maxPorts = 10;
+                dev->maxPhyNum = 10;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->devName = DEV_88E6185;
+                break;
+
+        case GT_88E6121:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 3;
+                dev->validPortVec = 0xE;    /* port 1, 2, and 3 */
+                dev->validPhyVec = 0xE;        /* port 1, 2, and 3 */
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6122:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 16;
+                dev->validPortVec = 0x7E;    /* port 1 ~ 6 */
+                dev->validPhyVec = 0xF07E;    /* port 1 ~ 6, 12 ~ 15 (serdes) */
+                dev->validSerdesVec = 0xF000;
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6131:
+        case GT_88E6108:
+                dev->numOfPorts = 8;
+                dev->maxPorts = 8;
+                dev->maxPhyNum = 16;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = (1 << dev->maxPhyNum) - 1;
+                dev->validSerdesVec = 0xF000;
+                dev->devName = DEV_88E6108;
+                break;
+
+        case GT_88E6123:
+                dev->numOfPorts = 3;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = 0x23;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6161;
+                break;
+
+        case GT_88E6140:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6165;
+                break;
+
+        case GT_88E6161:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6161;
+                break;
+
+        case GT_88E6165:
+                dev->numOfPorts = 6;
+                dev->maxPorts = 6;
+                dev->maxPhyNum = 14;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x303F;
+                dev->validSerdesVec = 0x3000;
+                dev->devName = DEV_88E6165;
+                break;
 
 		case GT_KW2_INT :
 				dev->deviceId = GT_88E6351;
 				/* fall through */
-		case GT_88E6351:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x7F;
-				dev->devName = DEV_88E6351;
-				break;
-
-		case GT_88E6175:
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x7F;
-				dev->devName = DEV_88E6175;
-				break;
-
-		case GT_88E6125 :
-				dev->numOfPorts = 4;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPortVec &= ~(0x7);
-				dev->validPhyVec = 0x78;
-				dev->devName = DEV_88E6171;
-				break;
-
-		case GT_88E6171 :
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x7F;
-				dev->devName = DEV_88E6171;
-				break;
-
-		case GT_88E6321 :
-				dev->numOfPorts = 4;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPortVec &= ~(0x7);
-				dev->validPhyVec = 0x78;
-				dev->devName = DEV_88E6371;
-				break;
-
-		case GT_88E6350 :
-				dev->numOfPorts = 7;
-				dev->maxPorts = 7;
-				dev->maxPhyNum = 7;
-				dev->validPortVec = (1 << dev->numOfPorts) - 1;
-				dev->validPhyVec = 0x7F;
-				dev->devName = DEV_88E6371;
-				break;
-
-		default:
-				DBG_INFO(("Unknown Device. Initialization failed\n"));
-				return GT_FAIL;
+        case GT_88E6351:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6351;
+                break;
+
+        case GT_88E6175:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6175; /* test device group 1 */
+                break;
+
+        case GT_88E6125 :
+                dev->numOfPorts = 4;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPortVec &= ~(0x7);
+                dev->validPhyVec = 0x78;
+                dev->devName = DEV_88E6171;
+                break;
+
+        case GT_88E6171 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6171;
+                break;
+
+        case GT_88E6321 :
+                dev->numOfPorts = 4;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPortVec &= ~(0x7);
+                dev->validPhyVec = 0x78;
+                dev->devName = DEV_88E6371;
+                break;
+
+        case GT_88E6350 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6371;
+                break;
+
+        case GT_88EC000 :
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88EC000;
+                break;
+        case GT_88E3020:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E3020;
+                break;
+        case GT_88E6020:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6020;
+                break;
+        case GT_88E6070:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6070;
+                break;
+        case GT_88E6071:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6071;
+                break;
+        case GT_88E6220:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6220;
+                break;
+        case GT_88E6250:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName1 = DEV_88E6250;
+                break;
+        case GT_88E6172:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6172;
+                break;
+
+        case GT_88E6176:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6176;
+                break;
+
+        case GT_88E6240:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6240;
+                break;
+
+        case GT_88E6352:
+                dev->numOfPorts = 7;
+                dev->maxPorts = 7;
+                dev->maxPhyNum = 7;
+                dev->validPortVec = (1 << dev->numOfPorts) - 1;
+                dev->validPhyVec = 0x7F;
+                dev->devName = DEV_88E6352;
+                break;
+
+
+        default:
+                DBG_INFO(("Unknown Device. Initialization failed\n"));
+                return GT_FAIL;
     }
 
     dev->cpuPortNum = GT_PORT_2_LPORT(cfg->cpuPortNum);
 
     if(dev->cpuPortNum == GT_INVALID_PORT)
-	{
-    	if(GT_LPORT_2_PORT((GT_LPORT)cfg->cpuPortNum) != GT_INVALID_PORT)
-		{
-		    dev->cpuPortNum = cfg->cpuPortNum;
-		}
-		else
-		{
-			return GT_BAD_CPU_PORT;
-		}
-	}
+    {
+        if(GT_LPORT_2_PORT((GT_LPORT)cfg->cpuPortNum) != GT_INVALID_PORT)
+        {
+            dev->cpuPortNum = cfg->cpuPortNum;
+        }
+        else
+        {
+            return GT_BAD_CPU_PORT;
+        }
+    }
 
     /* Initialize the MultiAddress Register Access semaphore.    */
     if((dev->multiAddrSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
@@ -559,7 +825,7 @@ GT_STATUS qdLoadDriver
     if((dev->vtuRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
         DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
+        qdUnloadDriver(dev);
         return GT_FAIL;
     }
 
@@ -567,7 +833,7 @@ GT_STATUS qdLoadDriver
     if((dev->statsRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
         DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
+        qdUnloadDriver(dev);
         return GT_FAIL;
     }
 
@@ -575,7 +841,7 @@ GT_STATUS qdLoadDriver
     if((dev->pirlRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
         DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
+        qdUnloadDriver(dev);
         return GT_FAIL;
     }
 
@@ -583,24 +849,24 @@ GT_STATUS qdLoadDriver
     if((dev->ptpRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
         DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
+        qdUnloadDriver(dev);
         return GT_FAIL;
     }
 
     /* Initialize the Table semaphore.    */
     if((dev->tblRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
-		DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
-		return GT_FAIL;
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
     }
 
     /* Initialize the EEPROM Configuration semaphore.    */
     if((dev->eepromRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
     {
-		DBG_INFO(("semCreate Failed.\n"));
-		qdUnloadDriver(dev);
-		return GT_FAIL;
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
     }
 
     /* Initialize the PHY Device Register Access semaphore.    */
@@ -611,113 +877,126 @@ GT_STATUS qdLoadDriver
         return GT_FAIL;
     }
 
+    /* Initialize the Remote management Register Access semaphore.    */
+    if((dev->hwAccessRegsSem = gtSemCreate(dev,GT_SEM_FULL)) == 0)
+    {
+        DBG_INFO(("semCreate Failed.\n"));
+        qdUnloadDriver(dev);
+        return GT_FAIL;
+    }
+
     /* Initialize the ports states to forwarding mode. */
     if(cfg->initPorts == GT_TRUE)
     {
-		for (port=0; port<dev->numOfPorts; port++)
-		{
-			if((retVal = gstpSetPortState(dev,port,GT_PORT_FORWARDING)) != GT_OK)
-   			{
-	    	    DBG_INFO(("Failed.\n"));
-				qdUnloadDriver(dev);
-   		    	return retVal;
-	    	}
-		}
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            if((retVal = gstpSetPortState(dev,port,GT_PORT_FORWARDING)) != GT_OK)
+               {
+                DBG_INFO(("Failed.\n"));
+                qdUnloadDriver(dev);
+                   return retVal;
+            }
+        }
     }
 
+    dev->use_mad = GT_FALSE;
+#ifdef GT_USE_MAD
+    qd_madInit(dev);
+#endif
+
     if(cfg->skipInitSetup == GT_SKIP_INIT_SETUP)
-	{
-	    dev->devEnabled = 1;
-    	dev->devNum = cfg->devNum;
-
-	    DBG_INFO(("OK.\n"));
-    	return GT_OK;
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_ENHANCED_CPU_PORT))
-	{
-		if((retVal = gsysSetRsvd2CpuEnables(dev,0)) != GT_OK)
-		{
-	        DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
-			qdUnloadDriver(dev);
-			return retVal;
-		}
-
-		if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
-		{
-	        DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
-			qdUnloadDriver(dev);
-			return retVal;
-		}
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
-	{
-		for (port=0; port<dev->numOfPorts; port++)
-		{
-			retVal = gprtSetCPUPort(dev,port,dev->cpuPortNum);
-		    if(retVal != GT_OK)
-    		{
-	    	    DBG_INFO(("Failed.\n"));
-				qdUnloadDriver(dev);
-	   	    	return retVal;
-		    }
-		}
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
-	{
-		retVal = gsysSetCPUPort(dev,dev->cpuPortNum);
-	    if(retVal != GT_OK)
-   		{
-    	    DBG_INFO(("Failed.\n"));
-			qdUnloadDriver(dev);
-   	    	return retVal;
-	    }
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
-	{
-		retVal = gsysSetCPUDest(dev,dev->cpuPortNum);
-	    if(retVal != GT_OK)
-   		{
-    	    DBG_INFO(("Failed.\n"));
-			qdUnloadDriver(dev);
-   	    	return retVal;
-	    }
-	}
-
-	if(IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
-	{
-		if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
-		{
-	        DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
-			qdUnloadDriver(dev);
-			return retVal;
-		}
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
-	{
-		retVal = gpirlInitialize(dev);
-	    if(retVal != GT_OK)
-   		{
-    	    DBG_INFO(("Failed.\n"));
-			qdUnloadDriver(dev);
-   	    	return retVal;
-	    }
-	}
-
-	if (IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
-	{
-		retVal = gpirl2Initialize(dev);
-	    if(retVal != GT_OK)
-   		{
-    	    DBG_INFO(("Failed.\n"));
-			qdUnloadDriver(dev);
-   	    	return retVal;
-	    }
-	}
+    {
+        dev->devEnabled = 1;
+        dev->devNum = cfg->devNum;
+
+        DBG_INFO(("OK.\n"));
+        return GT_OK;
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_ENHANCED_CPU_PORT))
+    {
+        if((retVal = gsysSetRsvd2CpuEnables(dev,0)) != GT_OK)
+        {
+            DBG_INFO(("gsysGetRsvd2CpuEnables failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+
+        if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_CPU_DEST_PER_PORT))
+    {
+        for (port=0; port<dev->numOfPorts; port++)
+        {
+            retVal = gprtSetCPUPort(dev,port,dev->cpuPortNum);
+            if(retVal != GT_OK)
+            {
+                DBG_INFO(("Failed.\n"));
+                qdUnloadDriver(dev);
+                   return retVal;
+            }
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    {
+        retVal = gsysSetCPUPort(dev,dev->cpuPortNum);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        retVal = gsysSetCPUDest(dev,dev->cpuPortNum);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if(IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        if((retVal = gsysSetRsvd2Cpu(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("gsysSetRsvd2Cpu failed.\n"));
+            qdUnloadDriver(dev);
+            return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PIRL_RESOURCE))
+    {
+        retVal = gpirlInitialize(dev);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
+
+    if (IS_IN_DEV_GROUP(dev,DEV_PIRL2_RESOURCE))
+    {
+        retVal = gpirl2Initialize(dev);
+        if(retVal != GT_OK)
+           {
+            DBG_INFO(("Failed.\n"));
+            qdUnloadDriver(dev);
+               return retVal;
+        }
+    }
 
     dev->devEnabled = 1;
     dev->devNum = cfg->devNum;
@@ -845,9 +1124,15 @@ GT_STATUS qdUnloadDriver
         DBG_INFO(("Failed.\n"));
         return GT_FAIL;
     }
+    /* Delete the Remote management Register Access semaphore.    */
+    if(gtSemDelete(dev,dev->hwAccessRegsSem) != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_FAIL;
+    }
 
-	gtMemSet(dev,0,sizeof(GT_QD_DEV));
-	return GT_OK;
+    gtMemSet(dev,0,sizeof(GT_QD_DEV));
+    return GT_OK;
 }
 
 
@@ -856,25 +1141,25 @@ GT_STATUS qdUnloadDriver
 *
 * DESCRIPTION:
 *       BSP should register the following functions:
-*		1) MII Read - (Input, must provide)
-*			allows QuarterDeck driver to read QuarterDeck device registers.
-*		2) MII Write - (Input, must provice)
-*			allows QuarterDeck driver to write QuarterDeck device registers.
-*		3) Semaphore Create - (Input, optional)
-*			OS specific Semaphore Creat function.
-*		4) Semaphore Delete - (Input, optional)
-*			OS specific Semaphore Delete function.
-*		5) Semaphore Take - (Input, optional)
-*			OS specific Semaphore Take function.
-*		6) Semaphore Give - (Input, optional)
-*			OS specific Semaphore Give function.
-*		Notes: 3) ~ 6) should be provided all or should not be provided at all.
+*        1) MII Read - (Input, must provide)
+*            allows QuarterDeck driver to read QuarterDeck device registers.
+*        2) MII Write - (Input, must provice)
+*            allows QuarterDeck driver to write QuarterDeck device registers.
+*        3) Semaphore Create - (Input, optional)
+*            OS specific Semaphore Creat function.
+*        4) Semaphore Delete - (Input, optional)
+*            OS specific Semaphore Delete function.
+*        5) Semaphore Take - (Input, optional)
+*            OS specific Semaphore Take function.
+*        6) Semaphore Give - (Input, optional)
+*            OS specific Semaphore Give function.
+*        Notes: 3) ~ 6) should be provided all or should not be provided at all.
 *
 * INPUTS:
-*		pBSPFunctions - pointer to the structure for above functions.
+*        pBSPFunctions - pointer to the structure for above functions.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
 *       GT_TRUE, if input is valid. GT_FALSE, otherwise.
@@ -885,15 +1170,68 @@ GT_STATUS qdUnloadDriver
 *******************************************************************************/
 static GT_BOOL gtRegister(GT_QD_DEV *dev, BSP_FUNCTIONS* pBSPFunctions)
 {
-	dev->fgtReadMii =  pBSPFunctions->readMii;
-	dev->fgtWriteMii = pBSPFunctions->writeMii;
-	
-	dev->semCreate = pBSPFunctions->semCreate;
-	dev->semDelete = pBSPFunctions->semDelete;
-	dev->semTake   = pBSPFunctions->semTake  ;
-	dev->semGive   = pBSPFunctions->semGive  ;
+    dev->fgtReadMii =  pBSPFunctions->readMii;
+    dev->fgtWriteMii = pBSPFunctions->writeMii;
+#ifdef GT_RMGMT_ACCESS
+    dev->fgtHwAccessMod =  pBSPFunctions->hwAccessMod;
+    dev->fgtHwAccess = pBSPFunctions->hwAccess;
+#endif
 	
-	return GT_TRUE;
+    dev->semCreate = pBSPFunctions->semCreate;
+    dev->semDelete = pBSPFunctions->semDelete;
+    dev->semTake   = pBSPFunctions->semTake  ;
+    dev->semGive   = pBSPFunctions->semGive  ;
+    
+    return GT_TRUE;
 }
 
+static GT_U8 qd32_2_8[256] = {
+0,1,2,3,4,5,6,7,8,9,
+10,11,12,13,14,15,16,17,18,19,
+20,21,22,23,24,25,26,27,28,29,
+30,31,32,33,34,35,36,37,38,39,
+40,41,42,43,44,45,46,47,48,49,
+50,51,52,53,54,55,56,57,58,59,
+60,61,62,63,64,65,66,67,68,69,
+70,71,72,73,74,75,76,77,78,79,
+80,81,82,83,84,85,86,87,88,89,
+90,91,92,93,94,95,96,97,98,99,
+100,101,102,103,104,105,106,107,108,109,
+110,111,112,113,114,115,116,117,118,119,
+120,121,122,123,124,125,126,127,128,129,
+130,131,132,133,134,135,136,137,138,139,
+140,141,142,143,144,145,146,147,148,149,
+150,151,152,153,154,155,156,157,158,159,
+160,161,162,163,164,165,166,167,168,169,
+170,171,172,173,174,175,176,177,178,179,
+180,181,182,183,184,185,186,187,188,189,
+190,191,192,193,194,195,196,197,198,199,
+200,201,202,203,204,205,206,207,208,209,
+210,211,212,213,214,215,216,217,218,219,
+220,221,222,223,224,225,226,227,228,229,
+230,231,232,233,234,235,236,237,238,239,
+240,241,242,243,244,245,246,247,248,249,
+250,251,252,253,254,255};
+
+
+
+GT_U8 qdLong2Char(GT_U32 data)
+{
+	return qd32_2_8[data&0xff];
+}
+
+GT_U8 qdShort2Char(GT_U16 data)
+{
+	GT_U32 dataL = data;
+	return qd32_2_8[dataL&0xff];
+}
+
+GT_U16 qdLong2Short(GT_U32 data)
+{
+  GT_U32 data1= 1;
+  if( *((GT_U16 *)&data1) )
+    return *((GT_U16 *)&data);
+  else
+    return *((GT_U16 *)&data + 1);
+} 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c
old mode 100644
new mode 100755
index 5ff8c21..7df1c0e
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysCtrl.c
@@ -17,6 +17,43 @@
 #include <gtDrvSwRegs.h>
 #include <gtSem.h>
 
+static GT_STATUS writeSwitchMacWolReg
+(
+    IN GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
+    IN GT_ETHERADDR *mac
+);
+static GT_STATUS readSwitchMacWolReg
+(
+    IN  GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
+    OUT GT_ETHERADDR *mac
+);
+static GT_STATUS writeDiffMACWoL
+(
+    IN GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
+    IN GT_U16       diffAddr
+);
+static GT_STATUS readDiffMACWoL
+(
+    IN  GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
+    OUT GT_U16        *diffAddr
+);
+static GT_STATUS writeSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+	IN GT_U8        data
+);
+static GT_STATUS readSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+	OUT GT_U8       *data
+);
+
 static GT_STATUS writeSwitchMacReg
 (
     IN GT_QD_DEV    *dev,
@@ -32,16 +69,14 @@ static GT_STATUS readSwitchMacReg
 static GT_STATUS writeDiffMAC
 (
     IN GT_QD_DEV    *dev,
-    IN GT_U16		diffAddr
+    IN GT_U16        diffAddr
 );
 
 static GT_STATUS readDiffMAC
 (
-    IN  GT_QD_DEV	*dev,
-    OUT GT_U16		*diffAddr
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16        *diffAddr
 );
-
-
 /*******************************************************************************
 * gsysSwReset
 *
@@ -69,21 +104,26 @@ GT_STATUS gsysSwReset
     IN  GT_QD_DEV *dev
 )
 {
+#ifndef GT_RMGMT_ACCESS
     GT_U16          data;           /* Used to poll the SWReset bit */
+#endif
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U8			regOffset;
+    GT_U8            regOffset;
 
     DBG_INFO(("gsysSwReset Called.\n"));
 
     /* Set the Software reset bit.                  */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		regOffset = QD_REG_GLOBAL_CONTROL;
-	}
-	else
-	{
-		regOffset = QD_REG_ATU_CONTROL;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        regOffset = QD_REG_GLOBAL_CONTROL;
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        regOffset = QD_REG_GLOBAL_CONTROL;
+      else
+        regOffset = QD_REG_ATU_CONTROL;
+    }
 
     retVal = hwSetGlobalRegField(dev,regOffset,15,1,1);
     if(retVal != GT_OK)
@@ -92,11 +132,29 @@ GT_STATUS gsysSwReset
         return retVal;
     }
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = regOffset;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
     /* Make sure the reset operation is completed.  */
     data = 1;
     while(data != 0)
     {
-   	    retVal = hwGetGlobalRegField(dev,regOffset,15,1,&data);
+           retVal = hwGetGlobalRegField(dev,regOffset,15,1,&data);
 
         if(retVal != GT_OK)
         {
@@ -104,7 +162,8 @@ GT_STATUS gsysSwReset
             return retVal;
         }
     }
-	
+#endif
+    
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -113,128 +172,128 @@ GT_STATUS gsysSwReset
 * gsysSetPPUEn
 *
 * DESCRIPTION:
-*		This routine enables/disables Phy Polling Unit.
+*        This routine enables/disables Phy Polling Unit.
 *
 * INPUTS:
-*		en - GT_TRUE to enable PPU, GT_FALSE otherwise.
+*        en - GT_TRUE to enable PPU, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysSetPPUEn
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* Data to be set into the      */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
                                 /* register.                    */
-	DBG_INFO(("gsysSetPPUEn Called.\n"));
+    DBG_INFO(("gsysSetPPUEn Called.\n"));
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	BOOL_2_BIT(en,data);
+    BOOL_2_BIT(en,data);
 
-	/* Set the PPUEn bit.                */
-	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
-	
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    /* Set the PPUEn bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+    
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gsysGetPPUEn
 *
 * DESCRIPTION:
-*		This routine get the PPU state.
+*        This routine get the PPU state.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if PPU is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetPPUEn
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* The register's read data.    */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
 
-	DBG_INFO(("gsysGetPPUEn Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    DBG_INFO(("gsysGetPPUEn Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(en == NULL)
-	{
-		DBG_INFO(("Failed.\n"));
-		return GT_BAD_PARAM;
-	}
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
 
-	/* Get the GetPPUEn bit.                */
-	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Get the GetPPUEn bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	BIT_2_BOOL(data,*en);
-	DBG_INFO(("OK.\n"));
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -372,10 +431,10 @@ GT_STATUS gsysSetSchedulingMode
                                     /* register.                    */
     DBG_INFO(("gsysSetSchedulingMode Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
+    if (IS_IN_DEV_GROUP(dev,DEV_PORT_MIXED_SCHEDULE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(mode,data);
@@ -428,11 +487,10 @@ GT_STATUS gsysGetSchedulingMode
     GT_U16          data;           /* The register's read data.    */
 
     DBG_INFO(("gsysGetSchedulingMode Called.\n"));
-
-	if (IS_IN_DEV_GROUP(dev, DEV_PORT_MIXED_SCHEDULE))
+    if (IS_IN_DEV_GROUP(dev, DEV_PORT_MIXED_SCHEDULE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     if(mode == NULL)
@@ -463,7 +521,7 @@ GT_STATUS gsysGetSchedulingMode
 *
 * INPUTS:
 *       mode - GT_TRUE max size 1522, 
-*			   GT_FALSE max size 1535, 1632, or 2048.
+*               GT_FALSE max size 1535, 1632, or 2048.
 *
 * OUTPUTS:
 *       None.
@@ -471,10 +529,10 @@ GT_STATUS gsysGetSchedulingMode
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Please refer to the device spec. to get the max frame size.
+*        Please refer to the device spec. to get the max frame size.
 *       88E6095 device supports upto 1632. 
 *       88E6065/88E6061 devices support upto 2048. 
 *
@@ -490,11 +548,11 @@ GT_STATUS gsysSetMaxFrameSize
                                     /* register.                    */
     DBG_INFO(("gsysSetMaxFrameSize Called.\n"));
 
-	if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     BOOL_2_BIT(mode,data);
     data = 1 - data;
@@ -523,16 +581,16 @@ GT_STATUS gsysSetMaxFrameSize
 *
 * OUTPUTS:
 *       mode - GT_TRUE max size 1522, 
-*			   GT_FALSE max size 1535, 1632, or 2048.
+*               GT_FALSE max size 1535, 1632, or 2048.
 *
 * RETURNS:
 *       GT_OK           - on success
 *       GT_BAD_PARAM    - on bad parameter
 *       GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Please refer to the device spec. to get the max frame size.
+*        Please refer to the device spec. to get the max frame size.
 *       88E6095 device supports upto 1632.
 *       88E6065/88E6061 devices support upto 2048. 
 *
@@ -553,11 +611,11 @@ GT_STATUS gsysGetMaxFrameSize
         return GT_BAD_PARAM;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_JUMBO_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
     /* Get the Max Frame Size bit.          */
     retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,10,1,&data);
@@ -653,11 +711,12 @@ GT_STATUS gsysSetWatchDog
                                     /* register.                    */
     DBG_INFO(("gsysSetWatchDog Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH|DEV_WATCHDOG_EVENT))
+    /* Check if Switch supports this feature. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_WATCHDOG_EVENT)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -710,11 +769,11 @@ GT_STATUS gsysGetWatchDog
 
     DBG_INFO(("gsysGetWatchDog Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
+    /* Check if Switch supports this feature. */
+    if (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     if(en == NULL)
@@ -742,9 +801,9 @@ GT_STATUS gsysGetWatchDog
 *
 * DESCRIPTION:
 *       This routine sets the full duplex pause src Mac Address.
-*		MAC address should be an Unicast address.
-*		For different MAC Addresses per port operation, 
-*		use gsysSetPerPortDuplexPauseMac API.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation, 
+*        use gsysSetPerPortDuplexPauseMac API.
 *
 * INPUTS:
 *       mac - The Mac address to be set.
@@ -777,12 +836,44 @@ GT_STATUS gsysSetDuplexPauseMac
         return GT_BAD_PARAM;
     }
 
-	/* if the device has Switch MAC Register, we need the special operation */
-	if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
-    {
-		return writeSwitchMacReg(dev,mac);
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        return writeSwitchMacReg(dev,mac);
+    }
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_MACADDR_01;
+  /* Set the first Mac register with diffAddr bit reset.  */
+      data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
+      regAccess.rw_reg_list[0].data = data;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_MACADDR_23;
+  /* Set the Mac23 address register.   */
+      data = ((*mac).arEther[2] << 8) | (*mac).arEther[3];
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_MACADDR_45;
+  /* Set the Mac45 address register.   */
+      data = ((*mac).arEther[4] << 8) | (*mac).arEther[5];
+      regAccess.rw_reg_list[2].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
     }
-
+#else
     /* Set the first Mac register with diffAddr bit reset.  */
     data = (((*mac).arEther[0] & 0xFE) << 8) | (*mac).arEther[1];
     retVal = hwWriteGlobalReg(dev,QD_REG_MACADDR_01,data);
@@ -809,6 +900,8 @@ GT_STATUS gsysSetDuplexPauseMac
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
+#endif
+
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -819,8 +912,8 @@ GT_STATUS gsysSetDuplexPauseMac
 *
 * DESCRIPTION:
 *       This routine Gets the full duplex pause src Mac Address.
-*		For different MAC Addresses per port operation, 
-*		use gsysGetPerPortDuplexPauseMac API.
+*        For different MAC Addresses per port operation, 
+*        use gsysGetPerPortDuplexPauseMac API.
 *
 * INPUTS:
 *       None.
@@ -844,7 +937,9 @@ GT_STATUS gsysGetDuplexPauseMac
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
+#ifndef GT_RMGMT_ACCESS
     GT_U16          data;           /* Data to read from register.  */
+#endif
 
     DBG_INFO(("gsysGetDuplexPauseMac Called.\n"));
     if(mac == NULL)
@@ -853,12 +948,44 @@ GT_STATUS gsysGetDuplexPauseMac
         return GT_BAD_PARAM;
     }
 
-	/* if the device has Switch MAC Register, we need the special operation */
-	if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
     {
-		return readSwitchMacReg(dev,mac);
+        return readSwitchMacReg(dev,mac);
     }
 
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_MACADDR_01;
+      regAccess.rw_reg_list[0].data = 0;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_MACADDR_23;
+      regAccess.rw_reg_list[1].data = 0;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_MACADDR_45;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      (*mac).arEther[0] = qdLong2Char((regAccess.rw_reg_list[0].data >> 8)) & ~0x01;
+      (*mac).arEther[1] = qdLong2Char(regAccess.rw_reg_list[0].data & 0xFF);
+      (*mac).arEther[2] = qdLong2Char(regAccess.rw_reg_list[1].data >> 8);
+      (*mac).arEther[3] = qdLong2Char(regAccess.rw_reg_list[1].data & 0xFF);
+      (*mac).arEther[4] = qdLong2Char(regAccess.rw_reg_list[2].data >> 8);
+      (*mac).arEther[5] = qdLong2Char(regAccess.rw_reg_list[2].data & 0xFF);
+    }
+#else
     /* Get the Mac01 register.      */
     retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_01,&data);
     if(retVal != GT_OK)
@@ -866,14 +993,8 @@ GT_STATUS gsysGetDuplexPauseMac
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
-#if 0	/* This should be always a unicast. */
-    /* The mac is allwasy a multicast mac   */
-    (*mac).arEther[0] = (data >> 8) | 0x01;
-    (*mac).arEther[1] = data & 0xFF;
-#else
     (*mac).arEther[0] = (data >> 8) & ~0x01;
     (*mac).arEther[1] = data & 0xFF;
-#endif
     /* Get the Mac23 register.      */
     retVal = hwReadGlobalReg(dev,QD_REG_MACADDR_23,&data);
     if(retVal != GT_OK)
@@ -893,6 +1014,8 @@ GT_STATUS gsysGetDuplexPauseMac
     }
     (*mac).arEther[4] = data >> 8;
     (*mac).arEther[5] = data & 0xFF;
+#endif
+
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -934,15 +1057,18 @@ GT_STATUS gsysSetPerPortDuplexPauseMac
     DBG_INFO(("gsysSetPerPortDuplexPauseMac Called.\n"));
     BOOL_2_BIT(en,data);
 
-	/* if the device has Switch MAC Register, we need the special operation */
-	if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
     {
-		retVal = writeDiffMAC(dev,data);
+        retVal = writeDiffMAC(dev,data);
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        retVal = writeDiffMAC(dev,data);
+      else
+        retVal = hwSetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,data);
     }
-	else
-	{
-    	retVal = hwSetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,data);
-	}
 
     if(retVal != GT_OK)
     {
@@ -953,8 +1079,6 @@ GT_STATUS gsysSetPerPortDuplexPauseMac
     return GT_OK;
 }
 
-
-
 /*******************************************************************************
 * gsysGetPerPortDuplexPauseMac
 *
@@ -995,15 +1119,18 @@ GT_STATUS gsysGetPerPortDuplexPauseMac
         return GT_BAD_PARAM;
     }
 
-	/* if the device has Switch MAC Register, we need the special operation */
-	if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
     {
-		retVal = readDiffMAC(dev,&data);
+        retVal = readDiffMAC(dev,&data);
+    }
+    else
+    {
+      if (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH))
+        retVal = readDiffMAC(dev,&data);
+      else
+        retVal = hwGetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,&data);
     }
-	else
-	{
-	    retVal = hwGetGlobalRegField(dev,QD_REG_MACADDR_01,8,1,&data);
-	}
 
     if(retVal != GT_OK)
     {
@@ -1017,23 +1144,21 @@ GT_STATUS gsysGetPerPortDuplexPauseMac
 }
 
 /*******************************************************************************
-* gsysReadMiiReg
+* gsysSetPortWakeonFrameEn
 *
 * DESCRIPTION:
-*       This routine reads QuarterDeck Registers. Since this routine is only for
-*		Diagnostic Purpose, no error checking will be performed.
-*		User has to know which phy address(0 ~ 0x1F) will be read.		
+*       This routine sets port interrupt for wake on frame.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
-*       regAddr - The register's address.
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*       None.
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
 *       None.
@@ -1041,50 +1166,52 @@ GT_STATUS gsysGetPerPortDuplexPauseMac
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysReadMiiReg
+GT_STATUS gsysSetPortWakeonFrameEn
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     phyAddr,
-    IN  GT_U32	     regAddr,
-    OUT GT_U32	     *data
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        portVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          u16Data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysReadMiiRegister Called.\n"));
+    DBG_INFO(("gsysSetPortWakeonFrame Called.\n"));
 
-    /* Get the register data */
-    retVal = hwReadMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,&u16Data);
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+	retVal = writeSwMacWolWofReg(dev, 0x0e, portVec);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
-
-	*data = (GT_U32)u16Data;
-
+    DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysWriteMiiReg
+* gsysGetPortWakeonFrameEn
 *
 * DESCRIPTION:
-*       This routine writes QuarterDeck Registers. Since this routine is only for
-*		Diagnostic Purpose, no error checking will be performed.
-*		User has to know which phy address(0 ~ 0x1F) will be read.		
+*       This routine gets port interrupt enable for wake on frame.
 *
 * INPUTS:
-*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
-*       regAddr - The register's address.
+*       None.
 *
 * OUTPUTS:
-*       data    - The read register's data.
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * RETURNS:
-*       GT_OK           - on success
-*       GT_FAIL         - on error
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
 *       None.
@@ -1092,41 +1219,48 @@ GT_STATUS gsysReadMiiReg
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysWriteMiiReg
+GT_STATUS gsysGetPortWakeonFrameEn
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_U32	     phyAddr,
-    IN  GT_U32	     regAddr,
-    IN  GT_U16	     data
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    
-    DBG_INFO(("gsysWriteMiiRegister Called.\n"));
 
-    /* Set the register data */
-    retVal = hwWriteMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,data);
+    DBG_INFO(("gsysGetPortWakeonFrameEn Called.\n"));
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+	retVal = readSwMacWolWofReg(dev, 0x0e, portVec);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
-
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetRetransmitMode
+* gsysGetPortWakeonFrameEnSt
 *
 * DESCRIPTION:
-*       This routine set the Retransmit Mode.
+*       This routine gets port interrupt status for wake on frame.
 *
 * INPUTS:
-*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
+*       None.
 *
 * OUTPUTS:
-*       None.
+*       portVec - combine port interrupt enable=1 disable=0:
+*                 port 0: bit0, port 1: bit1, port 2: bit2, ...
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -1138,49 +1272,50 @@ GT_STATUS gsysWriteMiiReg
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetRetransmitMode
+GT_STATUS gsysGetPortWakeonFrameEnSt
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_BOOL      en
+    IN GT_QD_DEV    *dev,
+    OUT GT_U8       *portVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* Data to be set into the      */
-                                    /* register.                    */
-    DBG_INFO(("gsysSetRetransmitMode Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-    BOOL_2_BIT(en,data);
 
-    /* Set the Retransmit Mode bit.                */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,data);
+    DBG_INFO(("gsysGetPortWakeonFrameEnSt Called.\n"));
+
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (!(IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG)))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+	retVal = readSwMacWolWofReg(dev, 0x0c, portVec);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
-
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
-
-
 /*******************************************************************************
-* gsysGetRetransmitMode
+* gsysSetWoLMac
 *
 * DESCRIPTION:
-*       This routine get the Retransmit Mode.
+*       This routine sets the Wake on Lan Mac Address.
+*        MAC address should be an Unicast address.
+*        For different MAC Addresses per port operation, 
+*        use gsysSetPerPortDuplexPauseMac API.
 *
 * INPUTS:
-*       None.
+*       mac - The Mac address to be set.
 *
 * OUTPUTS:
-*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
+*       None.
 *
 * RETURNS:
 *       GT_OK           - on success
@@ -1190,54 +1325,85 @@ GT_STATUS gsysSetRetransmitMode
 * COMMENTS:
 *       None.
 *
-* GalTis:
-*
 *******************************************************************************/
-GT_STATUS gsysGetRetransmitMode
+GT_STATUS gsysSetWoLMac
 (
-    IN  GT_QD_DEV    *dev,
-    OUT GT_BOOL      *en
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
 )
 {
-    GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-
-    DBG_INFO(("gsysGetRetransmitMode Called.\n"));
-    if(en == NULL)
+    DBG_INFO(("gsysSetWoLMac Called.\n"));
+    if(mac == NULL)
     {
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
 
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-    /* Get the bit.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,&data);
-    if(retVal != GT_OK)
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
     {
-        DBG_INFO(("Failed.\n"));
-        return retVal;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
-    BIT_2_BOOL(data,*en);
-    DBG_INFO(("OK.\n"));
-    return GT_OK;
-}
+    return writeSwitchMacWolReg(dev, 0x10, mac);
 
+}
 
 /*******************************************************************************
-* gsysSetLimitBackoff
+* gsysGetWoLMac
 *
 * DESCRIPTION:
-*       This routine set the Limit Backoff bit.
+*       This routine Gets the Wake on Lan Mac Address.
+*        For different MAC Addresses per port operation, 
+*        use gsysGetPerPortDuplexPauseMac API.
 *
 * INPUTS:
-*       en - GT_TRUE:  uses QoS half duplex backoff operation  
-*            GT_FALSE: uses normal half duplex backoff operation
+*       None.
+*
+* OUTPUTS:
+*       mac - the Mac address.
+*
+* RETURNS:
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetWoLMac
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    DBG_INFO(("gsysGetWoLMac Called.\n"));
+    if(mac == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    return readSwitchMacWolReg(dev, 0x10, mac);
+}
+
+/*******************************************************************************
+* gsysSetPerPortWoLMac
+*
+* DESCRIPTION:
+*       This routine sets whether the Wake on Lan Mac Address is per
+*       port or per device.
+*
+* INPUTS:
+*       en - GT_TURE per port mac, GT_FALSE global mac.
 *
 * OUTPUTS:
 *       None.
@@ -1252,50 +1418,45 @@ GT_STATUS gsysGetRetransmitMode
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetLimitBackoff
+GT_STATUS gsysSetPerPortWoLMac
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_BOOL      en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL      en
 )
 {
-    GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* Data to be set into the      */
                                     /* register.                    */
-    DBG_INFO(("gsysSetLimitBackoff Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    DBG_INFO(("gsysSetPerPortWoLMac Called.\n"));
     BOOL_2_BIT(en,data);
 
-    /* Set the bit.                */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
-    if(retVal != GT_OK)
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
     {
-        DBG_INFO(("Failed.\n"));
-        return retVal;
-    }
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
 
-    DBG_INFO(("OK.\n"));
-    return GT_OK;
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+	{
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+	}
+     
+    return writeDiffMACWoL(dev, 0x10, data);
 }
 
-
-
 /*******************************************************************************
-* gsysGetLimitBackoff
+* gsysGetPerPortWoLMac
 *
 * DESCRIPTION:
-*       This routine set the Limit Backoff bit.
+*       This routine Gets whether the Wake on Lanc Mac Address is per
+*       port or per device.
 *
 * INPUTS:
-*       None.
+*       en - GT_TURE per port mac, GT_FALSE global mac.
 *
 * OUTPUTS:
-*       en - GT_TRUE:  uses QoS half duplex backoff operation  
-*            GT_FALSE: uses normal half duplex backoff operation
+*       None.
 *
 * RETURNS:
 *       GT_OK           - on success
@@ -1308,7 +1469,7 @@ GT_STATUS gsysSetLimitBackoff
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetLimitBackoff
+GT_STATUS gsysGetPerPortWoLMac
 (
     IN  GT_QD_DEV    *dev,
     OUT GT_BOOL      *en
@@ -1317,21 +1478,29 @@ GT_STATUS gsysGetLimitBackoff
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysGetLimitBackoff Called.\n"));
+    DBG_INFO(("gsysGetPerPortWoLMac Called.\n"));
     if(en == NULL)
     {
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_MAC_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+
+    }
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
 	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
 	}
+     
+
+	retVal = readDiffMACWoL(dev, 0x10, &data);
 
-    /* Get the bit.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -1343,74 +1512,62 @@ GT_STATUS gsysGetLimitBackoff
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetRsvReqPri
+* gsysSetWoLPass
 *
 * DESCRIPTION:
-*       This routine set the Reserved Queue's Requesting Priority 
+*       This routine sets the Wake on Lan Password Mac Address.
 *
 * INPUTS:
-*       en - GT_TRUE: use the last received frome's priority
-*            GT_FALSE:use the last switched frame's priority 
+*       mac - The Mac address to be set.
 *
 * OUTPUTS:
 *       None.
 *
 * RETURNS:
-*       GT_OK   - on success
-*       GT_FAIL - on error
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
 *       None.
 *
-* GalTis:
-*
 *******************************************************************************/
-GT_STATUS gsysSetRsvReqPri
+GT_STATUS gsysSetWoLPass
 (
-    IN  GT_QD_DEV    *dev,
-    IN  GT_BOOL      en
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
 )
 {
-    GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* Data to be set into the      */
-                                    /* register.                    */
-    DBG_INFO(("gsysSetRsvReqPri Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
-    BOOL_2_BIT(en,data);
-
-    /* Set the bit.                */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
-    if(retVal != GT_OK)
+    DBG_INFO(("gsysSetWoLPass Called.\n"));
+    if(mac == NULL)
     {
         DBG_INFO(("Failed.\n"));
-        return retVal;
+        return GT_BAD_PARAM;
     }
 
-    DBG_INFO(("OK.\n"));
-    return GT_OK;
-}
+    /* if the device has Switch MAC Register, we need the special operation */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
+    return writeSwitchMacWolReg(dev, 0x16, mac);
 
+}
 
 /*******************************************************************************
-* gsysGetRsvReqPri
+* gsysGetWoLPass
 *
 * DESCRIPTION:
-*       This routine get the Reserved Queue's Requesting Priority 
+*       This routine Gets the Wake on Lan password Mac Address.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
-*       en - GT_TRUE: use the last received frome's priority
-*            GT_FALSE:use the last switched frame's priority 
+*       mac - the Mac address.
 *
 * RETURNS:
 *       GT_OK           - on success
@@ -1420,916 +1577,808 @@ GT_STATUS gsysSetRsvReqPri
 * COMMENTS:
 *       None.
 *
-* GalTis:
-*
 *******************************************************************************/
-GT_STATUS gsysGetRsvReqPri
+GT_STATUS gsysGetWoLPass
 (
     IN  GT_QD_DEV    *dev,
-    OUT GT_BOOL      *en
+    OUT GT_ETHERADDR *mac
 )
 {
-    GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-
-    DBG_INFO(("gsysGetRsvReqPri Called.\n"));
-    if(en == NULL)
+    DBG_INFO(("gsysGetWoLPass Called.\n"));
+    if(mac == NULL)
     {
         DBG_INFO(("Failed.\n"));
         return GT_BAD_PARAM;
     }
-	/* Only Gigabit Switch supports this status. */
-	if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
 
-    /* Get the bit.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
-    if(retVal != GT_OK)
+    if (!IS_IN_DEV_GROUP(dev,DEV_SWITCH_WOL_WOF_REG))
     {
-        DBG_INFO(("Failed.\n"));
-        return retVal;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
-    BIT_2_BOOL(data,*en);
-    DBG_INFO(("OK.\n"));
-    return GT_OK;
+    return readSwitchMacWolReg(dev, 0x16, mac);
 }
 
+
 /*******************************************************************************
-* gsysSetCascadePort
+* gsysReadMiiReg
 *
 * DESCRIPTION:
-*		This routine sets Cascade Port number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip.
-*
-*		Use Cascade Port = 0xE to indicate this chip has no Cascade port.
-*		Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
+*       This routine reads QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know which phy address(0 ~ 0x1F) will be read.        
 *
 * INPUTS:
-*		port - Cascade Port
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
 *
 * OUTPUTS:
-*		None.
+*       data    - The read register's data.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetCascadePort
+GT_STATUS gsysReadMiiReg
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         phyAddr,
+    IN  GT_U32         regAddr,
+    OUT GT_U32         *data
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysSetCascadePort Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
+    GT_U16          u16Data;           /* The register's read data.    */
 
-    /* translate LPORT to hardware port */
-	if((port == 0xE) || (port == 0xF))
-		data = (GT_U16)port;
-	else
-	{
-	    data = (GT_U16)(GT_LPORT_2_PORT(port));
-		if (data == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
+    DBG_INFO(("gsysReadMiiRegister Called.\n"));
 
-    /* Set the Cascade port.                */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,data);
+    /* Get the register data */
+    retVal = hwReadMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,&u16Data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    DBG_INFO(("OK.\n"));
+    *data = (GT_U32)u16Data;
+
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysGetCascadePort
+* gsysWriteMiiReg
 *
 * DESCRIPTION:
-*		This routine gets Cascade Port number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip.
-*
-*		Use Cascade Port = 0xE to indicate this chip has no Cascade port.
-*		Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
+*       This routine writes QuarterDeck Registers. Since this routine is only for
+*        Diagnostic Purpose, no error checking will be performed.
+*        User has to know which phy address(0 ~ 0x1F) will be read.        
 *
 * INPUTS:
-*		None.
+*       phyAddr - Phy Address to read the register for.( 0 ~ 0x1F )
+*       regAddr - The register's address.
 *
 * OUTPUTS:
-*		port - Cascade Port
+*       data    - The read register's data.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetCascadePort
+GT_STATUS gsysWriteMiiReg
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         phyAddr,
+    IN  GT_U32         regAddr,
+    IN  GT_U16         data
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysSetCascadePort Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
+    
+    DBG_INFO(("gsysWriteMiiRegister Called.\n"));
 
-    /* Get the Cascade port.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,&data);
+    /* Set the register data */
+    retVal = hwWriteMiiReg(dev,(GT_U8)phyAddr,(GT_U8)regAddr,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if((data == 0xE) || (data == 0xF))
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
-    
-    DBG_INFO(("OK.\n"));
     return GT_OK;
 }
-
+#ifdef GT_RMGMT_ACCESS
 /*******************************************************************************
-* gsysSetDeviceNumber
+* gsysAccessMultiRegs
 *
 * DESCRIPTION:
-*		This routine sets Device Number.
-*		In multichip systems frames coming from a CPU need to know when they
-*		have reached their destination chip. From CPU frames whose Dev_Num
-*		fieldmatches these bits have reachedtheir destination chip and are sent
-*		out this chip using the port number indicated in the frame's Trg_Port 
-*		field.
+*       This function accesses switch's registers.
 *
 * INPUTS:
-*		devNum - Device Number (0 ~ 31)
-*
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
 * OUTPUTS:
-*		None.
+*   regList
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetDeviceNumber
+GT_STATUS gsysAccessMultiRegs
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		devNum
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysSetDeviceNumber Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-    data = ((GT_U16)devNum) & 0x1F; /* only 5 bits are valid */
-
-    /* Set the Device Number.                */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,data);
+    
+    DBG_INFO(("gsysAccessMultiReg Called.\n"));
+    /* Set the register data */
+    retVal = hwAccessMultiRegs(dev,regList);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
-
-    DBG_INFO(("OK.\n"));
     return GT_OK;
 }
+#endif
 
 /*******************************************************************************
-* gsysGetDeviceNumber
+* gsysSetRetransmitMode
 *
 * DESCRIPTION:
-*		This routine gets Device Number.
+*       This routine set the Retransmit Mode.
 *
 * INPUTS:
-*		None.
+*       en - GT_TRUE Retransimt Mode is enabled, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		devNum - Device Number (0 ~ 31)
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetDeviceNumber
+GT_STATUS gsysSetRetransmitMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U32  	*devNum
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetDeviceNumber Called.\n"));
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRetransmitMode Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
+    BOOL_2_BIT(en,data);
 
-    /* Get the Device Number.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,&data);
+    /* Set the Retransmit Mode bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    *devNum = (GT_U32)data;
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
+
 /*******************************************************************************
-* gsysSetCoreTagType
+* gsysGetRetransmitMode
 *
 * DESCRIPTION:
-*		This routine sets Ether Core Tag Type.
-*		This Ether Type is added to frames that egress the switch as Double Tagged 
-*		frames. It is also the Ether Type expected during Ingress to determine if 
-*		a frame is Tagged or not on ports configured as UseCoreTag mode.
+*       This routine get the Retransmit Mode.
 *
 * INPUTS:
-*		etherType - Core Tag Type (2 bytes)
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       en - GT_TRUE Retransmit Mode is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetCoreTagType
+GT_STATUS gsysGetRetransmitMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16  		etherType
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysSetCoreTagType Called.\n"));
+    DBG_INFO(("gsysGetRetransmitMode Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
-
-    /* Set the Ether Type */
-    retVal = hwWriteGlobalReg(dev,QD_REG_CORETAG_TYPE,etherType);
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,15,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
 /*******************************************************************************
-* gsysGetCoreTagType
+* gsysSetLimitBackoff
 *
 * DESCRIPTION:
-*		This routine gets CoreTagType
+*       This routine set the Limit Backoff bit.
 *
 * INPUTS:
-*		None.
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
 *
 * OUTPUTS:
-*		etherType - Core Tag Type (2 bytes)
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetCoreTagType
+GT_STATUS gsysSetLimitBackoff
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*etherType
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetCoreTagType Called.\n"));
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetLimitBackoff Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
+    BOOL_2_BIT(en,data);
 
-    /* Get the Device Number.                */
-    retVal = hwReadGlobalReg(dev,QD_REG_CORETAG_TYPE,&data);
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    *etherType = data;
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
+
 /*******************************************************************************
-* gsysSetIngressMonitorDest
+* gsysGetLimitBackoff
 *
 * DESCRIPTION:
-*		This routine sets Ingress Monitor Destination Port. Frames that are 
-*		targeted toward an Ingress Monitor Destination go out the port number 
-*		indicated in these bits. This includes frames received on a Marvell Tag port
-*		with the Ingress Monitor type, and frames received on a Network port that 
-*		is enabled to be the Ingress Monitor Source Port.
-*		If the Ingress Monitor Destination Port resides in this device these bits 
-*		should point to the Network port where these frames are to egress. If the 
-*		Ingress Monitor Destination Port resides in another device these bits 
-*		should point to the Marvell Tag port in this device that is used to get 
-*		to the device that contains the Ingress Monitor Destination Port.
+*       This routine set the Limit Backoff bit.
 *
 * INPUTS:
-*		port  - the logical port number.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       en - GT_TRUE:  uses QoS half duplex backoff operation  
+*            GT_FALSE: uses normal half duplex backoff operation
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetIngressMonitorDest
+GT_STATUS gsysGetLimitBackoff
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U8           hwPort;         /* the physical port number     */
-
-    DBG_INFO(("gsysSetIngressMonitorDest Called.\n"));
-
-    /* translate LPORT to hardware port */
-    hwPort = GT_LPORT_2_PORT(port);
+    GT_U16          data;           /* The register's read data.    */
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    DBG_INFO(("gsysGetLimitBackoff Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Only Gigabit Switch supports this status. */
+    if ((IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MELODY_SWITCH)))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* translate LPORT to hardware port */
-	if(port == 0xF)
-		hwPort = (GT_U8)port;
-	else
-	{
-	    hwPort = (GT_U8)GT_LPORT_2_PORT(port);
-		if (hwPort == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
-
-    /* Set the Ether Type */
-    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, (GT_U16)hwPort);
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,14,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
 /*******************************************************************************
-* gsysGetIngressMonitorDest
+* gsysSetRsvReqPri
 *
 * DESCRIPTION:
-*		This routine gets Ingress Monitor Destination Port.
+*       This routine set the Reserved Queue's Requesting Priority 
 *
 * INPUTS:
-*		None.
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*       None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK   - on success
+*       GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetIngressMonitorDest
+GT_STATUS gsysSetRsvReqPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL      en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetIngressMonitorDest Called.\n"));
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    GT_U16          data;           /* Data to be set into the      */
+                                    /* register.                    */
+    DBG_INFO(("gsysSetRsvReqPri Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
+    BOOL_2_BIT(en,data);
 
-    /* Get the IngressMonitorDest. */
-    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, &data);
+    /* Set the bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if(data == 0xF)
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
+
 /*******************************************************************************
-* gsysSetEgressMonitorDest
+* gsysGetRsvReqPri
 *
 * DESCRIPTION:
-*		This routine sets Egress Monitor Destination Port. Frames that are 
-*		targeted toward an Egress Monitor Destination go out the port number 
-*		indicated in these bits. This includes frames received on a Marvell Tag port
-*		with the Egress Monitor type, and frames transmitted on a Network port that 
-*		is enabled to be the Egress Monitor Source Port.
-*		If the Egress Monitor Destination Port resides in this device these bits 
-*		should point to the Network port where these frames are to egress. If the 
-*		Egress Monitor Destination Port resides in another device these bits 
-*		should point to the Marvell Tag port in this device that is used to get 
-*		to the device that contains the Egress Monitor Destination Port.
+*       This routine get the Reserved Queue's Requesting Priority 
 *
 * INPUTS:
-*		port  - the logical port number.
+*       None.
 *
 * OUTPUTS:
-*		None.
+*       en - GT_TRUE: use the last received frome's priority
+*            GT_FALSE:use the last switched frame's priority 
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*       GT_OK           - on success
+*       GT_BAD_PARAM    - on bad parameter
+*       GT_FAIL         - on error
 *
 * COMMENTS:
-*		None.
+*       None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetEgressMonitorDest
+GT_STATUS gsysGetRsvReqPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U8           hwPort;         /* the physical port number     */
-
-    DBG_INFO(("gsysSetEgressMonitorDest Called.\n"));
-
-    /* translate LPORT to hardware port */
-    hwPort = GT_LPORT_2_PORT(port);
+    GT_U16          data;           /* The register's read data.    */
 
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    DBG_INFO(("gsysGetRsvReqPri Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+    /* Only Gigabit Switch supports this status. */
+    if (IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if(port == 0xF)
-		hwPort = (GT_U8)port;
-	else
-	{
-	    hwPort = (GT_U8)GT_LPORT_2_PORT(port);
-		if (hwPort == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
-
-    /* Set EgressMonitorDest */
-    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, (GT_U16)hwPort);
+    /* Get the bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysGetEgressMonitorDest
+* gsysSetCascadePort
 *
 * DESCRIPTION:
-*		This routine gets Egress Monitor Destination Port.
+*        This routine sets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
+*
+*        Use Cascade Port = 0xE to indicate this chip has no Cascade port.
+*        Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
 *
 * INPUTS:
-*		None.
+*        port - Cascade Port
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetEgressMonitorDest
+GT_STATUS gsysSetCascadePort
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetEgressMonitorDest Called.\n"));
-
-	/* Only Gigabit Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get the EgressMonitorDest. */
-    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, &data);
+    /* translate LPORT to hardware port */
+    if((port == 0xE) || (port == 0xF))
+        data = (GT_U16)port;
+    else
+    {
+        data = (GT_U16)(GT_LPORT_2_PORT(port));
+        if (data == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
+
+    /* Set the Cascade port.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if(data == 0xF)
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetARPDest
+* gsysGetCascadePort
 *
 * DESCRIPTION:
-*		This routine sets ARP Monitor Destination Port. Tagged or untagged 
-*		frames ingress Network ports that have the Broadcast Destination Address 
-*		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
-*		should point to the port that directs these frames to the switch's CPU 
-*		that will process ARPs. This target port should be a Marvell Tag port so 
-*		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
-*		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
-*		Tag port will be sent to the port number defineded in ARPDest.
+*        This routine gets Cascade Port number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip.
 *
-*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
-*		frames will be discarded.
+*        Use Cascade Port = 0xE to indicate this chip has no Cascade port.
+*        Use Cascade Port = 0xF to use Routing table (gsysGetDevRoutingTable).
 *
 * INPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        port - Cascade Port
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetARPDest
+GT_STATUS gsysGetCascadePort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U8           hwPort;         /* the physical port number     */
-
-    DBG_INFO(("gsysSetARPDest Called.\n"));
-
-    /* translate LPORT to hardware port */
-    hwPort = GT_LPORT_2_PORT(port);
-
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysSetCascadePort Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CASCADE_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* translate LPORT to hardware port */
-	if(port == 0xF)
-		hwPort = (GT_U8)port;
-	else
-	{
-	    hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
-		if (hwPort == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
-
-    /* Set related bit */
-    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
+    /* Get the Cascade port.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,4,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    if((data == 0xE) || (data == 0xF))
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysGetARPDest
+* gsysSetDeviceNumber
 *
 * DESCRIPTION:
-*		This routine gets ARP Monitor Destination Port. Tagged or untagged 
-*		frames ingress Network ports that have the Broadcast Destination Address 
-*		with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
-*		should point to the port that directs these frames to the switch's CPU 
-*		that will process ARPs. This target port should be a Marvell Tag port so 
-*		that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
-*		To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
-*		Tag port will be sent to the port number defineded in ARPDest.
-*
-*		If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
-*		frames will be discarded.
+*        This routine sets Device Number.
+*        In multichip systems frames coming from a CPU need to know when they
+*        have reached their destination chip. From CPU frames whose Dev_Num
+*        fieldmatches these bits have reachedtheir destination chip and are sent
+*        out this chip using the port number indicated in the frame's Trg_Port 
+*        field.
 *
 * INPUTS:
-*		None.
+*        devNum - Device Number (0 ~ 31)
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetARPDest
+GT_STATUS gsysSetDeviceNumber
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetARPDest Called.\n"));
-
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
+    DBG_INFO(("gsysSetDeviceNumber Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related bit */
-    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
+    data = ((GT_U16)devNum) & 0x1F; /* only 5 bits are valid */
+
+    /* Set the Device Number.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if(data == 0xF)
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetRsvd2CpuEnables
+* gsysGetDeviceNumber
 *
 * DESCRIPTION:
-*		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
-*		the 16 reserved multicast DA addresses, whose bit in this register are 
-*		also set to a one, are treadted as MGMT frames. All the reserved DA's 
-*		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
-*		tested. When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*        This routine gets Device Number.
 *
 * INPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        devNum - Device Number (0 ~ 31)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetRsvd2CpuEnables
+GT_STATUS gsysGetDeviceNumber
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		enBits
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *devNum
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-
-    DBG_INFO(("gsysSetRsvd2CpuEnables Called.\n"));
-
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetDeviceNumber Called.\n"));
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Set related register */
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE, (GT_U16)enBits);
+    /* Get the Device Number.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,5,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    *devNum = (GT_U32)data;
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysGetRsvd2CpuEnables
+* gsysSetCoreTagType
 *
 * DESCRIPTION:
-*		Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
-*		the 16 reserved multicast DA addresses, whose bit in this register are 
-*		also set to a one, are treadted as MGMT frames. All the reserved DA's 
-*		take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
-*		tested. When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*        This routine sets Ether Core Tag Type.
+*        This Ether Type is added to frames that egress the switch as Double Tagged 
+*        frames. It is also the Ether Type expected during Ingress to determine if 
+*        a frame is Tagged or not on ports configured as UseCoreTag mode.
 *
 * INPUTS:
-*		None.
+*        etherType - Core Tag Type (2 bytes)
 *
 * OUTPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetRsvd2CpuEnables
+GT_STATUS gsysSetCoreTagType
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*enBits
+    IN GT_QD_DEV    *dev,
+    IN GT_U16          etherType
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
-    DBG_INFO(("gsysGetRsvd2CpuEnables Called.\n"));
+    DBG_INFO(("gsysSetCoreTagType Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related register */
-    retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE, enBits);
+    /* Set the Ether Type */
+    retVal = hwWriteGlobalReg(dev,QD_REG_CORETAG_TYPE,etherType);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2340,188 +2389,124 @@ GT_STATUS gsysGetRsvd2CpuEnables
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetRsvd2Cpu
+* gsysGetCoreTagType
 *
 * DESCRIPTION:
-*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
-*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
-*		membership, will be considered MGMT frames and sent to the CPU Port.
-*		If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
-*		the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
-*		bit for the frames's DA is also set to a one.
+*        This routine gets CoreTagType
 *
 * INPUTS:
-*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*        None.
 *
 * OUTPUTS:
-*		None.
+*        etherType - Core Tag Type (2 bytes)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetRsvd2Cpu
+GT_STATUS gsysGetCoreTagType
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *etherType
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
-
-    DBG_INFO(("gsysSetRsvd2Cpu Called.\n"));
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetCoreTagType Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST|DEV_MULTICAST))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CORE_TAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    BOOL_2_BIT(en,data);
-
-    /* Set related bit */
-	if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
-	{
-	    retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1, data);
-	}
-	else
-	{
-	    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 3, 1, data);
-	}
-
+    /* Get the Device Number.                */
+    retVal = hwReadGlobalReg(dev,QD_REG_CORETAG_TYPE,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    *etherType = data;
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysGetRsvd2Cpu
+* gsysSetIngressMonitorDest
 *
 * DESCRIPTION:
-*		When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
-*		Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
-*		membership, will be considered MGMT frames and sent to the CPU Port.
-*		If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
-*		the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
-*		bit for the frames's DA is also set to a one.
+*        This routine sets Ingress Monitor Destination Port. Frames that are 
+*        targeted toward an Ingress Monitor Destination go out the port number 
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Ingress Monitor type, and frames received on a Network port that 
+*        is enabled to be the Ingress Monitor Source Port.
+*        If the Ingress Monitor Destination Port resides in this device these bits 
+*        should point to the Network port where these frames are to egress. If the 
+*        Ingress Monitor Destination Port resides in another device these bits 
+*        should point to the Marvell Tag port in this device that is used to get 
+*        to the device that contains the Ingress Monitor Destination Port.
 *
 * INPUTS:
-*		None.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetRsvd2Cpu
+GT_STATUS gsysSetIngressMonitorDest
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetRsvd2Cpu Called.\n"));
+    GT_U8           hwPort;         /* the physical port number     */
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST|DEV_MULTICAST))
-    {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
+    DBG_INFO(("gsysSetIngressMonitorDest Called.\n"));
 
-    /* Get related bit */
-	if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
-	{
-	    retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1,&data);
-	}
-	else
-	{
-	    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,3,1,&data);
-	}
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
 
-    if(retVal != GT_OK)
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
-        DBG_INFO(("Failed.\n"));
-        return retVal;
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
     }
 
-    BIT_2_BOOL(data,*en);
-    DBG_INFO(("OK.\n"));
-    return GT_OK;
-}
-
-/*******************************************************************************
-* gsysSetMGMTPri
-*
-* DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
-*
-* INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
-*
-* OUTPUTS:
-*		None.
-*
-* RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
-*
-* COMMENTS:
-*		None.
-*
-*******************************************************************************/
-GT_STATUS gsysSetMGMTPri
-(
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
-)
-{
-    GT_STATUS       retVal;         /* Functions return value.      */
-
-    DBG_INFO(("gsysSetMGMTPri Called.\n"));
-
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
     {
-        DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        hwPort = (GT_U8)GT_LPORT_2_PORT(port);
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
     }
 
-	if (pri > 0x7)
-	{
-        DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
-
-    /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 0, 3, pri);
+    /* Set the Ether Type */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, (GT_U16)hwPort);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2533,102 +2518,129 @@ GT_STATUS gsysSetMGMTPri
 }
 
 /*******************************************************************************
-* gsysGetMGMTPri
+* gsysGetIngressMonitorDest
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
+*        This routine gets Ingress Monitor Destination Port.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetMGMTPri
+GT_STATUS gsysGetIngressMonitorDest
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    DBG_INFO(("gsysGetMGMTPri Called.\n"));
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetIngressMonitorDest Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,0,3,pri);
+    /* Get the IngressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 12, 4, &data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetUseDoubleTagData
+* gsysSetEgressMonitorDest
 *
 * DESCRIPTION:
-*		This bit is used to determine if Double Tag data that is removed from a 
-*		Double Tag frame is used or ignored when making switching decisions on 
-*		the frame.
+*        This routine sets Egress Monitor Destination Port. Frames that are 
+*        targeted toward an Egress Monitor Destination go out the port number 
+*        indicated in these bits. This includes frames received on a Marvell Tag port
+*        with the Egress Monitor type, and frames transmitted on a Network port that 
+*        is enabled to be the Egress Monitor Source Port.
+*        If the Egress Monitor Destination Port resides in this device these bits 
+*        should point to the Network port where these frames are to egress. If the 
+*        Egress Monitor Destination Port resides in another device these bits 
+*        should point to the Marvell Tag port in this device that is used to get 
+*        to the device that contains the Egress Monitor Destination Port.
 *
 * INPUTS:
-*		en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetUseDoubleTagData
+GT_STATUS gsysSetEgressMonitorDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U8           hwPort;         /* the physical port number     */
 
-    DBG_INFO(("gsysSetUseDoubleTagData Called.\n"));
+    DBG_INFO(("gsysSetEgressMonitorDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    BOOL_2_BIT(en,data);
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)GT_LPORT_2_PORT(port);
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
 
-    /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
+    /* Set EgressMonitorDest */
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, (GT_U16)hwPort);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2640,109 +2652,132 @@ GT_STATUS gsysSetUseDoubleTagData
 }
 
 /*******************************************************************************
-* gsysGetUseDoubleTagData
+* gsysGetEgressMonitorDest
 *
 * DESCRIPTION:
-*		This bit is used to determine if Double Tag data that is removed from a 
-*		Double Tag frame is used or ignored when making switching decisions on 
-*		the frame.
+*        This routine gets Egress Monitor Destination Port.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetUseDoubleTagData
+GT_STATUS gsysGetEgressMonitorDest
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetUseDoubleTagData Called.\n"));
+    DBG_INFO(("gsysGetEgressMonitorDest Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    /* Only Gigabit Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_88E6093_FAMILY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+    /* Get the EgressMonitorDest. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 8, 4, &data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    BIT_2_BOOL(data,*en);
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 
 /*******************************************************************************
-* gsysSetPreventLoops
+* gsysSetARPDest
 *
 * DESCRIPTION:
-*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
-*		field equals this device's Device Number, the following action will be 
-*		taken depending upon the value of this bit.
-*		GT_TRUE (1) - The frame will be discarded.
-*		GT_FALSE(0) - The frame will be prevented from going out its original 
-*						source port as defined by the frame's Src_Port field.
+*        This routine sets ARP Monitor Destination Port. Tagged or untagged 
+*        frames ingress Network ports that have the Broadcast Destination Address 
+*        with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*        should point to the port that directs these frames to the switch's CPU 
+*        that will process ARPs. This target port should be a Marvell Tag port so 
+*        that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*        To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*        Tag port will be sent to the port number defineded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+*        frames will be discarded.
 *
 * INPUTS:
-*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetPreventLoops
+GT_STATUS gsysSetARPDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U8           hwPort;         /* the physical port number     */
 
-    DBG_INFO(("gsysSetPreventLoops Called.\n"));
+    DBG_INFO(("gsysSetARPDest Called.\n"));
+
+    /* translate LPORT to hardware port */
+    hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    BOOL_2_BIT(en,data);
+    /* translate LPORT to hardware port */
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 14, 1, data);
+    retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2754,110 +2789,124 @@ GT_STATUS gsysSetPreventLoops
 }
 
 /*******************************************************************************
-* gsysGetPreventLoops
+* gsysGetARPDest
 *
 * DESCRIPTION:
-*		When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
-*		field equals this device's Device Number, the following action will be 
-*		taken depending upon the value of this bit.
-*		GT_TRUE (1) - The frame will be discarded.
-*		GT_FALSE(0) - The frame will be prevented from going out its original 
-*						source port as defined by the frame's Src_Port field.
+*        This routine gets ARP Monitor Destination Port. Tagged or untagged 
+*        frames ingress Network ports that have the Broadcast Destination Address 
+*        with an Ethertype of 0x0806 are mirrored to this port. The ARPDest 
+*        should point to the port that directs these frames to the switch's CPU 
+*        that will process ARPs. This target port should be a Marvell Tag port so 
+*        that frames will egress with a To CPU Marvell Tag with a CPU Code of ARP.
+*        To CPU Marvell Tag frames with a CPU Code off ARP that ingress a Marvell 
+*        Tag port will be sent to the port number defineded in ARPDest.
+*
+*        If ARPDest =  0xF, ARP Monitoring is disabled and ingressing To CPU ARP 
+*        frames will be discarded.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetPreventLoops
+GT_STATUS gsysGetARPDest
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetPreventLoops Called.\n"));
+    DBG_INFO(("gsysGetARPDest Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_DEST_SUPPORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,14,1,&data);
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, &data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    BIT_2_BOOL(data,*en);
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
 /*******************************************************************************
-* gsysSetFlowControlMessage
+* gsysSetRsvd2CpuEnables
 *
 * DESCRIPTION:
-*		When this bit is set to one, Marvell Tag Flow Control messages will be 
-*		generated when an output queue becomes congested and received Marvell Tag 
-*		Flow Control messages will pause MACs inside this device. When this bit 
-*		is cleared to a zero Marvell Tag Flow Control messages will not be 
-*		generated and any received will be ignored at the target MAC.
+*        Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+*        the 16 reserved multicast DA addresses, whose bit in this register are 
+*        also set to a one, are treadted as MGMT frames. All the reserved DA's 
+*        take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+*        tested. When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetFlowControlMessage
+GT_STATUS gsysSetRsvd2CpuEnables
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
 
-    DBG_INFO(("gsysSetFlowControlMessage Called.\n"));
+    DBG_INFO(("gsysSetRsvd2CpuEnables Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    BOOL_2_BIT(en,data);
-
-    /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 13, 1, data);
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_MGMT_ENABLE, (GT_U16)enBits);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2869,111 +2918,123 @@ GT_STATUS gsysSetFlowControlMessage
 }
 
 /*******************************************************************************
-* gsysGetFlowControlMessage
+* gsysGetRsvd2CpuEnables
 *
 * DESCRIPTION:
-*		When this bit is set to one, Marvell Tag Flow Control messages will be 
-*		generated when an output queue becomes congested and received Marvell Tag 
-*		Flow Control messages will pause MACs inside this device. When this bit 
-*		is cleared to a zero Marvell Tag Flow Control messages will not be 
-*		generated and any received will be ignored at the target MAC.
+*        Reserved DA Enables. When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, 
+*        the 16 reserved multicast DA addresses, whose bit in this register are 
+*        also set to a one, are treadted as MGMT frames. All the reserved DA's 
+*        take the form 01:80:C2:00:00:0x. When x = 0x0, bit 0 of this register is 
+*        tested. When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFlowControlMessage
+GT_STATUS gsysGetRsvd2CpuEnables
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetFlowControlMessage Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    DBG_INFO(("gsysGetRsvd2CpuEnables Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,13,1,&data);
+    /* Get related register */
+    retVal = hwReadGlobal2Reg(dev, QD_REG_MGMT_ENABLE, enBits);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
 /*******************************************************************************
-* gsysSetForceFlowControlPri
+* gsysSetRsvd2Cpu
 *
 * DESCRIPTION:
-*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
-*		Flow Control frames will be set to the value of the FC Pri bits (set by 
-*		gsysSetFCPri function call). When this bit is cleared to a zero generated 
-*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
-*		frames that caused the congestion. This bit will have no effect if the 
-*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
-*		cleared to a zero.
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*        membership, will be considered MGMT frames and sent to the CPU Port.
+*        If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
+*        the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
+*        bit for the frames's DA is also set to a one.
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysSetForceFlowControlPri
+GT_STATUS gsysSetRsvd2Cpu
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
-    DBG_INFO(("gsysSetForceFlowControlPri Called.\n"));
+    DBG_INFO(("gsysSetRsvd2Cpu Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
 
     /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 7, 1, data);
+    if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1, data);
+    }
+    else
+    {
+        retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 3, 1, data);
+    }
+
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -2985,53 +3046,61 @@ GT_STATUS gsysSetForceFlowControlPri
 }
 
 /*******************************************************************************
-* gsysGetForceFlowControlPri
+* gsysGetRsvd2Cpu
 *
 * DESCRIPTION:
-*		When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
-*		Flow Control frames will be set to the value of the FC Pri bits (set by 
-*		gsysSetFCPri function call). When this bit is cleared to a zero generated 
-*		Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
-*		frames that caused the congestion. This bit will have no effect if the 
-*		FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
-*		cleared to a zero.
+*        When the Rsvd2Cpu is set to a one(GT_TRUE), frames with a Destination 
+*        Address in the range 01:80:C2:00:00:0x, regardless of their VLAN 
+*        membership, will be considered MGMT frames and sent to the CPU Port.
+*        If device supports Rsvd2CpuEnable (gsysSetRsvd2CpuEnable function),
+*        the frame will be considered MGMT frame when the associated Rsvd2CpuEnable
+*        bit for the frames's DA is also set to a one.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE if Rsvd2Cpu is set. GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetForceFlowControlPri
+GT_STATUS gsysGetRsvd2Cpu
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetForceFlowControlPri Called.\n"));
+    DBG_INFO(("gsysGetRsvd2Cpu Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,7,1,&data);
+    if (IS_IN_DEV_GROUP(dev,DEV_MULTICAST))
+    {
+        retVal = hwGetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,3,1,&data);
+    }
+    else
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,3,1,&data);
+    }
+
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3044,54 +3113,52 @@ GT_STATUS gsysGetForceFlowControlPri
 }
 
 /*******************************************************************************
-* gsysSetFCPri
+* gsysSetMGMTPri
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
-*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
-*		is set to a one.
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetFCPri
+GT_STATUS gsysSetMGMTPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
-    DBG_INFO(("gsysSetFCPri Called.\n"));
+    DBG_INFO(("gsysSetMGMTPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (pri > 0x7)
-	{
+    if (pri > 0x7)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 4, 3, pri);
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 0, 3, pri);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3103,48 +3170,46 @@ GT_STATUS gsysSetFCPri
 }
 
 /*******************************************************************************
-* gsysGetFCPri
+* gsysGetMGMTPri
 *
 * DESCRIPTION:
-*		These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
-*		Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
-*		is set to a one.
+*        These bits are used as the PRI[2:0] bits on Rsvd2CPU frames.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFCPri
+GT_STATUS gsysGetMGMTPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    DBG_INFO(("gsysGetFCPri Called.\n"));
+    DBG_INFO(("gsysGetMGMTPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,4,3,pri);
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,0,3,pri);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3157,94 +3222,50 @@ GT_STATUS gsysGetFCPri
 
 
 /*******************************************************************************
-* gsysSetFlowCtrlDelay
+* gsysSetUseDoubleTagData
 *
 * DESCRIPTION:
-*		This function sets Flow control delay time for 10Mbps, 100Mbps, and 
-*		1000Mbps. 
+*        This bit is used to determine if Double Tag data that is removed from a 
+*        Double Tag frame is used or ignored when making switching decisions on 
+*        the frame.
 *
 * INPUTS:
-*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
-*		delayTime - delay time.
+*        en - GT_TRUE to use removed tag data, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*	Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on 
-*	switch device. Please refer to the device datasheet for detailed information.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetFlowCtrlDelay
+GT_STATUS gsysSetUseDoubleTagData
 (
-	IN GT_QD_DEV			*dev,
-	IN GT_PORT_SPEED_MODE	sp,
-	IN GT_U32				delayTime
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
-    DBG_INFO(("gsysSetFlowCtrlDelay Called.\n"));
+    DBG_INFO(("gsysSetUseDoubleTagData Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	switch(sp)
-	{
-		case PORT_SPEED_10_MBPS:
-				data = 0;
-				break;
-		case PORT_SPEED_100_MBPS:
-				data = 1 << 13;
-				break;
-		case PORT_SPEED_1000_MBPS:
-				data = 2 << 13;
-				break;
-		default:
-		        DBG_INFO(("GT_BAD_PARAM (sp)\n"));
-				gtSemGive(dev,dev->tblRegsSem);
-				return GT_BAD_PARAM;
-	}
-
-	if (delayTime > 0x1FFF)
-	{
-		DBG_INFO(("GT_BAD_PARAM (delayTime)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	data |= (GT_U16)(0x8000 | delayTime);
-
-    /* Set related register */
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
-
-	gtSemGive(dev,dev->tblRegsSem);
+    BOOL_2_BIT(en,data);
 
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 15, 1, data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3256,187 +3277,109 @@ GT_STATUS gsysSetFlowCtrlDelay
 }
 
 /*******************************************************************************
-* gsysGetFlowCtrlDelay
+* gsysGetUseDoubleTagData
 *
 * DESCRIPTION:
-*		This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
-*		1000Mbps. 
+*        This bit is used to determine if Double Tag data that is removed from a 
+*        Double Tag frame is used or ignored when making switching decisions on 
+*        the frame.
 *
 * INPUTS:
-*		sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        None.
 *
 * OUTPUTS:
-*		delayTime - delay time
+*        en - GT_TRUE if removed tag data is used, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*	Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on 
-*	switch device. Please refer to the device datasheet for detailed information.
+*        None.
+*
+* GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetFlowCtrlDelay
+GT_STATUS gsysGetUseDoubleTagData
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_PORT_SPEED_MODE	sp,
-	OUT GT_U32		*delayTime
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetFlowCtrlDelay Called.\n"));
+    DBG_INFO(("gsysGetUseDoubleTagData Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	switch(sp)
-	{
-		case PORT_SPEED_10_MBPS:
-				data = 0;
-				break;
-		case PORT_SPEED_100_MBPS:
-				data = 1 << 13;
-				break;
-		case PORT_SPEED_1000_MBPS:
-				data = 2 << 13;
-				break;
-		default:
-		        DBG_INFO(("GT_BAD_PARAM (sp)\n"));
-				gtSemGive(dev,dev->tblRegsSem);
-				return GT_BAD_PARAM;
-	}
-
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
-   	if(retVal != GT_OK)
-    {
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-       	return retVal;
-    }
-
-    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-   	if(retVal != GT_OK)
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,15,1,&data);
+    if(retVal != GT_OK)
     {
-   	    DBG_INFO(("Failed.\n"));
-       	return retVal;
+        DBG_INFO(("Failed.\n"));
+        return retVal;
     }
 
-	*delayTime = (GT_U32)(data & 0x1FFF);
-		
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 
 /*******************************************************************************
-* gsysSetDevRoutingTable
+* gsysSetPreventLoops
 *
 * DESCRIPTION:
-*		This function sets Device to Port mapping (which device is connected to 
-*		which port of this device). 
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*        field equals this device's Device Number, the following action will be 
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original 
+*                        source port as defined by the frame's Src_Port field.
 *
 * INPUTS:
-*		devNum - target device number.
-*		portNum - the logical port number.
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetDevRoutingTable
+GT_STATUS gsysSetPreventLoops
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		devNum,
-	IN GT_LPORT 	port
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U8           hwPort;         /* the physical port number     */
-    GT_U16          data;           /* The register's read data.    */
+    GT_U16            data;
 
-    DBG_INFO(("gsysSetDevRoutingTable Called.\n"));
+    DBG_INFO(("gsysSetPreventLoops Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	if(devNum > 0x1F)
-	{
-		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-    /* translate LPORT to hardware port */
-	if(port >= dev->numOfPorts)
-	{
-		hwPort = 0xF;
-	}
-	else
-	{
-	    hwPort = GT_LPORT_2_PORT(port);
-	}
-
-	data = (GT_U16)(0x8000 | (devNum << 8) | hwPort);
-
-    /* Set related register */
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
-
-	gtSemGive(dev,dev->tblRegsSem);
+    BOOL_2_BIT(en,data);
 
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 14, 1, data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3448,194 +3391,110 @@ GT_STATUS gsysSetDevRoutingTable
 }
 
 /*******************************************************************************
-* gsysGetDevRoutingTable
+* gsysGetPreventLoops
 *
 * DESCRIPTION:
-*		This function gets Device to Port mapping (which device is connected to 
-*		which port of this device). 
+*        When a Marvell Tag port receives a Forward Marvell Tag whose Src_Dev 
+*        field equals this device's Device Number, the following action will be 
+*        taken depending upon the value of this bit.
+*        GT_TRUE (1) - The frame will be discarded.
+*        GT_FALSE(0) - The frame will be prevented from going out its original 
+*                        source port as defined by the frame's Src_Port field.
 *
 * INPUTS:
-*		devNum - target device number.
+*        None.
 *
 * OUTPUTS:
-*		portNum - the logical port number.
+*        en - GT_TRUE to discard the frame as described above, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetDevRoutingTable
+GT_STATUS gsysGetPreventLoops
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		devNum,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetPreventLoops Called.\n"));
 
-    DBG_INFO(("gsysGetDevRoutingTable Called.\n"));
-
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_LOOP_BLOCK))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	if(devNum > 0x1F)
-	{
-		DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	data = (GT_U16)(devNum << 8);
-
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
-   	if(retVal != GT_OK)
-    {
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-       	return retVal;
+        return GT_NOT_SUPPORTED;
     }
 
-    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-   	if(retVal != GT_OK)
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,14,1,&data);
+    if(retVal != GT_OK)
     {
-   	    DBG_INFO(("Failed.\n"));
-       	return retVal;
+        DBG_INFO(("Failed.\n"));
+        return retVal;
     }
 
-	*port = GT_PORT_2_LPORT((GT_U8)(data & 0xF));
-	if(*port == GT_INVALID_PORT)
-	{
-		*port = 0xF;
-	}	
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysSetTrunkMaskTable
+* gsysSetFlowControlMessage
 *
 * DESCRIPTION:
-*		This function sets Trunk Mask for the given Trunk Number.
+*        When this bit is set to one, Marvell Tag Flow Control messages will be 
+*        generated when an output queue becomes congested and received Marvell Tag 
+*        Flow Control messages will pause MACs inside this device. When this bit 
+*        is cleared to a zero Marvell Tag Flow Control messages will not be 
+*        generated and any received will be ignored at the target MAC.
 *
 * INPUTS:
-*		trunkNum - Trunk Number.
-*		trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
-*					bit 1 for port 1 , etc.
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
-*					   if trunkNum > 0x3 for 88E6065 family.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetTrunkMaskTable
+GT_STATUS gsysSetFlowControlMessage
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		trunkNum,
-	IN GT_U32		trunkMask
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-	GT_U32			mask;
+    GT_U16            data;
 
-    DBG_INFO(("gsysSetTrunkMaskTable Called.\n"));
+    DBG_INFO(("gsysSetFlowControlMessage Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK|DEV_REDUCED_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	data &= 0x0800;
-
-	if(trunkNum > 0x7)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	mask = (1 << dev->numOfPorts) - 1;
-
-	if(trunkMask > mask)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkMask)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	mask = GT_LPORTVEC_2_PORTVEC(trunkMask);
-
-	data = (GT_U16)(0x8000 | data | (trunkNum << 12) | mask);
-
-    /* Set related register */
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
-
-	gtSemGive(dev,dev->tblRegsSem);
+    BOOL_2_BIT(en,data);
 
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 13, 1, data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3647,157 +3506,111 @@ GT_STATUS gsysSetTrunkMaskTable
 }
 
 /*******************************************************************************
-* gsysGetTrunkMaskTable
+* gsysGetFlowControlMessage
 *
 * DESCRIPTION:
-*		This function gets Trunk Mask for the given Trunk Number.
+*        When this bit is set to one, Marvell Tag Flow Control messages will be 
+*        generated when an output queue becomes congested and received Marvell Tag 
+*        Flow Control messages will pause MACs inside this device. When this bit 
+*        is cleared to a zero Marvell Tag Flow Control messages will not be 
+*        generated and any received will be ignored at the target MAC.
 *
 * INPUTS:
-*		trunkNum - Trunk Number.
+*        None.
 *
 * OUTPUTS:
-*		trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
-*					bit 1 for port 1 , etc.
+*        en - GT_TRUE to use Marvell Tag Flow Control message, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
-*					   if trunkNum > 0x3 for 88E6065 family.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetTrunkMaskTable
+GT_STATUS gsysGetFlowControlMessage
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		trunkNum,
-	OUT GT_U32		*trunkMask
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-	GT_U32			mask;
-
-    DBG_INFO(("gsysGetTrunkMaskTable Called.\n"));
+    DBG_INFO(("gsysGetFlowControlMessage Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK|DEV_REDUCED_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	data &= 0x0800;
-
-	if(trunkNum > 0x7)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	data = (GT_U16)(data | (trunkNum << 12));
-
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
-   	if(retVal != GT_OK)
-    {
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-       	return retVal;
+        return GT_NOT_SUPPORTED;
     }
 
-    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-   	if(retVal != GT_OK)
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,13,1,&data);
+    if(retVal != GT_OK)
     {
-   	    DBG_INFO(("Failed.\n"));
-       	return retVal;
+        DBG_INFO(("Failed.\n"));
+        return retVal;
     }
 
-	mask = (1 << dev->maxPorts) - 1;
-
-	*trunkMask = GT_PORTVEC_2_LPORTVEC(data & mask);
-			
+    BIT_2_BOOL(data,*en);
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 /*******************************************************************************
-* gsysSetHashTrunk
+* gsysSetForceFlowControlPri
 *
 * DESCRIPTION:
-*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
-*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
-*		When this bit is set to a one the hashed computed for address table 
-*		lookups is used for the TrunkMask selection. When this bit is cleared to 
-*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
-*		select the TrunkMask to use.
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*        Flow Control frames will be set to the value of the FC Pri bits (set by 
+*        gsysSetFCPri function call). When this bit is cleared to a zero generated 
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*        frames that caused the congestion. This bit will have no effect if the 
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*        cleared to a zero.
 *
 * INPUTS:
-*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetHashTrunk
+GT_STATUS gsysSetForceFlowControlPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
-    DBG_INFO(("gsysSetHashTrunk Called.\n"));
+    DBG_INFO(("gsysSetForceFlowControlPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK|DEV_REDUCED_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
 
     /* Set related bit */
-    retVal = hwSetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL, 11, 1, data);
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 7, 1, data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3809,52 +3622,53 @@ GT_STATUS gsysSetHashTrunk
 }
 
 /*******************************************************************************
-* gsysGetHashTrunk
+* gsysGetForceFlowControlPri
 *
 * DESCRIPTION:
-*		Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
-*		by using the frame's DA and SA fields to access one of eight Trunk Masks. 
-*		When this bit is set to a one the hashed computed for address table 
-*		lookups is used for the TrunkMask selection. When this bit is cleared to 
-*		a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
-*		select the TrunkMask to use.
+*        When this bit is set to a one the PRI[2:0] bits of generated Marvell Tag 
+*        Flow Control frames will be set to the value of the FC Pri bits (set by 
+*        gsysSetFCPri function call). When this bit is cleared to a zero generated 
+*        Marvell Tag Flow Control frames will retain the PRI[2:0] bits from the 
+*        frames that caused the congestion. This bit will have no effect if the 
+*        FlowControlMessage bit(gsysSetFlowControlMessage function call) is 
+*        cleared to a zero.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetHashTrunk
+GT_STATUS gsysGetForceFlowControlPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetHashTrunk Called.\n"));
+    DBG_INFO(("gsysGetForceFlowControlPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK|DEV_REDUCED_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
-    retVal = hwGetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL,11,1,&data);
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,7,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3867,96 +3681,54 @@ GT_STATUS gsysGetHashTrunk
 }
 
 /*******************************************************************************
-* gsysSetTrunkRouting
+* gsysSetFCPri
 *
 * DESCRIPTION:
-*		This function sets routing information for the given Trunk ID.
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
 *
 * INPUTS:
-*		trunkId - Trunk ID.
-*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
-*					bit 1 for port 1 , etc.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId > 0xF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
-*
-* GalTis:
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetTrunkRouting
+GT_STATUS gsysSetFCPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		trunkId,
-	IN GT_U32		trunkRoute
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-	GT_U32			mask;
-	GT_U32			maxTrunk;
 
-    DBG_INFO(("gsysSetTrunkRouting Called.\n"));
+    DBG_INFO(("gsysSetFCPri Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
-		maxTrunk = 8;
-	else
-		maxTrunk = 16;
-
-	if(trunkId >= maxTrunk)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	mask = (1 << dev->numOfPorts) - 1;
-
-	if(trunkRoute > mask)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkRoute)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	mask = GT_LPORTVEC_2_PORTVEC(trunkRoute);
-
-	data = (GT_U16)(0x8000 | (trunkId << 11) | mask);
-
-    /* Set related register */
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
-
-	gtSemGive(dev,dev->tblRegsSem);
+    if (pri > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
 
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 4, 3, pri);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -3968,162 +3740,1226 @@ GT_STATUS gsysSetTrunkRouting
 }
 
 /*******************************************************************************
-* gsysGetTrunkRouting
+* gsysGetFCPri
 *
 * DESCRIPTION:
-*		This function retrieves routing information for the given Trunk ID.
+*        These bits are used as the PRI[2:0] bits on generated Marvell Tag Flow 
+*        Control frames if the ForceFlowControlPri bit(gsysSetForceFlowControlPri)
+*        is set to a one.
 *
 * INPUTS:
-*		trunkId - Trunk ID.
+*        None.
 *
 * OUTPUTS:
-*		trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
-*					bit 1 for port 1 , etc.
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if trunkId > 0xF.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
-GT_STATUS gsysGetTrunkRouting
+GT_STATUS gsysGetFCPri
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		trunkId,
-	OUT GT_U32		*trunkRoute
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-    GT_U16          data;           /* The register's read data.    */
-	GT_U32			mask;
-	GT_U32			maxTrunk;
-
-    DBG_INFO(("gsysGetTrunkRouting Called.\n"));
+    DBG_INFO(("gsysGetFCPri Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MARVELL_TAG_FLOW_CTRL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-    }
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	/* Check if the register can be accessed. */
-	do
-	{
-	    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
-    	if(retVal != GT_OK)
-	    {
-    	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-        	return retVal;
-	    }
-	} while (data & 0x8000);
-
-	if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
-		maxTrunk = 8;
-	else
-		maxTrunk = 16;
-
-	if(trunkId >= maxTrunk)
-	{
-		DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-		return GT_BAD_PARAM;
-	}
-
-	data = (GT_U16)(trunkId << 11);
-
-    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
-   	if(retVal != GT_OK)
-    {
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-       	return retVal;
+        return GT_NOT_SUPPORTED;
     }
 
-    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
-	gtSemGive(dev,dev->tblRegsSem);
-   	if(retVal != GT_OK)
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT,4,3,pri);
+    if(retVal != GT_OK)
     {
-   	    DBG_INFO(("Failed.\n"));
-       	return retVal;
+        DBG_INFO(("Failed.\n"));
+        return retVal;
     }
 
-	mask = (1 << dev->maxPorts) - 1;
-
-	*trunkRoute = GT_PORTVEC_2_LPORTVEC(data & mask);
-			
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 
 /*******************************************************************************
-* gsysSetRateLimitMode
+* gsysSetFlowCtrlDelay
 *
 * DESCRIPTION:
-*		Ingress Rate Limiting can be either Priority based or Burst Size based.
-*		This routine sets which mode to use.
+*        This function sets Flow control delay time for 10Mbps, 100Mbps, and 
+*        1000Mbps. 
 *
 * INPUTS:
-*		mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*        delayTime - delay time.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if invalid mode is used.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*    Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on 
+*    switch device. Please refer to the device datasheet for detailed information.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRateLimitMode
+GT_STATUS gsysSetFlowCtrlDelay
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_INGRESS_RATE_MODE mode
+    IN GT_QD_DEV            *dev,
+    IN GT_PORT_SPEED_MODE    sp,
+    IN GT_U32                delayTime
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetFlowCtrlDelay Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_FLOWCTRL_DELAY;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    switch(sp)
+    {
+        case PORT_SPEED_10_MBPS:
+                data = 0;
+                break;
+        case PORT_SPEED_100_MBPS:
+                data = 1 << 13;
+                break;
+        case PORT_SPEED_1000_MBPS:
+                data = 2 << 13;
+                break;
+        default:
+                DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_BAD_PARAM;
+    }
+
+    if (delayTime > 0x1FFF)
+    {
+        DBG_INFO(("GT_BAD_PARAM (delayTime)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    data |= (GT_U16)(0x8000 | delayTime);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetFlowCtrlDelay
+*
+* DESCRIPTION:
+*        This function retrieves Flow control delay time for 10Mbps, 100Mbps, and
+*        1000Mbps. 
+*
+* INPUTS:
+*        sp - PORT_SPEED_10_MBPS, PORT_SPEED_100_MBPS, or PORT_SPEED_1000_MBPS
+*
+* OUTPUTS:
+*        delayTime - delay time
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*    Actual delay time will be delayTime x 2.048uS (or x 8.192uS) depending on 
+*    switch device. Please refer to the device datasheet for detailed information.
+*
+*******************************************************************************/
+GT_STATUS gsysGetFlowCtrlDelay
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_PORT_SPEED_MODE    sp,
+    OUT GT_U32        *delayTime
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetFlowCtrlDelay Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOW_CTRL_DELAY))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_FLOWCTRL_DELAY;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    switch(sp)
+    {
+        case PORT_SPEED_10_MBPS:
+                data = 0;
+                break;
+        case PORT_SPEED_100_MBPS:
+                data = 1 << 13;
+                break;
+        case PORT_SPEED_1000_MBPS:
+                data = 2 << 13;
+                break;
+        default:
+                DBG_INFO(("GT_BAD_PARAM (sp)\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_BAD_PARAM;
+    }
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_FLOWCTRL_DELAY,&data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *delayTime = (GT_U32)(data & 0x1FFF);
+        
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function sets Device to Port mapping (which device is connected to 
+*        which port of this device). 
+*
+* INPUTS:
+*        devNum - target device number.
+*        portNum - the logical port number.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetDevRoutingTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          devNum,
+    IN GT_LPORT     port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U8           hwPort;         /* the physical port number     */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetDevRoutingTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if(devNum > 0x1F)
+    {
+        DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_ROUTING_TBL;
+      /* translate LPORT to hardware port */
+      if(port >= dev->numOfPorts)
+      {
+        hwPort = 0xF;
+      }
+      else
+      {
+        hwPort = GT_LPORT_2_PORT(port);
+      }
+      data = (GT_U16)(0x8000 | (devNum << 8) | hwPort);
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    /* translate LPORT to hardware port */
+    if(port >= dev->numOfPorts)
+    {
+        hwPort = 0xF;
+    }
+    else
+    {
+        hwPort = GT_LPORT_2_PORT(port);
+    }
+
+    data = (GT_U16)(0x8000 | (devNum << 8) | hwPort);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+#endif
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetDevRoutingTable
+*
+* DESCRIPTION:
+*        This function gets Device to Port mapping (which device is connected to 
+*        which port of this device). 
+*
+* INPUTS:
+*        devNum - target device number.
+*
+* OUTPUTS:
+*        portNum - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sp is not valid or delayTime is > 0x1FFF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetDevRoutingTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         devNum,
+    OUT GT_LPORT     *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetDevRoutingTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_STACKING))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if(devNum > 0x1F)
+    {
+        DBG_INFO(("GT_BAD_PARAM (devNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_ROUTING_TBL;
+      data = (GT_U16)(devNum << 8);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_ROUTING_TBL;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    data = (GT_U16)(devNum << 8);
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_ROUTING_TBL,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_ROUTING_TBL,&data);
+
+#endif
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    *port = GT_PORT_2_LPORT((GT_U8)(data & 0xF));
+    if(*port == GT_INVALID_PORT)
+    {
+        *port = 0xF;
+    }    
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function sets Trunk Mask for the given Trunk Number.
+*
+* INPUTS:
+*        trunkNum - Trunk Number.
+*        trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
+*                       if trunkNum > 0x3 for 88E6065 family.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkMaskTable
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkNum,
+    IN GT_U32        trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+
+    DBG_INFO(("gsysSetTrunkMaskTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    data &= 0x0800;
+
+    if(trunkNum > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = (1 << dev->numOfPorts) - 1;
+
+    if(trunkMask > mask)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkMask)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = GT_LPORTVEC_2_PORTVEC(trunkMask);
+
+    data = (GT_U16)(0x8000 | data | (trunkNum << 12) | mask);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkMaskTable
+*
+* DESCRIPTION:
+*        This function gets Trunk Mask for the given Trunk Number.
+*
+* INPUTS:
+*        trunkNum - Trunk Number.
+*
+* OUTPUTS:
+*        trunkMask - Trunk mask bits. Bit 0 controls trunk masking for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkNum > 0x7 for 88E6095 and 88E6183 family and
+*                       if trunkNum > 0x3 for 88E6065 family.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkMaskTable
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkNum,
+    OUT GT_U32        *trunkMask
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+
+    DBG_INFO(("gsysGetTrunkMaskTable Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_MASK_TBL;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    data &= 0x0800;
+
+    if(trunkNum > 0x7)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    if((trunkNum > 0x3) && IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkNum)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    data = (GT_U16)(data | (trunkNum << 12));
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_MASK_TBL,&data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    mask = (1 << dev->maxPorts) - 1;
+
+    *trunkMask = GT_PORTVEC_2_LPORTVEC(data & mask);
+            
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*        When this bit is set to a one the hashed computed for address table 
+*        lookups is used for the TrunkMask selection. When this bit is cleared to 
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetHashTrunk
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
+
+    DBG_INFO(("gsysSetHashTrunk Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetHashTrunk
+*
+* DESCRIPTION:
+*        Hash DA & SA for TrunkMask selection. Trunk load balancing is accomplished 
+*        by using the frame's DA and SA fields to access one of eight Trunk Masks. 
+*        When this bit is set to a one the hashed computed for address table 
+*        lookups is used for the TrunkMask selection. When this bit is cleared to 
+*        a zero the lower 3 bits of the frame's DA and SA are XOR'ed together to 
+*        select the TrunkMask to use.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        en - GT_TRUE to use lookup table, GT_FALSE to use XOR.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetHashTrunk
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetHashTrunk Called.\n"));
+
+    /* Check if Switch supports this feature. */
+    if (!((IS_IN_DEV_GROUP(dev,DEV_TRUNK)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_REDUCED_TRUNK))))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_TRUNK_MASK_TBL,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetTrunkRouting
+*
+* DESCRIPTION:
+*        This function sets routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysSetTrunkRouting
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          trunkId,
+    IN GT_U32        trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+    GT_U32            maxTrunk;
+
+    DBG_INFO(("gsysSetTrunkRouting Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+#endif
+
+    if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+        maxTrunk = 8;
+    else
+        maxTrunk = 16;
+
+    if(trunkId >= maxTrunk)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = (1 << dev->numOfPorts) - 1;
+
+    if(trunkRoute > mask)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkRoute)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    mask = GT_LPORTVEC_2_PORTVEC(trunkRoute);
+
+    data = (GT_U16)(0x8000 | (trunkId << 11) | mask);
+
+    /* Set related register */
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetTrunkRouting
+*
+* DESCRIPTION:
+*        This function retrieves routing information for the given Trunk ID.
+*
+* INPUTS:
+*        trunkId - Trunk ID.
+*
+* OUTPUTS:
+*        trunkRoute - Trunk route bits. Bit 0 controls trunk routing for port 0,
+*                    bit 1 for port 1 , etc.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if trunkId > 0xF.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+* GalTis:
+*
+*******************************************************************************/
+GT_STATUS gsysGetTrunkRouting
+(
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         trunkId,
+    OUT GT_U32        *trunkRoute
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    GT_U32            mask;
+    GT_U32            maxTrunk;
+
+    DBG_INFO(("gsysGetTrunkRouting Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TRUNK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_8_TRUNKING))
+        maxTrunk = 8;
+    else
+        maxTrunk = 16;
+
+    if(trunkId >= maxTrunk)
+    {
+        DBG_INFO(("GT_BAD_PARAM (trunkId)\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return GT_BAD_PARAM;
+    }
+
+    /* Check if the register can be accessed. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_TRUNK_ROUTING;
+      data = (GT_U16)(trunkId << 11);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_TRUNK_ROUTING;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+    do
+    {
+        retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+        if(retVal != GT_OK)
+        {
+            DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    } while (data & 0x8000);
+
+    data = (GT_U16)(trunkId << 11);
+
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,data);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
+    }
+
+    retVal = hwReadGlobal2Reg(dev,QD_REG_TRUNK_ROUTING,&data);
+#endif
+    gtSemGive(dev,dev->tblRegsSem);
+       if(retVal != GT_OK)
+    {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
+    }
+
+    mask = (1 << dev->maxPorts) - 1;
+
+    *trunkRoute = GT_PORTVEC_2_LPORTVEC(data & mask);
+            
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRateLimitMode
+*
+* DESCRIPTION:
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine sets which mode to use.
+*
+* INPUTS:
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if invalid mode is used.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRateLimitMode
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_INGRESS_RATE_MODE mode
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
     GT_U8           hwPort;         /* the physical port number     */
 
     DBG_INFO(("gsysSetRateLimitMode Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_2))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
-	switch (mode)
-	{
-		case GT_RATE_PRI_BASE:
-			data = 0;
-			break;
-		case GT_RATE_BURST_BASE:
-			data = 1;
-			break;
-		default:
-	        DBG_INFO(("Not supported mode %i\n",mode));
-			return GT_BAD_PARAM;
-	}
+    switch (mode)
+    {
+        case GT_RATE_PRI_BASE:
+            data = 0;
+            break;
+        case GT_RATE_BURST_BASE:
+            data = 1;
+            break;
+        default:
+            DBG_INFO(("Not supported mode %i\n",mode));
+            return GT_BAD_PARAM;
+    }
 
     hwPort = 7;
 
@@ -4143,49 +4979,49 @@ GT_STATUS gsysSetRateLimitMode
 * gsysGetRateLimitMode
 *
 * DESCRIPTION:
-*		Ingress Rate Limiting can be either Priority based or Burst Size based.
-*		This routine gets which mode is being used.
+*        Ingress Rate Limiting can be either Priority based or Burst Size based.
+*        This routine gets which mode is being used.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
+*        mode - either GT_RATE_PRI_BASE or GT_RATE_BURST_BASE
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetRateLimitMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_INGRESS_RATE_MODE *mode
+    IN  GT_QD_DEV    *dev,
+    OUT GT_INGRESS_RATE_MODE *mode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
     GT_U8           hwPort;         /* the physical port number     */
 
     DBG_INFO(("gsysGetRateLimitMode Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_2))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_BURST_RATE))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     hwPort = 7;
-	data = 0;
+    data = 0;
 
     /* Get related bit */
     retVal = hwGetPortRegField(dev,hwPort, 0x1A, 15, 1, &data);
@@ -4195,10 +5031,10 @@ GT_STATUS gsysGetRateLimitMode
         return retVal;
     }
 
-	if (data == 0)
-		*mode = GT_RATE_PRI_BASE;
-	else
-		*mode = GT_RATE_BURST_BASE;
+    if (data == 0)
+        *mode = GT_RATE_PRI_BASE;
+    else
+        *mode = GT_RATE_BURST_BASE;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -4209,73 +5045,73 @@ GT_STATUS gsysGetRateLimitMode
 * gsysSetAgeInt
 *
 * DESCRIPTION:
-*		Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
-*		used (gprtSetLockedPort), it may be desirable to know when an address is
-*		still being used before it totally ages out of the switch. This can be 
-*		accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
-*		An ATU Age Violation looks identical to and reported the same as an ATU 
-*		Miss Violation. The only difference is when this reported. Normal ATU Miss
-*		Violation only occur if a new SA arrives at a LockedPort. The Age version 
-*		of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
-*		the address is contained in the ATU's database, but where its EntryState 
-*		is less than 0x4 (i.e., it has aged more than 1/2 way).
-*		GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
-*		Refer to eventSetActive routine to enable GT_ATU_PROB.
-*
-*		If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
-*		the feature must not be enabled for this Miss Violation to occur.
+*        Enable/Disable Age Refresh Interrupt. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be 
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU 
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version 
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState 
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*        If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
+*        the feature must not be enabled for this Miss Violation to occur.
 *
 * INPUTS:
-*		en - GT_TRUE, to enable,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, to enable,
+*             GT_FALSE, otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetAgeInt
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
     GT_U8           hwPort;         /* the physical port number     */
 
     DBG_INFO(("gsysSetAgeInt Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_2))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
     BOOL_2_BIT(en, data);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
-	{
-	    retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, data);
-	}
-	else
-	{
-	    hwPort = 7;
-	    /* Set related bit */
-    	retVal = hwSetPortRegField(dev,hwPort, 0x1A, 14, 1, data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
+    {
+        retVal = hwSetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, data);
+    }
+    else
+    {
+        hwPort = 7;
+        /* Set related bit */
+        retVal = hwSetPortRegField(dev,hwPort, 0x1A, 14, 1, data);
+    }
 
     if(retVal != GT_OK)
     {
@@ -4291,73 +5127,73 @@ GT_STATUS gsysSetAgeInt
 * gsysGetAgeInt
 *
 * DESCRIPTION:
-*		Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
-*		used (gprtSetLockedPort), it may be desirable to know when an address is
-*		still being used before it totally ages out of the switch. This can be 
-*		accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
-*		An ATU Age Violation looks identical to and reported the same as an ATU 
-*		Miss Violation. The only difference is when this reported. Normal ATU Miss
-*		Violation only occur if a new SA arrives at a LockedPort. The Age version 
-*		of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
-*		the address is contained in the ATU's database, but where its EntryState 
-*		is less than 0x4 (i.e., it has aged more than 1/2 way).
-*		GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
-*		Refer to eventSetActive routine to enable GT_ATU_PROB.
-*
-*		If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
-*		the feature must not be enabled for this Miss Violation to occur.
+*        Get state of Age Refresh Interrupt mode. If CPU Directed Learning is being
+*        used (gprtSetLockedPort), it may be desirable to know when an address is
+*        still being used before it totally ages out of the switch. This can be 
+*        accomplished by enabling Age Refresh Interrupt (or ATU Age Violation Int).
+*        An ATU Age Violation looks identical to and reported the same as an ATU 
+*        Miss Violation. The only difference is when this reported. Normal ATU Miss
+*        Violation only occur if a new SA arrives at a LockedPort. The Age version 
+*        of the ATU Miss Violation occurs if an SA arrives at a LockedPort, where
+*        the address is contained in the ATU's database, but where its EntryState 
+*        is less than 0x4 (i.e., it has aged more than 1/2 way).
+*        GT_ATU_PROB Interrupt should be enabled for this interrupt to occur.
+*        Refer to eventSetActive routine to enable GT_ATU_PROB.
+*
+*        If the device supports Refresh Locked feature (gprtSetRefreshLocked API),
+*        the feature must not be enabled for this Miss Violation to occur.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE, if enabled,
-*			 GT_FALSE, otherwise.
+*        en - GT_TRUE, if enabled,
+*             GT_FALSE, otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetAgeInt
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
     GT_U8           hwPort;         /* the physical port number     */
 
     DBG_INFO(("gsysGetAgeInt Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
-	{
-		if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
-			((GT_DEVICE_REV)dev->revision < GT_REV_2))
-	    {
-    	    DBG_INFO(("GT_NOT_SUPPORTED\n"));
-			return GT_NOT_SUPPORTED;
-	    }
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_AGE_INTERRUPT))
+    {
+        if (!IS_IN_DEV_GROUP(dev,DEV_NEW_FEATURE_IN_REV) || 
+            ((GT_DEVICE_REV)dev->revision < GT_REV_2))
+        {
+            DBG_INFO(("GT_NOT_SUPPORTED\n"));
+            return GT_NOT_SUPPORTED;
+        }
+    }
 
-	data = 0;
+    data = 0;
 
-	if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
-	{
-	    retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, &data);
-	}
-	else
-	{
- 	   hwPort = 7;
-    	/* Get related bit */
-	    retVal = hwGetPortRegField(dev,hwPort, 0x1A, 14, 1, &data);
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_AGE_INT_GLOBAL2))
+    {
+        retVal = hwGetGlobal2RegField(dev,QD_REG_MANAGEMENT, 10, 1, &data);
+    }
+    else
+    {
+        hwPort = 7;
+        /* Get related bit */
+        retVal = hwGetPortRegField(dev,hwPort, 0x1A, 14, 1, &data);
+    }
 
     if(retVal != GT_OK)
     {
@@ -4376,42 +5212,42 @@ GT_STATUS gsysGetAgeInt
 * gsysSetForceSnoopPri
 *
 * DESCRIPTION:
-*		Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
-*		set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
 *       Priority is enabled. When it's disabled, the priority on these frames
-*		is not modified.
+*        is not modified.
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetForceSnoopPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetForceSnoopPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -4432,43 +5268,43 @@ GT_STATUS gsysSetForceSnoopPri
 * gsysGetForceSnoopPri
 *
 * DESCRIPTION:
-*		Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
-*		set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
+*        Force Snooping Priority. The priority on IGMP or MLD Snoop frames are
+*        set to the SnoopPri value (gsysSetSnoopPri API) when Force Snooping
 *       Priority is enabled. When it's disabled, the priority on these frames
-*		is not modified.
+*        is not modified.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetForceSnoopPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetForceSnoopPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -4488,49 +5324,49 @@ GT_STATUS gsysGetForceSnoopPri
 * gsysSetSnoopPri
 *
 * DESCRIPTION:
-*		Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
 *       this priority is used as the egressing frame's PRI[2:0] bits on generated
 *       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
 *       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetSnoopPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetSnoopPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (pri > 0x7)
-	{
+    if (pri > 0x7)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
     retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 4, 3, pri);
@@ -4548,42 +5384,42 @@ GT_STATUS gsysSetSnoopPri
 * gsysGetSnoopPri
 *
 * DESCRIPTION:
-*		Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
+*        Snoop Priority. When ForceSnoopPri (gsysSetForceSnoopPri API) is enabled,
 *       this priority is used as the egressing frame's PRI[2:0] bits on generated
 *       Marvell Tag To_CPU Snoop frames and higher 2 bits of the priority are
 *       used as the internal Queue Priority to use on IGMP/MLD snoop frames.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetSnoopPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     DBG_INFO(("gsysGetSnoopPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SNOOP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -4603,41 +5439,41 @@ GT_STATUS gsysGetSnoopPri
 * gsysSetForceARPPri
 *
 * DESCRIPTION:
-*		Force ARP Priority. The priority on ARP frames are set to the ARPPri 
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri 
 *       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
 *       disabled, the priority on these frames is not modified.
 *
 * INPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetForceARPPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetForceARPPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -4658,42 +5494,42 @@ GT_STATUS gsysSetForceARPPri
 * gsysGetForceARPPri
 *
 * DESCRIPTION:
-*		Force ARP Priority. The priority on ARP frames are set to the ARPPri 
+*        Force ARP Priority. The priority on ARP frames are set to the ARPPri 
 *       value (gsysSetARPPri API) when Force ARP Priority is enabled. When it's 
 *       disabled, the priority on these frames is not modified.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
+*        en - GT_TRUE to use defined PRI bits, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetForceARPPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetForceARPPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -4713,49 +5549,49 @@ GT_STATUS gsysGetForceARPPri
 * gsysSetARPPri
 *
 * DESCRIPTION:
-*		ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
 *       this priority is used as the egressing frame's PRI[2:0] bits on generated
 *       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
 *       used as the internal Queue Priority to use on ARP frames.
 *
 * INPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - If pri is not less than 8.
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - If pri is not less than 8.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetARPPri
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		pri
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetARPPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (pri > 0x7)
-	{
+    if (pri > 0x7)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
+        return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
     retVal = hwSetGlobal2RegField(dev,QD_REG_PRIORITY_OVERRIDE, 0, 3, pri);
@@ -4773,42 +5609,42 @@ GT_STATUS gsysSetARPPri
 * gsysGetARPPri
 *
 * DESCRIPTION:
-*		ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
+*        ARP Priority. When ForceARPPri (gsysSetForceARPPri API) is enabled,
 *       this priority is used as the egressing frame's PRI[2:0] bits on generated
 *       Marvell Tag To_CPU ARP frames and higher 2 bits of the priority are
 *       used as the internal Queue Priority to use on ARP frames.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		pri - PRI[2:0] bits (should be less than 8)
+*        pri - PRI[2:0] bits (should be less than 8)
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetARPPri
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*pri
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *pri
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     DBG_INFO(("gsysGetARPPri Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ARP_PRI))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -4832,7 +5668,7 @@ GT_STATUS gsysGetARPPri
 *
 * INPUTS:
 *       en - GT_TRUE enables per port scheduling, 
-*			 GT_FALSE disable.
+*             GT_FALSE disable.
 *
 * OUTPUTS:
 *       None.
@@ -4856,10 +5692,10 @@ GT_STATUS gsysSetUsePortSchedule
                                     /* register.                    */
     DBG_INFO(("gsysSetWatchDog Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -4888,7 +5724,7 @@ GT_STATUS gsysSetUsePortSchedule
 *
 * OUTPUTS:
 *       en - GT_TRUE enables per port scheduling, 
-*			 GT_FALSE disable.
+*             GT_FALSE disable.
 *
 * RETURNS:
 *       GT_OK   - on success
@@ -4909,10 +5745,10 @@ GT_STATUS gsysGetUsePortSchedule
                                     /* register.                    */
     DBG_INFO(("gsysSetWatchDog Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
+    if (!IS_IN_DEV_GROUP(dev,DEV_PORT_SCHEDULE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the UsePortSchedule bit.            */
@@ -4934,15 +5770,15 @@ GT_STATUS gsysGetUsePortSchedule
 *
 * DESCRIPTION:
 *       This routine sets Egress Old Header.
-*		When this feature is enabled and frames are egressed with a Marvell Header, 
-*		the format of the Header is slightly modified to be backwards compatible 
-*		with previous devices that used the original Header. Specifically, bit 3
-*		of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
-*		is available in the Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header, 
+*        the format of the Header is slightly modified to be backwards compatible 
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
 *
 * INPUTS:
 *       en - GT_TRUE to enable Old Header Mode,
-*			 GT_FALSE to disable
+*             GT_FALSE to disable
 *
 * OUTPUTS:
 *       None.
@@ -4950,7 +5786,7 @@ GT_STATUS gsysGetUsePortSchedule
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -4963,14 +5799,14 @@ GT_STATUS gsysSetOldHader
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetArpQPri Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
+    if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -4993,23 +5829,23 @@ GT_STATUS gsysSetOldHader
 *
 * DESCRIPTION:
 *       This routine gets Egress Old Header.
-*		When this feature is enabled and frames are egressed with a Marvell Header, 
-*		the format of the Header is slightly modified to be backwards compatible 
-*		with previous devices that used the original Header. Specifically, bit 3
-*		of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
-*		is available in the Header.
+*        When this feature is enabled and frames are egressed with a Marvell Header, 
+*        the format of the Header is slightly modified to be backwards compatible 
+*        with previous devices that used the original Header. Specifically, bit 3
+*        of the Header's 2nd octet is cleared to a zero such that only FPri[2:1]
+*        is available in the Header.
 *
 * INPUTS:
 *       None.
 *
 * OUTPUTS:
 *       en - GT_TRUE to enable Old Header Mode,
-*			 GT_FALSE to disable
+*             GT_FALSE to disable
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -5022,14 +5858,14 @@ GT_STATUS gsysGetOldHader
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysGetArpQPri Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
+    if (!IS_IN_DEV_GROUP(dev,DEV_OLD_HEADER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the OldHader bit.            */
@@ -5052,11 +5888,11 @@ GT_STATUS gsysGetOldHader
 *
 * DESCRIPTION:
 *       This routine determines if recursive tag stripping feature needs to be
-*		disabled.
+*        disabled.
 *
 * INPUTS:
 *       en - GT_TRUE to disable Recursive Tag Stripping,
-*			 GT_FALSE to enable
+*             GT_FALSE to enable
 *
 * OUTPUTS:
 *       None.
@@ -5064,7 +5900,7 @@ GT_STATUS gsysGetOldHader
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -5077,14 +5913,14 @@ GT_STATUS gsysSetRecursiveStrippingDisable
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetRecursiveStrippingDisable Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -5113,12 +5949,12 @@ GT_STATUS gsysSetRecursiveStrippingDisable
 *
 * OUTPUTS:
 *       en - GT_TRUE, if Recursive Tag Stripping is disabled,
-*			 GT_FALSE, otherwise
+*             GT_FALSE, otherwise
 *
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -5131,14 +5967,14 @@ GT_STATUS gsysGetRecursiveStrippingDisable
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysGetRecursiveStrippingDisable Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
+    if (!IS_IN_DEV_GROUP(dev,DEV_RECURSIVE_TAG_STRIP))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the RecursiveStrippingDisable bit.            */
@@ -5161,7 +5997,7 @@ GT_STATUS gsysGetRecursiveStrippingDisable
 *
 * DESCRIPTION:
 *       This routine sets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
-*		frames are destined.
+*        frames are destined.
 *
 * INPUTS:
 *       cpuPort - CPU Port
@@ -5172,7 +6008,7 @@ GT_STATUS gsysGetRecursiveStrippingDisable
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -5192,16 +6028,16 @@ GT_STATUS gsysSetCPUPort
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(cpuPort);
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (cpuPort >= dev->numOfPorts)
-	{
-		return GT_BAD_PARAM;
-	}
+    if (cpuPort >= dev->numOfPorts)
+    {
+        return GT_BAD_PARAM;
+    }
 
     /* Set the CPU Port.            */
     retVal = hwSetGlobalRegField(dev,QD_REG_MANGEMENT_CONTROL,0,3,(GT_U16)hwPort);
@@ -5220,7 +6056,7 @@ GT_STATUS gsysSetCPUPort
 *
 * DESCRIPTION:
 *       This routine gets CPU Port where Rsvd2Cpu frames and IGMP/MLD Snooped 
-*		frames are destined.
+*        frames are destined.
 *
 * INPUTS:
 *       cpuPort - CPU Port
@@ -5231,7 +6067,7 @@ GT_STATUS gsysSetCPUPort
 * RETURNS:
 *       GT_OK   - on success
 *       GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -5248,10 +6084,10 @@ GT_STATUS gsysGetCPUPort
 
     DBG_INFO(("gsysGetCPUPort Called.\n"));
 
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_PORT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the CPU Port.            */
@@ -5274,49 +6110,49 @@ GT_STATUS gsysGetCPUPort
 * gsysSetCPUDest
 *
 * DESCRIPTION:
-*		This routine sets CPU Destination Port. CPU Destination port indicates the
-*		port number on this device where the CPU is connected (either directly or
-*		indirectly through another Marvell switch device).
-*
-*		Many modes of frame processing need to know where the CPU is located.
-*		These modes are:
-*		1. When IGMP/MLD frame is received and Snooping is enabled
-*		2. When the port is configured as a DSA port and it receives a To_CPU frame
-*		3. When a Rsvd2CPU frame enters the port
-*		4. When the port's SA Filtering mode is Drop to CPU
-*		5. When any of the port's Policy Options trap the frame to the CPU
-*		6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
-*		   device
-*
-*		In all cases, except for ARP, the frames that meet the enabled criteria 
-*		are mapped to the CPU Destination port, overriding where the frame would 
-*		normally go. In the case of ARP, the frame will be mapped normally and it 
-*		will also get copied to this port.
-*		Frames that filtered or discarded will not be mapped to the CPU Destination 
-*		port with the exception of the Rsvd2CPU and DSA Tag cases.
-*
-*		If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
-*		will occur and ingressing To_CPU frames will be discarded.
+*        This routine sets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria 
+*        are mapped to the CPU Destination port, overriding where the frame would 
+*        normally go. In the case of ARP, the frame will be mapped normally and it 
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination 
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
+*        will occur and ingressing To_CPU frames will be discarded.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetCPUDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5327,22 +6163,22 @@ GT_STATUS gsysSetCPUDest
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate LPORT to hardware port */
-	if(port == 0xF)
-		hwPort = (GT_U8)port;
-	else
-	{
-	    hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
-		if (hwPort == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
     retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 4, 4, (GT_U16)hwPort);
@@ -5360,60 +6196,60 @@ GT_STATUS gsysSetCPUDest
 * gsysGetCPUDest
 *
 * DESCRIPTION:
-*		This routine gets CPU Destination Port. CPU Destination port indicates the
-*		port number on this device where the CPU is connected (either directly or
-*		indirectly through another Marvell switch device).
-*
-*		Many modes of frame processing need to know where the CPU is located.
-*		These modes are:
-*		1. When IGMP/MLD frame is received and Snooping is enabled
-*		2. When the port is configured as a DSA port and it receives a To_CPU frame
-*		3. When a Rsvd2CPU frame enters the port
-*		4. When the port's SA Filtering mode is Drop to CPU
-*		5. When any of the port's Policy Options trap the frame to the CPU
-*		6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
-*		   device
-*
-*		In all cases, except for ARP, the frames that meet the enabled criteria 
-*		are mapped to the CPU Destination port, overriding where the frame would 
-*		normally go. In the case of ARP, the frame will be mapped normally and it 
-*		will also get copied to this port.
-*		Frames that filtered or discarded will not be mapped to the CPU Destination 
-*		port with the exception of the Rsvd2CPU and DSA Tag cases.
-*
-*		If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
-*		will occur and ingressing To_CPU frames will be discarded.
+*        This routine gets CPU Destination Port. CPU Destination port indicates the
+*        port number on this device where the CPU is connected (either directly or
+*        indirectly through another Marvell switch device).
+*
+*        Many modes of frame processing need to know where the CPU is located.
+*        These modes are:
+*        1. When IGMP/MLD frame is received and Snooping is enabled
+*        2. When the port is configured as a DSA port and it receives a To_CPU frame
+*        3. When a Rsvd2CPU frame enters the port
+*        4. When the port's SA Filtering mode is Drop to CPU
+*        5. When any of the port's Policy Options trap the frame to the CPU
+*        6. When the ingressing frame is an ARP and ARP mirroring is enabled in the
+*           device
+*
+*        In all cases, except for ARP, the frames that meet the enabled criteria 
+*        are mapped to the CPU Destination port, overriding where the frame would 
+*        normally go. In the case of ARP, the frame will be mapped normally and it 
+*        will also get copied to this port.
+*        Frames that filtered or discarded will not be mapped to the CPU Destination 
+*        port with the exception of the Rsvd2CPU and DSA Tag cases.
+*
+*        If CPUDest = 0xF, the remapped frames will be discarded, no ARP mirroring 
+*        will occur and ingressing To_CPU frames will be discarded.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetCPUDest
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetCPUDest Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -5424,14 +6260,14 @@ GT_STATUS gsysGetCPUDest
         return retVal;
     }
 
-	if(data == 0xF)
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
@@ -5441,38 +6277,38 @@ GT_STATUS gsysGetCPUDest
 * gsysSetMirrorDest
 *
 * DESCRIPTION:
-*		This routine sets Mirror Destination Port. Frames that ingress a port 
-*		that trigger a policy mirror are mapped (copied) to this port as long as 
-*		the frame is not filtered or discarded. 
-*		The Mirror Destination port should point to the port that directs these 
-*		frames to the CPU that will process these frames. This target port should 
-*		be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
-*		CPU Code of Policy Mirror.
-*		To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
-*		Tag port will be sent to the port number defined in MirrorDest.
-*
-*		If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
-*		Policy Mirror frames will be discarded.
+*        This routine sets Mirror Destination Port. Frames that ingress a port 
+*        that trigger a policy mirror are mapped (copied) to this port as long as 
+*        the frame is not filtered or discarded. 
+*        The Mirror Destination port should point to the port that directs these 
+*        frames to the CPU that will process these frames. This target port should 
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
+*        Policy Mirror frames will be discarded.
 *
 * INPUTS:
-*		port  - the logical port number.
+*        port  - the logical port number.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetMirrorDest
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT		port
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT        port
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -5483,22 +6319,22 @@ GT_STATUS gsysSetMirrorDest
     /* translate LPORT to hardware port */
     hwPort = GT_LPORT_2_PORT(port);
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_MIRROR_DEST))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_MIRROR_DEST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* translate LPORT to hardware port */
-	if(port == 0xF)
-		hwPort = (GT_U8)port;
-	else
-	{
-	    hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
-		if (hwPort == GT_INVALID_PORT)
-			return GT_BAD_PARAM;
-	}
+    if(port == 0xF)
+        hwPort = (GT_U8)port;
+    else
+    {
+        hwPort = (GT_U8)(GT_LPORT_2_PORT(port));
+        if (hwPort == GT_INVALID_PORT)
+            return GT_BAD_PARAM;
+    }
 
     /* Set related bit */
     retVal = hwSetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 0, 4, (GT_U16)hwPort);
@@ -5516,131 +6352,409 @@ GT_STATUS gsysSetMirrorDest
 * gsysGetMirrorDest
 *
 * DESCRIPTION:
-*		This routine gets Mirror Destination Port. Frames that ingress a port 
-*		that trigger a policy mirror are mapped (copied) to this port as long as 
-*		the frame is not filtered or discarded. 
-*		The Mirror Destination port should point to the port that directs these 
-*		frames to the CPU that will process these frames. This target port should 
-*		be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
-*		CPU Code of Policy Mirror.
-*		To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
-*		Tag port will be sent to the port number defined in MirrorDest.
-*
-*		If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
-*		Policy Mirror frames will be discarded.
+*        This routine gets Mirror Destination Port. Frames that ingress a port 
+*        that trigger a policy mirror are mapped (copied) to this port as long as 
+*        the frame is not filtered or discarded. 
+*        The Mirror Destination port should point to the port that directs these 
+*        frames to the CPU that will process these frames. This target port should 
+*        be a DSA Tag port so the frames will egress with a To_CPU DSA Tag with a 
+*        CPU Code of Policy Mirror.
+*        To_CPU DSA Tag frames with a CPU Code of Policy Mirror that ingress a DSA 
+*        Tag port will be sent to the port number defined in MirrorDest.
+*
+*        If MirrorDest = 0xF, Policy Mirroring is disabled and ingressing To_CPU 
+*        Policy Mirror frames will be discarded.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port  - the logical port number.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysGetMirrorDest
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT      *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    DBG_INFO(("gsysGetMirrorDest Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get related bit */
+    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 0, 4, &data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 0xF)
+    {
+        *port = (GT_LPORT)data;
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT((GT_U8)data);
+    }
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysSetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
+*        device allows logical port 4 and 5.
+*        
+* INPUTS:
+*        port - Remote Management Port
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on unallowable port
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMPort
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_LPORT     port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetRMPort Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* translate LPORT to hardware port */
+    switch(GT_LPORT_2_PORT(port))
+    {
+        case 9:
+                data = 0;
+                break;
+        case 10:
+                data = 1;
+                break;
+        default:
+                DBG_INFO(("Not Allowed Port.\n"));
+                return GT_BAD_PARAM;
+    }
+
+    /* Set the F2R port. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMPort
+*
+* DESCRIPTION:
+*        Remote Management feature is enabled only on one port. Since not all ports
+*        can be enabled for Remote Management feature, please refer to the device
+*        datasheet for detailed information.
+*        For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
+*        device allows logical port 4 and 5.
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        port - Remote Management Port
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
+*
+*******************************************************************************/
+GT_STATUS gsysGetRMPort
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_LPORT     *port
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysGetRMPort Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the F2R port.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    if(data == 1)
+    {
+        *port = GT_PORT_2_LPORT(10);
+    }
+    else
+    {
+        *port = GT_PORT_2_LPORT(9);
+    }
+    
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* gsysSetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames. 
+*        When DA Check is enabled, the DA of Remote Management frames must be 
+*        contained in this device's address database (ATU) as a Static entry 
+*        (either unicast or multicast). If the DA of the frame is not contained 
+*        in this device's address database, the frame will be not be processed as 
+*        a Remote Management frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not 
+*        validated before processing the frame.
+*        
+* INPUTS:
+*        en - GT_TRUE to enable DA Check, 
+*             GT_FALSE otherwise.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*        None.
+*
+*******************************************************************************/
+GT_STATUS gsysSetRMDACheck
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
+)
+{
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+
+    DBG_INFO(("gsysSetRMDACheck Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    if (!IS_IN_DEV_GROUP(dev,DEV_DA_CHECK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    BOOL_2_BIT(en,data);
+
+    if (IS_IN_DEV_GROUP(dev,DEV_DA_CHECK_1))
+    {
+      /* Set the DA Check bit. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,11,1,data);
+    }
+	else
+	{
+      /* Set the DA Check bit. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,data);
+	}
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+}
+
+/*******************************************************************************
+* gsysGetRMDACheck
+*
+* DESCRIPTION:
+*        Check the DA on Remote Management frames. 
+*        When DA Check is enabled, the DA of Remote Management frames must be 
+*        contained in this device's address database (ATU) as a Static entry 
+*        (either unicast or multicast). If the DA of the frame is not contained 
+*        in this device's address database, the frame will be not be processed as 
+*        a Frame-to-Regter frame.
+*        When DA Check is disabled, the DA of Remote Management frames is not 
+*        validated before processing the frame.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		port  - the logical port number.
+*        en - GT_TRUE if DA Check is enabled, 
+*             GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetMirrorDest
+GT_STATUS gsysGetRMDACheck
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT  	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    DBG_INFO(("gsysGetMirrorDest Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CPU_DEST))
+    DBG_INFO(("gsysGetRMDACheck Called.\n"));
+
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get related bit */
-    retVal = hwGetGlobalRegField(dev,QD_REG_MONITOR_CONTROL, 0, 4, &data);
+    if (!IS_IN_DEV_GROUP(dev,DEV_DA_CHECK))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Get the DA Check bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if(data == 0xF)
-	{
-		*port = (GT_LPORT)data;
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT((GT_U8)data);
-	}
+    BIT_2_BOOL(data,*en);
+
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
+
 /*******************************************************************************
-* gsysSetRMPort
+* gsysSetHeaderType
 *
 * DESCRIPTION:
-*		Remote Management feature is enabled only on one port. Since not all ports
-*		can be enabled for Remote Management feature, please refer to the device
-*		datasheet for detailed information.
-*		For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
-*		device allows logical port 4 and 5.
-*		
+*   To set Header Type. These bits are used to configure the bits that are placed 
+*   into the Egress Header when it is enabled on a port (Port offset 0x04) 
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*        
 * INPUTS:
-*		port - Remote Management Port
+*        hdType 
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM     - on unallowable port
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Obsolete. Please uses gsysSetRMUMode API, instead.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMPort
+GT_STATUS gsysSetHeaderType
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_LPORT 	port
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       hdType
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysSetRMPort Called.\n"));
+    DBG_INFO(("gsysSetHeaderType Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_HEADER_TYPE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* translate LPORT to hardware port */
-	switch(GT_LPORT_2_PORT(port))
-	{
-		case 9:
-				data = 0;
-				break;
-		case 10:
-				data = 1;
-				break;
-		default:
-	    	    DBG_INFO(("Not Allowed Port.\n"));
-    	    	return GT_BAD_PARAM;
-	}
-
-    /* Set the F2R port. */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,data);
+    data = hdType&0x3;
+    /* Set the DA Check bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,2,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -5652,121 +6766,112 @@ GT_STATUS gsysSetRMPort
 }
 
 /*******************************************************************************
-* gsysGetRMPort
+* gsysGetHeaderType
 *
 * DESCRIPTION:
-*		Remote Management feature is enabled only on one port. Since not all ports
-*		can be enabled for Remote Management feature, please refer to the device
-*		datasheet for detailed information.
-*		For example, 88E6097 device allows logical port 9 or 10, and 88E6047 
-*		device allows logical port 4 and 5.
-*
+*   To get Header Type. These bits are used to configure the bits that are placed 
+*   into the Egress Header when it is enabled on a port (Port offset 0x04) 
+*   as follows:
+*     00 = Original Header  for backwards compatibility to UniMACs that look at
+*          Header byte 1 bits[4:2] and byte 2 bits [3:0]
+*     01 = Single chip MGMT Header  for compatibility to Marvell Fast Ethernet
+*          switches that support Spanning Tree without DSA Tags
+*     10 = Trunk Header  used together with the DSA Tags to perform Remote Switching
+*     11 = Reserved for future use.
+*        
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		port - Remote Management Port
+*        hdType 
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Obsolete. Please uses gsysGetRMUMode API, instead.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMPort
+GT_STATUS gsysGetHeaderType
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_LPORT 	*port
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16     *hdType
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysGetRMPort Called.\n"));
+    DBG_INFO(("gsysGetHeaderType Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_HEADER_TYPE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get the F2R port.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,13,1,&data);
+    /* Get the DA Check bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,2,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if(data == 1)
-	{
-		*port = GT_PORT_2_LPORT(10);
-	}
-	else
-	{
-	    *port = GT_PORT_2_LPORT(9);
-	}
-    
+    *hdType = data;
+
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
 
 /*******************************************************************************
-* gsysSetRMDACheck
+* gsysSetRMEnable
 *
 * DESCRIPTION:
-*		Check the DA on Remote Management frames. 
-*		When DA Check is enabled, the DA of Remote Management frames must be 
-*		contained in this device's address database (ATU) as a Static entry 
-*		(either unicast or multicast). If the DA of the frame is not contained 
-*		in this device's address database, the frame will be not be processed as 
-*		a Remote Management frame.
-*		When DA Check is disabled, the DA of Remote Management frames is not 
-*		validated before processing the frame.
-*		
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
+*        
 * INPUTS:
-*		en - GT_TRUE to enable DA Check, 
-*			 GT_FALSE otherwise.
+*        en - GT_TRUE to enable Remote Management feature, 
+*             GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        Obsolete. Please uses gsysSetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMDACheck
+GT_STATUS gsysSetRMEnable
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL         en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysSetRMDACheck Called.\n"));
+    DBG_INFO(("gsysSetRMEnable Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
 
-    /* Set the DA Check bit. */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,data);
+    /* Set the F2R En bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -5778,54 +6883,48 @@ GT_STATUS gsysSetRMDACheck
 }
 
 /*******************************************************************************
-* gsysGetRMDACheck
+* gsysGetRMEnable
 *
 * DESCRIPTION:
-*		Check the DA on Remote Management frames. 
-*		When DA Check is enabled, the DA of Remote Management frames must be 
-*		contained in this device's address database (ATU) as a Static entry 
-*		(either unicast or multicast). If the DA of the frame is not contained 
-*		in this device's address database, the frame will be not be processed as 
-*		a Frame-to-Regter frame.
-*		When DA Check is disabled, the DA of Remote Management frames is not 
-*		validated before processing the frame.
+*        Enable or disable Remote Management feature. This feature can be enabled
+*        only on one port (see gsysSetRMPort API).
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if DA Check is enabled, 
-*			 GT_FALSE otherwise.
+*        en - GT_TRUE if Remote Management feature is enabled, 
+*             GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        Obsolete. Please uses gsysGetRMUMode API, instead.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMDACheck
+GT_STATUS gsysGetRMEnable
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL 	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL     *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysGetRMDACheck Called.\n"));
+    DBG_INFO(("gsysGetRMEnable Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get the DA Check bit.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,14,1,&data);
+    /* Get the F2R En bit.                */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -5840,50 +6939,115 @@ GT_STATUS gsysGetRMDACheck
 
 
 /*******************************************************************************
-* gsysSetRMEnable
+* gsysSetRMUMode
 *
 * DESCRIPTION:
-*		Enable or disable Remote Management feature. This feature can be enabled
-*		only on one port (see gsysSetRMPort API).
-*		
+*        Set Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote 
+*        Management Response frame will be generated and sent out.
+*        
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*        
 * INPUTS:
-*		en - GT_TRUE to enable Remote Management feature, 
-*			 GT_FALSE otherwise.
+*        rmu - GT_RMU structure
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Obsolete. Please uses gsysSetRMUMode API, instead.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMEnable
+GT_STATUS gsysSetRMUMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL 		en
+    IN GT_QD_DEV    *dev,
+    IN GT_RMU        *rmu
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
+    GT_U16          port;
 
-    DBG_INFO(("gsysSetRMEnable Called.\n"));
+    DBG_INFO(("gsysSetRMUMode Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    BOOL_2_BIT(en,data);
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        if (rmu->rmuEn == GT_TRUE)
+        {
+            port = GT_LPORT_2_PORT(rmu->port);
+            if (port == GT_INVALID_PORT)
+                return GT_BAD_PARAM;
+
+            switch(port)
+            {
+                case 4:
+                    data = 1;
+                    break;
+                case 5:
+                    data = 2;
+                    break;
+                 case 6:
+                    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+					{
+                      data = 3;
+                      break;
+					}
+                    return GT_BAD_PARAM;
+               default:
+                    return GT_BAD_PARAM;
+            }
+        }
+        else
+        {
+            data = 0;
+        }
+    }
+    else
+    {
+        if (rmu->rmuEn)
+        {
+            port = GT_LPORT_2_PORT(rmu->port);
+            if (port == GT_INVALID_PORT)
+                return GT_BAD_PARAM;
+
+            switch(port)
+            {
+                case 9:
+                    data = 1;
+                    break;
+                case 10:
+                    data = 3;
+                    break;
+                default:
+                    return GT_BAD_PARAM;
+            }
+        }
+        else
+        {
+            data = 0;
+        }
+    }
 
-    /* Set the F2R En bit. */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,data);
+    /* Set the RMUMode bit. */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -5895,164 +7059,172 @@ GT_STATUS gsysSetRMEnable
 }
 
 /*******************************************************************************
-* gsysGetRMEnable
+* gsysGetRMUMode
 *
 * DESCRIPTION:
-*		Enable or disable Remote Management feature. This feature can be enabled
-*		only on one port (see gsysSetRMPort API).
-*
+*        Get Rmote Management Unit Mode: disable, enable on port 4, 5 or 6, or enable
+*        on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
+*        while other devices, such as 88E6165, support RMU on port 4, 5 and 6. So,
+*        please refer to the device datasheet for detail.
+*        When RMU is enabled and this device receives a Remote Management Request
+*        frame directed to this device, the frame will be processed and a Remote 
+*        Management Response frame will be generated and sent out.
+*        
+*        Note: enabling RMU has no effect if the Remote Management port is in half
+*        duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
+*        
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Remote Management feature is enabled, 
-*			 GT_FALSE otherwise.
+*        rmu - GT_RMU structure
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		Obsolete. Please uses gsysGetRMUMode API, instead.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMEnable
+GT_STATUS gsysGetRMUMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL 	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_RMU        *rmu
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysGetRMEnable Called.\n"));
+    DBG_INFO(("gsysGetRMUMode Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get the F2R En bit.                */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,1,&data);
+    /* Get the RMUMode bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,&data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-    BIT_2_BOOL(data,*en);
+    if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
+    {
+        switch (data)
+        {
+            case 0:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+
+            case 1:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(4);
+                    break;
+
+            case 2:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(5);
+                    break;
+            case 3:
+                    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+					{
+                      rmu->rmuEn = GT_TRUE;
+                      rmu->port = GT_PORT_2_LPORT(6);
+                      break;
+					}
+                    return GT_FAIL;
+            default:
+                    return GT_FAIL;
+        }
+    }
+    else
+    {
+        switch (data)
+        {
+            case 0:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+
+            case 1:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(9);
+                    break;
+
+            case 3:
+                    rmu->rmuEn = GT_TRUE;
+                    rmu->port = GT_PORT_2_LPORT(10);
+                    break;
+
+            default:
+                    rmu->rmuEn = GT_FALSE;
+                    break;
+        }
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
 }
 
-
 /*******************************************************************************
-* gsysSetRMUMode
+* gsysSetCtrMode
 *
 * DESCRIPTION:
-*		Set Rmote Management Unit Mode: disable, enable on port 4 or 5, or enable
-*		on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
-*		while other devices, such as 88E6165, support RMU on port 4 and 5. So,
-*		please refer to the device datasheet for detail.
-*		When RMU is enabled and this device receives a Remote Management Request
-*		frame directed to this device, the frame will be processed and a Remote 
-*		Management Response frame will be generated and sent out.
-*		
-*		Note: enabling RMU has no effect if the Remote Management port is in half
-*		duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
-*		
+*        Set Counter Modes. These bits control the operating modes of the two of 
+*        the Ports MIB counters.
+*        
 * INPUTS:
-*		rmu - GT_RMU structure
+*        ctrMode - Counter mode
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM     - on bad parameter
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM     - on bad parameter
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysSetRMUMode
+GT_STATUS gsysSetCtrMode
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_RMU		*rmu
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       ctrMode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
-    GT_U16          port;
 
-    DBG_INFO(("gsysSetRMUMode Called.\n"));
+    DBG_INFO(("gsysSetCtrMode Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
-	{
-		if (rmu->rmuEn == GT_TRUE)
-		{
-			port = GT_LPORT_2_PORT(rmu->port);
-			if (port == GT_INVALID_PORT)
-				return GT_BAD_PARAM;
-
-			switch(port)
-			{
-				case 4:
-					data = 1;
-					break;
-				case 5:
-					data = 2;
-					break;
-				default:
-					return GT_BAD_PARAM;
-			}
-		}
-		else
-		{
-			data = 0;
-		}
-	}
-	else
-	{
-		if (rmu->rmuEn)
-		{
-			port = GT_LPORT_2_PORT(rmu->port);
-			if (port == GT_INVALID_PORT)
-				return GT_BAD_PARAM;
-
-			switch(port)
-			{
-				case 9:
-					data = 1;
-					break;
-				case 10:
-					data = 3;
-					break;
-				default:
-					return GT_BAD_PARAM;
-			}
-		}
-		else
-		{
-			data = 0;
-		}
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+    {
+	  data = ctrMode&0x3;
+      /* Set the Counter Mode. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,5,2,data);
+    }
+    else
+    {
+	  data = ctrMode&0x1;
+      /* Set the Counter Mode. */
+      retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,1,data);
+    }
 
-    /* Set the RMUMode bit. */
-    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,data);
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
@@ -6064,106 +7236,68 @@ GT_STATUS gsysSetRMUMode
 }
 
 /*******************************************************************************
-* gsysGetRMUMode
+* gsysGetCtrMode
 *
 * DESCRIPTION:
-*		Get Rmote Management Unit Mode: disable, enable on port 4 or 5, or enable
-*		on port 9 or 10. Devices, such as 88E6097, support RMU on port 9 and 10, 
-*		while other devices, such as 88E6165, support RMU on port 4 and 5. So,
-*		please refer to the device datasheet for detail.
-*		When RMU is enabled and this device receives a Remote Management Request
-*		frame directed to this device, the frame will be processed and a Remote 
-*		Management Response frame will be generated and sent out.
-*		
-*		Note: enabling RMU has no effect if the Remote Management port is in half
-*		duplex mode. The port's FrameMode must be DSA or EtherType DSA as well.
-*		
+*        Get Counter Modes. These bits control the operating modes of the two of 
+*        the Ports MIB counters.
+*        
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		rmu - GT_RMU structure
+*        ctrMode - Counter mode
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
-GT_STATUS gsysGetRMUMode
+GT_STATUS gsysGetCtrMode
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_RMU		*rmu
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16       *ctrMode
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
 
-    DBG_INFO(("gsysGetRMUMode Called.\n"));
+    DBG_INFO(("gsysGetCtrMode Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FRAME_TO_REGISTER))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_COUNTER_MODE))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-    /* Get the RMUMode bit. */
-    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,12,2,&data);
+    if (IS_IN_DEV_GROUP(dev,DEV_88E6352_FAMILY))
+    {
+      /* Set the Counter Mode. */
+      retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,5,2, &data);
+    }
+    else
+    {
+      /* Set the Counter Mode. */
+      retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL2,0,1, &data);
+    }
     if(retVal != GT_OK)
     {
         DBG_INFO(("Failed.\n"));
         return retVal;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_RMU_MODE))
-	{
-		switch (data)
-		{
-			case 0:
-					rmu->rmuEn = GT_FALSE;
-					break;
-
-			case 1:
-					rmu->rmuEn = GT_TRUE;
-					rmu->port = GT_PORT_2_LPORT(4);
-					break;
-
-			case 2:
-					rmu->rmuEn = GT_TRUE;
-					rmu->port = GT_PORT_2_LPORT(5);
-					break;
-
-			default:
-					return GT_FAIL;
-		}
-	}
-	else
-	{
-		switch (data)
-		{
-			case 0:
-					rmu->rmuEn = GT_FALSE;
-					break;
-
-			case 1:
-					rmu->rmuEn = GT_TRUE;
-					rmu->port = GT_PORT_2_LPORT(9);
-					break;
-
-			case 3:
-					rmu->rmuEn = GT_TRUE;
-					rmu->port = GT_PORT_2_LPORT(10);
-					break;
-
-			default:
-					rmu->rmuEn = GT_FALSE;
-					break;
-		}
-	}
+	*ctrMode = data;
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -6174,45 +7308,45 @@ GT_STATUS gsysGetRMUMode
 * gsysSetRsvd2CpuEnables2X
 *
 * DESCRIPTION:
-*		Reserved DA Enables for the form of 01:80:C2:00:00:2x.
-*		When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
-*		multicast DA addresses, whose bit in this register are also set to a one, 
-*		are treadted as MGMT frames. All the reserved DA's take the form 
-*		01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
-*		When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
+*        multicast DA addresses, whose bit in this register are also set to a one, 
+*        are treadted as MGMT frames. All the reserved DA's take the form 
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetRsvd2CpuEnables2X
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U16		enBits
+    IN GT_QD_DEV    *dev,
+    IN GT_U16        enBits
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysSetRsvd2CpuEnables2X Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Set related register */
@@ -6231,45 +7365,45 @@ GT_STATUS gsysSetRsvd2CpuEnables2X
 * gsysGetRsvd2CpuEnables2X
 *
 * DESCRIPTION:
-*		Reserved DA Enables for the form of 01:80:C2:00:00:2x.
-*		When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
-*		multicast DA addresses, whose bit in this register are also set to a one, 
-*		are treadted as MGMT frames. All the reserved DA's take the form 
-*		01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
-*		When x = 0x2, bit 2 of this field is tested and so on.
-*		If the tested bit in this register is cleared to a zero, the frame will 
-*		be treated as a normal (non-MGMT) frame.
+*        Reserved DA Enables for the form of 01:80:C2:00:00:2x.
+*        When the Rsvd2Cpu(gsysSetRsvd2Cpu) is set to a one, the 16 reserved 
+*        multicast DA addresses, whose bit in this register are also set to a one, 
+*        are treadted as MGMT frames. All the reserved DA's take the form 
+*        01:80:C2:00:00:2x. When x = 0x0, bit 0 of this register is tested. 
+*        When x = 0x2, bit 2 of this field is tested and so on.
+*        If the tested bit in this register is cleared to a zero, the frame will 
+*        be treated as a normal (non-MGMT) frame.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		enBits - bit vector of enabled Reserved Multicast.
+*        enBits - bit vector of enabled Reserved Multicast.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetRsvd2CpuEnables2X
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U16  	*enBits
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16      *enBits
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
 
     DBG_INFO(("gsysGetRsvd2CpuEnables2X Called.\n"));
 
-	/* Check if Switch supports this status. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
+    /* Check if Switch supports this status. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ENHANCED_MULTICAST_2X))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related register */
@@ -6289,43 +7423,43 @@ GT_STATUS gsysGetRsvd2CpuEnables2X
 * gsysSetLoopbackFilter
 *
 * DESCRIPTION:
-*		Loopback Filter.
-*		When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
-*		that came from the same Src_Dev will be filtered to the same Src_Port,
-*		i.e., the frame will not be allowed to egress the source port on the 
-*		source device as indicated in the DSA Forward's Tag.
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the 
+*        source device as indicated in the DSA Forward's Tag.
 *
 * INPUTS:
-*		en - GT_TRUE to enable LoopbackFilter, GT_FALSE otherwise.
+*        en - GT_TRUE to enable LoopbackFilter, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetLoopbackFilter
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetLoopbackFilter Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6346,42 +7480,42 @@ GT_STATUS gsysSetLoopbackFilter
 * gsysGetLoopbackFilter
 *
 * DESCRIPTION:
-*		Loopback Filter.
-*		When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
-*		that came from the same Src_Dev will be filtered to the same Src_Port,
-*		i.e., the frame will not be allowed to egress the source port on the 
-*		source device as indicated in the DSA Forward's Tag.
+*        Loopback Filter.
+*        When Loopback Filter is enabled,Forward DSA frames that ingress a DSA port
+*        that came from the same Src_Dev will be filtered to the same Src_Port,
+*        i.e., the frame will not be allowed to egress the source port on the 
+*        source device as indicated in the DSA Forward's Tag.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if LoopbackFilter is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if LoopbackFilter is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetLoopbackFilter
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetLoopbackFilter Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_LOOPBACK_FILTER))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -6402,46 +7536,46 @@ GT_STATUS gsysGetLoopbackFilter
 * gsysSetFloodBC
 *
 * DESCRIPTION:
-*		Flood Broadcast.
-*		When Flood Broadcast is enabled, frames with the Broadcast destination 
-*		address will flood out all the ports regardless of the setting of the
-*		port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
-*		other switch policy still applies to these Broadcast frames. 
-*		When this feature is disabled, frames with the Broadcast destination
-*		address are considered Multicast frames and will be affected by port's 
-*		Egress Floods mode.
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination 
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
+*        other switch policy still applies to these Broadcast frames. 
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's 
+*        Egress Floods mode.
 *
 * INPUTS:
-*		en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
+*        en - GT_TRUE to enable Flood Broadcast, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetFloodBC
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetFloodBC Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6462,45 +7596,45 @@ GT_STATUS gsysSetFloodBC
 * gsysGetFloodBC
 *
 * DESCRIPTION:
-*		Flood Broadcast.
-*		When Flood Broadcast is enabled, frames with the Broadcast destination 
-*		address will flood out all the ports regardless of the setting of the
-*		port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
-*		other switch policy still applies to these Broadcast frames. 
-*		When this feature is disabled, frames with the Broadcast destination
-*		address are considered Multicast frames and will be affected by port's 
-*		Egress Floods mode.
+*        Flood Broadcast.
+*        When Flood Broadcast is enabled, frames with the Broadcast destination 
+*        address will flood out all the ports regardless of the setting of the
+*        port's Egress Floods mode (see gprtSetEgressFlood API). VLAN rules and 
+*        other switch policy still applies to these Broadcast frames. 
+*        When this feature is disabled, frames with the Broadcast destination
+*        address are considered Multicast frames and will be affected by port's 
+*        Egress Floods mode.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if Flood Broadcast is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetFloodBC
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetFloodBC Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_FLOOD_BROADCAST))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -6521,48 +7655,48 @@ GT_STATUS gsysGetFloodBC
 * gsysSetRemove1PTag
 *
 * DESCRIPTION:
-*		Remove One Provider Tag.
-*		When this feature is enabled and a port is configured as a Provider Port
-*		(see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
-*		performed. Only the first Provider Tag found on the frame will be 
-*		extracted and removed. Its extracted data will be used for switching.
-*		When it's disabled and a port is configured as a Provider Port, recursive 
-*		Provider Tag stripping will be performed. The first Provider Tag's data 
-*		will be extracted and used for switching, and then all subsequent Provider 
-*		Tags found in the frame will also be removed. This will only occur if the 
-*		port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
+*        performed. Only the first Provider Tag found on the frame will be 
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive 
+*        Provider Tag stripping will be performed. The first Provider Tag's data 
+*        will be extracted and used for switching, and then all subsequent Provider 
+*        Tags found in the frame will also be removed. This will only occur if the 
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
 *
 * INPUTS:
-*		en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
+*        en - GT_TRUE to enable Remove One Provider Tag, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetRemove1PTag
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetRemove1PTag Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6584,48 +7718,48 @@ GT_STATUS gsysSetRemove1PTag
 * gsysGetRemove1PTag
 *
 * DESCRIPTION:
-*		Remove One Provider Tag.
-*		When this feature is enabled and a port is configured as a Provider Port
-*		(see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
-*		performed. Only the first Provider Tag found on the frame will be 
-*		extracted and removed. Its extracted data will be used for switching.
-*		When it's disabled and a port is configured as a Provider Port, recursive 
-*		Provider Tag stripping will be performed. The first Provider Tag's data 
-*		will be extracted and used for switching, and then all subsequent Provider 
-*		Tags found in the frame will also be removed. This will only occur if the 
-*		port's PortEType (see gprtSetPortEType API) is not 0x8100.
+*        Remove One Provider Tag.
+*        When this feature is enabled and a port is configured as a Provider Port
+*        (see gprtSetFrameMode API), recursive Provider Tag stripping will NOT be 
+*        performed. Only the first Provider Tag found on the frame will be 
+*        extracted and removed. Its extracted data will be used for switching.
+*        When it's disabled and a port is configured as a Provider Port, recursive 
+*        Provider Tag stripping will be performed. The first Provider Tag's data 
+*        will be extracted and used for switching, and then all subsequent Provider 
+*        Tags found in the frame will also be removed. This will only occur if the 
+*        port's PortEType (see gprtSetPortEType API) is not 0x8100.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if Remove One Provider Tag is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetRemove1PTag
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL		*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL        *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysGetRemove1PTag Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_RM_ONE_PTAG))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -6647,49 +7781,49 @@ GT_STATUS gsysGetRemove1PTag
 * gsysSetTagFlowControl
 *
 * DESCRIPTION:
-*		Use and generate source port Flow Control status for Cross-Chip Flow 
-*		Control.
-*		When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
-*		defined to be Src_FC and it is added to these frames when generated and 
-*		it is inspected on these frames when received. The QC will use the Src_FC 
-*		bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
-*		QC Flow Control algorithm.
-*		When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
-*		be Reserved and it will be zero on these frames when generated and it 
-*		will not be used on these frames when received (this is a backwards 
-*		compatibility mode).
+*        Use and generate source port Flow Control status for Cross-Chip Flow 
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
+*        defined to be Src_FC and it is added to these frames when generated and 
+*        it is inspected on these frames when received. The QC will use the Src_FC 
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
+*        be Reserved and it will be zero on these frames when generated and it 
+*        will not be used on these frames when received (this is a backwards 
+*        compatibility mode).
 *
 * INPUTS:
-*		en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
+*        en - GT_TRUE to enable Tag Flow Control, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetTagFlowControl
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetTagFlowControl Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6710,48 +7844,48 @@ GT_STATUS gsysSetTagFlowControl
 * gsysGetTagFlowControl
 *
 * DESCRIPTION:
-*		Use and generate source port Flow Control status for Cross-Chip Flow 
-*		Control.
-*		When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
-*		defined to be Src_FC and it is added to these frames when generated and 
-*		it is inspected on these frames when received. The QC will use the Src_FC 
-*		bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
-*		QC Flow Control algorithm.
-*		When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
-*		be Reserved and it will be zero on these frames when generated and it 
-*		will not be used on these frames when received (this is a backwards 
-*		compatibility mode).
+*        Use and generate source port Flow Control status for Cross-Chip Flow 
+*        Control.
+*        When this feature is enabled, bit 17 of the DSA Tag Forward frames is 
+*        defined to be Src_FC and it is added to these frames when generated and 
+*        it is inspected on these frames when received. The QC will use the Src_FC 
+*        bit on DSA ports instead of the DSA port's Flow Control mode bit for the 
+*        QC Flow Control algorithm.
+*        When it is disabled, bit 17 of the DSA Tag Forward frames is defined to 
+*        be Reserved and it will be zero on these frames when generated and it 
+*        will not be used on these frames when received (this is a backwards 
+*        compatibility mode).
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if Tag Flow Control is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetTagFlowControl
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetTagFlowControl Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TAG_FLOW_CONTROL))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -6772,43 +7906,43 @@ GT_STATUS gsysGetTagFlowControl
 * gsysSetAlwaysUseVTU
 *
 * DESCRIPTION:
-*		Always use VTU. 
-*		When this feature is enabled, VTU hit data will be used to map frames 
-*		even if 802.1Q is Disabled on the port. 
-*		When it's disabled, data will be ignored when mapping frames on ports 
-*		where 802.1Q is Disabled.
+*        Always use VTU. 
+*        When this feature is enabled, VTU hit data will be used to map frames 
+*        even if 802.1Q is Disabled on the port. 
+*        When it's disabled, data will be ignored when mapping frames on ports 
+*        where 802.1Q is Disabled.
 *
 * INPUTS:
-*		en - GT_TRUE to use VTU always, GT_FALSE otherwise.
+*        en - GT_TRUE to use VTU always, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetAlwaysUseVTU
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetAlwaysUseVTU Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6829,42 +7963,42 @@ GT_STATUS gsysSetAlwaysUseVTU
 * gsysGetAlwaysUseVTU
 *
 * DESCRIPTION:
-*		Always use VTU. 
-*		When this feature is enabled, VTU hit data will be used to map frames 
-*		even if 802.1Q is Disabled on the port. 
-*		When it's disabled, data will be ignored when mapping frames on ports 
-*		where 802.1Q is Disabled.
+*        Always use VTU. 
+*        When this feature is enabled, VTU hit data will be used to map frames 
+*        even if 802.1Q is Disabled on the port. 
+*        When it's disabled, data will be ignored when mapping frames on ports 
+*        where 802.1Q is Disabled.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
+*        en - GT_TRUE if VTU is always used, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetAlwaysUseVTU
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetAlwaysUseVTU Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_ALWAYS_USE_VTU))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -6885,49 +8019,49 @@ GT_STATUS gsysGetAlwaysUseVTU
 * gsysSetQVlansOnly
 *
 * DESCRIPTION:
-*		802.1Q VLANs Only.
-*		When this feature is disabled, the egress mapping of the frame is 
-*		limited by the frame's VID (using the MemberTag data found in the VTU) 
-*		together with the port based VLANs (using the source port's PortVLANTable, 
-*		gvlnSetPortVlanPorts API). The two methods are always used together in 
-*		this mode.
-*		When this feature is enabled, the egress mapping of the frame is limitied
-*		by the frame's VID only, if the VID was found in the VTU. If the frame's
-*		VID was not found in the VTU the egress mapping of the frame is limited
-*		by the source port's PortVLANTable only. The two methods are never
-*		used together in this mode.
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is 
+*        limited by the frame's VID (using the MemberTag data found in the VTU) 
+*        together with the port based VLANs (using the source port's PortVLANTable, 
+*        gvlnSetPortVlanPorts API). The two methods are always used together in 
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
 *
 * INPUTS:
-*		en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
+*        en - GT_TRUE to use 802.1Q Vlan Only feature, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetQVlansOnly
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_U16            data;
 
     DBG_INFO(("gsysSetQVlansOnly Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     BOOL_2_BIT(en,data);
@@ -6948,48 +8082,48 @@ GT_STATUS gsysSetQVlansOnly
 * gsysGetQVlansOnly
 *
 * DESCRIPTION:
-*		802.1Q VLANs Only.
-*		When this feature is disabled, the egress mapping of the frame is 
-*		limited by the frame's VID (using the MemberTag data found in the VTU) 
-*		together with the port based VLANs (using the source port's PortVLANTable, 
-*		gvlnSetPortVlanPorts API). The two methods are always used together in 
-*		this mode.
-*		When this feature is enabled, the egress mapping of the frame is limitied
-*		by the frame's VID only, if the VID was found in the VTU. If the frame's
-*		VID was not found in the VTU the egress mapping of the frame is limited
-*		by the source port's PortVLANTable only. The two methods are never
-*		used together in this mode.
+*        802.1Q VLANs Only.
+*        When this feature is disabled, the egress mapping of the frame is 
+*        limited by the frame's VID (using the MemberTag data found in the VTU) 
+*        together with the port based VLANs (using the source port's PortVLANTable, 
+*        gvlnSetPortVlanPorts API). The two methods are always used together in 
+*        this mode.
+*        When this feature is enabled, the egress mapping of the frame is limitied
+*        by the frame's VID only, if the VID was found in the VTU. If the frame's
+*        VID was not found in the VTU the egress mapping of the frame is limited
+*        by the source port's PortVLANTable only. The two methods are never
+*        used together in this mode.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if 802.1Q Vlan Only feature is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetQVlansOnly
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetQVlansOnly Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QVLAN_ONLY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get related bit */
@@ -7010,118 +8144,118 @@ GT_STATUS gsysGetQVlansOnly
 * gsysSet5BitPort
 *
 * DESCRIPTION:
-*		Use 5 bits for Port data in the Port VLAN Table (PVT). 
-*		When this feature is enabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:5] = Source Device[3:0] or Device Number[3:0]
-*			Addr[4:0] = Source Port/Trunk[4:0]
-*		When it's disabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:4] = Source Device[4:0] or Device Number[4:0]
-*			Addr[3:0] = Source Port/Trunk[3:0]
+*        Use 5 bits for Port data in the Port VLAN Table (PVT). 
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
 *
 * INPUTS:
-*		en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
+*        en - GT_TRUE to use 5 bit as a Source port in PVT, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSet5BitPort
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
 
-	DBG_INFO(("gsysSet5BitPort Called.\n"));
+    DBG_INFO(("gsysSet5BitPort Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	BOOL_2_BIT(en,data);
+    BOOL_2_BIT(en,data);
 
-	/* Set related bit */
-	retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 14, 1, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 14, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gsysGet5BitPort
 *
 * DESCRIPTION:
-*		Use 5 bits for Port data in the Port VLAN Table (PVT). 
-*		When this feature is enabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:5] = Source Device[3:0] or Device Number[3:0]
-*			Addr[4:0] = Source Port/Trunk[4:0]
-*		When it's disabled, the 9 bits used to access the PVT memory is:
-*			Addr[8:4] = Source Device[4:0] or Device Number[4:0]
-*			Addr[3:0] = Source Port/Trunk[3:0]
+*        Use 5 bits for Port data in the Port VLAN Table (PVT). 
+*        When this feature is enabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:5] = Source Device[3:0] or Device Number[3:0]
+*            Addr[4:0] = Source Port/Trunk[4:0]
+*        When it's disabled, the 9 bits used to access the PVT memory is:
+*            Addr[8:4] = Source Device[4:0] or Device Number[4:0]
+*            Addr[3:0] = Source Port/Trunk[3:0]
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
+*        en - GT_TRUE if 5 bit is used as a Source Port in PVT, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGet5BitPort
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* The register's read data.    */
-	
-	DBG_INFO(("gsysGet5BitPort Called.\n"));
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    
+    DBG_INFO(("gsysGet5BitPort Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_5BIT_PORT))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* Get related bit */
-	retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,14,1,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,14,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	BIT_2_BOOL(data,*en);
-	DBG_INFO(("OK.\n"));
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -7129,37 +8263,37 @@ GT_STATUS gsysGet5BitPort
 * gsysSetSDETPolarity
 *
 * DESCRIPTION:
-*		SDET (Signal Detect) Polarity select bits for each port. 
-*		Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
-*		determine link on fiber ports. This bit affects the active level of a 
-*		port's SDET pins as follows:
-*			0 = SDET is active low. A low level on the port's SDET pin is 
-*				required for link to occur.
-*			1 = SDET is active high. A high level on the ports SDET pin is 
-*				required for link to occur.
-*		SDET is used when the port is configured as a fiber port. In all other 
-*		port modes the SDET pins are ignored and these bits have no effect.
+*        SDET (Signal Detect) Polarity select bits for each port. 
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
+*        determine link on fiber ports. This bit affects the active level of a 
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is 
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is 
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other 
+*        port modes the SDET pins are ignored and these bits have no effect.
 *
 * INPUTS:
-*		sdetVec - SDET Polarity for each port in Vector format
+*        sdetVec - SDET Polarity for each port in Vector format
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_BAD_PARAM - if sdetVec is invalid
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_BAD_PARAM - if sdetVec is invalid
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetSDETPolarity
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_U32  		sdetVec
+    IN GT_QD_DEV    *dev,
+    IN GT_U32          sdetVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -7167,29 +8301,29 @@ GT_STATUS gsysSetSDETPolarity
 
     DBG_INFO(("gsysSetSDETPolarity Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     if ((GT_U16)sdetVec > ((1 << dev->numOfPorts) - 1))
-	{
-		DBG_INFO(("GT_BAD_PARAM \n"));
-		return GT_BAD_PARAM;
-	}
+    {
+        DBG_INFO(("GT_BAD_PARAM \n"));
+        return GT_BAD_PARAM;
+    }
 
-	data = (GT_U16)GT_LPORTVEC_2_PORTVEC(sdetVec);
+    data = (GT_U16)GT_LPORTVEC_2_PORTVEC(sdetVec);
 
-	if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
-	{
-		if (data & (~0x30))	/* only port 4 and 5 of this device support SDET */
-		{
-			DBG_INFO(("GT_BAD_PARAM \n"));
-			return GT_BAD_PARAM;
-		}
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
+    {
+        if (data & (~0x30))    /* only port 4 and 5 of this device support SDET */
+        {
+            DBG_INFO(("GT_BAD_PARAM \n"));
+            return GT_BAD_PARAM;
+        }
+    }
 
     /* Set the related bits. */
     retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY,0,dev->maxPorts,data);
@@ -7207,47 +8341,47 @@ GT_STATUS gsysSetSDETPolarity
 * gsysGetSDETPolarity
 *
 * DESCRIPTION:
-*		SDET (Signal Detect) Polarity select bits for each port. 
-*		Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
-*		determine link on fiber ports. This bit affects the active level of a 
-*		port's SDET pins as follows:
-*			0 = SDET is active low. A low level on the port's SDET pin is 
-*				required for link to occur.
-*			1 = SDET is active high. A high level on the ports SDET pin is 
-*				required for link to occur.
-*		SDET is used when the port is configured as a fiber port. In all other 
-*		port modes the SDET pins are ignored and these bits have no effect.
+*        SDET (Signal Detect) Polarity select bits for each port. 
+*        Bit 10 is for Port 10, bit 9 is for Port 9, etc. SDET is used to help 
+*        determine link on fiber ports. This bit affects the active level of a 
+*        port's SDET pins as follows:
+*            0 = SDET is active low. A low level on the port's SDET pin is 
+*                required for link to occur.
+*            1 = SDET is active high. A high level on the ports SDET pin is 
+*                required for link to occur.
+*        SDET is used when the port is configured as a fiber port. In all other 
+*        port modes the SDET pins are ignored and these bits have no effect.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		sdetVec - SDET Polarity for each port in Vector format
+*        sdetVec - SDET Polarity for each port in Vector format
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetSDETPolarity
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_U32  	*sdetVec
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U32      *sdetVec
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
     GT_U16          data;           /* The register's read data.    */
     DBG_INFO(("gsysGetSDETPolarity Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_SDET_POLARITY))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
     /* Get the related bits. */
@@ -7258,12 +8392,12 @@ GT_STATUS gsysGetSDETPolarity
         return retVal;
     }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
-	{
-		data &= 0x30;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_LIMITED_SDET))
+    {
+        data &= 0x30;
+    }
 
-	*sdetVec = GT_PORTVEC_2_LPORTVEC(data);
+    *sdetVec = GT_PORTVEC_2_LPORTVEC(data);
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -7294,26 +8428,26 @@ GT_STATUS gsysGetSDETPolarity
 *******************************************************************************/
 GT_STATUS gsysSetARPwoBC
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_BOOL 	en
+    IN  GT_QD_DEV    *dev,
+    IN  GT_BOOL     en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* Data to be set into the      */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* Data to be set into the      */
                                 /* register.                    */
-	DBG_INFO(("sysSetARPwoBC Called.\n"));
-	BOOL_2_BIT(en,data);
+    DBG_INFO(("sysSetARPwoBC Called.\n"));
+    BOOL_2_BIT(en,data);
 
-	/* Set the Discard Exissive bit.                */
-	retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Set the Discard Exissive bit.                */
+    retVal = hwSetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -7343,31 +8477,31 @@ GT_STATUS gsysSetARPwoBC
 *******************************************************************************/
 GT_STATUS gsysGetARPwoBC
 (
-	IN  GT_QD_DEV 	*dev,
-	IN  GT_BOOL		*en
+    IN  GT_QD_DEV     *dev,
+    IN  GT_BOOL        *en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* The register's read data.    */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
 
-	DBG_INFO(("gsysGetARPwoBC Called.\n"));
-	if(en == NULL)
-	{
-		DBG_INFO(("Failed.\n"));
-		return GT_BAD_PARAM;
-	}
+    DBG_INFO(("gsysGetARPwoBC Called.\n"));
+    if(en == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
 
-	/* Get the bit. */
-	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Get the bit. */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_CONTROL,12,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	BIT_2_BOOL(data,*en);
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 
@@ -7375,112 +8509,112 @@ GT_STATUS gsysGetARPwoBC
 * gsysSetCLK125En
 *
 * DESCRIPTION:
-*		Clock 125MHz Enable.
-*		When this feature is enabled, the CLK125 pin has a free running 125 MHz
-*		clock output.
-*		When it's disabled, the CLK125 pin will be in tri-state.
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
 *
 * INPUTS:
-*		en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
+*        en - GT_TRUE to enable 125 MHz clock, GT_FALSE otherwise.
 *
 * OUTPUTS:
-*		None.
+*        None.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysSetCLK125En
 (
-	IN GT_QD_DEV	*dev,
-	IN GT_BOOL		en
+    IN GT_QD_DEV    *dev,
+    IN GT_BOOL        en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16			data;
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16            data;
 
-	DBG_INFO(("gsysSetCLK125En Called.\n"));
+    DBG_INFO(("gsysSetCLK125En Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	BOOL_2_BIT(en,data);
+    BOOL_2_BIT(en,data);
 
-	/* Set related bit */
-	retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 11, 1, data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Set related bit */
+    retVal = hwSetGlobal2RegField(dev,QD_REG_SDET_POLARITY, 11, 1, data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
 * gsysGetCLK125En
 *
 * DESCRIPTION:
-*		Clock 125MHz Enable.
-*		When this feature is enabled, the CLK125 pin has a free running 125 MHz
-*		clock output.
-*		When it's disabled, the CLK125 pin will be in tri-state.
+*        Clock 125MHz Enable.
+*        When this feature is enabled, the CLK125 pin has a free running 125 MHz
+*        clock output.
+*        When it's disabled, the CLK125 pin will be in tri-state.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
+*        en - GT_TRUE if 125MHz clock is enabled, GT_FALSE otherwise.
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK   - on success
+*        GT_FAIL - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysGetCLK125En
 (
-	IN  GT_QD_DEV	*dev,
-	OUT GT_BOOL  	*en
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL      *en
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* The register's read data.    */
-	
-	DBG_INFO(("gsysGetCLK125En Called.\n"));
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
+    
+    DBG_INFO(("gsysGetCLK125En Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
-	{
-		DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_CLK_125))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	/* Get related bit */
-	retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,11,1,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* Get related bit */
+    retVal = hwGetGlobal2RegField(dev,QD_REG_SDET_POLARITY,11,1,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	BIT_2_BOOL(data,*en);
-	DBG_INFO(("OK.\n"));
+    BIT_2_BOOL(data,*en);
+    DBG_INFO(("OK.\n"));
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -7488,42 +8622,42 @@ GT_STATUS gsysGetCLK125En
 * gsysPort2Lport
 *
 * DESCRIPTION:
-*		This routine converts physical port number to logical port number.
+*        This routine converts physical port number to logical port number.
 *
 * INPUTS:
-*		port - physical port number
+*        port - physical port number
 *
 * OUTPUTS:
-*		lport - logical port number
+*        lport - logical port number
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysPort2Lport
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32 		port,
-	OUT GT_LPORT	*lport
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32         port,
+    OUT GT_LPORT    *lport
 )
 {
     DBG_INFO(("gsysPort2Lport Called.\n"));
 
-	if (port > 0xFF)
-	{
-		return GT_FAIL;
-	}
+    if (port > 0xFF)
+    {
+        return GT_FAIL;
+    }
 
-	*lport = GT_PORT_2_LPORT((GT_U8)port);
+    *lport = GT_PORT_2_LPORT((GT_U8)port);
 
-	if (*lport == GT_INVALID_PORT)
-	{
-		return GT_FAIL;
-	}
+    if (*lport == GT_INVALID_PORT)
+    {
+        return GT_FAIL;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -7533,37 +8667,37 @@ GT_STATUS gsysPort2Lport
 * gsysLport2Port
 *
 * DESCRIPTION:
-*		This routine converts logical port number to physical port number.
+*        This routine converts logical port number to physical port number.
 *
 * INPUTS:
-*		lport - logical port number
+*        lport - logical port number
 *
 * OUTPUTS:
-*		port - physical port number
+*        port - physical port number
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysLport2Port
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_LPORT	lport,
-	OUT GT_U32 		*port
+    IN  GT_QD_DEV    *dev,
+    IN  GT_LPORT    lport,
+    OUT GT_U32         *port
 )
 {
     DBG_INFO(("gsysLport2Port Called.\n"));
 
-	*port = (GT_U32)GT_LPORT_2_PORT(lport);
+    *port = (GT_U32)GT_LPORT_2_PORT(lport);
 
-	if (*port == GT_INVALID_PORT)
-	{
-		return GT_FAIL;
-	}
+    if (*port == GT_INVALID_PORT)
+    {
+        return GT_FAIL;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -7574,42 +8708,42 @@ GT_STATUS gsysLport2Port
 * gsysPortvec2Lportvec
 *
 * DESCRIPTION:
-*		This routine converts physical port vector to logical port vector.
+*        This routine converts physical port vector to logical port vector.
 *
 * INPUTS:
-*		portvec - physical port vector
+*        portvec - physical port vector
 *
 * OUTPUTS:
-*		lportvec - logical port vector
+*        lportvec - logical port vector
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysPortvec2Lportvec
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32		portvec,
-	OUT GT_U32 		*lportvec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        portvec,
+    OUT GT_U32         *lportvec
 )
 {
     DBG_INFO(("gsysPortvec2Lportvec Called.\n"));
 
-	if (portvec & (~((GT_U32)dev->validPortVec)))
-	{
-		return GT_FAIL;
-	}
+    if (portvec & (~((GT_U32)dev->validPortVec)))
+    {
+        return GT_FAIL;
+    }
 
-	*lportvec = GT_PORTVEC_2_LPORTVEC(portvec);
+    *lportvec = GT_PORTVEC_2_LPORTVEC(portvec);
 
-	if (*lportvec == GT_INVALID_PORT_VEC)
-	{
-		return GT_FAIL;
-	}
+    if (*lportvec == GT_INVALID_PORT_VEC)
+    {
+        return GT_FAIL;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -7619,37 +8753,37 @@ GT_STATUS gsysPortvec2Lportvec
 * gsysLportvec2Portvec
 *
 * DESCRIPTION:
-*		This routine converts logical port vector to physical port vector.
+*        This routine converts logical port vector to physical port vector.
 *
 * INPUTS:
-*		lportvec - logical port vector
+*        lportvec - logical port vector
 *
 * OUTPUTS:
-*		portvec - physical port vector
+*        portvec - physical port vector
 *
 * RETURNS:
-*		GT_OK   - on success
-*		GT_FAIL - on error
+*        GT_OK   - on success
+*        GT_FAIL - on error
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 *******************************************************************************/
 GT_STATUS gsysLportvec2Portvec
 (
-	IN  GT_QD_DEV	*dev,
-	IN  GT_U32		lportvec,
-	OUT GT_U32 		*portvec
+    IN  GT_QD_DEV    *dev,
+    IN  GT_U32        lportvec,
+    OUT GT_U32         *portvec
 )
 {
     DBG_INFO(("gsysLportvec2Portvec Called.\n"));
 
-	*portvec = GT_LPORTVEC_2_PORTVEC(lportvec);
+    *portvec = GT_LPORTVEC_2_PORTVEC(lportvec);
 
-	if (*portvec == GT_INVALID_PORT_VEC)
-	{
-		return GT_FAIL;
-	}
+    if (*portvec == GT_INVALID_PORT_VEC)
+    {
+        return GT_FAIL;
+    }
 
     DBG_INFO(("OK.\n"));
     return GT_OK;
@@ -7662,182 +8796,446 @@ GT_STATUS gsysLportvec2Portvec
 /****************************************************************************/
 
 /*
- * Write to Switch MAC Register
+ * Write to Switch MAC/Wol MAC Register
  */
-static GT_STATUS writeSwitchMacReg
+static GT_STATUS writeSwitchMacWolReg
 (
     IN GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
     IN GT_ETHERADDR *mac
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
-	GT_U16			i;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+    GT_U16            i;
 
-	for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
-	{
-	    /* Wait until the device is ready. */
-	    data = 1;
-    	while(data == 1)
-	    {
-    	    retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
-        	if(retVal != GT_OK)
-	        {
-        	    return retVal;
-	        }
-    	}
-
-		data = (1 << 15) | (i << 8) | mac->arEther[i];
-
-		retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
+    {
+        /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+        }
+#endif
+
+        data = (1 << 15) | ((i+baseid) << 8) | mac->arEther[i];
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
-	}
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*
- * Read from Switch MAC Register
+ * Read from Switch MAC/WoL MAC Register
  */
-static GT_STATUS readSwitchMacReg
+static GT_STATUS readSwitchMacWolReg
 (
     IN  GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
     OUT GT_ETHERADDR *mac
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
-	GT_U16			i;
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+    GT_U16            i;
 
     /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
-   	    retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
-       	if(retVal != GT_OK)
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+           if(retVal != GT_OK)
         {
-       	    return retVal;
+               return retVal;
         }
-   	}
+       }
+#endif
 
-	for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
-	{
-		data = i << 8;
+    for (i=0; i<GT_ETHERNET_HEADER_SIZE; i++)
+    {
+        data = (i+baseid) << 8;
 
-		retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
 
-		retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+        retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
         if(retVal != GT_OK)
-   	    {
-           	return retVal;
+           {
+               return retVal;
         }
 
-		if (i == 0)
-			mac->arEther[i] = data & 0xFE;	/* bit 0 is for diffAddr */
-		else
-			mac->arEther[i] = data & 0xFF;
-	}
+        if ((baseid != 0x16) && (i == 0))  /* base id = 0x16 is Wol Password,and it has nor diffAddr */
+            mac->arEther[i] = data & 0xFE;    /* bit 0 is for diffAddr */
+        else
+            mac->arEther[i] = data & 0xFF;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
 /*
- * Write to Different MAC Address per port bit in Switch MAC Register
+ * Write to Different MAC Address per port bit in Switch MAC/WoL Register
  */
-static GT_STATUS writeDiffMAC
+static GT_STATUS writeDiffMACWoL
 (
     IN GT_QD_DEV    *dev,
-    IN GT_U16		diffAddr
+	IN GT_U8        baseid,
+    IN GT_U16       diffAddr
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
 
     /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SWITCH_MAC;
+      data = baseid<<8;
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
     data = 1;
-   	while(data == 1)
+    while(data == 1)
     {
-   	    retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
-       	if(retVal != GT_OK)
+       retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+          if(retVal != GT_OK)
         {
-       	    return retVal;
+               return retVal;
         }
-   	}
-
-    /* Write to Swith MAC Reg for reading operation */
-	data = 0;
-	retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    }
+    data = baseid<<8;
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
     /* Read Swith MAC Reg */
-	retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+#endif
 
-	data = (1 << 15) | (data & 0xFE) | (diffAddr & 0x1);
+    data = (1 << 15) | (baseid<<8) | (data & 0xFE) | (diffAddr & 0x1);
 
     /* Write back to Swith MAC Reg with updated diffAddr */
-	retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 /*
- * Read Different MAC Address per port bit in Switch MAC Register
+ * Read Different MAC Address per port bit in Switch MAC/WoL Register
  */
-static GT_STATUS readDiffMAC
+static GT_STATUS readDiffMACWoL
 (
-    IN  GT_QD_DEV	*dev,
-    OUT GT_U16		*diffAddr
+    IN  GT_QD_DEV    *dev,
+	IN GT_U8        baseid,
+    OUT GT_U16        *diffAddr
 )
 {
-    GT_STATUS       retVal;	/* Functions return value */
-    GT_U16          data; 	/* temporary Data storage */
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
 
     /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_SWITCH_MAC;
+      data = baseid<<8;
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
     data = 1;
-   	while(data == 1)
+       while(data == 1)
     {
-   	    retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
-       	if(retVal != GT_OK)
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&data);
+           if(retVal != GT_OK)
         {
-       	    return retVal;
+               return retVal;
         }
-   	}
+       }
 
     /* Write to Swith MAC Reg for reading operation */
-	data = 0;
-	retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    data = baseid<<8;
+    retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
 
-	retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
-	if(retVal != GT_OK)
-	{
-		return retVal;
-	}
+    retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&data);
+    if(retVal != GT_OK)
+    {
+        return retVal;
+    }
+#endif
+    *diffAddr = data & 0x1;
+
+    return GT_OK;
+}
+
+/*
+ * Write to Switch MAC/WoL/WoF Register
+ */
+static GT_STATUS writeSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+	IN GT_U8        data
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          tmpData;     /* temporary Data storage */
+    {
+        /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+        tmpData = 1;
+        while(tmpData == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&tmpData);
+            if(retVal != GT_OK)
+            {
+                return retVal;
+            }
+        }
+#endif
+
+        tmpData = (1 << 15) | (pointer << 8) | data;
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC, tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+    }
+
+    return GT_OK;
+}
+
+/*
+ * Read from Switch MAC/WoL/WoF Register
+ */
+static GT_STATUS readSwMacWolWofReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U8        pointer,
+	OUT GT_U8       *data
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          tmpData;     /* temporary Data storage */
+
+    /* Wait until the device is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_SWITCH_MAC;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+    tmpData = 1;
+       while(tmpData == 1)
+    {
+           retVal = hwGetGlobal2RegField(dev,QD_REG_SWITCH_MAC,15,1,&tmpData);
+           if(retVal != GT_OK)
+        {
+               return retVal;
+        }
+       }
+#endif
+
+    {
+        tmpData = pointer << 8;
+
+        retVal = hwWriteGlobal2Reg(dev,QD_REG_SWITCH_MAC,tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev,QD_REG_SWITCH_MAC,&tmpData);
+        if(retVal != GT_OK)
+           {
+               return retVal;
+        }
+
+        *data = tmpData & 0xFF;
+    }
+
+    return GT_OK;
+}
+
+
+/*
+ * Write to Switch MAC Register
+ */
+static GT_STATUS writeSwitchMacReg
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_ETHERADDR *mac
+)
+{
+    return writeSwitchMacWolReg(dev, 0, mac);
+}
+
+/*
+ * Read from Switch MAC Register
+ */
+static GT_STATUS readSwitchMacReg
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_ETHERADDR *mac
+)
+{
+    return readSwitchMacWolReg(dev, 0, mac);
+}
 
-	*diffAddr = data & 0x1;
 
-	return GT_OK;
+/*
+ * Write to Different MAC Address per port bit in Switch MAC Register
+ */
+static GT_STATUS writeDiffMAC
+(
+    IN GT_QD_DEV    *dev,
+    IN GT_U16       diffAddr
+)
+{
+    return writeDiffMACWoL(dev, 0, diffAddr);
+}
+
+/*
+ * Read Different MAC Address per port bit in Switch MAC Register
+ */
+static GT_STATUS readDiffMAC
+(
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16        *diffAddr
+)
+{
+    return readDiffMACWoL(dev, 0, diffAddr);
 }
 
+
+
+
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysStatus.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysStatus.c
old mode 100644
new mode 100755
index 3175bcd..736789b
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysStatus.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtSysStatus.c
@@ -5,7 +5,7 @@
 *
 * DESCRIPTION:
 *       API definitions for system global status.
-* 	Added for fullsail
+*     Added for fullsail
 *
 * DEPENDENCIES:
 *
@@ -22,67 +22,67 @@
 * gsysGetPPUState
 *
 * DESCRIPTION:
-*		This routine get the PPU State. These two bits return 
-*		the current value of the PPU.
+*        This routine get the PPU State. These two bits return 
+*        the current value of the PPU.
 *
 * INPUTS:
-*		None.
+*        None.
 *
 * OUTPUTS:
-*		mode - GT_PPU_STATE
+*        mode - GT_PPU_STATE
 *
 * RETURNS:
-*		GT_OK           - on success
-*		GT_BAD_PARAM    - on bad parameter
-*		GT_FAIL         - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_OK           - on success
+*        GT_BAD_PARAM    - on bad parameter
+*        GT_FAIL         - on error
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
-*		None.
+*        None.
 *
 * GalTis:
 *
 *******************************************************************************/
 GT_STATUS gsysGetPPUState
 (
-	IN  GT_QD_DEV   	*dev,
-	OUT GT_PPU_STATE	*mode
+    IN  GT_QD_DEV       *dev,
+    OUT GT_PPU_STATE    *mode
 )
 {
-	GT_STATUS       retVal;         /* Functions return value.      */
-	GT_U16          data;           /* The register's read data.    */
+    GT_STATUS       retVal;         /* Functions return value.      */
+    GT_U16          data;           /* The register's read data.    */
 
-	DBG_INFO(("gsysGetPPUState Called.\n"));
+    DBG_INFO(("gsysGetPPUState Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
-	{
-		DBG_INFO(("Not Supported.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+    if (!IS_IN_DEV_GROUP(dev,DEV_GIGABIT_SWITCH))
+    {
+        DBG_INFO(("Not Supported.\n"));
+        return GT_NOT_SUPPORTED;
+    }
 
-	if(mode == NULL)
-	{
-		DBG_INFO(("Failed.\n"));
-		return GT_BAD_PARAM;
-	}
+    if(mode == NULL)
+    {
+        DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
 
-	/* get the bits from hardware */
-	retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,14,2,&data);
-	if(retVal != GT_OK)
-	{
-		DBG_INFO(("Failed.\n"));
-		return retVal;
-	}
+    /* get the bits from hardware */
+    retVal = hwGetGlobalRegField(dev,QD_REG_GLOBAL_STATUS,14,2,&data);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed.\n"));
+        return retVal;
+    }
 
-	if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
-	{
-		data |= 0x4000;
-	}
+    if (IS_IN_DEV_GROUP(dev,DEV_PPU_READ_ONLY))
+    {
+        data |= 0x4000;
+    }
 
-	*mode = data;
-	DBG_INFO(("OK.\n"));
-	return GT_OK;
+    *mode = data;
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
 }
 
 /*******************************************************************************
@@ -121,11 +121,13 @@ GT_STATUS gsysGetSW_Mode
     DBG_INFO(("gsysGetSW_Mode Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QD_PLUS|DEV_ENHANCED_FE_SWITCH))
-	{
+    if (!((IS_IN_DEV_GROUP(dev,DEV_QD_PLUS)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
         DBG_INFO(("Not Supported.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+        return GT_NOT_SUPPORTED;
+    }
 
     if(mode == NULL)
     {
@@ -183,11 +185,13 @@ GT_STATUS gsysGetInitReady
     DBG_INFO(("gsysGetInitReady Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QD_PLUS|DEV_ENHANCED_FE_SWITCH))
-	{
+    if (!((IS_IN_DEV_GROUP(dev,DEV_QD_PLUS)) ||
+        (IS_IN_DEV_GROUP(dev,DEV_ENHANCED_FE_SWITCH)) ||
+		(IS_IN_DEV_GROUP(dev,DEV_FE_AVB_FAMILY))))
+    {
         DBG_INFO(("Not Supported.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+        return GT_NOT_SUPPORTED;
+    }
 
     if(mode == NULL)
     {
@@ -213,7 +217,7 @@ GT_STATUS gsysGetInitReady
 *
 * DESCRIPTION:
 *       This routine gets Free Queue Counter. This counter reflects the 
-*		current number of unalllocated buffers available for all the ports.
+*        current number of unalllocated buffers available for all the ports.
 *
 * INPUTS:
 *       None.
@@ -224,7 +228,7 @@ GT_STATUS gsysGetInitReady
 * RETURNS:
 *       GT_OK            - on success
 *       GT_FAIL          - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None.
@@ -234,8 +238,8 @@ GT_STATUS gsysGetInitReady
 *******************************************************************************/
 GT_STATUS gsysGetFreeQSize
 (
-    IN  GT_QD_DEV	*dev,
-    OUT GT_U16 		*count
+    IN  GT_QD_DEV    *dev,
+    OUT GT_U16         *count
 )
 {
     GT_STATUS       retVal;         /* Functions return value.      */
@@ -243,11 +247,11 @@ GT_STATUS gsysGetFreeQSize
     DBG_INFO(("gsysGetFreeQSize Called.\n"));
 
     /* check if device supports this feature */
-	if (!IS_IN_DEV_GROUP(dev,DEV_OUT_Q_SIZE))
-	{
+    if (!IS_IN_DEV_GROUP(dev,DEV_OUT_Q_SIZE))
+    {
         DBG_INFO(("Not Supported.\n"));
-		return GT_NOT_SUPPORTED;
-	}
+        return GT_NOT_SUPPORTED;
+    }
 
     /* get the counter */
     retVal = hwGetGlobalRegField(dev,QD_REG_TOTAL_FREE_COUNTER,0,9,count);
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtTCAM.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtTCAM.c
new file mode 100755
index 0000000..2f4c628
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtTCAM.c
@@ -0,0 +1,979 @@
+#include <Copyright.h>
+
+/*******************************************************************************
+* gtTCAM.c
+*
+* DESCRIPTION:
+*       API definitions for control of Ternary Content Addressable Memory
+*
+* DEPENDENCIES:
+*
+* FILE REVISION NUMBER:
+*******************************************************************************/
+
+#include <msApi.h>
+#include <gtSem.h>
+#include <gtHwCntl.h>
+#include <gtDrvSwRegs.h>
+
+/****************************************************************************/
+/* TCAM operation function declaration.                                    */
+/****************************************************************************/
+static GT_STATUS tcamOperationPerform
+(
+    IN   GT_QD_DEV             *dev,
+    IN   GT_TCAM_OPERATION    tcamOp,
+    INOUT GT_TCAM_OP_DATA    *opData
+);
+
+/*******************************************************************************
+* gtcamFlushAll
+*
+* DESCRIPTION:
+*       This routine is to flush all entries. A Flush All command will initialize 
+*       TCAM Pages 0 and 1, offsets 0x02 to 0x1B to 0x0000, and TCAM Page 2 offset
+*       0x02 to 0x05 to 0x0000 for all TCAM entries with the exception that TCAM 
+*       Page 0 offset 0x02 will be initialized to 0x00FF.
+*
+*
+* INPUTS:
+*        None.
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushAll
+(
+    IN  GT_QD_DEV     *dev
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamFlushAll Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_FLUSH_ALL;
+    tcamOpData.tcamEntry = 0xFF;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamFlushEntry
+*
+* DESCRIPTION:
+*       This routine is to flush a single entry. A Flush a single TCAM entry command 
+*       will write the same values to a TCAM entry as a Flush All command, but it is
+*       done to the selected single TCAM entry only.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamFlushEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamFlushEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if (tcamPointer > 0xFE)
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_FLUSH_ALL;
+    tcamOpData.tcamEntry = tcamPointer;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamLoadEntry
+*
+* DESCRIPTION:
+*       This routine loads a TCAM entry.
+*    	The load sequence of TCAM entry is critical. Each TCAM entry is made up of
+*       3 pages of data. All 3 pages need to loaded in a particular order for the TCAM 
+*       to operate correctly while frames are flowing through the switch. 
+*       If the entry is currently valid, it must first be flushed. Then page 2 needs 
+*       to be loaded first, followed by page 1 and then finally page 0. 
+*       Each page load requires its own write TCAMOp with these TCAM page bits set 
+*       accordingly. 
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamLoadEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamLoadEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_LOAD_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamPurgyEntry
+*
+* DESCRIPTION:
+*       This routine Purgy a TCAM entry.
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*        tcamData    - Tcam entry Data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamPurgyEntry
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    IN  GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamPurgyEntry Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_LOAD_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/*******************************************************************************
+* gtcamReadTCAMData
+*
+* DESCRIPTION:
+*       This routine loads the global 3 offsets 0x02 to 0x1B registers with 
+*       the data found in the TCAM entry and its TCAM page pointed to by the TCAM
+*       entry and TCAM page bits of this register (bits 7:0 and 11:10 respectively.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 254)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamReadTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamReadTCAMData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFE)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_READ_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+/*******************************************************************************
+* gtcamGetNextTCAMData
+*
+* DESCRIPTION:
+*       This routine  finds the next higher TCAM Entry number that is valid (i.e.,
+*       any entry whose Page 0 offset 0x02 is not equal to 0x00FF). The TCAM Entry 
+*       register (bits 7:0) is used as the TCAM entry to start from. To find 
+*       the lowest number TCAM Entry that is valid, start the Get Next operation 
+*       with TCAM Entry set to 0xFF.
+*
+*
+* INPUTS:
+*        tcamPointer - pointer to the desired entry of TCAM (0 ~ 255)
+*
+* OUTPUTS:
+*        tcamData    - Tcam entry Data
+*
+* RETURNS:
+*       GT_OK      - on success
+*       GT_FAIL    - on error
+*        GT_BAD_PARAM - if invalid parameter is given
+*       GT_NOT_SUPPORTED - if current device does not support this feature.
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+GT_STATUS gtcamGetNextTCAMData
+(
+    IN  GT_QD_DEV     *dev,
+    IN  GT_U32        tcamPointer,
+    OUT GT_TCAM_DATA        *tcamData
+)
+{
+    GT_STATUS           retVal;
+    GT_TCAM_OPERATION    op;
+    GT_TCAM_OP_DATA     tcamOpData;
+
+    DBG_INFO(("gtcamGetNextTCAMData Called.\n"));
+
+    /* check if device supports this feature */
+    if (!IS_IN_DEV_GROUP(dev,DEV_TCAM))
+    {
+        DBG_INFO(("GT_NOT_SUPPORTED\n"));
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the given pointer is valid */
+    if ((tcamPointer > 0xFF)||(tcamData==NULL))
+    {
+        DBG_INFO(("GT_BAD_PARAM\n"));
+        return GT_BAD_PARAM;
+    }
+
+    /* Program Tuning register */
+    op = TCAM_GET_NEXT_ENTRY;
+    tcamOpData.tcamPage = 0; /* useless */
+    tcamOpData.tcamEntry = tcamPointer;
+    tcamOpData.tcamDataP = tcamData;
+    retVal = tcamOperationPerform(dev,op, &tcamOpData);
+    if(retVal != GT_OK)
+    {
+        DBG_INFO(("Failed (tcamOperationPerform returned GT_FAIL).\n"));
+        return retVal;
+    }
+
+    DBG_INFO(("OK.\n"));
+    return GT_OK;
+
+}
+
+
+/****************************************************************************/
+/* Internal functions.                                                  */
+/****************************************************************************/
+static GT_STATUS tcamSetPage0Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i;
+
+  data = ((tcamDataP->paraFrm.frameTypeMask<<14) | (tcamDataP->paraFrm.frameType<<6) );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.spvMask<<8) | (tcamDataP->paraFrm.spv<<0)  );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_2,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.ppriMask<<12) | (tcamDataP->paraFrm.ppri<<4));
+  data = (((tcamDataP->paraFrm.pvidMask&0x0f00)&0x000f) | ((tcamDataP->paraFrm.pvid>>8)&0x000f));
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_3,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.pvidMask&0x00ff)<<8 | (tcamDataP->paraFrm.pvid&0x00ff));
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_4,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  for(i=0; i<22; i++)
+  {
+    data = ((tcamDataP->paraFrm.frameOctetMask[i])<<8 | (tcamDataP->paraFrm.frameOctet[i]));
+    retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_MATCH_DATA_1+i,data);
+    if(retVal != GT_OK)
+	{
+     return retVal;
+	}
+  }
+
+  return GT_OK;
+}
+static GT_STATUS tcamSetPage1Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i;
+
+  for(i=0; i<25; i++)
+  {
+    data = ((tcamDataP->paraFrm.frameOctetMask[i+23])<<8 | (tcamDataP->paraFrm.frameOctet[i+23]));
+    retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P1_MATCH_DATA_23+i,data);
+    if(retVal != GT_OK)
+	{
+     return retVal;
+	}
+  }
+
+  return GT_OK;
+}
+
+static GT_STATUS tcamSetPage2Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+
+  data = ((tcamDataP->paraFrm.continu<<15) | (tcamDataP->paraFrm.interrupt<<14) |
+	  (tcamDataP->paraFrm.IncTcamCtr<<13) | (tcamDataP->paraFrm.vidOverride<<12) |
+	  (tcamDataP->paraFrm.vidData&0x07ff));
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_1,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.nextId<<8) | (tcamDataP->paraFrm.qpriOverride<<7) |
+	  (tcamDataP->paraFrm.qpriData<<4) | (tcamDataP->paraFrm.fpriOverride<<3) |
+	  (tcamDataP->paraFrm.fpriData));
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_2,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.qpriAvbOverride<<15) | (tcamDataP->paraFrm.qpriAvbData<<12) |
+	  (tcamDataP->paraFrm.dpvOverride<<11) | (tcamDataP->paraFrm.dpvData) );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_3,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.factionOverride<<15) | (tcamDataP->paraFrm.factionData<<4) |
+	  (tcamDataP->paraFrm.ldBalanceOverride<<3) | (tcamDataP->paraFrm.ldBalanceData) );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_4,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = (tcamDataP->paraFrm.debugPort );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_DEBUG_PORT,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  data = ((tcamDataP->paraFrm.highHit<<8) | (tcamDataP->paraFrm.lowHit<<0)  );
+  retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P2_ALL_HIT,data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  return GT_OK;
+}
+
+
+static GT_STATUS tcamGetPage0Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i;
+
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.frameTypeMask = (data >>14)&0xff;
+  tcamDataP->paraFrm.frameType = (data >> 6)&0xff;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_2,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.spvMask = (data >>8)&0xff;
+  tcamDataP->paraFrm.spv = data&0xff;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_3,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.ppriMask = (data >>12)&0xff;
+  tcamDataP->paraFrm.ppri = (data>>4)&0xff;
+  tcamDataP->paraFrm.pvidMask = data &0x0f00;
+  tcamDataP->paraFrm.pvid = data <<8;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_4,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.pvidMask = (data>>8)&0xff ;
+  tcamDataP->paraFrm.pvid = data&0x00ff;
+  for(i=0; i<22; i++)
+  {
+    retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_MATCH_DATA_1+i,&data);
+    if(retVal != GT_OK)
+	{
+     return retVal;
+	}
+    tcamDataP->paraFrm.frameOctetMask[i] = data>>8;
+    tcamDataP->paraFrm.frameOctet[i] = data&0xff;
+  }
+
+  return GT_OK;
+}
+static GT_STATUS tcamGetPage1Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+  int i;
+
+  for(i=0; i<25; i++)
+  {
+    retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P1_MATCH_DATA_23+i,&data);
+    if(retVal != GT_OK)
+	{
+     return retVal;
+	}
+    tcamDataP->paraFrm.frameOctetMask[i+23] = data>>8;
+    tcamDataP->paraFrm.frameOctet[i+23] = data&0xff;
+  }
+
+  return GT_OK;
+}
+
+static GT_STATUS tcamGetPage2Data(GT_QD_DEV *dev, GT_TCAM_DATA *tcamDataP)
+{
+  GT_STATUS       retVal;    /* Functions return value */
+  GT_U16          data;     /* temporary Data storage */
+
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_1,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.continu = data >>15;
+  tcamDataP->paraFrm.interrupt = (data >>14)&1;
+  tcamDataP->paraFrm.IncTcamCtr = (data>>13)&1;
+  tcamDataP->paraFrm.vidOverride = (data<<12)&1;
+  tcamDataP->paraFrm.vidData = data&0x07ff;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_2,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.nextId = (data>>8)&0xff;
+  tcamDataP->paraFrm.qpriOverride = (data>>7)&1;
+  tcamDataP->paraFrm.qpriData = (data>>4)&3;
+  tcamDataP->paraFrm.fpriOverride = (data>>3)&1;
+  tcamDataP->paraFrm.fpriData = data&7;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_3,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.qpriAvbOverride = (data>>15)&1;
+  tcamDataP->paraFrm.qpriAvbData = (data>>12)&3;
+  tcamDataP->paraFrm.dpvOverride  = (data>>11)&1;
+  tcamDataP->paraFrm.dpvData = data&0x7F;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_ACTION_4,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.factionOverride = (data>>15)&1;
+  tcamDataP->paraFrm.factionData = (data>>4)&0x7ff;
+  tcamDataP->paraFrm.ldBalanceOverride = (data>>3)&1;
+  tcamDataP->paraFrm.ldBalanceData = data&7;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_DEBUG_PORT,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.debugPort = (data)&0xf;
+  retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P2_ALL_HIT,&data);
+  if(retVal != GT_OK)
+  {
+     return retVal;
+  }
+  tcamDataP->paraFrm.highHit = (data>>8)&0xff;
+  tcamDataP->paraFrm.lowHit = data&0xff;
+  return GT_OK;
+}
+
+static GT_STATUS waitTcamReady(GT_QD_DEV           *dev)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 1;
+  
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL3_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_TCAM_OPERATION;
+      regAccess.rw_reg_list[0].data = 15;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        gtSemGive(dev,dev->tblRegsSem);
+        return retVal;
+      }
+    }
+#else
+    GT_U16          data;     /* temporary Data storage */
+    data = 1;
+    while(data == 1)
+    {
+        retVal = hwGetGlobal3RegField(dev,QD_REG_TCAM_OPERATION,15,1,&data);
+        if(retVal != GT_OK)
+        {
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+    }
+#endif
+    return GT_OK;
+}
+
+
+/*******************************************************************************
+* tcamOperationPerform
+*
+* DESCRIPTION:
+*       This function accesses TCAM Table
+*
+* INPUTS:
+*       tcamOp   - The tcam operation
+*       tcamData - address and data to be written into TCAM
+*
+* OUTPUTS:
+*       tcamData - data read from TCAM pointed by address
+*
+* RETURNS:
+*       GT_OK on success,
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+static GT_STATUS tcamOperationPerform
+(
+    IN    GT_QD_DEV           *dev,
+    IN    GT_TCAM_OPERATION   tcamOp,
+    INOUT GT_TCAM_OP_DATA     *opData
+)
+{
+    GT_STATUS       retVal;    /* Functions return value */
+    GT_U16          data;     /* temporary Data storage */
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    /* Wait until the tcam in ready. */
+    retVal = waitTcamReady(dev);
+    if(retVal != GT_OK)
+    {
+      gtSemGive(dev,dev->tblRegsSem);
+      return retVal;
+    }
+
+    /* Set the TCAM Operation register */
+    switch (tcamOp)
+    {
+        case TCAM_FLUSH_ALL:
+            data = (1 << 15) | (tcamOp << 12);
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case TCAM_FLUSH_ENTRY:
+            data = (1 << 15) | (tcamOp << 12) | (opData->tcamPage << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case TCAM_LOAD_ENTRY:
+           data = (1 << 15) | (tcamOp << 12) | (2 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            retVal = tcamSetPage2Data(dev, opData->tcamDataP);
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            data = (1 << 15) | (tcamOp << 12) | (1 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            retVal = tcamSetPage1Data(dev, opData->tcamDataP);
+             {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            data = (1 << 15) | (tcamOp << 12) | (0 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            retVal = tcamSetPage0Data(dev,  opData->tcamDataP);
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+            break;
+
+        case TCAM_PURGE_ENTRY:
+            data = (1 << 15) | (tcamOp << 12) | ((opData->tcamEntry)<< 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            data = 0x00ff ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        case TCAM_GET_NEXT_ENTRY:
+			{
+            data = (1 << 15) | (tcamOp << 12) | (0 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            /* Wait until the tcam in ready. */
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_OPERATION, &data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+			if(opData->tcamEntry == 0xff)  /* If ask to find the lowest entry*/
+			{
+			  if ((data&0xff)==0xff)
+			  {
+                retVal = hwReadGlobal3Reg(dev,QD_REG_TCAM_P0_KEYS_1, &data);
+                if(retVal != GT_OK)
+				{
+                  gtSemGive(dev,dev->tblRegsSem);
+                  return retVal;
+				}
+	            if(data==0x00ff)
+				{
+					/* No higher valid TCAM entry */
+					return GT_OK;
+				}
+				else
+				{
+					/* The highest valid TCAM entry found*/
+				}
+			  }
+			}
+
+            /* Get next entry and read the entry */
+            opData->tcamEntry = data&0xff;   
+           }
+        case TCAM_READ_ENTRY:
+			/* Read page 0 */
+            data = (1 << 15) | (tcamOp << 12) | (0 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            /* Wait until the tcam in ready. */
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            retVal = tcamGetPage0Data(dev, opData->tcamDataP);
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+			/* Read page 1 */
+            data = (1 << 15) | (tcamOp << 12) | (1 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            /* Wait until the tcam in ready. */
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            retVal = tcamGetPage1Data(dev, opData->tcamDataP);
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+
+			/* Read page 2 */
+            data = (1 << 15) | (tcamOp << 12) | (2 << 10) | (opData->tcamEntry) ;
+            retVal = hwWriteGlobal3Reg(dev,QD_REG_TCAM_OPERATION,data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            /* Wait until the tcam in ready. */
+            retVal = waitTcamReady(dev);
+            if(retVal != GT_OK)
+			{
+              gtSemGive(dev,dev->tblRegsSem);
+              return retVal;
+			}
+
+            retVal = tcamGetPage2Data(dev, opData->tcamDataP);
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+            break;
+
+        default:
+            
+            gtSemGive(dev,dev->tblRegsSem);
+            return GT_FAIL;
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+    return retVal;
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtUtils.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtUtils.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c
old mode 100644
new mode 100755
index 5c5f74a..2ddb29d
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct.c
@@ -18,6 +18,9 @@
 #include <gtHwCntl.h>
 #include <gtSem.h>
 
+#ifdef GT_USE_MAD
+#include <gtMad.h>
+#endif
 
 
 /*******************************************************************************
@@ -52,57 +55,57 @@ GT_STATUS analizePhy100MVCTResult
     OUT GT_CABLE_LEN *cableLen
 )
 {
-	int len;
-
-	GT_UNUSED_PARAM(dev);
-
-	switch((regValue & 0x6000) >> 13)
-	{
-		case 0:
-			/* test passed. No problem found. */
-			/* check if there is impedance mismatch */
-			if ((regValue & 0xFF) == 0xFF)
-			{
-				*cableStatus = GT_NORMAL_CABLE;
-				cableLen->normCableLen = GT_UNKNOWN_LEN;
-			}
-			else
-			{
-				*cableStatus = GT_IMPEDANCE_MISMATCH;
-				len = (int)FORMULA_PHY100M(regValue & 0xFF);
-				if(len <= 0)
-					cableLen->errCableLen = 0;
-				else
-					cableLen->errCableLen = (GT_U8)len;
-			}
-				
-			break;
-		case 1:
-			/* test passed. Cable is short. */
-			*cableStatus = GT_SHORT_CABLE;
-			len = (int)FORMULA_PHY100M(regValue & 0xFF);
-			if(len <= 0)
-				cableLen->errCableLen = 0;
-			else
-				cableLen->errCableLen = (GT_U8)len;
-			break;
-		case 2:
-			/* test passed. Cable is open. */
-			*cableStatus = GT_OPEN_CABLE;
-			len = (int)FORMULA_PHY100M(regValue & 0xFF);
-			if(len <= 0)
-				cableLen->errCableLen = 0;
-			else
-				cableLen->errCableLen = (GT_U8)len;
-			break;
-		case 3:
-		default:
-			/* test failed. No result is valid. */
-			*cableStatus = GT_TEST_FAIL;
-			break;
-	}
-
-	return GT_OK;
+    int len;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch((regValue & 0x6000) >> 13)
+    {
+        case 0:
+            /* test passed. No problem found. */
+            /* check if there is impedance mismatch */
+            if ((regValue & 0xFF) == 0xFF)
+            {
+                *cableStatus = GT_NORMAL_CABLE;
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+            }
+            else
+            {
+                *cableStatus = GT_IMPEDANCE_MISMATCH;
+                len = (int)FORMULA_PHY100M(regValue & 0xFF);
+                if(len <= 0)
+                    cableLen->errCableLen = 0;
+                else
+                    cableLen->errCableLen = (GT_U8)len;
+            }
+                
+            break;
+        case 1:
+            /* test passed. Cable is short. */
+            *cableStatus = GT_SHORT_CABLE;
+            len = (int)FORMULA_PHY100M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 2:
+            /* test passed. Cable is open. */
+            *cableStatus = GT_OPEN_CABLE;
+            len = (int)FORMULA_PHY100M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 3:
+        default:
+            /* test failed. No result is valid. */
+            *cableStatus = GT_TEST_FAIL;
+            break;
+    }
+
+    return GT_OK;
 }
 
 
@@ -138,67 +141,69 @@ GT_STATUS getCableStatus_Phy100M
     OUT GT_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status;
-	GT_U16 reg26, reg27;
+    GT_STATUS status;
+    GT_U16 reg26, reg27;
 
     DBG_INFO(("getCableStatus_100Phy Called.\n"));
 
-	/* 
-	 * 	phy should be in 100 Full Duplex.
-	 */
-	if((status= hwWritePhyReg(dev,hwPort,0,QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX)) != GT_OK)
-	{
-		return status;
-	}
-
-	/* 
-	 * start Virtual Cable Tester
-	 */
-	if((status= hwWritePhyReg(dev,hwPort,26,0x8000)) != GT_OK)
-	{
-		return status;
-	}
-
-	do
-	{
-		if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
-		{
-			return status;
-		}
-		
-	} while(reg26 & 0x8000);
-
-	/*
-	 * read the test result for RX Pair
-	 */
-	if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
-	{
-		return status;
-	}
-		
-	/*
-	 * read the test result for TX Pair
-	 */
-	if((status= hwReadPhyReg(dev,hwPort,27,&reg27)) != GT_OK)
-	{
-		return status;
-	}
-		
-	cableStatus->phyType = PHY_100M;
-
-	/*
-	 * analyze the test result for RX Pair
-	 */
-	analizePhy100MVCTResult(dev, reg26, &cableStatus->cableStatus[MDI_RX_PAIR], 
-							&cableStatus->cableLen[MDI_RX_PAIR]);
-
-	/*
-	 * analyze the test result for TX Pair
-	 */
-	analizePhy100MVCTResult(dev, reg27, &cableStatus->cableStatus[MDI_TX_PAIR], 
-							&cableStatus->cableLen[MDI_TX_PAIR]);
-
-	return status;
+
+    /* Wait until the Table is ready. */
+    /* 
+     *     phy should be in 100 Full Duplex.
+     */
+    if((status= hwWritePhyReg(dev,hwPort,0,QD_PHY_RESET | QD_PHY_SPEED | QD_PHY_DUPLEX)) != GT_OK)
+    {
+        return status;
+    }
+
+    /* 
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePhyReg(dev,hwPort,26,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+        {
+            return status;
+        }
+        
+    } while(reg26 & 0x8000);
+
+    /*
+     * read the test result for RX Pair
+     */
+    if((status= hwReadPhyReg(dev,hwPort,26,&reg26)) != GT_OK)
+    {
+        return status;
+    }
+        
+    /*
+     * read the test result for TX Pair
+     */
+    if((status= hwReadPhyReg(dev,hwPort,27,&reg27)) != GT_OK)
+    {
+        return status;
+    }
+        
+    cableStatus->phyType = PHY_100M;
+
+    /*
+     * analyze the test result for RX Pair
+     */
+    analizePhy100MVCTResult(dev, reg26, &cableStatus->cableStatus[MDI_RX_PAIR], 
+                            &cableStatus->cableLen[MDI_RX_PAIR]);
+
+    /*
+     * analyze the test result for TX Pair
+     */
+    analizePhy100MVCTResult(dev, reg27, &cableStatus->cableStatus[MDI_TX_PAIR], 
+                            &cableStatus->cableLen[MDI_TX_PAIR]);
+
+    return status;
 }
 
 static
@@ -249,46 +254,46 @@ GT_STATUS workAround_Phy100M
     OUT GT_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status = GT_OK;
+    GT_STATUS status = GT_OK;
 
-	/* 
-	 * If Cable Status is OPEN and the length is less than 15m,
-	 * then apply Work Around.
-	 */
+    /* 
+     * If Cable Status is OPEN and the length is less than 15m,
+     * then apply Work Around.
+     */
 
-	if((cableStatus->cableStatus[MDI_RX_PAIR] == GT_OPEN_CABLE) ||
-		(cableStatus->cableStatus[MDI_TX_PAIR] == GT_OPEN_CABLE))
-	{
-		/* must be disabled first and then enable again */
+    if((cableStatus->cableStatus[MDI_RX_PAIR] == GT_OPEN_CABLE) ||
+        (cableStatus->cableStatus[MDI_TX_PAIR] == GT_OPEN_CABLE))
+    {
+        /* must be disabled first and then enable again */
         disable1stWorkAround_Phy100M(dev,hwPort);
 
         enable1stWorkAround_Phy100M(dev,hwPort);
 
-		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
-		{
-			return status;
-		}
-		if((status= hwWritePhyReg(dev,hwPort,30,0x0002)) != GT_OK)
-		{
-			return status;
-		}
-
-		if((status = getCableStatus_Phy100M(dev,hwPort,cableStatus)) != GT_OK)
-		{
-			return status;
-		}
-		
-		if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
-		{
-			return status;
-		}
-		if((status= hwWritePhyReg(dev,hwPort,30,0x0000)) != GT_OK)
-		{
-			return status;
-		}
-	}
-
-	return status;
+        if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+        {
+            return status;
+        }
+        if((status= hwWritePhyReg(dev,hwPort,30,0x0002)) != GT_OK)
+        {
+            return status;
+        }
+
+        if((status = getCableStatus_Phy100M(dev,hwPort,cableStatus)) != GT_OK)
+        {
+            return status;
+        }
+        
+        if((status= hwWritePhyReg(dev,hwPort,29,0x000A)) != GT_OK)
+        {
+            return status;
+        }
+        if((status= hwWritePhyReg(dev,hwPort,30,0x0000)) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return status;
 }
 
 
@@ -313,7 +318,6 @@ GT_STATUS  enable1stWorkAround_Phy1000M
 
     if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
        return status;
-
     return GT_OK;
 }
 
@@ -370,105 +374,105 @@ GT_STATUS analizePhy1000MVCTResult
     OUT GT_CABLE_LEN *cableLen
 )
 {
-	GT_U16 u16Data;
-	int len;
-
-	GT_UNUSED_PARAM(dev);
-
-	switch((regValue & 0x6000) >> 13)
-	{
-		case 0:
-
-			/* Check Impedance Mismatch */
-			if ((regValue & 0xFF) < 0xFF)
-			{
-				/*  if the reflected amplitude is low it is good cable too.
-					for this registers values it is a good cable:
-					0xE23, 0xE24, 0xE25, 0xE26, 0xE27 */
-				if ((regValue < 0xE23) || (regValue > 0xE27))
-				{
-					*cableStatus = GT_IMPEDANCE_MISMATCH;
-					len = (int)FORMULA_PHY1000M(regValue & 0xFF);
-					if(len <= 0)
-						cableLen->errCableLen = 0;
-					else
-						cableLen->errCableLen = (GT_U8)len;
-					break;
-				}
-			}
-
-			/* test passed. No problem found. */
-			*cableStatus = GT_NORMAL_CABLE;
-
-			u16Data = reg17;
-
-			/* To get Cable Length, Link should be on and Speed should be 100M or 1000M */
-			if(!(u16Data & 0x0400))
-			{
-				cableLen->normCableLen = GT_UNKNOWN_LEN;
-				break;
-			}
-
-			if((u16Data & 0xC000) != 0x8000)
-			{
-				cableLen->normCableLen = GT_UNKNOWN_LEN;
-				break;
-			}
-
-			/*
-			 * read the test result for the selected MDI Pair
-			 */
-
-			u16Data = ((u16Data >> 7) & 0x7);
-
-			switch(u16Data)
-			{
-				case 0:
-					cableLen->normCableLen = GT_LESS_THAN_50M;
-					break;
-				case 1:
-					cableLen->normCableLen = GT_50M_80M;
-					break;
-				case 2:
-					cableLen->normCableLen = GT_80M_110M;
-					break;
-				case 3:
-					cableLen->normCableLen = GT_110M_140M;
-					break;
-				case 4:
-					cableLen->normCableLen = GT_MORE_THAN_140;
-					break;
-				default:
-					cableLen->normCableLen = GT_UNKNOWN_LEN;
-					break;
-			}
-			break;
-		case 1:
-			/* test passed. Cable is short. */
-			*cableStatus = GT_SHORT_CABLE;
-			len = (int)FORMULA_PHY1000M(regValue & 0xFF);
-			if(len <= 0)
-				cableLen->errCableLen = 0;
-			else
-				cableLen->errCableLen = (GT_U8)len;
-			break;
-		case 2:
-			/* test passed. Cable is open. */
-			*cableStatus = GT_OPEN_CABLE;
-			len = (int)FORMULA_PHY1000M(regValue & 0xFF);
-			if(len <= 0)
-				cableLen->errCableLen = 0;
-			else
-				cableLen->errCableLen = (GT_U8)len;
-			break;
-		case 3:
-		default:
-			/* test failed. No result is valid. */
-			*cableStatus = GT_TEST_FAIL;
-			break;
-	}
-
-	return GT_OK;
+    GT_U16 u16Data;
+    int len;
+
+    GT_UNUSED_PARAM(dev);
+
+    switch((regValue & 0x6000) >> 13)
+    {
+        case 0:
+
+            /* Check Impedance Mismatch */
+            if ((regValue & 0xFF) < 0xFF)
+            {
+                /*  if the reflected amplitude is low it is good cable too.
+                    for this registers values it is a good cable:
+                    0xE23, 0xE24, 0xE25, 0xE26, 0xE27 */
+                if ((regValue < 0xE23) || (regValue > 0xE27))
+                {
+                    *cableStatus = GT_IMPEDANCE_MISMATCH;
+                    len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+                    if(len <= 0)
+                        cableLen->errCableLen = 0;
+                    else
+                        cableLen->errCableLen = (GT_U8)len;
+                    break;
+                }
+            }
+
+            /* test passed. No problem found. */
+            *cableStatus = GT_NORMAL_CABLE;
+
+            u16Data = reg17;
+
+            /* To get Cable Length, Link should be on and Speed should be 100M or 1000M */
+            if(!(u16Data & 0x0400))
+            {
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+                break;
+            }
+
+            if((u16Data & 0xC000) != 0x8000)
+            {
+                cableLen->normCableLen = GT_UNKNOWN_LEN;
+                break;
+            }
+
+            /*
+             * read the test result for the selected MDI Pair
+             */
+
+            u16Data = ((u16Data >> 7) & 0x7);
+
+            switch(u16Data)
+            {
+                case 0:
+                    cableLen->normCableLen = GT_LESS_THAN_50M;
+                    break;
+                case 1:
+                    cableLen->normCableLen = GT_50M_80M;
+                    break;
+                case 2:
+                    cableLen->normCableLen = GT_80M_110M;
+                    break;
+                case 3:
+                    cableLen->normCableLen = GT_110M_140M;
+                    break;
+                case 4:
+                    cableLen->normCableLen = GT_MORE_THAN_140;
+                    break;
+                default:
+                    cableLen->normCableLen = GT_UNKNOWN_LEN;
+                    break;
+            }
+            break;
+        case 1:
+            /* test passed. Cable is short. */
+            *cableStatus = GT_SHORT_CABLE;
+            len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 2:
+            /* test passed. Cable is open. */
+            *cableStatus = GT_OPEN_CABLE;
+            len = (int)FORMULA_PHY1000M(regValue & 0xFF);
+            if(len <= 0)
+                cableLen->errCableLen = 0;
+            else
+                cableLen->errCableLen = (GT_U8)len;
+            break;
+        case 3:
+        default:
+            /* test failed. No result is valid. */
+            *cableStatus = GT_TEST_FAIL;
+            break;
+    }
+
+    return GT_OK;
 }
 
 
@@ -481,7 +485,7 @@ GT_STATUS analizePhy1000MVCTResult
 *
 * INPUTS:
 *       port - logical port number.
-*		reg17 - original value of reg17.
+*        reg17 - original value of reg17.
 *
 * OUTPUTS:
 *       cableStatus - the port copper cable status.
@@ -499,62 +503,62 @@ GT_STATUS analizePhy1000MVCTResult
 *******************************************************************************/
 static 
 GT_STATUS getCableStatus_Phy1000M
-(	
+(    
     IN  GT_QD_DEV *dev,
-    IN  GT_U8			hwPort,
-    IN  GT_U16 			reg17,
+    IN  GT_U8            hwPort,
+    IN  GT_U16             reg17,
     OUT GT_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status;
-	GT_U16 reg28;
-	int i;
+    GT_STATUS status;
+    GT_U16 reg28;
+    int i;
 
     DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
 
-	/* 
-	 * start Virtual Cable Tester
-	 */
-	if((status= hwWritePagedPhyReg(dev,hwPort,0,28,0,0x8000)) != GT_OK)
-	{
-		return status;
-	}
-
-	do
-	{
-		if((status= hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
-		{
-			return status;
-		}
-		
-	} while(reg28 & 0x8000);
-
-	cableStatus->phyType = PHY_1000M;
+    /* 
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePagedPhyReg(dev,hwPort,0,28,0,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPhyReg(dev,hwPort,28,&reg28)) != GT_OK)
+        {
+            return status;
+        }
+        
+    } while(reg28 & 0x8000);
+
+    cableStatus->phyType = PHY_1000M;
 
     DBG_INFO(("Reg28 after test : %0#x.\n", reg28));
 
-	for (i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		/*
-		 * read the test result for the selected MDI Pair
-		 */
-		if((status= hwReadPagedPhyReg(dev,hwPort,(GT_U8)i,28,0,&reg28)) != GT_OK)
-		{
-			return status;
-		}
-		
-		/*
-		 * analyze the test result for RX Pair
-		 */
-		if((status = analizePhy1000MVCTResult(dev, reg17, reg28, 
-								&cableStatus->cableStatus[i], 
-								&cableStatus->cableLen[i])) != GT_OK)
-		{
-			return status;
-		}
-	}
-
-	return GT_OK;
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the selected MDI Pair
+         */
+        if((status= hwReadPagedPhyReg(dev,hwPort,(GT_U8)i,28,0,&reg28)) != GT_OK)
+        {
+            return status;
+        }
+        
+        /*
+         * analyze the test result for RX Pair
+         */
+        if((status = analizePhy1000MVCTResult(dev, reg17, reg28, 
+                                &cableStatus->cableStatus[i], 
+                                &cableStatus->cableLen[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return GT_OK;
 }
 
 static
@@ -564,39 +568,46 @@ GT_STATUS workAround_Phy1000M
   GT_U8 hwPort
 )
 {
-	GT_STATUS status;
+    GT_STATUS status;
 
     DBG_INFO(("workAround for Gigabit Phy Called.\n"));
 
-	if((status = hwWritePhyReg(dev,hwPort,29,0x1e)) != GT_OK)
-	{
-		return status;
-	}
-		
-	if((status = hwWritePhyReg(dev,hwPort,30,0xcc00)) != GT_OK)
-	{
-		return status;
-	}
-
-	if((status = hwWritePhyReg(dev,hwPort,30,0xc800)) != GT_OK)
-	{
-		return status;
-	}
-	if((status = hwWritePhyReg(dev,hwPort,30,0xc400)) != GT_OK)
-	{
-		return status;
-	}
-	if((status = hwWritePhyReg(dev,hwPort,30,0xc000)) != GT_OK)
-	{
-		return status;
-	}
-	if((status = hwWritePhyReg(dev,hwPort,30,0xc100)) != GT_OK)
-	{
-		return status;
-	}
+    /* enable 1st work-around */
+    if ((status = hwWritePhyReg(dev, hwPort, 29, 0x0018)) != GT_OK)
+       return status;
+
+    if ((status = hwWritePhyReg(dev, hwPort, 30, 0x00c2)) != GT_OK)
+       return status;
+
+    if((status = hwWritePhyReg(dev,hwPort,29,0x1e)) != GT_OK)
+    {
+        return status;
+    }
+        
+    if((status = hwWritePhyReg(dev,hwPort,30,0xcc00)) != GT_OK)
+    {
+        return status;
+    }
+
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc800)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc400)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc000)) != GT_OK)
+    {
+        return status;
+    }
+    if((status = hwWritePhyReg(dev,hwPort,30,0xc100)) != GT_OK)
+    {
+        return status;
+    }
 
     DBG_INFO(("workAround for Gigabit Phy completed.\n"));
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -626,103 +637,103 @@ GT_STATUS workAround_Phy1000M
 *******************************************************************************/
 static 
 GT_STATUS getCableStatus_Phy1000MPage
-(	
+(    
     IN  GT_QD_DEV *dev,
-    IN  GT_U8			hwPort,
-	IN  GT_PHY_INFO		*phyInfo,
+    IN  GT_U8            hwPort,
+    IN  GT_PHY_INFO        *phyInfo,
     OUT GT_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status;
-	GT_U16 u16Data;
-	GT_U16 reg17 = 0;
-	int i;
+    GT_STATUS status;
+    GT_U16 u16Data;
+    GT_U16 reg17 = 0;
+    int i;
 
     DBG_INFO(("getCableStatus_Phy1000M Called.\n"));
 
-	/*
-	 * If Fiber is used, simply return with test fail.
-	 */
-	if(phyInfo->flag & GT_PHY_FIBER)
-	{
-		if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			return status;
-		}
-
-		if(u16Data & 0x400)
-		{
-			for (i=0; i<GT_MDI_PAIR_NUM; i++)
-			{
-				cableStatus->cableStatus[i] = GT_TEST_FAIL;
-			}
-			return GT_OK;
-		}
-	}
-
-	/*
-	 * If Copper is used and Link is on, get DSP Distance and put it in the
-	 * old reg17 format.(bit9:7 with DSP Distance)
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo->anyPage,&u16Data)) != GT_OK)
-	{
-		return status;
-	}
-
-	if(u16Data & 0x400)
-	{
-		reg17 = (u16Data & 0xC000) | 0x400;
-
-		if((status= hwReadPagedPhyReg(dev,hwPort,5,26,phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			return status;
-		}
-		reg17 |= ((u16Data & 0x7) << 7);
-	}
-
-	/* 
-	 * start Virtual Cable Tester
-	 */
-	if((status= hwWritePagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,0x8000)) != GT_OK)
-	{
-		return status;
-	}
-
-	do
-	{
-		if((status= hwReadPagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			return status;
-		}
-		
-	} while(u16Data & 0x8000);
-
-	cableStatus->phyType = PHY_1000M;
+    /*
+     * If Fiber is used, simply return with test fail.
+     */
+    if(phyInfo->flag & GT_PHY_FIBER)
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,1,17,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+
+        if(u16Data & 0x400)
+        {
+            for (i=0; i<GT_MDI_PAIR_NUM; i++)
+            {
+                cableStatus->cableStatus[i] = GT_TEST_FAIL;
+            }
+            return GT_OK;
+        }
+    }
+
+    /*
+     * If Copper is used and Link is on, get DSP Distance and put it in the
+     * old reg17 format.(bit9:7 with DSP Distance)
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo->anyPage,&u16Data)) != GT_OK)
+    {
+        return status;
+    }
+
+    if(u16Data & 0x400)
+    {
+        reg17 = (u16Data & 0xC000) | 0x400;
+
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,26,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+        reg17 |= ((u16Data & 0x7) << 7);
+    }
+
+    /* 
+     * start Virtual Cable Tester
+     */
+    if((status= hwWritePagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,0x8000)) != GT_OK)
+    {
+        return status;
+    }
+
+    do
+    {
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,16,phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+        
+    } while(u16Data & 0x8000);
+
+    cableStatus->phyType = PHY_1000M;
 
     DBG_INFO(("Page 5 of Reg16 after test : %0#x.\n", u16Data));
 
-	for (i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		/*
-		 * read the test result for the selected MDI Pair
-		 */
-		if((status= hwReadPagedPhyReg(dev,hwPort,5,(GT_U8)(16+i),phyInfo->anyPage,&u16Data)) != GT_OK)
-		{
-			return status;
-		}
-		
-		/*
-		 * analyze the test result for RX Pair
-		 */
-		if((status = analizePhy1000MVCTResult(dev, reg17, u16Data, 
-								&cableStatus->cableStatus[i], 
-								&cableStatus->cableLen[i])) != GT_OK)
-		{
-			return status;
-		}
-	}
-
-	return GT_OK;
+    for (i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        /*
+         * read the test result for the selected MDI Pair
+         */
+        if((status= hwReadPagedPhyReg(dev,hwPort,5,(GT_U8)(16+i),phyInfo->anyPage,&u16Data)) != GT_OK)
+        {
+            return status;
+        }
+        
+        /*
+         * analyze the test result for RX Pair
+         */
+        if((status = analizePhy1000MVCTResult(dev, reg17, u16Data, 
+                                &cableStatus->cableStatus[i], 
+                                &cableStatus->cableLen[i])) != GT_OK)
+        {
+            return status;
+        }
+    }
+
+    return GT_OK;
 }
 
 
@@ -747,8 +758,8 @@ GT_STATUS getCableStatus_Phy1000MPage
 *
 * COMMENTS:
 *       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are not supported by this API. For those devices, gvctGetAdvCableDiag 
-*		API can be used, instead.
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag 
+*        API can be used, instead.
 *
 *******************************************************************************/
 GT_STATUS gvctGetCableDiag
@@ -758,157 +769,161 @@ GT_STATUS gvctGetCableDiag
     OUT GT_CABLE_STATUS *cableStatus
 )
 {
-	GT_STATUS status;
-	GT_U8 hwPort;
-	GT_U16 orgReg0, orgReg17;
-	GT_BOOL ppuEn;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_U16 orgReg0, orgReg17;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
+
+#ifdef GT_USE_MAD
+	if (dev->use_mad==GT_TRUE)
+		return gvctGetCableDiag_mad(dev, port, cableStatus);
+#endif
 
     DBG_INFO(("gvctGetCableDiag Called.\n"));
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports VCT */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_VCT_CAPABLE))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Need to disable PPUEn for safe. */
-	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
-	{
-		ppuEn = GT_FALSE;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to disable PPUEn.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-		gtDelay(250);
-	}
-		
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	/*
-	 * save original register 17 value, which will be used later depending on
-	 * test result.
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&orgReg17)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to reset the Phy.\n"));
-		goto cableDiagCleanup;
-	}
-
-	/*
-	 * save Config Register data
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&orgReg0)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to reset the Phy.\n"));
-		goto cableDiagCleanup;
-	}
-
-	switch(phyInfo.vctType)
-	{
-		case GT_PHY_VCT_TYPE1:
-			enable1stWorkAround_Phy100M(dev,hwPort);
-			status = getCableStatus_Phy100M(dev,hwPort,cableStatus);
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+        
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    /*
+     * save original register 17 value, which will be used later depending on
+     * test result.
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,17,phyInfo.anyPage,&orgReg17)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        goto cableDiagCleanup;
+    }
+
+    /*
+     * save Config Register data
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,&orgReg0)) != GT_OK)
+    {
+        DBG_INFO(("Not able to reset the Phy.\n"));
+        goto cableDiagCleanup;
+    }
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_VCT_TYPE1:
+            enable1stWorkAround_Phy100M(dev,hwPort);
+            status = getCableStatus_Phy100M(dev,hwPort,cableStatus);
             /* every fast ethernet phy requires this work-around */
-			workAround_Phy100M(dev,hwPort,cableStatus);
-			disable1stWorkAround_Phy100M(dev,hwPort);
-			break;
-		case GT_PHY_VCT_TYPE2:
-			enable1stWorkAround_Phy1000M(dev,hwPort);
-			status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
-			disable1stWorkAround_Phy1000M(dev,hwPort);
-			break;
-		case GT_PHY_VCT_TYPE3:
-			enable1stWorkAround_Phy1000M(dev,hwPort);
-			workAround_Phy1000M(dev,hwPort);
-			status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
-			disable1stWorkAround_Phy1000M(dev,hwPort);
-			break;
-		case GT_PHY_VCT_TYPE4:
-			status = getCableStatus_Phy1000MPage(dev,hwPort,&phyInfo,cableStatus);
-			break;
-		default:
-			status = GT_FAIL;
-			break;
-	}
-	
-	if (!(phyInfo.flag & GT_PHY_GIGABIT))
-	{
-		if((status = hwPhyReset(dev,hwPort,orgReg0)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-	}
-	else
-	{
-		/*
-		 * restore Config Register Data
-		 */
-		if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,orgReg0)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-
-		/* soft reset */
-		if((status = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
-		{
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-	}
+            workAround_Phy100M(dev,hwPort,cableStatus);
+            disable1stWorkAround_Phy100M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE2:
+            enable1stWorkAround_Phy1000M(dev,hwPort);
+            status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+            disable1stWorkAround_Phy1000M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE3:
+            enable1stWorkAround_Phy1000M(dev,hwPort);
+            workAround_Phy1000M(dev,hwPort);
+            status = getCableStatus_Phy1000M(dev,hwPort,orgReg17,cableStatus);
+            disable1stWorkAround_Phy1000M(dev,hwPort);
+            break;
+        case GT_PHY_VCT_TYPE4:
+            status = getCableStatus_Phy1000MPage(dev,hwPort,&phyInfo,cableStatus);
+            break;
+        default:
+            status = GT_FAIL;
+            break;
+    }
+    
+    if (!(phyInfo.flag & GT_PHY_GIGABIT))
+    {
+        if((status = hwPhyReset(dev,hwPort,orgReg0)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+    }
+    else
+    {
+        /*
+         * restore Config Register Data
+         */
+        if((status= hwWritePagedPhyReg(dev,hwPort,0,0,phyInfo.anyPage,orgReg0)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+
+        /* soft reset */
+        if((status = hwPhyReset(dev,hwPort,0xFF)) != GT_OK)
+        {
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+    }
 
 cableDiagCleanup:
 
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to enable PPUEn.\n"));
-			status = GT_FAIL;
-		}
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return status;	
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;    
 }
 
 
@@ -917,7 +932,7 @@ cableDiagCleanup:
 *
 * DESCRIPTION:
 *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
-*		for 1000M phy
+*        for 1000M phy
 *
 * INPUTS:
 *       dev - device context.
@@ -936,77 +951,77 @@ cableDiagCleanup:
 *******************************************************************************/
 static GT_STATUS getExStatus1000M
 (
-    IN  GT_QD_DEV 		*dev,
+    IN  GT_QD_DEV         *dev,
     IN  GT_U8           hwPort,
     OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
 )
 {
-	GT_STATUS status;
-	GT_U16 u16Data, i;
-
-	/*
-	 * get data from 28_5 register
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,5,28,0,&u16Data)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read a Phy register.\n"));
-		return status;
-	}
-
-	/* if bit 6 is not set, it's not valid. */
-	if (!(u16Data & 0x0040))
-	{
-	    DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
-		extendedStatus->isValid = GT_FALSE;
-		return GT_OK;
-	}
-
-	extendedStatus->isValid = GT_TRUE;
-	
-	/* get Pair Polarity */
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		switch((u16Data >> i) & 0x1)
-		{
-			case 0:
-				extendedStatus->pairPolarity[i] = GT_POSITIVE;
-				break;
-			default:
-				extendedStatus->pairPolarity[i] = GT_NEGATIVE;
-				break;
-		}
-	}
-
-	/* get Pair Swap */
-	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
-	{
-		switch((u16Data >> (i+4)) & 0x1)
-		{
-			case 0:
-				extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
-				break;
-			default:
-				extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
-				break;
-		}
-	}
-
-	/*
-	 * get data from 28_4 register
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,4,28,0,&u16Data)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read a Phy register.\n"));
-		return status;
-	}
-
-	/* get Pair Skew */
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
-	}
-
-	return GT_OK;
+    GT_STATUS status;
+    GT_U16 u16Data, i;
+
+    /*
+     * get data from 28_5 register
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,28,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a Phy register.\n"));
+        return status;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x0040))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        extendedStatus->isValid = GT_FALSE;
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+    
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+                break;
+        }
+    }
+
+    /* get Pair Swap */
+    for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+    {
+        switch((u16Data >> (i+4)) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+                break;
+            default:
+                extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+                break;
+        }
+    }
+
+    /*
+     * get data from 28_4 register
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,4,28,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a Phy register.\n"));
+        return status;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+    return GT_OK;
 }
 
 
@@ -1015,7 +1030,7 @@ static GT_STATUS getExStatus1000M
 *
 * DESCRIPTION:
 *       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
-*		for 1000M phy with multiple page mode
+*        for 1000M phy with multiple page mode
 *
 * INPUTS:
 *       dev - device context.
@@ -1034,77 +1049,77 @@ static GT_STATUS getExStatus1000M
 *******************************************************************************/
 static GT_STATUS getExStatus1000MPage
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_U8	        hwPort,
+    IN  GT_QD_DEV         *dev,
+    IN  GT_U8            hwPort,
     OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
 )
 {
-	GT_STATUS status;
-	GT_U16 u16Data, i;
-
-	/*
-	 * get data from 21_5 register for pair swap
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,5,21,0,&u16Data)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read a paged Phy register.\n"));
-		return status;
-	}
-
-	/* if bit 6 is not set, it's not valid. */
-	if (!(u16Data & 0x0040))
-	{
-	    DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
-		extendedStatus->isValid = GT_FALSE;
-		return GT_OK;
-	}
-
-	extendedStatus->isValid = GT_TRUE;
-	
-	/* get Pair Polarity */
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		switch((u16Data >> i) & 0x1)
-		{
-			case 0:
-				extendedStatus->pairPolarity[i] = GT_POSITIVE;
-				break;
-			default:
-				extendedStatus->pairPolarity[i] = GT_NEGATIVE;
-				break;
-		}
-	}
-
-	/* get Pair Swap */
-	for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
-	{
-		switch((u16Data >> (i+4)) & 0x1)
-		{
-			case 0:
-				extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
-				break;
-			default:
-				extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
-				break;
-		}
-	}
-
-	/*
-	 * get data from 20_5 register for pair skew
-	 */
-	if((status= hwReadPagedPhyReg(dev,hwPort,5,20,0,&u16Data)) != GT_OK)
-	{
-	    DBG_INFO(("Not able to read a paged Phy register.\n"));
-		return status;
-	}
-
-	/* get Pair Skew */
-	for(i=0; i<GT_MDI_PAIR_NUM; i++)
-	{
-		extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
-	}
-
-	return GT_OK;
+    GT_STATUS status;
+    GT_U16 u16Data, i;
+
+    /*
+     * get data from 21_5 register for pair swap
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,21,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a paged Phy register.\n"));
+        return status;
+    }
+
+    /* if bit 6 is not set, it's not valid. */
+    if (!(u16Data & 0x0040))
+    {
+        DBG_INFO(("Valid Bit is not set (%0#x).\n", u16Data));
+        extendedStatus->isValid = GT_FALSE;
+        return GT_OK;
+    }
+
+    extendedStatus->isValid = GT_TRUE;
+    
+    /* get Pair Polarity */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        switch((u16Data >> i) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairPolarity[i] = GT_POSITIVE;
+                break;
+            default:
+                extendedStatus->pairPolarity[i] = GT_NEGATIVE;
+                break;
+        }
+    }
+
+    /* get Pair Swap */
+    for(i=0; i<GT_CHANNEL_PAIR_NUM; i++)
+    {
+        switch((u16Data >> (i+4)) & 0x1)
+        {
+            case 0:
+                extendedStatus->pairSwap[i] = GT_STRAIGHT_CABLE;
+                break;
+            default:
+                extendedStatus->pairSwap[i] = GT_CROSSOVER_CABLE;
+                break;
+        }
+    }
+
+    /*
+     * get data from 20_5 register for pair skew
+     */
+    if((status= hwReadPagedPhyReg(dev,hwPort,5,20,0,&u16Data)) != GT_OK)
+    {
+        DBG_INFO(("Not able to read a paged Phy register.\n"));
+        return status;
+    }
+
+    /* get Pair Skew */
+    for(i=0; i<GT_MDI_PAIR_NUM; i++)
+    {
+        extendedStatus->pairSkew[i] = ((u16Data >> i*4) & 0xF) * 8;
+    }
+
+    return GT_OK;
 }
 
 
@@ -1127,104 +1142,104 @@ static GT_STATUS getExStatus1000MPage
 *
 * COMMENTS:
 *       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
-*		are not supported by this API. For those devices, gvctGetAdvExtendedStatus 
-*		API can be used, instead.
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus 
+*        API can be used, instead.
 *
 *******************************************************************************/
 GT_STATUS gvctGet1000BTExtendedStatus
 (
-    IN  GT_QD_DEV 		*dev,
+    IN  GT_QD_DEV         *dev,
     IN  GT_LPORT        port,
     OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
 )
 {
-	GT_STATUS status;
-	GT_U8 hwPort;
-	GT_BOOL ppuEn;
-	GT_PHY_INFO	phyInfo;
-	GT_BOOL			autoOn;
-	GT_U16			pageReg;
+    GT_STATUS status;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+    GT_BOOL            autoOn;
+    GT_U16            pageReg;
 
     DBG_INFO(("gvctGetCableDiag Called.\n"));
-	hwPort = GT_LPORT_2_PHY(port);
-
-	gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
-
-	/* check if the port is configurable */
-	if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* check if the port supports VCT */
-	if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
-	{
-	    DBG_INFO(("Unknown PHY device.\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
-	{
-		DBG_INFO(("Not Supported\n"));
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_NOT_SUPPORTED;
-	}
-
-	/* Need to disable PPUEn for safe. */
-	if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
-	{
-		ppuEn = GT_FALSE;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to disable PPUEn.\n"));
-			gtSemGive(dev,dev->phyRegsSem);
-			return status;
-		}
-		gtDelay(250);
-	}
-
-	if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	switch(phyInfo.vctType)
-	{
-		case GT_PHY_VCT_TYPE2:
-			status = getExStatus1000M(dev,hwPort,extendedStatus);
-			break;
-		case GT_PHY_VCT_TYPE4:
-			status = getExStatus1000MPage(dev,hwPort,extendedStatus);
-			break;
-		default:
-	   		DBG_INFO(("Device is not supporting Extended Cable Status.\n"));
-			status = GT_NOT_SUPPORTED;
-	}
-
-	if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
-	{
-		gtSemGive(dev,dev->phyRegsSem);
-		return GT_FAIL;
-	}
-
-	if(ppuEn != GT_FALSE)
-	{
-		if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
-		{
-	    	DBG_INFO(("Not able to enable PPUEn.\n"));
-			status = GT_FAIL;
-		}
-	}
-
-	gtSemGive(dev,dev->phyRegsSem);
-	return status;
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if(driverPagedAccessStart(dev,hwPort,phyInfo.pageType,&autoOn,&pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    switch(phyInfo.vctType)
+    {
+        case GT_PHY_VCT_TYPE2:
+            status = getExStatus1000M(dev,hwPort,extendedStatus);
+            break;
+        case GT_PHY_VCT_TYPE4:
+            status = getExStatus1000MPage(dev,hwPort,extendedStatus);
+            break;
+        default:
+               DBG_INFO(("Device is not supporting Extended Cable Status.\n"));
+            status = GT_NOT_SUPPORTED;
+    }
+
+    if(driverPagedAccessStop(dev,hwPort,phyInfo.pageType,autoOn,pageReg) != GT_OK)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
 }
 
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct_mad.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct_mad.c
new file mode 100755
index 0000000..f80ae62
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVct_mad.c
@@ -0,0 +1,226 @@
+#include <Copyright.h>
+/*******************************************************************************
+* gtVct.c
+*
+* DESCRIPTION:
+*       API for Marvell Virtual Cable Tester.
+*
+* DEPENDENCIES:
+*       None.
+*
+* FILE REVISION NUMBER:
+*       $Revision: 1 $
+*******************************************************************************/
+#include <msApi.h>
+#include <gtVct.h>
+#include <gtDrvConfig.h>
+#include <gtDrvSwRegs.h>
+#include <gtHwCntl.h>
+#include <gtSem.h>
+
+#include <madApi.h>
+
+
+/*******************************************************************************
+* gvctGetCableStatus_mad
+*
+* DESCRIPTION:
+*       This routine perform the virtual cable test for the requested port,
+*       and returns the the status per MDI pair.
+*
+* INPUTS:
+*       port - logical port number.
+*
+* OUTPUTS:
+*       cableStatus - the port copper cable status.
+*       cableLen    - the port copper cable length.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvCableDiag 
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGetCableDiag_mad
+(
+    IN  GT_QD_DEV *dev,
+    IN  GT_LPORT        port,
+    OUT GT_CABLE_STATUS *cableStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_VCT_CAPABLE))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+        
+    if ( mdDiagGetCableStatus(&(dev->mad_dev),port, (MAD_CABLE_STATUS*)cableStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGetCableStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;    
+}
+
+
+
+/*******************************************************************************
+* gvctGet1000BTExtendedStatus_mad
+*
+* DESCRIPTION:
+*       This routine retrieves Pair Skew, Pair Swap, and Pair Polarity
+*
+* INPUTS:
+*       dev - device context.
+*       port - logical port number.
+*
+* OUTPUTS:
+*       extendedStatus - extended cable status.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       Internal Gigabit Phys in 88E6165 family and 88E6351 family devices
+*        are not supported by this API. For those devices, gvctGetAdvExtendedStatus 
+*        API can be used, instead.
+*
+*******************************************************************************/
+GT_STATUS gvctGet1000BTExtendedStatus_mad
+(
+    IN  GT_QD_DEV         *dev,
+    IN  GT_LPORT        port,
+    OUT GT_1000BT_EXTENDED_STATUS *extendedStatus
+)
+{
+    GT_STATUS status=GT_OK;
+    GT_U8 hwPort;
+    GT_BOOL ppuEn;
+    GT_PHY_INFO    phyInfo;
+
+    DBG_INFO(("gvctGetCableDiag_mad Called.\n"));
+    hwPort = GT_LPORT_2_PHY(port);
+
+    gtSemTake(dev,dev->phyRegsSem,OS_WAIT_FOREVER);
+
+    /* check if the port is configurable */
+    if((phyInfo.phyId=GT_GET_PHY_ID(dev,hwPort)) == GT_INVALID_PHY)
+    {
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* check if the port supports VCT */
+    if(driverFindPhyInformation(dev,hwPort,&phyInfo) != GT_OK)
+    {
+        DBG_INFO(("Unknown PHY device.\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_FAIL;
+    }
+
+    if (!(phyInfo.flag & GT_PHY_EX_CABLE_STATUS))
+    {
+        DBG_INFO(("Not Supported\n"));
+        gtSemGive(dev,dev->phyRegsSem);
+        return GT_NOT_SUPPORTED;
+    }
+
+    /* Need to disable PPUEn for safe. */
+    if(gsysGetPPUEn(dev,&ppuEn) != GT_OK)
+    {
+        ppuEn = GT_FALSE;
+    }
+
+    if(ppuEn != GT_FALSE)
+    {
+        if((status= gsysSetPPUEn(dev,GT_FALSE)) != GT_OK)
+        {
+            DBG_INFO(("Not able to disable PPUEn.\n"));
+            gtSemGive(dev,dev->phyRegsSem);
+            return status;
+        }
+        gtDelay(250);
+    }
+
+    if ( mdDiagGet1000BTExtendedStatus(&(dev->mad_dev),port,(MAD_1000BT_EXTENDED_STATUS*)extendedStatus) != MAD_OK)
+    {
+      DBG_INFO(("Failed to run mdDiagGet1000BTExtendedStatus.\n"));
+      gtSemGive(dev,dev->phyRegsSem);
+      return GT_FALSE;
+    }
+
+
+    if(ppuEn != GT_FALSE)
+    {
+        if(gsysSetPPUEn(dev,ppuEn) != GT_OK)
+        {
+            DBG_INFO(("Not able to enable PPUEn.\n"));
+            status = GT_FAIL;
+        }
+    }
+
+    gtSemGive(dev,dev->phyRegsSem);
+    return status;
+}
+
+
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVersion.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtVersion.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtWeight.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtWeight.c
old mode 100644
new mode 100755
index e2437d5..6ea9441
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtWeight.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/gtWeight.c
@@ -23,11 +23,11 @@
 *
 * DESCRIPTION:
 *       Programmable Round Robin Weights.
-*		Each port has 4 output Queues. Queue 3 has the highest priority and 
-*		Queue 0 has the lowest priority. When a scheduling mode of port is 
-*		configured as Weighted Round Robin queuing mode, the access sequece of the 
-*		Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
-*		This sequence can be configured with this API.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and 
+*        Queue 0 has the lowest priority. When a scheduling mode of port is 
+*        configured as Weighted Round Robin queuing mode, the access sequece of the 
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This sequence can be configured with this API.
 *
 * INPUTS:
 *       weight - access sequence of the queue
@@ -38,7 +38,7 @@
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -46,133 +46,216 @@
 *******************************************************************************/
 GT_STATUS gsysSetQoSWeight
 (
-    IN  GT_QD_DEV 		*dev,
-    IN  GT_QoS_WEIGHT	*weight
+    IN  GT_QD_DEV         *dev,
+    IN  GT_QoS_WEIGHT    *weight
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data;
-	GT_U32		len, i;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data;
+    GT_U32        len, i;
 
     DBG_INFO(("gsysSetQoSWeight Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	if (weight->len > 128)
-	{
+    if (weight->len > 128)
+    {
         DBG_INFO(("GT_BAD_PARAM\n"));
-		return GT_BAD_PARAM;
-	}
-
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
-
-	len = weight->len/4;
-
-	/* program QoS Weight Table, 4 sequences at a time */
-
-	for(i=0; i<len; i++)
-	{
-	    /* Wait until the QoS Weight Table is ready. */
-    	data = 1;
-	    while(data == 1)
-    	{
-	        retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
-    	    if(retVal != GT_OK)
-        	{
-				gtSemGive(dev,dev->tblRegsSem);
-    	        return retVal;
-        	}
-	    }
-
-		data =  (GT_U16)((1 << 15) | (i << 8) | 
-				(weight->queue[i*4] & 0x3) |
-				((weight->queue[i*4+1] & 0x3) << 2) |
-				((weight->queue[i*4+2] & 0x3) << 4) |
-				((weight->queue[i*4+3] & 0x3) << 6));
-
-		retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
-	    if(retVal != GT_OK)
-    	{
-	   	    DBG_INFO(("Failed.\n"));
+        return GT_BAD_PARAM;
+    }
+
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+
+    len = weight->len/4;
+
+    /* program QoS Weight Table, 4 sequences at a time */
+
+    for(i=0; i<len; i++)
+    {
+        /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data =  (GT_U16)((1 << 15) | (i << 8) | 
+            (weight->queue[i*4] & 0x3) |
+            ((weight->queue[i*4+1] & 0x3) << 2) |
+            ((weight->queue[i*4+2] & 0x3) << 4) |
+            ((weight->queue[i*4+3] & 0x3) << 6));
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      if(retVal != GT_OK)
+      {
+        return retVal;
+      }
+    }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+        }
+
+        data =  (GT_U16)((1 << 15) | (i << 8) | 
+                (weight->queue[i*4] & 0x3) |
+                ((weight->queue[i*4+1] & 0x3) << 2) |
+                ((weight->queue[i*4+2] & 0x3) << 4) |
+                ((weight->queue[i*4+3] & 0x3) << 6));
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
             gtSemGive(dev,dev->tblRegsSem);
-    	    return retVal;
-	    }
-	}
-
-	/* program remaining sequences if any */
-	i = weight->len % 4;
-	if (i)
-	{
-	    /* Wait until the QoS Weight Table is ready. */
-    	data = 1;
-	    while(data == 1)
-    	{
-	        retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
-    	    if(retVal != GT_OK)
-        	{
-	            gtSemGive(dev,dev->tblRegsSem);
-    	        return retVal;
-        	}
-	    }
-		
-		data =  (GT_U16)((1 << 15) | (len << 8));
-		
-		switch (i)
-		{
-			case 3:
-				data |= ((weight->queue[len*4+2] & 0x3) << 4);
-			case 2:
-				data |= ((weight->queue[len*4+1] & 0x3) << 2);
-			case 1:
-				data |= ((weight->queue[len*4+0] & 0x3) << 0);
-				break;
-			default:
-		   	    DBG_INFO(("Should not come to this point.\n"));
-	            gtSemGive(dev,dev->tblRegsSem);
-				return GT_FALSE;
-		}
-
-		retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
-	    if(retVal != GT_OK)
-    	{
-	   	    DBG_INFO(("Failed.\n"));
+            return retVal;
+        }
+#endif
+    }
+
+    /* program remaining sequences if any */
+    i = weight->len % 4;
+    if (i)
+    {
+        /* Wait until the QoS Weight Table is ready. */
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 2;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[0].data = 15;
+          regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+          regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+          data =  (GT_U16)((1 << 15) | (len << 8));
+          switch (i)
+          {
+            case 3:
+                data |= ((weight->queue[len*4+2] & 0x3) << 4);
+            case 2:
+                data |= ((weight->queue[len*4+1] & 0x3) << 2);
+            case 1:
+                data |= ((weight->queue[len*4+0] & 0x3) << 0);
+            break;
+            default:
+                DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+            return GT_FALSE;
+          }
+          regAccess.rw_reg_list[1].data = data;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          if(retVal != GT_OK)
+          {
+            return retVal;
+          }
+        }
+#else
+        data = 1;
+        while(data == 1)
+        {
+            retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
+            if(retVal != GT_OK)
+            {
+                gtSemGive(dev,dev->tblRegsSem);
+                return retVal;
+            }
+        }
+        
+        data =  (GT_U16)((1 << 15) | (len << 8));
+        
+        switch (i)
+        {
+            case 3:
+                data |= ((weight->queue[len*4+2] & 0x3) << 4);
+            case 2:
+                data |= ((weight->queue[len*4+1] & 0x3) << 2);
+            case 1:
+                data |= ((weight->queue[len*4+0] & 0x3) << 0);
+                break;
+            default:
+                   DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_FALSE;
+        }
+
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
             gtSemGive(dev,dev->tblRegsSem);
-    	    return retVal;
-	    }
-	}
+            return retVal;
+        }
+#endif
+    }
 
-	/* Write the lengh of the sequence */
+    /* Write the lengh of the sequence */
 
     /* Wait until the QoS Weight Table is ready. */
-   	data = 1;
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data =  (GT_U16)((1 << 15) | (0x20 << 8) | weight->len);
+      regAccess.rw_reg_list[1].data = data;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+    }
+#else
+       data = 1;
     while(data == 1)
-   	{
+       {
         retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
-   	    if(retVal != GT_OK)
-       	{
+           if(retVal != GT_OK)
+           {
             gtSemGive(dev,dev->tblRegsSem);
-   	        return retVal;
-       	}
+               return retVal;
+           }
     }
 
-	data =  (GT_U16)((1 << 15) | (0x20 << 8) | weight->len);
-		
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+    data =  (GT_U16)((1 << 15) | (0x20 << 8) | weight->len);
+        
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+#endif
 
-	gtSemGive(dev,dev->tblRegsSem);
+    gtSemGive(dev,dev->tblRegsSem);
 
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+           return retVal;
     }
 
-	return GT_OK;
+    return GT_OK;
 }
 
 
@@ -181,11 +264,11 @@ GT_STATUS gsysSetQoSWeight
 *
 * DESCRIPTION:
 *       Programmable Round Robin Weights.
-*		Each port has 4 output Queues. Queue 3 has the highest priority and 
-*		Queue 0 has the lowest priority. When a scheduling mode of port is 
-*		configured as Weighted Round Robin queuing mode, the access sequece of the 
-*		Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
-*		This routine retrieves the access sequence of the Queue.
+*        Each port has 4 output Queues. Queue 3 has the highest priority and 
+*        Queue 0 has the lowest priority. When a scheduling mode of port is 
+*        configured as Weighted Round Robin queuing mode, the access sequece of the 
+*        Queue is 3,2,3,1,3,2,3,0,3,2,3,1,3,2,3 by default.
+*        This routine retrieves the access sequence of the Queue.
 *
 * INPUTS:
 *       None.
@@ -196,7 +279,7 @@ GT_STATUS gsysSetQoSWeight
 * RETURNS:
 *       GT_OK      - on success
 *       GT_FAIL    - on error
-*		GT_NOT_SUPPORTED - if current device does not support this feature.
+*        GT_NOT_SUPPORTED - if current device does not support this feature.
 *
 * COMMENTS:
 *       None
@@ -204,130 +287,192 @@ GT_STATUS gsysSetQoSWeight
 *******************************************************************************/
 GT_STATUS gsysGetQoSWeight
 (
-    IN  GT_QD_DEV 		*dev,
-    OUT GT_QoS_WEIGHT	*weight
+    IN  GT_QD_DEV         *dev,
+    OUT GT_QoS_WEIGHT    *weight
 )
 {
-    GT_STATUS	retVal;         /* Functions return value.      */
-	GT_U16		data, i;
-	GT_U32		len;
+    GT_STATUS    retVal;         /* Functions return value.      */
+    GT_U16        data, i;
+    GT_U32        len;
 
     DBG_INFO(("gsysGetQoSWeight Called.\n"));
 
-	/* Check if Switch supports this feature. */
-	if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
+    /* Check if Switch supports this feature. */
+    if (!IS_IN_DEV_GROUP(dev,DEV_QoS_WEIGHT))
     {
         DBG_INFO(("GT_NOT_SUPPORTED\n"));
-		return GT_NOT_SUPPORTED;
+        return GT_NOT_SUPPORTED;
     }
 
-	gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
+    gtSemTake(dev,dev->tblRegsSem,OS_WAIT_FOREVER);
 
-	/* Read the lengh of the sequence */
+    /* Read the lengh of the sequence */
 
     /* Wait until the QoS Weight Table is ready. */
-   	data = 1;
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 3;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = 15;
+      regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      data = (0x20 << 8);
+      regAccess.rw_reg_list[1].data = data;
+      regAccess.rw_reg_list[2].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[2].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[2].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[2].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      data = qdLong2Short(regAccess.rw_reg_list[2].data);
+    }
+#else
+       data = 1;
     while(data == 1)
-   	{
+       {
         retVal = hwGetGlobal2RegField(dev,QD_REG_QOS_WEIGHT,15,1,&data);
-   	    if(retVal != GT_OK)
-       	{
-			gtSemGive(dev,dev->tblRegsSem);
-   	        return retVal;
-       	}
+           if(retVal != GT_OK)
+           {
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+           }
     }
 
-	data = (0x20 << 8);
-		
-	retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+    data = (0x20 << 8);
+        
+    retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
     }
 
-	retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+    retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
     if(retVal != GT_OK)
-   	{
-   	    DBG_INFO(("Failed.\n"));
-		gtSemGive(dev,dev->tblRegsSem);
-   	    return retVal;
+       {
+           DBG_INFO(("Failed.\n"));
+        gtSemGive(dev,dev->tblRegsSem);
+           return retVal;
     }
 
-	weight->len = data & 0xFF;
-
-	len = weight->len/4;
-
-	/* read QoS Weight Table, 4 sequences at a time */
-
-	for(i=0; i<len; i++)
-	{
-		data = i << 8;
-
-		retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
-	    if(retVal != GT_OK)
-    	{
-	   	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-    	    return retVal;
-	    }
-
-		retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
-    	if(retVal != GT_OK)
-	   	{
-   		    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-   	    	return retVal;
-	    }
-
-		weight->queue[i*4] = data & 0x3;
-		weight->queue[i*4+1] = (data >> 2) & 0x3;
-		weight->queue[i*4+2] = (data >> 4) & 0x3;
-		weight->queue[i*4+3] = (data >> 6) & 0x3;
-
-	}
-
-	/* read remaining sequences if any */
-	i = (GT_U16) (weight->len % 4);
-	if (i)
-	{
-		data = (GT_U16)(len << 8);
-		
-		retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
-	    if(retVal != GT_OK)
-    	{
-	   	    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-    	    return retVal;
-	    }
-
-		retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
-    	if(retVal != GT_OK)
-	   	{
-   		    DBG_INFO(("Failed.\n"));
-			gtSemGive(dev,dev->tblRegsSem);
-   	    	return retVal;
-	    }
-
-		switch (i)
-		{
-			case 3:
-				weight->queue[len*4+2] = (data >> 4) & 0x3;
-			case 2:
-				weight->queue[len*4+1] = (data >> 2) & 0x3;
-			case 1:
-				weight->queue[len*4] = data & 0x3;
-				break;
-			default:
-		   	    DBG_INFO(("Should not come to this point.\n"));
-				gtSemGive(dev,dev->tblRegsSem);
-				return GT_FALSE;
-		}
-	}
-
-	gtSemGive(dev,dev->tblRegsSem);
-
-	return GT_OK;
+    weight->len = data & 0xFF;
+
+    len = weight->len/4;
+
+    /* read QoS Weight Table, 4 sequences at a time */
+
+    for(i=0; i<len; i++)
+    {
+        data = i << 8;
+
+#ifdef GT_RMGMT_ACCESS
+    {
+      HW_DEV_REG_ACCESS regAccess;
+
+      regAccess.entries = 2;
+
+      regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+      regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[0].data = data;
+      regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+      regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+      regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+      regAccess.rw_reg_list[1].data = 0;
+      retVal = hwAccessMultiRegs(dev, &regAccess);
+      data = qdLong2Short(regAccess.rw_reg_list[1].data);
+    }
+#else
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+
+        weight->queue[i*4] = data & 0x3;
+        weight->queue[i*4+1] = (data >> 2) & 0x3;
+        weight->queue[i*4+2] = (data >> 4) & 0x3;
+        weight->queue[i*4+3] = (data >> 6) & 0x3;
+
+    }
+
+    /* read remaining sequences if any */
+    i = (GT_U16) (weight->len % 4);
+    if (i)
+    {
+        data = (GT_U16)(len << 8);
+        
+#ifdef GT_RMGMT_ACCESS
+        {
+          HW_DEV_REG_ACCESS regAccess;
+
+          regAccess.entries = 2;
+
+          regAccess.rw_reg_list[0].cmd = HW_REG_WRITE;
+          regAccess.rw_reg_list[0].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[0].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[0].data = data;
+          regAccess.rw_reg_list[1].cmd = HW_REG_READ;
+          regAccess.rw_reg_list[1].addr = CALC_SMI_DEV_ADDR(dev, 0, GLOBAL2_REG_ACCESS);
+          regAccess.rw_reg_list[1].reg = QD_REG_QOS_WEIGHT;
+          regAccess.rw_reg_list[1].data = 0;
+          retVal = hwAccessMultiRegs(dev, &regAccess);
+          data = qdLong2Short(regAccess.rw_reg_list[1].data);
+        }
+#else
+        retVal = hwWriteGlobal2Reg(dev, QD_REG_QOS_WEIGHT, data);
+        if(retVal != GT_OK)
+        {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+            return retVal;
+        }
+
+        retVal = hwReadGlobal2Reg(dev, QD_REG_QOS_WEIGHT, &data);
+#endif
+        if(retVal != GT_OK)
+           {
+               DBG_INFO(("Failed.\n"));
+            gtSemGive(dev,dev->tblRegsSem);
+               return retVal;
+        }
+
+        switch (i)
+        {
+            case 3:
+                weight->queue[len*4+2] = (data >> 4) & 0x3;
+            case 2:
+                weight->queue[len*4+1] = (data >> 2) & 0x3;
+            case 1:
+                weight->queue[len*4] = data & 0x3;
+                break;
+            default:
+                   DBG_INFO(("Should not come to this point.\n"));
+                gtSemGive(dev,dev->tblRegsSem);
+                return GT_FALSE;
+        }
+    }
+
+    gtSemGive(dev,dev->tblRegsSem);
+
+    return GT_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/makefile
old mode 100644
new mode 100755
index 96881a0..3fe953d
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/makefile
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/msapi/makefile
@@ -1,4 +1,5 @@
 # Source files in this directory
+TARGET = 
 CSOURCES	= gtBrgFdb.c gtBrgStp.c gtBrgVlan.c \
 			gtEvents.c \
 			gtPortCtrl.c gtPortStat.c gtPortStatus.c \
@@ -14,13 +15,13 @@ ASOURCES	=
 
 # Include common variable definitions
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.defs
+include $(DSDT_TOOL_DIR)\make.defs
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.defs
+include $(DSDT_TOOL_DIR)\makewce.defs
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.defs
+include $(DSDT_TOOL_DIR)/makelnx.defs
 endif
 
 # Add in extra stuffs
@@ -28,15 +29,20 @@ EXTRA_INCLUDE	+=
 EXTRA_DEFINE	+=
 ADDED_CFLAGS	+=
 
+ifeq ($(DSDT_USE_MAD),TRUE)
+CSOURCES	+= gtPhyCtrl_mad.c gtPhyInt_mad.c gtVct_mad.c gtAdvVct_mad.c
+ADDED_CFLAGS	+= -DGT_USE_MAD
+endif
+
 # Include common build rules
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.rules
+include $(DSDT_TOOL_DIR)\make.rules
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.rules
+include $(DSDT_TOOL_DIR)\makewce.rules
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.rules
+include $(DSDT_TOOL_DIR)/makelnx.rules
 endif
 
 # end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtDebug.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtDebug.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c
old mode 100644
new mode 100755
index 74500c1..c8b1ecd
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtMiiSmiIf.c
@@ -21,10 +21,19 @@
 #include <platformDeps.h>
 #include <gtSem.h>
 
+/* Local sub-functions */
 GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
                         unsigned int* value);
 GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MIIReg,
                        unsigned int value);
+static GT_BOOL fgtReadMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int miiReg, unsigned int* value);
+static GT_BOOL fgtWriteMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int miiReg, unsigned int value);
+
+#ifdef GT_RMGMT_ACCESS
+static GT_BOOL fgtAccessRegs(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+static GT_BOOL qdMultiAddrAccess(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList);
+#endif
+
 /*******************************************************************************
 * miiSmiIfInit
 *
@@ -52,103 +61,113 @@ GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int MI
 *******************************************************************************/
 GT_U16 miiSmiIfInit
 (
-	IN  GT_QD_DEV    *dev,
-	OUT GT_BOOL * highSmiDevAddr
+    IN  GT_QD_DEV    *dev,
+    OUT GT_BOOL * highSmiDevAddr
 )
 {
-	GT_STATUS status;
-	GT_U16 data, data1;
+    GT_STATUS status;
+    GT_U16 data, data1;
 
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR,QD_REG_SWITCH_ID,&data)) != GT_OK)
-	{
-		return 0;
-	}
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
 
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
-	{
-		return 0;
-	}
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
 
-	switch(data & 0xFF00)
-	{
-		case 0x0200:
-		case 0x0300:
-		case 0x0500:
-		case 0x0600:
-		case 0x1500:
-		case 0xF500:
-		case 0xF900:
-			if (data == data1)
-			{
-				*highSmiDevAddr = GT_FALSE;
-				return data;
-			}
-			break;
-		default:
-			break;
-	}
-
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x10,QD_REG_SWITCH_ID,&data)) != GT_OK)
-	{
-		return 0;
-	}
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xC000:		/* Melody */
+        case 0x0700:		/* Spinnaker */
+        case 0x2200:		/* Spinnaker */
+        case 0x2500:		/* Spinnaker */
+        case 0xF500:
+        case 0xF900:
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_FALSE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
 
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x11,QD_REG_SWITCH_ID,&data1)) != GT_OK)
-	{
-		return 0;
-	}
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x10,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
 
-	switch(data & 0xFF00)
-	{
-		case 0x0200:
-		case 0x0300:
-		case 0x0500:
-		case 0x0600:
-		case 0x1500:
-		case 0xF500:
-		case 0xF900:
-			if (data == data1)
-			{
-				*highSmiDevAddr = GT_TRUE;
-				return data;
-			}
-			break;
-		default:
-			break;
-	}
-
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT,QD_REG_SWITCH_ID,&data)) != GT_OK)
-	{
-		return 0;
-	}
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR+0x11,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
 
-	if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
-	{
-		return 0;
-	}
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xC000:		/* Melody */
+        case 0x0700:		/* Spinnaker */
+        case 0x2200:		/* Spinnaker */
+        case 0x2500:		/* Spinnaker */
+        case 0xF500:
+        case 0xF900:
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_TRUE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
 
-	switch(data & 0xFF00)
-	{
-		case 0x0800:
-		case 0x1A00:
-		case 0x1000:
-		case 0x0900:
-		case 0x0400:
-		case 0x1200:
-		case 0x1400:
-		case 0x1600:
-		case 0x1700:
-		case 0x3200:
-		case 0x3700:
-			if (data == data1)
-			{
-				*highSmiDevAddr = GT_FALSE;
-				return data;
-			}
-			break;
-		default:
-			break;
-	}
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT,QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    if((status = miiSmiIfReadRegister(dev,PORT_REGS_START_ADDR_8PORT+1,QD_REG_SWITCH_ID,&data1)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0800:
+        case 0x1A00:
+        case 0x1000:
+        case 0x0900:
+        case 0x0400:
+        case 0x1200:
+        case 0x1400:
+        case 0x1600:
+        case 0x1700:
+        case 0x3200:
+        case 0x3700:
+        case 0x2400:    /* Agate */
+        case 0x3500:    /* Agate */
+            if (data == data1)
+            {
+                *highSmiDevAddr = GT_FALSE;
+                return data;
+            }
+            break;
+        default:
+            break;
+    }
 
     return 0;
 }
@@ -162,10 +181,10 @@ GT_U16 miiSmiIfInit
 *
 * INPUTS:
 *       baseAddr - either 0x0 or 0x10. Indicates whether to use the low device 
-*					register address or high device register address.
-*					The device register range is from 0x0 to 0xF or from 0x10 
-*					to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
-*					switchs.
+*                    register address or high device register address.
+*                    The device register range is from 0x0 to 0xF or from 0x10 
+*                    to 0x1F for 5 port switchs and from 0x0 to 0x1B for 8 port 
+*                    switchs.
 *
 * OUTPUTS:
 *       None.
@@ -180,60 +199,71 @@ GT_U16 miiSmiIfInit
 *******************************************************************************/
 GT_U16 miiSmiManualIfInit
 (
-	IN  GT_QD_DEV   *dev,
-	IN  GT_U32		baseAddr
+    IN  GT_QD_DEV   *dev,
+    IN  GT_U32        baseAddr
 )
 {
-	GT_STATUS status;
-	GT_U16 data;
+    GT_STATUS status;
+    GT_U16 data;
 
-	if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
-	{
-		return 0;
-	}
 
-	switch(data & 0xFF00)
-	{
-		case 0x0200:
-		case 0x0300:
-		case 0x0500:
-		case 0x0600:
-		case 0x1500:
-		case 0xF500:
-		case 0xF900:
-			return data;
-		default:
-			break;
-	}
-	if(baseAddr != 0)
-		return 0;
-
-	if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR_8PORT+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
-	{
-		return 0;
-	}
+    if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
 
-	switch(data & 0xFF00)
-	{
-		case 0x0800:
-		case 0x1A00:
-		case 0x1000:
-		case 0x0900:
-		case 0x0400:
-		case 0x1200:
-		case 0x1400:
-		case 0x1600:
-		case 0x3200:
-		case 0x1700:
-		case 0x3700:
-			return data;
-		default:
-			break;
-	}
+    switch(data & 0xFF00)
+    {
+        case 0x0200:
+        case 0x0300:
+        case 0x0500:
+        case 0x0600:
+        case 0x1500:
+        case 0xF500:
+        case 0xF900:
+        case 0x0700:		/* Spinnaker */
+        case 0x2200:		/* Spinnaker */
+        case 0x2500:		/* Spinnaker */
+            return data;
+        case 0xC000:		/* Melody, Now it could be 0xc00 - 0xc07 */
+            return data&0xFF0F;
+        default:
+            break;
+    }
+    if(baseAddr != 0)
+        return 0;
+
+    if((status = miiSmiIfReadRegister(dev,(GT_U8)(PORT_REGS_START_ADDR_8PORT+baseAddr),QD_REG_SWITCH_ID,&data)) != GT_OK)
+    {
+        return 0;
+    }
+
+    switch(data & 0xFF00)
+    {
+        case 0x0800:
+        case 0x1A00:
+        case 0x1000:
+        case 0x0900:
+        case 0x0400:
+        case 0x1200:
+        case 0x1400:
+        case 0x1600:
+        case 0x3200:
+        case 0x1700:
+        case 0x3700:
+        case 0x2400:    /* Agate */
+        case 0x3500:    /* Agate */
+            return data;
+        default:
+            break;
+    }
 
     return 0;
 }
 
+/*******************************************************************************
+* Following functions are internal APIs between Driver layer and Platform layer
+********************************************************************************/
 
 /*******************************************************************************
 * miiSmiIfReadRegister
@@ -266,21 +296,25 @@ GT_STATUS miiSmiIfReadRegister
 )
 {
     unsigned int tmpData;
-
-	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
-	{
-     	if(qdMultiAddrRead(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
-	    {
-    	    return GT_FAIL;
-	    }
-	}
+#ifdef GT_RMGMT_ACCESS
+    if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+       (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+#else
+    if(dev->accessMode == SMI_MULTI_ADDR_MODE) 
+#endif
+    {
+         if(qdMultiAddrRead(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
     else
-	{
-     	if(dev->fgtReadMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
-	    {
-    	    return GT_FAIL;
-	    }
-	}
+    {
+         if(fgtReadMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,&tmpData) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
     *data = (GT_U16)tmpData;
     return GT_OK;
 }
@@ -317,23 +351,99 @@ GT_STATUS miiSmiIfWriteRegister
     IN  GT_U16       data
 )
 {
-	if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+#ifdef GT_RMGMT_ACCESS
+    if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+       (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+#else
+    if(dev->accessMode == SMI_MULTI_ADDR_MODE)
+#endif
 	{
-     	if(qdMultiAddrWrite(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
-	    {
-    	    return GT_FAIL;
-	    }
-	}
+         if(qdMultiAddrWrite(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
     else
-	{
-	    if(dev->fgtWriteMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
-	    {
-    	    return GT_FAIL;
-	    }
-	}
-	return GT_OK;
+    {
+        if(fgtWriteMii(dev,(GT_U32)phyAddr,(GT_U32)regAddr,(GT_U32)data) != GT_TRUE)
+        {
+            return GT_FAIL;
+        }
+    }
+    return GT_OK;
 }
 
+#ifdef GT_RMGMT_ACCESS
+
+/*******************************************************************************
+* qdAccessRegs 
+*
+* DESCRIPTION:
+*       This function access registers through device interface
+*        (like Marvell F2R on ethernet) by user, to be used by upper layers.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG includes:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*     
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_OK   - on success
+*       GT_FAIL - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+GT_STATUS qdAccessRegs
+(
+    IN  GT_QD_DEV    *dev,
+    INOUT HW_DEV_REG_ACCESS *regList
+)
+{
+  if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
+     (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
+  {
+      if(qdMultiAddrAccess(dev, regList) != GT_TRUE)
+      {
+        return GT_FAIL;
+      }
+  }
+  else
+  {
+    if ((IS_IN_DEV_GROUP(dev,DEV_RMGMT)) &&
+        (dev->fgtHwAccess != NULL) &&
+        (dev->fgtHwAccessMod == HW_ACCESS_MODE_F2R) )
+    {
+      if(dev->fgtHwAccess(dev, regList) != GT_TRUE)
+      {
+        if(fgtAccessRegs(dev, regList) != GT_TRUE)
+        {
+          return GT_FAIL;
+        }
+      }
+    }
+    else
+    {
+      if(fgtAccessRegs(dev, regList) != GT_TRUE)
+      {
+        return GT_FAIL;
+      }
+    }
+  }
+  return GT_OK;
+
+}
+#endif
+
+
+/* Local sub-functions */
 
 /*****************************************************************************
 * qdMultiAddrRead
@@ -357,15 +467,14 @@ GT_STATUS miiSmiIfWriteRegister
 *       None.
 *
 *******************************************************************************/
-GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
-                        unsigned int* value)
+GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value)
 {
-	unsigned int smiReg;
-	volatile unsigned int timeOut; /* in 100MS units */
-	volatile int i;
+    unsigned int smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
 
-	/* first check that it is not busy */
-    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    /* first check that it is not busy */
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
@@ -378,24 +487,24 @@ GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int reg
         {
             if(timeOut-- < 1 ) 
             {
-    	        return GT_FALSE;
-    	    }
-		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
-		    {
-		        return GT_FALSE;
-		    }
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
         } while (smiReg & QD_SMI_BUSY);
     }
 
     smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | 
-    		(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
 
-    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
     timeOut = QD_SMI_ACCESS_LOOP; /* initialize the loop count */
-    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
@@ -403,25 +512,25 @@ GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int reg
     if(smiReg & QD_SMI_BUSY) 
     {
         for(i = 0 ; i < QD_SMI_TIMEOUT ; i++);
-		do 
-		{
+        do 
+        {
             if(timeOut-- < 1 ) 
             {
-    	        return GT_FALSE;
-    	    }
-		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
-		    {
-		        return GT_FALSE;
-		    }
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
         } while (smiReg & QD_SMI_BUSY);
-	}
-    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, &smiReg) != GT_TRUE)
+    }
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, &smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
-	*value = smiReg;
+    *value = smiReg;
     
-	return GT_TRUE;
+    return GT_TRUE;
 }
 
 /*****************************************************************************
@@ -447,15 +556,14 @@ GT_BOOL qdMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int reg
 *
 *******************************************************************************/
 
-GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr,
-                       unsigned int value)
+GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value)
 {
-	unsigned int smiReg;
-	volatile unsigned int timeOut; /* in 100MS units */
-	volatile int i;
+    unsigned int smiReg;
+    volatile unsigned int timeOut; /* in 100MS units */
+    volatile int i;
 
-	/* first check that it is not busy */
-    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+    /* first check that it is not busy */
+    if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
@@ -468,23 +576,23 @@ GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int re
         {
             if(timeOut-- < 1 ) 
             {
-    	        return GT_FALSE;
-    	    }
-		    if(dev->fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
-		    {
-		        return GT_FALSE;
-		    }
+                return GT_FALSE;
+            }
+            if(fgtReadMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, &smiReg) != GT_TRUE)
+            {
+                return GT_FALSE;
+            }
         } while (smiReg & QD_SMI_BUSY);
     }
 
-    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, value) != GT_TRUE)
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_DATA, value) != GT_TRUE)
     {
         return GT_FALSE;
     }
     smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | 
-			(regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+            (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
 
-    if(dev->fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
+    if(fgtWriteMii(dev,(GT_U32)dev->phyAddr,(GT_U32)QD_REG_SMI_COMMAND, smiReg) != GT_TRUE)
     {
         return GT_FALSE;
     }
@@ -492,3 +600,230 @@ GT_BOOL qdMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int re
     return GT_TRUE;
 }
 
+
+static GT_BOOL fgtReadMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int reg, unsigned int* value)
+{
+  GT_BOOL retVal;
+  retVal =  dev->fgtReadMii(dev, phyAddr, reg, value);
+  return  retVal;
+}
+
+
+static GT_BOOL fgtWriteMii(GT_QD_DEV*dev, unsigned int phyAddr, unsigned int reg, unsigned int value)
+{
+  GT_BOOL retVal;
+  retVal = dev->fgtWriteMii(dev, phyAddr, reg, value);
+  return  retVal;
+}
+
+#ifdef GT_RMGMT_ACCESS
+
+static GT_BOOL fgtAccessRegs(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList)
+{
+  int i;
+  GT_BOOL retVal = GT_TRUE;
+  unsigned short data, mask;
+  unsigned int tmpData;
+  for (i=0; i<regList->entries; i++)
+  {
+    switch (regList->rw_reg_list[i].cmd)
+    {
+      case HW_REG_READ:
+        retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&(regList->rw_reg_list[i].data));
+        break;
+      case HW_REG_WRITE:
+        retVal=dev->fgtWriteMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, regList->rw_reg_list[i].data);
+        break;
+      case HW_REG_WAIT_TILL_0:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(data & mask);
+      }
+        break;
+      case HW_REG_WAIT_TILL_1:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=dev->fgtReadMii(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(!(data & mask));
+      }
+        break;
+
+      default:
+        return GT_FALSE;
+    }
+  }
+    return retVal;
+}
+
+GT_BOOL qdAccessMultiAddrRead (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int* value)
+{
+  GT_U16 smiReg;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  regAccess.entries = 4;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[0].data = 15;
+  smiReg =  QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_READ << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[1].data = smiReg;
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[2].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[2].data = 15;
+
+  regAccess.rw_reg_list[3].cmd = HW_REG_READ;
+  regAccess.rw_reg_list[3].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[3].reg = QD_REG_SMI_DATA;
+  regAccess.rw_reg_list[3].data = 0;
+  if(dev->fgtHwAccess(dev, &regAccess) != GT_TRUE)
+  {
+    return GT_FALSE;
+  }
+  *value = (unsigned short)regAccess.rw_reg_list[3].data;
+    
+  return GT_TRUE;
+}
+GT_BOOL qdAccessMultiAddrWrite (GT_QD_DEV* dev, unsigned int phyAddr , unsigned int regAddr, unsigned int value)
+{
+  GT_U16 smiReg;
+
+  HW_DEV_REG_ACCESS regAccess;
+
+  regAccess.entries = 3;
+
+  regAccess.rw_reg_list[0].cmd = HW_REG_WAIT_TILL_0;
+  regAccess.rw_reg_list[0].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[0].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[0].data = 15;
+
+  regAccess.rw_reg_list[1].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[1].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[1].reg = QD_REG_SMI_DATA;
+  regAccess.rw_reg_list[1].data = value;
+
+  smiReg = QD_SMI_BUSY | (phyAddr << QD_SMI_DEV_ADDR_BIT) | (QD_SMI_WRITE << QD_SMI_OP_BIT) | (regAddr << QD_SMI_REG_ADDR_BIT) | (QD_SMI_CLAUSE22 << QD_SMI_MODE_BIT);
+
+  regAccess.rw_reg_list[2].cmd = HW_REG_WRITE;
+  regAccess.rw_reg_list[2].addr = (GT_U32)dev->phyAddr;
+  regAccess.rw_reg_list[2].reg = QD_REG_SMI_COMMAND;
+  regAccess.rw_reg_list[2].data = smiReg;
+
+  if(dev->fgtHwAccess(dev, &regAccess) != GT_TRUE)
+  {
+    return GT_FALSE;
+  }
+    
+  return GT_TRUE;
+}
+
+/*****************************************************************************
+* qdMultiAddrAccess
+*
+* DESCRIPTION:
+*       This function access data to the device in the secondary MII bus.
+*
+* INPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*     HW_DEV_RW_REG includes:
+*     cmd - HW_REG_READ, HW_REG_WRITE, HW_REG_WAIT_TILL_0 or HW_REG_WAIT_TILL_1 
+*     addr - SMI Address 
+*     reg  - Register offset 
+*     data - INPUT,OUTPUT:Value in the Register or Bit number
+*
+* OUTPUTS:
+*   regList     - list of HW_DEV_RW_REG.
+*
+* RETURNS:
+*       GT_TRUE   - on success
+*       GT_FALSE  - on error
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+
+static GT_BOOL qdMultiAddrAccess(GT_QD_DEV* dev, HW_DEV_REG_ACCESS *regList)
+{
+  int i;
+  GT_BOOL retVal = GT_TRUE;
+  unsigned short data, mask;
+  unsigned int tmpData;
+
+  for (i=0; i<regList->entries; i++)
+  {
+    switch (regList->rw_reg_list[i].cmd)
+    {
+      case HW_REG_READ:
+        retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&(regList->rw_reg_list[i].data));
+        break;
+      case HW_REG_WRITE:
+        retVal=qdAccessMultiAddrWrite(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, regList->rw_reg_list[i].data);
+        break;
+      case HW_REG_WAIT_TILL_0:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(data & mask);
+      }
+        break;
+      case HW_REG_WAIT_TILL_1:
+      {
+        mask = (1<<regList->rw_reg_list[i].data);
+        do
+        {
+          retVal=qdAccessMultiAddrRead(dev, regList->rw_reg_list[i].addr,
+                regList->rw_reg_list[i].reg, (unsigned int *)&tmpData);
+          if(retVal != GT_TRUE)
+          {
+            return retVal;
+          }
+          data = tmpData;
+        } while(!(data & mask));
+      }
+        break;
+
+      default:
+        return GT_FALSE;
+    }
+  }
+    return retVal;
+}
+
+#endif
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtSem.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/gtSem.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/makefile b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/makefile
old mode 100644
new mode 100755
index 40f8d03..4b15611
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/makefile
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/makefile
@@ -1,16 +1,17 @@
 # Source files in this directory
+TARGET = 
 CSOURCES	= gtMiiSmiIf.c platformDeps.c gtSem.c gtDebug.c
 ASOURCES	=
 
 # Include common variable definitions
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.defs
+include $(DSDT_TOOL_DIR)\make.defs
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.defs
+include $(DSDT_TOOL_DIR)\makewce.defs
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.defs
+include $(DSDT_TOOL_DIR)/makelnx.defs
 endif
 
 # Add in extra stuffs
@@ -20,13 +21,13 @@ ADDED_CFLAGS	+=
 
 # Include common build rules
 ifeq ($(OS_RUN),VXWORKS)
-include $(TOOL_DIR)\make.rules
+include $(DSDT_TOOL_DIR)\make.rules
 endif
 ifeq ($(OS_RUN),WIN32)
-include $(TOOL_DIR)\makewce.rules
+include $(DSDT_TOOL_DIR)\makewce.rules
 endif
 ifeq ($(OS_RUN),LINUX)
-include $(TOOL_DIR)/makelnx.rules
+include $(DSDT_TOOL_DIR)/makelnx.rules
 endif
 
-# end of file
\ No newline at end of file
+# end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/platformDeps.c b/arch/arm/plat-armada/mv_hal/qd-dsdt/src/platform/platformDeps.c
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs
old mode 100644
new mode 100755
index 822f752..fffa5a9
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.defs
@@ -42,7 +42,7 @@ endif
 
 TOOL       = gnu
 
-SW_ROOT = $(subst \,/,$(USER_BASE))
+SW_ROOT = $(subst \,/,$(DSDT_USER_BASE))
 SRC_BASE_PATH = $(SW_ROOT)/src
 QD_INCLUDE_PATH = $(SW_ROOT)/Include/h
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.rules b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/make.rules
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs
old mode 100644
new mode 100755
index 2551436..89d5930
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.defs
@@ -6,17 +6,20 @@
 #
 SHELL=/bin/sh -e
 
-CC_ARCH_SPEC=  -march=i386 -mcpu=i686
+#CC_ARCH_SPEC=  -march=i386 -mcpu=i686
 
-SW_ROOT = $(USER_BASE)
+SW_ROOT = $(DSDT_USER_BASE)
 SRC_BASE_PATH = $(SW_ROOT)/src
 QD_INCLUDE_PATH = $(SW_ROOT)/Include/h
 
 LIB_DIR = $(SW_ROOT)/Library
-OBJDIR = obj
+OBJDIR = $(DSDT_PROJ_NAME)_obj
 
+ifeq ($(CC),)
 CC      =cc
 LD      =ld
+endif
+
 MAKE    =make
 CD      =pwd
 RM      =rm -f
@@ -24,7 +27,8 @@ ECHO    =echo
 
 DEPENDENCIES= makedeps
 
-CFLAGS = $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
+#CFLAGS = $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
+CFLAGS += $(CFLAGS1) $(CFLAGS2) $(INCLUDE_PATH) $(CDEBUG_DEFINES)
 
 CFLAGS1 = $(CC_ARCH_SPEC) $(DEBUG_TYPE)
 CFLAGS2 = $(CC_OPTIM) $(CC_COMPILER) $(CC_WARNINGS_ALL)
@@ -49,4 +53,11 @@ INCLUDE_PATH = -I. \
                -I$(QD_INCLUDE_PATH)/msApi \
                -I$(QD_INCLUDE_PATH)/platform \
                -I$(SW_ROOT)/Include
+ifeq ($(DSDT_USE_MAD),TRUE)
+MAD_INCLUDE_PATH = $(SW_ROOT)/../phy/Include
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH) 
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/driver 
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/madApi 
+INCLUDE_PATH += -I$(MAD_INCLUDE_PATH)/h/platform 
+endif
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules
old mode 100644
new mode 100755
index d91cfdf..4c1b926
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makelnx.rules
@@ -47,10 +47,11 @@ deps : $(CSOURCES)
 
 .PHONY: clean
 clean:
-	cd $(OBJDIR); $(RM) *.o
-	cd $(OBJDIR); $(RM) *.map
+#	cd $(OBJDIR); $(RM) *.o
+#	cd $(OBJDIR); $(RM) *.map
+	$(RM) -f -r $(OBJDIR)
 	$(RM) $(DEPENDENCIES)
 
 FORCE :
 
-# end of file
\ No newline at end of file
+# end of file
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.defs b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.defs
old mode 100644
new mode 100755
index 17fc3a1..52db4e4
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.defs
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.defs
@@ -11,17 +11,17 @@ TARGET	= $(notdir $(subst \,/,$(shell cd)))
 endif
 default : $(TARGET).lib
 
-SW_ROOT = $(subst \,/,$(USER_BASE))
+SW_ROOT = $(subst \,/,$(DSDT_USER_BASE))
 SRC_BASE_PATH = $(SW_ROOT)/src
 #INCLUDE_PATH = $(subst ;, -I,$(INCLUDE))
 
 LIB_DIR = $(SW_ROOT)/library
 OBJDIR = obj
 
-QD_INCLUDE_PATH = -I$(USER_BASE)\Include\h\driver \
-                  -I$(USER_BASE)\Include\h\msApi \
-                  -I$(USER_BASE)\Include\h\platform \
-                  -I$(USER_BASE)\Include
+QD_INCLUDE_PATH = -I$(DSDT_USER_BASE)\Include\h\driver \
+                  -I$(DSDT_USER_BASE)\Include\h\msApi \
+                  -I$(DSDT_USER_BASE)\Include\h\platform \
+                  -I$(DSDT_USER_BASE)\Include
 
 MAKE    =make
 CD		=cd
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.rules b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/makewce.rules
old mode 100644
new mode 100755
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv
old mode 100644
new mode 100755
index 0dba986..1e9dd00
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv
@@ -1,5 +1,13 @@
-declare -x USER_BASE=$HOME/DSDT_2.8a
-declare -x PROJ_NAME=qdDrv
-declare -x TOOL_DIR=$USER_BASE/tools
+declare -x DSDT_USER_BASE=/work/marvell/mvl_drivers/DSDT_3.0/switch
+declare -x DSDT_PROJ_NAME=qdDrv
+declare -x DSDT_TOOL_DIR=$DSDT_USER_BASE/tools
 declare -x RELEASE=YES
 declare -x OS_RUN=LINUX
+declare -x MAD_USER_BASE=$DSDT_USER_BASE/../phy
+declare -x MAD_PROJ_NAME=madDrv
+declare -x MAD_TOOL_DIR=$MAD_USER_BASE/tools
+declare -x USER_API_NAME=
+declare -x USER_NAME=
+declare -x DSP_VCT=FALSE
+declare -x VCT_PENDING=FALSE
+declare -x DSDT_USE_MAD=FALSE
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv.bat b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv.bat
old mode 100644
new mode 100755
index 48407d8..ab42cb9
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv.bat
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt/tools/setenv.bat
@@ -10,9 +10,10 @@ if "%REQ_OS%"=="WIN32"   set OS_RUN=WIN32
 if "%REQ_OS%"=="wince"   set OS_RUN=WIN32
 if "%REQ_OS%"=="WINCE"   set OS_RUN=WIN32
 
-set USER_BASE=C:\DSDT_2.8a
-set PROJ_NAME=qdDrv
-set TOOL_DIR=%USER_BASE%\tools
+set DSDT_USER_BASE=C:\DSDT_2.8pre_4
+set DSDT_PROJ_NAME=qdDrv
+set DSDT_USE_MAD=FALSE
+set DSDT_TOOL_DIR=%DSDT_USER_BASE%\tools
 set RELEASE=YES
 set TARGET_CPU=ARM
 rem set TARGET_CPU=MIPS
@@ -45,11 +46,11 @@ rem set TARGETCPU=x86
 set WCEROOT=C:\WINCE400
 
 set INCLUDE=%WCEROOT%\public\common\oak\inc;%WCEROOT%\public\common\sdk\inc;%WCEROOT%\public\common\ddk\inc;%INCLUDE%
-set PATH=%WCEROOT%\sdk\bin\i386;%WCEROOT%\public\common\oak\bin\i386;%USER_BASE%\tools;%path%
+set PATH=%WCEROOT%\sdk\bin\i386;%WCEROOT%\public\common\oak\bin\i386;%DSDT_USER_BASE%\tools;%path%
 
 echo Environment Variable for WinCE has been set.
 goto DONE
 
 :DONE
-cd %USER_BASE%\src
+cd %DSDT_USER_BASE%\src
 
-- 
1.7.5.4

