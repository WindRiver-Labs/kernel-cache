From 48befdbeb8525a0ed6f51bb0f1dd8be94a1f32da Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Tue, 8 Apr 2014 15:38:28 +0300
Subject: [PATCH 1538/1825] new sysfs file for qm module

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9b153686d5069969b80ae9b5f9e71deb34ddda95

Change-Id: I98c540409300858342bc8b4aa2962f6be77cbaaf
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6990
Reviewed-by: Eliezer Ben Zeev <eliezerb@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Makefile         |    2 +-
 drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c |  297 +++++++++++++++++++++
 2 files changed, 298 insertions(+), 1 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c

diff --git a/drivers/net/ethernet/marvell/pp3/Makefile b/drivers/net/ethernet/marvell/pp3/Makefile
index 0e082cf..da0dcc4 100644
--- a/drivers/net/ethernet/marvell/pp3/Makefile
+++ b/drivers/net/ethernet/marvell/pp3/Makefile
@@ -11,4 +11,4 @@ mv_pp3-objs += emac/mv_emac_sysfs.o hmac/mv_hmac_sysfs.o net_dev/mv_dev_sysfs.o
 mv_pp3-objs += gmac/mv_gmac.o fw/mv_channel_if.o common/mv_stack.o
 mv_pp3-objs += fw/mv_fw.o fw/mv_fw_sysfs.o
 mv_pp3-objs += bm/mv_bm.o bm/mv_bm_sysfs.o bm/mv_bm_regs.o
-mv_pp3-objs += qm/mv_qm.o qm/mv_qm_regs.o
+mv_pp3-objs += qm/mv_qm.o qm/mv_qm_regs.o qm/mv_qm_sysfs.o
diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c b/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c
new file mode 100644
index 0000000..7d7315d
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm_sysfs.c
@@ -0,0 +1,297 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "common/mv_sw_if.h"
+#include "common/mv_hw_if.h"
+#include "qm/mv_qm.h"
+#include "qm/mv_qm_regs.h"
+
+/*
+#define PR_ERR_CODE(_rc, _func)	\
+{								\
+	pr_err("error code = 0x%08X on illegal operation at line %05d in function <%s> in file <%s>\n", rc, __LINE__, __func__, __FILE__);			\
+	pr_err("%s: error code = 0x%08X on illegal operation at line %05d in function <%s> in file <%s>\n", _func, _rc, __LINE__, __func__, __FILE__);	\
+}
+*/
+#define PR_ERR_CODE(_rc)	\
+{							\
+	pr_err("%s: error code = 0x%08X in function <%s>\n", __func__, _rc, attr->attr.name);	\
+}
+/*
+	pr_err("%s: illegal operation in function <%s> at line %05d in file <%s>, error code = 0x%08X\n", __func__, attr->attr.name, __LINE__, __FILE__, rc);	\
+	pr_err("%s: illegal operation in function <%s>, error code = 0x%08X\n", __func__, attr->attr.name, rc);		\
+	pr_err("%s: error code = 0x%08X on illegal operation at line %05d in function <%s> in file <%s>\n", _func, _rc, __LINE__, __func__, __FILE__);	\
+*/
+
+#define PR_INFO_CALLED		\
+{							\
+	pr_info("%s is called\n", attr->attr.name);	\
+}
+
+
+
+static ssize_t mv_qm_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "cat status                              - show QM status\n");
+/*
+	off += sprintf(buf+off, "echo      > open                        - Open session with BM\n");
+	off += sprintf(buf+off, "echo      > enable                      - enable BM\n");
+	off += sprintf(buf+off, "echo      > disable                     - disable BM\n");
+*/
+	off += sprintf(buf+off, "echo      > qm_dma_gpm_pools_def_enable - en QM, Conf DMA w/GPM p thrs w/def\n");
+/* QM */
+	off += sprintf(buf+off, "echo > default_set                  - Set default for QM units for mandatory parameters\n");
+	off += sprintf(buf+off, "echo > dma_gpm_pools_def_enable     - Enables QM for  GPM pools (0,1)\n");
+	off += sprintf(buf+off, "echo > dma_dram_pools_def_enable    - Enables QM for DRAM pools (2,3)\n");
+	off += sprintf(buf+off, "echo qth, qtl, pth, ptl > qm_dma_gpm_pools_enable - En QM, Conf DMA w/GPM p thrs\n");
+
+	off += sprintf(buf+off, "parameters: [p]    pool number\n");
+	off += sprintf(buf+off, "            [nb]   number of buffers\n");
+	off += sprintf(buf+off, "            [id]   vmid\n");
+	off += sprintf(buf+off, "            [pool] pool number\n");
+	off += sprintf(buf+off, "            [qi]   ???\n");
+	off += sprintf(buf+off, "            [ps]   ???\n");
+	off += sprintf(buf+off, "            [pp]   ???\n");
+	off += sprintf(buf+off, "            [pm]   ???\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+static ssize_t mv_qm_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	const char      *name = attr->attr.name;
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	pr_info("mv_qm_show is called\n");
+	if (!strcmp(name, "status")) {
+		u32 status = 0;
+		pr_info("qm_enable_status_get: ");
+		/*qm_enable_status_get(&status);*/
+		pr_info("status is %d\n", status);
+	} else if (!strcmp(name, "help")) {
+		off = mv_qm_help(buf);
+	} else if (!strcmp(name, "debug")) {
+		pr_info("debug\n");
+	} else {
+		off = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	return off;
+}
+
+static ssize_t mv_qm_config(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int rc = -QM_INPUT_NOT_IN_RANGE;
+	int             err = 0;
+/*
+	u32 flags;
+*/
+	unsigned long flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	local_irq_save(flags);
+
+/*
+*/
+	if (!strcmp(name, "open")) {
+
+		/* Read input values */
+		PR_INFO_CALLED
+		rc = qm_open();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "close")) {
+		PR_INFO_CALLED
+		rc = qm_close();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+/* QM */
+	} else if (!strcmp(name, "default_set")) {
+		PR_INFO_CALLED
+		rc = qm_default_set();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "dma_gpm_pools_def_enable")) {
+		PR_INFO_CALLED
+		rc = qm_dma_gpm_pools_def_enable();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "dma_dram_pools_def_enable")) {
+		PR_INFO_CALLED
+		rc = qm_dma_dram_pools_def_enable();
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "dma_gpm_pools_enable")) {
+		u32 qece_thr_hi, qece_thr_lo, pl_thr_hi, pl_thr_lo;
+
+		/* Read input values */
+		PR_INFO_CALLED
+		qece_thr_hi = qece_thr_lo = pl_thr_hi = pl_thr_lo = 0xFFFFFFFF;
+		sscanf(buf, "%d %d %d %d", &qece_thr_hi, &qece_thr_lo, &pl_thr_hi, &pl_thr_lo);
+		rc = qm_dma_gpm_pools_enable(qece_thr_hi, qece_thr_lo, pl_thr_hi, pl_thr_lo);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+/*not used*/
+	} else if (!strcmp(name, "register_read")) {
+		u32 base_address, offset, wordsNumber, dataPtr;
+
+		PR_INFO_CALLED
+		base_address = offset = wordsNumber = dataPtr = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%x %x %x %x", &base_address, &offset, &wordsNumber, &dataPtr);
+		rc = qm_register_read(base_address, offset, wordsNumber, (u32 *)&dataPtr);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else if (!strcmp(name, "register_write")) {
+		u32 base_address, offset, wordsNumber, dataPtr;
+
+		PR_INFO_CALLED
+		base_address = offset = wordsNumber = dataPtr = 0xFFFFFFFF;
+		/* Read input values */
+		sscanf(buf, "%x %x %x %x", &base_address, &offset, &wordsNumber, &dataPtr);
+		rc = qm_register_write(base_address, offset, wordsNumber, (u32 *)&dataPtr);
+		if (rc != OK)
+			PR_ERR_CODE(rc)
+	} else {
+		err = 1;
+/*		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);*/
+		pr_err("%s: wrong name of QM function <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,                            S_IRUSR, mv_qm_show, NULL);
+static DEVICE_ATTR(status,                          S_IRUSR, mv_qm_show, NULL);
+static DEVICE_ATTR(open,                         S_IWUSR, NULL,       mv_qm_config);
+/*
+static DEVICE_ATTR(qm_gpm_init,                     S_IWUSR, NULL,       mv_qm_config);
+static DEVICE_ATTR(qm_dram_init,                    S_IWUSR, NULL,       mv_qm_config);
+*/
+static DEVICE_ATTR(qm_register_read,                S_IWUSR, NULL,       mv_qm_config);
+static DEVICE_ATTR(qm_register_write,               S_IWUSR, NULL,       mv_qm_config);
+
+
+static struct attribute *mv_qm_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_status.attr,
+	&dev_attr_open.attr,
+/*
+	&dev_attr_qm_gpm_init.attr,
+	&dev_attr_qm_dram_init.attr,
+*/
+	&dev_attr_qm_register_read.attr,
+	&dev_attr_qm_register_write.attr,
+	NULL
+};
+
+
+static struct attribute_group mv_qm_group = {
+	.name = "qm",
+	.attrs = mv_qm_attrs,
+};
+
+int mv_pp3_qm_sysfs_init(struct kobject *neta_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(neta_kobj, &mv_qm_group);
+	if (err) {
+		pr_err(KERN_INFO "sysfs group failed for qm%d\n", err);
+		return err;
+	}
+
+	return err;
+}
+
+int mv_pp3_qm_sysfs_exit(struct kobject *emac_kobj)
+{
+	/*TODO*/
+	return 0;
+}
+
+
+/*
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+echo > qm_open
+echo > qm_pool_disable 0
+
+
+
+*/
-- 
1.7.5.4

