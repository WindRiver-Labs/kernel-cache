From 78e6be89d2f2dcd3e31e0b4764e4d56cfb58ac0c Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sat, 3 Aug 2013 12:50:23 +0300
Subject: [PATCH 0922/1825] fix: iocc: alp: add new IO Sync Barrier WA using
 XOR engine

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 830176fb823d785b068d4cac0e4b6ff1f7908eaf

	The ALP IOCC SYNC Barrier WA overcomes the ALP Z1 revision sync barrier
	issue using the XOR engine.
	When the dma_io_sync is called by each of the CPUs, the correct channel
	(CPU dependent) is activated to preform a memset operation.
	The XOR's memset operation provides the required IO transaction that
	guarantees that the latest data fetched from the IO is coherent.
	The WA uses both channels of XOR engine 0.

Change-Id: Ia1c21482fbb422994f98aea76bfe8d8f96bff382
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2921
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.c |   72 ++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 71 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 65dbbac..85b0ab6 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -61,6 +61,10 @@
 #include <plat/mv_xor.h>
 #endif
 
+#ifdef CONFIG_ALP_IOCC_SYNC_BARRIER_WA
+#include "xor/mvXorRegs.h"
+#endif
+
 #if defined(CONFIG_MV_ETH_PP2)
 #include <linux/mv_pp2.h>
 #endif
@@ -1057,6 +1061,7 @@ static void __init alp_xor0_init(void)
 
 	platform_device_register(&alp_xor0_shared);
 
+#if !defined(CONFIG_ALP_IOCC_SYNC_BARRIER_WA)
 	/*
 	 * two engines can't do memset simultaneously, this limitation
 	 * satisfied by removing memset support from one of the engines.
@@ -1069,6 +1074,7 @@ static void __init alp_xor0_init(void)
 	dma_cap_set(DMA_MEMSET, alp_xor01_data.cap_mask);
 	dma_cap_set(DMA_XOR, alp_xor01_data.cap_mask);
 	platform_device_register(&alp_xor01_channel);
+#endif
 }
 
 /*
@@ -1216,7 +1222,7 @@ static void print_board_info(void)
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 	pr_info("\tIOCC: Support IO coherency.\n");
 #ifdef CONFIG_ALP_IOCC_SYNC_BARRIER_WA
-	pr_info("\t   -> Sync Barrier WA enabled\n");
+	pr_info("\t   -> XOR Sync Barrier WA enabled\n");
 #endif
 #endif
 
@@ -1281,13 +1287,77 @@ void alp_smp_cpu1_enable_wa(void)
 
 #ifdef CONFIG_ALP_IOCC_SYNC_BARRIER_WA
 
+/*
+ * The ALP IOCC SYNC Barrier WA overcomes the ALP Z1 revision sync barrier
+ * issue using the XOR engine.
+ * When the dma_io_sync is called by each of the CPUs, the correct channel
+ * (CPU dependent) is activated to preform a memset operation.
+ * The XOR's memset operation provides the required IO transaction that
+ * guarantees that the latest data fetched from the IO is coherent.
+ * The WA uses both channels of XOR engine 0.
+ */
+
+static void *dma_io_sync_buff_virt[CONFIG_NR_CPUS];
+
 void dma_io_sync(void)
 {
+	u32 data;
+	volatile u32 *virt;
+	int cpu = smp_processor_id();
+
+	virt = dma_io_sync_buff_virt[cpu];
+
+	/* Write '1' to the first word of the buffer */
+	*virt = 0x1;
+
+	/* Wait until the engine is idle */
+	while ((MV_REG_READ(XOR_ACTIVATION_REG(0, cpu)) >> 4) & 0x3)
+		;
+
+	dmb();
+
+	/* Trigger channel */
+	MV_REG_WRITE((XOR_ACTIVATION_REG(0, cpu)), 0x1);
+
+	/* Poll the data until it is cleared by the XOR engine */
+	do {
+		data = *virt;
+	} while (data);
 }
 EXPORT_SYMBOL(dma_io_sync);
 
 static void alp_iocc_wa_init(void)
 {
+#define XOR_MEMSET_SIZE 128
+	dma_addr_t phys;
+	void *virt;
+	int cpu;
+
+	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
+		virt = kzalloc(XOR_MEMSET_SIZE, GFP_KERNEL);
+		if (!virt) {
+			pr_err("%s: Error: memory alloc failed\n", __func__);
+			return;
+		}
+		dma_io_sync_buff_virt[cpu] = virt;
+
+		phys = dma_map_single(NULL, virt, XOR_MEMSET_SIZE, DMA_FROM_DEVICE);
+
+		/*
+		 * Initialize the XOR engines
+		 */
+		/* Set to memset operation and burst limit to 128 bytes */
+		MV_REG_WRITE(XOR_CONFIG_REG(0, cpu), 0x444);
+		/* Set memset size */
+		MV_REG_WRITE(XOR_BLOCK_SIZE_REG(0, cpu), XOR_MEMSET_SIZE);
+		/* Set buffer address */
+		MV_REG_WRITE(XOR_DST_PTR_REG(0, cpu) , phys);
+	}
+
+	/* Set initVal Low to '0' */
+	MV_REG_WRITE(XOR_INIT_VAL_LOW_REG(0), 0x0);
+	/* Set initVal High to '0' */
+	MV_REG_WRITE(XOR_INIT_VAL_HIGH_REG(0), 0x0);
 }
 #else
 void dma_io_sync(void)
-- 
1.7.5.4

