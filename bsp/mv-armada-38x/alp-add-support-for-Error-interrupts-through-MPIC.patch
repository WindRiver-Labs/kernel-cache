From b51bc27fc7b6010e76e9fb4b9336cab68f8e6ed1 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Tue, 24 Dec 2013 12:04:27 +0200
Subject: [PATCH 1258/1825] alp: add support for Error interrupts through MPIC

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 62dc0aeb19806e7ea39905962ffd80af30d74836

	New fuctionality added:
	-----------------------
	- CPU-private Error Summary interrupt
	- Tested with XOR1 engine by breaking destination address
	of TX transaction of of XOR engine.

	Tested existing functionality:
	------------------------------
	- Gobal GPIO
	- Tested on Avanta-LP DB-6660 board with GPIO 39 (out)
	connected to GPIO 18 (in) on-board.
	- Tested Edge and Level interrupt.
	- CPU-private GPIO interrupts
	- Not tested
	- CPU-private PPv2 RX/TX interrupt
	- Tested with PPv2 by changing 'global' to 'private'
	interrupts in core.c file for PPv2.

	New /proc/interrupts look when testing Global GPIO and Error Summary:
	---------------------------------------------------------------------
	$ cat /proc/interrupts
	CPU0       CPU1
	29:       1555        777       GIC  twd
	34:          0          0       GIC  mv64xxx_i2c
	35:          0          0       GIC  mv64xxx_i2c
	41:         10          0       GIC  alp_clk_evt
	44:        157          0       GIC  serial
	48:          0          0       GIC  xhci-hcd:usb1
	53:          0          0       GIC  rtc-mv
	57:       2938          0       GIC  mvsdio
	58:          0          0       GIC  sata_mv
	73:      10671          0       GIC  mv_eth
	82:          2          0       GIC  mv_eth_link
	84:          1          0       GIC  switch
	97:          2          0       GIC  mv_xor.2
	98:          1          0       GIC  mv_xor.3
	116:          8          0       GIC  armada-nand
	210:          0          0  GlobGPIO  gpio
	481:          0          0  ErrorSum  err_xor
	IPI0:          0          0  Timer broadcast interrupts
	IPI1:        933       1852  Rescheduling interrupts
	IPI2:          0          0  Function call interrupts
	IPI3:         35         95  Single function call interrupts
	IPI4:          0          0  CPU stop interrupts
	Err:          0

Change-Id: If2675a8e9a79a9c9efc4fb6d5e308b19efc94791
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4847
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                                   |   13 -
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    3 +-
 arch/arm/mach-avantalp/config/mvSysGppConfig.h     |    5 +-
 arch/arm/mach-avantalp/core.c                      |    2 +-
 arch/arm/mach-avantalp/irq.c                       |  420 ++++++++++++++++----
 arch/arm/plat-armada/mv_hal/gpp/mvGppRegs.h        |   16 +-
 6 files changed, 364 insertions(+), 95 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 0d91850..7941bbf 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -720,8 +720,6 @@ config ARCH_FEROCEON_KW2
 config ARCH_AVANTA_LP
 	bool "Marvell Avanta LP"
 	select PCI
-#	select ARCH_HAS_CPUFREQ
-#	select ARCH_SUPPORTS_MSI
 	select CPU_V7
 	select ARCH_REQUIRE_GPIOLIB
 	select GENERIC_GPIO
@@ -736,18 +734,7 @@ config ARCH_AVANTA_LP
 	select NEED_MACH_IO_H
 	select NEED_MACH_MEMORY_H
 	select DMABOUNCE
-#	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
-#	bool "ARM Ltd. Versatile Express family"
-#	select ARCH_WANT_OPTIONAL_GPIOLIB
-#	select ARM_AMBA
-#	select ARM_TIMER_SP804
-#	select HAVE_MACH_CLKDEV
-#	select HAVE_CLK
-#	select HAVE_PATA_PLATFORM
-#	select ICST
-#	select PLAT_VERSATILE
-#	select PLAT_VERSATILE_CLCD
 	help
 	  Support for the Marvell Avanta-LP SoC Family
  
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index 9b5b389..0c15e9c 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -92,7 +92,8 @@ extern "C" {
 #define MV_MISC_REGS_OFFSET                     (0x18200)
 #define MV_COMMON_PHY_REGS_OFFSET               (0x18300)
 #define MV_IP_CONFIG_REGS_OFFSET		(0x18400)
-#define MV_CLK_CMPLX_REGS_OFFSET        	(0x18700)
+#define MV_CLK_CMPLX_REGS_OFFSET		(0x18700)
+#define MV_CPU_GPP_REGS_OFFSET(cpu, unit)	(0x18800 + ((unit) * 0x40) + ((cpu) * 0x4))
 #define MV_ETH_COMPLEX_OFFSET			(0x18900)
 #define MV_MBUS_REGS_OFFSET                     (0x20000)
 #define CPU_GLOBAL_BASE                         (MV_MBUS_REGS_OFFSET)
diff --git a/arch/arm/mach-avantalp/config/mvSysGppConfig.h b/arch/arm/mach-avantalp/config/mvSysGppConfig.h
index 630d523..0ae70e3 100644
--- a/arch/arm/mach-avantalp/config/mvSysGppConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysGppConfig.h
@@ -33,5 +33,6 @@ disclaimer.
 /*
 ** Base address for GPP registers.
 */
-#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
-#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
+#define MV_CPU_GPP_REGS_BASE(cpu, unit)		(MV_CPU_GPP_REGS_OFFSET(cpu, unit))
+#define MV_GPP_REGS_BASE(unit)			(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0			(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 390190b..685d14c 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -1740,9 +1740,9 @@ static void __init alp_board_init(void)
 	alp_sdio_init();
 	alp_i2c_init();
 	alp_audio_init();
+	alp_gpio_init();
 
 #if 0
-	alp_gpio_init();
 	alp_hwmon_init();
 #endif
 #endif
diff --git a/arch/arm/mach-avantalp/irq.c b/arch/arm/mach-avantalp/irq.c
index 2a2e25d..382c980 100644
--- a/arch/arm/mach-avantalp/irq.c
+++ b/arch/arm/mach-avantalp/irq.c
@@ -20,10 +20,17 @@
 #include "gpp/mvGppRegs.h"
 #include "cpu/mvCpu.h"
 
-/* CPU-shared registers  */
+/*
+ * CPU-shared registers
+ */
 #define SOC_LOCAL_SUM_CAUSE		0x20260
 #define SOC_LOCAL_SUM_CAUSE_BITS	0xffc71111
 
+#define SOC_ERROR_SUM_CAUSE0		0x20a20
+#define SOC_ERROR_SUM_CAUSE1		0x20a24
+#define SOC_ERROR_SUM_CAUSE0_BITS	0xffffffff
+#define SOC_ERROR_SUM_CAUSE1_BITS	0x7ffff
+
 /*
  * CPU-private registers
  */
@@ -34,19 +41,22 @@
 
 #define SOC_LOCAL_SUM_MASK		0x218c4
 
+#define SOC_ERROR_SUM_MASK0		0x218c0
+#define SOC_ERROR_SUM_MASK1		0x218c8
+
 static DEFINE_RAW_SPINLOCK(irq_controller_lock);
 
 /*******************************************************************************
  * Global GPIO interrupt handling
  */
-static void alp_gpio_irq_mask(struct irq_data *d)
+static void alp_glob_gpio_irq_mask(struct irq_data *d)
 {
         u32 irq = d->irq, bitmask, reg;
 
 	if (irq <  IRQ_START_GLOBAL_GPIO ||
 	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
 		WARN(1, "Error: wrong GPIO irq %d\n", irq);
-		return; /* wrong  */
+		return;
 	}
 
 	bitmask = 1 << (irq & 0x1F);
@@ -54,14 +64,14 @@ static void alp_gpio_irq_mask(struct irq_data *d)
 	MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
 }
 
-static void alp_gpio_irq_unmask(struct irq_data *d)
+static void alp_glob_gpio_irq_unmask(struct irq_data *d)
 {
         u32 irq = d->irq, bitmask, reg;
 
 	if (irq <  IRQ_START_GLOBAL_GPIO ||
 	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
 		WARN(1, "Error: wrong GPIO irq %d\n", irq);
-		return; /* wrong  */
+		return;
 	}
 
 	bitmask = 1 << (irq & 0x1F);
@@ -69,27 +79,25 @@ static void alp_gpio_irq_unmask(struct irq_data *d)
 	MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
 }
 
-static struct irq_chip alp_irq_chip = {
-	.name		= "alp_gpio_irq",
-	.irq_mask	= alp_gpio_irq_mask,
-	.irq_mask_ack	= alp_gpio_irq_mask,
-	.irq_unmask	= alp_gpio_irq_unmask,
-	.irq_disable	= alp_gpio_irq_mask,
-	.irq_enable	= alp_gpio_irq_unmask,
+static struct irq_chip alp_glob_gpio_irq_chip = {
+	.name		= "GlobGPIO",
+	.irq_mask	= alp_glob_gpio_irq_mask,
+	.irq_unmask	= alp_glob_gpio_irq_unmask,
 };
 
 /*
- * gpio_cascade_irq is in [85:88] or [90:94]
+ * glob_gpio_cascade_irq is in [85:88] or [90:94]
  */
-static void alp_gpio_cascade_irq_handler(u32 gpio_cascade_irq,
-					 struct irq_desc *desc)
+static void
+alp_glob_gpio_cascade_irq_handler(u32 glob_gpio_cascade_irq,
+				  struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	u32 bit, n, gpio_group, irq, cause, mask;
 
 	chained_irq_enter(chip, desc);
 
-	gpio_group = (gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7) / 4;
+	gpio_group = (glob_gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7) / 4;
 
 	cause = MV_REG_READ(GPP_INT_CAUSE_REG(gpio_group));
 	mask  = MV_REG_READ(GPP_INT_MASK_REG (gpio_group));
@@ -98,44 +106,156 @@ static void alp_gpio_cascade_irq_handler(u32 gpio_cascade_irq,
 	/* Ack GPIO interrupts */
 	MV_REG_WRITE(GPP_INT_LVL_REG(gpio_group), cause);
 
-	for_each_set_bit(bit, &cause, 32) {
-		n = gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7;
+	for_each_set_bit(bit, (unsigned long *)&cause, 32) {
+		n = glob_gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7;
 
 		if (n >= 5)
 			n -= 1;
 		n = (n * 8) + (bit % 4);
 
 		irq = IRQ_START_GLOBAL_GPIO + n;
-		handle_level_irq(irq, desc);
+		generic_handle_irq(irq);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void __init
+alp_cascade_irq_gpio_global(int irq_start, int nr_irqs)
+{
+	int irq, irq_base;
+
+	irq_base = irq_alloc_descs(-1, irq_start, nr_irqs, 0);
+	if (IS_ERR_VALUE(irq_base))
+		BUG();
+
+	for (irq = irq_start; irq < irq_start + nr_irqs; irq++) {
+		irq_set_chip_and_handler(irq, &alp_glob_gpio_irq_chip,
+					 handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+
+	       /* Use handle_edge_irq() to support edge triggered GPIO IRQ.
+		* See IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, etc.
+		* Note: change also irq_mask and irq_unmask callbacks.
+		*  - For Edge GPIO IRQ: use GPP_INT_MASK_REG register
+		*  - For Level GPIO IRQ: use GPP_INT_LVL_REG register
+		*
+		* irq_set_chip_and_handler(irq, &alp_glob_gpio_irq_chip,
+		*			    handle_edge_irq);
+		*/
+	}
+
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,   alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,  alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63, alp_glob_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66, alp_glob_gpio_cascade_irq_handler);
+}
+
+/*******************************************************************************
+ * CPU-private GPIO interrupts
+ */
+static void alp_priv_gpio_irq_mask(struct irq_data *d)
+{
+	u32 irq = d->irq, bitmask, reg;
+	u32 cpu = smp_processor_id();
+
+	if (irq <  IRQ_START_PRIV_GPIO ||
+	    irq >= IRQ_START_PRIV_GPIO + NR_IRQS_PRIV_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return;
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_PRIV_GPIO) >> 5;
+	MV_REG_BIT_RESET(CPU_GPP_INT_LVL_REG(cpu, reg), bitmask);
+}
+
+static void alp_priv_gpio_irq_unmask(struct irq_data *d)
+{
+	u32 irq = d->irq, bitmask, reg;
+	u32 cpu = smp_processor_id();
+
+	if (irq <  IRQ_START_PRIV_GPIO ||
+	    irq >= IRQ_START_PRIV_GPIO + NR_IRQS_PRIV_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return;
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_PRIV_GPIO) >> 5;
+	MV_REG_BIT_SET(CPU_GPP_INT_LVL_REG(cpu, reg), bitmask);
+}
+
+static struct irq_chip alp_priv_gpio_irq_chip = {
+	.name		= "PrivGPIO",
+	.irq_mask	= alp_priv_gpio_irq_mask,
+	.irq_unmask	= alp_priv_gpio_irq_unmask,
+};
+
+/*
+ * priv_gpio_cascade_irq is in [85:88] or [90:94]
+ */
+static void alp_priv_gpio_cascade_irq_handler(u32 priv_gpio_cascade_irq,
+					      struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u32 bit, n, gpio_group, irq, cause, mask;
+	u32 cpu = smp_processor_id();
+
+	chained_irq_enter(chip, desc);
+
+	gpio_group = (priv_gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7) / 4;
+
+	cause = MV_REG_READ(CPU_GPP_INT_CAUSE_REG(cpu, gpio_group));
+	mask  = MV_REG_READ(CPU_GPP_INT_MASK_REG(cpu, gpio_group));
+	cause &= mask;
+
+	/* Ack GPIO interrupts */
+	MV_REG_WRITE(CPU_GPP_INT_LVL_REG(cpu, gpio_group), cause);
+
+	for_each_set_bit(bit, (unsigned long *)&cause, 32) {
+		n = priv_gpio_cascade_irq - IRQ_PRIV_GPIO_0_7;
+
+		if (n >= 5)
+			n -= 1;
+		n = (n * 8) + (bit % 4);
+
+		irq = IRQ_START_PRIV_GPIO + n;
+		generic_handle_irq(irq);
 	}
 
 	chained_irq_exit(chip, desc);
 }
 
-static void __init alp_cascade_irq_gpio_global(void)
+static void __init
+alp_cascade_irq_gpio_private(int irq_start, int nr_irqs)
 {
 	int irq, irq_base;
 
-	irq_base = irq_alloc_descs(-1, IRQ_START_GLOBAL_GPIO,
-				   NR_IRQS_GLOBAL_GPIO, 0);
+	irq_base = irq_alloc_descs(-1, irq_start, nr_irqs, 0);
 	if (IS_ERR_VALUE(irq_base))
 		BUG();
 
-	for (irq = IRQ_START_GLOBAL_GPIO;
-	     irq < IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO; irq++) {
-		irq_set_chip_and_handler(irq, &alp_irq_chip, handle_level_irq);
+	for (irq = irq_start; irq < irq_start + nr_irqs; irq++) {
+		irq_set_chip_and_handler(irq, &alp_priv_gpio_irq_chip,
+					 handle_level_irq);
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,   alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,  alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63, alp_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66, alp_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_0_7,   alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_8_15,  alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_16_23, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_24_31, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_32_39, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_40_47, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_48_55, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_56_63, alp_priv_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_64_66, alp_priv_gpio_cascade_irq_handler);
 }
 
 /* Mask and Unmaks registers are the same in case of some interrupts.
@@ -157,7 +277,7 @@ struct alp_irq_chip_data {
 /*******************************************************************************
  * CPU-private Local Summary interrupts
  */
-static struct alp_irq_chip_data alp_local_summary_chip_data = {
+static struct alp_irq_chip_data alp_local_sum_irq_chip_data = {
 	.regs = {
 		.cause	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_CAUSE,
 		.mask	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_MASK,
@@ -166,7 +286,7 @@ static struct alp_irq_chip_data alp_local_summary_chip_data = {
 	.mask = SOC_LOCAL_SUM_CAUSE_BITS,
 };
 
-static void alp_local_summary_irq_mask(struct irq_data *d)
+static void alp_local_sum_irq_mask(struct irq_data *d)
 {
 	u32 mask;
 	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
@@ -179,7 +299,7 @@ static void alp_local_summary_irq_mask(struct irq_data *d)
 	raw_spin_unlock(&irq_controller_lock);
 }
 
-static void alp_local_summary_irq_unmask(struct irq_data *d)
+static void alp_local_sum_irq_unmask(struct irq_data *d)
 {
 	u32 mask;
 	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
@@ -193,15 +313,16 @@ static void alp_local_summary_irq_unmask(struct irq_data *d)
 }
 
 
-static struct irq_chip alp_local_summary_irq_chip = {
-	.irq_mask	= alp_local_summary_irq_mask,
-	.irq_unmask	= alp_local_summary_irq_unmask,
+static struct irq_chip alp_local_sum_irq_chip = {
+	.name		= "LocalSum",
+	.irq_mask	= alp_local_sum_irq_mask,
+	.irq_unmask	= alp_local_sum_irq_unmask,
 };
 
 static void
-alp_handle_cascade_irq_local_summary(u32 irq, struct irq_desc *desc)
+alp_handle_cascade_irq_local_sum(u32 irq, struct irq_desc *desc)
 {
-	struct alp_irq_chip_data *chd = &alp_local_summary_chip_data;
+	struct alp_irq_chip_data *chd = &alp_local_sum_irq_chip_data;
 	u32 cause, virt_irq;
 
 	chained_irq_enter(irq_get_chip(irq), desc);
@@ -226,33 +347,189 @@ alp_handle_cascade_irq_local_summary(u32 irq, struct irq_desc *desc)
 }
 
 static int
-alp_local_sumary_irq_domain_map(struct irq_domain *d, u32 irq,
+alp_local_sum_irq_domain_map(struct irq_domain *d, u32 irq,
 				irq_hw_number_t hwirq)
 {
 	irq_set_chip_and_handler(irq,
-		&alp_local_summary_irq_chip, handle_percpu_devid_irq);
+		&alp_local_sum_irq_chip, handle_percpu_devid_irq);
 	irq_set_chip_data(irq, d->host_data);
-	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	set_irq_flags(irq, IRQF_VALID);
 	return 0;
 }
 
-static struct irq_domain_ops alp_local_summary_irq_domain_ops = {
-	.map	= alp_local_sumary_irq_domain_map,
+static struct irq_domain_ops alp_local_sum_irq_domain_ops = {
+	.map	= alp_local_sum_irq_domain_map,
 };
 
 static void __init
-alp_cascade_irq_local_summary(int chained_irq, int irq, int nr_irqs)
+alp_cascade_irq_local_sum(int chained_irq, int irq, int nr_irqs)
 {
-	struct alp_irq_chip_data *chd = &alp_local_summary_chip_data;
+	struct alp_irq_chip_data *chd = &alp_local_sum_irq_chip_data;
 
 	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
 	if (IS_ERR_VALUE(chd->irq_base))
 		BUG();
 
 	chd->domain = irq_domain_add_legacy(NULL, nr_irqs, chd->irq_base,
-				    0, &alp_local_summary_irq_domain_ops, chd);
+				    0, &alp_local_sum_irq_domain_ops, chd);
 	WARN_ON(!chd->domain);
-	irq_set_chained_handler(chained_irq, alp_handle_cascade_irq_local_summary);
+	irq_set_chained_handler(chained_irq, alp_handle_cascade_irq_local_sum);
+}
+
+/*******************************************************************************
+ * CPU-private Error interrupts
+ */
+
+/*
+ * Avanta-LP has 51 Error interrupts, hence,
+ * there are pairs or register of Cause and Mask registers.
+ */
+static struct alp_irq_chip_data alp_error_sum0_irq_chip_data = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_CAUSE0,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_MASK0,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_MASK0,
+	},
+	.mask = SOC_ERROR_SUM_CAUSE0_BITS,
+};
+
+static struct alp_irq_chip_data alp_error_sum1_irq_chip_data = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_CAUSE1,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_MASK1,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_ERROR_SUM_MASK1,
+	},
+	.mask = SOC_ERROR_SUM_CAUSE1_BITS,
+};
+
+static struct alp_irq_chip_data *alp_error_sum_irq_chip_data[2] = {
+	&alp_error_sum0_irq_chip_data,
+	&alp_error_sum1_irq_chip_data,
+};
+
+static void alp_error_sum_irq_mask(struct irq_data *d)
+{
+	u32 mask;
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	/* To mask IRQ, set its bit to zero. */
+	raw_spin_lock(&irq_controller_lock);
+	mask = readl_relaxed(chd->regs.mask);
+	mask &= ~(1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static void alp_error_sum_irq_unmask(struct irq_data *d)
+{
+	u32 mask;
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	/* To unmask IRQ, set its bit to one. */
+	raw_spin_lock(&irq_controller_lock);
+	mask = readl_relaxed(chd->regs.unmask);
+	mask |= (1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.unmask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+
+static struct irq_chip alp_error_sum_irq_chip = {
+	.name		= "ErrorSum",
+	.irq_mask	= alp_error_sum_irq_mask,
+	.irq_unmask	= alp_error_sum_irq_unmask,
+};
+
+static int alp_get_error_sum_virt_irq(struct alp_irq_chip_data *chd)
+{
+	int virt_irq = 0;
+	u32 cause;
+
+	raw_spin_lock(&irq_controller_lock);
+	cause = readl_relaxed(chd->regs.cause);
+	raw_spin_unlock(&irq_controller_lock);
+
+	/* leave only relevant cause bits */
+	cause &= chd->mask;
+	if (cause)
+		virt_irq = ffs(cause) - 1 + chd->irq_base;
+
+	return virt_irq;
+}
+
+static void
+alp_handle_cascade_irq_error_sum(u32 chained_irq,
+				 struct irq_desc *chained_irq_desc)
+{
+	int irq[2];
+
+	chained_irq_enter(irq_get_chip(chained_irq), chained_irq_desc);
+
+	/* Check Error Summary0 Register */
+	irq[0] = alp_get_error_sum_virt_irq(alp_error_sum_irq_chip_data[0]);
+	if (irq[0])
+		generic_handle_irq(irq[0]);
+
+	/* Check Error Summary1 Register */
+	irq[1] = alp_get_error_sum_virt_irq(alp_error_sum_irq_chip_data[1]);
+	if (irq[1])
+		generic_handle_irq(irq[1]);
+
+	/* Warn in case of spurious interrupt */
+	if (!irq[0] && !irq[1])
+		pr_warn("%s: Zero error summary interrupt cause regs\n", __func__);
+
+	chained_irq_exit(irq_get_chip(chained_irq), chained_irq_desc);
+}
+
+/*
+ * Register Error Summary interrupts.
+ */
+static int
+alp_error_sum_irq_domain_map(struct irq_domain *d, u32 irq,
+			     irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &alp_error_sum_irq_chip,
+				 handle_percpu_devid_irq);
+	/* irq_set_percpu_devid(irq); */
+	irq_set_chip_data(irq, d->host_data);
+	set_irq_flags(irq, IRQF_VALID);
+	return 0;
+}
+
+static struct irq_domain_ops alp_error_sum_irq_domain_ops = {
+	.map	= alp_error_sum_irq_domain_map,
+};
+
+static void __init
+alp_cascade_irq_error_sum(int chained_irq, int irq, int nr_irqs)
+{
+	struct alp_irq_chip_data *chd;
+
+	/* Register first 32 Error Summary0 interrupts */
+	chd = alp_error_sum_irq_chip_data[0];
+
+	chd->irq_base = irq_alloc_descs(-1, irq, 32, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
+		BUG();
+
+	chd->domain = irq_domain_add_legacy(NULL, 32, chd->irq_base,
+				0, &alp_error_sum_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+
+	/* Register 19 remaining Error Summary1 interrupts */
+	chd = alp_error_sum_irq_chip_data[1];
+
+	chd->irq_base = irq_alloc_descs(-1, irq + 32, nr_irqs - 32, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
+		BUG();
+
+	chd->domain = irq_domain_add_legacy(NULL, nr_irqs - 32, chd->irq_base,
+				0, &alp_error_sum_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+
+	/* Set chained handler */
+	irq_set_chained_handler(chained_irq, alp_handle_cascade_irq_error_sum);
 }
 
 /*******************************************************************************
@@ -295,16 +572,18 @@ static void alp_ppi_irq_unmask(struct irq_data *d)
 }
 
 static struct irq_chip alp_ppi_irq_chip = {
+	.name		= "PIC-PPI",
 	.irq_mask	= alp_ppi_irq_mask,
 	.irq_unmask	= alp_ppi_irq_unmask,
 };
 
-static void alp_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
+static void alp_ppi_handle_cascade_irq(u32 chained_irq,
+				       struct irq_desc *chained_irq_desc)
 {
 	struct alp_irq_chip_data *chd = irq_get_chip_data(IRQ_START_PRIV_SOC_PPI);
 	u32 cause, virt_irq;
 
-	chained_irq_enter(irq_get_chip(irq), desc);
+	chained_irq_enter(irq_get_chip(chained_irq), chained_irq_desc);
 
 	raw_spin_lock(&irq_controller_lock);
 	cause = readl_relaxed(chd->regs.cause);
@@ -322,13 +601,13 @@ static void alp_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
 	generic_handle_irq(virt_irq);
 
  out:
-	chained_irq_exit(irq_get_chip(irq), desc);
+	chained_irq_exit(irq_get_chip(chained_irq), chained_irq_desc);
 }
 
 static int
 alp_ppi_irq_domain_map(struct irq_domain *d, u32 irq, irq_hw_number_t hwirq)
 {
-	irq_set_chip_and_handler(irq, &alp_ppi_irq_chip, handle_percpu_devid_irq);
+	irq_set_chip_and_handler(irq, &alp_ppi_irq_chip, handle_level_irq);
 	irq_set_chip_data(irq, d->host_data);
 	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 	return 0;
@@ -357,16 +636,16 @@ alp_cascade_irq_ppi(int chained_irq, int irq, int nr_irqs)
 	WARN_ON(!chd->domain);
 	irq_set_chained_handler(chained_irq, alp_ppi_handle_cascade_irq);
 
-	alp_cascade_irq_local_summary(IRQ_PRIV_MP_LOCAL_SUMMARY,
-			      IRQ_START_PRIV_LOCAL_SUM, NR_IRQS_PRIV_LOCAL_SUM);
-}
+	/*
+	 * Init all interrupt sub-trees.
+	 */
+	alp_cascade_irq_local_sum(IRQ_PRIV_MP_LOCAL_SUMMARY,
+			IRQ_START_PRIV_LOCAL_SUM, NR_IRQS_PRIV_LOCAL_SUM);
 
-/*******************************************************************************
- * CPU-private GPIO interrupts
- */
-static void __init alp_cascade_irq_gpio_private(void)
-{
-	/* TBD */
+	alp_cascade_irq_gpio_private(IRQ_START_PRIV_GPIO, NR_IRQS_PRIV_GPIO);
+
+	alp_cascade_irq_error_sum(IRQ_PRIV_SOC_ERROR_SUMMARY,
+				  IRQ_START_PRIV_ERROR, NR_IRQS_PRIV_ERROR);
 }
 
 /*******************************************************************************
@@ -386,14 +665,6 @@ static void __init alp_cascade_irq_msi_private(void)
 }
 
 /*******************************************************************************
- * CPU-private error interrupts
- */
-static void __init alp_cascade_irq_errors(void)
-{
-	/* TBD */
-}
-
-/*******************************************************************************
  * Init GIC and MPIC and setup cascade irq
  * handling for Local Summary, GPIO, MSI and Error interrupts.
  */
@@ -405,11 +676,8 @@ void __init alp_irq_init(void)
 	alp_cascade_irq_ppi(IRQ_PRIV_MPIC_PPI_IRQ,
 			    IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
 
-	alp_cascade_irq_gpio_global();
-	alp_cascade_irq_gpio_private();
+	alp_cascade_irq_gpio_global(IRQ_START_GLOBAL_GPIO, NR_IRQS_GLOBAL_GPIO);
 
 	alp_cascade_irq_msi_global();
 	alp_cascade_irq_msi_private();
-
-	alp_cascade_irq_errors();
 }
diff --git a/arch/arm/plat-armada/mv_hal/gpp/mvGppRegs.h b/arch/arm/plat-armada/mv_hal/gpp/mvGppRegs.h
index ea223c8..cf58fda 100755
--- a/arch/arm/plat-armada/mv_hal/gpp/mvGppRegs.h
+++ b/arch/arm/plat-armada/mv_hal/gpp/mvGppRegs.h
@@ -157,17 +157,29 @@ extern "C" {
 #define GPP_OUT_SET_REG(grp)			(GPP_OUT_SET_REG_BASE + ( (grp) * 0x40 ) )
 #define GPP_64_66_DATA_OUT_SET_REG		(MV_GPP_REGS_BASE(0) + 0xA4)
 #define GPP_OUT_CLEAR_REG(grp)			(GPP_OUT_CLEAR_REG_BASE + ((grp) * 0x40))
-#define GPP_64_66_DATA_OUT_CLEAR_REG	(MV_GPP_REGS_BASE(0) + 0xB0)
+#define GPP_64_66_DATA_OUT_CLEAR_REG		(MV_GPP_REGS_BASE(0) + 0xB0)
 
 #define GPP_FUNC_SELECT_REG			(MV_GPP_REGS_BASE(0) + 0x40)
 
+/*
+ * CPU-private GPIO (aka GPIO per CPU)
+ */
+#define CPU_GPP_DATA_OUT_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x00)
+#define CPU_GPP_DATA_OUT_EN_REG(cpu, grp)	(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x04)
+#define CPU_GPP_BLINK_EN_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x08)
+#define CPU_GPP_DATA_IN_POL_REG(cpu, grp)	(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x0C)
+#define CPU_GPP_DATA_IN_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x10)
+#define CPU_GPP_INT_CAUSE_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x14)
+#define CPU_GPP_INT_MASK_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x18)
+#define CPU_GPP_INT_LVL_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x1C)
+#define CPU_GPP_BLINK_SEL_REG(cpu, grp)		(MV_CPU_GPP_REGS_BASE(cpu, grp) + 0x20)
+
 /* Relevant for MV78XX0 */
 #define GPP_DATA_OUT_SET_REG			(MV_GPP_REGS_BASE(0) + 0x20)
 #define GPP_DATA_OUT_CLEAR_REG			(MV_GPP_REGS_BASE(0) + 0x24)
 #define GPP_OUT_SET_REG_BASE			(MV_GPP_REGS_BASE(0) + 0x30)
 #define GPP_OUT_CLEAR_REG_BASE			(MV_GPP_REGS_BASE(0) + 0x34)
 
-
 #ifdef __cplusplus
 }
 #endif				/* __cplusplus */
-- 
1.7.5.4

