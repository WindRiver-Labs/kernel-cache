From 2e2fbd8d4635941feb2cc56140c41673e6ee3bd1 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Tue, 8 Oct 2013 10:32:28 +0200
Subject: [PATCH 1093/1825] a38x: add initial mach-armada38x directory
 contents

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b406647e8e386cb5b8330dfe5777ada5f008becb

	- added contents are a clone of mach-armada375 - to be adjusted to a38x

Change-Id: I5e4d6fae3aa9a348ef63f33551b93367c3141679
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3630
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/Kconfig                    |   79 ++
 arch/arm/mach-armada38x/Makefile                   |  125 ++
 arch/arm/mach-armada38x/Makefile.boot              |    9 +
 arch/arm/mach-armada38x/ca9x2.h                    |   24 +
 arch/arm/mach-armada38x/config/mvRules.mk          |  163 +++
 arch/arm/mach-armada38x/config/mvSysCesaConfig.h   |   45 +
 arch/arm/mach-armada38x/config/mvSysCntmrConfig.h  |   36 +
 arch/arm/mach-armada38x/config/mvSysDdrConfig.h    |   44 +
 arch/arm/mach-armada38x/config/mvSysEthConfig.h    |  182 +++
 arch/arm/mach-armada38x/config/mvSysEthPhyConfig.h |   31 +
 arch/arm/mach-armada38x/config/mvSysGppConfig.h    |   37 +
 arch/arm/mach-armada38x/config/mvSysHwConfig.h     |  280 ++++
 arch/arm/mach-armada38x/config/mvSysNfcConfig.h    |   36 +
 arch/arm/mach-armada38x/config/mvSysPciConfig.h    |   25 +
 arch/arm/mach-armada38x/config/mvSysPexConfig.h    |   49 +
 arch/arm/mach-armada38x/config/mvSysPonConfig.h    |   37 +
 arch/arm/mach-armada38x/config/mvSysRtcConfig.h    |   36 +
 arch/arm/mach-armada38x/config/mvSysSataConfig.h   |   36 +
 arch/arm/mach-armada38x/config/mvSysSdmmcConfig.h  |   36 +
 arch/arm/mach-armada38x/config/mvSysSpiConfig.h    |   36 +
 arch/arm/mach-armada38x/config/mvSysTdmConfig.h    |   63 +
 arch/arm/mach-armada38x/config/mvSysTwsiConfig.h   |   41 +
 arch/arm/mach-armada38x/config/mvSysUsbConfig.h    |   24 +
 arch/arm/mach-armada38x/config/mvSysXorConfig.h    |   36 +
 arch/arm/mach-armada38x/core.c                     | 1333 +++++++++++++++++++
 arch/arm/mach-armada38x/core.h                     |   50 +
 arch/arm/mach-armada38x/dump_cp15_regs.c           |  217 ++++
 arch/arm/mach-armada38x/export.c                   |  212 +++
 arch/arm/mach-armada38x/flashmap.c                 |  291 +++++
 arch/arm/mach-armada38x/headsmp.S                  |   90 ++
 arch/arm/mach-armada38x/hwmon.c                    |  392 ++++++
 arch/arm/mach-armada38x/include/mach/armada380.h   |  141 ++
 arch/arm/mach-armada38x/include/mach/debug-macro.S |   24 +
 arch/arm/mach-armada38x/include/mach/entry-macro.S |    7 +
 arch/arm/mach-armada38x/include/mach/gpio.h        |   55 +
 arch/arm/mach-armada38x/include/mach/hardware.h    |   14 +
 arch/arm/mach-armada38x/include/mach/io.h          |   21 +
 arch/arm/mach-armada38x/include/mach/irqs.h        |  220 ++++
 arch/arm/mach-armada38x/include/mach/memory.h      |   28 +
 arch/arm/mach-armada38x/include/mach/param.h       |   15 +
 arch/arm/mach-armada38x/include/mach/serial.h      |   41 +
 arch/arm/mach-armada38x/include/mach/smp.h         |   23 +
 arch/arm/mach-armada38x/include/mach/system.h      |   34 +
 arch/arm/mach-armada38x/include/mach/timex.h       |    9 +
 arch/arm/mach-armada38x/include/mach/uncompress.h  |   43 +
 arch/arm/mach-armada38x/include/mach/vmalloc.h     |    6 +
 arch/arm/mach-armada38x/irq.c                      |  278 ++++
 arch/arm/mach-armada38x/localtimer.c               |   27 +
 arch/arm/mach-armada38x/mpp.h                      |   33 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysCesa.c      |  122 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysCesaApi.h   |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysDdr.c       |  131 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysEth.c       |  133 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysEthApi.h    |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhy.c    |  108 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhyApi.h |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysNeta.c      |  150 +++
 arch/arm/mach-armada38x/mv_hal_if/mvSysNetaApi.h   |   71 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysPci.c       | 1343 ++++++++++++++++++++
 arch/arm/mach-armada38x/mv_hal_if/mvSysPci.h       |  261 ++++
 arch/arm/mach-armada38x/mv_hal_if/mvSysPex.c       |   98 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysPexApi.h    |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysSFlash.c    |  225 ++++
 arch/arm/mach-armada38x/mv_hal_if/mvSysSata.c      |   81 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysSataApi.h   |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysSpi.c       |  123 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysSpiApi.h    |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysTdm.c       |  242 ++++
 arch/arm/mach-armada38x/mv_hal_if/mvSysTdmApi.h    |   78 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c       |  116 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysUsbApi.h    |   70 +
 arch/arm/mach-armada38x/mv_hal_if/mvSysXor.c       |   91 ++
 arch/arm/mach-armada38x/mv_hal_if/mvSysXorApi.h    |   70 +
 arch/arm/mach-armada38x/pci.c                      |  240 ++++
 arch/arm/mach-armada38x/pex.c                      |  370 ++++++
 arch/arm/mach-armada38x/platsmp.c                  |  152 +++
 arch/arm/mach-armada38x/sysmap.c                   |  166 +++
 arch/arm/mach-armada38x/time.c                     |  245 ++++
 arch/arm/mach-armada38x/usb.c                      |  312 +++++
 79 files changed, 10532 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-armada38x/Kconfig
 create mode 100644 arch/arm/mach-armada38x/Makefile
 create mode 100644 arch/arm/mach-armada38x/Makefile.boot
 create mode 100644 arch/arm/mach-armada38x/ca9x2.h
 create mode 100644 arch/arm/mach-armada38x/config/mvRules.mk
 create mode 100644 arch/arm/mach-armada38x/config/mvSysCesaConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysCntmrConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysDdrConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysEthConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysEthPhyConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysGppConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysNfcConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysPciConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysPexConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysPonConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysRtcConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysSataConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysSdmmcConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysSpiConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysTdmConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysTwsiConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysUsbConfig.h
 create mode 100644 arch/arm/mach-armada38x/config/mvSysXorConfig.h
 create mode 100644 arch/arm/mach-armada38x/core.c
 create mode 100644 arch/arm/mach-armada38x/core.h
 create mode 100644 arch/arm/mach-armada38x/dump_cp15_regs.c
 create mode 100644 arch/arm/mach-armada38x/export.c
 create mode 100644 arch/arm/mach-armada38x/flashmap.c
 create mode 100644 arch/arm/mach-armada38x/headsmp.S
 create mode 100644 arch/arm/mach-armada38x/hwmon.c
 create mode 100644 arch/arm/mach-armada38x/include/mach/armada380.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-armada38x/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-armada38x/include/mach/gpio.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/hardware.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/io.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/irqs.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/memory.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/param.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/serial.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/smp.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/system.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/timex.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-armada38x/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-armada38x/irq.c
 create mode 100644 arch/arm/mach-armada38x/localtimer.c
 create mode 100644 arch/arm/mach-armada38x/mpp.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysCesa.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysCesaApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysDdr.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysEth.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysEthApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhy.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhyApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysNeta.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysNetaApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysPci.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysPci.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysPex.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysPexApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysSFlash.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysSata.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysSataApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysSpi.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysSpiApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysTdm.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysTdmApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysUsbApi.h
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysXor.c
 create mode 100644 arch/arm/mach-armada38x/mv_hal_if/mvSysXorApi.h
 create mode 100644 arch/arm/mach-armada38x/pci.c
 create mode 100644 arch/arm/mach-armada38x/pex.c
 create mode 100644 arch/arm/mach-armada38x/platsmp.c
 create mode 100644 arch/arm/mach-armada38x/sysmap.c
 create mode 100644 arch/arm/mach-armada38x/time.c
 create mode 100644 arch/arm/mach-armada38x/usb.c

diff --git a/arch/arm/mach-armada38x/Kconfig b/arch/arm/mach-armada38x/Kconfig
new file mode 100644
index 0000000..b94f9a1
--- /dev/null
+++ b/arch/arm/mach-armada38x/Kconfig
@@ -0,0 +1,79 @@
+if ARCH_ARMADA380
+
+config  MV_HAL_RULES_PATH
+	string "path of the mvRules.mk file for HAL drivers"
+	default "arch/arm/mach-armada380/mv_hal_support/mvRules.mk"
+	help
+	  No help currently.
+
+config A380_CPU1_ENABLE_WA
+	depends on SMP
+	bool "SMP CPU1 Enable WA"
+	default y
+
+menu "Marvell Armada-380 Options"
+
+config ARMADA_380
+	bool "Armada-380 SoC Family"
+	default y
+
+choice
+	prompt "Armada-380 Chip revision"
+	depends on ARMADA_380
+	default ARMADA_380_REV_XX
+
+config  ARMADA_380_REV_XX
+	bool "Armada-380 SoC devices"
+	select ARM_GIC
+	select ARM_ERRATA_720789
+	select ARM_ERRATA_751472
+	select ARM_ERRATA_753970
+	select NEON
+	help
+	  Choosing this option will generate a linux kernel for the
+	  Armada-380 devices
+
+endchoice
+
+config MACH_ARMADA_380
+	bool "Marvell Armada-380 SoC Family"
+	default y
+	help
+	  No help currently.
+
+config CFU_DRAM_BYPASS
+        bool "Bypass CFU to DRAM via Punit"
+	default n
+	help
+	  No help currently.
+
+config A375_FIRST_DABT_WA
+	bool "Discard first data abort"
+	default n
+	help
+	  Workaround that discards first data abort to avoid getting
+	  unhandled fault on boot.
+
+config A380_Z1_USB3_LFPS_FREQ_WA
+	bool "Enable the LFPS frequency workaround for USB3"
+	default n
+	help
+	  This flag enables a workaround for USB3 in Armada 380. It
+	  fixes the USB3 LFPS timing to fix some clock issues
+	  in the integration of USB3. This WA is needed only
+	  for Z1 devices
+
+
+
+config ARMADA_380_USE_LEGACY_USB2
+	bool "Use legacy USB2 IP instead of USB3 IP"
+	default n
+	help
+	 Armada 380 contain 2 USB host controllers: A legacy USB2
+	 only controller and a new USB3 controller which also supports USB2.
+	 This flag enables to choose which of the host controllers to use.
+	 It mainly affects the USB2 PHY to host connectivity
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-armada38x/Makefile b/arch/arm/mach-armada38x/Makefile
new file mode 100644
index 0000000..2aae2cc
--- /dev/null
+++ b/arch/arm/mach-armada38x/Makefile
@@ -0,0 +1,125 @@
+#*******************************************************************************
+# Marvell GPL License Option
+#
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
+# disclaimer.
+#*******************************************************************************/
+include		  $(srctree)/arch/arm/mach-armada380/config/mvRules.mk
+
+
+# Objects list
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o $(COMMON_DIR)/mvIpc.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_RTC_DIR)/mvRtc.o					\
+		  $(HAL_CNTMR_DIR)/mvCntmr.o					\
+		  $(HAL_TWSI_DIR)/mvTwsi.o					\
+		  $(HAL_UART_DIR)/mvUart.o $(HAL_GPP_DIR)/mvGpp.o		\
+		  $(HAL_DRAM_DIR)/mvDramIf.o					\
+		  $(HAL_IF_DIR)/mvSysDdr.o
+#		  $(HAL_DRAM_SPD_DIR)/mvSpd.o
+
+KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o $(SOC_ENV_DIR)/mvCtrlEnvLib.o	\
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
+		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
+		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o			\
+		  $(SOC_ENV_DIR)/mvCtrlEthCompLib.o
+
+QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
+		  $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o	\
+		  $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o	\
+		  $(HAL_QD_DIR)/src/platform/gtDebug.o $(HAL_QD_DIR)/src/msapi/gtBrgFdb.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtBrgStp.o $(HAL_QD_DIR)/src/msapi/gtBrgVlan.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtEvents.o $(HAL_QD_DIR)/src/msapi/gtPortCtrl.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtPortStat.o $(HAL_QD_DIR)/src/msapi/gtPortStatus.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtQosMap.o $(HAL_QD_DIR)/src/msapi/gtPIRL.o  		\
+		  $(HAL_QD_DIR)/src/msapi/gtPhyCtrl.o $(HAL_QD_DIR)/src/msapi/gtPhyInt.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtSysConfig.o $(HAL_QD_DIR)/src/msapi/gtSysCtrl.o	\
+		  $(HAL_QD_DIR)/src/msapi/gtVersion.o $(HAL_QD_DIR)/src/msapi/gtUtils.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtBrgVtu.o $(HAL_QD_DIR)/src/msapi/gtPortRmon.o 	\
+		  $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o\
+		  $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
+
+LSP_OBJS        = core.o irq.o sysmap.o export.o time.o
+
+obj-y					:= armada380.o
+obj-$(CONFIG_LOCAL_TIMERS)		+= localtimer.o
+armada380-objs				:= $(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS)	\
+					   $(KW_FAM_OBJS)
+
+armada380-$(CONFIG_MV_INCLUDE_SDIO)	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
+armada380-$(CONFIG_MV_INCLUDE_XOR)	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysXor.o
+armada380-$(CONFIG_MV_INCLUDE_PEX)	+= $(HAL_PEX_DIR)/mvPex.o					\
+					   $(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
+armada380-$(CONFIG_MV_INCLUDE_PCI)	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+armada380-$(CONFIG_MV_INCLUDE_USB)	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysUsb.o
+armada380-$(CONFIG_MV_INCLUDE_ETH_PHY)	+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
+
+# PP2 Giga driver
+obj-$(CONFIG_MV_ETH_PP2)		+= $(LSP_PP2_DIR)/
+
+armada380-$(CONFIG_MV_INCLUDE_CESA)	+= $(HAL_CESA_DIR)/mvCesa.o					\
+					   $(HAL_CESA_DIR)/mvCesaDebug.o				\
+					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
+					   $(HAL_CESA_DIR)/mvMD5.o $(HAL_CESA_DIR)/mvSHA1.o		\
+					   $(HAL_CESA_DIR)/mvSHA256.o					\
+					   $(HAL_CESA_AES_DIR)/mvAesAlg.o $(HAL_CESA_AES_DIR)/mvAesApi.o\
+					   $(HAL_IF_DIR)/mvSysCesa.o
+
+armada380-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
+					   $(HAL_SATA_DIR)/mvSataAddrDec.o
+armada380-$(CONFIG_MV_INCLUDE_SPI)	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o		\
+					   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
+					   $(HAL_IF_DIR)/mvSysSpi.o
+armada380-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
+armada380-$(CONFIG_MV_INCLUDE_AUDIO)	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
+					   $(HAL_AUDIO_DIR)/mvAudioAddrDec.o
+armada380-$(CONFIG_MV_CPU_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
+armada380-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
+armada380-$(CONFIG_MV_CPU_L2_PERF_CNTRS)	+= $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(QD_OBJS)
+
+# drivers part
+
+
+obj-$(CONFIG_MV_INCLUDE_GIG_ETH)	+= $(LSP_PHY_DIR)/phy_sysfs.o
+
+obj-$(CONFIG_MV_USE_XOR_ENGINE)		+= $(PLAT_DRIVERS)/mv_xor/
+obj-$(CONFIG_MV_CESA)			+= $(PLAT_DRIVERS)/mv_cesa/
+obj-$(CONFIG_MV_IPC_DRIVER)		+= $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
+#obj-y					+= $(PLAT_DRIVERS)/mv_btns/
+obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_DBG_TRACE)		+= $(PLAT_DRIVERS)/mv_trace/
+obj-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(LSP_SWITCH_DIR)/
+obj-y					+= $(LSP_MUX_DIR)/
+obj-$(CONFIG_SENSORS_A380)		+= hwmon.o
+# The rest of the drivers are compiled through the driver dir directly.
+
+
+# LSP part
+armada380-$(CONFIG_MV_INCLUDE_USB)	+= usb.o
+armada380-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+armada380-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+armada380-$(CONFIG_FEROCEON_PROC)	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+armada380-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+armada380-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
+armada380-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvSemaphore.o
+armada380-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
+obj-$(CONFIG_FB_DOVE_CLCD)		+= clcd.o
+obj-$(CONFIG_MV_ETH_NFP) += nfp.o
diff --git a/arch/arm/mach-armada38x/Makefile.boot b/arch/arm/mach-armada38x/Makefile.boot
new file mode 100644
index 0000000..0ef7d93
--- /dev/null
+++ b/arch/arm/mach-armada38x/Makefile.boot
@@ -0,0 +1,9 @@
+ifdef CONFIG_MV_AMP_ENABLE
+   zreladdr-y   := $(CONFIG_MV_ZREL_ADDR)
+params_phys-y   := $(CONFIG_MV_PARAM_PHYS)
+initrd_phys-y   := $(CONFIG_MV_INITRD_PHYS)
+else
+    zreladdr-y	:= 0x00008000
+ params_phys-y	:= 0x00000100
+ initrd_phys-y	:= 0x00800000
+endif
diff --git a/arch/arm/mach-armada38x/ca9x2.h b/arch/arm/mach-armada38x/ca9x2.h
new file mode 100644
index 0000000..4a2fac4
--- /dev/null
+++ b/arch/arm/mach-armada38x/ca9x2.h
@@ -0,0 +1,24 @@
+#ifndef __MACH_MV_CA9X2_H
+#define __MACH_MV_CA9X2_H
+
+#if defined(CONFIG_SMP) && defined(CONFIG_A380_CPU1_ENABLE_WA)
+void a380_secondary_startup(void);
+void a380_smp_cpu1_enable_wa(void);
+
+extern void *a380_smp_cpu1_enable_code_start;
+extern void *a380_smp_cpu1_enable_code_end;
+#endif
+
+/*
+ * Physical base addresses
+ */
+#define MV_CA9X2_L2CC_OFFSET	(0x8000)
+
+#define MV_CA9X2_MPIC		(0xC000)
+#define A9_MPCORE_SCU		(MV_CA9X2_MPIC + 0x0000)
+#define A9_MPCORE_GIC_CPU	(MV_CA9X2_MPIC + 0x0100)
+#define A9_MPCORE_GIT		(MV_CA9X2_MPIC + 0x0200)
+#define A9_MPCORE_TWD		(MV_CA9X2_MPIC + 0x0600)
+#define A9_MPCORE_GIC_DIST	(MV_CA9X2_MPIC + 0x1000)
+
+#endif /* __MACH_MV_CA9X2_H */
diff --git a/arch/arm/mach-armada38x/config/mvRules.mk b/arch/arm/mach-armada38x/config/mvRules.mk
new file mode 100644
index 0000000..790cbab
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvRules.mk
@@ -0,0 +1,163 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F68XX
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+PLAT_PATH	  = ../plat-armada
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR		  = $(PLAT_PATH)/mv_hal
+COMMON_DIR	  = $(PLAT_PATH)/common
+OSSERV_DIR	  = $(PLAT_PATH)/linux_oss
+CONFIG_DIR	  = config
+HAL_IF		  = mv_hal_if
+
+# HALs
+HAL_ETHPHY_DIR	  = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR	  = $(HAL_DIR)/flash
+HAL_RTC_DIR	  = $(HAL_DIR)/rtc/integ_rtc
+HAL_VOICEBAND	  = $(HAL_DIR)/voiceband
+HAL_SLIC_DIR	  = $(HAL_VOICEBAND)/slic
+HAL_DAA_DIR	  = $(HAL_VOICEBAND)/daa
+HAL_SATA_DIR	  = $(HAL_DIR)/sata/CoreDriver/
+HAL_QD_DIR	  = $(HAL_DIR)/qd-dsdt-3.3
+HAL_SFLASH_DIR	  = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR	  = $(HAL_DIR)/cntmr
+HAL_DRAM_DIR	  = $(HAL_DIR)/ddr2_3
+#HAL_DRAM_SPD_DIR  = $(HAL_DIR)/ddr2_3/spd
+HAL_GPP_DIR	  = $(HAL_DIR)/gpp
+HAL_TWSI_DIR	  = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR	  = $(HAL_DIR)/uart
+
+HAL_PP2_DIR	  = $(HAL_DIR)/pp2
+LSP_PP2_DIR	  = $(PLAT_DRIVERS)/mv_pp2
+
+HAL_CPU_DIR	  = $(HAL_DIR)/cpu
+HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
+ifeq ($(CONFIG_MV_INCLUDE_PCI),y)
+HAL_PCI_DIR	  = $(HAL_DIR)/pci
+endif
+ifeq ($(CONFIG_MV_INCLUDE_PEX),y)
+HAL_PEX_DIR	  = $(HAL_DIR)/pex
+endif
+ifeq ($(CONFIG_MV_INCLUDE_TDM),y)
+HAL_TDM_DIR	  = $(HAL_DIR)/voiceband/tdm
+endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+HAL_USB_DIR	  = $(HAL_DIR)/usb
+endif
+ifeq ($(CONFIG_MV_INCLUDE_CESA),y)
+HAL_CESA_DIR	  = $(HAL_DIR)/cesa
+HAL_CESA_AES_DIR  = $(HAL_DIR)/cesa/AES
+endif
+ifeq ($(CONFIG_MV_INCLUDE_XOR),y)
+HAL_XOR_DIR	  = $(HAL_DIR)/xor
+endif
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR	  = $(HAL_DIR)/spi
+endif
+ifeq ($(CONFIG_MV_INCLUDE_AUDIO),y)
+HAL_AUDIO_DIR	  = $(HAL_DIR)/audio
+endif
+ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
+HAL_NFC_DIR	  = $(HAL_DIR)/nfc
+endif
+
+LSP_TRACE_DIR	  = $(PLAT_DRIVERS)/mv_trace
+LSP_SWITCH_DIR	  = $(PLAT_DRIVERS)/mv_switch
+LSP_PHY_DIR	  = $(PLAT_DRIVERS)/mv_phy
+LSP_MUX_DIR	  = $(PLAT_DRIVERS)/mv_mux
+
+# Environment components
+A380_FAM_DIR	= armada_380_family
+SOC_DEVICE_DIR	= $(A380_FAM_DIR)/device
+SOC_CPU_DIR	= $(A380_FAM_DIR)/cpu
+BOARD_ENV_DIR	= $(A380_FAM_DIR)/boardEnv
+SOC_ENV_DIR	= $(A380_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	= $(A380_FAM_DIR)/ctrlEnv/sys
+HAL_IF_DIR	= mv_hal_if
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I	= $(srctree)/arch/arm/mach-armada380
+PLAT_PATH_I	= $(srctree)/arch/arm/plat-armada
+
+HAL_PATH	= -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+A380_FAM_PATH	= -I$(LSP_PATH_I)/$(A380_FAM_DIR)
+QD_PATH		= -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi	\
+		  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
+
+COMMON_PATH	= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+
+OSSERV_PATH	= -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH	= -I$(LSP_PATH_I)
+CONFIG_PATH	= -I$(LSP_PATH_I)/$(CONFIG_DIR)
+HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF) -I$(LSP_PATH_I)/$(HAL_PP2_DIR)
+DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_PP2_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
+		   -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
+
+EXTRA_INCLUDE	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(A380_FAM_PATH) \
+		  $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+
+
+ifeq ($(CONFIG_MV_GATEWAY),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS	+= -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS	+= -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_CESA_TEST),y)
+EXTRA_CFLAGS	+= -DCONFIG_MV_CESA_TEST
+endif
+
+ifeq ($(CONFIG_SATA_DEBUG_ON_ERROR),y)
+EXTRA_CFLAGS	+= -DMV_LOG_ERROR
+endif
+
+ifeq ($(CONFIG_SATA_FULL_DEBUG),y)
+EXTRA_CFLAGS	+= -DMV_LOG_DEBUG
+endif
+
+ifeq ($(CONFIG_MV_SATA_SUPPORT_ATAPI),y)
+EXTRA_CFLAGS	+= -DMV_SUPPORT_ATAPI
+endif
+
+ifeq ($(CONFIG_MV_SATA_ENABLE_1MB_IOS),y)
+EXTRA_CFLAGS	+= -DMV_SUPPORT_1MBYTE_IOS
+endif
+
+ifeq ($(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT),y)
+EXTRA_CFLAGS	+=-DPCIE_VIRTUAL_BRIDGE_SUPPORT
+endif
+
+ifeq ($(CONFIG_MV_CESA_CHAIN_MODE_SUPPORT),y)
+EXTRA_CFLAGS	+= -DMV_CESA_CHAIN_MODE_SUPPORT
+endif
+
+EXTRA_CFLAGS	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-armada38x/config/mvSysCesaConfig.h b/arch/arm/mach-armada38x/config/mvSysCesaConfig.h
new file mode 100644
index 0000000..cd0f132
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysCesaConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCesaConfig.h - Marvell Cesa unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* #include "mvSysHwConfig.h" */
+#include  "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for cesa registers.
+*/
+#define MV_CESA_REGS_BASE(chan)		(MV_CESA_REGS_OFFSET(chan))
+
+#define MV_CESA_TDMA_REGS_BASE(chan)	(MV_CESA_TDMA_REGS_OFFSET(chan))
+
+#define MV_CESA_CHANNELS		(CONFIG_MV_CESA_CHANNELS)
+
+#ifdef CONFIG_MV_CESA_CHAIN_MODE
+	#define MV_CESA_CHAIN_MODE
+#endif
diff --git a/arch/arm/mach-armada38x/config/mvSysCntmrConfig.h b/arch/arm/mach-armada38x/config/mvSysCntmrConfig.h
new file mode 100644
index 0000000..b6646ae
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysCntmrConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCntmrConfig.h - Marvell Counter Manager unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for counter manager registers.
+*/
+#define MV_CNTMR_REGS_BASE		(MV_CNTMR_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysDdrConfig.h b/arch/arm/mach-armada38x/config/mvSysDdrConfig.h
new file mode 100644
index 0000000..6dfd446
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysDdrConfig.h
@@ -0,0 +1,44 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for DDR registers.
+*/
+#define MV_DDR_WIN_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_DDR_CTRL_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+/* used for ddr2 "bak" files */
+#define MV_DDR_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+#ifndef MV_BOOTROM
+#define MV_STATIC_DRAM_ON_BOARD
+#endif
diff --git a/arch/arm/mach-armada38x/config/mvSysEthConfig.h b/arch/arm/mach-armada38x/config/mvSysEthConfig.h
new file mode 100644
index 0000000..49d0b5a
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysEthConfig.h
@@ -0,0 +1,182 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+#define MV_ETH_COMPLEX_BASE		(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE		(MV_ETH_ONLY_REGS_OFFSET)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0
+
+#ifdef CONFIG_MV_ETH_LEGACY
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL		    200
+#define ETH_RX_COAL		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff --git a/arch/arm/mach-armada38x/config/mvSysEthPhyConfig.h b/arch/arm/mach-armada38x/config/mvSysEthPhyConfig.h
new file mode 100644
index 0000000..ce9ff4a
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysEthPhyConfig.h
@@ -0,0 +1,31 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthPhyConfig.h - Marvell Ethernet-PHY specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
diff --git a/arch/arm/mach-armada38x/config/mvSysGppConfig.h b/arch/arm/mach-armada38x/config/mvSysGppConfig.h
new file mode 100644
index 0000000..7e37a90
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysGppConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysGppConfig.h - Marvell GPP unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for GPP registers.
+*/
+#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-armada38x/config/mvSysHwConfig.h b/arch/arm/mach-armada38x/config/mvSysHwConfig.h
new file mode 100644
index 0000000..8280012
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysHwConfig.h
@@ -0,0 +1,280 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+/* Glue between Linux .config and defines for shared code */
+#define INTER_REGS_BASE			INTER_REGS_VIRT_BASE
+#define CONFIG_MARVELL	1
+
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+#ifdef CONFIG_DRAM_IO_RESERVE_BASE
+#define MV_DRAM_IO_RESERVE_BASE	CONFIG_DRAM_IO_RESERVE_BASE
+#endif
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_PCI
+#define MV_INCLUDE_PCI
+
+#define PCI_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PCI_HOST_DEV_NUM(pciIf)		0
+
+#define PEX_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PEX_HOST_DEV_NUM(pciIf)		0
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_CESA
+#define MV_INCLUDE_CESA
+#endif
+#ifdef CONFIG_MV_ETH_PP2
+#define MV_ETH_PP2
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_SATA
+#endif
+#ifdef CONFIG_MV_INCLUDE_USB
+#define MV_INCLUDE_USB
+#endif
+#ifdef CONFIG_MV_INCLUDE_NFC
+#define MV_INCLUDE_NFC
+#endif
+#ifdef CONFIG_MV_INCLUDE_LEGACY_NAND
+#define MV_INCLUDE_LEGACY_NAND
+#endif
+#ifdef CONFIG_MV_INCLUDE_TDM
+#define MV_INCLUDE_TDM
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+#define MV_INCLUDE_XOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_NOR
+#define MV_INCLUDE_NOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#define MV_INCLUDE_AUDIO
+#endif
+#ifdef CONFIG_MV_INCLUDE_SDIO
+#define MV_INCLUDE_SDIO
+#endif
+#ifdef CONFIG_MTD_NAND_LNC_BOOT
+#define MTD_NAND_LNC_BOOT
+#endif
+#ifdef CONFIG_MTD_NAND_LNC
+#define MTD_NAND_LNC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+#define MTD_NAND_NFC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+#define MTD_NAND_NFC_GANG_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+#define MTD_NAND_NFC_MLC_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_NEGLECT_RNB
+#define MTD_NAND_NFC_NEGLECT_RNB
+#endif
+#ifdef CONFIG_MV_INCLUDE_PDMA
+#define MV_INCLUDE_PDMA
+#endif
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define AURORA_IO_CACHE_COHERENCY
+#endif
+
+/****************************************************************/
+/************* General configuration ****************************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Disable the DEVICE BAR in the PEX */
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* Flashes configuration ****************************/
+/****************************************************************/
+#if defined(MV_INCLUDE_SPI) && defined(MV_INCLUDE_NFC)
+#error "Wrong configuration. SPI and NAND NFC Share the same MPPs"
+#endif
+
+#if defined(MV_INCLUDE_SPI) && defined(MV_INCLUDE_LEGACY_NAND)
+#error "Wrong configuration. SPI and Legacy NAND Share the same MPPs"
+#endif
+
+#if defined(MV_INCLUDE_SPI) && defined(MV_INCLUDE_NOR)
+#error "Wrong configuration. SPI and NOR Share the same MPPs"
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND) && defined(MV_INCLUDE_NFC)
+#error "Wrong configuration. Legacy NAND and NFC NAND Share the same MPPs"
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND) && defined(MV_INCLUDE_NOR)
+#error "Wrong configuration. NOR and Legacy NAND Share the same MPPs"
+#endif
+
+#if defined(MV_INCLUDE_NFC) && defined(MV_INCLUDE_NOR)
+#error "Wrong configuration. NOR and NAND NFC Share the same MPPs"
+#endif
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+/****************************************************************/
+/************* CESA configuration ********************/
+/****************************************************************/
+
+#ifdef MV_INCLUDE_CESA
+
+#define MV_CESA_MAX_CHAN               4
+
+/* Use 2K of SRAM */
+#define MV_CESA_MAX_BUF_SIZE           1600
+
+#endif /* MV_INCLUDE_CESA */
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_LINEAR_MODE)
+ #define MV_TDM_LINEAR_MODE
+#elif defined(CONFIG_MV_TDM_ULAW_MODE)
+ #define MV_TDM_ULAW_MODE
+#endif
+
+#if defined(CONFIG_MV_TDM_5CHANNELS)
+ #define MV_TDM_5CHANNELS
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+/* We use the following registers to store DRAM interface pre configuration	*/
+/* auto-detection results							*/
+/* IMPORTANT: We are using mask register for that purpose. Before writing	*/
+/* to units mask register, make sure main maks register is set to disable	*/
+/* all interrupts.								*/
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Default FPGA Clock */
+#define MV_FPGA_CLK	25000000
+#endif /* __INCmvSysHwConfigh */
diff --git a/arch/arm/mach-armada38x/config/mvSysNfcConfig.h b/arch/arm/mach-armada38x/config/mvSysNfcConfig.h
new file mode 100644
index 0000000..a8365b64
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysNfcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_NFC_REGS_BASE		(MV_NFC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysPciConfig.h b/arch/arm/mach-armada38x/config/mvSysPciConfig.h
new file mode 100644
index 0000000..d95bfd7
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysPciConfig.h
@@ -0,0 +1,25 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PCI_IF_REGS_BASE(pciIf)		(MV_PEX_IF_REGS_OFFSET(pciIf))
diff --git a/arch/arm/mach-armada38x/config/mvSysPexConfig.h b/arch/arm/mach-armada38x/config/mvSysPexConfig.h
new file mode 100644
index 0000000..320e12c
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysPexConfig.h
@@ -0,0 +1,49 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysPciIfConfig.h - Marvell PCI / Pex units specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PEX_IF_REGS_BASE(unit)		(MV_PEX_IF_REGS_OFFSET(unit))
+
+/* PEX Work arround */
+/* the target we will use for the workarround */
+#define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
+/*a flag that indicates if we are going to use the
+size and base of the target we using for the workarround
+window */
+#define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
+/* if the above flag is 0 then the following values
+will be used for the workarround window base and size,
+otherwise the following defines will be ignored */
+#define PEX_CONFIG_RW_WA_BASE 0xF3000000
+#define PEX_CONFIG_RW_WA_SIZE _16M
diff --git a/arch/arm/mach-armada38x/config/mvSysPonConfig.h b/arch/arm/mach-armada38x/config/mvSysPonConfig.h
new file mode 100644
index 0000000..a29f56f
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysPonConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for PON registers.
+*/
+#define MV_EPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+#define MV_GPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysRtcConfig.h b/arch/arm/mach-armada38x/config/mvSysRtcConfig.h
new file mode 100644
index 0000000..d1be308
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysRtcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysRtcConfig.h - Marvell Real-Time clock unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for RTC registers.
+*/
+#define MV_RTC_REGS_BASE		(MV_RTC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysSataConfig.h b/arch/arm/mach-armada38x/config/mvSysSataConfig.h
new file mode 100644
index 0000000..b9df314
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysSataConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSataConfig.h - Marvell Sata unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SATA_REGS_BASE		(MV_SATA_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysSdmmcConfig.h b/arch/arm/mach-armada38x/config/mvSysSdmmcConfig.h
new file mode 100644
index 0000000..7e39c3b
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysSdmmcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSdmmcConfig.h - Marvell SDMMC unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for audio registers.
+*/
+#define MV_SDMMC_REGS_BASE		(MV_SDMMC_REGS_OFFSET)
diff --git a/arch/arm/mach-armada38x/config/mvSysSpiConfig.h b/arch/arm/mach-armada38x/config/mvSysSpiConfig.h
new file mode 100644
index 0000000..9901193
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysSpiConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SPI_REGS_BASE(unit)		(MV_SPI_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada38x/config/mvSysTdmConfig.h b/arch/arm/mach-armada38x/config/mvSysTdmConfig.h
new file mode 100644
index 0000000..5327557
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysTdmConfig.h
@@ -0,0 +1,63 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTdmConfig.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvOs.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_SUPPORT)
+	#define MV_TDM_SUPPORT
+	#define MV_TDM_REGS_BASE	MV_TDM_REGS_OFFSET
+#elif defined(CONFIG_MV_COMM_UNIT_SUPPORT)
+	#define MV_COMM_UNIT_SUPPORT
+	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
+#endif
+
+/* SLIC vendor */
+#if defined(CONFIG_SILABS_SLIC_SUPPORT)
+	#define SILABS_SLIC_SUPPORT
+	#if defined(CONFIG_SILABS_SLIC_3215)
+		#define SILABS_SLIC_3215
+	#elif defined(CONFIG_SILABS_SLIC_3217)
+		#define SILABS_SLIC_3217
+	#endif
+#elif defined(CONFIG_ZARLINK_SLIC_SUPPORT)
+	#define ZARLINK_SLIC_SUPPORT
+	#define SLIC_TIMER_EVENT_SUPPORT
+#else
+	#define SILABS_SLIC_3215_OLD_SUPPORT
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
diff --git a/arch/arm/mach-armada38x/config/mvSysTwsiConfig.h b/arch/arm/mach-armada38x/config/mvSysTwsiConfig.h
new file mode 100644
index 0000000..21d00cb
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysTwsiConfig.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTwsiConfig.h - Marvell TWSI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+/*
+** Base address for TWSI registers.
+*/
+#define MV_TWSI_SLAVE_REGS_BASE(unit)	(MV_TWSI_SLAVE_REGS_OFFSET(unit))
+
+/*
+** Specific definition for Main CPU interrupt cause register.
+** Needed for TWSI operation completion monitoring.
+*/
+#define MV_TWSI_CPU_MAIN_INT_CAUSE(chNum, cpu)	TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)
diff --git a/arch/arm/mach-armada38x/config/mvSysUsbConfig.h b/arch/arm/mach-armada38x/config/mvSysUsbConfig.h
new file mode 100644
index 0000000..e7b0f0c
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysUsbConfig.h
@@ -0,0 +1,24 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+#define MV_USB_REGS_BASE(unit)		MV_USB_REGS_OFFSET(unit)
+#define MV_USB3_REGS_BASE(unit)		MV_USB3_REGS_OFFSET(unit)
diff --git a/arch/arm/mach-armada38x/config/mvSysXorConfig.h b/arch/arm/mach-armada38x/config/mvSysXorConfig.h
new file mode 100644
index 0000000..ae86fc6
--- /dev/null
+++ b/arch/arm/mach-armada38x/config/mvSysXorConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysXorConfig.h - Marvell XOR unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for XOR registers.
+*/
+#define MV_XOR_REGS_BASE(unit)		(MV_XOR_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
new file mode 100644
index 0000000..831e335
--- /dev/null
+++ b/arch/arm/mach-armada38x/core.c
@@ -0,0 +1,1333 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/ata_platform.h>
+#include <linux/ethtool.h>
+#include <linux/device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/string.h>
+#include <linux/mbus.h>
+#include <linux/mv643xx_i2c.h>
+#include <asm/smp_scu.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <mach/system.h>
+
+#include <linux/tty.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <asm/serial.h>
+
+#include <mach/serial.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "cpu/mvCpu.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvSysHwConfig.h"
+
+#ifdef CONFIG_MTD_NAND_NFC
+#include "mv_mtd/nand_nfc.h"
+#endif
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+#include "sdmmc/mvSdmmc.h"
+#include <plat/mvsdio.h>
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_XOR
+#include <plat/mv_xor.h>
+#endif
+
+#ifdef CONFIG_A375_IOCC_SYNC_BARRIER_WA
+#include "xor/mvXorRegs.h"
+#endif
+
+#if defined(CONFIG_MV_ETH_NETA)
+#include <linux/mv_neta.h>
+#elif defined(CONFIG_MV_ETH_PP2)
+#include <linux/mv_pp2.h>
+#endif
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+#include "cesa/mvCesa.h"
+#endif
+
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "mvSysEthPhyApi.h"
+
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
+#include "ca9x2.h"
+#include "core.h"
+
+/* for debug putstr */
+static char arr[256];
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
+MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = { 0 };
+#endif
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)      (0x0180 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)      (0x0184 + ((n) << 3))
+#define TARGET_DDR              0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC     0x1
+
+struct mbus_dram_target_info a380_mbus_dram_info;
+
+/*******************************************************************************
+ * Early Printk Support
+ */
+#ifdef MV_INCLUDE_EARLY_PRINTK
+#define MV_UART0_LSR    (*(unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR    (*(unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0))
+/*
+ * This does not append a newline
+ */
+void putstr(const char *s)
+{
+	while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0)
+			;
+		MV_UART0_THR = *s;
+
+		if (*s == '\n') {
+			while ((MV_UART0_LSR & UART_LSR_THRE) == 0)
+				;
+			MV_UART0_THR = '\r';
+		}
+		s++;
+	}
+}
+
+void mv_early_printk(char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	vsprintf(arr, fmt, args);
+	va_end(args);
+	putstr(arr);
+}
+#endif /* MV_INCLUDE_EARLY_PRINTK */
+
+/*******************************************************************************
+ * UBoot Tagging Parameters
+ */
+#ifdef CONFIG_BE8_ON_LE
+#define read_tag(a)    le32_to_cpu(a)
+#define read_mtu(a)    le16_to_cpu(a)
+#else
+#define read_tag(a)    a
+#define read_mtu(a)    a
+#endif
+
+static int __init parse_tag_mv_uboot(const struct tag *tag)
+{
+	unsigned int mvUbootVer = 0;
+	int i = 0;
+
+	pr_info("Using UBoot passing parameters structure\n");
+	mvUbootVer = read_tag(tag->u.mv_uboot.uboot_version);
+#ifdef CONFIG_MV_INCLUDE_USB
+	mvIsUsbHost = read_tag(tag->u.mv_uboot.isUsbHost);
+#endif
+
+	mvBoardIdSet(mvBoardIdGet());
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+	for (i = 0; i < MV_UBOOT_ETH_PORTS; i++) {
+		memcpy(mvMacAddr[i], tag->u.mv_uboot.macAddr[i], 6);
+		mvMtu[i] = read_mtu(tag->u.mv_uboot.mtu[i]);
+	}
+#endif
+	return 0;
+}
+
+__tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
+
+/*******************************************************************************
+ * Command Line Parameters
+ */
+#ifdef CONFIG_SMP
+static int __init mv_rsrc_setup(char *s)
+{
+	char *rsrc = strchr(s, ' ');
+
+	/* Verify NULL termination */
+	if (rsrc)
+		(*rsrc) = '\0';
+
+	/* Parse string to table */
+	if (mvUnitMapSetup(s, strstr) == MV_FALSE)
+		pr_err("Invalid resource string %s\n", s);
+
+	/* Change to rsrc limited mode */
+	mvUnitMapSetRsrcLimited(MV_TRUE);
+
+	return 1;
+}
+
+__setup("mv_rsrc=", mv_rsrc_setup);
+#endif
+
+char *nfcConfig;
+static int __init nfcConfig_setup(char *s)
+{
+	nfcConfig = s;
+	return 1;
+}
+
+__setup("nfcConfig=", nfcConfig_setup);
+
+static void __init a380_init_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+	u8 coherency_status = 0;
+
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
+#endif
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	a380_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	addr = (void __iomem *)BRIDGE_VIRT_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+			if (base & 0xf)
+				/* BaseExtension is used (> 4GB). */
+				continue;
+			w = &a380_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->mbus_attr |= coherency_status << 4;
+			w->base = base & 0xff000000;
+			w->size = (size | 0x00ffffff) + 1;
+		}
+	}
+	a380_mbus_dram_info.num_cs = cs;
+}
+
+#ifdef CONFIG_MV_INCLUDE_CESA
+unsigned char *mv_sram_usage_get(int *sram_size_ptr)
+{
+	int used_size = 0;
+
+#if defined(CONFIG_MV_CESA)
+	used_size = sizeof(MV_CESA_SRAM_MAP);
+#endif
+
+	if (sram_size_ptr != NULL)
+		*sram_size_ptr = _8K - used_size;
+
+	return (char *)(mv_crypto_virt_base_get(0) + used_size);
+}
+#endif
+
+/*******************************************************************************
+ * I2C (TWSI)
+ */
+#ifdef CONFIG_I2C_MV64XXX
+static struct mv64xxx_i2c_pdata a380_i2c_pdata = {
+	.freq_m = 8, /* assumes 166 MHz TCLK */
+	.freq_n = 3,
+	.timeout = 1000, /* Default timeout of 1 second */
+};
+
+static struct resource a380_i2c_0_resources[] = {
+	{
+		.name = "i2c base",
+		.start = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0),
+		.end = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0) + 0x20 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = "i2c irq",
+		.start = IRQ_GLOBAL_I2C0,
+		.end = IRQ_GLOBAL_I2C0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device a380_i2c0 = {
+	.name = MV64XXX_I2C_CTLR_NAME,
+	.id = 0,
+	.num_resources = ARRAY_SIZE(a380_i2c_0_resources),
+	.resource = a380_i2c_0_resources,
+	.dev = {
+		.platform_data = &a380_i2c_pdata,
+	},
+};
+
+static struct resource a380_i2c_1_resources[] = {
+	{
+		.name = "i2c base",
+		.start = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(1),
+		.end = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(1) + 0x20 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.name = "i2c irq",
+		.start = IRQ_GLOBAL_I2C1,
+		.end = IRQ_GLOBAL_I2C1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device a380_i2c1 = {
+	.name = MV64XXX_I2C_CTLR_NAME,
+	.id = 1,
+	.num_resources = ARRAY_SIZE(a380_i2c_1_resources),
+	.resource = a380_i2c_1_resources,
+	.dev = {
+		.platform_data = &a380_i2c_pdata,
+	},
+};
+#endif
+
+static void __init a380_i2c_init(void)
+{
+#ifdef CONFIG_I2C_MV64XXX
+	if (mvUnitMapIsMine(I2C0) == MV_TRUE)
+		platform_device_register(&a380_i2c0);
+
+	if (mvCtrlSocUnitInfoNumGet(I2C_UNIT_ID) >= 1 &&
+	    mvUnitMapIsMine(I2C1) == MV_TRUE)
+		platform_device_register(&a380_i2c1);
+#endif
+}
+
+/**********
+ * UART-0 *
+ **********/
+static struct plat_serial8250_port uart0_data[] = {
+	{
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(0)),
+		.irq		= IRQ_GLOBAL_UART0,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(0) | 0x7C),
+		.type		= PORT_16550A,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource uart0_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_GLOBAL_UART0,
+		.end		= IRQ_GLOBAL_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= uart0_data,
+	},
+	.resource		= uart0_resources,
+	.num_resources		= ARRAY_SIZE(uart0_resources),
+};
+
+/**********
+ * UART-1 *
+ **********/
+static struct plat_serial8250_port uart1_data[] = {
+	{
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(1)),
+		.irq		= IRQ_GLOBAL_UART1,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(1) | 0x7C),
+		.type		= PORT_16550A,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource uart1_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_GLOBAL_UART1,
+		.end		= IRQ_GLOBAL_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device uart1 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= uart1_data,
+	},
+	.resource		= uart1_resources,
+	.num_resources		= ARRAY_SIZE(uart1_resources),
+};
+
+void __init serial_initialize(int port)
+{
+	if (port == 0) {
+		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART0);
+		}
+
+		uart0_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&uart0);
+	} else {
+		if (mvUnitMapIsMine(UART1) == MV_FALSE) {
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART1);
+		}
+
+		uart1_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&uart1);
+	}
+}
+
+
+/*******************************************************************************
+ * SDIO
+ */
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+static struct resource mvsdio_resources[] = {
+	[0] = {
+	       .start = INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET,
+	       .end = INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET + SZ_1K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_GLOBAL_SDIO,
+	       .end = IRQ_GLOBAL_SDIO,
+	       .flags = IORESOURCE_IRQ,
+	       },
+
+};
+
+static u64 mvsdio_dmamask = 0xffffffffUL;
+
+static struct mvsdio_platform_data mvsdio_data = {
+	.gpio_write_protect = 0,
+	.gpio_card_detect = 0,
+	.dram = NULL,
+};
+
+static struct platform_device mv_sdio_plat = {
+	.name = "mvsdio",
+	.id = -1,
+	.dev = {
+		.dma_mask = &mvsdio_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data = &mvsdio_data,
+		},
+	.num_resources = ARRAY_SIZE(mvsdio_resources),
+	.resource = mvsdio_resources,
+};
+#endif
+
+void __init a380_sdio_init(void)
+{
+#ifdef CONFIG_MV_INCLUDE_SDIO
+	if (mvUnitMapIsMine(SDIO) != MV_TRUE)
+		return;
+
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect =
+			    mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		}
+
+		if (mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect =
+			    mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if (MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+	}
+#endif
+}
+
+
+/*******************************************************************************
+ * USB
+ */
+
+void __init a380_usb_init(void)
+{
+#ifdef CONFIG_MV_INCLUDE_USB
+	mv_usb_init(&a380_mbus_dram_info);
+#endif
+}
+
+
+/*******************************************************************************
+ * GBE
+ */
+#ifdef CONFIG_MV_ETHERNET
+#if defined(CONFIG_MV_ETH_LEGACY)
+static struct platform_device mv88fx_eth = {
+	.name = "mv88fx_eth",
+	.id = 0,
+	.num_resources = 0,
+};
+#elif defined(CONFIG_MV_ETH_NETA)
+static struct platform_device mv88fx_neta = {
+	.name = "mv88fx_neta",
+	.id = 0,
+	.num_resources = 0,
+};
+#elif defined(CONFIG_MV_ETH_PP2)
+static void mv_pp2_giga_pdev_register(struct platform_device *pdev)
+{
+	struct mv_pp2_pdata *plat_data =
+	    (struct mv_pp2_pdata *)pdev->dev.platform_data;
+	int speed, port = pdev->id;
+
+	plat_data->max_port = mvCtrlEthMaxPortGet();
+	plat_data->tclk = mvBoardTclkGet();
+	plat_data->ctrl_model = mvCtrlModelGet();
+	plat_data->ctrl_rev = mvCtrlRevGet();
+	plat_data->cpu_mask = group_cpu_mask;
+	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->duplex = DUPLEX_FULL;
+
+	if (mvBoardIsPortLoopback(port))
+		plat_data->flags |= MV_PP2_PDATA_F_LB;
+
+	if (port < MV_UBOOT_ETH_PORTS) {
+		plat_data->mtu = mvMtu[port];
+		if (plat_data->mtu == 0) {
+			plat_data->mtu = 1500;
+			pr_err
+			    ("%s: warning - failed to use MTU from uboot env, changing to default MTU (1500).\n",
+			     __func__);
+		}
+
+		memcpy(plat_data->mac_addr, mvMacAddr[port], 6);
+	} else {
+		plat_data->mtu = 1500;
+		memset(plat_data->mac_addr, 0, 6);
+	}
+
+	speed = mvBoardMacSpeedGet(port);
+	switch (speed) {
+	case BOARD_MAC_SPEED_10M:
+		plat_data->speed = SPEED_10;
+		break;
+	case BOARD_MAC_SPEED_100M:
+		plat_data->speed = SPEED_100;
+		break;
+	case BOARD_MAC_SPEED_1000M:
+		plat_data->speed = SPEED_1000;
+		break;
+	case BOARD_MAC_SPEED_AUTO:
+	default:
+		plat_data->speed = 0;
+		break;
+	}
+
+	platform_device_register(pdev);
+}
+
+static struct resource mv_pp2_ge0_resources[] = {
+	{
+	 .start = IRQ_GLOBAL_PP_PORT0_RXTX,
+	 .end = IRQ_GLOBAL_PP_PORT0_RXTX,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct mv_pp2_pdata mv_pp2_ge0_pdata = {
+	.mtu = 1500,
+	.phy_addr = 0,
+	.flags = MV_PP2_PDATA_F_LINUX_CONNECT,
+};
+
+static struct platform_device mv_pp2_ge0_plat = {
+	.name = MV_PP2_PORT_NAME,
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mv_pp2_ge0_resources),
+	.resource = mv_pp2_ge0_resources,
+	.dev = {
+		.platform_data = &mv_pp2_ge0_pdata,
+		},
+};
+
+static struct resource mv_pp2_ge1_resources[] = {
+	{
+	 .start = IRQ_GLOBAL_PP_PORT1_RXTX,
+	 .end = IRQ_GLOBAL_PP_PORT1_RXTX,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct mv_pp2_pdata mv_pp2_ge1_pdata = {
+	.mtu = 1500,
+	.phy_addr = 0,
+	.flags = MV_PP2_PDATA_F_LINUX_CONNECT,
+};
+
+static struct platform_device mv_pp2_ge1_plat = {
+	.name = MV_PP2_PORT_NAME,
+	.id = 1,
+	.num_resources = ARRAY_SIZE(mv_pp2_ge1_resources),
+	.resource = mv_pp2_ge1_resources,
+	.dev = {
+		.platform_data = &mv_pp2_ge1_pdata,
+		},
+};
+
+static struct resource mv_pp2_ge2_resources[] = {
+	{
+	 .start = IRQ_GLOBAL_PP_PORT2_RXTX,
+	 .end = IRQ_GLOBAL_PP_PORT2_RXTX,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct mv_pp2_pdata mv_pp2_ge2_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+	.flags = MV_PP2_PDATA_F_LINUX_CONNECT,
+};
+
+static struct platform_device mv_pp2_ge2_plat = {
+	.name = MV_PP2_PORT_NAME,
+	.id = 2,
+	.num_resources = ARRAY_SIZE(mv_pp2_ge2_resources),
+	.resource = mv_pp2_ge2_resources,
+	.dev = {
+		.platform_data = &mv_pp2_ge2_pdata,
+		},
+};
+
+static struct mv_pp2_pdata mv_pp2_ge3_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+	.flags = MV_PP2_PDATA_F_LINUX_CONNECT,
+};
+
+static struct resource mv_pp2_ge3_resources[] = {
+	{
+	 .start = IRQ_GLOBAL_PP_PORT7_RXTX,
+	 .end = IRQ_GLOBAL_PP_PORT7_RXTX,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mv_pp2_ge3_plat = {
+	.name = MV_PP2_PORT_NAME,
+	.id = 3,
+	.num_resources = ARRAY_SIZE(mv_pp2_ge3_resources),
+	.resource = mv_pp2_ge3_resources,
+	.dev = {
+		.platform_data = &mv_pp2_ge3_pdata,
+		},
+};
+#else
+#error "Ethernet Mode is not defined (should be Legacy or NETA or PPv2)"
+#endif /* Ethernet mode: Legacy or NETA or PPv2 */
+
+static void __init eth_init(void)
+{
+	mv_pp2_giga_pdev_register(&mv_pp2_ge0_plat);
+#ifdef CONFIG_MV_INCLUDE_PON
+	mv_pp2_giga_pdev_register(&mv_pp2_ge3_plat);
+#endif
+}
+
+#endif /* CONFIG_MV_ETHERNET */
+
+static void a380_init_eth(void)
+{
+#ifdef CONFIG_MV_ETHERNET
+	mvSysEthPhyInit();
+	eth_init();
+#endif
+}
+
+/*******************************************************************************
+ * GPIO
+ */
+static struct platform_device mv_gpio = {
+	.name = "mv_gpio",
+	.id = 0,
+	.num_resources = 0,
+};
+
+static void __init a380_gpio_init(void)
+{
+	platform_device_register(&mv_gpio);
+}
+
+/*******************************************************************************
+ * RTC
+ */
+static struct resource rtc_resource[] = {
+	{
+	 .start = INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
+	 .end = INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
+	 .flags = IORESOURCE_MEM,
+	 }, {
+	     .start = IRQ_GLOBAL_RTC,
+	     .flags = IORESOURCE_IRQ,
+	     }
+};
+
+static void __init a380_rtc_init(void)
+{
+	platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
+}
+
+/*******************************************************************************
+ * SATA
+ */
+#ifdef CONFIG_SATA_MV
+#define SATA_PHYS_BASE (INTER_REGS_PHYS_BASE | 0xA0000)
+
+static struct mv_sata_platform_data a380_sata_data = {
+	.n_ports = 1,
+};
+
+static struct resource a380_sata_resources[] = {
+	{
+	 .name = "sata base",
+	 .start = SATA_PHYS_BASE,
+	 .end = SATA_PHYS_BASE + 0x5000 - 1,
+	 .flags = IORESOURCE_MEM,
+	 }, {
+	     .name = "sata irq",
+	     .start = IRQ_GLOBAL_SATA0,
+	     .end = IRQ_GLOBAL_SATA0,
+	     .flags = IORESOURCE_IRQ,
+	     },
+};
+
+static struct platform_device a380_sata = {
+	.name = "sata_mv",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.num_resources = ARRAY_SIZE(a380_sata_resources),
+	.resource = a380_sata_resources,
+};
+#endif
+
+static void __init a380_sata_init(struct mv_sata_platform_data *sata_data)
+{
+#ifdef CONFIG_SATA_MV
+	if (mvUnitMapIsMine(SATA) != MV_TRUE)
+		return;
+
+	a380_sata.dev.platform_data = sata_data;
+	sata_data->dram = &a380_mbus_dram_info;
+	platform_device_register(&a380_sata);
+#endif
+}
+
+/*******************************************************************************
+ * SoC hwmon Thermal Sensor
+ */
+static void __init a380_hwmon_init(void)
+{
+	if (mvUnitMapIsMine(HWMON) == MV_TRUE)
+		platform_device_register_simple("a380-temp", 0, NULL, 0);
+}
+
+/*******************************************************************************
+ * NAND controller
+ */
+#ifdef CONFIG_MTD_NAND_NFC
+static struct resource a380_nfc_resources[] = {
+	{
+	 .start = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET,
+	 .end = INTER_REGS_PHYS_BASE + MV_NFC_REGS_OFFSET + 0x400 - 1,
+	 .flags = IORESOURCE_MEM,
+	 }
+};
+
+static struct mtd_partition nand_parts_info[] = {
+	{
+	 .name = "UBoot",
+	 .offset = 0,
+	 .size = 1 * SZ_1M}, {
+			      .name = "UImage",
+			      .offset = MTDPART_OFS_APPEND,
+			      .size = 4 * SZ_1M}, {
+						   .name = "Root",
+						   .offset = MTDPART_OFS_APPEND,
+						   .size = MTDPART_SIZ_FULL},
+};
+
+static struct nfc_platform_data a380_nfc_data = {
+	.nfc_width = 8,
+	.num_devs = 1,
+	.num_cs = 1,
+	.use_dma = 0,
+	.ecc_type = MV_NFC_ECC_BCH_2K,
+	.parts = nand_parts_info,
+	.nr_parts = ARRAY_SIZE(nand_parts_info),
+};
+
+static struct platform_device a380_nfc = {
+	.name = "armada-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &a380_nfc_data,
+		},
+	.num_resources = ARRAY_SIZE(a380_nfc_resources),
+	.resource = a380_nfc_resources,
+};
+#endif
+
+static void __init a380_nand_nfc_init(void)
+{
+#ifdef CONFIG_MTD_NAND_NFC
+	if (mvUnitMapIsMine(NAND) != MV_TRUE)
+		return;
+
+	/* Check for ganaged mode */
+	if (nfcConfig) {
+		if (strncmp(nfcConfig, "ganged", 6) == 0) {
+			a380_nfc_data.nfc_width = 16;
+			a380_nfc_data.num_devs = 2;
+			nfcConfig += 7;
+		}
+
+		/* Check for ECC type directive */
+		if (strcmp(nfcConfig, "8bitecc") == 0)
+			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
+		else if (strcmp(nfcConfig, "12bitecc") == 0)
+			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
+		else if (strcmp(nfcConfig, "16bitecc") == 0)
+			a380_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
+	}
+
+	a380_nfc_data.tclk = mvBoardTclkGet();
+
+	platform_device_register(&a380_nfc);
+#endif
+}
+
+/*******************************************************************************
+ * XOR
+ */
+#ifdef CONFIG_MV_INCLUDE_XOR
+static struct mv_xor_platform_shared_data a380_xor_shared_data = {
+	.dram = &a380_mbus_dram_info,
+};
+
+static u64 a380_xor_dmamask = DMA_BIT_MASK(32);
+
+/*
+ * XOR0
+ */
+static struct resource a380_xor0_shared_resources[] = {
+	{
+	 .name = "xor 0 low",
+	 .start = XOR0_PHYS_BASE,
+	 .end = XOR0_PHYS_BASE + 0xff,
+	 .flags = IORESOURCE_MEM,
+	 }, {
+	     .name = "xor 0 high",
+	     .start = XOR0_HIGH_PHYS_BASE,
+	     .end = XOR0_HIGH_PHYS_BASE + 0xff,
+	     .flags = IORESOURCE_MEM,
+	     },
+};
+
+static struct platform_device a380_xor0_shared = {
+	.name = MV_XOR_SHARED_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &a380_xor_shared_data,
+		},
+	.num_resources = ARRAY_SIZE(a380_xor0_shared_resources),
+	.resource = a380_xor0_shared_resources,
+};
+
+static struct resource a380_xor00_resources[] = {
+	[0] = {
+	       .start = IRQ_GLOBAL_XOR0_CHAN0,
+	       .end = IRQ_GLOBAL_XOR0_CHAN0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct mv_xor_platform_data a380_xor00_data = {
+	.shared = &a380_xor0_shared,
+	.hw_id = 0,
+	.pool_size = PAGE_SIZE,
+};
+
+static struct platform_device a380_xor00_channel = {
+	.name = MV_XOR_NAME,
+	.id = 0,
+	.num_resources = ARRAY_SIZE(a380_xor00_resources),
+	.resource = a380_xor00_resources,
+	.dev = {
+		.dma_mask = &a380_xor_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &a380_xor00_data,
+		},
+};
+
+static struct resource a380_xor01_resources[] = {
+	[0] = {
+	       .start = IRQ_GLOBAL_XOR0_CHAN1,
+	       .end = IRQ_GLOBAL_XOR0_CHAN1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct mv_xor_platform_data a380_xor01_data = {
+	.shared = &a380_xor0_shared,
+	.hw_id = 1,
+	.pool_size = PAGE_SIZE,
+};
+
+static struct platform_device a380_xor01_channel = {
+	.name = MV_XOR_NAME,
+	.id = 1,
+	.num_resources = ARRAY_SIZE(a380_xor01_resources),
+	.resource = a380_xor01_resources,
+	.dev = {
+		.dma_mask = &a380_xor_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &a380_xor01_data,
+		},
+};
+
+static void __init a380_xor0_init(void)
+{
+	if (mvUnitMapIsMine(XOR0) != MV_TRUE)
+		return;
+
+	platform_device_register(&a380_xor0_shared);
+
+#ifndef CONFIG_A375_IOCC_SYNC_BARRIER_WA
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_MEMCPY, a380_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, a380_xor00_data.cap_mask);
+	platform_device_register(&a380_xor00_channel);
+
+	dma_cap_set(DMA_MEMCPY, a380_xor01_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, a380_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, a380_xor01_data.cap_mask);
+	platform_device_register(&a380_xor01_channel);
+#endif
+}
+
+/*
+ * XOR1
+ */
+static struct resource a380_xor1_shared_resources[] = {
+	{
+	 .name = "xor 1 low",
+	 .start = XOR1_PHYS_BASE,
+	 .end = XOR1_PHYS_BASE + 0xff,
+	 .flags = IORESOURCE_MEM,
+	 }, {
+	     .name = "xor 1 high",
+	     .start = XOR1_HIGH_PHYS_BASE,
+	     .end = XOR1_HIGH_PHYS_BASE + 0xff,
+	     .flags = IORESOURCE_MEM,
+	     },
+};
+
+static struct platform_device a380_xor1_shared = {
+	.name = MV_XOR_SHARED_NAME,
+	.id = 1,
+	.dev = {
+		.platform_data = &a380_xor_shared_data,
+		},
+	.num_resources = ARRAY_SIZE(a380_xor1_shared_resources),
+	.resource = a380_xor1_shared_resources,
+};
+
+static struct resource a380_xor10_resources[] = {
+	[0] = {
+	       .start = IRQ_GLOBAL_XOR1_CHAN0,
+	       .end = IRQ_GLOBAL_XOR1_CHAN0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct mv_xor_platform_data a380_xor10_data = {
+	.shared = &a380_xor1_shared,
+	.hw_id = 0,
+	.pool_size = PAGE_SIZE,
+};
+
+static struct platform_device a380_xor10_channel = {
+	.name = MV_XOR_NAME,
+	.id = 2,
+	.num_resources = ARRAY_SIZE(a380_xor10_resources),
+	.resource = a380_xor10_resources,
+	.dev = {
+		.dma_mask = &a380_xor_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &a380_xor10_data,
+		},
+};
+
+static struct resource a380_xor11_resources[] = {
+	[0] = {
+	       .start = IRQ_GLOBAL_XOR1_CHAN1,
+	       .end = IRQ_GLOBAL_XOR1_CHAN1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static struct mv_xor_platform_data a380_xor11_data = {
+	.shared = &a380_xor1_shared,
+	.hw_id = 1,
+	.pool_size = PAGE_SIZE,
+};
+
+static struct platform_device a380_xor11_channel = {
+	.name = MV_XOR_NAME,
+	.id = 3,
+	.num_resources = ARRAY_SIZE(a380_xor11_resources),
+	.resource = a380_xor11_resources,
+	.dev = {
+		.dma_mask = &a380_xor_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.platform_data = &a380_xor11_data,
+		},
+};
+
+static void __init a380_xor1_init(void)
+{
+	if (mvUnitMapIsMine(XOR1) != MV_TRUE)
+		return;
+
+	platform_device_register(&a380_xor1_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_XOR, a380_xor10_data.cap_mask);
+	platform_device_register(&a380_xor10_channel);
+
+	dma_cap_set(DMA_MEMCPY, a380_xor11_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, a380_xor11_data.cap_mask);
+	platform_device_register(&a380_xor11_channel);
+}
+#endif
+
+static void __init a380_xor_init(void)
+{
+#ifdef CONFIG_MV_INCLUDE_XOR
+	a380_xor0_init();
+	a380_xor1_init();
+#endif
+}
+
+/*******************************************************************************
+ * SPI
+ */
+static void a380_spi_init(void)
+{
+#ifdef CONFIG_MV_INCLUDE_SPI
+	/* SPI */
+	if (mvUnitMapIsMine(SPI) == MV_TRUE)
+		mvSysSpiInit(0, _16M);
+#endif
+}
+
+/*******************************************************************************
+ * Helper Routines
+ */
+
+static void print_board_info(void)
+{
+	char name_buff[50];
+
+	pr_info("\n  Marvell Armada-380");
+
+	mvBoardNameGet(name_buff, 50);
+	pr_info(" %s Board - ", name_buff);
+
+	mvCtrlModelRevNameGet(name_buff);
+	pr_info(" Soc: %s", name_buff);
+#if defined(MV_CPU_LE)
+	pr_info(" LE\n");
+#else
+	pr_info(" BE\n");
+#endif
+	pr_info("  LSP version: %s\n", LSP_VERSION);
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+	pr_info("  IOCC: Support IO coherency.\n");
+#ifdef CONFIG_A375_IOCC_SYNC_BARRIER_WA
+	pr_info("     -> Sync Barrier WA enabled\n");
+#endif
+#endif
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvUnitMapPrint();
+#endif
+	pr_info("\n");
+}
+
+/*******************************************************************************
+ * SMP WA to enable CPU1
+ * Note: This function is called before PUnit IO windows are configured.
+ */
+#if defined(CONFIG_SMP) && defined(CONFIG_A380_CPU1_ENABLE_WA)
+
+void a380_smp_cpu1_enable_wa(void)
+{
+	MV_AHB_TO_MBUS_DEC_WIN mbus_win;
+	u32 code_len, win_num, sram_phys_base = 0xFFFF0000;
+	void __iomem *sram_virt_base;
+
+	mbus_win.target			= CRYPT0_ENG;
+	mbus_win.addrWin.baseLow	= sram_phys_base;
+	mbus_win.addrWin.baseHigh	= 0x0;
+	mbus_win.addrWin.size		= SZ_64K;
+	mbus_win.enable			= MV_TRUE;
+
+	if (mvAhbToMbusWinNumByTargetGet(CRYPT0_ENG, &win_num) != MV_OK) {
+		pr_err("%s: Error: mvAhbToMbusWinNumByTargetGet(target = %d) failed\n",
+		       __func__, CRYPT0_ENG);
+		return;
+	}
+
+	if (mvAhbToMbusWinSet(win_num, &mbus_win) != MV_OK) {
+		pr_err("%s: Error: mvAhbToMbusWinSet(win_num = %d) failed\n",
+		       __func__, win_num);
+		return;
+	}
+
+	sram_virt_base = ioremap(sram_phys_base, SZ_64K);
+
+	code_len = 4 * (&a380_smp_cpu1_enable_code_end - &a380_smp_cpu1_enable_code_start);
+	memcpy(sram_virt_base, &a380_smp_cpu1_enable_code_start, code_len);
+}
+#else
+void a380_smp_cpu1_enable_wa(void)
+{
+	/* nothing */
+}
+#endif
+
+/*******************************************************************************
+ * IOCC sync implementation
+ */
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+
+#ifdef CONFIG_A375_IOCC_SYNC_BARRIER_WA
+
+/*	The A380 IOCC SYNC Barrirer WA overcomes the A380 Z1 revision sync barrier issue using the XOR engine.
+	When the dma_io_sync is called by each of the CPUs, the correct channel (CPU dependent) is activated
+	to preform a memset operation. The XOR's memset operation provides the required IO transaction that
+	guerentees that the latest data fetched from the IO is coherent.
+	The WA uses both channels of XOR engine 0.
+*/
+
+dma_addr_t dma_io_sync_buff_phys[CONFIG_NR_CPUS];
+volatile u32 *dma_io_sync_buff_virt[CONFIG_NR_CPUS];
+
+void dma_io_sync(void)
+{
+	int idx = smp_processor_id();
+	volatile u32 data;
+
+	/* Write '1' to the first word of the buffer */
+	*dma_io_sync_buff_virt[idx] = 0x1;
+
+	/* Wait untill the engine is idle */
+	while ((MV_REG_READ(XOR_ACTIVATION_REG(0, idx)) >> 4) & 0x3)
+		;
+
+	dmb();
+
+	/* Trigger channel */
+	MV_REG_WRITE((XOR_ACTIVATION_REG(0, idx)), 0x1);
+
+	/* Poll the data until it is cleard by the XOR transaction */
+	do {
+		data = *((volatile u32 *)dma_io_sync_buff_virt[idx]);
+
+	} while (data);
+
+	return;
+}
+
+static void dma_io_sync_wa_init(void)
+{
+	int i;
+
+	/* Allcate memory as XOR engine target, Use XOR unit 0 */
+	for (i = 0; i < CONFIG_NR_CPUS; i++) {
+		dma_io_sync_buff_virt[i] = kzalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!dma_io_sync_buff_virt[i]) {
+			pr_err("%s: Error - Cannot allocate memory for iocc sync WA.\n", __func__);
+			return;
+		}
+
+		dma_io_sync_buff_phys[i] = dma_map_single(NULL, (void *)dma_io_sync_buff_virt[i],
+				PAGE_SIZE, DMA_FROM_DEVICE);
+
+		/* Initialize the XOR engines. */
+		MV_REG_WRITE(XOR_CONFIG_REG(0, i), 0x444);			/* Set to memset operation */
+		MV_REG_WRITE(XOR_BLOCK_SIZE_REG(0, i), 128);			/* Set memset size */
+		MV_REG_WRITE(XOR_DST_PTR_REG(0, i) , dma_io_sync_buff_phys[i]);	/* Set buffer address */
+	}
+
+	MV_REG_WRITE(XOR_INIT_VAL_LOW_REG(0), 0x0);				/* Set initVal Low to '0' */
+	MV_REG_WRITE(XOR_INIT_VAL_HIGH_REG(0), 0x0);				/* Set initVal High to '0' */
+}
+#else
+void dma_io_sync(void)
+{
+	/* Need to implement final dma io sync for A380 */
+}
+#endif /* CONFIG_A375_IOCC_SYNC_BARRIER_WA */
+
+/*
+ * All combinations of IOCC/SMP/UP should be supported:
+ *     UP  + HWCC (Hardware Cache Coherency)
+ *     UP  + SWCC (Software Cache Coherency)
+ *     SMP + HWCC
+ *     SMP + SWCC
+ */
+static void __init a380_init_iocc(void)
+{
+
+#if !defined(CONFIG_SMP)
+	void __iomem *scu_base = (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+	scu_enable(scu_base);
+#endif
+
+	dma_io_sync_wa_init();
+
+	return;
+}
+
+#else
+void dma_io_sync(void)
+{
+	/* No IOCC is needed in SWCC mode */
+}
+#endif /* CONFIG_AURORA_IO_CACHE_COHERENCY */
+
+static void __init a380_init_l2x0_cache(void)
+{
+#ifdef CONFIG_CACHE_L2X0
+	void __iomem *l2x0_base =
+	    (void __iomem *)(INTER_REGS_VIRT_BASE + MV_CA9X2_L2CC_OFFSET);
+	l2x0_init(l2x0_base, 0x00400000, 0xfe0fffff);
+#endif
+}
+
+static void __init a380_board_init(void)
+{
+	mvBoardEnvInit();
+	if (mvCtrlEnvInit())
+		pr_err("%s: Error: ctrlEnv init failed.\n", __func__);
+
+	a380_init_cpu_mbus();
+	a380_init_l2x0_cache();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if (mvCpuIfInit(mv_sys_map())) {
+		pr_err("%s: Error: cpu memory windows init failed.\n",
+		       __func__);
+	}
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+	a380_init_iocc();
+#endif
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	mvCpuIfAddDecShow();
+	print_board_info();
+
+	a380_rtc_init();
+	a380_i2c_init();
+	a380_init_eth();
+	a380_sata_init(&a380_sata_data);
+	a380_xor_init();
+	a380_spi_init();
+	a380_sdio_init();
+	a380_nand_nfc_init();
+
+	a380_usb_init();
+#if 0
+	a380_gpio_init();
+	a380_hwmon_init();
+#endif
+}
+
+MACHINE_START(ARMADA_380, "Marvell Armada-380 Board")
+	.atag_offset = BOOT_PARAMS_OFFSET,
+	.map_io = a380_map_io,
+	.init_irq = a380_init_irq,
+	.timer = &a380_timer,
+	.init_machine = a380_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-armada38x/core.h b/arch/arm/mach-armada38x/core.h
new file mode 100644
index 0000000..18f4e7f
--- /dev/null
+++ b/arch/arm/mach-armada38x/core.h
@@ -0,0 +1,50 @@
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+#define AMBA_DEVICE(name, busid, base, plat)	\
+struct amba_device name##_device = {		\
+	.dev		= {			\
+		.coherent_dma_mask = ~0UL,	\
+		.init_name = busid,		\
+		.platform_data = plat,		\
+	},					\
+	.res		= {			\
+		.start	= base,			\
+		.end	= base + SZ_4K - 1,	\
+		.flags	= IORESOURCE_MEM,	\
+	},					\
+	.dma_mask	= ~0UL,			\
+	.irq		= IRQ_##base,		\
+	/* .dma		= DMA_##base,*/		\
+}
+
+void __init mv_usb_init(struct mbus_dram_target_info *dram);
+
+extern void a380_init_irq(void);
+extern void a380_secondary_startup(void);
+extern void __init a380_map_io(void);
+extern void __init set_core_count(unsigned int cpu_count);
+extern struct sys_timer a380_timer;
+extern unsigned int elf_hwcap;
+extern u32 mvIsUsbHost;
+extern MV_CPU_DEC_WIN *mv_sys_map(void);
+extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
+MV_STATUS mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate);
+
+#ifdef CONFIG_SMP
+extern unsigned int group_cpu_mask;
+#else
+static unsigned int group_cpu_mask = 1;
+#endif
+
+#ifdef MV_INCLUDE_EARLY_PRINTK
+extern void putstr(const char *ptr);
+#endif
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+extern u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(const char *);
+#endif
diff --git a/arch/arm/mach-armada38x/dump_cp15_regs.c b/arch/arm/mach-armada38x/dump_cp15_regs.c
new file mode 100644
index 0000000..17e3817
--- /dev/null
+++ b/arch/arm/mach-armada38x/dump_cp15_regs.c
@@ -0,0 +1,217 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+static int proc_dump_cp15_read(char *page, char **start, off_t off, int count,
+			       int *eof, void *data)
+{
+	char *p = page;
+	int len;
+	unsigned int value;
+
+	asm volatile ("mrc p15, 0, %0, c0, c0, 0" : "=r" (value));
+	p += sprintf(p, "Main ID: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c0, 1" : "=r" (value));
+	p += sprintf(p, "Cache Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile ("mrc p15, 0, %0, c0, c0, 2" : "=r" (value));
+	p += sprintf(p, "TCM Type: 0x%08x\n", value);
+#endif
+
+	asm volatile ("mrc p15, 0, %0, c0, c0, 3" : "=r" (value));
+	p += sprintf(p, "TLB Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile ("mrc p15, 0, %0, c0, c0, 5" : "=r" (value));
+	p += sprintf(p, "Microprocessor ID: 0x%08x\n", value);
+#endif
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 0" : "=r" (value));
+	p += sprintf(p, "Processor Feature 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 1" : "=r" (value));
+	p += sprintf(p, "Processor Feature 1: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 2" : "=r" (value));
+	p += sprintf(p, "Debug Feature 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 3" : "=r" (value));
+	p += sprintf(p, "Auxiliary Feature 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 4" : "=r" (value));
+	p += sprintf(p, "Memory Model Feature 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 5" : "=r" (value));
+	p += sprintf(p, "Memory Model Feature 1: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 6" : "=r" (value));
+	p += sprintf(p, "Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c1, 7" : "=r" (value));
+	p += sprintf(p, "Memory Model Feature 3: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 0" : "=r" (value));
+	p += sprintf(p, "Set Attribute 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 1" : "=r" (value));
+	p += sprintf(p, "Set Attribute 1: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 2" : "=r" (value));
+	p += sprintf(p, "Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 3" : "=r" (value));
+	p += sprintf(p, "Set Attribute 3: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 4" : "=r" (value));
+	p += sprintf(p, "Set Attribute 4: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c0, c2, 5" : "=r" (value));
+	p += sprintf(p, "Set Attribute 5: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (value));
+	p += sprintf(p, "Current Cache Size ID: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c0, c0, 1" : "=r" (value));
+	p += sprintf(p, "Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c0, c0, 7" : "=r" (value));
+	p += sprintf(p, "Silicon ID: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 2, %0, c0, c0, 0" : "=r" (value));
+	p += sprintf(p, "Cache Size Selection: 0x%08x\n", value);
+#endif
+	asm volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r" (value));
+	p += sprintf(p, "Control : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r" (value));
+	p += sprintf(p, "Auxiliary Control : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c1, c0, 2" : "=r" (value));
+	p += sprintf(p, "Coprocessor Access Control : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c1, c1, 0" : "=r" (value));
+	p += sprintf(p, "Secure Configuration : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r" (value));
+	p += sprintf(p, "Translation Table Base 0 : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c2, c0, 1" : "=r" (value));
+	p += sprintf(p, "Translation Table Base 1 : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c2, c0, 2" : "=r" (value));
+	p += sprintf(p, "Translation Table Control : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c3, c0, 0" : "=r" (value));
+	p += sprintf(p, "Domain Access Control : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c5, c0, 0" : "=r" (value));
+	p += sprintf(p, "Data Fault Status : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c5, c0, 1" : "=r" (value));
+	p += sprintf(p, "Instruction Fault Status : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c6, c0, 0" : "=r" (value));
+	p += sprintf(p, "Data Fault Address : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c6, c0, 1" : "=r" (value));
+	p += sprintf(p, "Watchpoint Fault Address : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c6, c0, 2" : "=r" (value));
+	p += sprintf(p, "Instruction Fault Address : 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c7, c10, 6" : "=r" (value));
+	p += sprintf(p, "Cache Dirty Status: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 0: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 1: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (value));
+	p += sprintf(p, "Control Configuration: 0x%08x\n", value);
+	p += sprintf(p, "    Write Buffer Coalescing\t: %s\n",
+		     (value & (1 << 8)) ? "Enabled" : "Disabled");
+	if (value & (1 << 8))
+		p += sprintf(p, "    WB WAIT CYC\t: 0x%x\n",
+			     (value >> 9) & 0x7);
+
+	p += sprintf(p, "    Coprocessor dual issue \t: %s\n",
+		     (value & (1 << 15)) ? "Disabled" : "Enabled");
+
+	p += sprintf(p, "    L2 write allocate\t: %s\n", (value & (1 << 28)) ?
+		     "Enabled" : "Disabled");
+
+	p += sprintf(p, "    Streaming\t: %s\n", (value & (1 << 29)) ?
+		     "Enabled" : "Disabled");
+
+	asm volatile ("mrc p15, 1, %0, c15, c12, 0" : "=r" (value));
+	p += sprintf(p, "CPU ID Code Extension: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c9, c14, 0" : "=r" (value));
+	p += sprintf(p, "User mode access for PMC registers: %s\n",
+		     (value & 1) ? "Enabled" : "Disabled");
+	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r" (value));
+	p += sprintf(p, "Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 0, %0, c10, c2, 1" : "=r" (value));
+	p += sprintf(p, "Memory Attribute NMRR: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c1, 2" : "=r" (value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 2: 0x%08x\n", value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c2, 0" : "=r" (value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 0: 0x%08x\n",
+		     value);
+
+	asm volatile ("mrc p15, 1, %0, c15, c2, 1" : "=r" (value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 1: 0x%08x\n",
+		     value);
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+int dump_init_module(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	res = create_proc_entry("mv_dump_cp15", S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+	res->read_proc = proc_dump_cp15_read;
+#endif
+
+	return 0;
+}
+
+void dump_cleanup_module(void)
+{
+	remove_proc_entry("mv_dump_cp15", NULL);
+}
+
+module_init(dump_init_module);
+module_exit(dump_cleanup_module);
+
+MODULE_AUTHOR("Saeed Bishara");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-armada38x/export.c b/arch/arm/mach-armada38x/export.c
new file mode 100644
index 0000000..e20b567
--- /dev/null
+++ b/arch/arm/mach-armada38x/export.c
@@ -0,0 +1,212 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvOs.h"
+
+/*************************************************************************************************************
+ * Environment
+ *************************************************************************************************************/
+EXPORT_SYMBOL(mv_early_printk);
+EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlModelRevGet);
+EXPORT_SYMBOL(mvCtrlModelGet);
+EXPORT_SYMBOL(mvOsIoUncachedMalloc);
+EXPORT_SYMBOL(mvOsIoUncachedFree);
+EXPORT_SYMBOL(mvOsIoCachedMalloc);
+EXPORT_SYMBOL(mvOsIoCachedFree);
+EXPORT_SYMBOL(mvDebugMemDump);
+EXPORT_SYMBOL(mvHexToBin);
+EXPORT_SYMBOL(mvBinToHex);
+EXPORT_SYMBOL(mvSizePrint);
+EXPORT_SYMBOL(mvDebugPrintMacAddr);
+EXPORT_SYMBOL(mvCtrlEthMaxPortGet);
+EXPORT_SYMBOL(mvCtrlTargetNameGet);
+EXPORT_SYMBOL(mvBoardIdGet);
+EXPORT_SYMBOL(mvBoardPhyAddrGet);
+EXPORT_SYMBOL(mvCpuIfTargetWinGet);
+EXPORT_SYMBOL(mvMacStrToHex);
+EXPORT_SYMBOL(mvBoardTclkGet);
+EXPORT_SYMBOL(mvBoardSysClkGet);
+EXPORT_SYMBOL(mvBoardMacSpeedGet);
+EXPORT_SYMBOL(mvWinOverlapTest);
+EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
+EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
+EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
+EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+
+#ifdef CONFIG_MV_INCLUDE_SPI
+#include "spi/mvSpiCmnd.h"
+EXPORT_SYMBOL(mvSpiWriteThenWrite);
+EXPORT_SYMBOL(mvSpiWriteThenRead);
+#include "spi/mvSpi.h"
+EXPORT_SYMBOL(mvSpiParamsSet);
+#endif
+#include "gpp/mvGpp.h"
+EXPORT_SYMBOL(mvGppValueSet);
+
+/*************************************************************************************************************
+ * TDM
+ *************************************************************************************************************/
+#if defined(MV_INCLUDE_TDM)
+EXPORT_SYMBOL(mvCtrlTdmUnitIrqGet);
+EXPORT_SYMBOL(mvCtrlTdmUnitTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * Audio
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#include "audio/mvAudio.h"
+#include "mvSysAudioApi.h"
+EXPORT_SYMBOL(mvSPDIFRecordTclockSet);
+EXPORT_SYMBOL(mvSPDIFPlaybackCtrlSet);
+EXPORT_SYMBOL(mvI2SPlaybackCtrlSet);
+EXPORT_SYMBOL(mvAudioPlaybackControlSet);
+EXPORT_SYMBOL(mvAudioDCOCtrlSet);
+EXPORT_SYMBOL(mvI2SRecordCntrlSet);
+EXPORT_SYMBOL(mvAudioRecordControlSet);
+EXPORT_SYMBOL(mvSysAudioInit);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrGet);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * USB
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+extern u32 mvIsUsbHost;
+
+#include "usb/mvUsb.h"
+EXPORT_SYMBOL(mvIsUsbHost);
+EXPORT_SYMBOL(mvCtrlUsbMaxGet);
+EXPORT_SYMBOL(mvUsbGetCapRegAddr);
+#ifdef MV_USB_VOLTAGE_FIX
+EXPORT_SYMBOL(mvUsbGppInit);
+EXPORT_SYMBOL(mvUsbBackVoltageUpdate);
+#endif
+#endif
+
+/*************************************************************************************************************
+ * CESA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+#include "mvSysCesaApi.h"
+#include "cesa/mvCesa.h"
+#include "cesa/mvMD5.h"
+#include "cesa/mvSHA1.h"
+extern unsigned char *mv_sram_usage_get(int *sram_size_ptr);
+
+EXPORT_SYMBOL(mvSysCesaInit);
+EXPORT_SYMBOL(mvCesaSessionOpen);
+EXPORT_SYMBOL(mvCesaSessionClose);
+EXPORT_SYMBOL(mvCesaAction);
+EXPORT_SYMBOL(mvCesaReadyGet);
+EXPORT_SYMBOL(mvCesaCopyFromMbuf);
+EXPORT_SYMBOL(mvCesaCopyToMbuf);
+EXPORT_SYMBOL(mvCesaMbufCopy);
+EXPORT_SYMBOL(mvCesaCryptoIvSet);
+EXPORT_SYMBOL(mvMD5);
+EXPORT_SYMBOL(mvSHA1);
+
+EXPORT_SYMBOL(mvCesaDebugQueue);
+EXPORT_SYMBOL(mvCesaDebugSram);
+EXPORT_SYMBOL(mvCesaDebugSAD);
+EXPORT_SYMBOL(mvCesaDebugStatus);
+EXPORT_SYMBOL(mvCesaDebugMbuf);
+EXPORT_SYMBOL(mvCesaDebugSA);
+EXPORT_SYMBOL(mv_sram_usage_get);
+
+extern u32 mv_crypto_virt_base_get(void);
+extern u32 mv_crypto_phys_base_get(void);
+EXPORT_SYMBOL(mv_crypto_virt_base_get);
+EXPORT_SYMBOL(mv_crypto_phys_base_get);
+EXPORT_SYMBOL(cesaReqResources);
+EXPORT_SYMBOL(mvCesaFinish);
+
+#endif
+
+/*************************************************************************************************************
+ * Flashes
+ *************************************************************************************************************/
+#if defined(CONFIG_MV_INCLUDE_SPI)
+#include <sflash/mvSFlash.h>
+#include <sflash/mvSFlashSpec.h>
+EXPORT_SYMBOL(mvSFlashInit);
+EXPORT_SYMBOL(mvSFlashSectorErase);
+EXPORT_SYMBOL(mvSFlashChipErase);
+EXPORT_SYMBOL(mvSFlashBlockRd);
+EXPORT_SYMBOL(mvSFlashBlockWr);
+EXPORT_SYMBOL(mvSFlashIdGet);
+EXPORT_SYMBOL(mvSFlashWpRegionSet);
+EXPORT_SYMBOL(mvSFlashWpRegionGet);
+EXPORT_SYMBOL(mvSFlashStatRegLock);
+EXPORT_SYMBOL(mvSFlashSizeGet);
+EXPORT_SYMBOL(mvSFlashPowerSaveEnter);
+EXPORT_SYMBOL(mvSFlashPowerSaveExit);
+EXPORT_SYMBOL(mvSFlashModelGet);
+#endif
+
+/*************************************************************************************************************
+ * SATA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#include <sata/CoreDriver/mvSata.h>
+EXPORT_SYMBOL(mvSataWinInit);
+#endif
+
+/*************************************************************************************************************
+ * DMA/XOR
+ *************************************************************************************************************/
+#if defined(CONFIG_MV_XOR_MEMCOPY) || defined(CONFIG_MV_IDMA_MEMCOPY)
+EXPORT_SYMBOL(asm_memcpy);
+#endif
+
+#ifdef CONFIG_MV_SP_I_FTCH_DB_INV
+EXPORT_SYMBOL(mv_l2_inv_range);
+#endif
+
+/*************************************************************************************************************
+ * Marvell TRACE
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_DBG_TRACE
+#include "dbg-trace.h"
+EXPORT_SYMBOL(TRC_INIT);
+EXPORT_SYMBOL(TRC_REC);
+EXPORT_SYMBOL(TRC_OUTPUT);
+EXPORT_SYMBOL(TRC_START);
+EXPORT_SYMBOL(TRC_RELEASE);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_MODULE
+#ifdef CONFIG_MV_ETH_BM
+#include "bm/mvBm.h"
+EXPORT_SYMBOL(mvBmVirtBase);
+#endif
+#include "mvList.h"
+EXPORT_SYMBOL(mvListCreate);
+EXPORT_SYMBOL(mvListDestroy);
+#endif
diff --git a/arch/arm/mach-armada38x/flashmap.c b/arch/arm/mach-armada38x/flashmap.c
new file mode 100644
index 0000000..550e5b0
--- /dev/null
+++ b/arch/arm/mach-armada38x/flashmap.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <drivers/mtd/mtdcore.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+#define MTD_FLASH_MAP_DEBUG
+
+#ifdef MTD_FLASH_MAP_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+#define MTD_MAX_FLASH_NUMBER	4
+#define MTD_DUMMY_BANK_WIDTH	2
+
+struct maps_init_info {
+	struct map_info mapInfo;
+	char **mtdDrv;
+	struct mtd_info *mtdInfo;
+	char name[32];
+};
+
+static struct maps_init_info maps[MTD_MAX_FLASH_NUMBER];
+static unsigned int mapsNum;
+
+#if defined(CONFIG_MTD_CFI) || defined(CONFIG_MTD_JEDECPROBE)
+static char *cfiDev = "cfi_flash";
+static char *cfiMtdList[] = { "cfi_probe", NULL };
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+static char *sflashDev = "spi_flash";
+static char *sflashMtdList[] = { "sflash", NULL };
+#endif
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static struct mtd_partition *mtd_parts;
+static int mtd_parts_nb;
+static const char *part_probes[] __initdata = { "cmdlinepart", NULL };
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+static int flashInfoFill(void)
+{
+	int expectedDevs = 0;
+	int devs, i;
+
+	/* clear the whole array */
+	memset((void *)maps, 0x0, sizeof(maps));
+
+#if defined(CONFIG_MTD_CFI) || defined(CONFIG_MTD_JEDECPROBE)
+	/* gather the CFI and JEDEC NOR flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_NOR_FLASH);
+
+	for (i = 0; i < devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE
+			       "\nERROR: %s - Exceeded MAX MTD flash devices number",
+			       __func__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = cfiMtdList;
+		sprintf(maps[expectedDevs].name, "%s_%d", cfiDev, i);
+		maps[expectedDevs].mapInfo.name = maps[expectedDevs].name;
+		maps[expectedDevs].mapInfo.phys =
+		    mvBoardGetDeviceBaseAddr(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.size =
+		    mvBoardGetDeviceWinSize(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth =
+		    (mvBoardGetDeviceBusWidth(i, BOARD_DEV_NOR_FLASH) / 8);
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk
+			   ("\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d",
+			    maps[expectedDevs].mapInfo.name, i,
+			    (unsigned int)maps[expectedDevs].mapInfo.phys,
+			    (unsigned int)maps[expectedDevs].mapInfo.size,
+			    maps[expectedDevs].mapInfo.bankwidth));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE
+			       "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+			       __func__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+	/* gather the SPI flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_SPI_FLASH);
+
+	for (i = 0; i < devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE
+			       "\nERROR: %s - Exceeded MAX MTD flash devices number",
+			       __func__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = sflashMtdList;
+		maps[expectedDevs].mapInfo.name = sflashDev;
+		maps[expectedDevs].mapInfo.phys =
+		    mvBoardGetDeviceBaseAddr(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.size =
+		    mvBoardGetDeviceWinSize(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = MTD_DUMMY_BANK_WIDTH;
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk
+			   ("\nINFO: Found %s %d - base 0x%08x, size 0x%x",
+			    maps[expectedDevs].mapInfo.name, i,
+			    (unsigned int)maps[expectedDevs].mapInfo.phys,
+			    (unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE
+			       "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+			       __func__, maps[expectedDevs].mapInfo.name,
+			       i);
+		}
+	}
+#endif
+
+	DB(printk
+	   ("\nINFO: %s - Found %d Flash Devices", __func__, expectedDevs));
+	return expectedDevs;
+}
+
+static int __init flashProbe(char **mtdDrv, struct map_info *map,
+			     struct mtd_info **mtd)
+{
+	if ((mtdDrv == NULL) || (map == NULL) || (mtd == NULL)) {
+		printk(KERN_NOTICE
+		       "\nERROR: NULL pointer parameter at %s entry",
+		       __func__);
+		return -EINVAL;
+	}
+
+	/* remap the physical address to a virtual address */
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt) {
+		printk(KERN_NOTICE
+		       "\nERROR: Failed to ioremap Flash device at physical base 0x%x.",
+		       (unsigned int)map->phys);
+		return -EIO;
+	}
+
+	DB(printk
+	   ("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+	    (unsigned int)map->phys, (unsigned int)map->virt));
+
+	simple_map_init(map);
+
+	*mtd = NULL;
+	for (; (!(*mtd) && *mtdDrv); mtdDrv++) {
+		DB(printk
+		   ("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+		    *mtdDrv, map->name, (unsigned int)map->phys,
+		    (unsigned int)map->size, map->bankwidth));
+		*mtd = do_map_probe(*mtdDrv, map);
+		if (*mtd) {
+			DB(printk(" - detected OK"));
+			/*map->size = (*mtd)->size; */
+			(*mtd)->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+			mtd_parts_nb =
+			    parse_mtd_partitions(*mtd, part_probes, &mtd_parts,
+						 0);
+
+			if (mtd_parts_nb > 0) {
+				add_mtd_partitions(*mtd, mtd_parts,
+						   mtd_parts_nb);
+				return 0;
+			}
+#endif
+
+			if (/*add_mtd_device(*mtd) != 0 */
+			    mtd_device_register(*mtd, NULL, 0)) {
+				printk(KERN_NOTICE
+				       "\nERROR: %s - Failed to add the mtd device",
+				       __func__);
+				iounmap((void *)map->virt);
+				map->virt = 0;
+				return -ENXIO;
+			}
+
+			return 0;
+		} else {
+			DB(printk(" - Not detected"));
+		}
+	}
+
+	iounmap((void *)map->virt);
+	map->virt = 0;
+	return -ENXIO;
+}
+
+static int __init flash_map_init(void)
+{
+	int i;
+
+	if (mvUnitMapIsMine(SPI) == MV_FALSE)
+		return 0;
+
+	mapsNum = flashInfoFill();
+	DB(printk(KERN_INFO "\nINFO: flash_map_init - detected %d devices\n", mapsNum));
+
+	for (i = 0; i < mapsNum; i++) {
+		DB(printk
+		   ("MTD: Initialize the %s device at address 0x%08x\n",
+		    maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
+		if (flashProbe
+		    (maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0) {
+			DB(printk(KERN_INFO " - OK.\n"));
+		} else {
+			maps[i].mtdInfo = NULL;
+			DB(printk(KERN_INFO " - FAILED!\n"));
+		}
+	}
+
+	return 0;
+}
+
+static void __exit flash_map_exit(void)
+{
+	int i;
+
+	for (i = 0; i < mapsNum; i++) {
+		if (maps[i].mtdInfo) {
+			/* del_mtd_device(maps[i].mtdInfo); */
+			mtd_device_unregister(maps[i].mtdInfo);
+			map_destroy(maps[i].mtdInfo);
+		}
+
+		if (maps[i].mapInfo.virt) {
+			iounmap((void *)maps[i].mapInfo.virt);
+			maps[i].mapInfo.virt = 0;
+		}
+	}
+}
+
+module_init(flash_map_init);
+module_exit(flash_map_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for Marvell platforms");
diff --git a/arch/arm/mach-armada38x/headsmp.S b/arch/arm/mach-armada38x/headsmp.S
new file mode 100644
index 0000000..4d910b6
--- /dev/null
+++ b/arch/arm/mach-armada38x/headsmp.S
@@ -0,0 +1,90 @@
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+#ifdef CONFIG_A380_CPU1_ENABLE_WA
+
+#define CPU_RESUME_ADDR_REG 0xf10182d4
+
+.global a380_smp_cpu1_enable_code_start
+.global a380_smp_cpu1_enable_code_end
+
+ENTRY(a380_smp_cpu1_enable_code_start)
+a380_smp_cpu1_enable_code_start:
+	ldr	r0, [pc, #4]
+	ldr	r1, [r0]
+	mov	pc, r1
+	.word	CPU_RESUME_ADDR_REG
+a380_smp_cpu1_enable_code_end:
+ENDPROC(a380_smp_cpu1_enable_code_end)
+
+#endif /* CONFIG_A380_CPU1_ENABLE_WA */
+
+/*
+ *   The secondary kernel init calls v7_flush_dcache_all before it enables
+ *   the L1; however, the L1 comes out of reset in an undefined state, so
+ *   the clean + invalidate performed by v7_flush_dcache_all causes a bunch
+ *   of cache lines with uninitialized data and uninitialized tags to get
+ *   written out to memory, which does really unpleasant things to the main
+ *   processor.  We fix this by performing an invalidate, rather than a
+ *   clean + invalidate, before jumping into the kernel.
+ */
+ENTRY(v7_invalidate_l1)
+        mov     r0, #0
+        mcr     p15, 2, r0, c0, c0, 0
+        mrc     p15, 1, r0, c0, c0, 0
+
+        ldr     r1, =0x7fff
+        and     r2, r1, r0, lsr #13
+
+        ldr     r1, =0x3ff
+
+        and     r3, r1, r0, lsr #3  @ NumWays - 1
+        add     r2, r2, #1          @ NumSets
+
+        and     r0, r0, #0x7
+        add     r0, r0, #4          @ SetShift
+
+        clz     r1, r3              @ WayShift
+        add     r4, r3, #1          @ NumWays
+1:      sub     r2, r2, #1          @ NumSets--
+        mov     r3, r4              @ Temp = NumWays
+2:      subs    r3, r3, #1          @ Temp--
+        mov     r5, r3, lsl r1
+        mov     r6, r2, lsl r0
+        orr     r5, r5, r6          @ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+        mcr     p15, 0, r5, c7, c6, 2
+        bgt     2b
+        cmp     r2, #0
+        bgt     1b
+        dsb
+        isb
+        mov     pc, lr
+ENDPROC(v7_invalidate_l1)
+
+/*
+ * This provides a "holding pen" into which all secondary cores are held
+ * until we're ready for them to initialise.
+ */
+ENTRY(a380_secondary_startup)
+	bl      v7_invalidate_l1
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+	.align
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-armada38x/hwmon.c b/arch/arm/mach-armada38x/hwmon.c
new file mode 100644
index 0000000..c843b15
--- /dev/null
+++ b/arch/arm/mach-armada38x/hwmon.c
@@ -0,0 +1,392 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG				0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+
+#define A380_OVERHEAT_TEMP	105	/* milidegree Celsius */
+#define A380_OVERHEAT_DELAY	0x700
+#define A380_OVERCOOL_TEMP	10	/* milidegree Celsius */
+#define	A380_OVERCOOL_DELAY	0x700
+#define A380_OVERHEAT_MIN	0
+#define A380_OVERHEAT_MAX	110000
+#define A380_OVERCOOL_MIN	0
+#define A380_OVERCOOL_MAX	110000
+#define PMU_THERMAL_MNGR_REG	0x184c4
+#define	PMU_INT_MASK_REG        0x1C124
+#define	PMU_INT_CAUSE_REG	0x1c120
+#define PMU_INT_OVRHEAT_MASK	0x1
+#define PMU_INT_COOLING_MASK	0x2
+
+#define PMU_TM_COOL_THRSH_OFFS          10
+#define PMU_TM_COOL_THRSH_MASK          (0x1FF << PMU_TM_COOL_THRSH_OFFS)
+#define PMU_TM_OVRHEAT_THRSH_OFFS       19
+#define PMU_TM_OVRHEAT_THRSH_MASK       (0x1FF << PMU_TM_OVRHEAT_THRSH_OFFS)
+
+#define PMU_TM_DISABLE_OFFS             0
+#define PMU_TM_DISABLE_MASK             (0x1 << PMU_TM_DISABLE_OFFS)
+
+#define	PMU_TM_OVRHEAT_DLY_REG  0x184cc
+#define	PMU_TM_COOLING_DLY_REG	0x184c8
+
+/* Junction Temperature */
+#define A380_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define A380_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+
+#define LABEL "T-junction"
+static struct device *hwmon_dev;
+unsigned int temp_min = A380_OVERCOOL_TEMP;
+unsigned int temp_max = A380_OVERHEAT_TEMP;
+
+typedef enum {
+	SHOW_TEMP,
+	TEMP_MAX,
+	TEMP_MIN,
+	SHOW_NAME,
+	SHOW_TYPE,
+	SHOW_LABEL
+} SHOW;
+
+static void a380_temp_set_thresholds(unsigned int max, unsigned int min)
+{
+	u32 temp, reg;
+
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_DISABLE_MASK;
+	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the overheat threashold & delay */
+	temp = A380_TSEN_TEMP2RAW(max);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
+	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
+	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the cool threshole & delay */
+	temp = A380_TSEN_TEMP2RAW(min);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_COOL_THRSH_MASK;
+	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
+	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
+}
+
+static int a380_temp_init_sensor(void)
+{
+	u32 reg;
+
+	/* init the TSEN sensor once */
+	/* Enable On-The-Fly Calibration mode */
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_OTF_CALIB_MASK;
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
+
+	/* Set the Reference Count value */
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_REF_CAL_MASK);
+	reg |= (0xf1 << 11);
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
+
+	/* Do not start calibration sequence */
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_START_CALIB_MASK);
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
+
+	/* Initiate Soft Reset
+	   reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
+	   reg |= TSEN_CONF_SOFT_RESET_MASK;
+	   writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
+	 */
+	/* udelay(1000); */
+
+	/* Exit from Soft Reset
+	   reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
+	   reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
+	   writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
+	 */
+	/* udelay(10000); */
+
+	/* Set thresholds */
+	a380_temp_set_thresholds(temp_max, temp_min);
+
+	/* Set delays */
+	writel(A380_OVERHEAT_DELAY,
+	       (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(A380_OVERCOOL_DELAY,
+	       (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK),
+	       (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
+
+	return 0;
+}
+
+static int a380_temp_read_temp(void)
+{
+	int reg;
+
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+	return A380_TSEN_RAW2TEMP(reg);
+}
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			 *devattr, char *buf)
+{
+	return sprintf(buf, "%s\n", "a380-hwmon");
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	int alarm = 0;
+	u32 reg;
+
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG);
+	if (reg & PMU_INT_OVRHEAT_MASK) {
+		alarm = 1;
+		writel((reg & ~PMU_INT_OVRHEAT_MASK),
+		       (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	} else if (reg & PMU_INT_COOLING_MASK) {
+		alarm = 2;
+		writel((reg & ~PMU_INT_COOLING_MASK),
+		       (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	}
+
+	return sprintf(buf, "%d\n", alarm);
+}
+
+static ssize_t show_info(struct device *dev,
+			 struct device_attribute *devattr, char *buf)
+{
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TYPE)
+		ret = sprintf(buf, "%d\n", 3);
+	else if (attr->index == SHOW_LABEL)
+		ret = sprintf(buf, "%s\n", LABEL);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+	return ret;
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf)
+{
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TEMP)
+		ret = sprintf(buf, "%d\n", a380_temp_read_temp());
+	else if (attr->index == TEMP_MAX)
+		ret = sprintf(buf, "%d\n", temp_max);
+	else if (attr->index == TEMP_MIN)
+		ret = sprintf(buf, "%d\n", temp_min);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+
+	return ret;
+}
+
+static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
+			const char *buf, size_t count)
+{
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	unsigned int temp;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		printk(KERN_WARNING "Invalid input string for temperature!");
+
+	if (attr->index == TEMP_MAX) {
+		if ((temp < A380_OVERHEAT_MIN) || (temp > A380_OVERHEAT_MAX))
+			printk(KERN_WARNING
+			       "Invalid max temperature input (out of range: %d-%d)!",
+			       A380_OVERHEAT_MIN, A380_OVERHEAT_MAX);
+		else {
+			temp_max = temp;
+			a380_temp_set_thresholds(temp_max, temp_min);
+		}
+	} else if (attr->index == TEMP_MIN) {
+		if ((temp < A380_OVERCOOL_MIN) || (temp > A380_OVERCOOL_MAX))
+			printk(KERN_WARNING
+			       "Invalid min temperature input (out of range: %d-%d)!",
+			       A380_OVERCOOL_MIN, A380_OVERCOOL_MAX);
+		else {
+			temp_min = temp;
+			a380_temp_set_thresholds(temp_max, temp_min);
+		}
+	} else
+		printk(KERN_ERR "a380-temp: Invalid sensor attribute!");
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK),
+	       (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_INFO "set_temp got string: %d\n", temp);
+	return count;
+}
+
+static irqreturn_t a380_temp_irq_handler(int irq, void *data)
+{
+	u32 val, mask;
+	mask = readl(INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG);
+	val = (readl(INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG) & mask);
+	/* Mask cooling/overheat interrupt */
+	writel((mask & ~val), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
+	       ((val & PMU_INT_OVRHEAT_MASK) ? "overheat" : "cooling"));
+
+	if (val & PMU_INT_OVRHEAT_MASK)
+		val &= ~PMU_INT_OVRHEAT_MASK;
+	else if (val & PMU_INT_COOLING_MASK)
+		val &= ~PMU_INT_COOLING_MASK;
+
+	/* Clear cooling/overheat interrupt */
+	writel(val, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+
+	return IRQ_HANDLED;
+}
+
+/* TODO - Add read/write support in order to support setting max/min */
+static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL, SHOW_TYPE);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_info, NULL, SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL, SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IRWXUGO, show_temp, set_temp, TEMP_MAX);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp, TEMP_MIN);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *a380_temp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group a380_temp_group = {
+	.attrs = a380_temp_attributes,
+};
+
+static int __devinit a380_temp_probe(struct platform_device *pdev)
+{
+	int err, irq;
+
+	err = a380_temp_init_sensor();
+	if (err)
+		goto exit;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &a380_temp_group);
+	if (err)
+		goto exit;
+
+	hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon_dev)) {
+		dev_err(&pdev->dev, "Class registration failed (%d)\n", err);
+		goto exit;
+	}
+
+	/* Register cooling/overheat interrupt */
+	irq = IRQ_AURORA_PMU;
+	err = request_irq(irq, a380_temp_irq_handler, IRQF_DISABLED,
+			  "a380-temp", NULL);
+	if (err)
+		printk(KERN_INFO "unable to request IRQ%d for a380-temp\n",
+		       irq);
+	printk(KERN_INFO "Armada 380 hwmon thermal sensor initialized.\n");
+
+	return 0;
+exit:
+	sysfs_remove_group(&pdev->dev.kobj, &a380_temp_group);
+	return err;
+}
+
+static int __devexit a380_temp_remove(struct platform_device *pdev)
+{
+	struct a380_temp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(hwmon_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &a380_temp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static int a380_temp_resume(struct platform_device *dev)
+{
+	return a380_temp_init_sensor();
+}
+
+static struct platform_driver a380_temp_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "a380-temp",
+		   },
+	.probe = a380_temp_probe,
+	.remove = __devexit_p(a380_temp_remove),
+	.resume = a380_temp_resume,
+};
+
+static int __init a380_temp_init(void)
+{
+	return platform_driver_register(&a380_temp_driver);
+}
+
+static void __exit a380_temp_exit(void)
+{
+	platform_driver_unregister(&a380_temp_driver);
+}
+
+MODULE_AUTHOR("Marvell Semiconductors");
+MODULE_DESCRIPTION("Marvell Armada 380 LP SoC hwmon driver");
+MODULE_LICENSE("GPL");
+
+module_init(a380_temp_init)
+module_exit(a380_temp_exit)
diff --git a/arch/arm/mach-armada38x/include/mach/armada380.h b/arch/arm/mach-armada38x/include/mach/armada380.h
new file mode 100644
index 0000000..ab86f0b
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/armada380.h
@@ -0,0 +1,141 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_AURORA_H
+#define __ASM_ARCH_AURORA_H
+
+/*
+ * The base address of memory that should be reserved for IO windows.
+ * The reserved end address is 0xFFFFFFFF.
+ */
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE			0x00000000
+#define SDRAM_CS0_SIZE			_256M
+#define SDRAM_CS1_BASE			0x10000000
+#define SDRAM_CS1_SIZE			_256M
+#define SDRAM_CS2_BASE			0x20000000
+#define SDRAM_CS2_SIZE			_256M
+#define SDRAM_CS3_BASE			0x30000000
+#define SDRAM_CS3_SIZE			_256M
+
+/*
+ * Physical address map
+ */
+#define INTER_REGS_PHYS_BASE		0xF1000000
+
+#define PEX0_MEM_PHYS_BASE		0xE0000000
+#define PEX0_MEM_SIZE			_32M
+#define PEX1_MEM_PHYS_BASE		0xE2000000
+#define PEX1_MEM_SIZE			_32M
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_SIZE			_1M
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_SIZE			_16M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_SIZE		_32M
+
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_SIZE			_64K
+
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60A00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+
+#define PP2_CPU0_PHYS_BASE		0xF4500000
+#define PP2_CPU1_PHYS_BASE		0xF4510000
+#define PP2_SIZE			_64K
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_SIZE			_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_SIZE		_1M
+
+#define NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#define IOCC_WA_WIN0_PHYS_BASE		0xFF000000
+
+#define USB3_REGS_PHYS_BASE		0xFF100000
+#define USB3_REGS_SIZE			_128K
+
+
+/*
+ * Virtual address map
+ */
+#define SPI_CS0_VIRT_BASE		0xFAB00000
+#define INTER_REGS_VIRT_BASE		0xFBB00000
+
+#define PEX0_IO_VIRT_BASE		0xFBC00000
+#define PEX1_IO_VIRT_BASE		0xFBD00000
+
+#define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
+
+#define USB3_REGS_VIRT_BASE		0xFBF00000
+
+#define UART_VIRT_BASE			0xFC600000
+
+#define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
+#define DEVICE_CS0_VIRT_BASE		0xFE700000
+#define DEVICE_CS1_VIRT_BASE		0xFE800000
+#define DEVICE_CS2_VIRT_BASE		0xFE900000
+#define DEVICE_CS3_VIRT_BASE		0xFEA00000
+
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
+#define PP2_CPU0_VIRT_BASE		0xFEC00000
+#define PP2_CPU1_VIRT_BASE		0xFEC10000
+#define BOOTROM_VIRT_BASE		0xFED00000
+#define LEGACY_NAND_VIRT_BASE		0xFEF00000
+
+/*
+ * Linux native definitiotns
+ */
+#define SDRAM_OPERATION_REG		(INTER_REGS_VIRT_BASE | 0x1418)
+#define SDRAM_CONFIG_REG		(INTER_REGS_VIRT_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG		(INTER_REGS_VIRT_BASE | 0x170C)
+
+#define UART_PHYS_BASE(port)		(INTER_REGS_PHYS_BASE | \
+						(0x12000 + (port * 0x100)))
+#define DDR_VIRT_BASE			(INTER_REGS_VIRT_BASE | 0x00000)
+#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
+
+#define BRIDGE_VIRT_BASE		(INTER_REGS_VIRT_BASE | 0x20000)
+#define BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define SW_TRIG_IRQ			(BRIDGE_VIRT_BASE | 0x0A04)
+#define SW_TRIG_IRQ_PHYS		(BRIDGE_PHYS_BASE | 0x0A04)
+#define SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define SW_TRIG_IRQ_INITID_MASK	0x1F
+#define PER_CPU_BASE			(BRIDGE_VIRT_BASE | 0x1000)
+#define IRQ_VIRT_BASE			(PER_CPU_BASE)
+#define CPU_INTACK			0xB4
+#define IRQ_SEL_CAUSE_OFF		0xA0
+#define IN_DOORBELL_CAUSE		0x78
+#define IN_DRBEL_CAUSE			(PER_CPU_BASE | 0x78)
+#define IN_DRBEL_MSK			(PER_CPU_BASE | 0x7c)
+
+#endif /* __ASM_ARCH_AURORA_H */
diff --git a/arch/arm/mach-armada38x/include/mach/debug-macro.S b/arch/arm/mach-armada38x/include/mach/debug-macro.S
new file mode 100644
index 0000000..a4b6f40
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/debug-macro.S
@@ -0,0 +1,24 @@
+/*
+ * debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <mach/armada380.h>
+
+
+	.macro  addruart, rp, rv, tmp
+	ldr     \rp, =INTER_REGS_PHYS_BASE
+	ldr	\rv, =INTER_REGS_VIRT_BASE
+	orr     \rp, \rp, #0x00012000
+        orr     \rv, \rv, #0x00012000
+#ifdef CONFIG_MV_UART_PORT
+	orr     \rp, \rp, #0x100 * CONFIG_MV_UART_PORT
+        orr     \rv, \rv, #0x100 * CONFIG_MV_UART_PORT
+#endif
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-armada38x/include/mach/entry-macro.S b/arch/arm/mach-armada38x/include/mach/entry-macro.S
new file mode 100644
index 0000000..73c1129
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/entry-macro.S
@@ -0,0 +1,7 @@
+#include <asm/hardware/entry-macro-gic.S>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
diff --git a/arch/arm/mach-armada38x/include/mach/gpio.h b/arch/arm/mach-armada38x/include/mach/gpio.h
new file mode 100644
index 0000000..948c4f5
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_GPIO_H__
+#define __MACH_GPIO_H__
+
+#include <asm/errno.h>
+#include <mach/armada380.h>
+#include <mach/irqs.h>
+#include <plat/gpio.h>
+#include <asm-generic/gpio.h>
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+
+#define GPIO_MAX	64
+
+#define GPIO_BASE_LO		(GPIO_VIRT_BASE + 0x00)
+#define GPIO_BASE_HI		(GPIO_VIRT_BASE + 0x20)
+
+#define GPIO_BASE(pin)		((pin < 32) ? GPIO_BASE_LO : GPIO_BASE_HI)
+
+#define GPIO_OUT(pin)		(GPIO_BASE(pin) + 0x00)
+#define GPIO_IO_CONF(pin)	(GPIO_BASE(pin) + 0x04)
+#define GPIO_BLINK_EN(pin)	(GPIO_BASE(pin) + 0x08)
+#define GPIO_IN_POL(pin)	(GPIO_BASE(pin) + 0x0c)
+#define GPIO_DATA_IN(pin)	(GPIO_BASE(pin) + 0x10)
+#define GPIO_EDGE_CAUSE(pin)	(GPIO_BASE(pin) + 0x14)
+#define GPIO_EDGE_MASK(pin)	(GPIO_BASE(pin) + 0x18)
+#define GPIO_LEVEL_MASK(pin)	(GPIO_BASE(pin) + 0x1c)
+
+static inline int gpio_to_irq(int pin)
+{
+	if (pin < NR_IRQS_GLOBAL_GPIO)
+		return pin + IRQ_START_GLOBAL_GPIO;
+
+	WARN(1, "%s: Error: wrong gpio pin number (%d)\n", __func__, pin);
+	return -EINVAL;
+}
+
+static inline int irq_to_gpio(int irq)
+{
+	if (irq >= IRQ_START_GLOBAL_GPIO &&
+	    irq <  IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO)
+		return irq - IRQ_START_GLOBAL_GPIO;
+
+	WARN(1, "%s: Error: wrong irq number (%d)\n", __func__, irq);
+	return -EINVAL;
+}
+
+#endif /* __MACH_GPIO_H__ */
diff --git a/arch/arm/mach-armada38x/include/mach/hardware.h b/arch/arm/mach-armada38x/include/mach/hardware.h
new file mode 100644
index 0000000..11ea3b4
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * include/mach/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "armada380.h"
+
+#endif
diff --git a/arch/arm/mach-armada38x/include/mach/io.h b/arch/arm/mach-armada38x/include/mach/io.h
new file mode 100644
index 0000000..dba029a
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/io.h
@@ -0,0 +1,21 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "armada380.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define IO_SPACE_REMAP		PEX0_IO_PHYS_BASE
+
+#define __io(a)			((a) + PEX0_IO_VIRT_BASE)
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(a)
+
+void dma_io_sync(void);
+
+#endif /* __ASM_ARCH_IO_H */
diff --git a/arch/arm/mach-armada38x/include/mach/irqs.h b/arch/arm/mach-armada38x/include/mach/irqs.h
new file mode 100644
index 0000000..a6b9930
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/irqs.h
@@ -0,0 +1,220 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * Software Generated Interrupts (SGI)
+ */
+#define IRQ_SGI_0			0
+#define IRQ_SGI_15			15
+
+/*
+ * Private Peripheral Interrupts (PPI)
+ */
+#define IRQ_PRIV_CPU_TIMER0		27
+#define IRQ_PRIV_MPIC_PPI_FIQ		28
+#define IRQ_PRIV_CPU_LOCAL_TIMER	29
+#define IRQ_PRIV_CPU_LOCAL_WD		30
+#define IRQ_PRIV_MPIC_PPI_IRQ		31
+
+/*
+ * Shared Peripheral Interrupts (SPI)
+ */
+#define IRQ_GLOBAL_SPI0			33
+#define IRQ_GLOBAL_I2C0			34
+#define IRQ_GLOBAL_I2C1			35
+
+#define IRQ_GLOBAL_TIMER0		40
+#define IRQ_GLOBAL_TIMER1		41
+#define IRQ_GLOBAL_TIMER2		42
+#define IRQ_GLOBAL_TIMER3		43
+#define IRQ_GLOBAL_TIMER(timer)		((timer >= 0 && timer <= 3) ? \
+					IRQ_GLOBAL_TIMER0 + timer : \
+					IRQ_GLOBAL_TIMER0)
+
+#define IRQ_GLOBAL_UART0		44
+#define IRQ_GLOBAL_UART1		45
+
+#define IRQ_GLOBAL_USB3_IP		48
+#define IRQ_GLOBAL_USB2_IP		49
+
+#define IRQ_GLOBAL_CESA0		51
+#define IRQ_GLOBAL_CESA1		52
+#define CESA_IRQ(chan)			((chan == 0) ? \
+					IRQ_GLOBAL_CESA0 : \
+					IRQ_GLOBAL_CESA1)
+
+#define IRQ_GLOBAL_RTC			53
+
+#define IRQ_GLOBAL_XOR0_CHAN0		54
+#define IRQ_GLOBAL_XOR0_CHAN1		55
+
+#define IRQ_GLOBAL_SDIO			57
+#define IRQ_GLOBAL_SATA0		58
+#define IRQ_GLOBAL_TDM			59
+
+#define IRQ_GLOBAL_PCIE0		61
+#define IRQ_GLOBAL_PCIE1		65
+
+#define IRQ_GLOBAL_PP_PORT0_RXTX	69
+#define IRQ_GLOBAL_PP_MISC		72
+#define IRQ_GLOBAL_PP_PORT1_RXTX	73
+#define IRQ_GLOBAL_PP_PORT2_RXTX	77
+#define IRQ_GLOBAL_PP_PORT7_RXTX	81
+
+#define IRQ_GLOBAL_GOP			82 /* Group of Ports (GOP) */
+#define IRQ_GLOBAL_PON			83
+
+#define IRQ_GLOBAL_ETH_COMPLEX		84
+
+#define IRQ_GLOBAL_GPIO_0_7		85
+#define IRQ_GLOBAL_GPIO_8_15		86
+#define IRQ_GLOBAL_GPIO_16_23		87
+#define IRQ_GLOBAL_GPIO_24_31		88
+
+#define IRQ_GLOBAL_DYING_GASP		89
+
+#define IRQ_GLOBAL_GPIO_32_39		90
+#define IRQ_GLOBAL_GPIO_40_47		91
+#define IRQ_GLOBAL_GPIO_48_55		92
+#define IRQ_GLOBAL_GPIO_56_63		93
+#define IRQ_GLOBAL_GPIO_64_66		94
+
+#define IRQ_GLOBAL_SPI1			95
+
+#define IRQ_GLOBAL_WD			96
+
+#define IRQ_GLOBAL_XOR1_CHAN0		97
+#define IRQ_GLOBAL_XOR1_CHAN1		98
+
+#define IRQ_GLOBAL_INB_DOOR_BELL_SUMMARY0	99
+#define IRQ_GLOBAL_INB_DOOR_BELL_SUMMARY1	100
+#define IRQ_GLOBAL_INB_DOOR_BELL_SUMMARY2	101
+
+#define IRQ_GLOBAL_AUDIO		107
+#define IRQ_GLOBAL_CODEC_SUMMARY	109
+
+#define IRQ_GLOBAL_THERMAL		110
+
+#define IRQ_GLOBAL_DRAM			111
+
+#define IRQ_GLOBAL_NET_WAKE_UP		112
+
+#define IRQ_GLOBAL_NAND			116
+/* Redefinition for the NFC driver */
+#define IRQ_AURORA_NFC			IRQ_GLOBAL_NAND
+
+#define IRQ_GLOBAL_SOC_MISC_SUMMARY	117
+
+#define IRQ_GLOBAL_DRAGONITE		118
+
+/*
+ * Global GPIO interrupts
+ */
+#define IRQ_START_GLOBAL_GPIO		192
+#define NR_IRQS_GLOBAL_GPIO		67
+#define IRQ_GLOBAL_GPIO(gpio_irq)	(gpio_irq >= NR_IRQS_GLOBAL_GPIO ? \
+			NR_IRQS_GLOBAL_GPIO : IRQ_START_GLOBAL_GPIO + gpio_irq)
+
+/*
+ * Global PCIe MSI interrupts
+ */
+#define IRQ_START_GLOBAL_MSI		(IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO)
+#define NR_IRQS_GLOBAL_MSI		96
+#define IRQ_GLOBAL_MSI(msi_irq)		(msi_irq >= NR_IRQS_GLOBAL_MSI ? \
+			NR_IRQS_GLOBAL_MSI : NR_IRQS_GLOBAL_MSI + msi_irq)
+
+/*
+ * SoC private interrupts
+ */
+#define IRQ_START_PRIV_SOC_PPI		(IRQ_START_GLOBAL_MSI + NR_IRQS_GLOBAL_MSI)
+#define NR_IRQS_PRIV_SOC_PPI		24
+
+#define IRQ_PRIV_INB_DOOR_BELL_SUMMARY0		(IRQ_START_PRIV_SOC_PPI + 0)
+#define IRQ_PRIV_INB_DOOR_BELL_SUMMARY1		(IRQ_START_PRIV_SOC_PPI + 1)
+#define IRQ_PRIV_OUT_DOOR_BELL_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 2)
+#define IRQ_PRIV_MP_LOCAL_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 3)
+#define IRQ_PRIV_SOC_ERROR_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 4)
+#define IRQ_PRIV_SOC_PRIV_TIMER0		(IRQ_START_PRIV_SOC_PPI + 5)
+#define IRQ_PRIV_SOC_PRIV_TIMER1		(IRQ_START_PRIV_SOC_PPI + 6)
+#define IRQ_PRIV_PP_PORT0_RXTX			(IRQ_START_PRIV_SOC_PPI + 9)
+#define IRQ_PRIV_PP_PORT1_RXTX			(IRQ_START_PRIV_SOC_PPI + 11)
+#define IRQ_PRIV_PP_PORT2_RXTX			(IRQ_START_PRIV_SOC_PPI + 13)
+#define IRQ_PRIV_PP_PORT7_RXTX			(IRQ_START_PRIV_SOC_PPI + 15)
+#define IRQ_PRIV_GPIO_0_7			(IRQ_START_PRIV_SOC_PPI + 16)
+#define IRQ_PRIV_GPIO_8_15			(IRQ_START_PRIV_SOC_PPI + 17)
+#define IRQ_PRIV_GPIO_16_23			(IRQ_START_PRIV_SOC_PPI + 18)
+#define IRQ_PRIV_GPIO_24_31			(IRQ_START_PRIV_SOC_PPI + 19)
+#define IRQ_PRIV_GPIO_32_39			(IRQ_START_PRIV_SOC_PPI + 20)
+#define IRQ_PRIV_GPIO_40_47			(IRQ_START_PRIV_SOC_PPI + 21)
+#define IRQ_PRIV_GPIO_48_55			(IRQ_START_PRIV_SOC_PPI + 22)
+#define IRQ_PRIV_GPIO_56_63			(IRQ_START_PRIV_SOC_PPI + 23)
+#define IRQ_PRIV_GPIO_64_66			(IRQ_START_PRIV_SOC_PPI + 24)
+
+/*
+ * Private GPIO interrupts
+ */
+#define IRQ_START_PRIV_GPIO	(IRQ_START_PRIV_SOC_PPI + NR_IRQS_PRIV_SOC_PPI)
+#define NR_IRQS_PRIV_GPIO	67
+#define IRQ_PRIV_GPIO(gpio_irq)		(gpio_irq >= NR_IRQS_PRIV_GPIO ? \
+			NR_IRQS_PRIV_GPIO : IRQ_START_PRIV_GPIO + gpio_irq)
+
+/*
+ * Private PCIe MSI interrupts
+ */
+#define IRQ_START_PRIV_MSI		(IRQ_START_PRIV_GPIO + NR_IRQS_PRIV_GPIO)
+#define NR_IRQS_PRIV_MSI		32
+#define IRQ_PRIV_MSI(msi_irq)		(msi_irq >= NR_IRQS_PRIV_MSI ? \
+			NR_IRQS_PRIV_MSI : IRQ_START_PRIV_MSI + msi_irq)
+
+/*
+ * Private SoC error interrupts
+ */
+#define IRQ_START_PRIV_ERROR		(IRQ_START_PRIV_MSI + NR_IRQS_PRIV_MSI)
+#define NR_IRQS_PRIV_ERROR		50
+
+#define IRQ_PRIV_ERROR_CESA0		(IRQ_START_PRIV_ERROR + 0)
+#define IRQ_PRIV_ERROR_DEV_BUS		(IRQ_START_PRIV_ERROR + 1)
+#define IRQ_PRIV_ERROR_XOR1		(IRQ_START_PRIV_ERROR + 3)
+#define IRQ_PRIV_ERROR_PCIE0		(IRQ_START_PRIV_ERROR + 4)
+#define IRQ_PRIV_ERROR_PCIE1		(IRQ_START_PRIV_ERROR + 5)
+#define IRQ_PRIV_ERROR_CESA1		(IRQ_START_PRIV_ERROR + 7)
+#define IRQ_PRIV_ERROR_USB		(IRQ_START_PRIV_ERROR + 8)
+#define IRQ_PRIV_ERROR_DRAM		(IRQ_START_PRIV_ERROR + 9)
+#define IRQ_PRIV_ERROR_XOR0		(IRQ_START_PRIV_ERROR + 10)
+#define IRQ_PRIV_ERROR_SATA0		(IRQ_START_PRIV_ERROR + 17)
+#define IRQ_PRIV_ERROR_TDM		(IRQ_START_PRIV_ERROR + 20)
+#define IRQ_PRIV_ERROR_NAND		(IRQ_START_PRIV_ERROR + 21)
+#define IRQ_PRIV_ERROR_L2_DECODE	(IRQ_START_PRIV_ERROR + 23)
+#define IRQ_PRIV_ERROR_L2_EVENT_CNT	(IRQ_START_PRIV_ERROR + 24)
+#define IRQ_PRIV_ERROR_L2_RAM_RD_DATA	(IRQ_START_PRIV_ERROR + 25)
+#define IRQ_PRIV_ERROR_L2_RAM_RD_TAG	(IRQ_START_PRIV_ERROR + 26)
+#define IRQ_PRIV_ERROR_L2_RAM_WR_DATA	(IRQ_START_PRIV_ERROR + 27)
+#define IRQ_PRIV_ERROR_L2_RAM_WR_TAG	(IRQ_START_PRIV_ERROR + 28)
+#define IRQ_PRIV_ERROR_L2_COMBINED	(IRQ_START_PRIV_ERROR + 29)
+#define IRQ_PRIV_ERROR_L2_PARITY_RAM_RD_DATA	(IRQ_START_PRIV_ERROR + 30)
+#define IRQ_PRIV_ERROR_L2_PARITY_RAM_RD_TAG	(IRQ_START_PRIV_ERROR + 31)
+#define IRQ_PRIV_ERROR_L2_SLAVE_ERR	(IRQ_START_PRIV_ERROR + 32)
+#define IRQ_PRIV_ERROR_PARITY_FAIL0(parity0_irq) \
+			(parity0_irq >= 8 ? \
+			IRQ_START_PRIV_ERROR + 33 : \
+			IRQ_START_PRIV_ERROR + 33 + parity0_irq)
+#define IRQ_PRIV_ERROR_PARITY_FAIL1(parity1_irq) \
+			(parity1_irq >= 8 ? \
+			IRQ_START_PRIV_ERROR + 41 : \
+			IRQ_START_PRIV_ERROR + 41 + parity1_irq)
+#define IRQ_PRIV_ERROR_POLARITY_SCU0	(IRQ_START_PRIV_ERROR + 49)
+#define IRQ_PRIV_ERROR_POLARITY_SCU1	(IRQ_START_PRIV_ERROR + 50)
+
+/*
+ * Total number of interrupts
+ */
+#define NR_IRQS			(IRQ_START_PRIV_ERROR + NR_IRQS_PRIV_ERROR)
+#define NR_GPIO_IRQS		NR_IRQS_GLOBAL_GPIO
+
+#endif /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-armada38x/include/mach/memory.h b/arch/arm/mach-armada38x/include/mach/memory.h
new file mode 100644
index 0000000..32cd5da
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/memory.h
@@ -0,0 +1,28 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#ifdef CONFIG_MV_DRAM_BASE
+#define PLAT_PHYS_OFFSET		UL(CONFIG_MV_DRAM_BASE)
+#else
+#define PLAT_PHYS_OFFSET		UL(0x00000000)
+#endif
+
+#define BOOT_PARAMS_OFFSET		(PLAT_PHYS_OFFSET + 0x100)
+
+/* Override the ARM default */
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS		35
+#define SECTION_SIZE_BITS		29
+#endif
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define arch_is_coherent()		1
+#endif
+
+#endif /* __ASM_ARCH_MEMORY_H */
diff --git a/arch/arm/mach-armada38x/include/mach/param.h b/arch/arm/mach-armada38x/include/mach/param.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/param.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-armada38x/include/mach/serial.h b/arch/arm/mach-armada38x/include/mach/serial.h
new file mode 100644
index 0000000..246d769
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/serial.h
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/irq.h>
+/* #include <linux/autoconf.h> */
+
+#include "../arch/arm/mach-armada380/config/mvSysHwConfig.h"
+
+extern unsigned int mvTclk;
+
+#undef  BASE_BAUD
+#define BASE_BAUD (mvTclk / 16)
+
+#define PORT0_BASE	(INTER_REGS_VIRT_BASE + 0x12000)	/* port 0 base */
+#define PORT1_BASE	(INTER_REGS_VIRT_BASE + 0x12100)	/* port 1 base */
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST /* | ASYNC_SPD_VHI  115200 */)
+
+#define STD_SERIAL_PORT_DEFNS
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff --git a/arch/arm/mach-armada38x/include/mach/smp.h b/arch/arm/mach-armada38x/include/mach/smp.h
new file mode 100644
index 0000000..812bb54
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/smp.h
@@ -0,0 +1,23 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+#include <asm/io.h>
+#include <mach/armada380.h>
+
+extern unsigned int master_cpu_id;
+extern unsigned int group_cpu_mask;
+extern unsigned long mv_cpu_count;
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#define get_hw_cpu_mask(cpu_mask)	((cpu_mask << master_cpu_id) & group_cpu_mask)
+#define get_hw_cpu_id(cpu)		(cpu + master_cpu_id)
+#define is_primary_amp()		(master_cpu_id == 0 ? 1 : 0)
+
+#endif /* ASMARM_ARCH_SMP_H */
diff --git a/arch/arm/mach-armada38x/include/mach/system.h b/arch/arm/mach-armada38x/include/mach/system.h
new file mode 100644
index 0000000..eef12f3
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/system.h
@@ -0,0 +1,34 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
+#define LSP_PG_SZ_VER  " (Large Page)"
+#else
+#define LSP_PG_SZ_VER  ""
+#endif
+
+#define LSP_VERSION "linux-3.2.y-2013_Q3.0" LSP_PG_SZ_VER
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk(KERN_NOTICE "Reseting...\n");
+	mvBoardReset();
+	/* This should never be reached */
+	while (1)
+		;
+}
+
+#endif /* __MACH_SYSTEM_H */
diff --git a/arch/arm/mach-armada38x/include/mach/timex.h b/arch/arm/mach-armada38x/include/mach/timex.h
new file mode 100644
index 0000000..c8cf294
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-dove/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
diff --git a/arch/arm/mach-armada38x/include/mach/uncompress.h b/arch/arm/mach-armada38x/include/mach/uncompress.h
new file mode 100644
index 0000000..09acaa7
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/uncompress.h
@@ -0,0 +1,43 @@
+/*
+ * include/asm-arm/arch-aurora/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/armada380.h>
+
+#ifndef CONFIG_MV_UART_PORT
+#define UART_THR ((unsigned char *)(UART_PHYS_BASE(0) + 0x0))
+#define UART_LSR ((unsigned char *)(UART_PHYS_BASE(0) + 0x14))
+#else
+#define UART_THR ((unsigned char *)(UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
+#define UART_LSR ((unsigned char *)(UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
+#endif
+
+#define LSR_THRE	0x20
+
+static void putc(const char c)
+{
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		/* Transmit fifo not full? */
+		if (*UART_LSR & LSR_THRE)
+			break;
+	}
+
+	*UART_THR = c;
+}
+
+static void flush(void)
+{
+	/* empty function */
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-armada38x/include/mach/vmalloc.h b/arch/arm/mach-armada38x/include/mach/vmalloc.h
new file mode 100644
index 0000000..26ace24
--- /dev/null
+++ b/arch/arm/mach-armada38x/include/mach/vmalloc.h
@@ -0,0 +1,6 @@
+/*
+ * arch/arm/mach-armada380/include/mach/vmalloc.h
+ */
+
+
+#define VMALLOC_END	(0xfa800000UL)
diff --git a/arch/arm/mach-armada38x/irq.c b/arch/arm/mach-armada38x/irq.c
new file mode 100644
index 0000000..745fe78
--- /dev/null
+++ b/arch/arm/mach-armada38x/irq.c
@@ -0,0 +1,278 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include "ca9x2.h"
+#include "mvOs.h"
+#include "gpp/mvGppRegs.h"
+
+#define SOC_PPI_CAUSE			0x21880
+#define SOC_PPI_MASK_SET		0x218b8
+#define SOC_PPI_MASK_CLEAR		0x218bc
+
+static DEFINE_RAW_SPINLOCK(irq_controller_lock);
+
+/*
+ * Global GPIO interrupt handling
+ */
+static void a380_gpio_irq_mask(struct irq_data *d)
+{
+	u32 irq = d->irq, bitmask, reg;
+
+	if (irq < IRQ_START_GLOBAL_GPIO ||
+	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return;		/* wrong  */
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_GLOBAL_GPIO) >> 5;
+	MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
+}
+
+static void a380_gpio_irq_unmask(struct irq_data *d)
+{
+	u32 irq = d->irq, bitmask, reg;
+
+	if (irq < IRQ_START_GLOBAL_GPIO ||
+	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
+		WARN(1, "Error: wrong GPIO irq %d\n", irq);
+		return;		/* wrong  */
+	}
+
+	bitmask = 1 << (irq & 0x1F);
+	reg = (irq - IRQ_START_GLOBAL_GPIO) >> 5;
+	MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
+}
+
+static struct irq_chip a380_irq_chip = {
+	.name = "a380_gpio_irq",
+	.irq_mask = a380_gpio_irq_mask,
+	.irq_mask_ack = a380_gpio_irq_mask,
+	.irq_unmask = a380_gpio_irq_unmask,
+	.irq_disable = a380_gpio_irq_mask,
+	.irq_enable = a380_gpio_irq_unmask,
+};
+
+/*
+ * gpio_cascade_irq is in [85:88] or [90:94]
+ */
+static void a380_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
+					  struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	u32 bit, n, gpio_group, irq;
+	unsigned long cause, mask;
+
+	chained_irq_enter(chip, desc);
+
+	gpio_group = (gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7) / 4;
+
+	cause = MV_REG_READ(GPP_INT_CAUSE_REG(gpio_group));
+	mask = MV_REG_READ(GPP_INT_MASK_REG(gpio_group));
+	cause &= mask;
+
+	/* Ack GPIO interrupts */
+	MV_REG_WRITE(GPP_INT_LVL_REG(gpio_group), cause);
+
+	for_each_set_bit(bit, &cause, 32) {
+		n = gpio_cascade_irq - IRQ_GLOBAL_GPIO_0_7;
+
+		if (n >= 5)
+			n -= 1;
+		n = (n * 8) + (bit % 4);
+
+		irq = IRQ_START_GLOBAL_GPIO + n;
+		handle_level_irq(irq, desc);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void __init a380_cascade_irq_gpio_global(void)
+{
+	int irq, irq_base;
+
+	irq_base = irq_alloc_descs(-1, IRQ_START_GLOBAL_GPIO,
+				   NR_IRQS_GLOBAL_GPIO, 0);
+	if (IS_ERR_VALUE(irq_base))
+		BUG();
+
+	for (irq = IRQ_START_GLOBAL_GPIO;
+	     irq < IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO; irq++) {
+		irq_set_chip_and_handler(irq, &a380_irq_chip, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63,
+				a380_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66,
+				a380_gpio_cascade_irq_handler);
+}
+
+/*
+ * Handle SOC PPI (Private Peripheral Interrupts).
+ */
+struct mpic_chip_regs {
+	unsigned long cause;
+	unsigned long mask;
+	unsigned long unmask;
+};
+
+struct mpic_data {
+	int irq_base;
+	struct irq_domain *domain;
+	struct mpic_chip_regs regs;
+};
+
+static struct mpic_data mpic_data = {
+	.regs = {
+		 .cause = INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE,
+		 .mask = INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET,
+		 .unmask = INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR,
+		 }
+};
+
+static inline u_int
+mpic_hw_irq(struct mpic_data *mpic, u_int irq)
+{
+
+	return irq - mpic->irq_base;
+}
+
+static void mpic_irq_mask(struct irq_data *d)
+{
+	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+
+	raw_spin_lock(&irq_controller_lock);
+	writel_relaxed(mpic_hw_irq(mpic, d->irq), mpic->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static void mpic_irq_unmask(struct irq_data *d)
+{
+	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+
+	raw_spin_lock(&irq_controller_lock);
+	writel_relaxed(mpic_hw_irq(mpic, d->irq), mpic->regs.unmask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static struct irq_chip mpic_chip = {
+	.irq_mask = mpic_irq_mask,
+	.irq_unmask = mpic_irq_unmask,
+};
+
+static void mpic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
+{
+	struct mpic_data *mpic = irq_get_handler_data(irq);
+	struct irq_chip *chip = irq_get_chip(irq);
+	unsigned long cause;
+
+	chained_irq_enter(chip, desc);
+
+	raw_spin_lock(&irq_controller_lock);
+	cause = readl_relaxed(mpic->regs.cause);
+	raw_spin_unlock(&irq_controller_lock);
+
+	/* leave only relevant cause bits */
+	cause &= 0x1FFAAFF;
+	if (cause == 0)
+		goto out;	/* spurious irq ? */
+
+	irq = ffs(cause) - 1;
+	generic_handle_irq(mpic->irq_base + irq);
+
+out:
+	chained_irq_exit(chip, desc);
+}
+
+static void __init a380_cascade_irq_mpic(int irq_start, int nr_irqs)
+{
+	struct mpic_data *mpic = &mpic_data;
+	unsigned int i, intr;
+
+	mpic->irq_base = irq_alloc_descs(-1, irq_start, nr_irqs, 0);
+	if (IS_ERR_VALUE(mpic->irq_base))
+		BUG();
+
+	for (i = 0; i <= nr_irqs; i++) {
+		intr = mpic->irq_base + i;
+		irq_set_percpu_devid(intr);
+		irq_set_chip_and_handler(intr, &mpic_chip, handle_percpu_devid_irq);
+		irq_set_chip_data(intr, &mpic_data);
+		set_irq_flags(intr, IRQF_VALID | IRQF_PROBE);
+	}
+	if (irq_set_handler_data(irq_start, &mpic_data) != 0)
+		BUG();
+
+	irq_set_chained_handler(irq_start, mpic_handle_cascade_irq);
+}
+
+static void __init a380_cascade_irq_gpio_private(void)
+{
+	/* TBD */
+}
+
+static void __init a380_cascade_irq_msi_global(void)
+{
+	/* TBD */
+}
+
+static void __init a380_cascade_irq_msi_private(void)
+{
+	/* TBD */
+}
+
+static void __init a380_cascade_irq_errors(void)
+{
+	/* TBD */
+}
+
+/*
+ * Init GIC and MPIC and setup cascade irq
+ * handling for GPIO, MSI and Error interrupts.
+ */
+void __init a380_init_irq(void)
+{
+	gic_init(0, 29,
+		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
+		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
+
+	a380_cascade_irq_mpic(IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
+
+	a380_cascade_irq_gpio_global();
+	a380_cascade_irq_gpio_private();
+
+	a380_cascade_irq_msi_global();
+	a380_cascade_irq_msi_private();
+
+	a380_cascade_irq_errors();
+}
diff --git a/arch/arm/mach-armada38x/localtimer.c b/arch/arm/mach-armada38x/localtimer.c
new file mode 100644
index 0000000..9f69f59
--- /dev/null
+++ b/arch/arm/mach-armada38x/localtimer.c
@@ -0,0 +1,27 @@
+/*
+ *  linux/arch/arm/plat-versatile/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+#include <mach/irqs.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	evt->irq = IRQ_PRIV_CPU_LOCAL_TIMER;
+	twd_timer_setup(evt);
+	return 0;
+}
diff --git a/arch/arm/mach-armada38x/mpp.h b/arch/arm/mach-armada38x/mpp.h
new file mode 100644
index 0000000..3b145b3
--- /dev/null
+++ b/arch/arm/mach-armada38x/mpp.h
@@ -0,0 +1,33 @@
+#ifndef __ARCH_DOVE_MPP_H
+#define __ARCH_DOVE_MPP_H
+
+enum aurora_mpp_type {
+	/*
+	 * This MPP is unused.
+	 */
+	MPP_UNUSED,
+
+	/*
+	 * This MPP pin is used as a generic GPIO pin.
+	 */
+	MPP_GPIO,
+
+	/*
+	 * This MPP is used as a SATA activity LED.
+	 */
+	MPP_SATA_LED,
+	/*
+	 * This MPP is used as a functional pad.
+	 */
+	MPP_FUNCTIONAL,
+
+};
+
+struct aurora_mpp_mode {
+	int mpp;
+	enum aurora_mpp_type type;
+};
+
+void aurora_mpp_conf(struct aurora_mpp_mode *mode);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysCesa.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysCesa.c
new file mode 100644
index 0000000..0d83504
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysCesa.c
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mv_cesa/cesa_if.h"
+
+extern u32 mv_crypto_phys_base_get(u8 chan);
+extern u32 mv_crypto_virt_base_get(u8 chan);
+
+/*******************************************************************************
+* mvSysCesaInit - Initialize the Cesa subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle)
+{
+	MV_CESA_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	MV_U8 chan;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+
+	if (status == MV_OK) {
+		for (chan = 0; chan < MV_CESA_CHANNELS; chan++) {
+			status = mvCesaIfTdmaWinInit(chan, addrWinMap);
+
+			if (status != MV_OK) {
+				mvOsPrintf
+				    ("Error, unable to initialize CESA windows for channel(%d)\n",
+				     chan);
+				break;
+			}
+			halData.sramPhysBase[chan] =
+			    (MV_ULONG) mv_crypto_phys_base_get(chan);
+			halData.sramVirtBase[chan] =
+			    (MV_U8 *) mv_crypto_virt_base_get(chan);
+			halData.sramOffset[chan] = 0;
+		}
+
+		if (status == MV_OK) {
+			halData.ctrlModel = mvCtrlModelGet();
+			halData.ctrlRev = mvCtrlRevGet();
+			status = mvCesaIfInit(numOfSession, queueDepth,
+					      osHandle, &halData);
+		}
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysCesaApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysCesaApi.h
new file mode 100644
index 0000000..e1d929d
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysCesaApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_CESA_API_H__
+#define __MV_SYS_CESA_API_H__
+
+MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysDdr.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysDdr.c
new file mode 100644
index 0000000..1e0d9f6
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysDdr.c
@@ -0,0 +1,131 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+/*******************************************************************************
+* mvSysDdrSpdRead
+*
+* DESCRIPTION:
+*	System interface for reading DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer to read data into.
+*       size:	Number of bytes to read.
+*
+* OUTPUT:
+*       data:	SPD data.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
+/*******************************************************************************
+* mvSysDdrSpdWrite
+*
+* DESCRIPTION:
+*	System interface for writing DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer holding the data to be written.
+*       size:	Number of bytes to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiWrite(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysEth.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysEth.c
new file mode 100644
index 0000000..8d8cfa1
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysEth.c
@@ -0,0 +1,133 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "eth/mvEth.h"
+
+/*******************************************************************************
+* mvSysEthInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysEthInit(MV_VOID)
+{
+	MV_ETH_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK)
+		return;
+
+	{
+		int i;
+		for (i = 0; i < MAX_TARGETS; i++) {
+			if (addrWinMap[i].enable == MV_FALSE)
+				continue;
+			printk(KERN_INFO "%d - Base 0x%08x , Size = 0x%08x.\n",
+			       i, addrWinMap[i].addrWin.baseLow,
+			       addrWinMap[i].addrWin.size);
+		}
+	}
+	halData.maxPortNum = mvCtrlEthMaxPortGet();
+	halData.cpuPclk = mvCpuPclkGet();
+	halData.tclk = mvBoardTclkGet();
+#ifdef ETH_DESCR_IN_SRAM
+	halData.sramSize = mvCtrlSramSizeGet();
+#endif
+
+	for (port = 0; port < halData.maxPortNum; port++) {
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE) {
+			halData.portData[port].powerOn = MV_FALSE;
+			continue;
+		}
+		status = mvEthWinInit(port, addrWinMap);
+		if (status == MV_OK) {
+			halData.portData[port].powerOn = MV_TRUE;
+			halData.portData[port].phyAddr =
+			    mvBoardPhyAddrGet(port);
+			halData.portData[port].isSgmii =
+			    mvBoardIsPortInSgmii(port);
+			halData.portData[port].macSpeed =
+			    mvBoardMacSpeedGet(port);
+		}
+	}
+
+	mvEthHalInit(&halData);
+
+	return;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysEthApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthApi.h
new file mode 100644
index 0000000..7211b8f
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETH_API_H__
+#define __MV_SYS_ETH_API_H__
+
+MV_VOID mvSysEthInit(void);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhy.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhy.c
new file mode 100644
index 0000000..c1c7408
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhy.c
@@ -0,0 +1,108 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "eth-phy/mvEthPhy.h"
+
+#if defined(CONFIG_MV_ETH_LEGACY)
+#include "eth/gbe/mvEthRegs.h"
+#elif defined(CONFIG_MV_ETH_NETA)
+#include "neta/gbe/mvEthRegs.h"
+#elif defined(CONFIG_MV_ETH_PP2)
+#include "pp2/gbe/mvPp2GbeRegs.h"
+#endif
+
+/*******************************************************************************
+* mvSysEthPhyInit - Initialize the EthPhy subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysEthPhyInit(void)
+{
+	MV_ETHPHY_HAL_DATA halData;
+	MV_U32 port;
+
+	for (port = 0; port < mvCtrlEthMaxPortGet(); port++) {
+		halData.phyAddr[port] = mvBoardPhyAddrGet(port);
+		halData.boardSpecInit = MV_FALSE;
+	}
+
+	halData.ethPhySmiReg = ETH_SMI_REG(MV_ETH_SMI_PORT);
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+
+	return mvEthPhyHalInit(&halData);
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhyApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhyApi.h
new file mode 100644
index 0000000..02bd8db
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysEthPhyApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETHPHY_API_H__
+#define __MV_SYS_ETHPHY_API_H__
+
+MV_STATUS mvSysEthPhyInit(void);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysNeta.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysNeta.c
new file mode 100644
index 0000000..9ff1404
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysNeta.c
@@ -0,0 +1,150 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "neta/gbe/mvNeta.h"
+
+/*******************************************************************************
+* mvSysNetaInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+void mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask)
+{
+	MV_NETA_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	int i;
+
+	memset(&halData, 0, sizeof(halData));
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK)
+		return;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (addrWinMap[i].enable == MV_FALSE)
+			continue;
+
+#ifdef CONFIG_MV_SUPPORT_L2_DEPOSIT
+		/* Setting DRAM windows attribute to :
+		   0x3 - Shared transaction + L2 write allocate (L2 Deposit) */
+		if (MV_TARGET_IS_DRAM(i)) {
+			addrWinMap[i].attrib &= ~(0x30);
+			addrWinMap[i].attrib |= 0x30;
+		}
+#endif
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08llx.\n", i,
+			   addrWinMap[i].addrWin.baseLow,
+			   addrWinMap[i].addrWin.size);
+	}
+
+	halData.portMask = portMask;
+	halData.cpuMask = cpuMask;
+	halData.maxPort = mvCtrlEthMaxPortGet();
+	halData.pClk = mvCpuPclkGet();
+	halData.tClk = mvBoardTclkGet();
+	halData.maxCPUs = mvCtrlEthMaxCPUsGet();
+	halData.iocc = arch_is_coherent();
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+#ifdef CONFIG_MV_ETH_BM
+	halData.bmPhysBase = PNC_BM_PHYS_BASE;
+	halData.bmVirtBase = (MV_U8 *) ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_BM */
+
+#ifdef CONFIG_MV_ETH_PNC
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *) ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_PNC */
+
+	for (port = 0; port < halData.maxPort; port++) {
+		if (!(MV_BIT_CHECK(portMask, port)))
+			continue;
+
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE)
+			continue;
+
+		mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port),
+				  !mvBoardIsPortInGmii(port));
+		status = mvNetaWinInit(port, addrWinMap);
+		if (status != MV_OK)
+			continue;
+	}
+	mvNetaHalInit(&halData);
+
+	return;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysNetaApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysNetaApi.h
new file mode 100644
index 0000000..be0aaa0
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysNetaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_NETA_API_H__
+#define __MV_SYS_NETA_API_H__
+
+
+void mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask);
+
+#endif /* __MV_SYS_NETA_API_H__ */
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.c
new file mode 100644
index 0000000..588c297
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.c
@@ -0,0 +1,1343 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysPci.h"
+#include "ddr2_3/mvDramIf.h"
+
+/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
+/* register offsets	and its function where its is located.			*/
+/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
+/* describes address remap register offsets					*/
+typedef struct _pciBarRegInfo {
+	MV_U32 funcNum;
+	MV_U32 baseLowRegOffs;
+	MV_U32 baseHighRegOffs;
+	MV_U32 sizeRegOffs;
+	MV_U32 remapLowRegOffs;
+	MV_U32 remapHighRegOffs;
+} PCI_BAR_REG_INFO;
+
+typedef struct _pciBarStatus {
+	MV_PCI_BAR bar;
+	int enable;
+} PCI_BAR_STATUS;
+
+PCI_BAR_STATUS pciBarStatusMap[] = {
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	{CS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	{CS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	{CS2_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	{CS3_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	{DEVCS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	{DEVCS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	{DEVCS2_BAR, EN},
+#endif
+	{BOOTCS_BAR, EN},
+	{MEM_INTER_REGS_BAR, EN},
+	{IO_INTER_REGS_BAR, EN},
+	{P2P_MEM0, DIS},
+	{P2P_IO, DIS},
+	{TBL_TERM, TBL_TERM}
+};
+
+/* PCI BAR table. Note that table entry number must match its target		*/
+/* enumerator. For example, table entry '4' must describe Deivce CS0		*/
+/* target which is represent by DEVICE_CS0 enumerator (4).                  */
+#if 0
+MV_PCI_BAR_WIN pciBarMap[] = {
+/*     base low      base high      size        enable/disable				*/
+	{{SDRAM_CS0_BASE, 0, SDRAM_CS0_SIZE}, EN},
+	{{SDRAM_CS1_BASE, 0, SDRAM_CS1_SIZE}, EN},
+	{{SDRAM_CS2_BASE, 0, SDRAM_CS2_SIZE}, EN},
+	{{SDRAM_CS3_BASE, 0, SDRAM_CS3_SIZE}, EN},
+	{{DEVICE_CS0_BASE, 0, DEVICE_CS0_SIZE}, EN},
+	{{DEVICE_CS1_BASE, 0, DEVICE_CS1_SIZE}, EN},
+	{{DEVICE_CS2_BASE, 0, DEVICE_CS2_SIZE}, EN},
+	{{BOOTDEV_CS_BASE, 0, BOOTDEV_CS_SIZE}, EN},
+	{{INTER_REGS_VIRT_BASE, 0, INTER_REGS_SIZE}, EN},
+	{{INTER_REGS_VIRT_BASE, 0, INTER_REGS_SIZE}, EN},
+	{{0xFFFFFFFF, 0, 0xFFFFFFFF}, DIS},	/* Ignore P2P   */
+	{{0xFFFFFFFF, 0, 0xFFFFFFFF}, DIS},	/* Ignore P2P   */
+	/* Table terminator */
+	{{TBL_TERM, TBL_TERM, TBL_TERM}, TBL_TERM}
+};
+#endif
+
+/* Locals */
+static MV_U32 pciBurstBytes2Reg(MV_U32 size);
+static MV_U32 pciBurstReg2Bytes(MV_U32 size);
+
+static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar,
+				     MV_ADDR_WIN *pAddrWin);
+
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, MV_PCI_BAR bar,
+				  PCI_BAR_REG_INFO *pBarRegInfo);
+
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
+
+/* Forward declarations */
+const MV_8 *pciBarNameGet(MV_PCI_BAR bar);
+
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*       This function initiate the PCI interface:
+*       1) Set local bus number. In case of convential PCI it gets the bus
+*          number using mvPciLocalBusNumGet(). In case of PCI-X this
+*          information is read only.
+*       2) Interface device number. In case of conventional PCI it gets the
+*          device number using mvPciLocalDevNumGet(). In case of PCI-X this
+*          information is read only.
+*       3) PCI Arbiter if needed.
+*       4) Enable Master and Slave on PCI interfaces.
+*	5) Open PCI BARs according to default setting.
+*	   Note that PCI bridge (P2P) is NOT initialized.
+*	6) Enable CPU to PCI ordering.
+*
+* INPUT:
+*
+*       pciIf   - PCI interface number.
+*		localBus - Local Bus of the PCI interface to be set
+*		localDev - Local Dev of the PCI interface to be set
+*		bFirstCall - Indicates wether this is the first call of this
+*					 function .
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
+{
+	MV_PCI_BAR bar, barix = 0;
+	MV_PCI_MODE pciMode;
+	MV_PCI_PROT_WIN pciProtWin;
+	MV_PCI_BAR_WIN pciBarMap[PCI_MAX_BARS];
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_TARGET target;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/* Parameter checking  */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	/* device and bus numbers */
+	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
+		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
+		return MV_ERROR;
+	}
+
+	/* First disable all PCI target windows  */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++)
+		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+
+	/* WA CQ 4382 */
+	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BIT15);
+
+	/* Loop over all BARs and copy enabled SDRAM windows only */
+	if (MV_OK != mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1)) {
+		mvOsPrintf("mvPciInit: ERR. mvCtrlAddrWinMapBuild failed\n");
+		return MV_ERROR;
+	}
+
+	for (target = SDRAM_CS0; target <= SDRAM_CS3; target++) {
+		addrDecWin = &addrWinMap[target];
+		if (addrDecWin->enable == MV_TRUE) {
+			pciBarMap[barix].addrWin.baseLow =
+			    addrDecWin->addrWin.baseLow;
+			pciBarMap[barix].addrWin.baseHigh =
+			    addrDecWin->addrWin.baseHigh;
+			pciBarMap[barix].addrWin.size =
+			    addrDecWin->addrWin.size;
+			pciBarMap[barix].enable = EN;
+			barix++;
+		}
+	}
+
+	/* Initialize all non used BARs */
+	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
+		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
+		pciBarMap[bar].addrWin.baseHigh = 0;
+		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
+		pciBarMap[bar].enable = DIS;
+	}
+
+	/* finally fill table with TBL_TERM entry */
+	bar = PCI_MAX_BARS - 1;
+	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
+	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
+	pciBarMap[bar].addrWin.size = TBL_TERM;
+	pciBarMap[bar].enable = TBL_TERM;
+
+	/* Memory Mapped Internal Registers BAR can not be disabled.            */
+	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
+	if (MV_OK !=
+	    mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR,
+			      &pciBarMap[MEM_INTER_REGS_BAR])) {
+		mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	/* Now, go through all targets in default table until table terminator  */
+	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++) {
+		/* Skip the P2P BARs. They should be configured seperately                      */
+		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
+			continue;
+
+		/* check if the size passed is zero ! */
+		if (0 == pciBarMap[bar].addrWin.size) {
+			/* disable the bar */
+			mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+			continue;
+		}
+
+		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
+			mvOsPrintf
+			    ("mvPciInit: ERR. mvPciTargetWinSet %d failed\n",
+			     bar);
+			return MV_ERROR;
+		}
+	}
+
+	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf),
+		       PADCR_REMAP_REG_WR_DIS);
+
+	/* configure access control unit 0 to DDR to enhance performance */
+	pciProtWin.addrWin.baseLow = 0;
+	pciProtWin.addrWin.baseHigh = 0;
+	pciProtWin.addrWin.size = mvDramIfSizeGet();
+#ifdef AURORA_IO_CACHE_COHERENCY
+	pciProtWin.attributes.snoop = WT_CACHE_COHER;
+#else
+	pciProtWin.attributes.snoop = NO_CACHE_COHER;
+#endif
+	pciProtWin.attributes.access = ALLOWED;
+	pciProtWin.attributes.write = ALLOWED;
+	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
+	pciProtWin.attributes.readMaxBurst = 128;
+	pciProtWin.attributes.readBurst = 256;
+	pciProtWin.attributes.writeMaxBurst = 128;
+	pciProtWin.attributes.pciOrder = MV_FALSE;
+	pciProtWin.enable = MV_TRUE;
+	if (mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK) {
+		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	mvPciHalInit(pciIf, pciIfmod);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
+*
+* DESCRIPTION:
+*       This function sets an address window from PCI to a peripheral
+*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs.
+*       A new PCI BAR window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing PCI to access
+*       the target window.
+*
+* INPUT:
+*       pciIf       - PCI interface number.
+*       bar         - BAR to be accessed by slave.
+*       pAddrBarWin - PCI target window information data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params
+*       MV_ERROR otherwise
+*       (e.g. address window overlapps with other active PCI target window).
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf,
+			    MV_PCI_BAR bar, MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 pciData;
+	MV_U32 sizeToReg;
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	size = pAddrBarWin->addrWin.size;
+	baseLow = pAddrBarWin->addrWin.baseLow;
+	baseHigh = pAddrBarWin->addrWin.baseHigh;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n",
+			   pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* if the address windows is disabled , we only disable the appropriare
+	   pci bar and ignore other settings */
+
+	if (MV_FALSE == pAddrBarWin->enable) {
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf),
+			       BARER_ENABLE(bar));
+		return MV_OK;
+	}
+
+	if (0 == pAddrBarWin->addrWin.size) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n",
+			   bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec                                                   */
+	if (MV_TRUE != pciWinIsValid(baseLow, size)) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n",
+			   bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows           */
+	if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin)) {
+		mvOsPrintf
+		    ("mvPciTargetWinSet: ERR. Overlap detected for target %d\n",
+		     bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Get size register value according to window size                                             */
+	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
+
+	/* Size parameter validity check.                                   */
+	if (-1 == sizeToReg) {
+		mvOsPrintf
+		    ("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n",
+		     bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Internal register space size have no size register. Do not perform   */
+	/* size register assigment for this slave target                                                */
+	if (0 != barRegInfo.sizeRegOffs) {
+		/* Update size register */
+		MV_REG_WRITE(barRegInfo.sizeRegOffs,
+			     (sizeToReg << BAR_SIZE_OFFS));
+	}
+
+	/* Read current address */
+	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+				  barRegInfo.baseLowRegOffs);
+
+	/* Clear current address */
+	pciData &= ~PBBLR_BASE_MASK;
+	pciData |= (baseLow & PBBLR_BASE_MASK);
+
+	/* Write new address */
+	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+			 barRegInfo.baseLowRegOffs, pciData);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)                */
+	if (0 != barRegInfo.baseHighRegOffs) {
+		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+				 barRegInfo.baseHighRegOffs, baseHigh);
+	}
+
+	/* Enable/disable the BAR */
+	if (MV_TRUE == pAddrBarWin->enable) {
+		MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf),
+				 BARER_ENABLE(bar));
+	} else {
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf),
+			       BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinGet - Get PCI to peripheral target address window
+*
+* DESCRIPTION:
+*		Get the PCI to peripheral target address window BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*       bar   - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       pAddrBarWin - PCI target window information data structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR bar,
+			    MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	MV_U32 barEnable;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n",
+			   pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n",
+			   bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Reading Base Low bar */
+	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+				  barRegInfo.baseLowRegOffs);
+
+	baseLow &= PBBLR_BASE_MASK;
+
+	/* Skip base high if the BAR has only base low (32-bit)         */
+	if (0 != barRegInfo.baseHighRegOffs) {
+		/* Reading Base High */
+		baseHigh =
+		    mvPciConfigRead(pciIf, localBus, localDev,
+				    barRegInfo.funcNum,
+				    barRegInfo.baseHighRegOffs);
+	} else {
+		baseHigh = 0;
+	}
+
+	/* Internal register space size have no size register. Do not perform       */
+	/* size register assigment for this slave target                                                */
+	if (0 != barRegInfo.sizeRegOffs) {
+		/* Reading bar size */
+		size = ctrlRegToSize((MV_REG_READ(barRegInfo.sizeRegOffs) >>
+				      PBSR_SIZE_OFFS), PBBLR_BASE_ALIGNMET);
+	} else {
+		size = INTER_REGS_SIZE;
+	}
+
+	/* Assign value to user struct */
+	pAddrBarWin->addrWin.baseLow = baseLow;
+	pAddrBarWin->addrWin.baseHigh = baseHigh;
+	pAddrBarWin->addrWin.size = size;
+
+	/* Check if window is enabled   */
+	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	if (~barEnable & (BARER_ENABLE(bar)))
+		pAddrBarWin->enable = MV_TRUE;
+	else
+		pAddrBarWin->enable = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinEnable - Enable/disable a PCI BAR window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI BAR window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling PCI accesses for that BAR (before enabling the
+*       window it is tested for overlapping). Otherwise, the window will
+*       be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       bar    - BAR to be accessed by slave.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, MV_PCI_BAR bar, MV_BOOL enable)
+{
+	MV_PCI_BAR_WIN barWin;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf
+		    ("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n",
+		     pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n",
+			   bar);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TRUE == enable) {	/* First check for overlap with other enabled windows */
+		/* Get current window */
+		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin)) {
+			mvOsPrintf
+			    ("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+
+		/* Check for overlapping */
+		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin)) {
+			/* Overlap detected */
+			mvOsPrintf
+			    ("mvPciTargetWinEnable: ERR. Overlap detected\n");
+			return MV_ERROR;
+		} else {
+			/* No Overlap. Enable address decode target window              */
+			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf),
+					 BARER_ENABLE(bar));
+		}
+	} else {
+		/* Disable address decode target window                             */
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf),
+			       BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciProtWinSet - Set PCI protection access window
+*
+* DESCRIPTION:
+*       This function sets a specified address window with access protection
+*       attributes. If protection structure enables the window the routine will
+*       also enable the protection window.
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - Protection window structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf,
+			  MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n",
+			   pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n",
+			   winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec                                                   */
+	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow,
+				     pProtWin->addrWin.size)) {
+		mvOsPrintf
+		    ("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
+		     pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
+
+		return MV_BAD_PARAM;
+	}
+
+	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
+			   pProtWin->attributes.swapType);
+		return MV_BAD_PARAM;
+
+	}
+
+	/* 1) Calculate protection window base low register value       */
+	protBaseLow = pProtWin->addrWin.baseLow;
+
+	/* Setting the appropriate bits according to the passed values */
+	if (MV_TRUE == pProtWin->enable)
+		protBaseLow |= PACBLR_EN;
+	else
+		protBaseLow &= ~PACBLR_EN;
+
+	/* I/O Cache Coherency */
+	protBaseLow |=
+	    ((MV_U32) pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
+
+	/* Access protect */
+	if (ALLOWED == pProtWin->attributes.access)
+		protBaseLow &= ~PACBLR_ACCPROT;
+	else
+		protBaseLow |= PACBLR_ACCPROT;
+
+	/* Write Protect */
+	if (ALLOWED == pProtWin->attributes.write)
+		protBaseLow &= ~PACBLR_WRPROT;
+	else
+		protBaseLow |= PACBLR_WRPROT;
+
+	/* PCI slave Data Swap Control */
+	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
+
+	/* Read Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) <<
+	     PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
+		return MV_ERROR;
+	}
+	protBaseLow |=
+	    (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) <<
+	     PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. Only valid for PCI conventional */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) <<
+	     PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
+		return MV_ERROR;
+	}
+	protBaseLow |=
+	    (pciBurstBytes2Reg(pProtWin->attributes.readBurst) <<
+	     PACBLR_RDSIZE_OFFS);
+
+	/* 2) Calculate protection window base high register value      */
+	protBaseHigh = pProtWin->addrWin.baseHigh;
+
+	/* 3) Calculate protection window size register value   */
+	protSize =
+	    ctrlSizeToReg(pProtWin->addrWin.size,
+			  PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
+
+	/* Write Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) <<
+	     PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
+		return MV_ERROR;
+	}
+	protSize |=
+	    (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) <<
+	     PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (MV_TRUE == pProtWin->attributes.pciOrder)
+		protSize |= PACSR_PCI_ORDERING;
+	else
+		protSize &= ~PACSR_PCI_ORDERING;
+
+	/* Writing protection window walues into registers */
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), protBaseLow);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum), protBaseHigh);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum), protSize);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciProtWinGet - Get PCI protection access window
+*
+* DESCRIPTION:
+*       This function gets a specified address window and access protection
+*       attributes for a specific protection window .
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - pointer to a Protection window structure.
+*
+* OUTPUT:
+*       pProtWin - Protection window structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf,
+			  MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n",
+			   pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN) {
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n",
+			   winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Writing protection window walues into registers */
+	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum));
+	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum));
+	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum));
+
+	/* 1) Get Protection Windows base low   */
+	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
+
+	/* Get the appropriate protection attributes according to register bits */
+
+	/* Is Windows enabled ? */
+	if (protBaseLow & PACBLR_EN)
+		pProtWin->enable = MV_TRUE;
+	else
+		pProtWin->enable = MV_FALSE;
+
+	/* What is access protect ? */
+	if (protBaseLow & PACBLR_ACCPROT)
+		pProtWin->attributes.access = FORBIDDEN;
+	else
+		pProtWin->attributes.access = ALLOWED;
+
+	/* Is write protect ? */
+	if (protBaseLow & PACBLR_WRPROT)
+		pProtWin->attributes.write = FORBIDDEN;
+	else
+		pProtWin->attributes.write = ALLOWED;
+
+	/* PCI slave Data Swap Control */
+	pProtWin->attributes.swapType =
+	    (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
+
+	/* Read Max Burst */
+	pProtWin->attributes.readMaxBurst =
+	    pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >>
+			      PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. */
+	pProtWin->attributes.readBurst =
+	    pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >>
+			      PACBLR_RDSIZE_OFFS);
+
+	/* window base high register value      */
+	pProtWin->addrWin.baseHigh = protBaseHigh;
+
+	/*Calculate protection window size register value       */
+	pProtWin->addrWin.size =
+	    ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS),
+			  PACSR_SIZE_ALIGNMENT);
+
+	/* Write Max Burst */
+	pProtWin->attributes.writeMaxBurst =
+	    pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >>
+			      PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (protSize & PACSR_PCI_ORDERING)
+		pProtWin->attributes.pciOrder = MV_TRUE;
+	else
+		pProtWin->attributes.pciOrder = MV_FALSE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciProtWinEnable - Enable/disable a PCI protection access window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI protection access window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       protection window, otherwise, the protection window will be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       winNum - Protecion window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf
+		    ("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n",
+		     pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN) {
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n",
+			   winNum);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TRUE == enable) {
+		MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum),
+			       PACBLR_EN);
+	} else {
+		MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum),
+				 PACBLR_EN);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetRemap - Set PCI to target address window remap.
+*
+* DESCRIPTION:
+*       The PCI interface supports remap of the BAR original address window.
+*       For each BAR it is possible to define a remap address. For example
+*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
+*       according to remap register but will also be targeted to the
+*       SDRAM CS[0].
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       bar      - Peripheral target enumerator accessed by slave.
+*       pAddrWin - Address window to be checked.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, MV_PCI_BAR bar, MV_ADDR_WIN *pAddrWin)
+{
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf
+		    ("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n",
+		     pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT)) {
+		mvOsPrintf
+		    ("mvPciTargetRemap: Error remapping PCI interface %d bar %s."
+		     "\nAddress 0x%08x is unaligned to size 0x%llx.\n", pciIf,
+		     pciBarNameGet(bar), pAddrWin->baseLow, pAddrWin->size);
+		return MV_ERROR;
+	}
+
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Set remap low register value */
+	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)                */
+	if (0 != barRegInfo.remapHighRegOffs)
+		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciWinOverlapDetect - Detect address windows overlapping
+*
+* DESCRIPTION:
+*       This function detects address window overlapping of a given address
+*       window in PCI BARs.
+*
+* INPUT:
+*       pAddrWin - Address window to be checked.
+*       bar      - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar,
+				   MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 barEnableReg;
+	MV_U32 targetBar;
+	MV_PCI_BAR_WIN barAddrWin;
+
+	/* Read base address enable register. Do not check disabled windows             */
+	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	for (targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
+		/* don't check our target or illegal targets */
+		if (targetBar == bar)
+			continue;
+
+		/* Do not check disabled windows        */
+		if (barEnableReg & (BARER_ENABLE(targetBar)))
+			continue;
+
+		/* Get window parameters        */
+		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
+			mvOsPrintf
+			    ("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+
+		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR */
+		if (((bar == MEM_INTER_REGS_BAR)
+		     && (targetBar == IO_INTER_REGS_BAR))
+		    || ((bar == IO_INTER_REGS_BAR)
+			&& (targetBar == MEM_INTER_REGS_BAR))) {
+			return MV_FALSE;
+		} else if (MV_TRUE ==
+			   mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {
+			mvOsPrintf
+			    ("pciWinOverlapDetect: BAR %d overlap current %d\n",
+			     bar, targetBar);
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* cpuWinIsValid - Check if the given address window is valid
+*
+* DESCRIPTION:
+*		PCI spec restrict BAR base to be aligned to BAR size.
+*		This function checks if the given address window is valid.
+*
+* INPUT:
+*       baseLow - 32bit low base address.
+*       size    - Window size.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
+{
+
+	/* PCI spec restrict BAR base to be aligned to BAR size                                 */
+	if (MV_IS_NOT_ALIGN(baseLow, size))
+		return MV_ERROR;
+	else
+		return MV_TRUE;
+}
+
+/*******************************************************************************
+* pciBarRegInfoGet - Get BAR register information
+*
+* DESCRIPTION:
+*		PCI BARs registers offsets are inconsecutive.
+*		This function gets a PCI BAR register information like register offsets
+*		and function location of the BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*		bar	  - The PCI BAR in question.
+*
+* OUTPUT:
+*       pBarRegInfo - BAR register info struct.
+*
+* RETURN:
+*		MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
+*
+*******************************************************************************/
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf,
+				  MV_PCI_BAR bar,
+				  PCI_BAR_REG_INFO *pBarRegInfo)
+{
+	switch (bar) {
+		/* Function 0 Bars */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	case CS0_BAR:		/* SDRAM chip select 0 bar */
+		pBarRegInfo->funcNum = 0;
+		pBarRegInfo->baseLowRegOffs = PCI_SCS0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_SCS0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_CS0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_CS0_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	case CS1_BAR:		/* SDRAM chip select 1 bar */
+		pBarRegInfo->funcNum = 0;
+		pBarRegInfo->baseLowRegOffs = PCI_SCS1_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_SCS1_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_CS1_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_CS1_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+	case MEM_INTER_REGS_BAR:	/* Memory Mapped Internal bar */
+		pBarRegInfo->funcNum = 0;
+		pBarRegInfo->baseLowRegOffs =
+		    PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
+		pBarRegInfo->baseHighRegOffs =
+		    PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
+		pBarRegInfo->sizeRegOffs = 0;
+		pBarRegInfo->remapLowRegOffs = 0;
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+
+		/* Function 1 Bars */
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	case CS2_BAR:		/* SDRAM chip select 2 bar */
+		pBarRegInfo->funcNum = 1;
+		pBarRegInfo->baseLowRegOffs = PCI_SCS2_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_SCS2_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_CS2_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_CS2_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	case CS3_BAR:		/* SDRAM chip select 3 bar */
+		pBarRegInfo->funcNum = 1;
+		pBarRegInfo->baseLowRegOffs = PCI_SCS3_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_SCS3_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_CS3_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_CS3_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+		/* Function 2 Bars */
+	case DEVCS0_BAR:	/* Device chip select 0 bar */
+		pBarRegInfo->funcNum = 2;
+		pBarRegInfo->baseLowRegOffs = PCI_DEVCS0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_DEVCS0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_DEVCS0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	case DEVCS1_BAR:	/* Device chip select 0 bar */
+		pBarRegInfo->funcNum = 2;
+		pBarRegInfo->baseLowRegOffs = PCI_DEVCS1_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_DEVCS1_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_DEVCS1_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	case DEVCS2_BAR:	/* Device chip select 0 bar */
+		pBarRegInfo->funcNum = 2;
+		pBarRegInfo->baseLowRegOffs = PCI_DEVCS2_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_DEVCS2_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_DEVCS2_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+#endif
+	case BOOTCS_BAR:	/* Boot device chip select bar */
+		pBarRegInfo->funcNum = 3;
+		pBarRegInfo->baseLowRegOffs = PCI_BOOTCS_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_BOOTCS_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_BOOTCS_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+
+		/* Function 4 Bars */
+	case P2P_MEM0:		/* P2P memory 0 */
+		pBarRegInfo->funcNum = 4;
+		pBarRegInfo->baseLowRegOffs = PCI_P2P_MEM0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs = PCI_P2P_MEM0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs = PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs =
+		    PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs =
+		    PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
+		break;
+	case P2P_IO:		/* P2P IO */
+		pBarRegInfo->funcNum = 4;
+		pBarRegInfo->baseLowRegOffs = PCI_P2P_IO_BASE_ADDR;
+		pBarRegInfo->baseHighRegOffs = 0;
+		pBarRegInfo->sizeRegOffs = PCI_P2P_IO_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs = PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+	case IO_INTER_REGS_BAR:	/* IO Mapped Internal bar */
+		pBarRegInfo->funcNum = 4;
+		pBarRegInfo->baseLowRegOffs =
+		    PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
+		pBarRegInfo->baseHighRegOffs = 0;
+		pBarRegInfo->sizeRegOffs = 0;
+		pBarRegInfo->remapLowRegOffs = 0;
+		pBarRegInfo->remapHighRegOffs = 0;
+		break;
+
+	default:
+		mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
+		return MV_ERROR;
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciBarNameGet - Get the string name of PCI BAR.
+*
+* DESCRIPTION:
+*		This function get the string name of PCI BAR.
+*
+* INPUT:
+*       bar - PCI bar number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       pointer to the string name of PCI BAR.
+*
+*******************************************************************************/
+const MV_8 *pciBarNameGet(MV_PCI_BAR bar)
+{
+	switch (bar) {
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	case CS0_BAR:
+		return "CS0_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	case CS1_BAR:
+		return "CS1_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	case CS2_BAR:
+		return "CS2_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	case CS3_BAR:
+		return "CS3_BAR..............";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	case DEVCS0_BAR:
+		return "DEVCS0_BAR...........";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	case DEVCS1_BAR:
+		return "DEVCS1_BAR...........";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	case DEVCS2_BAR:
+		return "DEVCS2_BAR...........";
+#endif
+	case BOOTCS_BAR:
+		return "BOOTCS_BAR...........";
+	case MEM_INTER_REGS_BAR:
+		return "MEM_INTER_REGS_BAR...";
+	case IO_INTER_REGS_BAR:
+		return "IO_INTER_REGS_BAR....";
+	case P2P_MEM0:
+		return "P2P_MEM0.............";
+	case P2P_IO:
+		return "P2P_IO...............";
+	default:
+		return "target unknown";
+	}
+}
+
+/*******************************************************************************
+* mvPciAddrDecShow - Print the PCI address decode map (BARs).
+*
+* DESCRIPTION:
+*		This function print the PCI address decode map (BARs).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvPciAddrDecShow(MV_VOID)
+{
+	MV_PCI_BAR_WIN win;
+	MV_PCI_BAR bar;
+	MV_U32 pciIf;
+
+	for (pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++) {
+		mvOsOutput("\n");
+		mvOsOutput("PCI%d:\n", pciIf);
+		mvOsOutput("-----\n");
+
+		for (bar = 0; bar < PCI_MAX_BARS; bar++) {
+			memset(&win, 0, sizeof(MV_PCI_BAR_WIN));
+
+			mvOsOutput("%s ", pciBarNameGet(bar));
+
+			if (mvPciTargetWinGet(pciIf, bar, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("base %08x, ",
+						   win.addrWin.baseLow);
+					mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+}
+
+/* convert burst bytes to register value*/
+static MV_U32 pciBurstBytes2Reg(MV_U32 size)
+{
+	MV_U32 ret;
+	switch (size) {
+	case 32:
+		ret = 0;
+		break;
+	case 64:
+		ret = 1;
+		break;
+	case 128:
+		ret = 2;
+		break;
+	case 256:
+		ret = 3;
+		break;
+	default:
+		ret = 0xF;	/* error */
+	}
+	return ret;
+}
+
+/* convert register value to burst bytes*/
+static MV_U32 pciBurstReg2Bytes(MV_U32 size)
+{
+	MV_U32 ret;
+	switch (size) {
+	case 0:
+		ret = 32;
+		break;
+	case 1:
+		ret = 64;
+		break;
+	case 2:
+		ret = 128;
+		break;
+	case 3:
+		ret = 256;
+		break;
+	default:
+		ret = 0x0;	/* error */
+	}
+	return ret;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.h
new file mode 100644
index 0000000..c048bc5
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysPci.h
@@ -0,0 +1,261 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCSysPCIH
+#define __INCSysPCIH
+
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "pci/mvPci.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvSysPciConfig.h"
+
+#define PCI_MAX_PROT_WIN			6
+
+/* 4KB granularity */
+#define MINIMUM_WINDOW_SIZE			0x1000
+#define MINIMUM_BAR_SIZE			0x1000
+#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
+#define BAR_SIZE_OFFS				12
+#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
+
+#define PCI_IO_WIN_NUM				1	/* Number of PCI_IO windows  */
+#define PCI_MEM_WIN_NUM				4	/* Number of PCI_MEM windows */
+
+#ifndef MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvLib.h"
+typedef enum _mvPCIBars {
+	PCI_BAR_TBL_TERM = -1,	/* none valid bar, used as bars list terminator */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	CS0_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	CS1_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	CS2_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	CS3_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEVCS0_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEVCS1_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEVCS2_BAR,
+#endif
+	BOOTCS_BAR,		/* Boot device chip select bar */
+	MEM_INTER_REGS_BAR,	/* Memory Mapped Internal bar */
+	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
+	P2P_MEM0,		/* P2P memory 0 */
+	P2P_IO,			/* P2P IO */
+	PCI_MAX_BARS
+} MV_PCI_BAR;
+#endif /* MV_ASMLANGUAGE */
+
+#if defined(MV_INCLUDE_SDRAM_CS3)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS3_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS2)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS1)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS0)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
+#endif
+
+/****************************************/
+/* PCI Slave Address Decoding registers */
+/****************************************/
+#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
+#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
+#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
+#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
+#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80))
+#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80))
+#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80))
+#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80))
+#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80))
+#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80))
+#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
+#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
+#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
+
+/* PCI Bars Size Registers (PBSR) */
+#define PBSR_SIZE_OFFS				12
+#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
+
+/* Base Address Registers Enable Register (BARER) */
+#define BARER_ENABLE(target)			(1 << (target))
+
+/* PCI Base Address Remap Registers (PBARR) */
+#define PBARR_REMAP_OFFS			12
+#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
+#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
+
+/* PCI DRAM Bar Bank Select Register (PDBBSR) */
+#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
+#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
+
+/* PCI Address Decode Control Register (PADCR)*/
+#define PADCR_REMAP_REG_WR_DIS			BIT0
+#define PADCR_MSG_REG_ACC			BIT3
+
+#define PADCR_VPD_HIGH_ADDR_OFFS		8	/* Bits [31:15] of the VPD address */
+#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
+
+/* PCI Headers Retarget Control Register (PHRCR) */
+#define PHRCR_ENABLE				BIT0
+#define PHRCR_BUFF_SIZE_OFFS			1
+#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_MASK1_OFFS			16
+#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
+
+/* PCI Headers Retarget Base Register (PHRBR) */
+#define PHRBR_BASE_OFFS				16
+#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
+
+/* PCI Headers Retarget Base High Register (PHRBHR) */
+#define PHRBHR_BASE_OFFS			0
+#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
+
+/* This structure describes a PCI BAR. It is also refered as PCI target     */
+/* window to keep consistency with other address decode units in the system */
+typedef struct _mvPciBarWin {
+	MV_ADDR_WIN addrWin;	/* Address window       */
+	MV_BOOL enable;		/* BAR enable/disable   */
+} MV_PCI_BAR_WIN;
+
+typedef enum {
+	NO_CACHE_COHER = 0,
+	WT_CACHE_COHER,
+	WB_CACHE_COHER
+} MV_PCI_SNOOP;
+
+/* This structure describes PCI region attributes                           */
+typedef struct _mvPciRegionAttr {
+	MV_PCI_SNOOP snoop;	/* Cache Coherenc                       */
+	MV_PROT_RIGHT access;	/* Access protection                    */
+	MV_PROT_RIGHT write;	/* Write protection                     */
+	MV_SWAP_TYPE swapType;	/* Data swap mode for that region       */
+	MV_U32 readMaxBurst;	/* Read max burst                       */
+	MV_U32 readBurst;	/* Read burst. Conventional PCI only    */
+	MV_U32 writeMaxBurst;	/* Write max burst                      */
+	MV_BOOL pciOrder;	/* Hardware support for PCI ordering    */
+} MV_PCI_REGION_ATTR;
+
+/* The PCI slave interface supports configurable access control.            */
+/* It is possible to define up to six address ranges to different           */
+/* configurations. This structure describes the PCI access region           */
+typedef struct _mvPciProtWin {
+	MV_ADDR_WIN addrWin;	/* An address window                    */
+	MV_PCI_REGION_ATTR attributes;	/* Window attributes                    */
+	MV_BOOL enable;		/* Window enabled/disabled              */
+} MV_PCI_PROT_WIN;
+
+/* Global Functions prototypes */
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, MV_PCI_BAR slaveTarget,
+			    MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR slaveTarget,
+			    MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, MV_PCI_BAR slaveTarget,
+			       MV_BOOL enable);
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum,
+			  MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum,
+			  MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, MV_PCI_BAR slaveTarget,
+			   MV_ADDR_WIN *pAddrWin);
+MV_VOID mvPciAddrDecShow(MV_VOID);
+
+/* External Functions prototypes */
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysPex.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysPex.c
new file mode 100644
index 0000000..26fc8a1
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysPex.c
@@ -0,0 +1,98 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
+{
+	MV_PEX_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+	if (mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1) != MV_OK) {
+		mvOsPrintf("%s: mvCtrlAddrWinMapBuild failed\n", __func__);
+		return MV_FAIL;
+	}
+
+	if (mvPexWinInit(pexIf, pexType, addrWinMap) != MV_OK) {
+		mvOsPrintf("%s: mvPexWinInit failed\n", __func__);
+		return MV_FAIL;
+	}
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+	halData.maxPexIf = mvCtrlPexMaxIfGet();
+
+	if (mvPexInit(pexIf, pexType, &halData) != MV_OK) {
+		mvOsPrintf("%s: mvPexInit(pexIf = %d) failed\n", __func__,
+			   pexIf);
+		return MV_FAIL;
+	}
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysPexApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysPexApi.h
new file mode 100644
index 0000000..637eb5d
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysPexApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_PEX_API_H__
+#define __MV_SYS_PEX_API_H__
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysSFlash.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysSFlash.c
new file mode 100644
index 0000000..55506be
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysSFlash.c
@@ -0,0 +1,225 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "sflash/mvSysSFlash.h"
+
+#define MV_SYS_SFLASH_MAX_CMD_LEN 4
+
+static struct {
+	MV_U8 buf[MV_SYS_SFLASH_MAX_CMD_LEN];
+	MV_U32 bufLen;
+	MV_U8 transType;
+} mvSysSflashCmd;
+
+/*******************************************************************************
+* mvSysSflashCommandSet
+*
+* DESCRIPTION:
+*	System interface for sending a command to the SPI flash.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	cmdBuff:     Command data to be written.
+*	cmdLen:	     Command length in bytes.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashCommandSet(MV_VOID *flashHandle, MV_U8 *cmdBuff,
+				MV_U32 cmdLen, MV_U8 transType)
+{
+	if (cmdLen > MV_SYS_SFLASH_MAX_CMD_LEN)
+		return MV_ERROR;
+
+	if (!(transType & SYS_SFLASH_TRANS_START)
+	    || (mvSysSflashCmd.transType != 0))
+		return MV_ERROR;
+
+	mvSpiParamsSet(0, 0, SPI_TYPE_FLASH);
+
+	memcpy(mvSysSflashCmd.buf, cmdBuff, cmdLen);
+	mvSysSflashCmd.bufLen = cmdLen;
+	mvSysSflashCmd.transType = transType;
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		return mvSysSflashDataWrite(flashHandle, NULL, 0, transType);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvSysSflashDataRead
+*
+* DESCRIPTION:
+*	System interface for reading SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer to read the data into.
+*	dataLen:     Number of bytes to read.
+*	dummyBytes:  Number of dummy bytes to read before reading the real
+*		     data.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	dataBuff: The data as read from flash.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataRead(MV_VOID *flashHandle, MV_U8 *dataBuff,
+			      MV_U32 dataLen, MV_U32 dummyBytes,
+			      MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenRead(0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+				 dataBuff, dataLen, dummyBytes);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd, 0, sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+/*******************************************************************************
+* mvSysSflashDataWrite
+*
+* DESCRIPTION:
+*	System interface for writing SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer holding the data to be written.
+*	dataLen:     Number of bytes to write.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataWrite(MV_VOID *flashHandle, MV_U8 *dataBuff,
+			       MV_U32 dataLen, MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret =
+	    mvSpiWriteThenWrite(0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+				dataBuff, dataLen);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd, 0, sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+/*******************************************************************************
+* mvSysSflashFreqSet
+*
+* DESCRIPTION:
+*	System interface for controlling the SPI interface frequency.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	freq:	     The new frequency to be configured for the SPI IF.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashFreqSet(MV_VOID *flashHandle, MV_U32 freq)
+{
+
+	return mvSpiBaudRateSet(0, freq);
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysSata.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysSata.c
new file mode 100644
index 0000000..43fb5b1
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysSata.c
@@ -0,0 +1,81 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "sata/CoreDriver/mvSata.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+MV_STATUS mvSysSataWinInit(MV_VOID)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status == MV_OK)
+		status = mvSataWinInit(addrWinMap);
+
+	return status;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysSataApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysSataApi.h
new file mode 100644
index 0000000..aff9ab6
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysSataApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SATA_API_H__
+#define __MV_SYS_SATA_API_H__
+
+MV_STATUS mvSysSataWinInit(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysSpi.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysSpi.c
new file mode 100644
index 0000000..b5cc22e
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysSpi.c
@@ -0,0 +1,123 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSysSpi.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+/*******************************************************************************
+* mvSysSpiInit - Initialize the SPI subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
+{
+	MV_SPI_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.tclk = mvBoardTclkGet();
+
+	return mvSpiInit(spiId, serialBaudRate, &halData);
+}
+
+/*******************************************************************************
+* mvSysSpiMppConfig
+*
+* DESCRIPTION:
+*	System interface for configuring the MPP's configuration to enable /
+*	disable SPI mode.
+*
+* INPUT:
+*	mode:	The mode to be set into MPP unit.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
+{
+#if 0
+	if (mode == SYS_SPI_MPP_ENABLE)
+		mvMPPConfigToSPI();
+	else
+		mvMPPConfigToDefault();
+#endif
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysSpiApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysSpiApi.h
new file mode 100644
index 0000000..17ac264
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysSpiApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SPI_API_H__
+#define __MV_SYS_SPI_API_H__
+
+MV_STATUS mvSysSpiInit(MV_U8 spi_id, MV_U32 serialBaudRate);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysTdm.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysTdm.c
new file mode 100644
index 0000000..91dd8c6
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysTdm.c
@@ -0,0 +1,242 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#ifdef CONFIG_MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+#include "voiceband/commUnit/mvCommUnit.h"
+#include "gpp/mvGpp.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "spi/mvSpi.h"
+
+#define MAX_DATA_LENGTH		255
+
+/*******************************************************************************
+* mvSysTdmInit - Initialize the TDM subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS *tdmParams)
+{
+	MV_TDM_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status == MV_OK)
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmWinInit(addrWinMap);
+#else
+		status = mvCommUnitWinInit(addrWinMap);
+#endif
+
+	if (status == MV_OK) {
+		halData.spiMode = mvBoardTdmSpiModeGet();
+		halData.model = mvCtrlModelGet();
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmHalInit(tdmParams, &halData);
+#else
+		halData.maxCs = mvBoardTdmDevicesCountGet();
+		status = mvCommUnitHalInit(tdmParams, &halData);
+
+		/* Issue SLIC reset */
+		mvGppValueSet(0, BIT24, 0);
+		mvOsDelay(1);
+		mvGppValueSet(0, BIT24, BIT24);
+#endif
+	}
+
+	return status;
+}
+
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize,
+			MV_U8 *dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if ((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH)) {
+		mvOsPrintf
+		    ("Error, exceeded max size of command(%d) or data(%d)\n",
+		     cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if (MV_OK !=
+	    mvSpiWriteThenRead(0, cmdBuff, cmdSize, dataBuff, dataSize, 0))
+		printk(KERN_INFO "SPI read failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmSpiWrite - telephony register write via SPI interface
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize,
+			 MV_U8 *dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if ((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH)) {
+		mvOsPrintf
+		    ("Error, exceeded max size of command(%d) or data(%d)\n",
+		     cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if (MV_OK !=
+	    mvSpiWriteThenWrite(0, cmdBuff, cmdSize, dataBuff, dataSize))
+		printk(KERN_INFO "SPI write failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmIntEnable - Enable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntEnable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntEnable(deviceId);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmIntDisable - Disable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntDisable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntDisable(deviceId);
+
+#endif
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysTdmApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysTdmApi.h
new file mode 100644
index 0000000..f54f17a
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysTdmApi.h
@@ -0,0 +1,78 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TDM_API_H__
+#define __MV_SYS_TDM_API_H__
+
+#include "mvSysTdmConfig.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+#include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS *tdmParams);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
new file mode 100644
index 0000000..9b25bc8
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsb.c
@@ -0,0 +1,116 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "usb/mvUsb.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "usb/mvUsbRegs.h"
+
+/*******************************************************************************
+* mvSysUsbHalInit - Initialize the USB subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	None
+* OUTPUT:
+*	None
+* RETURN:
+*	None
+*
+*******************************************************************************/
+MV_STATUS mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
+{
+	MV_USB_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	MV_BOOL usb3Init = 0;
+
+#ifndef CONFIG_ARMADA_380_USE_LEGACY_USB2
+	usb3Init = 1;
+#endif
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+	halData.ctrlRev = mvCtrlRevGet();
+
+	/*
+	 * For USB3 initialize only the UTMI PHY
+	 * For USB2 initialize the PHY and the controller
+	 */
+	if (usb3Init) {
+		status = mvUsbUtmiPhyInit(dev, &halData);
+	} else {
+		status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+		if (status == MV_OK)
+			status = mvUsbWinInit(dev, addrWinMap);
+
+		if (status == MV_OK)
+			status = mvUsbHalInit(dev, isHost, &halData);
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysUsbApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsbApi.h
new file mode 100644
index 0000000..7bb128d
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysUsbApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_USB_API_H__
+#define __MV_SYS_USB_API_H__
+
+MV_STATUS mvSysUsbInit(MV_U32 dev, MV_BOOL isHost);
+
+#endif
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysXor.c b/arch/arm/mach-armada38x/mv_hal_if/mvSysXor.c
new file mode 100644
index 0000000..bd2b079
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysXor.c
@@ -0,0 +1,91 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "xor/mvXor.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "xor/mvXorRegs.h"
+
+MV_VOID mvSysXorInit(void)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status, unit;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status == MV_OK)
+		status = mvXorWinInit(addrWinMap);
+
+	if (status == MV_OK) {
+		for (unit = 0; unit < MV_XOR_MAX_UNIT; unit++) {
+			if (mvUnitMapIsMine(XOR0 + unit))
+				mvXorHalInit(unit);
+		}
+	}
+
+	return;
+}
diff --git a/arch/arm/mach-armada38x/mv_hal_if/mvSysXorApi.h b/arch/arm/mach-armada38x/mv_hal_if/mvSysXorApi.h
new file mode 100644
index 0000000..37f5674
--- /dev/null
+++ b/arch/arm/mach-armada38x/mv_hal_if/mvSysXorApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_XOR_API_H__
+#define __MV_SYS_XOR_API_H__
+
+MV_VOID mvSysXorInit(void);
+
+#endif
diff --git a/arch/arm/mach-armada38x/pci.c b/arch/arm/mach-armada38x/pci.c
new file mode 100644
index 0000000..d979681
--- /dev/null
+++ b/arch/arm/mach-armada38x/pci.c
@@ -0,0 +1,240 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysPci.h"
+#include "pci/mvPci.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x)
+#endif
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+
+	if (mvCtrlPciMaxIfGet() > 1)
+		panic("Single PCI is supported ONLY!");
+
+	mvPciInit(0, MV_PCI_MOD_HOST);
+
+	/* I/O remmap */
+	win.baseLow = 0x0;
+	win.baseHigh = 0x0;
+	mvCpuIfPciRemap(PCI_IF0_IO, &win);
+}
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn,
+			       int where, int size, u32 *val)
+{
+
+	MV_U32 bus_num, func, regOff, dev_no, temp;
+	MV_U32 localBus;
+
+	*val = 0xffffffff;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPciLocalBusNumGet(0);
+	if ((dev_no == 0) && (bus_num == localBus)) {
+		DB(printk
+		   (KERN_INFO "PCI 0 read from our own dev return 0xffffffff\n"));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32) where & PCAR_REG_NUM_MASK;
+
+	if ((func == 0) && (dev_no < 2))
+		DB(printk
+		   ("PCI 0 read: bus = %x dev = %x func = %x regOff = %x ",
+		    bus_num, dev_no, func, regOff));
+
+	temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+
+	switch (size) {
+	case 1:
+		temp = (temp >> (8 * (where & 0x3))) & 0xff;
+		break;
+
+	case 2:
+		temp = (temp >> (8 * (where & 0x2))) & 0xffff;
+		break;
+
+	default:
+		break;
+	}
+
+	*val = temp;
+
+	if ((func == 0) && (dev_no < 2))
+		DB(printk(KERN_INFO " got %x\n", temp));
+
+	return 0;
+}
+
+static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 val)
+{
+	MV_U32 bus_num, func, regOff, dev_no, temp, mask, shift;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32) where & PCAR_REG_NUM_MASK;
+
+	DB(printk
+	   (KERN_INFO "PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x\n",
+	    val, size, bus_num, dev_no, func, regOff));
+	if (size != 4)
+		temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+	switch (size) {
+	case 1:
+		shift = (8 * (where & 0x3));
+		mask = 0xff;
+		break;
+
+	case 2:
+		shift = (8 * (where & 0x2));
+		mask = 0xffff;
+		break;
+
+	default:
+		shift = 0;
+		mask = 0xffffffff;
+		break;
+	}
+
+	temp = (temp & (~(mask << shift))) | ((val & mask) << shift);
+	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
+
+	return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+	.read = mv_pci0_read_config,
+	.write = mv_pci0_write_config,
+};
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	sys->map_irq = mv_map_irq;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("PCI: unable to alloc resources");
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
+	res[0].end =
+	    mv_pci_io_base_get(0) - IO_SPACE_REMAP + mv_pci_io_size_get(0) - 1;
+	res[0].name = "PCI0 IO Primary";
+	res[0].flags = IORESOURCE_IO;
+
+	res[1].start = mv_pci_mem_base_get(0);
+	res[1].end = mv_pci_mem_base_get(0) + mv_pci_mem_size_get(0) - 1;
+	res[1].name = "PCI0 Memory Primary";
+	res[1].flags = IORESOURCE_MEM;
+
+	if (request_resource(&ioport_resource, &res[0]))
+		printk(KERN_NOTICE "IO Request resource failed - Pci If %x\n", nr);
+
+	if (request_resource(&iomem_resource, &res[1]))
+		printk(KERN_NOTICE "Memory Request resource failed - Pci If %x\n", nr);
+
+	sys->resource[0] = &res[0];
+	sys->resource[1] = &res[1];
+	sys->resource[2] = NULL;
+	sys->io_offset = 0x0;
+
+	return 1;
+
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops;
+	struct pci_bus *bus;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	ops = &mv_pci_ops;
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCI0;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle = pci_std_swizzle,
+	.map_irq = mv_map_irq,
+	.setup = mv_pci_setup,
+	.scan = mv_pci_scan_bus,
+	.preinit = mv_pci_preinit,
+};
+
+static int __init mv_pci_init(void)
+{
+	MV_U32 ifnum = mvCtrlPciMaxIfGet();
+	if (ifnum) {
+		mv_pci.nr_controllers = ifnum;
+		pci_common_init(&mv_pci);
+	}
+
+	return 0;
+}
+
+subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-armada38x/pex.c b/arch/arm/mach-armada38x/pex.c
new file mode 100644
index 0000000..91a21f7
--- /dev/null
+++ b/arch/arm/mach-armada38x/pex.c
@@ -0,0 +1,370 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "pex/mvPexRegs.h"
+#include "mvSysPexApi.h"
+
+#ifdef MV_DEBUG
+#define DB(x) x
+#else
+#define DB(x)
+#endif
+
+#define MV_PEX_MASK_ABCD              (BIT24 | BIT25 | BIT26 | BIT27)
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+extern int mv_is_pci_io_mapped(int ifNum);
+extern MV_TARGET mv_pci_io_target_get(int ifNum);
+
+static struct platform_device mv_pex = {
+	.name = "mv_pex",
+	.id = 0,
+	.num_resources = 0,
+};
+
+static void *mv_get_irqmap_func[] __initdata = {
+	mv_map_irq_0,
+	mv_map_irq_1,
+};
+
+void __init mv_pex_preinit(void)
+{
+	static MV_U32 pex0flg;
+	unsigned int pci_if;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+
+	for (pci_if = 0; pci_if < boardPexInfo->boardPexIfNum; pci_if++) {
+		if (mvUnitMapIsPexMine(pci_if) == MV_FALSE)
+			continue;
+
+		pr_info("PCIe: Cheking physical bus #%d: ", pci_if);
+		if (mvCtrlPwrClckGet(PEX_UNIT_ID, pci_if) == MV_FALSE) {
+			pr_info("Disabled\n");
+			continue;
+		}
+
+		if ((MV_REG_READ(PEX_DBG_STATUS_REG(pci_if)) & 0x7f) != 0x7E) {
+			pr_info("no link, disabled\n");
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pci_if, MV_FALSE);
+			continue;
+		}
+
+		if (mvSysPexInit(pci_if, MV_PEX_ROOT_COMPLEX) != MV_OK) {
+			pr_warn("%s: Error: mvSysPexInit(%d) failed\n",
+				__func__, pci_if);
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pci_if, MV_FALSE);
+			continue;
+		}
+
+		pr_info("PCIe %d enabled - link up\n", pci_if);
+
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == 0) {
+			mvPexLocalBusNumSet(pci_if, 0x0);
+			pex0flg = 1;
+		}
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pci_if), MV_PEX_MASK_ABCD);
+
+		if (mv_is_pci_io_mapped(pci_if)) {
+			pciIoRemap.baseLow =
+			    mv_pci_io_base_get(pci_if) - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0;
+			pciIoRemap.size = mv_pci_io_size_get(pci_if);
+			mvCpuIfPexRemap(mv_pci_io_target_get(pci_if),
+					&pciIoRemap);
+		}
+	}
+}
+
+void mv_pex_reinit(void)
+{
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	static MV_U32 pex0flg;
+	unsigned int pci_if;
+
+	for (pci_if = 0; pci_if < boardPexInfo->boardPexIfNum; pci_if++) {
+		if (mvUnitMapIsPexMine(pci_if) == MV_FALSE)
+			continue;
+
+		if (mvCtrlPwrClckGet(PEX_UNIT_ID, pci_if) == MV_FALSE)
+			continue;
+
+		if ((MV_REG_READ(PEX_DBG_STATUS_REG(pci_if)) & 0x7f) != 0x7E) {
+			pr_info("no link, disabled\n");
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pci_if, MV_FALSE);
+			continue;
+		}
+
+		if (mvSysPexInit(pci_if, MV_PEX_ROOT_COMPLEX) != MV_OK) {
+			pr_warn("%s: Error: mvSysPexInit(%d) failed\n",
+				__func__, pci_if);
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pci_if, MV_FALSE);
+			continue;
+		}
+
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == 0) {
+			mvPexLocalBusNumSet(pci_if, 0x0);
+			pex0flg = 1;
+		}
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pci_if), MV_PEX_MASK_ABCD);
+	}
+}
+
+static int mv_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 *val)
+{
+	u32 bus_num, func, regOff, dev_no, temp, localBus;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+	u32 pciIf = sysdata->mv_controller_num;
+
+	*val = 0xffffffff;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if (dev_no == 0 && bus_num == localBus) {
+		DB(pr_info
+		   ("PCI %d read from our own dev return 0xffffffff\n", pciIf));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn);
+
+	/* total of 12 bits: 8 legacy + 4 extended */
+	regOff =
+	    (MV_U32) where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	switch (size) {
+	case 1:
+		temp = (temp >> (8 * (where & 0x3))) & 0xff;
+		break;
+	case 2:
+		temp = (temp >> (8 * (where & 0x2))) & 0xffff;
+		break;
+	default:
+		break;
+	}
+
+	*val = temp;
+
+	DB(pr_info
+	   ("PCI %2d read : (b.d.f) = (%2d,%2d,%2d); reg = %4d: val = 0x%08x\n",
+	    pciIf, bus_num, dev_no, func, regOff, temp));
+
+	return 0;
+}
+
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+			       int where, int size, u32 val)
+{
+	u32 bus_num, func, regOff, dev_no, temp, mask, shift;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+	u32 pciIf = sysdata->mv_controller_num;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0xFFFFFFFF;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* total of 12 bits: 8 legacy + 4 extended */
+	regOff =
+	    (MV_U32) where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	DB(pr_info
+	   ("PCI %2d write: (b.d.f) = (%2d,%2d,%2d); reg = %4d: val = 0x%08x\n",
+	    pciIf, bus_num, dev_no, func, regOff, val));
+	if (size != 4)
+		temp =
+		    (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+	switch (size) {
+	case 1:
+		shift = (8 * (where & 0x3));
+		mask = 0xff;
+		break;
+	case 2:
+		shift = (8 * (where & 0x2));
+		mask = 0xffff;
+		break;
+	default:
+		shift = 0;
+		mask = 0xffffffff;
+	}
+
+	temp = (temp & (~(mask << shift))) | ((val & mask) << shift);
+	mvPexConfigWrite(pciIf, bus_num, dev_no, func, regOff, temp);
+	return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+	.read = mv_pci_read_config,
+	.write = mv_pci_write_config,
+};
+
+int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+	u32 mem_base, mem_size, iobase, index = 0;
+
+	if (mvUnitMapIsPexMine(nr) == MV_FALSE)
+		return 0;
+
+	if (mvCtrlPwrClckGet(PEX_UNIT_ID, nr) == MV_FALSE)
+		return 0;
+
+	res = kcalloc(1, sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res) {
+		panic("%s: memory alloc failed\n", __func__);
+		return 0;
+	}
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	/* Save the HW iface number for this PEX bus */
+	sys->mv_controller_num = nr;
+	sys->map_irq = mv_get_irqmap_func[nr];
+
+	if (mv_is_pci_io_mapped(nr)) {
+		iobase = mv_pci_io_base_get(nr);
+		res[index].start = iobase - IO_SPACE_REMAP;
+		res[index].end = iobase - IO_SPACE_REMAP + mv_pci_io_size_get(nr) - 1;
+		res[index].name = "PCIx IO Primary";
+		res[index].flags = IORESOURCE_IO;
+		if (request_resource(&ioport_resource, &res[index]))
+			printk(KERN_ERR "IO Request resource failed - "
+				"Pci If %x\n", nr);
+		else
+			index++;
+	}
+
+	mem_base = mv_pci_mem_base_get(nr);
+	mem_size = mv_pci_mem_size_get(nr);
+
+	res[index].start = mem_base;
+	res[index].end   = mem_base + mem_size - 1;
+	res[index].name  = "PCIx Memory Primary";
+	res[index].flags = IORESOURCE_MEM;
+
+	if (request_resource(&iomem_resource, &res[index]))
+		printk(KERN_ERR "Memory Request resource failed - Pci If %x\n", nr);
+
+	sys->resource[0] = &res[0];
+	if (index > 0) {
+		sys->resource[1] = &res[1];
+		sys->resource[2] = NULL;
+	} else
+		sys->resource[1] = NULL;
+
+	sys->io_offset   = 0x0;
+
+	return 1;
+}
+
+
+struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+	bus = pci_scan_bus(sys->busnr, &mv_pci_ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_GLOBAL_PCIE0;
+}
+
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_GLOBAL_PCIE1;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle = pci_std_swizzle,
+	.setup = mv_pex_setup,
+	.scan = mv_pex_scan_bus,
+	.preinit = mv_pex_preinit,
+};
+
+static int mv_pex_probe(struct platform_device *dev)
+{
+	return 0;
+}
+
+static struct platform_driver mv_pex_driver = {
+	.probe = mv_pex_probe,
+	.driver = {
+		   .name = "mv_pex",
+		   },
+};
+
+static int __init mv_pex_init_module(void)
+{
+	mv_pci.nr_controllers = mvBoardPexInfoGet()->boardPexIfNum;
+	mv_pci.swizzle = pci_std_swizzle;
+	mv_pci.map_irq = mv_map_irq_0;
+	mv_pci.setup = mv_pex_setup;
+	mv_pci.scan = mv_pex_scan_bus;
+	mv_pci.preinit = mv_pex_preinit;
+	pci_common_init(&mv_pci);
+	platform_device_register(&mv_pex);
+
+	return platform_driver_register(&mv_pex_driver);
+}
+
+module_init(mv_pex_init_module);
+MODULE_DESCRIPTION("Marvell PCIe driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-armada38x/platsmp.c b/arch/arm/mach-armada38x/platsmp.c
new file mode 100644
index 0000000..11ad331
--- /dev/null
+++ b/arch/arm/mach-armada38x/platsmp.c
@@ -0,0 +1,152 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <asm/smp_plat.h>
+#include <linux/io.h>
+
+#include <asm/unified.h>
+#include <asm/smp_scu.h>
+
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/gic.h>
+#include "ca9x2.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+#include "core.h"
+
+unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
+static void __iomem *scu_base = (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	int i, ncores = scu_get_core_count(scu_base);
+
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; ++i)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	scu_enable(scu_base);
+
+	a380_smp_cpu1_enable_wa();
+
+	/*
+	 * Write the address of secondary startup into the
+	 * system-wide flags register. The boot monitor waits
+	 * until it receives a soft interrupt, and then the
+	 * secondary CPU branches to this address.
+	 */
+	writel(virt_to_phys(a380_secondary_startup),
+	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG);
+}
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+int __cpuinitdata pen_release = -1;
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void __cpuinit write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	write_pen_release(cpu_logical_map(cpu));
+
+	/*
+	 * Get CPU out of software reset state.
+	 */
+	writel(0, CPU_SOFT_RESET_REG(cpu_logical_map(cpu)) +
+	       INTER_REGS_VIRT_BASE);
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
diff --git a/arch/arm/mach-armada38x/sysmap.c b/arch/arm/mach-armada38x/sysmap.c
new file mode 100644
index 0000000..c6bcc36
--- /dev/null
+++ b/arch/arm/mach-armada38x/sysmap.c
@@ -0,0 +1,166 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <asm/mach/map.h>
+#include <asm/smp_twd.h>
+#include "ca9x2.h"
+
+struct map_desc MEM_TABLE[] = {
+	/* no use for pex mem remap */
+	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,		MT_DEVICE},
+	{ PP2_CPU0_VIRT_BASE,		__phys_to_pfn(PP2_CPU0_PHYS_BASE),	PP2_SIZE,	MT_DEVICE},
+#ifdef CONFIG_SMP
+	{ PP2_CPU1_VIRT_BASE,		__phys_to_pfn(PP2_CPU1_PHYS_BASE),	PP2_SIZE,	MT_DEVICE},
+#endif
+	{ CRYPT_ENG_VIRT_BASE(0),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(0)),	CRYPT_ENG_SIZE,	MT_DEVICE},
+	{ IOCC_WA_WIN0_VIRT_BASE,	__phys_to_pfn(IOCC_WA_WIN0_PHYS_BASE),	SZ_64K,		MT_DEVICE},
+};
+
+MV_CPU_DEC_WIN SYSMAP_A380_6810[] = {
+	/* base low             base high       size                            WinNum          enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS}, /* SDRAM_CS3 */
+	{{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	8,		 EN}, /* DEVICE_CS0 */
+	{{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS}, /* DEVICE_CS1 */
+	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS}, /* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS}, /* DEVICE_CS3 */
+	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0,		 EN}, /* PEX0_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS}, /* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	1,		 EN}, /* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	TBL_UNUSED,	DIS}, /* PEX1_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	20,		 EN}, /* INTER_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS}, /* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	14,		 EN}, /* SPI_CS0 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS1 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS2 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS3 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS4 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS5 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS6 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	9,		DIS}, /* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	10,		 EN}, /* DEV_BOOCS */
+	{{USB3_REGS_PHYS_BASE,		0,	USB3_REGS_SIZE		},	11,		 EN}, /* USB3 */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	12,		 EN}, /* CRYPT_ENG */
+	{{PP2_CPU0_PHYS_BASE,		0,	PP2_SIZE		},	13,		 EN}, /* PP2 */
+#ifdef CONFIG_SMP
+	{{PP2_CPU1_PHYS_BASE,		0,	PP2_SIZE		},	15,		 EN}, /* PP2 */
+#else
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* PP2 */
+#endif
+	{{TBL_TERM,		 TBL_TERM,	TBL_TERM		},	TBL_TERM,  TBL_TERM}
+};
+
+MV_CPU_DEC_WIN *mv_sys_map(void)
+{
+	MV_CPU_DEC_WIN *map;
+	MV_U16 ctrlModel = mvCtrlModelGet();
+
+	switch (ctrlModel) {
+	case MV_6720_DEV_ID:
+		map = SYSMAP_A380_6810;
+		break;
+	default:
+		pr_warn("%s: Error: Wrong ctrlModel (%d)\n", __func__,
+			ctrlModel);
+		map = SYSMAP_A380_6810;
+	}
+
+	return map;
+}
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan)
+{
+	return CRYPT_ENG_PHYS_BASE(chan);
+}
+
+u32 mv_crypto_virt_base_get(u8 chan)
+{
+	return CRYPT_ENG_VIRT_BASE(chan);
+}
+#endif
+
+void __init a380_map_io(void)
+{
+	iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+}
+
+static u32 mv_pci_mem_base[] = {
+	PEX0_MEM_PHYS_BASE,
+	PEX1_MEM_PHYS_BASE,
+};
+
+static u32 mv_pci_mem_size[] = {
+	PEX0_MEM_SIZE,
+	PEX1_MEM_SIZE,
+};
+
+static u32 mv_pci_io_base[] = {
+	PEX0_IO_PHYS_BASE,
+	PEX1_IO_PHYS_BASE,
+};
+
+static u32 mv_pci_io_size[] = {
+	PEX0_IO_SIZE,
+	PEX1_IO_SIZE,
+};
+
+static MV_TARGET mv_pci_io_target[] = {
+	PEX0_IO,
+	PEX1_IO,
+};
+
+u32 mv_pci_mem_base_get(int ifNum)
+{
+	return mv_pci_mem_base[ifNum];
+}
+
+u32 mv_pci_mem_size_get(int ifNum)
+{
+	return mv_pci_mem_size[ifNum];
+}
+
+u32 mv_pci_io_base_get(int ifNum)
+{
+	return mv_pci_io_base[ifNum];
+}
+
+u32 mv_pci_io_size_get(int ifNum)
+{
+	return mv_pci_io_size[ifNum];
+}
+
+MV_TARGET mv_pci_io_target_get(int ifNum)
+{
+	return mv_pci_io_target[ifNum];
+}
+
+int mv_is_pci_io_mapped(int ifNum)
+{
+	/* FIXME: First 8 address decode windows are statically assigned
+	 * for 8 PCIE mem BARs.
+	 * This is disabled as long that no more windows are available for
+	 * I/O BARs
+	 */
+
+	return 0;
+}
diff --git a/arch/arm/mach-armada38x/time.c b/arch/arm/mach-armada38x/time.c
new file mode 100644
index 0000000..3c45612
--- /dev/null
+++ b/arch/arm/mach-armada38x/time.c
@@ -0,0 +1,245 @@
+/*
+ * arch/arm/mach-armada380/time.c
+ *
+ * Marvell SoC timer handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <ca9x2.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clockchips.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <asm/smp_twd.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+
+/* SoC global timer */
+#define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER_EN(x)		(1 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(2 << (2 * x))
+#define TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0004)
+#define  TIMER_INT_CLR(x)	(~(1 << (8 * x)))
+#define TIMER_RELOAD(x)		(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
+#define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
+
+/*
+ * Define SoC global timers to be used for event and source timers
+ */
+static int event_timer_id;
+static int source_timer_id;
+
+static u32 ticks_per_jiffy;
+
+static cycle_t a380_clksrc_read(struct clocksource *cs)
+{
+	return 0xffffffff - MV_REG_READ(TIMER_VAL(source_timer_id));
+}
+
+static struct clocksource a380_clksrc = {
+	.name = "a380_clocksource",
+	.shift = 20,
+	.rating = 300,
+	.read = a380_clksrc_read,
+	.mask = CLOCKSOURCE_MASK(32),
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+int a380_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
+{
+	unsigned long flags;
+	u32 u, t = event_timer_id;
+
+	if (delta == 0)
+		return -ETIME;
+
+	local_irq_save(flags);
+
+	/* Clear and enable clockevent timer interrupt */
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
+
+	/* Setup new clockevent timer value */
+	MV_REG_WRITE(TIMER_VAL(t), delta);
+
+	/* Enable the timer */
+	u = MV_REG_READ(TIMER_CTRL);
+	u = (u & ~TIMER_RELOAD_EN(t)) | TIMER_EN(t);
+	MV_REG_WRITE(TIMER_CTRL, u);
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static void a380_clkevt_mode(enum clock_event_mode mode,
+			     struct clock_event_device *evt)
+{
+	unsigned long flags;
+	u32 u, t = event_timer_id;
+	local_irq_save(flags);
+
+	if (mode == CLOCK_EVT_MODE_PERIODIC || mode == CLOCK_EVT_MODE_ONESHOT) {
+		/* Setup timer to fire at 1/HZ intervals */
+		MV_REG_WRITE(TIMER_RELOAD(t), ticks_per_jiffy - 1);
+		MV_REG_WRITE(TIMER_VAL(t), ticks_per_jiffy - 1);
+
+		/* Enable timer */
+		u = MV_REG_READ(TIMER_CTRL);
+		u |= TIMER_EN(t) | TIMER_RELOAD_EN(t);
+		MV_REG_WRITE(TIMER_CTRL, u);
+	} else {
+		/* Disable timer */
+		u = MV_REG_READ(TIMER_CTRL);
+		u &= ~TIMER_EN(t);
+		MV_REG_WRITE(TIMER_CTRL, u);
+
+		/* Ack pending timer interrupt */
+		MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
+	}
+
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device a380_clkevt;
+
+static irqreturn_t a380_timer_interrupt(int irq, void *dev_id)
+{
+	u32 t = event_timer_id;
+
+	/* Ack timer interrupt */
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
+
+	a380_clkevt.event_handler(&a380_clkevt);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction a380_timer_irq = {
+	.name = "a380_clk_evt",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = a380_timer_interrupt,
+	.dev_id = &a380_clkevt,
+};
+
+/*
+ * Implement clock API.
+ */
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+
+void clk_disable(struct clk *clk)
+{
+	/* Empty */
+}
+
+static DEFINE_CLOCK_DATA(cd);
+
+unsigned long long notrace sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(source_timer_id));
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void notrace a380_update_sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(source_timer_id));
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void __init setup_sched_clock(unsigned long tclk)
+{
+	init_sched_clock(&cd, a380_update_sched_clock, 32, tclk);
+}
+
+/* Setup free-running clocksource timer */
+static void a380_setup_clocksource(int timer, long rate)
+{
+	u32 i = timer, u;
+	void __iomem *base =
+	    (void __iomem *)(INTER_REGS_VIRT_BASE + TIMER_VAL(i));
+
+	MV_REG_WRITE(TIMER_VAL(i), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(i), 0xffffffff);
+
+	/* Config clock source for timer */
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= TIMER_EN(i) | TIMER_RELOAD_EN(i);
+	MV_REG_WRITE(TIMER_CTRL, u);
+
+	clocksource_mmio_init(base, "a380_clk_source",
+			      rate, 200, 32, clocksource_mmio_readl_down);
+
+	a380_clksrc.mult = clocksource_hz2mult(rate, a380_clksrc.shift);
+	setup_sched_clock(rate);
+	clocksource_register(&a380_clksrc);
+}
+
+static void a380_setup_clockevent(int irq, long rate)
+{
+	struct clock_event_device *evt = &a380_clkevt;
+	unsigned int cpu = smp_processor_id();
+
+	evt->name = "a380_clkevt";
+	evt->irq = irq;
+	evt->features = (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	    evt->shift = 32,
+	    evt->rating = 300,
+	    evt->set_next_event = a380_clkevt_next_event,
+	    evt->set_mode = a380_clkevt_mode, evt->cpumask = cpumask_of(cpu);
+	evt->mult = div_sc(rate, NSEC_PER_SEC, evt->shift);
+	evt->max_delta_ns = clockevent_delta2ns(0xffffffff, evt);
+	evt->min_delta_ns = clockevent_delta2ns(0x1, evt);
+
+	setup_irq(irq, &a380_timer_irq);
+	clockevents_config_and_register(evt, rate, 0x1, 0xffffffff);
+}
+
+static void a380_clear_timer_config(void)
+{
+	MV_REG_WRITE(TIMER_CTRL, 0);
+	MV_REG_WRITE(TIMER_CAUSE, 0);
+}
+
+static void __init a380_timer_init(void)
+{
+	u32 rate;
+
+	rate = 200000000;
+
+	printk(KERN_INFO "Initializing Armada-380 SoC Timers\n");
+	ticks_per_jiffy = (rate + HZ / 2) / HZ;
+
+	a380_clear_timer_config();
+
+	/* Define timers used for event and source */
+	event_timer_id = 1;
+	source_timer_id = 0;
+
+	a380_setup_clocksource(source_timer_id, rate);
+	a380_setup_clockevent(IRQ_GLOBAL_TIMER(event_timer_id), rate);
+
+#ifdef CONFIG_HAVE_ARM_TWD
+	twd_base = (INTER_REGS_VIRT_BASE + A9_MPCORE_TWD);
+#endif
+}
+
+struct sys_timer a380_timer = {
+	.init = a380_timer_init,
+};
diff --git a/arch/arm/mach-armada38x/usb.c b/arch/arm/mach-armada38x/usb.c
new file mode 100644
index 0000000..a317598
--- /dev/null
+++ b/arch/arm/mach-armada38x/usb.c
@@ -0,0 +1,312 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mbus.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "mvSysUsbApi.h"
+#include "usb/mvUsbRegs.h"
+#include "usb/mvUsb.h"
+
+u32 mvIsUsbHost = 0x03;
+
+#define MV_USB_DMA_MASK         0xffffffff
+#define MAX_USB_PORTS           1
+
+static const char usb_dev_name[] = "mv_udc";
+static const char usb_host_name[] = "ehci_marvell";
+static const char usb_bus_name[] = "platform";
+
+static void mv_usb_release(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	/* normally not freed */
+	printk(KERN_INFO "mv_usb_release\n");
+
+	kfree(pdev->resource);
+	kfree(pdev->dev.dma_mask);
+	kfree(pdev);
+}
+
+
+static int __init mv_usb2_init(void)
+{
+	int status, dev, num, isHost;
+	char *name_ptr;
+	struct platform_device *mv_usb_dev_ptr;
+	int irq_num[MAX_USB_PORTS] = { IRQ_GLOBAL_USB2_IP };
+
+	num = 1;
+
+	for (dev = 0; dev < num; dev++) {
+		if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev)) {
+			printk(KERN_INFO "\nWarning Integrated USB %d is Powered Off\n",
+			       dev);
+			continue;
+		}
+
+		/* Check if this USB is mapped to this AMP group */
+		if (MV_FALSE == mvUnitMapIsMine(USB0 + dev))
+			continue;
+
+		isHost = mvIsUsbHost & (1 << dev);
+
+		if (isHost)
+			name_ptr = usb_host_name;
+		else
+			name_ptr = usb_dev_name;
+
+		printk(KERN_INFO "registered dev#%d asa %s\n", dev, name_ptr);
+		status = mvSysUsbInit(dev, isHost);
+
+		if (status != MV_OK) {
+			pr_info("Error: mvSysUsbInit failed with code %d\n", status);
+			continue;
+		}
+
+		mv_usb_dev_ptr =
+		    kmalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if (mv_usb_dev_ptr == NULL) {
+			printk
+			    ("Can't allocate platform_device structure - %d bytes\n",
+			     sizeof(struct platform_device));
+			return 1;
+		}
+		memset(mv_usb_dev_ptr, 0, sizeof(struct platform_device));
+
+		mv_usb_dev_ptr->name = name_ptr;
+		mv_usb_dev_ptr->id = dev;
+
+		mv_usb_dev_ptr->num_resources = 2;
+
+		mv_usb_dev_ptr->resource = kmalloc(2 * sizeof(struct resource),
+					       GFP_KERNEL);
+		if (mv_usb_dev_ptr->resource == NULL) {
+			printk
+			    ("Can't allocate 2 resource structure - %d bytes\n",
+			     2 * sizeof(struct resource));
+			kfree(mv_usb_dev_ptr);
+			return 1;
+		}
+		memset(mv_usb_dev_ptr->resource, 0,
+		       2 * sizeof(struct resource));
+
+		mv_usb_dev_ptr->resource[0].start =
+		    (INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
+		mv_usb_dev_ptr->resource[0].end =
+		    ((INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) +
+		     4096);
+		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
+
+		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
+		mv_usb_dev_ptr->resource[1].flags = IORESOURCE_IRQ;
+
+		mv_usb_dev_ptr->dev.dma_mask = kmalloc(sizeof(u64), GFP_KERNEL);
+		*mv_usb_dev_ptr->dev.dma_mask = MV_USB_DMA_MASK;
+
+		mv_usb_dev_ptr->dev.coherent_dma_mask = ~0;
+		mv_usb_dev_ptr->dev.release = mv_usb_release;
+		dev_set_name(&mv_usb_dev_ptr->dev, "%s", usb_bus_name);
+
+		printk(KERN_INFO "Marvell USB %s controller #%d: %p\n",
+		       isHost ? "EHCI Host" : "Gadget", dev, mv_usb_dev_ptr);
+
+		status = platform_device_register(mv_usb_dev_ptr);
+		if (status) {
+			printk
+			    ("Can't register Marvell USB EHCI controller #%d, status=%d\n",
+			     dev, status);
+			return status;
+		}
+	}
+	return 0;
+}
+
+#define USB3_WIN_CTRL(w)	(0x0 + ((w) * 8))
+#define USB3_WIN_BASE(w)	(0x4 + ((w) * 8))
+#define USB3_MAX_WINDOWS	4
+#define USB3_XHCI_REGS_SIZE	_64K
+
+static u64 mv_usb3_dmamask = 0xffffffffUL;
+static struct resource mv_usb3_resources[] = {
+	[0] = {
+		.start	= USB3_REGS_PHYS_BASE,
+		.end	= USB3_REGS_PHYS_BASE + USB3_XHCI_REGS_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= IRQ_GLOBAL_USB3_IP,
+		.end	= IRQ_GLOBAL_USB3_IP,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+
+static void __init mv_usb3_conf_mbus_windows(void __iomem *base,
+			const struct mbus_dram_target_info *dram)
+{
+	int win;
+
+	/* Clear all existing windows */
+	for (win = 0; win < USB3_MAX_WINDOWS; win++) {
+		writel(0, base + USB3_WIN_CTRL(win));
+		writel(0, base + USB3_WIN_BASE(win));
+	}
+
+	/* Program each DRAM CS in a seperate window */
+	for (win = 0; win < dram->num_cs; win++) {
+		const struct mbus_dram_window *cs = dram->cs + win;
+
+		writel(((cs->size - 1) & 0xffff0000) | (cs->mbus_attr << 8) |
+		       (dram->mbus_dram_target_id << 4) | 1,
+		       base + USB3_WIN_CTRL(win));
+
+		writel((cs->base & 0xffff0000), base + USB3_WIN_BASE(win));
+	}
+}
+
+void __init mv_usb3_init(struct mbus_dram_target_info *dram)
+{
+	int ret = -ENOMEM;
+	struct platform_device	*xhci;
+	u8 __iomem *usb_mac_regs;
+	int reg, mask;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, 0)) {
+		pr_warn("Warning: Integrated USB3 is Powered Off\n");
+		return;
+	}
+
+	if (MV_FALSE == mvUnitMapIsMine(USB0))
+		return;
+
+	/* Allocate an XHCI device */
+	xhci = platform_device_alloc("xhci-hcd", -1);
+	if (!xhci) {
+		pr_err("Couldn't allocate XHCI device\n");
+		goto err0;
+	}
+
+	/* Setup XHCI resources */
+	ret = platform_device_add_resources(xhci, mv_usb3_resources,
+			ARRAY_SIZE(mv_usb3_resources));
+	if (ret) {
+		pr_err("Couldn't add resources to XHCI device\n");
+		goto err1;
+	}
+
+	dma_set_coherent_mask(&xhci->dev, 0xffffffff);
+	xhci->dev.dma_mask = &mv_usb3_dmamask;
+
+	/* Map the DDR address space to the XHCI */
+	mv_usb3_conf_mbus_windows((void *)(INTER_REGS_VIRT_BASE +
+				MV_USB3_REGS_BASE(0)), dram);
+
+#ifdef CONFIG_A380_Z1_USB3_LFPS_FREQ_WA
+/*
+ * All defines below are used for a temporary workaround and therefore
+ * are placed inside the code and not in an include file
+ */
+#define USB3_MAC_REGS_BASE		(0x10000)
+#define USB3_MAC_REGS_SIZE		(0x500)
+#define USB3_CNTR_PULSE_WIDTH_OFFSET	(0x454)
+#define REF_CLK_100NS_OFFSET		(24)
+#define REF_CLK_100NS_MASK		(0xFF)
+
+	/* Modify the LFPS timing to fix clock issues on ALP-Z1 */
+	usb_mac_regs = (u8 *)ioremap_nocache(USB3_REGS_PHYS_BASE +
+			USB3_MAC_REGS_BASE, USB3_MAC_REGS_SIZE);
+	if (!usb_mac_regs) {
+		pr_err("Failed to map USB3 MAC registers\n");
+		goto err1;
+	}
+
+	reg = readl(usb_mac_regs + USB3_CNTR_PULSE_WIDTH_OFFSET);
+	mask = ~(REF_CLK_100NS_MASK << REF_CLK_100NS_OFFSET);
+	reg = (reg & mask) | (0x10 << REF_CLK_100NS_OFFSET);
+	writel(reg, usb_mac_regs + USB3_CNTR_PULSE_WIDTH_OFFSET);
+#endif
+
+	/* Register the device */
+	ret = platform_device_add(xhci);
+	if (ret) {
+		pr_err("Failed to register xHCI device\n");
+		goto err1;
+	}
+
+	pr_info("USB3 XHCI Device registered successfully\n");
+	return;
+
+err1:
+	platform_device_put(xhci);
+err0:
+	return;
+}
+
+void __init mv_usb_init(struct mbus_dram_target_info *dram)
+{
+	int reg;
+	int use_usb3_ip = 0;
+	MV_STATUS status;
+
+#ifndef CONFIG_ARMADA_380_USE_LEGACY_USB2
+	use_usb3_ip = 1;
+	/* Initialize the USB2 PHY needed for USB3 functionality */
+	status = mvSysUsbInit(0, 1);
+	if (status != MV_OK) {
+		pr_info("Error: mvSysUsbInit failed with code %d\n", status);
+		return;
+	}
+#endif
+
+	/* Select USB3 IP (which supports USB2) or legacy USB2 IP*/
+	reg = readl(INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+	reg = (reg & (~0x1)) | use_usb3_ip;
+	writel(reg, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+
+	if (use_usb3_ip)
+		mv_usb3_init(dram);
+	else
+		mv_usb2_init();
+}
-- 
1.7.5.4

