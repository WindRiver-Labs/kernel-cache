From 5abaf83594ad1f0d5e68666ee455e65d1ce39009 Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Tue, 10 Dec 2013 10:44:22 +0200
Subject: [PATCH 1200/1825] fix: mv_xor: add BE support for XOR driver

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f75c3855054721d27ec25d8cc3c4b05611be98b9

	This patch adds support for XOR driver in BE mode.
	The patch do mainly two things:
	1. replace all __raw_readl/__raw_write with readl/writel to allow
	   the kernel generic swap support.
	2. swap descriptors fields to support BE.

	JIRA BUG #SYSTEMSW-81

Change-Id: Id9b3237a40ed460a845cd89295f55aec052ab73a
Signed-off-by: Lior Amsalem <alior@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4543
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4693
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/dma/mv_xor.c |   59 ++++++++++++++++++++++++++++----------------------
 drivers/dma/mv_xor.h |   27 ++++++++++++++++++++++-
 2 files changed, 59 insertions(+), 27 deletions(-)

diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index 42370a0..fc3e838 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -75,7 +75,7 @@ static u32 mv_desc_get_src_addr(struct mv_xor_desc_slot *desc,
 				int src_idx)
 {
 	struct mv_xor_desc *hw_desc = desc->hw_desc;
-	return hw_desc->phy_src_addr[src_idx];
+	return hw_desc->phy_src_addr[mv_phy_src_idx(src_idx)];
 }
 
 
@@ -115,41 +115,41 @@ static void mv_desc_set_src_addr(struct mv_xor_desc_slot *desc,
 
 static u32 mv_chan_get_current_desc(struct mv_xor_chan *chan)
 {
-	return __raw_readl(XOR_CURR_DESC(chan));
+	return readl_relaxed(XOR_CURR_DESC(chan));
 }
 
 static void mv_chan_set_next_descriptor(struct mv_xor_chan *chan,
 					u32 next_desc_addr)
 {
-	__raw_writel(next_desc_addr, XOR_NEXT_DESC(chan));
+	writel_relaxed(next_desc_addr, XOR_NEXT_DESC(chan));
 }
 
 static void mv_chan_set_dest_pointer(struct mv_xor_chan *chan, u32 desc_addr)
 {
-	__raw_writel(desc_addr, XOR_DEST_POINTER(chan));
+	writel_relaxed(desc_addr, XOR_DEST_POINTER(chan));
 }
 
 static void mv_chan_set_block_size(struct mv_xor_chan *chan, u32 block_size)
 {
-	__raw_writel(block_size, XOR_BLOCK_SIZE(chan));
+	writel_relaxed(block_size, XOR_BLOCK_SIZE(chan));
 }
 
 static void mv_chan_set_value(struct mv_xor_chan *chan, u32 value)
 {
-	__raw_writel(value, XOR_INIT_VALUE_LOW(chan));
-	__raw_writel(value, XOR_INIT_VALUE_HIGH(chan));
+	writel_relaxed(value, XOR_INIT_VALUE_LOW(chan));
+	writel_relaxed(value, XOR_INIT_VALUE_HIGH(chan));
 }
 
 static void mv_chan_unmask_interrupts(struct mv_xor_chan *chan)
 {
-	u32 val = __raw_readl(XOR_INTR_MASK(chan));
+	u32 val = readl_relaxed(XOR_INTR_MASK(chan));
 	val |= XOR_INTR_MASK_VALUE << (chan->idx * 16);
-	__raw_writel(val, XOR_INTR_MASK(chan));
+	writel_relaxed(val, XOR_INTR_MASK(chan));
 }
 
 static u32 mv_chan_get_intr_cause(struct mv_xor_chan *chan)
 {
-	u32 intr_cause = __raw_readl(XOR_INTR_CAUSE(chan));
+	u32 intr_cause = readl_relaxed(XOR_INTR_CAUSE(chan));
 	intr_cause = (intr_cause >> (chan->idx * 16)) & 0xFFFF;
 	return intr_cause;
 }
@@ -166,13 +166,13 @@ static void mv_xor_device_clear_eoc_cause(struct mv_xor_chan *chan)
 {
 	u32 val = ~(3 << (chan->idx * 16));
 	dev_dbg(chan->device->common.dev, "%s, val 0x%08x\n", __func__, val);
-	__raw_writel(val, XOR_INTR_CAUSE(chan));
+	writel_relaxed(val, XOR_INTR_CAUSE(chan));
 }
 
 static void mv_xor_device_clear_err_status(struct mv_xor_chan *chan)
 {
 	u32 val = 0xFFFF0000 >> (chan->idx * 16);
-	__raw_writel(val, XOR_INTR_CAUSE(chan));
+	writel_relaxed(val, XOR_INTR_CAUSE(chan));
 }
 
 static int mv_can_chain(struct mv_xor_desc_slot *desc)
@@ -192,7 +192,7 @@ static void mv_set_mode(struct mv_xor_chan *chan,
 			       enum dma_transaction_type type)
 {
 	u32 op_mode;
-	u32 config = __raw_readl(XOR_CONFIG(chan));
+	u32 config = readl_relaxed(XOR_CONFIG(chan));
 
 	switch (type) {
 	case DMA_XOR:
@@ -214,7 +214,14 @@ static void mv_set_mode(struct mv_xor_chan *chan,
 
 	config &= ~0x7;
 	config |= op_mode;
-	__raw_writel(config, XOR_CONFIG(chan));
+
+#if defined(__BIG_ENDIAN)
+	config |= XOR_DESCRIPTOR_SWAP;
+#else
+	config &= ~XOR_DESCRIPTOR_SWAP;
+#endif
+
+	writel_relaxed(config, XOR_CONFIG(chan));
 	chan->current_type = type;
 }
 
@@ -222,12 +229,12 @@ static void mv_chan_activate(struct mv_xor_chan *chan)
 {
 	dev_dbg(chan->device->common.dev, " activate chan.\n");
 
-	__raw_writel(1, XOR_ACTIVATION(chan));
+	writel_relaxed(1, XOR_ACTIVATION(chan));
 }
 
 static char mv_chan_is_busy(struct mv_xor_chan *chan)
 {
-	u32 state = __raw_readl(XOR_ACTIVATION(chan));
+	u32 state = readl_relaxed(XOR_ACTIVATION(chan));
 
 	state = (state >> 4) & 0x3;
 
@@ -805,27 +812,27 @@ static void mv_dump_xor_regs(struct mv_xor_chan *chan)
 {
 	u32 val;
 
-	val = __raw_readl(XOR_CONFIG(chan));
+	val = readl_relaxed(XOR_CONFIG(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "config       0x%08x.\n", val);
 
-	val = __raw_readl(XOR_ACTIVATION(chan));
+	val = readl_relaxed(XOR_ACTIVATION(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "activation   0x%08x.\n", val);
 
-	val = __raw_readl(XOR_INTR_CAUSE(chan));
+	val = readl_relaxed(XOR_INTR_CAUSE(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "intr cause   0x%08x.\n", val);
 
-	val = __raw_readl(XOR_INTR_MASK(chan));
+	val = readl_relaxed(XOR_INTR_MASK(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "intr mask    0x%08x.\n", val);
 
-	val = __raw_readl(XOR_ERROR_CAUSE(chan));
+	val = readl_relaxed(XOR_ERROR_CAUSE(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "error cause  0x%08x.\n", val);
 
-	val = __raw_readl(XOR_ERROR_ADDR(chan));
+	val = readl_relaxed(XOR_ERROR_ADDR(chan));
 	dev_printk(KERN_ERR, chan->device->common.dev,
 		   "error addr   0x%08x.\n", val);
 }
@@ -1253,8 +1260,8 @@ static int mv_xor_suspend(struct platform_device *dev, pm_message_t state)
 				device_node);
 
 	mv_chan = to_mv_xor_chan(dma_chan);
-	saved_regs.xor_config 	  = __raw_readl(XOR_CONFIG(mv_chan));
-	saved_regs.interrupt_mask = __raw_readl(XOR_INTR_MASK(mv_chan));
+	saved_regs.xor_config = readl_relaxed(XOR_CONFIG(mv_chan));
+	saved_regs.interrupt_mask = readl_relaxed(XOR_INTR_MASK(mv_chan));
 
 	return 0;
 }
@@ -1270,8 +1277,8 @@ static int mv_xor_resume(struct platform_device *dev)
 				device_node);
 
 	mv_chan = to_mv_xor_chan(dma_chan);
-	__raw_writel(saved_regs.xor_config, XOR_CONFIG(mv_chan));
-	__raw_writel(saved_regs.interrupt_mask, XOR_INTR_MASK(mv_chan));
+	writel_relaxed(saved_regs.xor_config, XOR_CONFIG(mv_chan));
+	writel_relaxed(saved_regs.interrupt_mask, XOR_INTR_MASK(mv_chan));
 
 	return 0;
 }
diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h
index 85e2559..d9e99cb 100644
--- a/drivers/dma/mv_xor.h
+++ b/drivers/dma/mv_xor.h
@@ -30,6 +30,7 @@
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_OPERATION_MODE_MEMSET	4
+#define XOR_DESCRIPTOR_SWAP            BIT(14)
 
 #define XOR_CURR_DESC(chan)	(chan->mmr_base + 0x210 + (chan->idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan->mmr_base + 0x200 + (chan->idx * 4))
@@ -149,7 +150,16 @@ struct mv_xor_desc_slot {
 #endif
 };
 
-/* This structure describes XOR descriptor size 64bytes	*/
+/*
+ * This structure describes XOR descriptor size 64bytes. The
+ * mv_phy_src_idx() macro must be used when indexing the values of the
+ * phy_src_addr[] array. This is due to the fact that the 'descriptor
+ * swap' feature, used on big endian systems, swaps descriptors data
+ * within blocks of 8 bytes. So two consecutive values of the
+ * phy_src_addr[] array are actually swapped in big-endian, which
+ * explains the different mv_phy_src_idx() implementation.
+ */
+#if defined(__LITTLE_ENDIAN)
 struct mv_xor_desc {
 	u32 status;		/* descriptor execution status */
 	u32 crc32_result;	/* result of CRC-32 calculation */
@@ -161,6 +171,21 @@ struct mv_xor_desc {
 	u32 reserved0;
 	u32 reserved1;
 };
+#define mv_phy_src_idx(src_idx) (src_idx)
+#else
+struct mv_xor_desc {
+	u32 crc32_result;	/* result of CRC-32 calculation */
+	u32 status;		/* descriptor execution status */
+	u32 phy_next_desc;	/* next descriptor address pointer */
+	u32 desc_command;	/* type of operation to be carried out */
+	u32 phy_dest_addr;	/* destination block address */
+	u32 byte_count;		/* size of src/dst blocks in bytes */
+	u32 phy_src_addr[8];	/* source block addresses */
+	u32 reserved1;
+	u32 reserved0;
+};
+#define mv_phy_src_idx(src_idx) (src_idx ^ 1)
+#endif
 
 /* Stores certain registers during suspend to RAM */
 struct mv_xor_save_regs {
-- 
1.7.5.4

