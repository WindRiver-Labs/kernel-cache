From 67ab2288fa1d5b1eec0cf23fa125b7069362c02e Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Wed, 17 Jul 2013 13:07:09 +0300
Subject: [PATCH 0879/1825] alp : Sample at reset: improved API for S@R read
 and write routines

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ddd2b3a0a9754d33a54e4992b71b19821dac2d3f

	- Replace mvCtrlSatRRead return value to MV_STATUS - to avoid end cases of read value == MV_ERROR
	  (return the read value with specific pointer instead)
	- Change mvCtrlSatRWrite to use only satrReadField
	  (calculate SatrWrite field instead)
	- Fixed 'SatR list sscg' values (values were inverted)

Change-Id: I7f8c1df2242cfb030a24f43052517d76e2b3004a
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2701
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   12 +++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |   59 +++++++++++++++-----
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    4 +-
 3 files changed, 56 insertions(+), 19 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 6d24e10..1234a2c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -1109,9 +1109,17 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 *******************************************************************************/
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 {
-	MV_U32 satrBootDeviceValue = mvCtrlSatRRead(MV_SATR_BOOT_DEVICE);
+	MV_U32 satrBootDeviceValue;
 	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
-	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
+	MV_SATR_BOOT_TABLE satrBootEntry;
+
+	if (mvCtrlSatRRead(MV_SATR_BOOT_DEVICE, &satrBootDeviceValue) != MV_OK) {
+		mvOsPrintf("%s: Error: failed to read boot source\n", __func__);
+		mvOsPrintf("Using NAND as the default boot source\n");
+		return MSAR_0_BOOT_NAND_NEW; /* NAND is the Default Boot source */
+	}
+
+	satrBootEntry = satrTable[satrBootDeviceValue];
 
 	if (satrBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
 		return satrBootEntry.bootSrc;
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index d1ea1b3..f1f6e36 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -130,10 +130,9 @@ MV_U32 mvCtrlGetCpuNum(MV_VOID)
 {
 	MV_U32 cpu1Enabled;
 
-	cpu1Enabled = mvCtrlSatRRead(MV_SATR_CPU1_ENABLE);
-	if (cpu1Enabled == MV_ERROR) {
-		DB(mvOsPrintf("%s: Error: MV_SATR_CPU1_ENABLE is not active for board (using default)\n", __func__));
-		return 0;
+	if (mvCtrlSatRRead(MV_SATR_CPU1_ENABLE, &cpu1Enabled) != MV_OK) {
+		mvOsPrintf("%s: Error: failed to read CPU#1 status\n", __func__);
+		return 0; /* use single CPU */
 	} else
 		return cpu1Enabled;
 }
@@ -156,7 +155,10 @@ MV_BOOL mvCtrlIsValidSatR(MV_VOID)
 	MV_U32 i, cpuFreqMode, maxFreqModes = mvBoardFreqModesNumGet();
 	MV_FREQ_MODE pFreqModes[] = MV_USER_SAR_FREQ_MODES;
 
-	cpuFreqMode =  mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+	if (mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ, &cpuFreqMode) != MV_OK) {
+		mvOsPrintf("%s: Error: failed to read Frequency status\n", __func__);
+		return MV_FALSE;
+	}
 
 	for (i = 0; i < maxFreqModes; i++) {
 		if (cpuFreqMode == pFreqModes[i].id)
@@ -341,11 +343,16 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 *       else if write failed - returns MV_ERROR
 *
 *******************************************************************************/
-MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val)
+MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrReadField, MV_U8 val)
 {
 	MV_BOARD_SATR_INFO satrInfo;
 	MV_U8 readValue, verifyValue;
 
+	/* S@R Write field enums are following the read field enums,
+	 * with equal field order as the read fields, adaptively.
+	 * The write fields starts right after the last Read field */
+	MV_SATR_TYPE_ID satrWriteField = satrReadField + MV_SATR_READ_MAX_OPTION + 1;
+
 	if (satrReadField >= MV_SATR_READ_MAX_OPTION ||
 		satrWriteField >= MV_SATR_WRITE_MAX_OPTION) {
 		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ ,satrWriteField);
@@ -408,6 +415,7 @@ MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrRe
 * DESCRIPTION: Read S@R configuration Field
 *
 * INPUT: satrField - Field description enum
+*	 value - pointer for returned value
 *
 * OUTPUT: None
 *
@@ -416,14 +424,30 @@ MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrRe
 *       else if field is not relevant for running board, return 0xFFFFFFF.
 *
 *******************************************************************************/
-MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
+MV_STATUS mvCtrlSatRRead(MV_SATR_TYPE_ID satrField, MV_U32 *value)
 {
 	MV_BOARD_SATR_INFO satrInfo;
+
+	if (value == NULL) {
+		DB(mvOsPrintf("%s: Error: NULL pointer parameter\n", __func__));
+		return MV_ERROR;
+	}
+
 	if (satrField < MV_SATR_READ_MAX_OPTION &&
-			mvBoardSatrInfoConfig(satrField, &satrInfo, MV_TRUE) == MV_OK)
-		return satrOptionsConfig[satrField];
+			mvBoardSatrInfoConfig(satrField, &satrInfo, MV_TRUE) == MV_OK) {
+		*value = satrOptionsConfig[satrField];
+		return MV_OK;
+	}
 	else
 		return MV_ERROR;
+
+/* The last MV_ERROR indicates that a certain field is not relevant for board
+ * There is no print/indication needed for user in case this "error" occurs,
+ * as this could be a result of a Valid situation:
+ *  - when using "SatR read"-read all fields: this indicates which fields to print
+ *  - but when using "SatR read fieldX" -to read 1 X field: this will be handled
+ *    by caller, and will be followed with an appropriate error message
+ */
 }
 
 /*******************************************************************************
@@ -499,15 +523,20 @@ MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
 {
 	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
-	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+	MV_U32 freqModeSatRValue;
 
-	if (MV_ERROR != freqModeSatRValue) {
-		*freqMode = freqTable[freqModeSatRValue];
-		return MV_OK;
+	if (freqMode == NULL) {
+		mvOsPrintf("%s: Error: NULL pointer parameter\n", __func__);
+		return MV_ERROR;
 	}
 
-	DB(mvOsPrintf("%s: Error Read from S@R fail\n", __func__));
-	return MV_ERROR;
+	if (mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ, &freqModeSatRValue) != MV_OK) {
+		mvOsPrintf("%s: Error: failed to read frequency status\n", __func__);
+		return MV_ERROR;
+	}
+
+	*freqMode = freqTable[freqModeSatRValue];
+	return MV_OK;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index daad4a9..6310038 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -270,8 +270,8 @@ typedef struct _boardSerdesConf {
 #define SAR_CPU_FAB_GET(cpu, fab)       (((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
 
 /* mcspLib.h API list */
-MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val);
-MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField);
+MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrReadField, MV_U8 val);
+MV_STATUS mvCtrlSatRRead(MV_SATR_TYPE_ID satrField, MV_U32 *value);
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
 MV_VOID mvCtrlSatrInit(MV_VOID);
 MV_VOID mvCtrlSysConfigInit(MV_VOID);
-- 
1.7.5.4

