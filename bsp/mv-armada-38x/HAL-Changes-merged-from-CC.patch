From 018ae3f7dc310e5365b18825a77015e3889e171e Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Tue, 21 Aug 2012 17:32:48 +0300
Subject: [PATCH 0021/1825] HAL Changes merged from CC

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 03c7a5e3220dde2c9e1b92b5af28f147e7b77caf

Change-Id: If93352838c5495a8e2d09845874754af8353c030
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/common/mv802_3.h              |    8 +-
 arch/arm/plat-armada/linux_oss/mvOs.c              |    2 +-
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c        |   71 +++++++-
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.h        |   47 +++++-
 arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h    |   91 ++++++++--
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c     |   25 +++-
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h     |    1 +
 arch/arm/plat-armada/mv_hal/nfc/mvNfc.c            |   83 +++++-----
 arch/arm/plat-armada/mv_hal/norflash/mvFlash.c     |    2 +-
 arch/arm/plat-armada/mv_hal/pex/mvPex.c            |   22 +++-
 arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h        |    8 +-
 .../mv_hal/sata/CoreDriver/mvSataAddrDec.c         |    1 +
 arch/arm/plat-armada/mv_hal/spi/mvSpi.c            |    2 +-
 arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c          |  174 ++++++++++----------
 arch/arm/plat-armada/mv_hal/uart/mvUart.h          |   10 +-
 arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c     |   22 ++--
 arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c     |    1 +
 17 files changed, 377 insertions(+), 193 deletions(-)

diff --git a/arch/arm/plat-armada/common/mv802_3.h b/arch/arm/plat-armada/common/mv802_3.h
index 5723310..f01ce44 100644
--- a/arch/arm/plat-armada/common/mv802_3.h
+++ b/arch/arm/plat-armada/common/mv802_3.h
@@ -74,12 +74,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* 802.3 types */
 #define MV_IP_TYPE                  0x0800
 #define MV_IP_ARP_TYPE              0x0806
-#define MV_IP6_TYPE                 0x86dd
+#define MV_IP6_TYPE					0x86dd
 #define MV_APPLE_TALK_ARP_TYPE      0x80F3
 #define MV_NOVELL_IPX_TYPE          0x8137
-#define MV_EAPOL_TYPE               0x888e
-#define MV_VLAN_TYPE                0x8100
-#define MV_PPPOE_TYPE               0x8864
+#define MV_EAPOL_TYPE				0x888e
+#define MV_VLAN_TYPE				0x8100
+#define MV_PPPOE_TYPE				0x8864
 
 /* PPPoE protocol type */
 #define MV_IP_PPP  0x0021
diff --git a/arch/arm/plat-armada/linux_oss/mvOs.c b/arch/arm/plat-armada/linux_oss/mvOs.c
index db7018e..2fd6196 100644
--- a/arch/arm/plat-armada/linux_oss/mvOs.c
+++ b/arch/arm/plat-armada/linux_oss/mvOs.c
@@ -39,7 +39,7 @@ disclaimer.
 *******************************************************************************/
 
 /* includes */
-//#include <asm/processor.h>
+#include <asm/processor.h>
 #include "mvOs.h"
 
 static MV_U32 read_p15_c0 (void);
diff --git a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
index 24d8864..a656b28 100644
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.c
@@ -67,7 +67,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvSysCntmrConfig.h"
 #include "mvCntmrRegs.h"
-#include "mvCntmr.h"
+#include "cntmr/mvCntmr.h"
+#include "cpu/mvCpu.h"
 
 /* defines  */
 #ifdef MV_DEBUG
@@ -77,10 +78,18 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #endif
 
 #define CNTMR_EVENTS_STATUS_REG_GLOBAL	(MV_CNTMR_REGS_OFFSET + 4)
-#define TIMER_GLOBAL_BIT(timer)		(1 << (timer * 8 - ((timer == MAX_GLOBAL_TIMER) ? 1 : 0)))
 
-#define CNTMR_EVENTS_STATUS_REG_PRIVATE	(MV_CPUIF_REGS_OFFSET(0) + 0x68)
-#define TIMER_PRIVATE_BIT(timer)	(1 << ((timer - FIRST_PRIVATE_TIMER) * 8 + ((timer == TIMER7) ? 8 : 0)))
+#define TIMER_GLOBAL_BIT(timer)		((timer == MAX_GLOBAL_TIMER) ? (1<<31) : (1 << (timer * 8)))
+
+#ifdef MV88F78X60_Z1
+#define CNTMR_EVENTS_STATUS_REG_PRIVATE(t)	(MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(t) + 0x68))
+#define TIMER_PRIVATE_BIT(timer)	(1 << ((CPU_TIMER(timer) * 8)))
+#elif MV88F78X60_A0
+#define CNTMR_EVENTS_STATUS_REG_PRIVATE		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x68)
+#define TIMER_PRIVATE_BIT(timer)	(1 << ((timer - FIRST_PRIVATE_TIMER) * 8)))
+#else
+#error "No device is defined!"
+#endif
 
 /*******************************************************************************
 * mvCntmrLoad -
@@ -181,16 +190,24 @@ MV_STATUS mvCntmrCtrlSet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 
 	/* read control register */
 	cntmrCtrl = MV_REG_READ(CNTMR_CTRL_REG(countNum));
+	cntmrCtrl &= ~((CTCR_ARM_TIMER_EN_MASK(countNum)) | (CTCR_ARM_TIMER_AUTO_MASK(countNum)));
 
 	if (pCtrl->enable)	/* enable counter\timer */
 		cntmrCtrl |= (CTCR_ARM_TIMER_EN(countNum));
-	else			/* disable counter\timer */
-		cntmrCtrl &= ~(CTCR_ARM_TIMER_EN(countNum));
 
 	if (pCtrl->autoEnable)	/* Auto mode */
 		cntmrCtrl |= (CTCR_ARM_TIMER_AUTO_EN(countNum));
-	else			/* no auto mode */
-		cntmrCtrl &= ~(CTCR_ARM_TIMER_AUTO_EN(countNum));
+
+#ifndef MV88F78X60_Z1
+	cntmrCtrl &= ~((CTCR_ARM_TIMER_RATIO_MASK(countNum)) | (CTCR_ARM_TIMER_25MhzFRQ_MASK(countNum)));
+
+	cntmrCtrl |= (pCtrl->Ratio & 0x7) << (CTCR_ARM_TIMER_RATIO_OFFS(countNum));
+
+	if (pCtrl->enable_25Mhz)	/* 25Mhz enable */
+		cntmrCtrl |= (CTCR_ARM_TIMER_25MhzFRQ_EN(countNum));
+
+#endif
+
 
 	MV_REG_WRITE(CNTMR_CTRL_REG(countNum), cntmrCtrl);
 
@@ -238,6 +255,13 @@ MV_STATUS mvCntmrCtrlGet(MV_U32 countNum, MV_CNTMR_CTRL *pCtrl)
 	else
 		pCtrl->autoEnable = MV_FALSE;
 
+
+#ifndef MV88F78X60_Z1
+	pCtrl->Ratio = (cntmrCtrl & (CTCR_ARM_TIMER_RATIO_MASK(countNum))) / (1 << (CTCR_ARM_TIMER_RATIO_OFFS(countNum)));
+
+	pCtrl->enable_25Mhz = (cntmrCtrl & CTCR_ARM_TIMER_25MhzFRQ_MASK(countNum)) ? MV_TRUE : MV_FALSE;
+#endif
+
 	return MV_OK;
 }
 
@@ -379,7 +403,38 @@ MV_STATUS mvCntmrIntClear(MV_U32 cntmrNum)
 		/* Reset cause bit to acknowledge interrupt */
 		MV_REG_WRITE(CNTMR_EVENTS_STATUS_REG_GLOBAL, ~(TIMER_GLOBAL_BIT(cntmrNum)));
 	} else {
+#ifdef MV88F78X60_Z1
+		MV_REG_WRITE(CNTMR_EVENTS_STATUS_REG_PRIVATE(cntmrNum), ~(TIMER_PRIVATE_BIT(cntmrNum)));
+#else
 		MV_REG_WRITE(CNTMR_EVENTS_STATUS_REG_PRIVATE, ~(TIMER_PRIVATE_BIT(cntmrNum)));
+#endif
 	}
 	return MV_OK;
 }
+/*******************************************************************************
+* mvCntmrFrqGet - get Counter/Timer Frequency.
+*
+* DESCRIPTION:
+*       This routine retuen timer clock Frequency
+*
+* INPUT:
+*       cntmrNum - Counter/Timer number.
+*
+* OUTPUT:
+*       timer clock Frequency.
+*
+* RETURN:
+*       ERROR - In case of invalid parameters.
+*
+*******************************************************************************/
+MV_U32 mvCntmrFrqGet(MV_U32 cntmrNum)
+{
+#ifndef MV88F78X60_Z1
+	if (INVALID_CNTMR(cntmrNum))
+		return MV_ERROR;
+
+	if (cntmrCtrl & CTCR_ARM_TIMER_25MhzFRQ_MASK(countNum))
+		return MV_BOARD_REFCLK_25MHZ;
+#endif
+	return mvCpuL2ClkGet();
+}
diff --git a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.h b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.h
index 72b34ad..8ce5fd7 100644
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.h
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmr.h
@@ -78,21 +78,48 @@ extern "C" {
 /* This enumerator describe counters\watchdog numbers       */
 	typedef enum _mvCntmrID {
 		TIMER0 = 0,		/* Global counter 0 */
-		TIMER1,         /* Global counter 1 */
-		TIMER2,         /* Global counter 2 */
-		TIMER3,         /* Global counter 3 */
-		TIMER4,         /* Global Watchdog 0*/
-		TIMER5,         /* CPU Timer 0  	*/
-		TIMER6,         /* CPU Timer 1  	*/
-		TIMER7          /* CPU Watchdog 	*/
+		TIMER1,			/* Global counter 1 */
+		TIMER2,			/* Global counter 2 */
+		TIMER3,			/* Global counter 3 */
+		TIMER4,			/* Global Watchdog 0*/
+		TIMER5,			/* CPU0 Timer 0   for A0 this is private CPU timer 0  */
+		TIMER6, 		/* CPU0 Timer 1   for A0 this is private CPU timer 1   */
+		TIMER7, 		/* CPU0 Watchdog  for A0 this is private CPU WD  */
+#ifdef MV88F78X60_Z1
+		TIMER8, 		/* CPU1 Timer 0     */
+		TIMER9, 		/* CPU1 Timer 1     */
+		TIMER10,		/* CPU1 Watchdog    */
+		TIMER11,		/* CPU2 Timer 0     */
+		TIMER12,		/* CPU2 Timer 1     */
+		TIMER13,		/* CPU2 Watchdog    */
+		TIMER14,		/* CPU73 Timer 0    */
+		TIMER15,		/* CPU73 Timer 1    */
+		TIMER16 		/* CPU73 Watchdog   */
+#endif
 	} MV_CNTMR_ID;
+
 #define MAX_GLOBAL_TIMER	TIMER4
 #define FIRST_PRIVATE_TIMER TIMER5
 
+	typedef enum _mvCntmrRatio {
+		MV_RATIO_1  = 0,  /*  0 = 1: Timer tic occurs every source clock        */
+		MV_RATIO_2,       /*  1 = 2: Timer tic occurs every 2 source clocks     */
+		MV_RATIO_4,       /*  2 = 4: Timer tic occurs every 4 source clocks     */
+		MV_RATIO_8,       /*  3 = 8: Timer tic occurs every 8 source clocks     */
+		MV_RATIO_16,      /*  4 = 16: Timer tic occurs every 16 source clocks   */
+		MV_RATIO_32,      /*  5 = 32: Timer tic occurs every 32 source clocks   */
+		MV_RATIO_64,      /*  6 = 64: Timer tic occurs every 64 source clocks   */
+		MV_RATIO_128      /*  7 = 128: Timer tic occurs every 128 source clocks */
+	} MV_CNTMR_RATIO_ID;
+
 /* Counter / Timer control structure */
 	typedef struct _mvCntmrCtrl {
 		MV_BOOL enable;	/* enable */
-		MV_BOOL autoEnable;	/* counter/Timer                    */
+		MV_BOOL autoEnable;	/* counter/Timer  */
+#ifndef MV88F78X60_Z1
+		MV_CNTMR_RATIO_ID	Ratio;
+		MV_BOOL enable_25Mhz;	/* enable timer count frequency is to 25Mhz*/
+#endif
 	} MV_CNTMR_CTRL;
 
 /* Functions */
@@ -124,6 +151,10 @@ extern "C" {
 /*	Clear an Counter/Timer interrupt (Ack) */
 	MV_STATUS mvCntmrIntClear(MV_U32 cntmrNum);
 
+/*	get Counter/Timer Frequency */
+	MV_U32 mvCntmrFrqGet(MV_U32 cntmrNum);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h
index 08c3368..256dceb 100644
--- a/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h
+++ b/arch/arm/plat-armada/mv_hal/cntmr/mvCntmrRegs.h
@@ -76,27 +76,64 @@ extern "C" {
 /* ARM Timers Registers Map                */
 /*******************************************/
 /*
-	TIMER0 = Global counter 0
-	TIMER1 = Global counter 1
-	TIMER2 = Global counter 2
-	TIMER3 = Global counter 3
-	TIMER4 = Global Watchdog 0
-	TIMER5 = CPU Timer 0
-	TIMER6 = CPU Timer 1
-	TIMER7 = CPU Watchdog
+	TIMER0  = Global counter 0
+	TIMER1  = Global counter 1
+	TIMER2  = Global counter 2
+	TIMER3  = Global counter 3
+	TIMER4  = Global Watchdog 0
+	TIMER5  = CPU0 Timer 0
+	TIMER6  = CPU0 Timer 1
+	TIMER7  = CPU0 Watchdog
+	TIMER8  = CPU1 Timer 0
+	TIMER9  = CPU1 Timer 1
+	TIMER10 = CPU1 Watchdog
+	TIMER11 = CPU2 Timer 0
+	TIMER12 = CPU2 Timer 1
+	TIMER13 = CPU2 Watchdog
+	TIMER14 = CPU73 Timer 0
+	TIMER15 = CPU73 Timer 1
+	TIMER16 = CPU73 Watchdog
 */
 #define INVALID_CNTMR(cntmrNum)    	((cntmrNum) >= MV_CNTMR_MAX_COUNTER)
 
+#ifdef MV88F78X60_Z1
+#define TIMER_TO_CPU(t)			((t < TIMER8) ? 0 :					\
+											((t < TIMER11) ? 1 : 	\
+											((t < TIMER14) ? 2 : 3)))
+#define CPU_TIMER(t)			((t < TIMER8) ? (t-TIMER5) :					\
+											((t < TIMER11) ? (t-TIMER8) :	\
+											((t < TIMER14) ? (t-TIMER11) : (t-TIMER14))))
+#else
+#define CPU_TIMER(t)			(t-TIMER5)
+#endif
+
+
+#ifdef MV88F78X60_Z1
 #define CNTMR_BASE(tmrNum)		((tmrNum <= MAX_GLOBAL_TIMER) ? (MV_CNTMR_REGS_OFFSET) : \
-						(MV_CPUIF_REGS_OFFSET(0) + 0x40))
+								(MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(tmrNum)) + 0x40))
 
-#define CNTMR_RELOAD_REG(tmrNum)	((CNTMR_BASE(tmrNum)) + 0x10 + \
-						(((tmrNum <= MAX_GLOBAL_TIMER) ? (tmrNum * 8) : \
-						((tmrNum-FIRST_PRIVATE_TIMER) * 8))))
+#define CNTMR_RELOAD_REG(tmrNum)	 ((tmrNum <= MAX_GLOBAL_TIMER) ? 				 \
+										(CNTMR_BASE(tmrNum)  + 0x10 + (tmrNum * 8)) : \
+										((MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(tmrNum)) + 0x50+CPU_TIMER(tmrNum)*8)))
 
-#define CNTMR_VAL_REG(tmrNum)		((CNTMR_BASE(tmrNum)) + 0x14 + \
-						(((tmrNum <= MAX_GLOBAL_TIMER) ? (tmrNum * 8) : \
-						((tmrNum-FIRST_PRIVATE_TIMER) * 8))))
+#define CNTMR_VAL_REG(tmrNum)		((tmrNum <= MAX_GLOBAL_TIMER) ? 					 \
+										(CNTMR_BASE(tmrNum)  + 0x14 + (tmrNum * 8)) : \
+										((MV_CPUIF_REGS_OFFSET(TIMER_TO_CPU(tmrNum)) + 0x54+CPU_TIMER(tmrNum)*8)))
+
+
+#else
+#define CNTMR_BASE(tmrNum)		((tmrNum <= MAX_GLOBAL_TIMER) ? (MV_CNTMR_REGS_OFFSET) : \
+																(MV_CPUIF_LOCAL_REGS_OFFSET + 0x40))
+
+#define CNTMR_RELOAD_REG(tmrNum)	 ((tmrNum <= MAX_GLOBAL_TIMER) ? 				 \
+										(CNTMR_BASE(tmrNum)  + 0x10 + (tmrNum * 8)) : \
+										(MV_CPUIF_LOCAL_REGS_OFFSET + 0x50 + ((tmrNum-5) * 8)))
+
+#define CNTMR_VAL_REG(tmrNum)		((tmrNum <= MAX_GLOBAL_TIMER) ? 					 \
+										(CNTMR_BASE(tmrNum)  + 0x14 + (tmrNum * 8)) : \
+										(MV_CPUIF_LOCAL_REGS_OFFSET + 0x54 + ((tmrNum-5) * 8)))
+
+#endif
 
 /* #define CNTMR_CTRL_REG(tmrNum)	(tmrNum <=MAX_GLOBAL_TIMER) ? (MV_CNTMR_REGS_OFFSET) :
 						 (MV_CPUIF_REGS_OFFSET(0) + 0x84) */
@@ -108,18 +145,36 @@ extern "C" {
 /* ARM Timers Control Register */
 /* CPU_TIMERS_CTRL_REG (CTCR) */
 
-#define CTCR_ARM_TIMER_EN_OFFS(timer)	((timer <= MAX_GLOBAL_TIMER) ? (timer * 2) : \
-						((timer-FIRST_PRIVATE_TIMER) * 2))
+#define CTCR_ARM_TIMER_EN_OFFS(timer)	((timer <= MAX_GLOBAL_TIMER) ? (timer * 2) : ((CPU_TIMER(timer))*2))
+
 #define CTCR_ARM_TIMER_EN_MASK(cntr)	(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_EN(cntr)		(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_DIS(cntr)	(0 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 
 #define CTCR_ARM_TIMER_AUTO_OFFS(timer)	((timer <= MAX_GLOBAL_TIMER) ? (1 + (timer * 2)) : \
-						(1 + (timer-FIRST_PRIVATE_TIMER) * 2))
+										(1 + ((CPU_TIMER(timer))) * 2))
 #define CTCR_ARM_TIMER_AUTO_MASK(cntr)	(1 << CTCR_ARM_TIMER_EN_OFFS(cntr))
 #define CTCR_ARM_TIMER_AUTO_EN(cntr)	(1 << CTCR_ARM_TIMER_AUTO_OFFS(cntr))
 #define CTCR_ARM_TIMER_AUTO_DIS(cntr)	(0 << CTCR_ARM_TIMER_AUTO_OFFS(cntr))
 
+
+#define CTCR_ARM_TIMER_RATIO_OFFS(timer) ((timer < TIMER4) ? (19 + timer*3) :	\
+										 ((timer == TIMER4) ? 16 :				\
+										 ((CPU_TIMER(timer) == 0) ? 19 :      \
+										 ((CPU_TIMER(timer) == 1) ? 22 : 16))))
+
+#define CTCR_ARM_TIMER_RATIO_MASK(cntr)	(0x7 << CTCR_ARM_TIMER_RATIO_OFFS(cntr))
+
+#define CTCR_ARM_TIMER_25MhzFRQ_ENABLE_OFFS(timer) ((timer < TIMER4) ? (11 + timer) :		\
+													 ((timer == TIMER4) ? 10 :				\
+													 ((CPU_TIMER(timer) == 0) ? 11 :	\
+													 ((CPU_TIMER(timer) == 1) ? 12 : 10))))
+
+#define CTCR_ARM_TIMER_25MhzFRQ_MASK(cntr)	(1 << CTCR_ARM_TIMER_25MhzFRQ_ENABLE_OFFS(cntr))
+#define CTCR_ARM_TIMER_25MhzFRQ_EN(cntr)	(1 << CTCR_ARM_TIMER_25MhzFRQ_ENABLE_OFFS(cntr))
+#define CTCR_ARM_TIMER_25MhzFRQ_DIS(cntr)	(0 << CTCR_ARM_TIMER_25MhzFRQ_ENABLE_OFFS(cntr))
+
+
 /* ARM Timer\Watchdog Reload Register */
 /* CNTMR_RELOAD_REG (TRR) */
 
diff --git a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
index 4c7bc0e..6d8695f 100644
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
@@ -191,10 +191,10 @@ MV_STATUS mvEthPhyInit(MV_U32 ethPortNum, MV_BOOL eeeEnable)
 	case MV_PHY_88E1240:
 	case MV_PHY_88E1149R:
 	case MV_PHY_88E1119R:
-            return MV_NO_SUCH;
+		return MV_NO_SUCH;
 	default:
-			mvOsPrintf("Unknown Device(%#x). Initialization failed\n", deviceId);
-			return MV_ERROR;
+		mvOsPrintf("Unknown Device(%#x). Initialization failed\n", deviceId);
+		return MV_ERROR;
 	}
 	return MV_OK;
 }
@@ -1235,7 +1235,7 @@ MV_VOID mvEth1540PhyBasicInit(MV_U32 ethPortNum, MV_BOOL eeeEnable)
 {
 	MV_U16 reg;
 	MV_U16 i = ethphyHalData.phyAddr[ethPortNum];
-
+	MV_U16 LinkCryptPortAddr = ethphyHalData.LinkCryptPortAddr[ethPortNum];
 	/* Set page to 0. */
 	mvEthPhyRegWrite(i, 0x16, 0);
 
@@ -1664,6 +1664,21 @@ MV_VOID mvEth1540PhyBasicInit(MV_U32 ethPortNum, MV_BOOL eeeEnable)
 	/*  RW U1 P0 R22 H0000 */
 	mvEthPhyRegWrite(i, 0x16, 0x0000);
 
+	/* Change MRU to Max : Page 16 */
+	mvEthPhyRegWrite(i, 0x16, 0x0010);
+
+	/* Write LinkCrypt Address */
+	mvEthPhyRegWrite(i, 0x1, LinkCryptPortAddr+0x0040);
+
+	/* Write LinkCrypt Data Low */
+	mvEthPhyRegWrite(i, 0x2, 0xFFF9);
+
+	/* Write LinkCrypt Data High */
+	mvEthPhyRegWrite(i, 0x3, 0x1);
+
+	mvEthPhyRegWrite(i, 0x16, 0x0000);
+
+
 	/* Power up the phy */
 	mvEthPhyRegRead(i, ETH_PHY_CTRL_REG, &reg);
 	reg &= ~(ETH_PHY_CTRL_POWER_DOWN_MASK);
@@ -1704,7 +1719,7 @@ MV_VOID mvEth1340PhyBasicInit(void)
 
 		mvEthPhyRegRead(i, ETH_PHY_CTRL_REG, &reg);
 		reg &= ~(ETH_PHY_CTRL_POWER_DOWN_MASK);
-		reg |= 0x1<<9;// workaround - restart workaround - restart workaround - restart workaround - restart
+		reg |= 0x1<<9;	/* workaround - restart workaround - restart workaround - restart workaround - restart */
 		mvEthPhyRegWrite(i, ETH_PHY_CTRL_REG, reg);
 
 
diff --git a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
index df45df5..4a3076d 100644
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
@@ -104,6 +104,7 @@ extern "C" {
 
 typedef struct {
 	MV_U32		phyAddr[MV_ETH_MAX_PORTS];
+	MV_U32		LinkCryptPortAddr[MV_ETH_MAX_PORTS];
 	MV_BOOL		boardSpecInit;		/* Special board phy init */
 	MV_U32		specRegOff;		/* Board specific register offset, Valid if boardSpecInit == TRUE */
 	MV_U32		specData;  		/* Board specific data to write, Valid if boardSpecInit == TRUE */
diff --git a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
index 269e0c6..89a6a9a 100644
--- a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
+++ b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
@@ -442,25 +442,25 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	},
 	{			/* Micron 8Gb */
 	.tADL = 100,		/* tADL, Address to write data delay */
-        .tCH = 5,		/* tCH, Enable signal hold time */
-        .tCS = 25,		/* tCS, Enable signal setup time */
-        .tWH = 10,		/* tWH, ND_nWE high duration */
-        .tWP = 15,		/* tWP, ND_nWE pulse time */
-        .tRH = 10,		/* tRH, ND_nRE high duration */
-        .tRP = 15,		/* tRP, ND_nRE pulse width */
-        .tR = 25241,		/* tR = data transfer from cell to register tR = tR+tRR+tWB+1 */
-        .tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
-        .tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
-        .tRHW = 100,		/* tRHW, ND_nRE high to ND_nWE low delay */
-        .pgPrBlk = 128,		/* Pages per block - detected */
-        .pgSz = 4096,		/* Page size */
-        .oobSz = 224,		/* Spare size */
-        .blkNum = 2048,		/* Number of blocks/sectors in the flash */
-        .id = 0x382C,		/* Device ID 0xDevice,Vendor */
-        .model = "Micron 8Gb 8bit",
-        .bb_page = 0,		/* Manufacturer Bad block marking page in block */
-        .flags = (NFC_CLOCK_UPSCALE_250M | NFC_FLAGS_ONFI_MODE_3_SET)
-        }
+	.tCH = 5,		/* tCH, Enable signal hold time */
+	.tCS = 25,		/* tCS, Enable signal setup time */
+	.tWH = 10,		/* tWH, ND_nWE high duration */
+	.tWP = 15,		/* tWP, ND_nWE pulse time */
+	.tRH = 10,		/* tRH, ND_nRE high duration */
+	.tRP = 15,		/* tRP, ND_nRE pulse width */
+	.tR = 25241,		/* tR = data transfer from cell to register tR = tR+tRR+tWB+1 */
+	.tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
+	.tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
+	.tRHW = 100,		/* tRHW, ND_nRE high to ND_nWE low delay */
+	.pgPrBlk = 128,		/* Pages per block - detected */
+	.pgSz = 4096,		/* Page size */
+	.oobSz = 224,		/* Spare size */
+	.blkNum = 2048,		/* Number of blocks/sectors in the flash */
+	.id = 0x382C,		/* Device ID 0xDevice,Vendor */
+		.model = "Micron 8Gb 8bit",
+	.bb_page = 0,		/* Manufacturer Bad block marking page in block */
+	.flags = (NFC_CLOCK_UPSCALE_250M | NFC_FLAGS_ONFI_MODE_3_SET)
+	}
 };
 
 /* Defined Command set */
@@ -531,30 +531,32 @@ static MV_STATUS mvDfcWait4Complete(MV_U32 statMask, MV_U32 usec);
 static MV_STATUS mvNfcReadIdNative(MV_NFC_CHIP_SEL cs, MV_U16 *id);
 static MV_STATUS mvNfcTimingSet(MV_U32 tclk, MV_NFC_FLASH_INFO *flInfo);
 static MV_U32 mvNfcColBits(MV_U32 pg_size);
+/* #ifdef CONFIG_MTD_NAND_NFC_INIT_RESET */
 static MV_STATUS mvNfcReset(void);
+/* #endif */
 static MV_STATUS mvNfcDeviceFeatureSet(MV_NFC_CTRL *nfcCtrl, MV_U8 cmd, MV_U8 addr, MV_U32 data0, MV_U32 data1);
 static MV_STATUS mvNfcDeviceFeatureGet(MV_NFC_CTRL *nfcCtrl, MV_U8 cmd, MV_U8 addr, MV_U32 *data0, MV_U32 *data1);
 static MV_STATUS mvNfcDeviceModeSet(MV_NFC_CTRL *nfcCtrl, MV_NFC_ONFI_MODE mode);
 
 MV_VOID setNANDClock(MV_U32 nClock)
 {
-    //Set the division ratio of ECC Clock 0x00018748[13:8] (by default it's double of core clock)
+    /* Set the division ratio of ECC Clock 0x00018748[13:8] (by default it's double of core clock) */
     MV_U32 nVal = MV_REG_READ(0x18748);
     nVal = nVal & ~(BIT8|BIT9|BIT10|BIT11|BIT12|BIT13);
     nVal = nVal | (nClock<<8);
-    MV_REG_WRITE(0x18748,nVal);
+    MV_REG_WRITE(0x18748, nVal);
 
-    //Set reload force of ECC clock 0x00018740[7:0] to 0x2 (meaning you will force only the ECC clock)
+    /* Set reload force of ECC clock 0x00018740[7:0] to 0x2 (meaning you will force only the ECC clock) */
     nVal = MV_REG_READ(0x18740);
     nVal = nVal & ~(0xff);
     nVal = nVal | 0x2;
-    MV_REG_WRITE(0x18740,nVal);
+    MV_REG_WRITE(0x18740, nVal);
 
-    //Set reload ratio bit 0x00018740[8] to 1'b1
-    MV_REG_BIT_SET(0x18740,BIT8);
-    mvOsDelay(1); // msec
-    //Set reload ratio bit 0x00018740[8] to 1'b1
-    MV_REG_BIT_RESET(0x18740,BIT8);
+    /* Set reload ratio bit 0x00018740[8] to 1'b1 */
+    MV_REG_BIT_SET(0x18740, BIT8);
+    mvOsDelay(1); /*  msec */
+    /* Set reload ratio bit 0x00018740[8] to 1'b1 */
+    MV_REG_BIT_RESET(0x18740, BIT8);
 }
 
 /*******************************************************************************
@@ -590,8 +592,8 @@ MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl)
 
 	/*
 	 Reduce NAND clock for supporting slower flashes for initialization
- 	 ECC engine clock = (2Ghz / divider)
- 	 NFC clock = ECC clock / 2
+	 ECC engine clock = (2Ghz / divider)
+	 NFC clock = ECC clock / 2
 	 */
 	setNANDClock(8); /* Go down to 125MHz */
 	nand_clock = 125000000;
@@ -634,10 +636,12 @@ MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl)
 	/* Write registers before device detection */
 	MV_REG_WRITE(NFC_CONTROL_REG, ctrl_reg);
 
+/* #ifdef CONFIG_MTD_NAND_NFC_INIT_RESET */
 	/* reset the device */
 	ret = mvNfcReset();
 	if (ret != MV_OK)
 		return ret;
+/* #endif */
 
 	/* Read the device ID */
 	ret = mvNfcReadIdNative(nfcCtrl->currCs, &read_id);
@@ -655,14 +659,14 @@ MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl)
 		nfcCtrl->flashIdx = i;
 
 	/* In case of ONFI Mode set needed */
-	if (flashDeviceInfo[i].flags &= NFC_FLAGS_ONFI_MODE_3_SET) {
+	if (flashDeviceInfo[i].flags & NFC_FLAGS_ONFI_MODE_3_SET) {
 		ret = mvNfcDeviceModeSet(nfcCtrl, MV_NFC_ONFI_MODE_3);
 		if (ret != MV_OK)
 			return ret;
 	}
 
 	/* Critical Initialization done. Raise NFC clock if needed */
-	if (flashDeviceInfo[i].flags &= NFC_CLOCK_UPSCALE_250M) {	
+	if (flashDeviceInfo[i].flags & NFC_CLOCK_UPSCALE_250M) {
 		setNANDClock(4);
 		nand_clock = 250000000;
 	}
@@ -676,7 +680,7 @@ MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl)
 	/* calculate Timing parameters */
 	ret = mvNfcTimingSet(nand_clock, &flashDeviceInfo[i]);
 	if (ret != MV_OK)
- 		return ret;
+		return ret;
 
 	/* Configure the control register based on the device detected */
 	ctrl_reg = MV_REG_READ(NFC_CONTROL_REG);
@@ -2303,7 +2307,7 @@ static MV_STATUS mvNfcDeviceFeatureSet(MV_NFC_CTRL *nfcCtrl, MV_U8 cmd, MV_U8 ad
 	if (errCode != MV_OK)
 		return errCode;
 
-	udelay(100);
+	mvOsUDelay(100);
 
 	MV_REG_WRITE(NFC_DATA_BUFF_REG, data0);
 	MV_REG_WRITE(NFC_DATA_BUFF_REG, data1);
@@ -2449,20 +2453,19 @@ static MV_STATUS mvNfcDeviceModeSet(MV_NFC_CTRL *nfcCtrl, MV_NFC_ONFI_MODE mode)
 		ret = mvNfcDeviceFeatureSet(nfcCtrl, 0xEF, 0x01, 0x00000013, 0);
 		if (ret != MV_OK)
 			return ret;
-		
+
 		/* Verify mode setting */
 		mvNfcDeviceFeatureGet(nfcCtrl, 0xEE, 0x01, &d0, &d1);
-		if(d0 != 3)
+		if (d0 != 3)
 			return MV_BAD_VALUE;
-	}
-	else
+	} else
 		return MV_FAIL;
 
 	return MV_OK;
 }
 
 
-//#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+/* #ifdef CONFIG_MTD_NAND_NFC_INIT_RESET */
 static MV_STATUS mvNfcReset(void)
 {
 	MV_U32 reg;
@@ -2506,7 +2509,7 @@ static MV_STATUS mvNfcReset(void)
 Error:
 	return errCode;
 }
-//#endif
+/* #endif */
 /*******************************************************************************
 * mvNfcReadIdNative
 *
diff --git a/arch/arm/plat-armada/mv_hal/norflash/mvFlash.c b/arch/arm/plat-armada/mv_hal/norflash/mvFlash.c
index 9bf9412..82939dbb 100644
--- a/arch/arm/plat-armada/mv_hal/norflash/mvFlash.c
+++ b/arch/arm/plat-armada/mv_hal/norflash/mvFlash.c
@@ -101,7 +101,7 @@ FLASH_STRUCT supFlashAry[] = {
 /*  flashVen       flashId              size #sec  secType #Frag pFragList HWprot HwWrBuff */
 	{INTEL_MANUF,	INTEL_FID_28F256P30B,	_32M,	259,	BOTTOM,	 4, IntelSecFrag, MV_TRUE, 64},
 	{INTEL_MANUF,	INTEL_FID_28F640J3A,	_8M,	64,	REGULAR, 0, NULL, 	MV_TRUE, 32},
-#if NOR_INTEL_FID_28F128J3A_65
+#ifdef NOR_INTEL_FID_28F128J3A_65
 	/* Application Note - 308038 */
 	{INTEL_MANUF,	INTEL_FID_28F128J3A,	_16M,	128,	REGULAR, 0, NULL,	MV_TRUE, 256},
 #else
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPex.c b/arch/arm/plat-armada/mv_hal/pex/mvPex.c
index 73dcb07..11c4579 100644
--- a/arch/arm/plat-armada/mv_hal/pex/mvPex.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPex.c
@@ -85,7 +85,7 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType, MV_PEX_HAL_DATA *halData)
 	MV_PEX_MODE pexMode;
 	MV_U32 regVal;
 	MV_U32 status;
-	MV_U16 ctrlModel, phyRegVal;
+	MV_U16 ctrlModel, phyRegVal = 0;
 
 	mvOsMemcpy(&pexHalData[pexIf], halData, sizeof(MV_PEX_HAL_DATA));
 
@@ -130,6 +130,26 @@ MV_STATUS mvPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType, MV_PEX_HAL_DATA *halData)
 		regVal |= 0x4;	/* Set the new value        */
 		regVal &= ~0x80000000;	/* Set "write" command      */
 		MV_REG_WRITE(PEX_PHY_ACCESS_REG(pexIf), regVal);	/* Write the write command  */
+#ifndef MV88F78X60_Z1
+		/* in DSMP A0 we should enable the target link width */
+		/* Read current value of Dynamic width management register 0x1A30*/
+		regVal = MV_REG_READ(PEX_DYNMC_WIDTH_MNG_REG(pexIf));	/* Read the dynamic width management register */
+		regVal &= ~0x3;	/* Clear bits [1:0]         */
+		regVal |= 0x3;	/* Set the new value '11'   */
+		MV_REG_WRITE(PEX_DYNMC_WIDTH_MNG_REG(pexIf), regVal);	/* Write the new value */
+
+		/* Enabling the SSPL message */
+		regVal = MV_REG_READ(PEX_ROOT_CMPLX_SSPL_REG(pexIf));	/* Read the PEX root complex SSPL register */
+		regVal &= ~0x10000;	/* Clear bit [16]         */
+		regVal |= 0x10000;	/* Set the new value  '1' */
+		MV_REG_WRITE(PEX_ROOT_CMPLX_SSPL_REG(pexIf), regVal);	/* Write the new value */
+
+		/* Setting dynamic speed*/
+		regVal = MV_REG_READ(PEX_CTRL_REG(pexIf));	/* Read the PEX control register */
+		regVal &= ~0x400;	/* Clear bit [10]         */
+		regVal |= 0x400;	/* Set the new value '11'   */
+		MV_REG_WRITE(PEX_CTRL_REG(pexIf), regVal);	/* Write the new value */
+#endif
 	} else {
 		/* Implement 1.0V termination GL for 88F1281 device only */
 		/* BIT0 - Common mode feedback */
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h b/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
index f4a14af..73a4a3d 100644
--- a/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPexRegs.h
@@ -178,11 +178,11 @@ extern "C" {
 #define PEX_COMPLT_TMEOUT_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A10)
 #define PEX_PWR_MNG_EXT_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A18)
 #define PEX_FLOW_CTRL_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A20)
-#define PEX_ACK_TMR_4X_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A30)
+#define PEX_DYNMC_WIDTH_MNG_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A30)
+#define PEX_ROOT_CMPLX_SSPL_REG(pexif)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A0C)
 #define PEX_ACK_TMR_1X_REG(pexIf)			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A40)
 #define PEX_TL_CTRL_REG(pexIf)				(MV_PEX_IF_REGS_BASE(pexIf) - (pexIf)*0x10000)
-
-#define PEX_RAM_PARITY_CTRL_REG(pexIf) 		((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A50)
+#define PEX_RAM_PARITY_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A50)
 #define PEX_DBG_CTRL_REG(pexIf) 			((MV_PEX_IF_REGS_BASE(pexIf)) + 0x1A60)
 /* PCI Express Control Register */
 
@@ -634,7 +634,7 @@ extern "C" {
 #define PXLCR_MAX_LINK_SPD_OFFS		0	/* Maximum Link Speed */
 #define PXLCR_MAX_LINK_SPD_MASK		(0xf << PXLCR_MAX_LINK_SPD_OFFS)
 
-#define PXLCR_MAX_LNK_WDTH_OFFS 	3	/* Maximum Link Width */
+#define PXLCR_MAX_LNK_WDTH_OFFS 	4	/* Maximum Link Width */
 #define PXLCR_MAX_LNK_WDTH_MASK		(0x3f << PXLCR_MAX_LNK_WDTH_OFFS)
 
 #define PXLCR_ASPM_SUP_OFFS 		10	/* Active State Link PM Support */
diff --git a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
index 9d530b7..1d6f99a 100644
--- a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
@@ -63,6 +63,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 
 #include "mvCommon.h"
+#include "mvSysHwConfig.h"
 #include "mvOs.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvRegs.h"
diff --git a/arch/arm/plat-armada/mv_hal/spi/mvSpi.c b/arch/arm/plat-armada/mv_hal/spi/mvSpi.c
index ccbbc91..f92bb1f 100644
--- a/arch/arm/plat-armada/mv_hal/spi/mvSpi.c
+++ b/arch/arm/plat-armada/mv_hal/spi/mvSpi.c
@@ -129,7 +129,7 @@ MV_STATUS mvSpiParamsSet(MV_U8 spiId, MV_U8 csId, MV_SPI_TYPE type)
 
 	if (currSpiInfo != (&(spiTypes[type]))) {
 		currSpiInfo = &(spiTypes[type]);
-		mvSpiBaudRateSet(0, currSpiInfo->baudRate);
+		mvSpiBaudRateSet(spiId, currSpiInfo->baudRate);
 	}
 
 	return MV_OK;
diff --git a/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c b/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
index 7591919..257be24 100644
--- a/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
+++ b/arch/arm/plat-armada/mv_hal/twsi/mvTwsi.c
@@ -163,7 +163,7 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 
 	/* check the status */
 	temp = twsiStsGet(chanNum);
-	if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
+	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
 		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", temp));
 		return MV_RETRY;
 	} else if ((temp != TWSI_START_CON_TRA) && (temp != TWSI_REPEATED_START_CON_TRA)) {
@@ -221,7 +221,7 @@ MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
 
 	/* check the status */
 	temp = twsiStsGet(chanNum);
-	if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
+	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
 		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", val));
 		return MV_RETRY;
 	} else if (temp != TWSI_NO_REL_STS_INT_FLAG_IS_KEPT_0) {
@@ -561,7 +561,7 @@ static MV_STATUS twsiAddr10BitSet(MV_U8 chanNum, MV_U32 deviceAddress, MV_TWSI_C
 
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
+	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
 		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", val));
 		return MV_RETRY;
 	} else if (((val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ)) ||
@@ -590,7 +590,7 @@ static MV_STATUS twsiAddr10BitSet(MV_U8 chanNum, MV_U32 deviceAddress, MV_TWSI_C
 
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
+	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
 		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", val));
 		return MV_RETRY;
 	} else if (((val != TWSI_SEC_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ)) ||
@@ -652,7 +652,7 @@ static MV_STATUS twsiAddr7BitSet(MV_U8 chanNum, MV_U32 deviceAddress, MV_TWSI_CM
 
 	/* check the status */
 	val = twsiStsGet(chanNum);
-	if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
+	if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == val) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == val)) {
 		DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", val));
 		return MV_RETRY;
 	} else if (((val != TWSI_AD_PLS_RD_BIT_TRA_ACK_REC) && (command == MV_TWSI_READ)) ||
@@ -733,7 +733,8 @@ static MV_STATUS twsiDataTransmit(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize
 
 		/* check the status */
 		temp = twsiStsGet(chanNum);
-		if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
+		if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || \
+			(TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
 			DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", temp));
 			return MV_RETRY;
 		} else if (temp != TWSI_M_TRAN_DATA_BYTE_ACK_REC) {
@@ -811,7 +812,8 @@ static MV_STATUS twsiDataReceive(MV_U8 chanNum, MV_U8 *pBlock, MV_U32 blockSize)
 
 		/* check the status */
 		temp = twsiStsGet(chanNum);
-		if((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || (TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
+		if ((TWSI_M_LOST_ARB_DUR_AD_OR_DATA_TRA == temp) || \
+			(TWSI_M_LOST_ARB_DUR_AD_TRA_GNL_CALL_AD_REC_ACK_TRA == temp)) {
 			DB(mvOsPrintf("TWSI: Lost Arb, status %x \n", temp));
 			return MV_RETRY;
 		} else if ((temp != TWSI_M_REC_RD_DATA_ACK_TRA) && (blockSizeRd != 1)) {
@@ -882,7 +884,7 @@ static MV_STATUS twsiTargetOffsSet(MV_U8 chanNum, MV_U32 offset, MV_BOOL moreThe
 * DESCRIPTION:
 *       The function calls the following functions:
 *       -) mvTwsiStartBitSet();
-*	if(EEPROM device)
+*	if (EEPROM device)
 *       	-) mvTwsiAddrSet(w);
 *       	-) twsiTargetOffsSet();
 *       	-) mvTwsiStartBitSet();
@@ -914,83 +916,83 @@ MV_STATUS mvTwsiRead(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, MV
 
 	MV_U32 counter = 0;
 	do	{
-		if(counter > 0) /* wait for 1 mili sec for the clear to take effect */			
+		if (counter > 0) /* wait for 1 mili sec for the clear to take effect */
 			mvOsDelay(1);
 		ret = mvTwsiStartBitSet(chanNum);
-		
+
 		if (MV_RETRY == ret)
 			continue;
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiRead: mvTwsiStartBitSet Faild\n"));
-			return MV_FAIL;
-		}
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiRead: mvTwsiStartBitSet Faild\n"));
+		return MV_FAIL;
+	}
 
-		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
+	DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
 
 	/* in case offset exsist (i.e. eeprom ) */
-		if (MV_TRUE == pTwsiSlave->validOffset) {
-			rc = mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE);
+	if (MV_TRUE == pTwsiSlave->validOffset) {
+		rc = mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE);
 			if (MV_RETRY == rc)
 				continue;
 			else if (MV_OK != rc) {
-				mvTwsiStopBitSet(chanNum);
-				DB1(mvOsPrintf("mvTwsiRead: mvTwsiAddrSet(%d,0x%x,%d) return rc=%d\n", chanNum,
-								(MV_U32)&(pTwsiSlave->slaveAddr), MV_TWSI_WRITE, rc));
-				return MV_FAIL;
-			}
-			DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
+			mvTwsiStopBitSet(chanNum);
+			DB1(mvOsPrintf("mvTwsiRead: mvTwsiAddrSet(%d,0x%x,%d) return rc=%d\n", chanNum,
+							(MV_U32)&(pTwsiSlave->slaveAddr), MV_TWSI_WRITE, rc));
+			return MV_FAIL;
+		}
+		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
 
-			ret = twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256);		
+			ret = twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256);
 			if (MV_RETRY == ret)
 				continue;
 			else if (MV_OK != ret) {
-				mvTwsiStopBitSet(chanNum);
-				DB1(mvOsPrintf("mvTwsiRead: twsiTargetOffsSet Faild\n"));
-				return MV_FAIL;
-			}
-			DB(mvOsPrintf("TWSI: mvTwsiEepromRead after twsiTargetOffsSet\n"));
+			mvTwsiStopBitSet(chanNum);
+			DB1(mvOsPrintf("mvTwsiRead: twsiTargetOffsSet Faild\n"));
+			return MV_FAIL;
+		}
+		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after twsiTargetOffsSet\n"));
 			ret = mvTwsiStartBitSet(chanNum);
 			if (MV_RETRY == ret)
-				continue;			
+				continue;
 			else if (MV_OK != ret) {
-				mvTwsiStopBitSet(chanNum);
-				DB1(mvOsPrintf("mvTwsiRead: mvTwsiStartBitSet 2 Faild\n"));
-				return MV_FAIL;
-			}
-			DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
+			mvTwsiStopBitSet(chanNum);
+			DB1(mvOsPrintf("mvTwsiRead: mvTwsiStartBitSet 2 Faild\n"));
+			return MV_FAIL;
 		}
+		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiStartBitSet\n"));
+	}
 		ret =  mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_READ);
 		if (MV_RETRY == ret)
-			continue;					
+			continue;
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiRead: mvTwsiAddrSet 2 Faild\n"));
-			return MV_FAIL;
-		}
-		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
-	
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiRead: mvTwsiAddrSet 2 Faild\n"));
+		return MV_FAIL;
+	}
+	DB(mvOsPrintf("TWSI: mvTwsiEepromRead after mvTwsiAddrSet\n"));
+
 		ret = twsiDataReceive(chanNum, pBlock, blockSize);
 		if (MV_RETRY == ret)
-			continue;					
+			continue;
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiRead: twsiDataReceive Faild\n"));
-			return MV_FAIL;
-		}
-		DB(mvOsPrintf("TWSI: mvTwsiEepromRead after twsiDataReceive\n"));
-		
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiRead: twsiDataReceive Faild\n"));
+		return MV_FAIL;
+	}
+	DB(mvOsPrintf("TWSI: mvTwsiEepromRead after twsiDataReceive\n"));
+
 		ret =  mvTwsiStopBitSet(chanNum);
 		if (MV_RETRY == ret)
-			continue;					
+			continue;
 		else if (MV_OK != ret) {
-			DB1(mvOsPrintf("mvTwsiRead: mvTwsiStopBitSet 3 Faild\n"));
-			return MV_FAIL;
-		}
+		DB1(mvOsPrintf("mvTwsiRead: mvTwsiStopBitSet 3 Faild\n"));
+		return MV_FAIL;
+	}
 		counter++;
-	} while((MV_RETRY == ret) && (counter < MAX_RETRY_CNT));
+	} while ((MV_RETRY == ret) && (counter < MAX_RETRY_CNT));
 
-	if(counter == MAX_RETRY_CNT)
+	if (counter == MAX_RETRY_CNT)
 		DB(mvOsPrintf("mvTwsiWrite: Retry Expire\n"));
 
 	twsiAckBitSet(chanNum);
@@ -1007,7 +1009,7 @@ MV_STATUS mvTwsiRead(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, MV
 *       The function calls the following functions:
 *       -) mvTwsiStartBitSet();
 *       -) mvTwsiAddrSet();
-*	-)if(EEPROM device)
+*	-)if (EEPROM device)
 *       	-) twsiTargetOffsSet();
 *       -) twsiDataTransmit();
 *       -) mvTwsiStopBitSet();
@@ -1037,7 +1039,7 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, M
 	MV_STATUS ret = MV_FAIL;
 	MV_U32 counter = 0;
 	do	{
-		if(counter > 0) /* wait for 1 mili sec for the clear to take effect */			
+		if (counter > 0) /* wait for 1 mili sec for the clear to take effect */
 			mvOsDelay(1);
 		 ret = mvTwsiStartBitSet(chanNum);
 
@@ -1045,56 +1047,56 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *pBlock, M
 			continue;
 
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiWrite: mvTwsiStartBitSet faild\n"));
-			return MV_FAIL;
-		}
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiWrite: mvTwsiStartBitSet faild\n"));
+		return MV_FAIL;
+	}
 
-		DB(mvOsPrintf("TWSI: mvTwsiEepromWrite after mvTwsiStartBitSet\n"));
-		ret = mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE);	
+	DB(mvOsPrintf("TWSI: mvTwsiEepromWrite after mvTwsiStartBitSet\n"));
+		ret = mvTwsiAddrSet(chanNum, &(pTwsiSlave->slaveAddr), MV_TWSI_WRITE);
 		if (MV_RETRY == ret)
 			continue;
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiWrite: mvTwsiAddrSet faild\n"));
-			return MV_FAIL;
-		}
-		DB(mvOsPrintf("mvTwsiWrite :mvTwsiEepromWrite after mvTwsiAddrSet\n"));
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiWrite: mvTwsiAddrSet faild\n"));
+		return MV_FAIL;
+	}
+	DB(mvOsPrintf("mvTwsiWrite :mvTwsiEepromWrite after mvTwsiAddrSet\n"));
 
-		/* in case offset exsist (i.e. eeprom ) */
-		if (MV_TRUE == pTwsiSlave->validOffset) {
+	/* in case offset exsist (i.e. eeprom ) */
+	if (MV_TRUE == pTwsiSlave->validOffset) {
 			ret = twsiTargetOffsSet(chanNum, pTwsiSlave->offset, pTwsiSlave->moreThen256);
 			if (MV_RETRY == ret)
 				continue;
 			else if (MV_OK != ret) {
-				mvTwsiStopBitSet(chanNum);
-				DB1(mvOsPrintf("mvTwsiWrite: twsiTargetOffsSet faild\n"));
-				return MV_FAIL;
-			}
-			DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after twsiTargetOffsSet\n"));
+			mvTwsiStopBitSet(chanNum);
+			DB1(mvOsPrintf("mvTwsiWrite: twsiTargetOffsSet faild\n"));
+			return MV_FAIL;
 		}
+		DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after twsiTargetOffsSet\n"));
+	}
 
 		ret = twsiDataTransmit(chanNum, pBlock, blockSize);
 		if (MV_RETRY == ret)
 			continue;
 		else if (MV_OK != ret) {
-			mvTwsiStopBitSet(chanNum);
-			DB1(mvOsPrintf("mvTwsiWrite: twsiDataTransmit faild\n"));
-			return MV_FAIL;
-		}
-		DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after twsiDataTransmit\n"));
+		mvTwsiStopBitSet(chanNum);
+		DB1(mvOsPrintf("mvTwsiWrite: twsiDataTransmit faild\n"));
+		return MV_FAIL;
+	}
+	DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after twsiDataTransmit\n"));
 		ret = mvTwsiStopBitSet(chanNum);
 		if (MV_RETRY == ret)
 			continue;
 		else if (MV_OK != ret) {
-			DB1(mvOsPrintf("mvTwsiWrite: mvTwsiStopBitSet faild in last mvTwsiWrite\n"));
-			return MV_FAIL;
-		}
-		DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after mvTwsiStopBitSet\n"));
+		DB1(mvOsPrintf("mvTwsiWrite: mvTwsiStopBitSet faild in last mvTwsiWrite\n"));
+		return MV_FAIL;
+	}
+	DB(mvOsPrintf("mvTwsiWrite: mvTwsiEepromWrite after mvTwsiStopBitSet\n"));
 		counter++;
-	} while((MV_RETRY == ret) && (counter < MAX_RETRY_CNT));
+	} while ((MV_RETRY == ret) && (counter < MAX_RETRY_CNT));
 
-	if(counter == MAX_RETRY_CNT)
+	if (counter == MAX_RETRY_CNT)
 		DB(mvOsPrintf("mvTwsiWrite: Retry Expire\n"));
 
 	return MV_OK;
diff --git a/arch/arm/plat-armada/mv_hal/uart/mvUart.h b/arch/arm/plat-armada/mv_hal/uart/mvUart.h
index a16c7a9..07cb5fb 100644
--- a/arch/arm/plat-armada/mv_hal/uart/mvUart.h
+++ b/arch/arm/plat-armada/mv_hal/uart/mvUart.h
@@ -59,8 +59,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 
 
-#ifndef __NS16550_H__
-#define __NS16550_H__
+#ifndef __INCmvUarth
+#define __INCmvUarth
 
 #ifdef __cplusplus
 extern "C" {
@@ -102,10 +102,10 @@ extern "C" {
 
 #if defined(MV_UART_OVER_PEX_WA) || defined(MV_UART_OVER_PCI_WA)
 #define mvUartBase(port)  \
-		((MV_UART_PORT *)(0xF2000000 + MV_UART_REGS_OFFSET(port)))
+                ((MV_UART_PORT *)(0xF2000000 + MV_UART_REGS_OFFSET(port)))
 #else
 #define mvUartBase(port)  \
-		((MV_UART_PORT *)(INTER_REGS_BASE + MV_UART_REGS_OFFSET(port)))
+                ((MV_UART_PORT *)(INTER_REGS_BASE + MV_UART_REGS_OFFSET(port)))
 #endif
 
 /* aliases - for registers which has the same offsets */
@@ -161,4 +161,4 @@ extern "C" {
 #ifdef __cplusplus
 }
 #endif
-#endif
+#endif /* __INCmvUarth */
diff --git a/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c b/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
index fdaa06f..b24a868 100644
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
@@ -63,6 +63,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 
 #include "mvCommon.h"
+#include "mvSysHwConfig.h"
 #include "mvOs.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvUsbRegs.h"
@@ -125,13 +126,12 @@ static MV_STATUS usbWinOverlapDetect(MV_U32 dev, MV_U32 winNum, MV_ADDR_WIN *pAd
 
 	for (winNumIndex = 0; winNumIndex < MV_USB_MAX_ADDR_DECODE_WIN; winNumIndex++) {
 		/* Do not check window itself       */
-		if (winNumIndex == winNum) {
+		if (winNumIndex == winNum)
 			continue;
-		}
 
 		/* Get window parameters    */
 		if (MV_OK != mvUsbWinRead(dev, winNumIndex, &addrDecWin)) {
-			mvOsPrintf("%s: ERR. TargetWinGet failed\n", __FUNCTION__);
+			mvOsPrintf("%s: ERR. TargetWinGet failed\n", __func__);
 			return MV_ERROR;
 		}
 
@@ -174,13 +174,13 @@ MV_STATUS mvUsbWinWrite(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
 
 	/* Parameter checking   */
 	if (winNum >= MV_USB_MAX_ADDR_DECODE_WIN) {
-		mvOsPrintf("%s: ERR. Invalid win num %d\n", __FUNCTION__, winNum);
+		mvOsPrintf("%s: ERR. Invalid win num %d\n", __func__, winNum);
 		return MV_BAD_PARAM;
 	}
 
 	/* Check if the requested window overlapps with current windows         */
 	if (MV_TRUE == usbWinOverlapDetect(dev, winNum, &pDecWin->addrWin)) {
-		mvOsPrintf("%s: ERR. Window %d overlap\n", __FUNCTION__, winNum);
+		mvOsPrintf("%s: ERR. Window %d overlap\n", __func__, winNum);
 		return MV_ERROR;
 	}
 
@@ -208,11 +208,11 @@ MV_STATUS mvUsbWinWrite(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
 	/* If window is DRAM with HW cache coherency, make sure bit2 is set */
 	sizeReg &= ~MV_USB_WIN_BURST_WR_LIMIT_MASK;
 
-	if ((MV_TARGET_IS_DRAM(pDecWin->target)) && (pDecWin->addrWinAttr.cachePolicy != NO_COHERENCY)) {
+	if ((MV_TARGET_IS_DRAM(pDecWin->target)) && (pDecWin->addrWinAttr.cachePolicy != NO_COHERENCY))
 		sizeReg |= MV_USB_WIN_BURST_WR_32BIT_LIMIT;
-	} else {
+	else
 		sizeReg |= MV_USB_WIN_BURST_WR_NO_LIMIT;
-	}
+
 #endif /* MV645xx || MV646xx */
 
 	if (pDecWin->enable == MV_TRUE)
@@ -251,7 +251,7 @@ MV_STATUS mvUsbWinRead(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
 
 	/* Parameter checking   */
 	if (winNum >= MV_USB_MAX_ADDR_DECODE_WIN) {
-		mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n", __FUNCTION__, dev, winNum);
+		mvOsPrintf("%s (dev=%d): ERR. Invalid winNum %d\n", __func__, dev, winNum);
 		return MV_NOT_SUPPORTED;
 	}
 
@@ -293,9 +293,9 @@ MV_STATUS mvUsbWinInit(MV_U32 dev, MV_UNIT_WIN_INFO *addrWinMap)
 	MV_U32 winPrioIndex = 0;
 
 	/* First disable all address decode windows */
-	for (winNum = 0; winNum < MV_USB_MAX_ADDR_DECODE_WIN; winNum++) {
+	for (winNum = 0; winNum < MV_USB_MAX_ADDR_DECODE_WIN; winNum++)
 		MV_REG_BIT_RESET(MV_USB_WIN_CTRL_REG(dev, winNum), MV_USB_WIN_ENABLE_MASK);
-	}
+
 
 	/* Go through all windows in user table until table terminator          */
 	winNum = 0;
diff --git a/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c b/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c
index 8c80f77..21dc1e9 100644
--- a/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/xor/mvXorAddrDec.c
@@ -61,6 +61,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 #include "mvCommon.h"
+#include "mvSysHwConfig.h"
 #include "mvOs.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvXorRegs.h"
-- 
1.7.5.4

