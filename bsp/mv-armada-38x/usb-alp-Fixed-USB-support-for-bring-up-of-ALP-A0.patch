From 1294368b63a123e7a1c6fc2a17d2a064c9a611ea Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Thu, 13 Mar 2014 11:01:20 +0200
Subject: [PATCH 1466/1825] usb: alp: Fixed USB support for bring up of ALP-A0

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5b3d5e2ff1df8406df93002c8c212f0bf1541f51

	- Fixed register offset of USB2 units
	- Fixed register size for USB3
	- Disabled USB2 on Zx devices
	- Cleaned ehci_marvell registration code

Change-Id: If2fc7df6c270ab0df4e60e0259370d55fbbe0c5a
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6390
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    2 +-
 arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c        |   26 +---
 arch/arm/mach-avantalp/usb.c                       |  146 +++++++++-----------
 3 files changed, 75 insertions(+), 99 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index f768a5c..ebb1765 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -131,7 +131,7 @@ extern "C" {
 #define MV_ETH_REGS_OFFSET(port)                (MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
 
 #define MV_PEX_IF_REGS_OFFSET(pexIf)            (0x40000 + (pexIf * 0x4000))
-#define MV_USB_REGS_OFFSET(dev)                 (0x50000)
+#define MV_USB_REGS_OFFSET(dev)                 (0x50000 + (0x4000 * dev))
 #define MV_USB3_REGS_OFFSET(dev)                ((mvCtrlRevGet() <= MV_88F66X0_Z3_ID) ? 0x5ff80 : 0x5b880)
 #define MV_XOR_REGS_OFFSET(unit)                (0x60800)
 #define MV_CESA_TDMA_REGS_OFFSET(chanNum)       (0x90000 + (chanNum * 0x2000))
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
index a9b388b..82cc8ef 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
@@ -87,31 +87,17 @@ MV_STATUS mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
 	MV_USB_HAL_DATA halData;
 	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
 	MV_STATUS status;
-	MV_BOOL usb3Init = 0;
-
-#ifndef CONFIG_AVANTA_LP_USE_LEGACY_USB2
-	if (mvCtrlModelGet() == MV_6660_DEV_ID)
-		usb3Init = 1;
-#endif
 
 	halData.ctrlModel = mvCtrlModelGet();
 	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
 	halData.ctrlRev = mvCtrlRevGet();
 
-	/*
-	 * For USB3 initialize only the UTMI PHY
-	 * For USB2 initialize the PHY and the controller
-	 */
-	if (usb3Init) {
-		status = mvUsbUtmiPhyInit(dev, &halData);
-	} else {
-		status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
-		if (status == MV_OK)
-			status = mvUsbWinInit(dev, addrWinMap, MV_FALSE);
-
-		if (status == MV_OK)
-			status = mvUsbHalInit(dev, isHost, &halData);
-	}
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+
+	if (status == MV_OK)
+		status = mvUsbWinInit(dev, addrWinMap, MV_FALSE);
+	if (status == MV_OK)
+		status = mvUsbHalInit(dev, isHost, &halData);
 
 	return status;
 }
diff --git a/arch/arm/mach-avantalp/usb.c b/arch/arm/mach-avantalp/usb.c
index bd0399b..be7d434 100644
--- a/arch/arm/mach-avantalp/usb.c
+++ b/arch/arm/mach-avantalp/usb.c
@@ -52,11 +52,7 @@
 u32 mvIsUsbHost = 0x03;
 
 #define MV_USB_DMA_MASK         0xffffffff
-#define MAX_USB_PORTS           2
-
-static char usb_dev_name[]  = "mv_udc";
-static char usb_host_name[] = "ehci_marvell";
-static char usb_bus_name[]  = "platform";
+#define MAX_USB2_PORTS           2
 
 static void mv_usb_release(struct device *dev)
 {
@@ -78,20 +74,27 @@ static void mv_usb_release(struct device *dev)
  */
 static int __init mv_usb2_init(void)
 {
-	int status, dev, isHost, num;
-	char*                   name_ptr;
-	struct platform_device* mv_usb_dev_ptr;
-	int irq_num[MAX_USB_PORTS] = { IRQ_GLOBAL_USB2_IP,  IRQ_GLOBAL_USB2_IP + 1};
+	int status, dev, num, id;
+	struct platform_device *ehci_dev;
+	int irq_num[MAX_USB2_PORTS] = { IRQ_GLOBAL_USB2_IP,  IRQ_GLOBAL_USB2_IP + 1};
+	int mac_id[MAX_USB2_PORTS] = { 1, 0};
+	resource_size_t ehci_regs_base;
 
 	num = mvCtrlUsbMaxGet();
-	if (num > MAX_USB_PORTS) {
-		printk("WARNING: Limited USB ports number to %d\n", MAX_USB_PORTS);
-		num = MAX_USB_PORTS;
+	if (num > MAX_USB2_PORTS) {
+		pr_info("WARNING: Limited USB ports number to %d\n", MAX_USB2_PORTS);
+		num = MAX_USB2_PORTS;
 	}
 
-	for (dev = 0; dev < num; dev++) {
+	/*
+	 * If a single USB2 is enabled it's ID is _1_ not 0
+	 * So the loop iterrator can not used as device ID
+	 */
+	for (id = 0; id < num; id++) {
+		dev = mac_id[id];
+
 		if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev)) {
-			printk("\nWarning Integrated USB %d is Powered Off\n", dev);
+			pr_info("\nWarning Integrated USB %d is Powered Off\n", dev);
 			continue;
 		}
 
@@ -99,66 +102,58 @@ static int __init mv_usb2_init(void)
 		if (MV_FALSE == mvUnitMapIsMine(USB0 + dev))
 			continue;
 
-		isHost = mvIsUsbHost & (1 << dev);
-
-		if (isHost)
-			name_ptr = usb_host_name;
-		else
-			name_ptr = usb_dev_name;
+		pr_info("Initialising USB2-%d HAL\n", dev);
+		status = mvSysUsbInit(dev, 1);
 
-		printk("registered dev#%d asa %s\n", dev, name_ptr);
-		status = mvSysUsbInit(dev, isHost);
 		if (status != MV_OK) {
 			pr_info("Error: mvSysUsbInit failed with code %d\n", status);
 			continue;
 		}
-		mv_usb_dev_ptr = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
-		if (mv_usb_dev_ptr == NULL) {
-			printk("Can't allocate platform_device structure - %d bytes\n",
+		ehci_dev = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if (ehci_dev == NULL) {
+			pr_info("Can't allocate platform_device structure - %d bytes\n",
 			       sizeof(struct platform_device) );
 			return 1;
 		}
-		memset(mv_usb_dev_ptr, 0, sizeof(struct platform_device) );
+		memset(ehci_dev, 0, sizeof(struct platform_device));
 
-		mv_usb_dev_ptr->name               = name_ptr;
-		mv_usb_dev_ptr->id                 = dev;
+		ehci_dev->name = "ehci_marvell";
+		ehci_dev->id   = id;
+		ehci_dev->num_resources  = 2;
 
-		mv_usb_dev_ptr->num_resources  = 2;
-
-		mv_usb_dev_ptr->resource = (struct resource*)kmalloc(2 * sizeof(struct resource), GFP_KERNEL);
-		if (mv_usb_dev_ptr->resource == NULL) {
+		/* Set the EHCI registers and interrupts resources */
+		ehci_dev->resource = kmalloc(2 * sizeof(struct resource), GFP_KERNEL);
+		if (ehci_dev->resource == NULL) {
 			printk("Can't allocate 2 resource structure - %d bytes\n",
 			       2 * sizeof(struct resource) );
-			kfree(mv_usb_dev_ptr);
+			kfree(ehci_dev);
 			return 1;
 		}
-		memset(mv_usb_dev_ptr->resource, 0, 2 * sizeof(struct resource));
-
-		mv_usb_dev_ptr->resource[0].start =
-			( INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
-		mv_usb_dev_ptr->resource[0].end   =
-			((INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
-		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
+		memset(ehci_dev->resource, 0, 2 * sizeof(struct resource));
 
-		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
-		mv_usb_dev_ptr->resource[1].flags = IORESOURCE_IRQ;
+		ehci_regs_base = INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev);
+		ehci_dev->resource[0].start = ehci_regs_base;
+		ehci_dev->resource[0].end   = ehci_regs_base + _4K;
+		ehci_dev->resource[0].flags = IORESOURCE_DMA;
 
-		mv_usb_dev_ptr->dev.dma_mask           = kmalloc(sizeof(u64), GFP_KERNEL);
-		*mv_usb_dev_ptr->dev.dma_mask          = MV_USB_DMA_MASK;
+		ehci_dev->resource[1].start = irq_num[dev];
+		ehci_dev->resource[1].flags = IORESOURCE_IRQ;
 
-		mv_usb_dev_ptr->dev.coherent_dma_mask  = ~0;
-		mv_usb_dev_ptr->dev.release            = mv_usb_release;
-		dev_set_name(&mv_usb_dev_ptr->dev, "%s", usb_bus_name);
+		ehci_dev->dev.dma_mask	= kmalloc(sizeof(u64), GFP_KERNEL);
+		*ehci_dev->dev.dma_mask	= MV_USB_DMA_MASK;
+		ehci_dev->dev.coherent_dma_mask  = ~0;
 
-		printk("Marvell USB %s controller #%d: %p\n",
-		       isHost ? "EHCI Host" : "Gadget", dev, mv_usb_dev_ptr);
+		ehci_dev->dev.release = mv_usb_release;
+		dev_set_name(&ehci_dev->dev, "%s", "platform");
 
-		status = platform_device_register(mv_usb_dev_ptr);
+		/* Register the device */
+		status = platform_device_register(ehci_dev);
 		if (status) {
-			printk("Can't register Marvell USB EHCI controller #%d, status=%d\n",
+			pr_info("Failed registering Marvell2 USB EHCI controller #%d, status=%d\n",
 			       dev, status);
 			return status;
 		}
+		pr_info("Registered Marvell USB2 EHCI host controller %d\n", dev);
 	}
 	return 0;
 }
@@ -167,10 +162,10 @@ static int __init mv_usb2_init(void)
 #define USB3_WIN_CTRL(w)	(0x0 + ((w) * 8))
 #define USB3_WIN_BASE(w)	(0x4 + ((w) * 8))
 #define USB3_MAX_WINDOWS	4
-#define USB3_XHCI_REGS_SIZE	_64K
+#define USB3_XHCI_REGS_SIZE	_16K
 
 static u64 mv_usb3_dmamask = 0xffffffffUL;
-static struct resource mv_usb3_resources[] = {
+static struct resource mv_usb3_resources[2] = {
 	[0] = {
 		.start	= USB3_REGS_PHYS_BASE,
 		.end	= USB3_REGS_PHYS_BASE + USB3_XHCI_REGS_SIZE - 1,
@@ -184,7 +179,6 @@ static struct resource mv_usb3_resources[] = {
 	},
 };
 
-
 static void __init mv_usb3_conf_mbus_windows(void __iomem *base,
 			const struct mbus_dram_target_info *dram)
 {
@@ -240,8 +234,9 @@ void __init mv_usb3_init(struct mbus_dram_target_info *dram)
 	/* Setup XHCI resources */
 	if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID) {
 		mv_usb3_resources[0].start = USB3_REGS_PHYS_BASE_Z;
-		mv_usb3_resources[0].end = USB3_REGS_PHYS_BASE_Z + USB3_XHCI_REGS_SIZE - 1;
+		mv_usb3_resources[0].end = USB3_REGS_PHYS_BASE_Z + _64K - 1;
 	}
+
 	ret = platform_device_add_resources(xhci, mv_usb3_resources,
 				ARRAY_SIZE(mv_usb3_resources));
 	if (ret) {
@@ -299,43 +294,38 @@ err0:
 
 void __init mv_usb_init(struct mbus_dram_target_info *dram)
 {
-	/* Select the new USB3 IP */
-
 	int reg;
-	int use_usb3_ip = 0;
-	MV_STATUS status;
 
 	if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID) {
+
 		/* Enable USB3 only for 6660 devices */
-#ifndef CONFIG_AVANTA_LP_USE_LEGACY_USB2
 		if (mvCtrlModelGet() == MV_6660_DEV_ID) {
-			use_usb3_ip = 1;
-#if 0
-			/* Initialize the USB2 PHY needed for USB3 functionality */
-			status = mvSysUsbInit(0, 1);
-			if (status != MV_OK) {
-				pr_info("Error: mvSysUsbInit failed with code %d\n", status);
-				return;
-			}
-#endif
-		}
-#endif
 
-		/* Select USB3 IP (which supports USB2) or legacy USB2 IP*/
-		reg = readl(INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
-		reg = (reg & (~0x1)) | use_usb3_ip;
-		writel(reg, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+			/* Select USB3 IP in IP mux */
+			reg = readl(INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+			reg = (reg & (~0x1)) | 1;
+			writel(reg, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
 
-		if (use_usb3_ip)
 			mv_usb3_init(dram);
-		else
-			mv_usb2_init();
+		}
 	} else {
 		if (mvCtrlUsb3MaxGet() > 0)
 			mv_usb3_init(dram);
 
 		if (mvCtrlUsbMaxGet() > 0)
 			mv_usb2_init();
+
+		/*
+		 * If 2 USB2 MACs are enabled (MAC0 & MAC1), UTMI PHY-0 should be
+		 * connected to MAC0. If 1 USB2 is enabled (MAC1) UTMI PHY-0
+		 * should be connected to USB3 MAC.
+		 */
+		reg = readl(INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
+		reg &= (~1);
+		if (mvCtrlUsbMaxGet() < 2)
+			reg |= 1; /* Connect UTMI to USB3 */
+		pr_info("-----> 0x18400 = 0x%x\n", reg);
+		writel(reg, INTER_REGS_VIRT_BASE + USB_CLUSTER_CONTROL);
 	}
 }
 
-- 
1.7.5.4

