From 47377b3f0eae21176063c157680cf038090aaa84 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Tue, 1 Jul 2014 17:29:33 +0800
Subject: [PATCH 1758/1825] fix: neta: split sysfs gbe directory

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ff4667f756840a8e0351f005687bc36704f1ffda

	split sysfs gbe directory to "gbe", "gbe/tx", "gbe/rx",
	"gbe/tx_sched", "gbe/qos" and "gbe/rss" to show	help for all
	commands
	SYSTEMSW-499: <Kernel panic happens on A380 zImage-linux-3.10.32
	-2014_T1.1p1-mvebu_lsp_smp>

Signed-off-by: Ken Ma <make@marvell.com>

Change-Id: I53e522ebb28e99a5f37503f9c561f33b99b1f85c
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8846
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-armada/mv_drivers_lsp/mv_neta/Makefile    |    4 +-
 .../mv_neta/net_dev/mv_eth_qos_sysfs.c             |  294 +++++++++++++++
 .../mv_neta/net_dev/mv_eth_rss_sysfs.c             |  163 ++++++++
 .../mv_neta/net_dev/mv_eth_rx_sysfs.c              |  156 ++++++++
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c  |  393 ++++----------------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.h  |   19 +-
 .../mv_neta/net_dev/mv_eth_tx_sched_sysfs.c        |  185 +++++++++
 .../mv_neta/net_dev/mv_eth_tx_sysfs.c              |  281 ++++++++++++++
 8 files changed, 1164 insertions(+), 331 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_qos_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rss_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rx_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sched_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sysfs.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
index 532123c..eef4370 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
@@ -45,7 +45,9 @@ ifeq ($(CONFIG_MV_ETH_HWF),y)
 mv_neta-objs += $(NETA_GBE_DIR)/mvHwf.o hwf/hwf_sysfs.o
 endif
 
-mv_neta-objs += net_dev/mv_netdev.o net_dev/mv_ethernet.o net_dev/mv_eth_sysfs.o net_dev/mv_eth_tool.o
+mv_neta-objs += net_dev/mv_netdev.o net_dev/mv_ethernet.o net_dev/mv_eth_tool.o
+mv_neta-objs += net_dev/mv_eth_sysfs.o net_dev/mv_eth_rx_sysfs.o net_dev/mv_eth_tx_sysfs.o
+mv_neta-objs += net_dev/mv_eth_tx_sched_sysfs.o net_dev/mv_eth_qos_sysfs.o net_dev/mv_eth_rss_sysfs.o
 
 ifeq ($(CONFIG_MV_ETH_L2FW),y)
 mv_neta-objs += l2fw/l2fw_sysfs.o l2fw/mv_eth_l2fw.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_qos_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_qos_sysfs.c
new file mode 100644
index 0000000..01f2f57
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_qos_sysfs.c
@@ -0,0 +1,294 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "mv_netdev.h"
+
+static ssize_t mv_eth_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "p, txq, rxq, cpu                      - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "v, tos                                - are hex numbers\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	o += scnprintf(b+o, s-o, "echo p             > tos           - show RX and TX TOS map for port <p>\n");
+	o += scnprintf(b+o, s-o, "echo p             > vprio         - show VLAN priority map for port <p>\n");
+	o += scnprintf(b+o, s-o, "echo p rxq tos     > rxq_tos       - set <rxq> for incoming IP packets with <tos>\n");
+	o += scnprintf(b+o, s-o, "echo p rxq t       > rxq_type      - set RXQ for different packet types. t=0-bpdu, 1-arp, 2-tcp, 3-udp\n");
+	o += scnprintf(b+o, s-o, "echo p rxq prio    > rxq_vlan      - set <rxq> for incoming VLAN packets with <prio>\n");
+	o += scnprintf(b+o, s-o, "echo p txq cpu tos > txq_tos       - set <txq> for outgoing IP packets with <tos> handeled by <cpu>\n");
+
+	return o;
+}
+
+
+static ssize_t mv_eth_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_eth_help(buf);
+
+	return off;
+}
+
+#ifdef CONFIG_MV_ETH_PNC
+int run_rxq_type(int port, int q, int t)
+{
+	void *port_hndl = mvNetaPortHndlGet(port);
+
+	if (port_hndl == NULL)
+		return 1;
+
+	if (!mv_eth_pnc_ctrl_en) {
+		pr_err("%s: PNC control is not supported\n", __func__);
+		return 1;
+	}
+
+	switch (t) {
+	case 1:
+		pnc_etype_arp(q);
+		break;
+	case 2:
+		pnc_ip4_tcp(q);
+		break;
+	case 3:
+		pnc_ip4_udp(q);
+		break;
+	default:
+		pr_err("unsupported packet type: value=%d\n", t);
+		return 1;
+	}
+	return 0;
+}
+#else
+int run_rxq_type(int port, int q, int t)
+{
+	void *port_hndl = mvNetaPortHndlGet(port);
+
+	if (port_hndl == NULL)
+		return 1;
+
+	switch (t) {
+	case 0:
+		mvNetaBpduRxq(port, q);
+		break;
+	case 1:
+		mvNetaArpRxq(port, q);
+		break;
+	case 2:
+		mvNetaTcpRxq(port, q);
+		break;
+	case 3:
+		mvNetaUdpRxq(port, q);
+		break;
+	default:
+		pr_err("unknown packet type: value=%d\n", t);
+		return 1;
+	}
+	return 0;
+}
+#endif /* CONFIG_MV_ETH_PNC */
+
+static ssize_t mv_eth_port_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = p = 0;
+	sscanf(buf, "%d", &p);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "tos")) {
+		mv_eth_tos_map_show(p);
+	} else if (!strcmp(name, "vprio")) {
+		mv_eth_vlan_prio_show(p);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_3_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char	*name = attr->attr.name;
+	int		err;
+	unsigned int	p, i, v;
+	unsigned long	flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %d", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "rxq_type"))
+		err = run_rxq_type(p, i, v);
+	else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_3_hex_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, i, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %x", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "rxq_tos")) {
+		err = mv_eth_rxq_tos_map_set(p, i, v);
+	} else if (!strcmp(name, "rxq_vlan")) {
+		err = mv_eth_rxq_vlan_prio_set(p, i, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_4_hex_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, cpu, txq, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = cpu = txq = v = 0;
+	sscanf(buf, "%d %d %d %x", &p, &txq, &cpu, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txq_tos")) {
+		err = mv_eth_txq_tos_map_set(p, txq, cpu, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(tos,         S_IWUSR, mv_eth_show, mv_eth_port_store);
+static DEVICE_ATTR(vprio,       S_IWUSR, mv_eth_show, mv_eth_port_store);
+static DEVICE_ATTR(rxq_tos,       S_IWUSR, NULL, mv_eth_3_hex_store);
+static DEVICE_ATTR(rxq_type,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rxq_vlan,      S_IWUSR, NULL, mv_eth_3_hex_store);
+static DEVICE_ATTR(txq_tos,     S_IWUSR, mv_eth_show, mv_eth_4_hex_store);
+
+
+static struct attribute *mv_eth_qos_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_tos.attr,
+	&dev_attr_vprio.attr,
+	&dev_attr_rxq_tos.attr,
+	&dev_attr_rxq_type.attr,
+	&dev_attr_rxq_vlan.attr,
+	&dev_attr_txq_tos.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_qos_group = {
+	.name = "qos",
+	.attrs = mv_eth_qos_attrs,
+};
+
+int mv_neta_qos_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_qos_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_qos_group.name, err);
+
+	return err;
+}
+
+int mv_neta_qos_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_qos_group);
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rss_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rss_sysfs.c
new file mode 100644
index 0000000..0a6f921
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rss_sysfs.c
@@ -0,0 +1,163 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "mv_netdev.h"
+
+static ssize_t mv_eth_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "p gr                               - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "mask                               - are hex numbers\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	o += scnprintf(b+o, s-o, "echo p             > napi          - show port NAPI groups: CPUs and RXQs\n");
+	o += scnprintf(b+o, s-o, "echo p gr mask     > cpu_group     - set <cpus mask>  for <port/napi group>.\n");
+	o += scnprintf(b+o, s-o, "echo p gr mask     > rxq_group     - set  <rxqs mask> for <port/napi group>.\n");
+
+	return o;
+}
+
+static ssize_t mv_eth_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_eth_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_eth_port_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = p = 0;
+	sscanf(buf, "%d", &p);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "napi")) {
+		mv_eth_napi_group_show(p);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_3_hex_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, i, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %x", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "cpu_group")) {
+		err = mv_eth_napi_set_cpu_affinity(p, i, v);
+	} else if (!strcmp(name, "rxq_group")) {
+		err = mv_eth_napi_set_rxq_affinity(p, i, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(napi,        S_IWUSR, mv_eth_show, mv_eth_port_store);
+static DEVICE_ATTR(cpu_group,   S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
+static DEVICE_ATTR(rxq_group,   S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
+
+
+static struct attribute *mv_eth_rss_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_napi.attr,
+	&dev_attr_cpu_group.attr,
+	&dev_attr_rxq_group.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_rss_group = {
+	.name = "rss",
+	.attrs = mv_eth_rss_attrs,
+};
+
+int mv_neta_rss_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_rss_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_rss_group.name, err);
+
+	return err;
+}
+
+int mv_neta_rss_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_rss_group);
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rx_sysfs.c
new file mode 100644
index 0000000..f1966d2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_rx_sysfs.c
@@ -0,0 +1,156 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "mv_netdev.h"
+
+static ssize_t mv_eth_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "p, rxq, d                             - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	o += scnprintf(b+o, s-o, "echo p rxq         > rxq_regs      - show RXQ registers for <p/rxq>\n");
+	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq           - show RXQ descriptors ring for <p/rxq>. d=0-brief, d=1-full\n");
+	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_size      - set number of descriptors <d> for <port/rxq>.\n");
+	o += scnprintf(b+o, s-o, "echo p d           > rx_weight     - set weight for the poll function; <d> - new weight, max val: 255\n");
+	o += scnprintf(b+o, s-o, "echo p             > rx_reset      - reset RX part of the port <p>\n");
+	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_pkts_coal - set RXQ interrupt coalesing. <d> - number of received packets\n");
+	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_time_coal - set RXQ interrupt coalesing. <d> - time in microseconds\n");
+
+	return o;
+}
+
+static ssize_t mv_eth_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_eth_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_eth_3_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char	*name = attr->attr.name;
+	int		err;
+	unsigned int	p, i, v;
+	unsigned long	flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %d", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "rxq_size"))
+		err = mv_eth_ctrl_rxq_size_set(p, i, v);
+	else if (!strcmp(name, "rxq_pkts_coal"))
+		err = mv_eth_rx_pkts_coal_set(p, i, v);
+	else if (!strcmp(name, "rxq_time_coal"))
+		err = mv_eth_rx_time_coal_set(p, i, v);
+	else if (!strcmp(name, "rxq"))
+		mvNetaRxqShow(p, i, v);
+	else if (!strcmp(name, "rxq_regs"))
+		mvNetaRxqRegs(p, i);
+	else if (!strcmp(name, "rx_reset"))
+		err = mv_eth_rx_reset(p);
+	else if (!strcmp(name, "rx_weight"))
+		err = mv_eth_ctrl_set_poll_rx_weight(p, i);
+	else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,          S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(rxq_size,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rxq_pkts_coal, S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rxq_time_coal, S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rxq,           S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rxq_regs,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rx_reset,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(rx_weight,     S_IWUSR, NULL, mv_eth_3_store);
+
+
+static struct attribute *mv_eth_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_rxq_size.attr,
+	&dev_attr_rxq_pkts_coal.attr,
+	&dev_attr_rxq_time_coal.attr,
+	&dev_attr_rxq.attr,
+	&dev_attr_rxq_regs.attr,
+	&dev_attr_rx_reset.attr,
+	&dev_attr_rx_weight.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_rx_group = {
+	.name = "rx",
+	.attrs = mv_eth_attrs,
+};
+
+int mv_neta_rx_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_rx_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_rx_group.name, err);
+
+	return err;
+}
+
+int mv_neta_rx_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_rx_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
index 67587ad..828dcab 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
@@ -42,129 +42,38 @@ static ssize_t mv_eth_help(char *b)
 	int o = 0; /* buffer offset */
 	int s = PAGE_SIZE; /* buffer size */
 
-	o += scnprintf(b+o, s-o, "p, txp, txq, rxq, cpu, prio, gr, d, t, l, s - are dec numbers\n");
-	o += scnprintf(b+o, s-o, "v, tos, mask                                - are hex numbers\n");
+	o += scnprintf(b+o, s-o, "p, txp, d, l, s                    - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "v                                  - are hex numbers\n");
 	o += scnprintf(b+o, s-o, "\n");
 
 	o += scnprintf(b+o, s-o, "cat                ports           - show all ports info\n");
+	o += scnprintf(b+o, s-o, "cd                 rx              - move to RX sysfs directory\n");
+	o += scnprintf(b+o, s-o, "cd                 tx              - move to TX sysfs directory\n");
+	o += scnprintf(b+o, s-o, "cd                 tx_sched        - move to TX Scheduler sysfs directory\n");
+	o += scnprintf(b+o, s-o, "cd                 qos             - move to QoS sysfs directory\n");
+	o += scnprintf(b+o, s-o, "cd                 rss             - move to RSS sysfs directory\n");
 	o += scnprintf(b+o, s-o, "echo p d           > stack         - show pools stack for port <p>. d=0-brief, d=1-full\n");
 	o += scnprintf(b+o, s-o, "echo p             > port          - show a port info\n");
 	o += scnprintf(b+o, s-o, "echo [if_name]     > netdev        - show <if_name> net_device status\n");
 	o += scnprintf(b+o, s-o, "echo p             > stats         - show a port statistics\n");
 	o += scnprintf(b+o, s-o, "echo p txp         > cntrs         - show a port counters\n");
-	o += scnprintf(b+o, s-o, "echo p             > tos           - show RX and TX TOS map for port <p>\n");
 	o += scnprintf(b+o, s-o, "echo p             > mac           - show MAC info for port <p>\n");
-	o += scnprintf(b+o, s-o, "echo p             > vprio         - show VLAN priority map for port <p>\n");
-	o += scnprintf(b+o, s-o, "echo p             > napi          - show port NAPI groups: CPUs and RXQs\n");
 	o += scnprintf(b+o, s-o, "echo p             > p_regs        - show port registers for <p>\n");
 #ifdef MV_ETH_GMAC_NEW
 	o += scnprintf(b+o, s-o, "echo p             > gmac_regs     - show gmac registers for <p>\n");
 #endif /* MV_ETH_GMAC_NEW */
-	o += scnprintf(b+o, s-o, "echo p rxq         > rxq_regs      - show RXQ registers for <p/rxq>\n");
-	o += scnprintf(b+o, s-o, "echo p txp         > wrr_regs      - show WRR registers for <p/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp         > txp_regs      - show TX registers for <p/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq     > txq_regs      - show TXQ registers for <p/txp/txq>\n");
-	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq           - show RXQ descriptors ring for <p/rxq>. d=0-brief, d=1-full\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq           - show TXQ descriptors ring for <p/txp/txq>. d=0-brief, d=1-full\n");
 #ifdef CONFIG_MV_ETH_PNC
 	o += scnprintf(b+o, s-o, "echo {0|1}         > pnc           - enable / disable PNC access\n");
 #endif /* CONFIG_MV_ETH_PNC */
 	o += scnprintf(b+o, s-o, "echo {0|1}         > skb           - enable / disable SKB recycle\n");
-	o += scnprintf(b+o, s-o, "echo p {0|1}       > mh_en         - enable Marvell Header\n");
-	o += scnprintf(b+o, s-o, "echo p {0|1}       > tx_nopad      - disable zero padding\n");
-	o += scnprintf(b+o, s-o, "echo p v           > mh_2B         - set 2 bytes of Marvell Header\n");
-	o += scnprintf(b+o, s-o, "echo p v           > tx_cmd        - set 4 bytes of TX descriptor offset 0xc\n");
 	o += scnprintf(b+o, s-o, "echo p v           > debug         - bit0:rx, bit1:tx, bit2:isr, bit3:poll, bit4:dump\n");
 	o += scnprintf(b+o, s-o, "echo p l s         > buf_num       - set number of long <l> and short <s> buffers allocated for port <p>\n");
-	o += scnprintf(b+o, s-o, "echo p rxq tos     > rxq_tos       - set <rxq> for incoming IP packets with <tos>\n");
-	o += scnprintf(b+o, s-o, "echo p gr mask     > cpu_group     - set <cpus mask>  for <port/napi group>.\n");
-	o += scnprintf(b+o, s-o, "echo p gr mask     > rxq_group     - set  <rxqs mask> for <port/napi group>.\n");
-	o += scnprintf(b+o, s-o, "echo p rxq prio    > rxq_vlan      - set <rxq> for incoming VLAN packets with <prio>\n");
-	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_size      - set number of descriptors <d> for <port/rxq>.\n");
-	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_pkts_coal - set RXQ interrupt coalesing. <d> - number of received packets\n");
-	o += scnprintf(b+o, s-o, "echo p rxq d       > rxq_time_coal - set RXQ interrupt coalesing. <d> - time in microseconds\n");
-	o += scnprintf(b+o, s-o, "echo p rxq t       > rxq_type      - set RXQ for different packet types. t=0-bpdu, 1-arp, 2-tcp, 3-udp\n");
-	o += scnprintf(b+o, s-o, "echo p             > rx_reset      - reset RX part of the port <p>\n");
-	o += scnprintf(b+o, s-o, "echo p txp         > txp_reset     - reset TX part of the port <p/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq     > txq_clean     - clean TXQ <p/txp/txq> - free descriptors and buffers\n");
-	o += scnprintf(b+o, s-o, "echo p txq cpu tos > txq_tos       - set <txq> for outgoing IP packets with <tos> handeled by <cpu>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq cpu > txq_def       - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
-	o += scnprintf(b+o, s-o, "echo p txp {0|1}   > ejp           - enable/disable EJP mode for <port/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp d       > txp_rate      - set outgoing rate <d> in [kbps] for <port/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp d       > txp_burst     - set maximum burst <d> in [Bytes] for <port/txp>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_rate      - set outgoing rate <d> in [kbps] for <port/txp/txq>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_burst     - set maximum burst <d> in [Bytes] for <port/txp/txq>\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_wrr       - set outgoing WRR weight for <port/txp/txq>. <d=0> - fixed\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_size      - set number of descriptors <d> for <port/txp/txq>.\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_coal      - set TXP/TXQ interrupt coalesing. <d> - number of sent packets\n");
-	o += scnprintf(b+o, s-o, "echo d             > tx_done       - set threshold <d> to start tx_done operations\n");
-	o += scnprintf(b+o, s-o, "echo p d           > rx_weight     - set weight for the poll function; <d> - new weight, max val: 255\n");
-	o += scnprintf(b+o, s-o, "echo p cpu mask    > txq_mask      - set cpu <cpu> accessible txq bitmap <mask>.\n");
-	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_shared    - set/reset shared bit for <port/txp/txq>. <d> - 1/0 for set/reset.\n");
 #ifdef CONFIG_MV_ETH_PNC_WOL
 	o += scnprintf(b+o, s-o, "echo p wol         > wol_mode      - set port <p> pm mode. 0 wol, 1 suspend.\n");
 #endif
 	return o;
 }
 
-#ifdef CONFIG_MV_ETH_PNC
-int run_rxq_type(int port, int q, int t)
-{
-	void *port_hndl = mvNetaPortHndlGet(port);
-
-	if (port_hndl == NULL)
-		return 1;
-
-	if (!mv_eth_pnc_ctrl_en) {
-		printk(KERN_ERR "%s: PNC control is not supported\n", __func__);
-		return 1;
-	}
-
-	switch (t) {
-	case 1:
-		pnc_etype_arp(q);
-		break;
-	case 2:
-		pnc_ip4_tcp(q);
-		break;
-	case 3:
-		pnc_ip4_udp(q);
-		break;
-	default:
-		printk(KERN_ERR "unsupported packet type: value=%d\n", t);
-		return 1;
-	}
-	return 0;
-}
-#else
-int run_rxq_type(int port, int q, int t)
-{
-	void *port_hndl = mvNetaPortHndlGet(port);
-
-	if (port_hndl == NULL)
-		return 1;
-
-	switch (t) {
-	case 0:
-		mvNetaBpduRxq(port, q);
-		break;
-	case 1:
-		mvNetaArpRxq(port, q);
-		break;
-	case 2:
-		mvNetaTcpRxq(port, q);
-		break;
-	case 3:
-		mvNetaUdpRxq(port, q);
-		break;
-	default:
-		printk(KERN_ERR "unknown packet type: value=%d\n", t);
-		return 1;
-	}
-	return 0;
-}
-#endif /* CONFIG_MV_ETH_PNC */
-
 static ssize_t mv_eth_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -201,7 +110,7 @@ static ssize_t mv_eth_netdev_store(struct device *dev,
 	sscanf(buf, "%s", dev_name);
 	netdev = dev_get_by_name(&init_net, dev_name);
 	if (netdev == NULL) {
-		printk(KERN_ERR "%s: network interface <%s> doesn't exist\n",
+		pr_err("%s: network interface <%s> doesn't exist\n",
 			__func__, dev_name);
 		err = 1;
 	} else {
@@ -209,12 +118,12 @@ static ssize_t mv_eth_netdev_store(struct device *dev,
 			mv_eth_netdev_print(netdev);
 		else {
 			err = 1;
-			printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+			pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
 		}
 		dev_put(netdev);
 	}
 	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
+		pr_err("%s: error %d\n", __func__, err);
 
 	return err ? -EINVAL : len;
 }
@@ -244,14 +153,6 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		err = mv_eth_ctrl_flag(p, MV_ETH_F_DBG_DUMP, v & 0x10);
 	} else if (!strcmp(name, "skb")) {
 		mv_eth_ctrl_recycle(p);
-	} else if (!strcmp(name, "tx_cmd")) {
-		err = mv_eth_ctrl_tx_cmd(p, v);
-	} else if (!strcmp(name, "mh_2B")) {
-		err = mv_eth_ctrl_tx_mh(p, MV_16BIT_BE((u16)v));
-	} else if (!strcmp(name, "mh_en")) {
-		err = mv_eth_ctrl_flag(p, MV_ETH_F_MH, v);
-	} else if (!strcmp(name, "tx_nopad")) {
-		err = mv_eth_ctrl_flag(p, MV_ETH_F_NO_PAD, v);
 	} else if (!strcmp(name, "port")) {
 		mv_eth_status_print();
 		mvNetaPortStatus(p);
@@ -260,16 +161,12 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		mv_eth_stack_print(p, v);
 	} else if (!strcmp(name, "stats")) {
 		mv_eth_port_stats_print(p);
-	} else if (!strcmp(name, "tos")) {
-		mv_eth_tos_map_show(p);
 	} else if (!strcmp(name, "mac")) {
 		mv_eth_mac_show(p);
-	} else if (!strcmp(name, "vprio")) {
-		mv_eth_vlan_prio_show(p);
 	} else if (!strcmp(name, "p_regs")) {
-		printk(KERN_INFO "\n[NetA Port: port=%d]\n", p);
+		pr_info("\n[NetA Port: port=%d]\n", p);
 		mvEthRegs(p);
-		printk(KERN_INFO "\n");
+		pr_info("\n");
 		mvEthPortRegs(p);
 		mvNetaPortRegs(p);
 #ifdef MV_ETH_GMAC_NEW
@@ -284,53 +181,15 @@ static ssize_t mv_eth_port_store(struct device *dev,
 	} else if (!strcmp(name, "wol_mode")) {
 		err = mv_eth_wol_mode_set(p, v);
 #endif /* CONFIG_MV_ETH_PNC_WOL */
-	} else if (!strcmp(name, "napi")) {
-		mv_eth_napi_group_show(p);
 	} else {
 		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
 	}
 
 	local_irq_restore(flags);
 
 	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
-
-	return err ? -EINVAL : len;
-}
-
-static ssize_t mv_eth_3_hex_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char      *name = attr->attr.name;
-	int             err;
-	unsigned int    p, i, v;
-	unsigned long   flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	err = p = i = v = 0;
-	sscanf(buf, "%d %d %x", &p, &i, &v);
-
-	local_irq_save(flags);
-
-	if (!strcmp(name, "rxq_tos")) {
-		err = mv_eth_rxq_tos_map_set(p, i, v);
-	} else if (!strcmp(name, "rxq_vlan")) {
-		err = mv_eth_rxq_vlan_prio_set(p, i, v);
-	} else if (!strcmp(name, "cpu_group")) {
-		err = mv_eth_napi_set_cpu_affinity(p, i, v);
-	} else if (!strcmp(name, "rxq_group")) {
-		err = mv_eth_napi_set_rxq_affinity(p, i, v);
-	} else if (!strcmp(name, "txq_mask")) {
-		err = mv_eth_cpu_txq_mask_set(p, i, v);
-	} else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-
-	local_irq_restore(flags);
+		pr_err("%s: error %d\n", __func__, err);
 
 	return err ? -EINVAL : len;
 }
@@ -351,267 +210,145 @@ static ssize_t mv_eth_3_store(struct device *dev,
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "txp_rate")) {
-		err = mvNetaTxpRateSet(p, i, v);
-	} else if (!strcmp(name, "txp_burst")) {
-		err = mvNetaTxpBurstSet(p, i, v);
-	} else if (!strcmp(name, "ejp")) {
-		err = mvNetaTxpEjpSet(p, i, v);
-	} else if (!strcmp(name, "rxq_size")) {
-		err = mv_eth_ctrl_rxq_size_set(p, i, v);
-	} else if (!strcmp(name, "rxq_pkts_coal")) {
-		err = mv_eth_rx_pkts_coal_set(p, i, v);
-	} else if (!strcmp(name, "rxq_time_coal")) {
-		err = mv_eth_rx_time_coal_set(p, i, v);
-	} else if (!strcmp(name, "rxq")) {
-		mvNetaRxqShow(p, i, v);
-	} else if (!strcmp(name, "rxq_regs")) {
-		mvNetaRxqRegs(p, i);
-	} else if (!strcmp(name, "buf_num")) {
+	if (!strcmp(name, "buf_num")) {
 		err = mv_eth_ctrl_port_buf_num_set(p, i, v);
-	} else if (!strcmp(name, "rx_reset")) {
-		err = mv_eth_rx_reset(p);
-	} else if (!strcmp(name, "txp_reset")) {
-		err = mv_eth_txp_reset(p, i);
-	} else if (!strcmp(name, "rx_weight")) {
-		err = mv_eth_ctrl_set_poll_rx_weight(p, i);
-	} else if (!strcmp(name, "tx_done")) {
-		mv_eth_ctrl_txdone(p);
-	} else if (!strcmp(name, "rxq_type")) {
-		err = run_rxq_type(p, i, v);
 	} else {
 		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
 	}
 
 	local_irq_restore(flags);
 
 	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
+		pr_err("%s: error %d\n", __func__, err);
 
 	return err ? -EINVAL : len;
 }
 
-static ssize_t mv_eth_4_hex_store(struct device *dev,
-				struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char      *name = attr->attr.name;
-	int             err;
-	unsigned int    p, cpu, txq, v;
-	unsigned long   flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	err = p = cpu = txq = v = 0;
-	sscanf(buf, "%d %d %d %x", &p, &txq, &cpu, &v);
-
-	local_irq_save(flags);
-
-	if (!strcmp(name, "txq_tos")) {
-		err = mv_eth_txq_tos_map_set(p, txq, cpu, v);
-	} else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-	local_irq_restore(flags);
-
-	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
-
-	return err ? -EINVAL : len;
-}
-
-static ssize_t mv_eth_4_store(struct device *dev,
+static ssize_t mv_eth_2_store(struct device *dev,
 				   struct device_attribute *attr, const char *buf, size_t len)
 {
 	const char      *name = attr->attr.name;
 	int             err;
-	unsigned int    p, txp, txq, v;
+	unsigned int    p, txp;
 	unsigned long   flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	err = p = txp = txq = v = 0;
-	sscanf(buf, "%d %d %d %d", &p, &txp, &txq, &v);
+	err = p = txp = 0;
+	sscanf(buf, "%d %d", &p, &txp);
 
 	local_irq_save(flags);
 
-	if (!strcmp(name, "txq_def")) {
-		err = mv_eth_ctrl_txq_cpu_def(p, txp, txq, v);
-	} else if (!strcmp(name, "cntrs")) {
+	if (!strcmp(name, "cntrs")) {
 		mvEthPortCounters(p, txp);
 		mvEthPortRmonCounters(p, txp);
-	} else if (!strcmp(name, "wrr_regs")) {
-		mvEthTxpWrrRegs(p, txp);
-	} else if (!strcmp(name, "txp_regs")) {
-		mvNetaTxpRegs(p, txp);
-	} else if (!strcmp(name, "txq_rate")) {
-		err = mvNetaTxqRateSet(p, txp, txq, v);
-	} else if (!strcmp(name, "txq_burst")) {
-		err = mvNetaTxqBurstSet(p, txp, txq, v);
-	} else if (!strcmp(name, "txq_wrr")) {
-		if (v == 0)
-			err = mvNetaTxqFixPrioSet(p, txp, txq);
-		else
-			err = mvNetaTxqWrrPrioSet(p, txp, txq, v);
-	} else if (!strcmp(name, "txq_size")) {
-		err = mv_eth_ctrl_txq_size_set(p, txp, txq, v);
-	} else if (!strcmp(name, "txq_coal")) {
-		mv_eth_tx_done_pkts_coal_set(p, txp, txq, v);
-	} else if (!strcmp(name, "txq")) {
-		mvNetaTxqShow(p, txp, txq, v);
-	} else if (!strcmp(name, "txq_regs")) {
-		mvNetaTxqRegs(p, txp, txq);
-	} else if (!strcmp(name, "txq_clean")) {
-		err = mv_eth_txq_clean(p, txp, txq);
-	} else if (!strcmp(name, "txq_shared")) {
-		err = mv_eth_shared_set(p, txp, txq, v);
 	} else {
 		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
 	}
 	local_irq_restore(flags);
 
 	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
+		pr_err("%s: error %d\n", __func__, err);
 
 	return err ? -EINVAL : len;
 }
 
-static DEVICE_ATTR(rxq,	        S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(txq,         S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(rxq_size,    S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(rxq_pkts_coal, S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(rxq_time_coal, S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(rx_reset,    S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(txq_size,    S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_coal,    S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_def,     S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_wrr,     S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_rate,    S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_burst,   S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txq_clean,   S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(txp_rate,    S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(txp_burst,   S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(txp_reset,   S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(ejp,         S_IWUSR, mv_eth_show, mv_eth_3_store);
 static DEVICE_ATTR(buf_num,     S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(rxq_tos,     S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
-static DEVICE_ATTR(rxq_vlan,    S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
-static DEVICE_ATTR(txq_tos,     S_IWUSR, mv_eth_show, mv_eth_4_hex_store);
-static DEVICE_ATTR(mh_en,       S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(mh_2B,       S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(tx_cmd,      S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(tx_nopad,    S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(debug,       S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(wrr_regs,    S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(cntrs,       S_IWUSR, mv_eth_show, mv_eth_4_store);
+static DEVICE_ATTR(cntrs,       S_IWUSR, mv_eth_show, mv_eth_2_store);
 static DEVICE_ATTR(port,        S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(stack,        S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(rxq_regs,    S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(txq_regs,    S_IWUSR, mv_eth_show, mv_eth_4_store);
 static DEVICE_ATTR(mac,         S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(vprio,       S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(tos,         S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(stats,       S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(skb,	        S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(ports,       S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(help,        S_IRUSR, mv_eth_show, NULL);
-static DEVICE_ATTR(rx_weight,   S_IWUSR, NULL, mv_eth_3_store);
 static DEVICE_ATTR(p_regs,      S_IWUSR, mv_eth_show, mv_eth_port_store);
 static DEVICE_ATTR(gmac_regs,   S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(txp_regs,    S_IWUSR, mv_eth_show, mv_eth_4_store);
-static DEVICE_ATTR(rxq_type,    S_IWUSR, mv_eth_show, mv_eth_3_store);
-static DEVICE_ATTR(tx_done,     S_IWUSR, mv_eth_show, mv_eth_3_store);
 #ifdef CONFIG_MV_ETH_PNC
 static DEVICE_ATTR(pnc,         S_IWUSR, NULL, mv_eth_port_store);
 #endif /* CONFIG_MV_ETH_PNC */
 #ifdef CONFIG_MV_ETH_PNC_WOL
 static DEVICE_ATTR(wol_mode,	S_IWUSR, mv_eth_show, mv_eth_port_store);
 #endif /* CONFIG_MV_ETH_PNC_WOL */
-static DEVICE_ATTR(cpu_group,   S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
-static DEVICE_ATTR(rxq_group,   S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
-static DEVICE_ATTR(napi,        S_IWUSR, mv_eth_show, mv_eth_port_store);
-static DEVICE_ATTR(txq_mask,    S_IWUSR, mv_eth_show, mv_eth_3_hex_store);
-static DEVICE_ATTR(txq_shared,  S_IWUSR, mv_eth_show, mv_eth_4_store);
 static DEVICE_ATTR(netdev,       S_IWUSR, NULL, mv_eth_netdev_store);
 
 static struct attribute *mv_eth_attrs[] = {
 
-	&dev_attr_rxq.attr,
-	&dev_attr_txq.attr,
-	&dev_attr_rxq_time_coal.attr,
-	&dev_attr_rx_reset.attr,
-	&dev_attr_rxq_size.attr,
-	&dev_attr_rxq_pkts_coal.attr,
-	&dev_attr_txq_size.attr,
-	&dev_attr_txq_coal.attr,
-	&dev_attr_txq_def.attr,
-	&dev_attr_txq_wrr.attr,
-	&dev_attr_txq_rate.attr,
-	&dev_attr_txq_burst.attr,
-	&dev_attr_txq_clean.attr,
-	&dev_attr_txp_rate.attr,
-	&dev_attr_txp_burst.attr,
-	&dev_attr_txp_reset.attr,
-	&dev_attr_ejp.attr,
 	&dev_attr_buf_num.attr,
-	&dev_attr_rxq_tos.attr,
-	&dev_attr_rxq_vlan.attr,
-	&dev_attr_txq_tos.attr,
-	&dev_attr_mh_en.attr,
-	&dev_attr_mh_2B.attr,
-	&dev_attr_tx_cmd.attr,
-	&dev_attr_tx_nopad.attr,
 	&dev_attr_debug.attr,
-	&dev_attr_wrr_regs.attr,
-	&dev_attr_rxq_regs.attr,
-	&dev_attr_txq_regs.attr,
 	&dev_attr_port.attr,
 	&dev_attr_stack.attr,
 	&dev_attr_stats.attr,
 	&dev_attr_cntrs.attr,
 	&dev_attr_ports.attr,
 	&dev_attr_netdev.attr,
-	&dev_attr_tos.attr,
 	&dev_attr_mac.attr,
-	&dev_attr_vprio.attr,
 	&dev_attr_skb.attr,
 	&dev_attr_p_regs.attr,
 	&dev_attr_gmac_regs.attr,
-	&dev_attr_txp_regs.attr,
-	&dev_attr_rxq_type.attr,
-	&dev_attr_tx_done.attr,
 	&dev_attr_help.attr,
-	&dev_attr_rx_weight.attr,
 #ifdef CONFIG_MV_ETH_PNC
     &dev_attr_pnc.attr,
 #endif /* CONFIG_MV_ETH_PNC */
 #ifdef CONFIG_MV_ETH_PNC_WOL
 	&dev_attr_wol_mode.attr,
 #endif
-	&dev_attr_cpu_group.attr,
-	&dev_attr_rxq_group.attr,
-	&dev_attr_napi.attr,
-	&dev_attr_txq_mask.attr,
-	&dev_attr_txq_shared.attr,
 	NULL
 };
 
 static struct attribute_group mv_eth_group = {
-	.name = "gbe",
 	.attrs = mv_eth_attrs,
 };
 
+static struct kobject *gbe_kobj;
+
 int mv_neta_gbe_sysfs_init(struct kobject *neta_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(neta_kobj, &mv_eth_group);
+	gbe_kobj = kobject_create_and_add("gbe", neta_kobj);
+	if (!gbe_kobj) {
+		pr_err("%s: cannot create gbe kobject\n", __func__);
+		return -ENOMEM;
+	}
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_group);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	err = mv_neta_rx_sysfs_init(gbe_kobj);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	err = mv_neta_tx_sysfs_init(gbe_kobj);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	err = mv_neta_tx_sched_sysfs_init(gbe_kobj);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	err = mv_neta_qos_sysfs_init(gbe_kobj);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	err = mv_neta_rss_sysfs_init(gbe_kobj);
 	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
+		pr_info("sysfs group failed %d\n", err);
 		return err;
 	}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.h
index 1740e23..e410258 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.h
@@ -50,8 +50,23 @@ int mv_neta_wol_sysfs_exit(struct kobject *gbe_kobj);
 int mv_neta_pon_sysfs_init(struct kobject *gbe_kobj);
 int mv_neta_pon_sysfs_exit(struct kobject *gbe_kobj);
 #ifdef CONFIG_MV_ETH_L2FW
-int mv_neta_l2fw_sysfs_init(struct kobject *pp2_kobj);
-int mv_neta_l2fw_sysfs_exit(struct kobject *pp2_kobj);
+int mv_neta_l2fw_sysfs_init(struct kobject *neta_kobj);
+int mv_neta_l2fw_sysfs_exit(struct kobject *neta_kobj);
 #endif
 
+int mv_neta_rx_sysfs_init(struct kobject *gbe_kobj);
+int mv_neta_rx_sysfs_exit(struct kobject *gbe_kobj);
+
+int mv_neta_tx_sysfs_init(struct kobject *gbe_kobj);
+int mv_neta_tx_sysfs_exit(struct kobject *gbe_kobj);
+
+int mv_neta_tx_sched_sysfs_init(struct kobject *gbe_kobj);
+int mv_neta_tx_sched_sysfs_exit(struct kobject *gbe_kobj);
+
+int mv_neta_qos_sysfs_init(struct kobject *gbe_kobj);
+int mv_neta_qos_sysfs_exit(struct kobject *gbe_kobj);
+
+int mv_neta_rss_sysfs_init(struct kobject *gbe_kobj);
+int mv_neta_rss_sysfs_exit(struct kobject *gbe_kobj);
+
 #endif /* __mv_eth_sysfs_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sched_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sched_sysfs.c
new file mode 100644
index 0000000..70eb044
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sched_sysfs.c
@@ -0,0 +1,185 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "mv_netdev.h"
+
+static ssize_t mv_eth_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "p, txp, txq, d                        - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	o += scnprintf(b+o, s-o, "echo p txp         > wrr_regs      - show WRR registers for <p/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp {0|1}   > ejp           - enable/disable EJP mode for <port/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp d       > txp_rate      - set outgoing rate <d> in [kbps] for <port/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp d       > txp_burst     - set maximum burst <d> in [Bytes] for <port/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_rate      - set outgoing rate <d> in [kbps] for <port/txp/txq>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_burst     - set maximum burst <d> in [Bytes] for <port/txp/txq>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_wrr       - set outgoing WRR weight for <port/txp/txq>. <d=0> - fixed\n");
+
+	return o;
+}
+
+static ssize_t mv_eth_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_eth_help(buf);
+
+	return off;
+}
+static ssize_t mv_eth_3_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, i, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %d", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txp_rate")) {
+		err = mvNetaTxpRateSet(p, i, v);
+	} else if (!strcmp(name, "txp_burst")) {
+		err = mvNetaTxpBurstSet(p, i, v);
+	} else if (!strcmp(name, "ejp")) {
+		err = mvNetaTxpEjpSet(p, i, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_4_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, txp, txq, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = txp = txq = v = 0;
+	sscanf(buf, "%d %d %d %d", &p, &txp, &txq, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "wrr_regs")) {
+		mvEthTxpWrrRegs(p, txp);
+	} else if (!strcmp(name, "txq_rate")) {
+		err = mvNetaTxqRateSet(p, txp, txq, v);
+	} else if (!strcmp(name, "txq_burst")) {
+		err = mvNetaTxqBurstSet(p, txp, txq, v);
+	} else if (!strcmp(name, "txq_wrr")) {
+		if (v == 0)
+			err = mvNetaTxqFixPrioSet(p, txp, txq);
+		else
+			err = mvNetaTxqWrrPrioSet(p, txp, txq, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,           S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(wrr_regs,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(ejp,            S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(txp_rate,       S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(txp_burst,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(txq_rate,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_burst,      S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_wrr,        S_IWUSR, NULL, mv_eth_4_store);
+
+static struct attribute *mv_eth_tx_sched_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_wrr_regs.attr,
+	&dev_attr_ejp.attr,
+	&dev_attr_txp_rate.attr,
+	&dev_attr_txp_burst.attr,
+	&dev_attr_txq_rate.attr,
+	&dev_attr_txq_burst.attr,
+	&dev_attr_txq_wrr.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_tx_sched_group = {
+	.name = "tx_sched",
+	.attrs = mv_eth_tx_sched_attrs,
+};
+
+int mv_neta_tx_sched_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_tx_sched_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_tx_sched_group.name, err);
+
+	return err;
+}
+
+int mv_neta_tx_sched_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_tx_sched_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sysfs.c
new file mode 100644
index 0000000..969e19d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tx_sysfs.c
@@ -0,0 +1,281 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "mv_netdev.h"
+
+
+static ssize_t mv_eth_help(char *b)
+{
+	int o = 0; /* buffer offset */
+	int s = PAGE_SIZE; /* buffer size */
+
+	o += scnprintf(b+o, s-o, "p, txp, txq, cpu, d                   - are dec numbers\n");
+	o += scnprintf(b+o, s-o, "v, mask                               - are hex numbers\n");
+	o += scnprintf(b+o, s-o, "\n");
+
+	o += scnprintf(b+o, s-o, "echo p txp         > txp_regs      - show TX registers for <p/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq     > txq_regs      - show TXQ registers for <p/txp/txq>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq           - show TXQ descriptors ring for <p/txp/txq>. d=0-brief, d=1-full\n");
+	o += scnprintf(b+o, s-o, "echo p txp         > txp_reset     - reset TX part of the port <p/txp>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq     > txq_clean     - clean TXQ <p/txp/txq> - free descriptors and buffers\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq cpu > txq_def       - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_size      - set number of descriptors <d> for <port/txp/txq>.\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_coal      - set TXP/TXQ interrupt coalesing. <d> - number of sent packets\n");
+	o += scnprintf(b+o, s-o, "echo p cpu mask    > txq_mask      - set cpu <cpu> accessible txq bitmap <mask>.\n");
+	o += scnprintf(b+o, s-o, "echo p txp txq d   > txq_shared    - set/reset shared bit for <port/txp/txq>. <d> - 1/0 for set/reset.\n");
+	o += scnprintf(b+o, s-o, "echo d             > tx_done       - set threshold <d> to start tx_done operations\n");
+	o += scnprintf(b+o, s-o, "echo p {0|1}       > mh_en         - enable Marvell Header\n");
+	o += scnprintf(b+o, s-o, "echo p {0|1}       > tx_nopad      - disable zero padding on transmit\n");
+	o += scnprintf(b+o, s-o, "echo p v           > tx_mh_2B      - set 2 bytes of Marvell Header for transmit\n");
+	o += scnprintf(b+o, s-o, "echo p v           > tx_cmd        - set 4 bytes of TX descriptor offset 0xc\n");
+
+	return o;
+}
+
+static ssize_t mv_eth_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_eth_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_eth_port_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = p = v = 0;
+	sscanf(buf, "%d %x", &p, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "tx_cmd")) {
+		err = mv_eth_ctrl_tx_cmd(p, v);
+	} else if (!strcmp(name, "mh_en")) {
+		err = mv_eth_ctrl_flag(p, MV_ETH_F_MH, v);
+	} else if (!strcmp(name, "tx_mh_2B")) {
+		err = mv_eth_ctrl_tx_mh(p, MV_16BIT_BE((u16)v));
+	} else if (!strcmp(name, "tx_nopad")) {
+		err = mv_eth_ctrl_flag(p, MV_ETH_F_NO_PAD, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_3_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, i, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %d", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txp_reset")) {
+		err = mv_eth_txp_reset(p, i);
+	} else if (!strcmp(name, "tx_done")) {
+		mv_eth_ctrl_txdone(p);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_3_hex_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, i, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = i = v = 0;
+	sscanf(buf, "%d %d %x", &p, &i, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txq_mask")) {
+		err = mv_eth_cpu_txq_mask_set(p, i, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_eth_4_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, txp, txq, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	err = p = txp = txq = v = 0;
+	sscanf(buf, "%d %d %d %d", &p, &txp, &txq, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "txq_def")) {
+		err = mv_eth_ctrl_txq_cpu_def(p, txp, txq, v);
+	} else if (!strcmp(name, "txp_regs")) {
+		mvNetaTxpRegs(p, txp);
+	} else if (!strcmp(name, "txq_size")) {
+		err = mv_eth_ctrl_txq_size_set(p, txp, txq, v);
+	} else if (!strcmp(name, "txq_coal")) {
+		mv_eth_tx_done_pkts_coal_set(p, txp, txq, v);
+	} else if (!strcmp(name, "txq")) {
+		mvNetaTxqShow(p, txp, txq, v);
+	} else if (!strcmp(name, "txq_regs")) {
+		mvNetaTxqRegs(p, txp, txq);
+	} else if (!strcmp(name, "txq_clean")) {
+		err = mv_eth_txq_clean(p, txp, txq);
+	} else if (!strcmp(name, "txq_shared")) {
+		err = mv_eth_shared_set(p, txp, txq, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+	local_irq_restore(flags);
+
+	if (err)
+		pr_err("%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,           S_IRUSR, mv_eth_show, NULL);
+static DEVICE_ATTR(txp_regs,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_regs,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq,            S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(tx_mh_2B,       S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(tx_cmd,         S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(txp_reset,      S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(txq_clean,      S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_def,        S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_size,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(txq_coal,       S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(mh_en,          S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(tx_done,        S_IWUSR, NULL, mv_eth_3_store);
+static DEVICE_ATTR(txq_mask,       S_IWUSR, NULL, mv_eth_3_hex_store);
+static DEVICE_ATTR(txq_shared,     S_IWUSR, NULL, mv_eth_4_store);
+static DEVICE_ATTR(tx_nopad,       S_IWUSR, NULL, mv_eth_port_store);
+
+static struct attribute *mv_eth_tx_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_txp_regs.attr,
+	&dev_attr_txq_regs.attr,
+	&dev_attr_txq.attr,
+	&dev_attr_tx_mh_2B.attr,
+	&dev_attr_tx_cmd.attr,
+	&dev_attr_txp_reset.attr,
+	&dev_attr_txq_clean.attr,
+	&dev_attr_txq_def.attr,
+	&dev_attr_txq_size.attr,
+	&dev_attr_txq_coal.attr,
+	&dev_attr_mh_en.attr,
+	&dev_attr_tx_done.attr,
+	&dev_attr_txq_mask.attr,
+	&dev_attr_txq_shared.attr,
+	&dev_attr_tx_nopad.attr,
+	NULL
+};
+
+static struct attribute_group mv_eth_tx_group = {
+	.name = "tx",
+	.attrs = mv_eth_tx_attrs,
+};
+
+int mv_neta_tx_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_tx_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_tx_group.name, err);
+
+	return err;
+}
+
+int mv_neta_tx_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_tx_group);
+
+	return 0;
+}
-- 
1.7.5.4

