From 30ed7d8325dccdb9d029108d4b6a010d3ded979c Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Thu, 11 Jul 2013 18:14:35 +0300
Subject: [PATCH 0814/1825] ALP: Add FIQ support for AvantaLP

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b47ec1d262e57c11d3b9577085923a3f238e20ed

	To handle both IRQ and FIQ interrupts supported by the GICv1, the IRQ have to
	be signaled with Non-secure interrupts and FIQ with Secure interrupts. In
	generic GIC code there is no distinguish between Secure and Non-secure
	interrupts as well as no FIQ support. Changes in the initialization code for
	GIC distributor and GIC CPU interface were needed.

	- Use Non-secure interrupts for IRQ handling.
	- Use Secure interrupt for FIQ handling.
	- Introduce new function needed for handling FIQ.
	- Include FIQ to Linux build system.

Change-Id: I526a83f73b4ee4171f6a17cfa44ebedf4c015c3c
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/common/gic.c               |  118 +++++++++++++++++++++++++++++++++++
 arch/arm/include/asm/hardware/gic.h |    9 +++
 arch/arm/mach-avantalp/Makefile     |    1 +
 arch/arm/mach-avantalp/fiq.c        |   62 ++++++++++++++++++
 4 files changed, 190 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-avantalp/fiq.c

diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index d90d07f..3564c44 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -242,6 +242,34 @@ static void gic_unmask_irq(struct irq_data *d)
 	raw_spin_unlock(&irq_controller_lock);
 }
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+void gic_mask_fiq(unsigned int intr_nr)
+{
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *base = gic_data_dist_base(gic);
+	u32 mask = 1 << (intr_nr % 32);
+
+	writel_relaxed(mask, base + GIC_DIST_ENABLE_CLEAR + (intr_nr / 32) * 4);
+}
+
+void gic_unmask_fiq(unsigned int intr_nr)
+{
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *base = gic_data_dist_base(gic);
+	u32 mask = 1 << (intr_nr % 32);
+
+	writel_relaxed(mask, base + GIC_DIST_ENABLE_SET + (intr_nr / 32) * 4);
+}
+
+void gic_eoi_fiq(unsigned int intr_nr)
+{
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *cpu_base = gic_data_cpu_base(gic);
+
+	writel_relaxed(intr_nr, cpu_base + GIC_CPU_EOI);
+}
+#endif
+
 static void gic_eoi_irq(struct irq_data *d)
 {
 	if (gic_arch_extn.irq_eoi) {
@@ -374,6 +402,44 @@ asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)
 	} while (1);
 }
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+int gic_get_intrnr(void)
+{
+	u32 irqstat;
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *cpu_base = gic_data_cpu_base(gic);
+
+	//This read acts as an acknowledge for the interrupt.
+	irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);
+
+	return (irqstat & ~0x1c00);
+}
+
+void gic_set_secure(unsigned int intr_nr)
+{
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *base = gic_data_dist_base(gic);
+
+	raw_spin_lock(&irq_controller_lock);
+	int mask = readl_relaxed(base + GIC_DIST_SECUR + (intr_nr / 32) * 4);
+	mask &= ~(1 << (intr_nr % 32));
+	writel_relaxed(mask, base + GIC_DIST_SECUR + (intr_nr /32 ) * 4);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+void gic_set_nonsecure(unsigned int intr_nr)
+{
+	struct gic_chip_data *gic = &gic_data[0];
+	void __iomem *base = gic_data_dist_base(gic);
+
+	raw_spin_lock(&irq_controller_lock);
+	int mask = readl_relaxed(base + GIC_DIST_SECUR + (intr_nr / 32) * 4);
+	mask |= (1 << (intr_nr % 32));
+	writel_relaxed(mask, base + GIC_DIST_SECUR + (intr_nr /32 ) * 4);
+	raw_spin_unlock(&irq_controller_lock);
+}
+#endif
+
 static void gic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
 {
 	struct gic_chip_data *chip_data = irq_get_handler_data(irq);
@@ -462,7 +528,31 @@ static void __init gic_dist_init(struct gic_chip_data *gic)
 	for (i = 32; i < gic_irqs; i += 32)
 		writel_relaxed(0xffffffff, base + GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
 
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	/*
+	 * Set all interrupts as Non-secure. Leave the PPI and SGIs alone as
+	 * these enables are banked registers.
+	 * According to further gic_cpu_init all IRQs are handled as Non-secure
+	 */
+	for (i = 32; i < gic_irqs; i += 32)
+		writel_relaxed(0xffffffff, base + GIC_DIST_SECUR + i * 4 / 32);
+
+	/*
+	 * Attention: According to GICv1 documentation ICDDCR[1] is reserved,
+	 * and ICDDCR[0] is described as "Global enable for monitoring
+	 * peripheral interrupt signals and forwarding pending interrupts to
+	 * the CPU interfaces."
+	 * But in Cortex-A9 MPCore TRM (Revision: r3p0) you can find:
+	 * ICDDCR[1] - Enable Non-secure interrupts
+	 * ICDDCR[0] - Enable Secure interrupts
+	 */
+	writel_relaxed(3, base + GIC_DIST_CTRL);
+#else
+	/*
+	 * If FIQs are not used, enable only Secure interrupts
+	 */
 	writel_relaxed(1, base + GIC_DIST_CTRL);
+#endif
 }
 
 static void __cpuinit gic_cpu_init(struct gic_chip_data *gic)
@@ -485,7 +575,21 @@ static void __cpuinit gic_cpu_init(struct gic_chip_data *gic)
 		writel_relaxed(0xa0a0a0a0, dist_base + GIC_DIST_PRI + i * 4 / 4);
 
 	writel_relaxed(0xf0, base + GIC_CPU_PRIMASK);
+
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	/*
+	 * Enable signalling of Secure and Non-secure interrupts.
+	 * Signal Secure interrupts using the FIQ signal.
+	 * The GIC always signals Non-secure interrupts using the IRQ signal.
+	 */
+	writel_relaxed(0xf, base + GIC_CPU_CTRL);
+#else
+	/*
+	 * If FIQs are not used, enable only Secure interrupts,
+	 * and signal them using the IRQ signal.
+	 */
 	writel_relaxed(1, base + GIC_CPU_CTRL);
+#endif
 }
 
 #ifdef CONFIG_CPU_PM
@@ -620,7 +724,21 @@ static void gic_cpu_restore(unsigned int gic_nr)
 		writel_relaxed(0xa0a0a0a0, dist_base + GIC_DIST_PRI + i * 4);
 
 	writel_relaxed(0xf0, cpu_base + GIC_CPU_PRIMASK);
+
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+	/*
+	 * Enable signalling of Secure and Non-secure interrupts.
+	 * Signal Secure interrupts using the FIQ signal.
+	 * The GIC always signals Non-secure interrupts using the IRQ signal.
+	 */
+	writel_relaxed(0xf, cpu_base + GIC_CPU_CTRL);
+#else
+	/*
+	 * If FIQs are not used, enable only Secure interrupts,
+	 * and signal them using the IRQ signal.
+	 */
 	writel_relaxed(1, cpu_base + GIC_CPU_CTRL);
+#endif
 }
 
 static int gic_notifier(struct notifier_block *self, unsigned long cmd,	void *v)
diff --git a/arch/arm/include/asm/hardware/gic.h b/arch/arm/include/asm/hardware/gic.h
index 4b1ce6c..a39e626 100644
--- a/arch/arm/include/asm/hardware/gic.h
+++ b/arch/arm/include/asm/hardware/gic.h
@@ -22,6 +22,7 @@
 
 #define GIC_DIST_CTRL			0x000
 #define GIC_DIST_CTR			0x004
+#define GIC_DIST_SECUR			0x080
 #define GIC_DIST_ENABLE_SET		0x100
 #define GIC_DIST_ENABLE_CLEAR		0x180
 #define GIC_DIST_PENDING_SET		0x200
@@ -45,6 +46,14 @@ void gic_secondary_init(unsigned int);
 void gic_handle_irq(struct pt_regs *regs);
 void gic_cascade_irq(unsigned int gic_nr, unsigned int irq);
 void gic_raise_softirq(const struct cpumask *mask, unsigned int irq);
+#ifdef CONFIG_MV_PHONE_USE_FIQ_PROCESSING
+void gic_mask_fiq(unsigned int fiq_nr);
+void gic_unmask_fiq(unsigned int fiq_nr);
+void gic_eoi_fiq(unsigned int fiqnr);
+int gic_get_intrnr(void);
+void gic_set_secure(unsigned int intr_nr);
+void gic_set_nonsecure(unsigned int intr_nr);
+#endif
 
 static inline void gic_init(unsigned int nr, int start,
 			    void __iomem *dist , void __iomem *cpu)
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index c0408eb..c5a6fcc 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -117,6 +117,7 @@ obj-$(CONFIG_SENSORS_ALP)		+= hwmon.o
 avantalp-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
 avantalp-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
 avantalp-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+avantalp-$(CONFIG_MV_PHONE_USE_FIQ_PROCESSING) += fiq.o
 avantalp-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
 avantalp-$(CONFIG_SMP)			+= platsmp.o headsmp.o
 avantalp-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
diff --git a/arch/arm/mach-avantalp/fiq.c b/arch/arm/mach-avantalp/fiq.c
new file mode 100644
index 0000000..2f45eca
--- /dev/null
+++ b/arch/arm/mach-avantalp/fiq.c
@@ -0,0 +1,62 @@
+/*
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/interrupt.h>
+#include <asm/hardware/gic.h>
+
+static irq_handler_t fiq_handlers[NR_IRQS] = {
+	[0 ... NR_IRQS-1] = NULL,
+};
+
+typedef void (*fiq_handler_t)(void);
+extern fiq_handler_t fiq_userptr;
+
+extern int fiq_cnt;
+void handle_all_fiqs(void)
+{
+	irq_handler_t handler;
+	int fiqnr = gic_get_intrnr();
+
+	handler = fiq_handlers[fiqnr];
+	if (handler)
+		handler(fiqnr, NULL);
+
+	gic_eoi_fiq(fiqnr);
+}
+
+int __must_check
+request_fiq(unsigned int intr_nr, irq_handler_t handler, unsigned long flags,
+	    const char *name, void *dev)
+{
+	if ((intr_nr < 0) | (intr_nr >= NR_IRQS))
+		return -EINVAL;
+
+	gic_mask_fiq(intr_nr);
+
+	if (!fiq_userptr)
+		fiq_userptr = handle_all_fiqs;
+
+	if (fiq_handlers[intr_nr])
+		return -EINVAL;
+
+	/*
+	 * Set intr_nr as Secured (secure interrupts are using the FIQ signal)
+	 * Updating of the appropriate interrupt Security status bit is made
+	 * while intr_nr is masked
+	 */
+	gic_set_secure(intr_nr);
+
+	fiq_handlers[intr_nr] = handler;
+	gic_unmask_fiq(intr_nr);
+	return 0;
+}
+
+void free_fiq(unsigned int irq, void *dev_id)
+{
+	gic_mask_fiq(irq);
+	gic_set_nonsecure(irq);
+	fiq_handlers[irq] = NULL;
+}
-- 
1.7.5.4

