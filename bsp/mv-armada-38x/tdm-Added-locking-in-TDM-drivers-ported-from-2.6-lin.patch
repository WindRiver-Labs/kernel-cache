From 3a02df9dd3b9ff9304e296673bf86292db5630d6 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Thu, 11 Jul 2013 17:58:43 +0300
Subject: [PATCH 0801/1825] tdm: Added locking in TDM drivers ported from 2.6
 line.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 86cff1e4b2a1ede361c69c3a2e053491a2442067

	The 2.6.39 kernel version removed The Big Kernel Lock, which protected
	ioctl calls among other things. In 3.x kernel, the drivers are responsible
	to provide proper fine-grained locking.

Change-Id: Iec495022662c389e3a2345a9fe10d6f1367ade4c
Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_phone/spi/spi_dev.c          |   12 ++++++++++++
 .../mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c     |   20 ++++++++++++++++++--
 2 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/spi/spi_dev.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/spi/spi_dev.c
index 10bba0c..d822260 100644
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/spi/spi_dev.c
+++ b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/spi/spi_dev.c
@@ -62,9 +62,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ******************************************************************************/
 
+#include <linux/kernel.h>
 #include <linux/poll.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include "spi_dev.h"
 #include "boardEnv/mvBoardEnvLib.h"
 #include "voiceband/mvSysTdmSpi.h"
@@ -72,6 +74,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Defines */
 #define SPI_MOD_NAME				"spi"
 
+static DEFINE_MUTEX(spi_ioctl_mutex);
 static ssize_t spi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos);
 static ssize_t spi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos);
 static unsigned int spi_poll(struct file *pFile, poll_table *pPollTable);
@@ -123,14 +126,20 @@ static long spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
 {
 	int ret = 0;
 
+	mutex_lock(&spi_ioctl_mutex);
+
 	/* Argument checking */
 	if (_IOC_TYPE(cmd) != SPI_MOD_IOCTL_MAGIC) {
 		printk("%s: invalid SPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), SPI_MOD_IOCTL_MAGIC);
+
+		mutex_unlock(&spi_ioctl_mutex);
 		return -ENOTTY;
 	}
 
 	if ((_IOC_NR(cmd) > SPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < SPI_MOD_IOCTL_MIN)) {
 		printk("%s: invalid SPI MOD IOCTL request\n", __func__);
+
+		mutex_unlock(&spi_ioctl_mutex);
 		return -ENOTTY;
 	}
 
@@ -143,6 +152,8 @@ static long spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
 
 	if (ret) {
 		printk("%s: invalid SPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
+
+		mutex_unlock(&spi_ioctl_mutex);
 		return -EFAULT;
 	}
 
@@ -164,6 +175,7 @@ static long spi_ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
 			break;
 	}
 
+	mutex_unlock(&spi_ioctl_mutex);
 	return (long)ret;
 }
 
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
index c8b5aca..135f124 100644
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
+++ b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
@@ -67,7 +67,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "tdm_dev.h"
 #include "mv_phone/tdm/tdm_if.h"
 #include "mv_phone/tdm/tal.h"
+#include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/miscdevice.h>
@@ -89,6 +91,7 @@ extern void mv_unmask_fiq(unsigned int irq);
 #endif /* CONFIG_MV_PHONE_USE_FIQ_PROCESSING */
 
 /* Globals */
+static DEFINE_MUTEX(tdm_ioctl_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(tdm_dev_wait);
 static DEFINE_SPINLOCK(tdm_dev_lock);
 static tal_params_t tdm_dev_params;
@@ -316,14 +319,20 @@ static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long a
 {
 	int ret = 0;
 
+	mutex_lock(&tdm_ioctl_mutex);
+
 	/* Argument checking */
 	if (_IOC_TYPE(cmd) != TDM_DEV_IOCTL_MAGIC) {
 		printk("%s: invalid TDM DEV Magic Num %i %i\n", __FUNCTION__, _IOC_TYPE(cmd), TDM_DEV_IOCTL_MAGIC);
+
+		mutex_unlock(&tdm_ioctl_mutex);
 		return -ENOTTY;
 	}
 
 	if ((_IOC_NR(cmd) > TDM_DEV_IOCTL_MAX) || (_IOC_NR(cmd) < TDM_DEV_IOCTL_MIN)) {
 		printk("%s: invalid TDM DEV IOCTL request\n", __FUNCTION__);
+
+		mutex_unlock(&tdm_ioctl_mutex);
 		return -ENOTTY;
 	}
 
@@ -336,6 +345,8 @@ static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long a
 
 	if (ret) {
 		printk("%s: invalid TDM DEV access type %i from cmd %i\n", __FUNCTION__, _IOC_DIR(cmd), cmd);
+
+		mutex_unlock(&tdm_ioctl_mutex);
 		return -EFAULT;
 	}
 
@@ -377,7 +388,9 @@ static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long a
 			/* Put user data */
 			if(copy_to_user((void*)arg, &tdm_dev_clk, sizeof(tdm_dev_clk_t))) {
 				printk("%s: copy_to_user failed\n", __FUNCTION__);
-			return -EFAULT;
+
+				mutex_unlock(&tdm_ioctl_mutex);
+				return -EFAULT;
 			}
 			printk("ioctl: TDM_DEV_TDM_CLK_GET\n");
 			break;
@@ -386,7 +399,9 @@ static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long a
 			/* Get user data */
 			if(copy_from_user(&tdm_dev_clk, (void*)arg, sizeof(tdm_dev_clk_t))) {
 				printk("%s: copy_from_user failed\n", __FUNCTION__);
-			return -EFAULT;
+
+				mutex_unlock(&tdm_ioctl_mutex);
+				return -EFAULT;
 			}
 			printk("ioctl: TDM_DEV_TDM_CLK_SET: %x\n", tdm_dev_clk.correction);
 			mvCtrlTdmClkCtrlSet(tdm_dev_clk.correction);
@@ -395,6 +410,7 @@ static long tdm_dev_ioctl(struct file *file_p, unsigned int cmd, unsigned long a
 #endif
 	}
 
+	mutex_unlock(&tdm_ioctl_mutex);
 	return ret;
 }
 static int tdm_dev_open(struct inode *inode_p, struct file *file_p)
-- 
1.7.5.4

