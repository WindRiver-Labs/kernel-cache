From 3d91046af10aeaa466dc16ca9dda5245f8fd711f Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Tue, 28 Jan 2014 09:14:36 +0200
Subject: [PATCH 1313/1825] msys: BC2 initial Linux support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2e359a463d44ae7f8d416815fc99586952f90499

	- add support for BC2 platform
	- code cleanup
	- this patch supports minimal MSYS support, achives Linux prompt on BC2 RD SMP.
	 Following interfaces are not supported by Linux: PEX,XOR,SPI,NFC,I2C,SDIO,ETH

Change-Id: I57e2f26d461b9561130be45734c13f0d67cfe7fd
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5320
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .gitignore                                         |    2 +-
 arch/arm/Kconfig                                   |   24 +-
 arch/arm/Makefile                                  |    1 +
 arch/arm/boot/compressed/head.S                    |    7 +-
 arch/arm/configs/msys_defconfig                    |  150 +++
 arch/arm/mach-msys/Kconfig                         |   17 +
 arch/arm/mach-msys/Makefile                        |   66 +
 arch/arm/mach-msys/Makefile.boot                   |    3 +
 arch/arm/mach-msys/clock.c                         |   74 ++
 arch/arm/mach-msys/clock.h                         |   32 +
 arch/arm/mach-msys/config/mvRules.mk               |  132 ++
 arch/arm/mach-msys/config/mvSysCntmrConfig.h       |   36 +
 arch/arm/mach-msys/config/mvSysDdrConfig.h         |   44 +
 arch/arm/mach-msys/config/mvSysEthConfig.h         |  183 +++
 arch/arm/mach-msys/config/mvSysEthPhyConfig.h      |   31 +
 arch/arm/mach-msys/config/mvSysGppConfig.h         |   37 +
 arch/arm/mach-msys/config/mvSysHwConfig.h          |  241 ++++
 arch/arm/mach-msys/config/mvSysPciConfig.h         |   25 +
 arch/arm/mach-msys/config/mvSysPexConfig.h         |   49 +
 arch/arm/mach-msys/config/mvSysTwsiConfig.h        |   41 +
 arch/arm/mach-msys/config/mvSysXorConfig.h         |   36 +
 arch/arm/mach-msys/core.c                          |  632 ++++++++++
 arch/arm/mach-msys/dump_cp15_regs.c                |  237 ++++
 arch/arm/mach-msys/flashmap.c                      |  263 ++++
 arch/arm/mach-msys/headsmp.S                       |  110 ++
 arch/arm/mach-msys/include/mach/clkdev.h           |    7 +
 arch/arm/mach-msys/include/mach/debug-macro.S      |   24 +
 arch/arm/mach-msys/include/mach/entry-macro.S      |  189 +++
 arch/arm/mach-msys/include/mach/gpio.h             |   55 +
 arch/arm/mach-msys/include/mach/hardware.h         |   14 +
 arch/arm/mach-msys/include/mach/io.h               |   30 +
 arch/arm/mach-msys/include/mach/irqs.h             |  182 +++
 arch/arm/mach-msys/include/mach/kw_macro.h         |   39 +
 arch/arm/mach-msys/include/mach/memory.h           |   26 +
 arch/arm/mach-msys/include/mach/msys.h             |  229 ++++
 arch/arm/mach-msys/include/mach/param.h            |   15 +
 arch/arm/mach-msys/include/mach/serial.h           |   40 +
 arch/arm/mach-msys/include/mach/smp.h              |   46 +
 arch/arm/mach-msys/include/mach/system.h           |   40 +
 arch/arm/mach-msys/include/mach/timex.h            |    9 +
 arch/arm/mach-msys/include/mach/uncompress.h       |   42 +
 arch/arm/mach-msys/irq.c                           |  287 +++++
 arch/arm/mach-msys/irq.h                           |   39 +
 arch/arm/mach-msys/mpp.h                           |   46 +
 arch/arm/mach-msys/msys_family/.gitignore          |    5 +
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.c |    6 +-
 arch/arm/mach-msys/msys_family/cpu/mvCpu.h         |    2 +-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   |  234 +----
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h   |   16 -
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h  |   20 +-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h  |   46 +-
 .../mach-msys/msys_family/ctrlEnv/mvSemaphore.h    |    1 -
 arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h |   22 -
 .../mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c    |    8 +-
 .../msys_family/ctrlEnv/sys/mvCpuIfRegs.h          |    1 +
 arch/arm/mach-msys/mv_hal_if/mvSysCntmr.c          |   93 ++
 arch/arm/mach-msys/mv_hal_if/mvSysCntmrApi.h       |   70 ++
 arch/arm/mach-msys/mv_hal_if/mvSysDdr.c            |  133 ++
 arch/arm/mach-msys/mv_hal_if/mvSysPci.c            | 1270 ++++++++++++++++++++
 arch/arm/mach-msys/mv_hal_if/mvSysPci.h            |  251 ++++
 arch/arm/mach-msys/mv_hal_if/mvSysPex.c            |  103 ++
 arch/arm/mach-msys/mv_hal_if/mvSysPexApi.h         |   70 ++
 arch/arm/mach-msys/pci.c                           |  246 ++++
 arch/arm/mach-msys/pex.c                           |  598 +++++++++
 arch/arm/mach-msys/platsmp.c                       |  264 ++++
 arch/arm/mach-msys/platsmp.h                       |   32 +
 arch/arm/mach-msys/proc_aurora_dbg.c               |  113 ++
 arch/arm/mach-msys/sysmap.c                        |  114 ++
 arch/arm/mach-msys/sysmap.h                        |   41 +
 arch/arm/mach-msys/time.c                          |  404 +++++++
 arch/arm/mach-msys/time.h                          |   30 +
 arch/arm/mm/Kconfig                                |   13 +-
 arch/arm/mm/proc-sheeva_pj4bv7.S                   |   47 +-
 arch/arm/mm/sheeva_pj4b-macros.S                   |    9 +-
 arch/arm/plat-armada/Kconfig                       |   21 +-
 arch/arm/tools/mach-types                          |    1 +
 76 files changed, 7738 insertions(+), 378 deletions(-)
 create mode 100644 arch/arm/configs/msys_defconfig
 create mode 100644 arch/arm/mach-msys/Kconfig
 create mode 100644 arch/arm/mach-msys/Makefile
 create mode 100644 arch/arm/mach-msys/Makefile.boot
 create mode 100644 arch/arm/mach-msys/clock.c
 create mode 100644 arch/arm/mach-msys/clock.h
 create mode 100644 arch/arm/mach-msys/config/mvRules.mk
 create mode 100644 arch/arm/mach-msys/config/mvSysCntmrConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysDdrConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysEthConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysEthPhyConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysGppConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysPciConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysPexConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysTwsiConfig.h
 create mode 100644 arch/arm/mach-msys/config/mvSysXorConfig.h
 create mode 100644 arch/arm/mach-msys/core.c
 create mode 100644 arch/arm/mach-msys/dump_cp15_regs.c
 create mode 100644 arch/arm/mach-msys/flashmap.c
 create mode 100644 arch/arm/mach-msys/headsmp.S
 create mode 100644 arch/arm/mach-msys/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-msys/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-msys/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-msys/include/mach/gpio.h
 create mode 100644 arch/arm/mach-msys/include/mach/hardware.h
 create mode 100644 arch/arm/mach-msys/include/mach/io.h
 create mode 100644 arch/arm/mach-msys/include/mach/irqs.h
 create mode 100644 arch/arm/mach-msys/include/mach/kw_macro.h
 create mode 100644 arch/arm/mach-msys/include/mach/memory.h
 create mode 100644 arch/arm/mach-msys/include/mach/msys.h
 create mode 100644 arch/arm/mach-msys/include/mach/param.h
 create mode 100644 arch/arm/mach-msys/include/mach/serial.h
 create mode 100644 arch/arm/mach-msys/include/mach/smp.h
 create mode 100644 arch/arm/mach-msys/include/mach/system.h
 create mode 100644 arch/arm/mach-msys/include/mach/timex.h
 create mode 100644 arch/arm/mach-msys/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-msys/irq.c
 create mode 100644 arch/arm/mach-msys/irq.h
 create mode 100644 arch/arm/mach-msys/mpp.h
 create mode 100644 arch/arm/mach-msys/msys_family/.gitignore
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysCntmr.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysCntmrApi.h
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysDdr.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPci.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPci.h
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPex.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysPexApi.h
 create mode 100644 arch/arm/mach-msys/pci.c
 create mode 100644 arch/arm/mach-msys/pex.c
 create mode 100644 arch/arm/mach-msys/platsmp.c
 create mode 100644 arch/arm/mach-msys/platsmp.h
 create mode 100644 arch/arm/mach-msys/proc_aurora_dbg.c
 create mode 100644 arch/arm/mach-msys/sysmap.c
 create mode 100644 arch/arm/mach-msys/sysmap.h
 create mode 100644 arch/arm/mach-msys/time.c
 create mode 100644 arch/arm/mach-msys/time.h

diff --git a/.gitignore b/.gitignore
index 5e997a8..0ad797c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -62,7 +62,7 @@ modules.builtin
 arch/arm/mach-armada38x/armada_38x_family/
 arch/arm/mach-armadaxp/armada_xp_family/
 arch/arm/mach-avantalp/avanta_lp_family/
-arch/arm/mach-msys/
+arch/arm/mach-msys/msys_family/
 arch/arm/plat-armada/common/
 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/
 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 7941bbf..a4e1d11 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -678,6 +678,27 @@ config ARCH_ARMADA_XP
 	select DMABOUNCE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 
+config ARCH_MSYS
+        bool "Marvell MSYS"
+        select CPU_V7
+        select PCI
+        select ARCH_HAS_CPUFREQ
+        select ARCH_SUPPORTS_MSI
+        select ARCH_REQUIRE_GPIOLIB
+        select GENERIC_GPIO
+        select GENERIC_TIME
+        select GENERIC_CLOCKEVENTS
+        select HAVE_SMP
+        select PLAT_ARMADA
+        select HAVE_REGS_AND_STACK_ACCESS_API
+        select COMMON_CLKDEV
+        select CLKSRC_MMIO
+        select CLKDEV_LOOKUP
+        select NEED_MACH_IO_H
+        select NEED_MACH_MEMORY_H
+        select DMABOUNCE
+        select ARCH_HAS_HOLES_MEMORYMODEL
+
 config ARCH_MV78XX0
 	bool "Marvell MV78xx0"
 	select CPU_FEROCEON
@@ -737,7 +758,7 @@ config ARCH_AVANTA_LP
 	select MIGHT_HAVE_CACHE_L2X0
 	help
 	  Support for the Marvell Avanta-LP SoC Family
- 
+
 config ARCH_MMP
 	bool "Marvell PXA168/910/MMP2"
 	depends on MMU
@@ -1207,6 +1228,7 @@ source "arch/arm/mach-sa1100/Kconfig"
 source "arch/arm/mach-armada370/Kconfig"
 source "arch/arm/mach-armada38x/Kconfig"
 source "arch/arm/mach-armadaxp/Kconfig"
+source "arch/arm/mach-msys/Kconfig"
 source "arch/arm/mach-avantalp/Kconfig"
 source "arch/arm/plat-armada/Kconfig"
 source "arch/arm/plat-feroceon/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index c43f223..7e77355 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -207,6 +207,7 @@ machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
 machine-$(CONFIG_ARCH_ARMADA_XP)	:= armadaxp
+machine-$(CONFIG_ARCH_MSYS)		:= msys
 machine-$(CONFIG_ARCH_AVANTA_LP)	:= avantalp
 
 # Platform directory name.  This list is sorted alphanumerically
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 28063a3..917f6a6 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -15,6 +15,9 @@
 #ifdef CONFIG_ARCH_ARMADA38X
 #include <mach/armada38x.h>
 #endif
+#ifdef CONFIG_ARCH_MSYS
+#include <mach/msys.h>
+#endif
 
 	.arch	armv7-a
 /*
@@ -956,7 +959,7 @@ proc_types:
 		W(b)	__armv3_mpu_cache_on
 		W(b)	__armv3_mpu_cache_off
 		W(b)	__armv3_mpu_cache_flush
-		
+
 		.word	0x41009400		@ ARM94x
 		.word	0xff00ff00
 		W(b)	__armv4_mpu_cache_on
@@ -1193,7 +1196,7 @@ __armv4_mpu_cache_flush:
 		mcrne	p15, 0, ip, c7, c5, 0	@ invalidate I cache
 		mcr	p15, 0, ip, c7, c10, 4	@ drain WB
 		mov	pc, lr
-		
+
 __fa526_cache_flush:
 		mov	r1, #0
 		mcr	p15, 0, r1, c7, c14, 0	@ clean and invalidate D cache
diff --git a/arch/arm/configs/msys_defconfig b/arch/arm/configs/msys_defconfig
new file mode 100644
index 0000000..c272785
--- /dev/null
+++ b/arch/arm/configs/msys_defconfig
@@ -0,0 +1,150 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_PERF_EVENTS is not set
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_EFI_PARTITION=y
+CONFIG_ARCH_MSYS=y
+# CONFIG_MV_INCLUDE_GIG_ETH is not set
+# CONFIG_MV_INCLUDE_SPI is not set
+CONFIG_MV_HAL_RULES_PATH="arch/arm/mach-armadaxp/mv_hal_support/mvRules.mk"
+# CONFIG_MV_INCLUDE_PEX is not set
+# CONFIG_MV_INCLUDE_XOR is not set
+# CONFIG_MV_INCLUDE_NFC is not set
+# CONFIG_MV_INCLUDE_LEGACY_NAND is not set
+# CONFIG_MV_INCLUDE_SDIO is not set
+CONFIG_MV_PMU_PROC=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
+CONFIG_PCI_DEBUG=y
+CONFIG_NO_HZ=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=y
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+CONFIG_NET_PKTGEN=m
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_E100=y
+CONFIG_E1000E=y
+CONFIG_SKY2=y
+CONFIG_PHYLIB=y
+CONFIG_PPP=y
+CONFIG_PPPOE=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MV64XXX=y
+CONFIG_SPI=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_THERMAL_SENSOR_KW2 is not set
+# CONFIG_SENSORS_ARMADA is not set
+CONFIG_SENSORS_JC42=y
+# CONFIG_VGA_ARB is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_MVSDIO=y
+CONFIG_NEW_LEDS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_XATTR is not set
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_UTF8=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_FTRACE is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_OCF_OCF=y
+CONFIG_OCF_CRYPTODEV=y
+CONFIG_CRC_CCITT=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/mach-msys/Kconfig b/arch/arm/mach-msys/Kconfig
new file mode 100644
index 0000000..4e32811
--- /dev/null
+++ b/arch/arm/mach-msys/Kconfig
@@ -0,0 +1,17 @@
+if ARCH_MSYS
+
+config  MV_HAL_RULES_PATH
+        string "path of the mvRules.mk file for HAL drivers"
+        default "arch/arm/mach-msys/mv_hal_support/mvRules.mk"
+        ---help---
+
+menu "Marvell MSYS Options"
+
+config MACH_MSYS_BC2_DB
+	bool "Marvell MSYS BC2 Development Board"
+	default y
+	help
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-msys/Makefile b/arch/arm/mach-msys/Makefile
new file mode 100644
index 0000000..e310ee3
--- /dev/null
+++ b/arch/arm/mach-msys/Makefile
@@ -0,0 +1,66 @@
+#*******************************************************************************
+# Marvell GPL License Option
+#
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
+# disclaimer.
+#*******************************************************************************/
+include 	  $(srctree)/arch/arm/mach-msys/config/mvRules.mk
+
+
+# Objects list
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_CNTMR_DIR)/mvCntmr.o $(HAL_IF_DIR)/mvSysCntmr.o		\
+		$(HAL_TWSI_DIR)/mvTwsi.o					\
+		$(HAL_UART_DIR)/mvUart.o $(HAL_GPP_DIR)/mvGpp.o			\
+		$(HAL_DRAM_DIR)/mvDramIf.o
+
+KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o $(SOC_ENV_DIR)/mvCtrlEnvLib.o	\
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
+		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
+		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o
+
+LSP_OBJS        = core.o irq.o time.o sysmap.o clock.o
+
+obj-y   			:=  msys.o
+msys-objs  			:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
+					$(KW_FAM_OBJS)
+
+msys-$(CONFIG_MV_INCLUDE_PEX) 	+= $(HAL_PEX_DIR)/mvPex.o					\
+					$(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
+
+msys-$(CONFIG_MV_INCLUDE_PCI) 	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+
+msys-$(CONFIG_MV_INCLUDE_SPI) 	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o 			\
+					   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
+					   $(HAL_IF_DIR)/mvSysSpi.o
+msys-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
+
+# drivers part
+
+obj-$(CONFIG_ERROR_HANDLING)		+= $(LSP_ERR_DIR)/mv_error.o
+obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
+obj-y                                   += $(LSP_MUX_DIR)/
+# The rest of the drivers are compiled through the driver dir directly.
+
+
+# LSP part
+msys-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+msys-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+msys-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+msys-$(CONFIG_SMP)		+= platsmp.o headsmp.o
+msys-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
diff --git a/arch/arm/mach-msys/Makefile.boot b/arch/arm/mach-msys/Makefile.boot
new file mode 100644
index 0000000..7a1f3c0
--- /dev/null
+++ b/arch/arm/mach-msys/Makefile.boot
@@ -0,0 +1,3 @@
+zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-msys/clock.c b/arch/arm/mach-msys/clock.c
new file mode 100644
index 0000000..e7bc304
--- /dev/null
+++ b/arch/arm/mach-msys/clock.c
@@ -0,0 +1,74 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/* TODO: Implement the functions below...	*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+
+#include "clock.h"
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+void clks_register(struct clk *clks, size_t num)
+{
+}
+
+static int __init clk_init(void)
+{
+	/* TODO: Call clks_register with appropriate params. */
+	clks_register(NULL, 0);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-msys/clock.h b/arch/arm/mach-msys/clock.h
new file mode 100644
index 0000000..4bdd4f4
--- /dev/null
+++ b/arch/arm/mach-msys/clock.h
@@ -0,0 +1,32 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+struct clk {
+	unsigned int dummy;
+};
+
+void clks_register(struct clk *clks, size_t num);
diff --git a/arch/arm/mach-msys/config/mvRules.mk b/arch/arm/mach-msys/config/mvRules.mk
new file mode 100644
index 0000000..9c7545c
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvRules.mk
@@ -0,0 +1,132 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F78xx0
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+PLAT_PATH	  = ../plat-armada
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR           = $(PLAT_PATH)/mv_hal
+COMMON_DIR        = $(PLAT_PATH)/common
+OSSERV_DIR        = $(PLAT_PATH)/linux_oss
+CONFIG_DIR        = config
+HAL_IF		  = mv_hal_if
+
+# HALs
+HAL_ETHPHY_DIR    = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR     = $(HAL_DIR)/flash
+HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
+HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3/
+HAL_GPP_DIR       = $(HAL_DIR)/gpp
+HAL_TWSI_DIR      = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR      = $(HAL_DIR)/uart
+
+# NETA driver directories
+HAL_NETA_DIR      = $(HAL_DIR)/neta
+HAL_NETA_GBE_DIR  = $(HAL_DIR)/neta/gbe
+HAL_NETA_NFP_DIR  = $(HAL_DIR)/neta/nfp
+HAL_NETA_PNC_DIR  = $(HAL_DIR)/neta/pnc
+HAL_NETA_BM_DIR   = $(HAL_DIR)/neta/bm
+HAL_NETA_PMT_DIR  = $(HAL_DIR)/neta/pmt
+LSP_NETA_DIR      = $(PLAT_DRIVERS)/mv_neta
+LSP_NETA_DEV_DIR  = $(LSP_NETA_DIR)/net_dev
+LSP_NETA_NFP_DIR  = $(LSP_NETA_DIR)/nfp_mgr
+LSP_NETA_PNC_DIR  = $(LSP_NETA_DIR)/pnc
+LSP_NETA_BM_DIR   = $(LSP_NETA_DIR)/bm
+LSP_NETA_PMT_DIR  = $(LSP_NETA_DIR)/pmt
+LSP_NETA_HWF_DIR  = $(LSP_NETA_DIR)/hwf
+
+# Legacy network driver directoires
+HAL_ETH_DIR       = $(HAL_DIR)/eth
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/eth/gbe
+HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_network
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/mv_etherent
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+
+HAL_CPU_DIR       = $(HAL_DIR)/cpu
+HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
+
+ifeq ($(CONFIG_MV_INCLUDE_PEX),y)
+HAL_PCI_DIR	  = $(HAL_DIR)/pci
+HAL_PEX_DIR       = $(HAL_DIR)/pex
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_XOR),y)
+HAL_XOR_DIR       = $(HAL_DIR)/xor
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR       = $(HAL_DIR)/spi
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
+HAL_NFC_DIR       = $(HAL_DIR)/nfc
+endif
+
+LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
+LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
+LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
+LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
+LSP_IPC_DIR       = $(PLAT_DRIVERS)/mv_ipc/linux_amp
+
+
+# Environment components
+MSYS_FAM_DIR	= msys_family
+SOC_DEVICE_DIR	= $(MSYS_FAM_DIR)/device
+SOC_CPU_DIR	= $(MSYS_FAM_DIR)/cpu
+BOARD_ENV_DIR	= $(MSYS_FAM_DIR)/boardEnv
+SOC_ENV_DIR	= $(MSYS_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	= $(MSYS_FAM_DIR)/ctrlEnv/sys
+HAL_IF_DIR	= mv_hal_if
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I      = $(srctree)/arch/arm/mach-msys
+PLAT_PATH_I	= $(srctree)/arch/arm/plat-armada
+
+HAL_PATH        = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_NETA_DIR)
+MSYS_FAM_PATH	= -I$(LSP_PATH_I)/$(MSYS_FAM_DIR)
+
+COMMON_PATH   	= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+
+OSSERV_PATH     = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH        = -I$(LSP_PATH_I)
+CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
+HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
+DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
+		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR)
+
+EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(MSYS_FAM_PATH) \
+                  $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+
+
+ifeq ($(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT),y)
+EXTRA_CFLAGS    +=-DPCIE_VIRTUAL_BRIDGE_SUPPORT
+endif
+
+EXTRA_CFLAGS 	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS 	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-msys/config/mvSysCntmrConfig.h b/arch/arm/mach-msys/config/mvSysCntmrConfig.h
new file mode 100644
index 0000000..b6646ae
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysCntmrConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCntmrConfig.h - Marvell Counter Manager unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for counter manager registers.
+*/
+#define MV_CNTMR_REGS_BASE		(MV_CNTMR_REGS_OFFSET)
diff --git a/arch/arm/mach-msys/config/mvSysDdrConfig.h b/arch/arm/mach-msys/config/mvSysDdrConfig.h
new file mode 100644
index 0000000..6dfd446
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysDdrConfig.h
@@ -0,0 +1,44 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for DDR registers.
+*/
+#define MV_DDR_WIN_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_DDR_CTRL_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+/* used for ddr2 "bak" files */
+#define MV_DDR_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+#ifndef MV_BOOTROM
+#define MV_STATIC_DRAM_ON_BOARD
+#endif
diff --git a/arch/arm/mach-msys/config/mvSysEthConfig.h b/arch/arm/mach-msys/config/mvSysEthConfig.h
new file mode 100644
index 0000000..d19f3ca
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysEthConfig.h
@@ -0,0 +1,183 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for ethernet registers.
+*/
+#define MV_PON_PORT(p)		MV_FALSE
+#define MV_ETH_REGS_BASE(p)	MV_ETH_REGS_OFFSET(p)
+#define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
+#define MV_PNC_REG_BASE		MV_PNC_REGS_OFFSET
+#define MV_ETH_COMPLEX_BASE	(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE	(MV_ETH_ONLY_REGS_OFFSET)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0
+
+#ifdef CONFIG_MV_ETH_LEGACY
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED		0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT	1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB	2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW	3
+#endif
+
+#define ETHER_DRAM_COHER	MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR		"DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR		"DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR		"DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR		"DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ		0
+
+#define MV_ETH_RX_Q_NUM		CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM		CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL		200
+#define ETH_RX_COAL		200
+
+/* Checksum offloading */
+#define				TX_CSUM_OFFLOAD
+#define				RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff --git a/arch/arm/mach-msys/config/mvSysEthPhyConfig.h b/arch/arm/mach-msys/config/mvSysEthPhyConfig.h
new file mode 100644
index 0000000..ce9ff4a
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysEthPhyConfig.h
@@ -0,0 +1,31 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthPhyConfig.h - Marvell Ethernet-PHY specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
diff --git a/arch/arm/mach-msys/config/mvSysGppConfig.h b/arch/arm/mach-msys/config/mvSysGppConfig.h
new file mode 100644
index 0000000..7e37a90
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysGppConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysGppConfig.h - Marvell GPP unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for GPP registers.
+*/
+#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-msys/config/mvSysHwConfig.h b/arch/arm/mach-msys/config/mvSysHwConfig.h
new file mode 100644
index 0000000..b27d3c5
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysHwConfig.h
@@ -0,0 +1,241 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+#define CONFIG_MARVELL	1
+
+/* includes */
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+#ifdef CONFIG_DRAM_IO_RESERVE_BASE
+#define MV_DRAM_IO_RESERVE_BASE	CONFIG_DRAM_IO_RESERVE_BASE
+#endif
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX
+
+#ifdef CONFIG_MV_PEX_0_4X1
+#define MV_PEX_0_4X1		1
+#define MV_PEX_0_1X4		0
+#endif
+#ifdef CONFIG_MV_PEX_0_1X4
+#define MV_PEX_0_4X1		0
+#define MV_PEX_0_1X4		1
+#endif
+
+#endif /* CONFIG_MV_INCLUDE_PEX */
+
+#ifdef CONFIG_MV_INCLUDE_PCI
+#define MV_INCLUDE_PCI
+
+#define PCI_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PCI_HOST_DEV_NUM(pciIf)		0
+
+#define PEX_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PEX_HOST_DEV_NUM(pciIf)		0
+
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+#define MV_INCLUDE_XOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_NOR
+#define MV_INCLUDE_NOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_SDIO
+#define MV_INCLUDE_SDIO
+#endif
+#ifdef CONFIG_MTD_NAND_LNC_BOOT
+#define MTD_NAND_LNC_BOOT
+#endif
+#ifdef CONFIG_MTD_NAND_LNC
+#define MTD_NAND_LNC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+#define MTD_NAND_NFC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+#define MTD_NAND_NFC_GANG_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+#define MTD_NAND_NFC_MLC_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_NEGLECT_RNB
+#define MTD_NAND_NFC_NEGLECT_RNB
+#endif
+#ifdef CONFIG_MV_INCLUDE_PDMA
+#define MV_INCLUDE_PDMA
+#endif
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define AURORA_IO_CACHE_COHERENCY
+#endif
+
+
+#define MV_DFX_REG_READ(offset)						\
+	MV_MEMIO_LE32_READ(DFX_REGS_VIRT_BASE | (offset))
+
+#define MV_DFX_REG_WRITE(offset, val)					\
+{									\
+	MV_MEMIO_LE32_WRITE((DFX_REGS_VIRT_BASE | (offset)), (val));	\
+}
+
+#define MV_DFX_REG_BIT_SET(offset, bitMask)				\
+{									\
+	(MV_MEMIO_LE32_WRITE((DFX_REGS_VIRT_BASE | (offset)),		\
+	(MV_MEMIO_LE32_READ(DFX_REGS_VIRT_BASE | (offset)) |		\
+	MV_32BIT_LE_FAST(bitMask))));					\
+}
+
+#define MV_DFX_REG_BIT_RESET(offset, bitMask)				\
+{									\
+	(MV_MEMIO_LE32_WRITE((DFX_REGS_VIRT_BASE | (offset)),		\
+	(MV_MEMIO_LE32_READ(DFX_REGS_VIRT_BASE | (offset)) &		\
+	MV_32BIT_LE_FAST(~bitMask))));					\
+}
+
+/****************************************************************/
+/************* General    configuration ********************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Disable the DEVICE BAR in the PEX */
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+
+
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+
+/****************************************************************/
+/******************* LPAE configuration *************************/
+/****************************************************************/
+#ifdef CONFIG_ARM_LPAE
+#define ARM_LPAE_SUPPORT
+#endif
+/* We use the following registers to store DRAM interface pre configuration	*/
+/* auto-detection results							*/
+/* IMPORTANT: We are using mask register for that purpose. Before writing	*/
+/* to units mask register, make sure main maks register is set to disable	*/
+/* all interrupts.								*/
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Default FPGA Clock */
+#define MV_FPGA_CLK	25000000
+#endif /* __INCmvSysHwConfigh */
diff --git a/arch/arm/mach-msys/config/mvSysPciConfig.h b/arch/arm/mach-msys/config/mvSysPciConfig.h
new file mode 100644
index 0000000..116d683
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysPciConfig.h
@@ -0,0 +1,25 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PCI_IF_REGS_BASE(pciIf)	(MV_PEX_IF_REGS_OFFSET(pciIf))
diff --git a/arch/arm/mach-msys/config/mvSysPexConfig.h b/arch/arm/mach-msys/config/mvSysPexConfig.h
new file mode 100644
index 0000000..793d2e0
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysPexConfig.h
@@ -0,0 +1,49 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysPciIfConfig.h - Marvell PCI / Pex units specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PEX_IF_REGS_BASE(unit)	(MV_PEX_IF_REGS_OFFSET(unit))
+
+/* PEX Work arround */
+/* the target we will use for the workarround */
+#define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
+/*a flag that indicates if we are going to use the
+size and base of the target we using for the workarround
+window */
+#define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
+/* if the above flag is 0 then the following values
+will be used for the workarround window base and size,
+otherwise the following defines will be ignored */
+#define PEX_CONFIG_RW_WA_BASE 0xF3000000
+#define PEX_CONFIG_RW_WA_SIZE _16M
diff --git a/arch/arm/mach-msys/config/mvSysTwsiConfig.h b/arch/arm/mach-msys/config/mvSysTwsiConfig.h
new file mode 100644
index 0000000..21d00cb
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysTwsiConfig.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTwsiConfig.h - Marvell TWSI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+/*
+** Base address for TWSI registers.
+*/
+#define MV_TWSI_SLAVE_REGS_BASE(unit)	(MV_TWSI_SLAVE_REGS_OFFSET(unit))
+
+/*
+** Specific definition for Main CPU interrupt cause register.
+** Needed for TWSI operation completion monitoring.
+*/
+#define MV_TWSI_CPU_MAIN_INT_CAUSE(chNum, cpu)	TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)
diff --git a/arch/arm/mach-msys/config/mvSysXorConfig.h b/arch/arm/mach-msys/config/mvSysXorConfig.h
new file mode 100644
index 0000000..ae86fc6
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysXorConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysXorConfig.h - Marvell XOR unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for XOR registers.
+*/
+#define MV_XOR_REGS_BASE(unit)		(MV_XOR_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-msys/core.c b/arch/arm/mach-msys/core.c
new file mode 100644
index 0000000..61146f5
--- /dev/null
+++ b/arch/arm/mach-msys/core.c
@@ -0,0 +1,632 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/mbus.h>
+#include <asm/mach/time.h>
+#include <linux/clocksource.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <linux/memblock.h>
+#include <linux/ethtool.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <mach/system.h>
+
+#include <linux/etherdevice.h>
+#include <linux/tty.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <asm/serial.h>
+#include <plat/cache-aurora-l2.h>
+
+#include <mach/serial.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "sysmap.h"
+#include "irq.h"
+#include "time.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "plat/gpio.h"
+#include "cpu/mvCpu.h"
+#include "include/mach/irqs.h"
+
+/* I2C */
+#include <linux/i2c.h>
+#include <linux/mv643xx_i2c.h>
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+/* for debug putstr */
+static char arr[256];
+
+MV_U32 mvTclk = 166666667;
+MV_U32 mvSysclk = 200000000;
+
+static struct sys_timer msys_timer = {
+	.init = msys_timer_init,
+};
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define TARGET_DDR		0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC	0x1
+
+struct mbus_dram_target_info msys_mbus_dram_info;
+
+const struct mbus_dram_target_info *mv_mbus_dram_info(void)
+{
+	return &msys_mbus_dram_info;
+}
+
+
+
+/*********************************************************************************/
+/**************                 Early Printk Support                **************/
+/*********************************************************************************/
+#ifdef MV_INCLUDE_EARLY_PRINTK
+#define MV_UART0_LSR	(*(unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x00))
+#define MV_UART1_LSR	(*(unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR	(*(unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x00))
+#define MV_SERIAL_BASE	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0))
+#define DEV_REG		(*(unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG		(*(unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+
+	/* Get dev ID, make sure pex clk is on */
+	if ((CLK_REG & 0x4) == 0) {
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	} else
+		model = (DEV_REG >> 16) & 0xffff;
+
+	while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0)
+			;
+		MV_UART0_THR = *s;
+
+		if (*s == '\n') {
+			while ((MV_UART0_LSR & UART_LSR_THRE) == 0)
+				;
+			MV_UART0_THR = '\r';
+		}
+		s++;
+	}
+}
+
+void mv_early_printk(char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	vsprintf(arr, fmt, args);
+	va_end(args);
+	putstr(arr);
+}
+EXPORT_SYMBOL(mv_early_printk);
+#endif
+
+/*********************************************************************************/
+/**************               UBoot Tagging Parameters              **************/
+/*********************************************************************************/
+#ifdef CONFIG_BE8_ON_LE
+#define read_tag(a)	le32_to_cpu(a)
+#define read_mtu(a)	le16_to_cpu(a)
+#else
+#define read_tag(a)	a
+#define read_mtu(a)	a
+#endif
+
+static int __init parse_tag_mv_uboot(const struct tag *tag)
+{
+	unsigned int mvUbootVer = 0;
+
+	printk(KERN_INFO "Using UBoot passing parameters structure\n");
+	mvUbootVer = read_tag(tag->u.mv_uboot.uboot_version);
+
+	return 0;
+}
+
+__tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
+
+/*********************************************************************************/
+/**************                Command Line Parameters              **************/
+/*********************************************************************************/
+
+#ifdef CONFIG_CACHE_AURORA_L2
+static int noL2 = -1;
+static int __init noL2_setup(char *__unused)
+{
+	noL2 = 1;
+	return 1;
+}
+
+__setup("noL2", noL2_setup);
+#endif
+
+unsigned int l0_disable_flag = -1;		/* L0 Enabled by Default */
+static int __init l0_disable_setup(char *__unused)
+{
+	l0_disable_flag = 1;
+	return 1;
+}
+
+__setup("l0_disable", l0_disable_setup);
+
+unsigned int sp_enable_flag = -1;		/* SP Disabled by Default */
+static int __init spec_prefesth_setup(char *__unused)
+{
+	sp_enable_flag = 1;
+	return 1;
+}
+
+__setup("sp_enable", spec_prefesth_setup);
+
+	MV_U32 support_wait_for_interrupt = 0x1;
+
+void __init msys_setup_cpu_mbus(void)
+{
+	int i;
+	int cs;
+	u8	coherency_status = 0;
+	static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
+#endif
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	msys_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	for (i = 0, cs = 0; i < MAX_TARGETS; i++) {
+		struct mbus_dram_window *w;
+		if (!MV_TARGET_IS_DRAM(i))
+			continue;
+
+		if (addrWinMap[i].enable == MV_FALSE)
+			continue;
+
+		if (addrWinMap[i].addrWin.baseHigh)
+			/* > 4GB not mapped by IO's */
+			continue;
+
+		w = &msys_mbus_dram_info.cs[cs++];
+		w->cs_index = (addrWinMap[i].targetId - SDRAM_CS0);
+		w->mbus_attr = addrWinMap[i].attrib;
+		w->base = addrWinMap[i].addrWin.baseLow;
+		w->size = addrWinMap[i].addrWin.size;
+	}
+
+	msys_mbus_dram_info.num_cs = cs;
+}
+
+/*********************************************************************************/
+/**************               I/O Devices Platform Info             **************/
+/*********************************************************************************/
+/*************
+ * I2C(TWSI) *
+ *************/
+static struct mv64xxx_i2c_pdata msys_i2c_pdata = {
+	.freq_m		= 8, /* assumes 166 MHz TCLK */
+	.freq_n		= 3,
+	.timeout	= 1000, /* Default timeout of 1 second */
+};
+
+static struct resource msys_i2c_0_resources[] = {
+	{
+		.name   = "i2c base",
+		.start  = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0),
+		.end    = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0) + 0x20 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "i2c irq",
+		.start  = IRQ_AURORA_I2C0,
+		.end    = IRQ_AURORA_I2C0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device msys_i2c0 = {
+	.name           = MV64XXX_I2C_CTLR_NAME,
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(msys_i2c_0_resources),
+	.resource       = msys_i2c_0_resources,
+	.dev            = {
+		.platform_data = &msys_i2c_pdata,
+	},
+};
+
+void __init msys_i2c0_init(void)
+{
+	if (mvUnitMapIsMine(I2C0) == MV_TRUE)
+		platform_device_register(&msys_i2c0);
+}
+
+
+/**********
+ * UART-0 *
+ **********/
+static struct plat_serial8250_port aurora_uart0_data[] = {
+	{
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(0)),
+		.irq		= IRQ_AURORA_UART0,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(0) | 0x7C),
+		.type		= PORT_16550A,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource aurora_uart0_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART0,
+		.end		= IRQ_AURORA_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart0 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart0_data,
+	},
+	.resource		= aurora_uart0_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart0_resources),
+};
+
+/**********
+ * UART-1 *
+ **********/
+static struct plat_serial8250_port aurora_uart1_data[] = {
+	{
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(1)),
+		.irq		= IRQ_AURORA_UART1,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(1) | 0x7C),
+		.type		= PORT_16550A,
+		.regshift	= 2,
+		.uartclk	= 0,
+	}, {
+	},
+};
+
+static struct resource aurora_uart1_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART1,
+		.end		= IRQ_AURORA_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart1 = {
+	.name			= "serial8250",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart1_data,
+	},
+	.resource		= aurora_uart1_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart1_resources),
+};
+
+void __init serial_initialize(int port)
+{
+	if (port == 0) {
+		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART0);
+		}
+
+		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart0);
+	} else {
+		if (mvUnitMapIsMine(UART1) == MV_FALSE) {
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART1);
+		}
+
+		aurora_uart1_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart1);
+	}
+}
+
+
+/************
+ * GPIO
+ ***********/
+static struct platform_device mv_gpio = {
+	.name	= "mv_gpio",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static void __init mv_gpio_init(void)
+{
+	platform_device_register(&mv_gpio);
+}
+
+
+/*********************************************************************************/
+/**************                      Helper Routines                **************/
+/*********************************************************************************/
+void print_board_info(void)
+{
+	char name_buff[50];
+	printk(KERN_INFO "\n");
+	printk(KERN_INFO "  Marvell MSYS");
+
+	mvBoardNameGet(name_buff);
+	printk(KERN_INFO " %s Board - ", name_buff);
+
+	mvCtrlModelRevNameGet(name_buff);
+	printk(KERN_INFO " Soc: %s",  name_buff);
+#if defined(MV_CPU_LE)
+	printk(KERN_INFO " LE\n");
+#else
+	printk(KERN_INFO " BE\n");
+#endif
+	printk(KERN_INFO "  Detected Tclk %d, SysClk %d, FabricClk %d, PClk %d\n",
+		mvTclk, mvSysclk, mvCpuL2ClkGet(), mvCpuPclkGet());
+	printk(KERN_INFO "  LSP version: %s\n", LSP_VERSION);
+	printk(KERN_INFO"\n");
+}
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+static void io_coherency_init(void)
+{
+	MV_U32 reg;
+
+	/* set CIB read snoop command to ReadUnique */
+	reg = MV_REG_READ(MV_CIB_CTRL_CFG_REG);
+	reg &= ~(7 << 16);
+	reg |= (7 << 16);
+	MV_REG_WRITE(MV_CIB_CTRL_CFG_REG, reg);
+
+#ifndef CONFIG_SMP
+	/* enable CPUs in SMP group on Fabric coherency */
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CTRL_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CTRL_REG, reg);
+
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CFG_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CFG_REG, reg);
+#endif
+}
+#endif
+
+/* For DEBUGGING ONLY!!!  Do not leave references to these in a production kernel! */
+/* extern void printascii(const char *); */
+#ifdef CONFIG_DEBUG_LL
+static void check_cpu_mode(void)
+{
+	u32 cpu_id_code_ext;
+	int cpu_mode = 0;
+	asm ("mrc p15, 1, %0, c15, c12, 0" : "=r"(cpu_id_code_ext));
+
+	if (((cpu_id_code_ext >> 16) & 0xF) == 0x2)
+		cpu_mode = 6;
+	else if (((cpu_id_code_ext >> 16) & 0xF) == 0x3)
+		cpu_mode = 7;
+	else
+		pr_err("unknow cpu mode!!!\n");
+
+#ifdef CONFIG_DEBUGGER_MODE_V6
+	if (cpu_mode != 6) {
+		/* printascii("cpu mode (ARMv7) doesn't mach kernel configuration\n"); */
+		panic("cpu mode mismatch");
+	}
+#else
+#ifdef CONFIG_CPU_V7
+	if (cpu_mode != 7) {
+		/* printascii("cpu mode (ARMv6) doesn't mach kernel configuration\n"); */
+		panic("cpu mode mismatch");
+	}
+#endif
+#endif
+	printk(KERN_INFO "Aurora: Working in ARMv%d mode\n", cpu_mode);
+}
+#endif
+
+
+static void cpu_fabric_common_init(void)
+{
+	MV_U32	reg;
+
+#ifdef CONFIG_DEBUG_LL
+	check_cpu_mode();
+#endif
+
+	__asm("mrc p15, 1, %0, c15, c1, 0" : "=r" (reg));
+	if (1 == l0_disable_flag) {
+		printk(KERN_INFO "L0 cache Disabled\n");
+		reg |= (1 << 0);
+	} else {
+		printk(KERN_INFO "L0 cache Enabled\n");
+		reg &= ~(1 << 0);
+	}
+	__asm("mcr p15, 1, %0, c15, c1, 0" : : "r" (reg));
+
+	__asm("mrc p15, 1, %0, c15, c2, 0" : "=r" (reg));
+	if (1 == sp_enable_flag) {
+		printk(KERN_INFO "Speculative Prefetch Enabled\n");
+		reg &= ~(1 << 7);
+	} else {
+		printk(KERN_INFO "Speculative Prefetch Disabled\n");
+		reg |= (1 << 7);
+	}
+	__asm("mcr p15, 1, %0, c15, c2, 0" : : "r" (reg));
+
+#ifdef CONFIG_CACHE_AURORA_L2
+	if (-1 == noL2)
+		aurora_l2_init((void __iomem *)(INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET));
+#endif
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+	printk(KERN_INFO "Support IO coherency.\n");
+	io_coherency_init();
+#endif
+}
+
+#ifdef CONFIG_SUSPEND
+#define TRAINING_SPACE	(10*1024)
+
+void __init reserve_training_mem(void)
+{
+	int i;
+	MV_UNIT_WIN_INFO addr_win_map[MAX_TARGETS + 1];
+	phys_addr_t base;
+	phys_addr_t size = (phys_addr_t)(TRAINING_SPACE);
+
+	mvCtrlAddrWinMapBuild(addr_win_map, MAX_TARGETS + 1);
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (!MV_TARGET_IS_DRAM(i))
+			continue;
+
+		if (addr_win_map[i].enable == MV_FALSE)
+			continue;
+
+		base = 0;
+		base |=  addr_win_map[i].addrWin.baseLow;
+
+		pr_info("Reserving training memory: base=0x%p size=0x%x\n",
+				(void *)base, size);
+
+		memblock_reserve(base, size);
+	}
+}
+#endif
+
+/*****************************************************************************
+ * BC2 BOARD
+ ****************************************************************************/
+static void __init msys_bc2_rd_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if (mvCtrlEnvInit()) {
+		printk(KERN_ERR "Controller env initialization failed.\n");
+		return;
+	}
+
+	msys_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if (mvCpuIfInit(mv_sys_map())) {
+		printk(KERN_ERR "Cpu Interface initialization failed.\n");
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+#ifndef CONFIG_MV_UART_PORT
+	serial_initialize(0);
+#else
+	serial_initialize(CONFIG_MV_UART_PORT);
+#endif
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	return;
+}
+
+
+MACHINE_START(MSYS_BC2, "Marvell BC2 RD")
+	.atag_offset	= BOOT_PARAMS_OFFSET,
+	.map_io		= msys_map_io,
+	.init_irq	= msys_init_irq,
+	.timer		= &msys_timer,
+	.init_machine	= msys_bc2_rd_init,
+#ifdef CONFIG_SUSPEND
+	.reserve	= reserve_training_mem,
+#endif /* CONFIG_SUSPEND */
+MACHINE_END
diff --git a/arch/arm/mach-msys/dump_cp15_regs.c b/arch/arm/mach-msys/dump_cp15_regs.c
new file mode 100644
index 0000000..64fb467
--- /dev/null
+++ b/arch/arm/mach-msys/dump_cp15_regs.c
@@ -0,0 +1,237 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+static int
+proc_dump_cp15_read(char *page, char **start, off_t off, int count, int *eof,
+			void *data)
+{
+	char *p = page;
+	int len;
+	unsigned int value;
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 0" : "=r"(value));
+	p += sprintf(p, "Main ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 1" : "=r"(value));
+	p += sprintf(p, "Cache Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 2" : "=r"(value));
+	p += sprintf(p, "TCM Type: 0x%08x\n", value);
+#endif
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3" : "=r"(value));
+	p += sprintf(p, "TLB Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 5" : "=r"(value));
+	p += sprintf(p, "Microprocessor ID: 0x%08x\n", value);
+#endif
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0" : "=r"(value));
+	p += sprintf(p, "Processor Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 1" : "=r"(value));
+	p += sprintf(p, "Processor Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 2" : "=r"(value));
+	p += sprintf(p, "Debug Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 3" : "=r"(value));
+	p += sprintf(p, "Auxiliary Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 4" : "=r"(value));
+	p += sprintf(p, "Memory Model Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 5" : "=r"(value));
+	p += sprintf(p, "Memory Model Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 6" : "=r"(value));
+	p += sprintf(p, "Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7" : "=r"(value));
+	p += sprintf(p, "Memory Model Feature 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 0" : "=r"(value));
+	p += sprintf(p, "Set Attribute 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 1" : "=r"(value));
+	p += sprintf(p, "Set Attribute 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 2" : "=r"(value));
+	p += sprintf(p, "Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3" : "=r"(value));
+	p += sprintf(p, "Set Attribute 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 4" : "=r"(value));
+	p += sprintf(p, "Set Attribute 4: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 5" : "=r"(value));
+	p += sprintf(p, "Set Attribute 5: 0x%08x\n", value);
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 1, %0, c0, c0, 0" : "=r"(value));
+	p += sprintf(p, "Current Cache Size ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 1" : "=r"(value));
+	p += sprintf(p, "Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 7" : "=r"(value));
+	p += sprintf(p, "Silicon ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0" : "=r"(value));
+	p += sprintf(p, "Cache Size Selection: 0x%08x\n", value);
+
+#endif
+	asm volatile("mrc p15, 0, %0, c1, c0, 0" : "=r"(value));
+	p += sprintf(p, "Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1" : "=r"(value));
+	p += sprintf(p, "Auxiliary Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2" : "=r"(value));
+	p += sprintf(p, "Coprocessor Access Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 0" : "=r"(value));
+	p += sprintf(p, "Secure Configuration : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(value));
+	p += sprintf(p, "Translation Table Base 0 : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 1" : "=r"(value));
+	p += sprintf(p, "Translation Table Base 1 : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 2" : "=r"(value));
+	p += sprintf(p, "Translation Table Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(value));
+	p += sprintf(p, "Domain Access Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(value));
+	p += sprintf(p, "Data Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1" : "=r"(value));
+	p += sprintf(p, "Instruction Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(value));
+	p += sprintf(p, "Data Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 1" : "=r"(value));
+	p += sprintf(p, "Watchpoint Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2" : "=r"(value));
+	p += sprintf(p, "Instruction Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c7, c10, 6" : "=r"(value));
+	p += sprintf(p, "Cache Dirty Status: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 0" : "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 1" : "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 0" : "=r"(value));
+	p += sprintf(p, "Control Configuration: 0x%08x\n", value);
+	p += sprintf(p, "    Write Buffer Coalescing\t: %s\n", (value & (1 << 8)) ?
+		     "Enabled" : "Disabled");
+	if (value & (1 << 8))
+		p += sprintf(p, "    WB WAIT CYC\t: 0x%x\n", (value >> 9) & 0x7);
+
+	p += sprintf(p, "    Coprocessor dual issue \t: %s\n", (value & (1 << 15)) ?
+		     "Disabled" : "Enabled");
+
+	p += sprintf(p, "    L2 write allocate\t: %s\n", (value & (1 << 28)) ?
+		     "Enabled" : "Disabled");
+
+	p += sprintf(p, "    Streaming\t: %s\n", (value & (1 << 29)) ?
+		     "Enabled" : "Disabled");
+
+	asm volatile("mrc p15, 1, %0, c15, c12, 0" : "=r"(value));
+	p += sprintf(p, "CPU ID Code Extension: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 0" : "=r"(value));
+	p += sprintf(p, "User mode access for PMC registers: %s\n", (value & 1) ?
+		     "Enabled" : "Disabled");
+	asm volatile("mrc p15, 0, %0, c10, c2, 0" : "=r"(value));
+	p += sprintf(p, "Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1" : "=r"(value));
+	p += sprintf(p, "Memory Attribute NMRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 2" : "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 0" : "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 1" : "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 1: 0x%08x\n", value);
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+int dump_init_module(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	res = create_proc_entry("mv_dump_cp15", S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+
+	res->read_proc = proc_dump_cp15_read;
+#endif
+
+	return 0;
+}
+
+void dump_cleanup_module(void)
+{
+	remove_proc_entry("mv_dump_cp15", NULL);
+}
+
+module_init(dump_init_module);
+module_exit(dump_cleanup_module);
+
+MODULE_AUTHOR("Saeed Bishara");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msys/flashmap.c b/arch/arm/mach-msys/flashmap.c
new file mode 100644
index 0000000..5d7ce00
--- /dev/null
+++ b/arch/arm/mach-msys/flashmap.c
@@ -0,0 +1,263 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <drivers/mtd/mtdcore.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+#define MTD_FLASH_MAP_DEBUG
+
+#ifdef MTD_FLASH_MAP_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+#define MTD_MAX_FLASH_NUMBER	4
+#define MTD_DUMMY_BANK_WIDTH	2
+
+struct maps_init_info {
+	struct map_info mapInfo;
+	char **mtdDrv;
+	struct mtd_info *mtdInfo;
+	char name[32];
+};
+
+static struct maps_init_info maps[MTD_MAX_FLASH_NUMBER];
+static unsigned int mapsNum = -1;
+
+#if defined(CONFIG_MTD_CFI) || defined(CONFIG_MTD_JEDECPROBE)
+static char *cfiDev = "cfi_flash";
+static char *cfiMtdList[] = { "cfi_probe", NULL };
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+static char *sflashDev = "spi_flash";
+static char *sflashMtdList[] = {"sflash", NULL};
+#endif
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static struct mtd_partition	*mtd_parts;
+static int			mtd_parts_nb;
+static const char *part_probes[] __initdata = {"cmdlinepart", NULL};
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+static int flashInfoFill(void)
+{
+	int expectedDevs = 0;
+	int devs, i;
+
+	/* clear the whole array */
+	memset((void *)maps, 0x0, sizeof(maps));
+
+#if defined(CONFIG_MTD_CFI) || defined(CONFIG_MTD_JEDECPROBE)
+	/* gather the CFI and JEDEC NOR flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_NOR_FLASH);
+
+	for (i = 0; i < devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __func__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = cfiMtdList;
+		sprintf(maps[expectedDevs].name, "%s_%d", cfiDev, i);
+		maps[expectedDevs].mapInfo.name = maps[expectedDevs].name;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = (mvBoardGetDeviceBusWidth(i, BOARD_DEV_NOR_FLASH) / 8);
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d",
+				maps[expectedDevs].mapInfo.name, i,
+				(unsigned int)maps[expectedDevs].mapInfo.phys,
+				(unsigned int)maps[expectedDevs].mapInfo.size,
+				maps[expectedDevs].mapInfo.bankwidth));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+				__func__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+	/* gather the SPI flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_SPI_FLASH);
+
+	for (i = 0; i < devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __func__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = sflashMtdList;
+		maps[expectedDevs].mapInfo.name = sflashDev;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = MTD_DUMMY_BANK_WIDTH;
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+						(unsigned int)maps[expectedDevs].mapInfo.phys,
+						(unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+					__func__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+	DB(printk("\nINFO: %s - Found %d Flash Devices", __func__, expectedDevs));
+	return expectedDevs;
+}
+
+static int __init flashProbe(char **mtdDrv, struct map_info *map, struct mtd_info **mtd)
+{
+	if ((mtdDrv == NULL) || (map == NULL) || (mtd == NULL)) {
+		printk(KERN_NOTICE "\nERROR: NULL pointer parameter at %s entry", __func__);
+		return -EINVAL;
+	}
+
+	/* remap the physical address to a virtual address */
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt) {
+		printk(KERN_NOTICE "\nERROR: Failed to ioremap Flash device at physical base 0x%x.",
+			(unsigned int)map->phys);
+		return -EIO;
+	}
+
+	DB(printk("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+		(unsigned int)map->phys, (unsigned int)map->virt));
+
+	simple_map_init(map);
+
+	*mtd = NULL;
+	for (; (!(*mtd) && *mtdDrv); mtdDrv++) {
+		DB(printk("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+				*mtdDrv, map->name, (unsigned int)map->phys,
+				(unsigned int)map->size, map->bankwidth));
+
+		*mtd = do_map_probe(*mtdDrv, map)
+		if (*mtd) {
+			DB(printk(" - detected OK"));
+			/*map->size = (*mtd)->size;*/
+			(*mtd)->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0);
+
+			if (mtd_parts_nb > 0) {
+				add_mtd_partitions(*mtd, mtd_parts, mtd_parts_nb);
+				return 0;
+			}
+#endif
+
+			if (mtd_device_register(*mtd, NULL, 0)) {
+				printk(KERN_NOTICE "\nERROR: %s - Failed to add the mtd device", __func__);
+				iounmap((void *)map->virt);
+				map->virt = 0;
+				return -ENXIO;
+			}
+			return 0;
+		} else {
+			DB(printk(KERN_DEBUG" - Not detected"));
+		}
+	}
+
+	iounmap((void *)map->virt);
+	map->virt = 0;
+	return -ENXIO;
+}
+
+static int __init flash_map_init(void)
+{
+	int i;
+
+	if (mvUnitMapIsMine(SPI) == MV_FALSE)
+		return 0;
+
+	mapsNum = flashInfoFill();
+	DB(printk(KERN_DEBUG "\nINFO: flash_map_init - detected %d devices\n",  mapsNum));
+
+	for (i = 0; i < mapsNum; i++) {
+		DB(printk(KERN_DEBUG "MTD: Initialize the %s device at address 0x%08x\n",
+			maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
+		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0) {
+			DB(printk(KERN_DEBUG" - OK.\n"));
+		} else {
+			maps[i].mtdInfo = NULL;
+			DB(printk(KERN_DEBUG" - FAILED!\n"));
+		}
+	}
+
+	return 0;
+}
+
+static void __exit flash_map_exit(void)
+{
+	int i;
+
+	if (-1 == mapsNum)
+		return;
+
+	for (i = 0; i < mapsNum; i++) {
+		if (maps[i].mtdInfo) {
+			mtd_device_unregister(maps[i].mtdInfo);
+			map_destroy(maps[i].mtdInfo);
+		}
+
+		if (maps[i].mapInfo.virt) {
+			iounmap((void *)maps[i].mapInfo.virt);
+			maps[i].mapInfo.virt = 0;
+		}
+	}
+}
+
+module_init(flash_map_init);
+module_exit(flash_map_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for Marvell platforms");
diff --git a/arch/arm/mach-msys/headsmp.S b/arch/arm/mach-msys/headsmp.S
new file mode 100644
index 0000000..b8eb3de
--- /dev/null
+++ b/arch/arm/mach-msys/headsmp.S
@@ -0,0 +1,110 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/memory.h>
+#include <mach/hardware.h>
+
+
+#define MSYS_COHERENCY_FABRIC_CTL_REG (INTER_REGS_PHYS_BASE + 0x20200)
+#define MSYS_COHERENCY_FABRIC_CFG_REG (INTER_REGS_PHYS_BASE + 0x20204)
+
+/*
+ * specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(msys_secondary_startup)
+
+#ifdef CONFIG_CPU_ENDIAN_BE32
+        /* convert CPU to big endian */
+        .word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
+        .word 0x800080e3 /* orr r0, r0, #0x80 */
+        .word 0x100f01ee /* mcr p15, 0, r0, c1, c0 */
+#endif
+#ifdef CONFIG_BE8_ON_LE
+        setend  be
+#endif
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+
+	/* Add CPU to coherency fabric */
+	/* Create bit by cpu index */
+	mov     r2,r0
+	add     r2,r2,#24
+	MOV     r3, #1
+	lsl     r3, r3, r2
+
+	/* Add CPU to SMP group - Atomic */
+	ldr     r0, = MSYS_COHERENCY_FABRIC_CTL_REG
+	ldr     r10, [r0]
+	orr     r10 , r10, r3
+	str	r10,[r0]
+
+	/* Enable coherency on CPU - Atomic*/
+	ldr     r0, = MSYS_COHERENCY_FABRIC_CFG_REG
+	ldr     r10, [r0]
+	orr     r10 , r10, r3
+	str     r10,[r0]
+
+	/*
+	 * Disable L0 on secondary CPU if flag set
+	 */
+	adr	r7, l0_disable_flag_addr
+	ldr	r7, [r7]
+	sub	r7, r7, #(PAGE_OFFSET - PLAT_PHYS_OFFSET)
+	ldr	r7, [r7]
+	cmp	r7, #0
+	beq	l0_dis_skip
+	mrc	p15, 1, r7, c15, c1, 0
+	orr	r7, r7, #0x1
+	mcr	p15, 1, r7, c15, c1, 0
+l0_dis_skip:
+	/*
+	 * Speculative prefetch on secondary CPU if flag set
+	 * Auxiliary Functional Modes Control 0 Register
+	 * Bit[7]: 0-Enable, 1-Disable (reset default)
+	 */
+	adr	r7, sp_enable_flag_addr
+	ldr	r7, [r7]
+	sub	r7, r7, #(PAGE_OFFSET - PLAT_PHYS_OFFSET)
+	ldr	r7, [r7]
+	cmp	r7, #0
+	beq	sp_ena_skip
+	mrc	p15, 1, r7, c15, c2, 0
+	bic	r7, r7, #(1 << 7)
+	mcr	p15, 1, r7, c15, c2, 0
+
+sp_ena_skip:
+	b	secondary_startup
+
+l0_disable_flag_addr:
+	.word	l0_disable_flag
+
+sp_enable_flag_addr:
+	.word	sp_enable_flag
diff --git a/arch/arm/mach-msys/include/mach/clkdev.h b/arch/arm/mach-msys/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-msys/include/mach/debug-macro.S b/arch/arm/mach-msys/include/mach/debug-macro.S
new file mode 100644
index 0000000..937e302
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/debug-macro.S
@@ -0,0 +1,24 @@
+/*
+ * debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <mach/msys.h>
+
+
+	.macro  addruart, rp, rv, tmp
+	ldr     \rp, =INTER_REGS_PHYS_BASE
+	ldr	\rv, =INTER_REGS_BASE
+	orr     \rp, \rp, #0x00012000
+        orr     \rv, \rv, #0x00012000
+#ifdef CONFIG_MV_UART_PORT
+	orr     \rp, \rp, #0x100 * CONFIG_MV_UART_PORT
+        orr     \rv, \rv, #0x100 * CONFIG_MV_UART_PORT
+#endif
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-msys/include/mach/entry-macro.S b/arch/arm/mach-msys/include/mach/entry-macro.S
new file mode 100644
index 0000000..c887815
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/entry-macro.S
@@ -0,0 +1,189 @@
+/*
+ * include/asm-arm/arch-mv78xx0/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell MV78xx0 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/msys.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =MSYS_IRQ_VIRT_BASE
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+#ifndef CONFIG_MSYS_USE_IRQ_INTERRUPT_ACK
+
+#if defined(CONFIG_CPU_BIG_ENDIAN)
+		.macro	HTOLL sr, tt		@ sr   = A  ,B  ,C  ,D
+		rev \sr, \sr
+		.endm
+#else
+		.macro	HTOLL sr, tt
+		.endm
+#endif
+	/* TBD - need to be optimized 29*(sel-1) + cls 						*/
+	/* r1 - we shouldnt use it here 							*/
+	/* in case of SMP we only handle bit 0,1 (doorbell) and 5,6 (timer) from cause Vec 0 	*/
+	/* return value is: irqnr and the flag state!!!!!!!!!!!!				*/
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #MSYS_IRQ_SEL_CAUSE_OFF]
+	HTOLL	\irqstat, \tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1001f
+	mov 	\tmp, \irqstat
+
+	mov 	\tmp, \tmp, lsr #29 			@ determine the irq group,
+	bics	\tmp, \tmp, #4 	 			@ clear irq_stat bit
+
+#ifdef CONFIG_SMP
+	@ if vec sel is 0 and bits 0-4 are set then it is IPI timer handled seperatly.
+	bne	1000f
+	ands	\tmp, \irqstat, #0x5
+	beq 	1000f
+
+	@restore tmp - should be optimized!!!!
+        mov     \tmp, \irqstat
+
+        mov     \tmp, \tmp, lsr #29                     @ determine the irq group,
+        bics    \tmp, \tmp, #4                          @ clear irq_stat bit
+	beq	1001f
+
+#endif
+1000:
+	bic	\irqstat, \irqstat, #(0xE0000000) 	@ leave irq bits, clear the rest
+	mov    	\irqnr, #0x1F
+	orrs    \irqnr, \irqnr, \tmp, lsl #5    	@ irqnr = 0x1F, 0x3F, 0x5F, 0x7f, make sure Z is off
+	clz	\irqstat, \irqstat	              	@ find first active interrupt source
+	sub	\irqnr, \irqnr, \irqstat
+	mov 	r1, #3
+	mul	\tmp, r1, \tmp
+	sub 	\irqnr, \irqnr, \tmp
+1001:
+	.endm
+
+
+        /* We assume that irqstat (the raw value of the IRQ acknowledge
+         * register) is preserved from the macro above.
+         */
+
+	.macro test_for_ipi, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1002f
+	ands 	\tmp, \irqstat, #0x00000001		@ was it doorbell
+	beq	1002f
+	ldr	\irqnr, [\base, #MSYS_IN_DOORBELL_CAUSE]
+	HTOLL	\irqnr, \tmp
+	ands    \irqnr, \irqnr, #0xFF		@ 8 lower doorbells are considered IPI
+	beq     1002f
+	clz	\irqnr, \irqnr
+	mov	\tmp, #31
+	sub	\irqnr, \tmp, \irqnr
+	mov     \tmp, #1
+	lsl     \tmp, \irqnr
+	HTOLL 	\tmp, \tmp
+	mvn     \tmp, \tmp
+	str   	\tmp, [\base, #MSYS_IN_DOORBELL_CAUSE]	@ clean irq
+1002:
+	.endm
+
+
+	/* As above, this assumes that irqstat and base are preserved.. */
+
+	.macro test_for_ltirq, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1003f
+	ands 	\tmp, \irqstat, #0x00000060		@ was it timer
+1003:
+	.endm
+
+	.macro test_for_ipc, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1006f
+	ands 	\tmp, \irqstat, #0x00000001		@ was it doorbell
+	beq	1006f
+	ldr	\irqnr, [\base, #MSYS_IN_DOORBELL_CAUSE]
+	HTOLL	\irqnr, \tmp
+	ands    \irqnr, \irqnr, #0xF000		@ 12-15 doorbells are considered IPC
+	beq     1006f
+	clz	\irqnr, \irqnr
+	mov	\tmp, #31
+	sub	\irqnr, \tmp, \irqnr
+	mov 	\tmp, #1
+	lsl	\tmp, \irqnr
+	mvn	\tmp, \tmp
+	strh   	\tmp, [\base, #MSYS_IN_DOORBELL_CAUSE]	@ clean irq
+1006:
+	.endm
+
+#else /* CONFIG_MSYS_USE_IRQ_INTERRUPT_ACK */
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.
+		 *
+		 * Interrupts 0-2 are IPI
+		 * 0-31 are local.
+		 * 32-1022 are global
+		 * 1023 is "spurious" (no interrupt)
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \irqstat, [\base, #MSYS_CPU_INTACK]
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+#ifdef CONFIG_SMP
+		cmp     \irqnr, #7
+		cmpcc	\irqnr, \irqnr
+		cmpne	\irqnr, \tmp
+		cmpcs	\irqnr, \irqnr
+#else
+		cmp     \irqnr, \tmp
+#endif
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		cmp	\irqnr, #3
+		movcc	\tmp, #0
+		strcc	\tmp, [\base, #MSYS_IN_DOORBELL_CAUSE]   @ clean ipi irq
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		mov	\tmp, #0
+		cmp	\irqnr, #5
+		moveq   \tmp, #1
+		cmp     \tmp, #0
+		.endm
+
+		.macro test_for_ipc, irqnr, irqstat, base, tmp @ YY - check this one again
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		cmp	\irqnr, #3
+		movcc	\tmp, #0
+		strcc	\tmp, [\base, #MSYS_IN_DOORBELL_CAUSE]   @ clean ipi irq
+		cmpcs	\irqnr, \irqnr
+		.endm
+#endif
diff --git a/arch/arm/mach-msys/include/mach/gpio.h b/arch/arm/mach-msys/include/mach/gpio.h
new file mode 100644
index 0000000..7ca789d
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * include/asm-arm/arch-dove/gpio.h
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/errno.h>
+#include <mach/irqs.h>
+#include <plat/gpio.h>
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+
+#define GPIO_MAX	64
+
+#define GPIO_BASE_LO		(AURORA_GPIO_VIRT_BASE + 0x00)
+#define GPIO_BASE_HI		(AURORA_GPIO_VIRT_BASE + 0x20)
+
+#define GPIO_BASE(pin)		((pin < 32) ? GPIO_BASE_LO : GPIO_BASE_HI)
+
+#define GPIO_OUT(pin)		(GPIO_BASE(pin) + 0x00)
+#define GPIO_IO_CONF(pin)	(GPIO_BASE(pin) + 0x04)
+#define GPIO_BLINK_EN(pin)	(GPIO_BASE(pin) + 0x08)
+#define GPIO_IN_POL(pin)	(GPIO_BASE(pin) + 0x0c)
+#define GPIO_DATA_IN(pin)	(GPIO_BASE(pin) + 0x10)
+#define GPIO_EDGE_CAUSE(pin)	(GPIO_BASE(pin) + 0x14)
+#define GPIO_EDGE_MASK(pin)	(GPIO_BASE(pin) + 0x18)
+#define GPIO_LEVEL_MASK(pin)	(GPIO_BASE(pin) + 0x1c)
+
+static inline int gpio_to_irq(int pin)
+{
+	if (pin < NR_GPIO_IRQS)
+		return pin + IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+static inline int irq_to_gpio(int irq)
+{
+	if (IRQ_AURORA_GPIO_START < irq && irq < NR_IRQS)
+		return irq - IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+#endif
diff --git a/arch/arm/mach-msys/include/mach/hardware.h b/arch/arm/mach-msys/include/mach/hardware.h
new file mode 100644
index 0000000..05da59a
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * include/mach/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "msys.h"
+
+#endif
diff --git a/arch/arm/mach-msys/include/mach/io.h b/arch/arm/mach-msys/include/mach/io.h
new file mode 100644
index 0000000..dbdaa69
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/io.h
@@ -0,0 +1,30 @@
+/*
+ * include/asm-arm/arch-dove/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "msys.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define IO_SPACE_REMAP		PEX0_IO_PHYS_BASE
+
+#define __io(a)			((a) + PEX0_IO_VIRT_BASE)
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(a)
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define dma_io_sync()	do {				\
+	writel(0x1, MSYS_CPU_IO_SYNC_BARRIER_CTRL_REG);		\
+	while (readl(MSYS_CPU_IO_SYNC_BARRIER_CTRL_REG) & 0x1)	\
+		;					\
+} while (0)
+#else
+#define dma_io_sync()	do { } while (0)
+#endif
+#endif
diff --git a/arch/arm/mach-msys/include/mach/irqs.h b/arch/arm/mach-msys/include/mach/irqs.h
new file mode 100644
index 0000000..0ab3ba6
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/irqs.h
@@ -0,0 +1,182 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __MACH_MSYS_IRQS_H
+#define __MACH_MSYS_IRQS_H
+
+/*
+ * Aurora Low Interrupt Controller
+ */
+
+#define IRQ_AURORA_IN_DRBL_LOW		0
+#define IRQ_AURORA_IN_DRBL_HIGH		1
+#define IRQ_AURORA_OUT_DRBL		2
+#define IRQ_AURORA_MP			3
+#define IRQ_AURORA_SOC_ERROR		4
+#define IRQ_AURORA_TIMER0		5
+#define IRQ_AURORA_TIMER1		6
+#define IRQ_LOCALTIMER			IRQ_AURORA_TIMER0
+#define IRQ_AURORA_WD			7
+
+#define IRQ_AURORA_GBE0_FIC		8
+#define IRQ_AURORA_GBE0_SIC		9
+#define IRQ_AURORA_GBE1_FIC		10
+#define IRQ_AURORA_GBE1_SIC		11
+
+/* 12..15 reserved */
+
+#define IRQ_AURORA_CPU_GPIO_0_7		16
+#define IRQ_AURORA_CPU_GPIO_8_15	17
+#define IRQ_AURORA_CPU_GPIO_16_23	18
+#define IRQ_AURORA_CPU_GPIO_24_31	19
+#define IRQ_AURORA_CPU_GPIO_32_33	20
+
+/* 21..24 reserved */
+
+#define IRQ_AURORA_SCNT0		25
+#define IRQ_AURORA_SCNT1		26
+
+/* 27 reserved */
+
+#define IRQ_AURORA_VCNT			28
+
+/* 29 reserved */
+
+#define IRQ_AURORA_SPI			30
+#define IRQ_AURORA_I2C0			31
+#define IRQ_AURORA_I2C1			32
+
+#define IRQ_AURORA_SW_CORE0		33
+#define IRQ_AURORA_SW_CORE1		34
+#define IRQ_AURORA_SW_CORE2		35
+
+/* 36 reserved */
+
+#define IRQ_AURORA_GLOB_TIMER0		37
+#define IRQ_AURORA_GLOB_TIMER1		38
+#define IRQ_AURORA_GLOB_TIMER2		39
+#define IRQ_AURORA_GLOB_TIMER3		40
+
+#define IRQ_AURORA_UART0		41
+#define IRQ_AURORA_UART1		42
+
+/* 43..50 reserved */
+
+#define IRQ_AURORA_XOR00		51
+#define IRQ_AURORA_XOR01		52
+
+/* 53 reserved */
+
+#define IRQ_AURORA_SDIO			54
+
+/* 55..57 reserved */
+
+#define IRQ_AURORA_PCIE			58
+
+/* 59..65 reserved */
+
+#define IRQ_AURORA_GBE0			66
+#define IRQ_AURORA_GBE0_RX		67
+#define IRQ_AURORA_GBE0_TX		68
+#define IRQ_AURORA_GBE0_MISC		69
+#define IRQ_AURORA_GBE1			70
+#define IRQ_AURORA_GBE1_RX		71
+#define IRQ_AURORA_GBE1_TX		72
+#define IRQ_AURORA_GBE1_MISC		73
+
+/* 74..81 reserved */
+
+#define IRQ_AURORA_GPIO_0_7		82
+#define IRQ_AURORA_GPIO_8_15		83
+#define IRQ_AURORA_GPIO_16_23		84
+#define IRQ_AURORA_GPIO_24_31		85
+/* 86 reserved */
+#define IRQ_AURORA_GPIO_32_33		87
+
+/* 88..92 reserved */
+
+#define IRQ_AURORA_GLOBAL_WD		93
+
+/* 94..95 reserved */
+
+#define IRQ_AURORA_SHARE_INB_DB0	96
+#define IRQ_AURORA_SHARE_INB_DB1	97
+#define IRQ_AURORA_SHARE_INB_DB2	98
+
+#define IRQ_AURORA_DFX_SRV		99
+
+/* 100..107 reserved */
+
+#define IRQ_AURORA_DRAM			108
+
+#define IRQ_AURORA_NET_WKUP0		109
+#define IRQ_AURORA_NET_WKUP1		110
+
+/* 111..112 reserved */
+
+#define IRQ_GLOBAL_NAND			113
+
+#define IRQ_AURORA_MTL_FIX		114
+
+/* 115 reserved */
+
+#define IRQ_MAIN_INTS_NUM		116
+
+#define MAX_PER_CPU_IRQ_NUMBER		7
+
+/*
+ * AURORA General Purpose Pins
+ */
+#define IRQ_AURORA_GPIO_START		128
+#define NR_GPIO_IRQS			34
+
+/*
+ * AURORA MSI interrupts
+ */
+#define NR_PRIVATE_MSI_GROUP		16
+#define NR_PRIVATE_MSI_IRQS		NR_PRIVATE_MSI_GROUP
+#define NR_MSI_IRQS			NR_PRIVATE_MSI_IRQS
+#define IRQ_AURORA_MSI_START		(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)
+#define NR_IRQS				(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS + NR_MSI_IRQS)
+#define GPP_IRQ_TYPE_LEVEL		0
+#define GPP_IRQ_TYPE_CHANGE_LEVEL	1
+
+/*
+ * Aurora Error interrupts
+ */
+
+#define INT_ERR_DEVBUS			1
+
+/*
+ * IRQ HAL remapping
+ */
+#define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_AURORA_GBE0_FIC + ((x) * 2))
+
+/* Performance Monitor IRQ */
+#define IRQ_PERF_MONITOR		IRQ_AURORA_MP
+
+#endif /*__MACH_MSYS_IRQS_H*/
diff --git a/arch/arm/mach-msys/include/mach/kw_macro.h b/arch/arm/mach-msys/include/mach/kw_macro.h
new file mode 100644
index 0000000..41e5fa3
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/kw_macro.h
@@ -0,0 +1,39 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Assembler-only file
+ */
+
+
+support_wait_for_interrupt_address:
+	.word	support_wait_for_interrupt
+
+/* rd, rs, rt, re - are temp registers that will b used (non are input/output) */
+.macro mv_flush_all, rd, rs, rt, re
+	mov	\re, #0
+
+	mov	\rd, #(4 - 1) << 30		@ 4 way cache
+	mov	\rs, #(256 * CACHE_DLINESIZE)
+
+1 :	orr	\rt, \re, \rd
+2 :	mcr	p15, 0, \rt, c7, c14, 2		@ clean & invalidate D index
+	subs	\rt, \rt, #1 << 30
+	bcs	2b				@ entries 3 to 0
+	add	\re, \re, #32
+	cmp	\re, \rs
+	bne	1b
+
+/* exit */
+	.endm
diff --git a/arch/arm/mach-msys/include/mach/memory.h b/arch/arm/mach-msys/include/mach/memory.h
new file mode 100644
index 0000000..f69fd6d
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/memory.h
@@ -0,0 +1,26 @@
+/*
+ * include/asm-arm/arch-mv78xx0/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#ifdef CONFIG_MV_DRAM_BASE
+#define PLAT_PHYS_OFFSET		UL(CONFIG_MV_DRAM_BASE)
+#else
+#define PLAT_PHYS_OFFSET		UL(0x00000000)
+#endif
+
+#define BOOT_PARAMS_OFFSET	(PLAT_PHYS_OFFSET + 0x100)
+
+/* Override the ARM default */
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS	35
+#define SECTION_SIZE_BITS	29
+#endif
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define arch_is_coherent()	1
+#endif
+
+#endif /* __ASM_ARCH_MEMORY_H */
diff --git a/arch/arm/mach-msys/include/mach/msys.h b/arch/arm/mach-msys/include/mach/msys.h
new file mode 100644
index 0000000..a29e804
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/msys.h
@@ -0,0 +1,229 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#ifndef __MACH_MSYS_H
+#define __MACH_MSYS_H
+
+/****************************************************************/
+/******************* System Address Mapping *********************/
+/****************************************************************/
+
+/* The base address of memory that should be reserved for IO windows.
+** The reserved end address is 0xFFFFFFFF.
+*/
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xF0000000ll
+
+/*
+ * MSYS address maps.
+ * Virtual Addresses should be between  0xFAB00000 and 0xFF100000  (70MB)
+ * Physical Addresses should be between 0xF0000000 and 0xFFFFFFFF (255MB)
+ * If a larger physical address space is needed, then the amount of DRAM
+ * available for Linux will be smaller.
+ *
+ * phys		virt		size
+ * e0000000	@runtime	128M	PCIe-0 Memory space
+ * f0000000	fab00000	16M	SPI-CS0 (Flash)
+ * f1000000	fb000000	 1M	Internal Registers
+ * f1100000	fb100000	 1M	DFX Internal Registers
+ * f1200000	fb200000	 1M	DMA based UART
+ * f1300000	fb300000	 1M	PCIe-0 I/O space
+ * f2000000			 2M	PCIe-0 MEM space
+ * f2200000			 1M	Device-CS1 (NOR Flash)
+ * f2300000			 1M	Device-CS2 (NOR Flash)
+ * f2400000			 1M	Device-CS3 (NOR Flash)
+ * f4000000			32M	Boot-Device CS (NOR Flash)
+ * fff00000	ff000000	 1M	BootROM
+ */
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE			0x00000000
+#define SDRAM_CS0_SIZE			_256M
+#define SDRAM_CS1_BASE			0x10000000
+#define SDRAM_CS1_SIZE			_256M
+#define SDRAM_CS2_BASE			0x20000000
+#define SDRAM_CS2_SIZE			_256M
+#define SDRAM_CS3_BASE			0x30000000
+#define SDRAM_CS3_SIZE			_256M
+
+
+/* First, we place the "static" windows (that has less chance to have a size
+ * change), then all the "dynamic" windows (the ones that might need different
+ * sizes depending on the system configuration - SPI flash size, PEX cards...).
+ */
+
+/*
+ * Internal registers.
+ * PHYS: 0xF1000000 - 0xF1100000
+ * VIRT: 0xFB000000 - 0xFB100000
+ * INTER_REGS_VIRT_BASE Must be 2MB aligned in order to support CONFIG_DEBUG_LL.
+ */
+#define INTER_REGS_PHYS_BASE		0xF1000000
+#define INTER_REGS_VIRT_BASE		0xFB000000
+#define INTER_REGS_BASE			INTER_REGS_VIRT_BASE /* For compatibility */
+/* #define INTER_REGS_SIZE		SZ_1M */
+
+/*
+ * DFX Internal registers.
+ * PHYS: 0xF1100000 - 0xF1200000
+ * VIRT: 0xFB100000 - 0xFB200000
+ */
+#define DFX_REGS_PHYS_BASE		0xF1100000
+#define DFX_REGS_VIRT_BASE		0xFB100000
+#define DFX_REGS_SIZE			SZ_1M
+
+/*
+ * Uart registers.
+ * PHYS: 0xF1200000 - 0xF1300000
+ * VIRT: 0xFB200000 - 0xFB300000
+ */
+#define UART_REGS_BASE			0xF1200000
+#define UART_VIRT_BASE			0xFB200000
+#define UART_SIZE			SZ_1M
+
+/*
+ * PHYS: 0xF1300000 - 0xF1400000
+ * VIRT: 0xFB300000 - 0xFB400000
+ * PEX IO Address Decoding
+ * Allocate 1MB for each IO window.
+ */
+#define PEX0_IO_PHYS_BASE		0xF1300000
+#define PEX0_IO_VIRT_BASE		0xFB300000
+#define PEX0_IO_SIZE			SZ_1M
+
+
+/*
+ * Below are the IOs that might require size change depending on the
+ * system peripherals.
+ */
+
+/*
+ * PHYS: 0xF2000000 - 0xF2200000
+ * VIRT: @runtime
+ * PEX Memory Address Decoding
+ * Virtual address not specified - remapped @runtime
+ */
+#define PEX_MEM_PHYS_BASE		0xF2000000
+#define PEX_MEM_SIZE			_2M
+
+/*
+ * Device Bus address decode windows.
+ * PHYS: 0xF2200000 - 0xF2600000
+ * VIRT: @runtime
+ */
+#define DEVICE_CS0_PHYS_BASE		0xF2200000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF2300000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF2400000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF2500000
+#define DEVICE_CS3_SIZE			_1M
+
+/*
+ * Device Boot-CS Window
+ * PHYS: 0xF3000000 - 0xF5000000
+ * VIRT: @runtime
+ */
+#define DEVICE_BOOTCS_PHYS_BASE		0xF4000000
+#define DEVICE_BOOTCS_SIZE		_32M
+
+
+/*
+ * SPI Flash window.
+ * PHYS: 0xF5000000 - 0xF6000000
+ * VIRT: @runtime
+ * This is a 16MB window, if a larger flash exists, then the
+ * window needs to be enlarged.
+ */
+#define SPI_CS0_PHYS_BASE		0xF6000000
+#define SPI_CS0_SIZE			_16M
+
+/*
+ * Free area from 0xF9000000 to 0xFFF00000 (111MB).
+ * This can be used to map a larger window for PCI / SPI / Device-CS....
+ */
+
+
+/*
+ * PHYS: 0xFFF00000 - 0xFFFFFFFF
+ * VIRT: 0xFF000000 - 0xFF0FFFFF
+ * Bootrom window
+ */
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFF000000
+#define BOOTROM_SIZE			_1M
+
+
+/*
+ * Linux native definitiotns
+ */
+#define XOR0_PHYS_BASE				(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR1_PHYS_BASE				(INTER_REGS_PHYS_BASE | 0xF0900)
+#define XOR0_HIGH_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60B00)
+#define XOR1_HIGH_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0B00)
+
+#define MSYS_NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#define SDRAM_OPERATION_REG			(INTER_REGS_BASE | 0x1418)
+#define SDRAM_CONFIG_REG			(INTER_REGS_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG			(INTER_REGS_BASE | 0x170C)
+
+#define MSYS_UART_PHYS_BASE(port)		(INTER_REGS_PHYS_BASE | 0x12000 + (port * 0x100))
+#define DDR_VIRT_BASE				(INTER_REGS_BASE | 0x00000)
+#define MSYS_BRIDGE_VIRT_BASE			(INTER_REGS_BASE | 0x20000)
+#define MSYS_BRIDGE_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x20000)
+#define DDR_WINDOW_CPU_BASE			(DDR_VIRT_BASE | 0x1500)
+#define MSYS_SW_TRIG_IRQ			(MSYS_BRIDGE_VIRT_BASE | 0x0A04)
+#define MSYS_SW_TRIG_IRQ_PHYS			(MSYS_BRIDGE_PHYS_BASE | 0x0A04)
+#define MSYS_SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define MSYS_SW_TRIG_IRQ_INITID_MASK		0x1F
+#define MSYS_PER_CPU_BASE			(MSYS_BRIDGE_VIRT_BASE | 0x1000)
+#define MSYS_IRQ_VIRT_BASE			(MSYS_PER_CPU_BASE)
+#define MSYS_CPU_INTACK				0xB4
+#define MSYS_IRQ_SEL_CAUSE_OFF			0xA0
+#define MSYS_IN_DOORBELL_CAUSE			0x78
+#define MSYS_IN_DRBEL_CAUSE			(MSYS_PER_CPU_BASE | 0x78)
+#define MSYS_IN_DRBEL_MSK			(MSYS_PER_CPU_BASE | 0x7c)
+#define MSYS_CPU_IO_SYNC_BARRIER_CTRL_REG	(MSYS_PER_CPU_BASE | 0x10)
+
+#define MSYS_CPU_RESUME_ADDR_REG		(MSYS_BRIDGE_VIRT_BASE | 0x984)
+#define MSYS_CPU_RESUME_CTRL_REG		(MSYS_BRIDGE_VIRT_BASE | 0x988)
+
+#define MSYS_CPU_RESET_REG(cpu)			(MSYS_BRIDGE_VIRT_BASE | (0x800+(cpu)*8))
+#define MSYS_CPU_RESET_OFFS			0
+
+#define MSYS_L2_CLEAN_WAY_REG			(INTER_REGS_BASE | 0x87BC)
+#define MSYS_L2_MNTNC_STAT_REG			(INTER_REGS_BASE | 0x8704)
+#define MSYS_SNOOP_FILTER_PHYS_REG		(INTER_REGS_PHYS_BASE | 0x21020)
+#define MSYS_REVISION_ID_PHYS_REG		(INTER_REGS_PHYS_BASE | 0x40008)
+#define MSYS_REVISION_ID_VIRT_REG		(INTER_REGS_BASE | 0x40008)
+
+#endif /* __MACH_MSYS_H */
diff --git a/arch/arm/mach-msys/include/mach/param.h b/arch/arm/mach-msys/include/mach/param.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/param.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-msys/include/mach/serial.h b/arch/arm/mach-msys/include/mach/serial.h
new file mode 100644
index 0000000..c6876e6
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/serial.h
@@ -0,0 +1,40 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/irq.h>
+
+#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
+
+extern unsigned int mvTclk;
+
+#undef BASE_BAUD
+#define BASE_BAUD (mvTclk / 16)
+
+#define PORT0_BASE	(INTER_REGS_BASE + 0x12000) /* port 0 base */
+#define PORT1_BASE	(INTER_REGS_BASE + 0x12100) /* port 1 base */
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+
+#define STD_SERIAL_PORT_DEFNS
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff --git a/arch/arm/mach-msys/include/mach/smp.h b/arch/arm/mach-msys/include/mach/smp.h
new file mode 100644
index 0000000..a7787f1
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/smp.h
@@ -0,0 +1,46 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#ifndef __MACH_MSYS_SMP_H
+#define __MACH_MSYS_SMP_H
+
+#include <asm/io.h>
+#include <mach/msys.h>
+
+#define hard_smp_processor_id()				\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#define get_hw_cpu_mask(cpu_mask)	((cpu_mask << master_cpu_id_get()) & group_cpu_mask_get())
+#define get_hw_cpu_id(cpu)		(cpu + master_cpu_id)
+
+#endif /* __MACH_MSYS_SMP_H */
diff --git a/arch/arm/mach-msys/include/mach/system.h b/arch/arm/mach-msys/include/mach/system.h
new file mode 100644
index 0000000..e2cefa9
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/system.h
@@ -0,0 +1,40 @@
+/*
+ * include/mach/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
+#define LSP_PG_SZ_VER  " (Large Page)"
+#else
+#define LSP_PG_SZ_VER  ""
+#endif
+
+#define LSP_VERSION	"linux-3.4.y-2013_Q3.0p1" LSP_PG_SZ_VER
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk(KERN_INFO "Reseting...\n");
+	mvBoardReset();
+
+	/* This should never be reached */
+	while (1)
+		;
+}
+
+#endif
diff --git a/arch/arm/mach-msys/include/mach/timex.h b/arch/arm/mach-msys/include/mach/timex.h
new file mode 100644
index 0000000..c8cf294
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-dove/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
diff --git a/arch/arm/mach-msys/include/mach/uncompress.h b/arch/arm/mach-msys/include/mach/uncompress.h
new file mode 100644
index 0000000..a0488fc
--- /dev/null
+++ b/arch/arm/mach-msys/include/mach/uncompress.h
@@ -0,0 +1,42 @@
+/*
+ * include/asm-arm/arch-aurora/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/msys.h>
+
+#ifndef CONFIG_MV_UART_PORT
+#define UART_THR ((unsigned char *)(MSYS_UART_PHYS_BASE(0) + 0x0))
+#define UART_LSR ((unsigned char *)(MSYS_UART_PHYS_BASE(0) + 0x14))
+#else
+#define UART_THR ((unsigned char *)(MSYS_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
+#define UART_LSR ((unsigned char *)(MSYS_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
+#endif
+
+#define LSR_THRE	0x20
+
+static void putc(const char c)
+{
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		/* Transmit fifo not full? */
+		if (*UART_LSR & LSR_THRE)
+			break;
+	}
+
+	*UART_THR = c;
+}
+
+static void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
diff --git a/arch/arm/mach-msys/irq.c b/arch/arm/mach-msys/irq.c
new file mode 100644
index 0000000..c9af816
--- /dev/null
+++ b/arch/arm/mach-msys/irq.c
@@ -0,0 +1,287 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <plat/msi.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvOs.h"
+#include "include/mach/smp.h"
+
+#include "platsmp.h"
+
+unsigned int  irq_int_type[NR_IRQS];
+static DEFINE_SPINLOCK(irq_controller_lock);
+#define ENABLED_DOORBELS		(0xF0FF)
+
+/* not enabled, default */
+int max_per_cpu_irq = 28;
+
+static int __init per_cpu_irq_setup(char *__unused)
+{
+	max_per_cpu_irq = 7;
+	return 1;
+}
+
+__setup("per_cpu_irq_enable", per_cpu_irq_setup);
+
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+static void msys_unmask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val |= (1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+	if (cpu > 0) { /*enabled for both cpu */
+		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+		/* FIXME: assuming all 2 cpus */
+		val |= 0x3;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+	}
+#endif
+}
+
+static void msys_mask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val &= ~(1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+if (cpu > 0) { /*disabled for both cpu */
+	val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+	/* FIXME: assuming all 2 cpus */
+	val &= ~0x3;
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+}
+#endif
+}
+#endif /* (CONFIG_PERF_EVENTS && CONFIG_HW_PERF_EVENTS) || CONFIG_ERROR_HANDLING */
+
+
+void msys_irq_mask(struct irq_data *d)
+{
+	u32 irq = d->irq;
+	MV_U32 addr, temp, gpio_indx;
+
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		/* GPIO Interrupts */
+		/* calculate index in main interrupt */
+		gpio_indx = IRQ_AURORA_GPIO_0_7 + ((irq - IRQ_AURORA_GPIO_START) >> 3);
+
+		/* add 1 because there is a gap between IRQ_AURORA_GPIO_24_31
+		   and IRQ_AURORA_GPIO_32_33 */
+		if (gpio_indx > IRQ_AURORA_GPIO_24_31)
+			gpio_indx++;
+
+		addr = (CPU_INT_SOURCE_CONTROL_REG(gpio_indx));
+	} else if (irq >= IRQ_AURORA_MSI_START) {
+		/* Per CPU MSI Interrupts */
+		if ((irq - IRQ_AURORA_MSI_START) < NR_PRIVATE_MSI_GROUP)
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW);
+		else
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH);
+	} else
+		addr = CPU_INT_SOURCE_CONTROL_REG(irq);
+	spin_lock(&irq_controller_lock);
+
+	temp = MV_REG_READ(addr);
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		MV_U32 bitmask = 1 << (irq & (32-1));
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+
+	if (irq <= max_per_cpu_irq)
+		temp &= ~(1 << hard_smp_processor_id());
+
+	/* for GPIO IRQs , don't disable INTS , they will be disabled in the units mask */
+	else if (irq < IRQ_MAIN_INTS_NUM)
+		temp &= ~0xf;
+
+	MV_REG_WRITE(addr, temp);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+	 if (irq == IRQ_AURORA_MP) {
+		for_each_online_cpu(i) {
+			msys_unmask_fabric_interrupt(i);
+		}
+	}
+#endif
+	spin_unlock(&irq_controller_lock);
+}
+
+void msys_irq_unmask(struct irq_data *d)
+{
+	u32 irq = d->irq;
+	MV_U32 addr, temp, gpio_indx;
+	unsigned int map = 0x1;
+
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		/* GPIO Interrupts */
+		/* calculate index in main interrupt */
+		gpio_indx = IRQ_AURORA_GPIO_0_7 + ((irq - IRQ_AURORA_GPIO_START) >> 3);
+
+		/* add 1 because there is a gap between IRQ_AURORA_GPIO_24_31
+		   and IRQ_AURORA_GPIO_32_33 */
+		if (gpio_indx > IRQ_AURORA_GPIO_24_31)
+			gpio_indx++;
+
+		addr = (CPU_INT_SOURCE_CONTROL_REG(gpio_indx));
+	} else if (irq >= IRQ_AURORA_MSI_START) {
+		/* Per CPU MSI Interrupts */
+		if ((irq - IRQ_AURORA_MSI_START) < NR_PRIVATE_MSI_GROUP)
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW);
+		else
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH);
+	} else
+		addr = CPU_INT_SOURCE_CONTROL_REG(irq);
+	spin_lock(&irq_controller_lock);
+	temp = MV_REG_READ(addr);
+
+	if (irq >= IRQ_AURORA_GPIO_START) {
+		MV_U32 bitmask = 1 << (irq & (32-1));
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+#ifdef CONFIG_SMP
+	else
+		map = get_hw_cpu_mask(*cpus_addr(*(d->affinity)));
+#endif
+	temp |= map;
+	temp |= (0x1 << 28); /* Set IntEn for this source */
+	MV_REG_WRITE(addr, temp);
+	spin_unlock(&irq_controller_lock);
+}
+
+
+#ifdef CONFIG_SMP
+int msys_set_affinity(struct irq_data *d, const struct cpumask *mask_val, bool force)
+{
+	struct cpumask mask_temp;
+
+	cpumask_and(&mask_temp, mask_val, cpu_online_mask);
+	cpumask_copy((*d).affinity, &mask_temp);
+	spin_lock(&irq_controller_lock);
+	(*d).node = cpumask_first(&mask_temp);
+	spin_unlock(&irq_controller_lock);
+	msys_irq_unmask(d);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SMP
+void msys_ipi_init(void)
+{
+	struct irq_data *d = irq_get_irq_data(IRQ_AURORA_IN_DRBL_LOW);
+	unsigned long temp;
+
+	/* open IPI mask */
+	temp = MV_REG_READ(MSYS_IN_DRBEL_MSK) | ENABLED_DOORBELS;
+	MV_REG_WRITE(MSYS_IN_DRBEL_MSK, temp);
+
+	msys_irq_unmask(d);
+}
+#endif
+
+static struct irq_chip msys_irq_chip = {
+	.name			= "msys_irq",
+	.irq_mask		= msys_irq_mask,
+	.irq_mask_ack		= msys_irq_mask,
+	.irq_unmask		= msys_irq_unmask,
+#ifdef CONFIG_SMP
+	.irq_set_affinity	= msys_set_affinity,
+#endif
+};
+
+
+void __init msys_init_irq(void)
+{
+	u32 irq;
+
+	/* MASK all interrupts */
+	/* Enable IRQ in control register */
+	for (irq = 0; irq < IRQ_MAIN_INTS_NUM; irq++)
+		msys_irq_mask(irq_get_irq_data(irq));
+/*
+ * Register IRQ sources
+ */
+	for (irq = 0; irq < IRQ_AURORA_MSI_START ; irq++) {
+		irq_set_chip(irq, &msys_irq_chip);
+		irq_set_chip_data(irq, 0);
+		irq_set_handler(irq, handle_level_irq);
+		irq_set_status_flags(irq, IRQ_LEVEL);
+#ifdef CONFIG_SMP
+		/*Warninig  - Seif Mazreeb, in Linux 3.2 you must declare that an
+		interrupt is a percpu .....without doing this timer interrupt won't happen.
+		If we declare network interrupt in the same way ( which I think we should),
+		we crash duing boot, keep this for timers for now.
+		This is a  TODO at a second stage, evalute perfrmance and fix as needed
+		*/
+		if (irq < MAX_PER_CPU_IRQ_NUMBER && irq != IRQ_AURORA_MP) {
+			irq_set_chip_and_handler(irq, &msys_irq_chip,
+						 handle_percpu_devid_irq);
+			irq_set_percpu_devid(irq);
+		}
+#endif
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+#ifdef CONFIG_SMP
+	{
+		u32/*void __iomem **/addr;
+
+		/* Set the default affinity to the boot cpu. */
+		cpumask_clear(irq_default_affinity);
+		cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
+
+		/* open IPI mask */
+		/* this  register write does the job of msys_irq_unmask(IRQ_AURORA_IN_DRBL_LOW)
+		   i.e. enable / unmask the DRBL_LOW interrupt.
+		*/
+		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, 0);
+		addr = /*(void __iomem *)*/(MSYS_IN_DRBEL_MSK);
+		MV_REG_WRITE(addr, ENABLED_DOORBELS);
+	}
+#endif
+
+	armada_msi_init();
+
+}
diff --git a/arch/arm/mach-msys/irq.h b/arch/arm/mach-msys/irq.h
new file mode 100644
index 0000000..3c03829
--- /dev/null
+++ b/arch/arm/mach-msys/irq.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+
+void __init msys_init_irq(void);
+void msys_irq_unmask(struct irq_data *d);
+void msys_irq_mask(struct irq_data *d);
+
+#ifdef CONFIG_SMP
+void msys_ipi_init(void);
+#endif
diff --git a/arch/arm/mach-msys/mpp.h b/arch/arm/mach-msys/mpp.h
new file mode 100644
index 0000000..fedd32b
--- /dev/null
+++ b/arch/arm/mach-msys/mpp.h
@@ -0,0 +1,46 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __ARCH_DOVE_MPP_H
+#define __ARCH_DOVE_MPP_H
+
+enum aurora_mpp_type {
+	MPP_UNUSED,		/* This MPP is unused */
+	MPP_GPIO,		/* This MPP pin is used as a generic GPIO pin. */
+	MPP_FUNCTIONAL,		/* This MPP is used as a functional pad. */
+};
+
+struct aurora_mpp_mode {
+	int			mpp;
+	enum aurora_mpp_type	type;
+};
+
+void aurora_mpp_conf(struct aurora_mpp_mode *mode);
+
+
+#endif
diff --git a/arch/arm/mach-msys/msys_family/.gitignore b/arch/arm/mach-msys/msys_family/.gitignore
new file mode 100644
index 0000000..b33b8f2
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/.gitignore
@@ -0,0 +1,5 @@
+*.o
+*.o.*
+*.rej
+*.orig
+*.su
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
index ddf1e54..b5c7e25 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
@@ -162,7 +162,7 @@ MV_U32 mvBoardDfxConfig(MV_VOID)
 
 	/* open windows to DFX */
 	MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(1), 0x000f0081);
-	MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(1), DFX_REGS_BASE);
+	MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(1), 0xF5000000);
 
 	return 0;
 }
@@ -1267,8 +1267,8 @@ MV_STATUS mvBoardTwsiRead(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
+
 	if (MV_OK != mvTwsiRead(0, &twsiSlave, pData, 1)) {
-		mvOsPrintf("Board: Read S@R fail\n");
 		DB(mvOsPrintf("Board: Read S@R fail\n"));
 		return MV_ERROR;
 	}
@@ -1329,7 +1329,6 @@ MV_STATUS mvBoardTwsiWrite(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNu
 * DESCRIPTION:
 *
 * INPUT:
-*	SatR bios index - 0,1,2
 *	device num - one of three devices
 *	reg num - 0 or 1
 *
@@ -1385,7 +1384,6 @@ MV_STATUS mvBoardCoreFreqGet(MV_U8 *value)
 }
 
 /*******************************************************************************/
-//MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal)
 MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal)
 {
 	MV_U8 sar0;
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.h b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
index 297cf9c..4ebbcbc 100644
--- a/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
@@ -102,7 +102,7 @@ typedef struct _mvCpuArmClkRatio {
 } MV_CPU_ARM_CLK_RATIO;
 
 MV_U32  mvCpuPclkGet(MV_VOID);
-MV_U32 mvCpuDdrClkGet(MV_VOID);
+MV_U32	mvCpuDdrClkGet(MV_VOID);
 MV_VOID mvCpuNameGet(char *pNameBuff);
 MV_U32  mvCpuL2ClkGet(MV_VOID);
 MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
index d62a1d56..94a0924 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -87,17 +87,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "xor/mvXor.h"
 #endif
 
-#if defined(MV_INCLUDE_SATA)
-#include "sata/CoreDriver/mvSata.h"
-#endif
-#if defined(MV_INCLUDE_USB)
-#include "usb/mvUsb.h"
-#endif
-
-#if defined(MV_INCLUDE_TDM)
-#include "mvSysTdmConfig.h"
-#endif
-
 #include "ddr2_3/mvDramIfRegs.h"
 
 /* defines  */
@@ -113,21 +102,10 @@ MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][1] = {
 /* DRAM_UNIT_ID         */ { 1, },
 /* PEX_UNIT_ID          */ { 1, },
 /* ETH_GIG_UNIT_ID      */ { 2, },
-/* USB_UNIT_ID          */ { 1, },
-/* USB3_UNIT_ID          */ { 1, },
-/* IDMA_UNIT_ID         */ { 0, },
 /* XOR_UNIT_ID          */ { 2, },
-/* SATA_UNIT_ID         */ { 2, },
-/* TDM_32CH_UNIT_ID     */ { 1, },
 /* UART_UNIT_ID         */ { 2, },
-/* CESA_UNIT_ID         */ { 1, },
 /* SPI_UNIT_ID          */ { 2, },
-/* AUDIO_UNIT_ID        */ { 1, },
 /* SDIO_UNIT_ID         */ { 1, },
-/* TS_UNIT_ID           */ { 0, },
-/* XPON_UNIT_ID         */ { 1, },
-/* BM_UNIT_ID           */ { 1, },
-/* PNC_UNIT_ID          */ { 1, },
 /* I2C_UNIT_ID          */ { 2, },
 };
 
@@ -352,74 +330,6 @@ MV_U8 mvCtrlEthMaxCPUsGet(MV_VOID)
 	return 2;
 }
 
-
-#if defined(MV_INCLUDE_SATA)
-/*******************************************************************************
-* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
-*
-* DESCRIPTION:
-*       This function returns Marvell controller number of Sata ports.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       Marvell controller number of Sata ports.
-*
-*******************************************************************************/
-MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
-{
-	return 0;
-}
-#endif
-
-#if defined(MV_INCLUDE_IDMA)
-/*******************************************************************************
-* mvCtrlIdmaMaxChanGet - Get Marvell controller number of IDMA channels.
-*
-* DESCRIPTION:
-*       This function returns Marvell controller number of IDMA channels.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       Marvell controller number of IDMA channels.
-*
-*******************************************************************************/
-MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID)
-{
-	return MV_IDMA_MAX_CHAN;
-}
-
-/*******************************************************************************
-* mvCtrlIdmaMaxUnitGet - Get Marvell controller number of IDMA units.
-*
-* DESCRIPTION:
-*       This function returns Marvell controller number of IDMA units.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       Marvell controller number of IDMA units.
-*
-*******************************************************************************/
-MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID)
-{
-	return MV_IDMA_MAX_UNIT;
-}
-#endif /* MV_INCLUDE_IDMA */
-
 #if defined(MV_INCLUDE_XOR)
 /*******************************************************************************
 * mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
@@ -465,50 +375,6 @@ MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
 
 #endif
 
-#if defined(MV_INCLUDE_USB)
-/*******************************************************************************
-* mvCtrlUsbHostMaxGet - Get number of Marvell Usb  controllers
-*
-* DESCRIPTION:
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       returns number of Marvell USB  controllers.
-*
-*******************************************************************************/
-MV_U32 mvCtrlUsbMaxGet(void)
-{
-	return BC2_MAX_USB_PORTS;
-}
-#endif
-
-#if defined(MV_INCLUDE_LEGACY_NAND)
-/*******************************************************************************
-* mvCtrlNandSupport - Return if this controller has integrated NAND flash support
-*
-* DESCRIPTION:
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if NAND is supported and MV_FALSE otherwise
-*
-*******************************************************************************/
-MV_U32 mvCtrlNandSupport(MV_VOID)
-{
-	return BC2_NAND;
-}
-#endif
-
 #if defined(MV_INCLUDE_SDIO)
 /*******************************************************************************
 * mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
@@ -531,91 +397,6 @@ MV_U32 mvCtrlSdioSupport(MV_VOID)
 }
 #endif
 
-#if defined(MV_INCLUDE_TDM)
-/*******************************************************************************
-* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
-*
-* DESCRIPTION:
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       MV_TRUE if TDM is supported and MV_FALSE otherwise
-*
-*******************************************************************************/
-MV_U32 mvCtrlTdmSupport(MV_VOID)
-{
-	return BC2_TDM;
-}
-
-/*******************************************************************************
-* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
-*
-* DESCRIPTION:
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       The number of TDM ports in device.
-*
-*******************************************************************************/
-MV_U32 mvCtrlTdmMaxGet(MV_VOID)
-{
-	return BC2_MAX_TDM_PORTS;
-}
-
-/*******************************************************************************
-* mvCtrlTdmTypeGet
-*
-* DESCRIPTION:
-*	Return the TDM unit type being compiled in.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*	The TDM unit type.
-*
-*******************************************************************************/
-MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID)
-{
-	return TDM_UNIT_32CH;
-}
-
-/*******************************************************************************
-* mvCtrlTdmUnitIrqGet
-*
-* DESCRIPTION:
-*	Return the TDM unit IRQ number depending on the TDM unit compilation
-*	options.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-******************************************************************************/
-MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
-{
-	return MV_TDM_IRQ_NUM;
-}
-
-#endif /* if defined(MV_INCLUDE_TDM) */
-
 /*******************************************************************************
 * mvCtrlModelGet - Get Marvell controller device model (Id)
 *
@@ -788,6 +569,7 @@ const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
 	return cntrlName[target];
 }
 
+#if defined(MV_INCLUDE_PEX)
 /*******************************************************************************
 * mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
 *
@@ -881,7 +663,9 @@ static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
 		}
 	}
 }
+#endif
 
+#if defined(MV_INCLUDE_GIG_ETH) || defined(MV_INCLUDE_XOR)
 /*******************************************************************************
 * mvUnitAddrDecShow - Print the Unit's address decode map.
 *
@@ -937,6 +721,7 @@ static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId, const char *nam
 	}
 	return;
 }
+#endif
 
 /*******************************************************************************
 * mvCtrlAddrDecShow - Print the Controller units address decode map.
@@ -961,9 +746,6 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 #if defined(MV_INCLUDE_PEX)
 	mvCtrlPexAddrDecShow();
 #endif
-#if defined(MV_INCLUDE_USB)
-	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
-#endif
 
 #if defined(MV_INCLUDE_GIG_ETH)
 #if defined(MV_ETH_LEGACY)
@@ -976,9 +758,6 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 #if defined(MV_INCLUDE_XOR)
 	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
 #endif
-#if defined(MV_INCLUDE_SATA)
-	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
-#endif
 }
 
 /*******************************************************************************
@@ -1290,7 +1069,9 @@ MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 ******************************************************************************/
 MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 {
+#if defined(MV_INCLUDE_PEX) || defined(MV_INCLUDE_PEX) || defined(MV_INCLUDE_GIG_ETH) || defined(MV_INCLUDE_SDIO)
 	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+#endif
 	MV_BOOL state = MV_TRUE;
 
 	switch (unitId) {
@@ -1539,10 +1320,11 @@ void mvCtrlGetPexActive(MV_BOOL *pPexActive, int size)
 *******************************************************************************/
 void mvCtrlNandClkSet(int nClock)
 {
+	MV_U32 nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(2));
+
 	DB(mvOsPrintf("%s: CPU (PLL_1) clock)  = %d, dividor = %d\n", __func__, mvCpuPclkGet(), nClock));
 
 	/* Set the division ratio of ECC Clock 0x000F8270[9:6] (ECC clock = CPU / dividor) */
-	MV_U32 nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(2));
 	nVal &= ~(NAND_ECC_DIVCKL_RATIO_MASK);
 	nVal |= (nClock << NAND_ECC_DIVCKL_RATIO_OFFS);
 	MV_DFX_REG_WRITE(CORE_DIV_CLK_CTRL(2), nVal);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
index ca69b7c..82b3fce 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
@@ -162,29 +162,13 @@ MV_U32	mvCtrlPciMaxIfGet(MV_VOID);
 
 MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
 MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
-#if defined(MV_INCLUDE_IDMA)
-MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID);
-MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID);
-#endif
 #if defined(MV_INCLUDE_XOR)
 MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
 MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
 #endif
-#if defined(MV_INCLUDE_USB)
-MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
-#endif
-#if defined(MV_INCLUDE_LEGACY_NAND)
-MV_U32	  mvCtrlNandSupport(MV_VOID);
-#endif
 #if defined(MV_INCLUDE_SDIO)
 MV_U32	  mvCtrlSdioSupport(MV_VOID);
 #endif
-#if defined(MV_INCLUDE_TDM)
-MV_U32	  mvCtrlTdmSupport(MV_VOID);
-MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
-MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
-MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
-#endif
 MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
 MV_U16    mvCtrlModelGet(MV_VOID);
 MV_U8     mvCtrlRevGet(MV_VOID);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
index 912d0a3..eb39ae4 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -79,9 +79,6 @@ extern "C" {
 #define PCCRIR_REVID_OFFS			0		/* Revision ID */
 #define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
 
-/* Controler environment registers offsets */
-#define MV_TDM_IRQ_NUM				56
-
 
 /* Coherent Fabric Control and Status */
 #define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
@@ -123,21 +120,6 @@ extern "C" {
 #define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
 #define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
 
-#define PMC_IDMASTOPMEM_OFFS			12
-#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
-#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
-#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
-
-#define PMC_LCDSTOPMEM_OFFS			0
-#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
-#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
-#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
-
-#define PMC_PMUSTOPMEM_OFFS			0
-#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
-#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
-#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
-
 
 /*  Power Management Clock Gating Control Register	*/
 #define POWER_MNG_CTRL_REG			0x18220
@@ -256,7 +238,7 @@ extern "C" {
 /*****************/
 /*  registers */
 /*****************/
-#define  I2C_CONFIC_DEBUG_REG	0x1180c
+#define I2C_CONFIC_DEBUG_REG	0x1108c
 #define	ICDR_UINIT_ID_MASK	0x0F
 #define ICDR_UNIT_ID_4_DFX	0x0f
 
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
index ed32f5e..97e4add 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -96,6 +96,8 @@ extern "C" {
 #define MV_MISC_REGS_OFFSET			(0x18200)
 #define MV_MBUS_REGS_OFFSET			(0x20000)
 #define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
 #define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
 #define MV_CNTMR_REGS_OFFSET			(0x20300)
 #define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
@@ -134,7 +136,6 @@ extern "C" {
 #define AVS_LOW_VDD_LIMIT			0x20860
 
 #define INTER_REGS_SIZE				_1M
-#define DFX_REGS_SIZE				_1M
 
 /* This define describes the TWSI interrupt bit and location */
 #define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
@@ -145,20 +146,12 @@ extern "C" {
 #define MV_GPP_MAX_GROUP    			2 	/* group == configuration register? */
 #define MV_CNTMR_MAX_COUNTER 			8 	/* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
 
-
 #define MV_UART_MAX_CHAN			2
 
 #define MV_XOR_MAX_UNIT				1 /* XOR unit == XOR engine */
 #define MV_XOR_MAX_CHAN         		2 /* total channels for all units together*/
 #define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
 
-#if defined(MV_INCLUDE_IDMA)
-#define MV_IDMA_MAX_UNIT			0 /* IDMA unit == IDMA engine */
-#define MV_IDMA_MAX_CHAN			0 /* total channels for all units together */
-#endif
-
-#define MV_SATA_MAX_CHAN			0
-
 #define MV_MPP_MAX_GROUP			5
 
 #define MV_DRAM_MAX_CS				4
@@ -191,16 +184,10 @@ extern "C" {
 #define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
 #define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
 /* This define describes the maximum number of supported PCI Interfaces 	*/
-#define MV_IDMA_MAX_CHAN			2
-#define BC2_MAX_USB_PORTS			0
 #define BC2_NAND				1
 #define BC2_SDIO				1
 #define MV_DEVICE_MAX_CS      			4
 
-#ifndef MV_USB_MAX_PORTS
-#define MV_USB_MAX_PORTS 			BC2_MAX_USB_PORTS
-#endif
-
 
 /* This define describes the maximum number of supported Ethernet ports */
 /* TODO - verify all these numbers */
@@ -210,7 +197,6 @@ extern "C" {
 #define MV_ETH_MAX_RXQ              		8
 #define MV_ETH_MAX_TXQ              		8
 #define MV_ETH_TX_CSUM_MAX_SIZE 		9800
-#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
 #define BOARD_ETH_SWITCH_PORT_NUM		2
 
 /* New GMAC module is used */
@@ -219,16 +205,9 @@ extern "C" {
 #define MV_ETH_WRR_NEW
 /* IPv6 parsing support for Legacy parser */
 #define MV_ETH_LEGACY_PARSER_IPV6
-/* New PNC module - extra fields */
-#define MV_ETH_PNC_NEW
-/* PNC Load Balancing support */
-#define MV_ETH_PNC_LB
 
 #define MV_MV_98DX_ETH_MAX_PORT			2
 
-/* This define describes the the support of USB */
-#define MV_USB_VERSION  			1
-
 #define MV_SPI_VERSION				2
 
 #define MV_INCLUDE_SDRAM_CS0
@@ -251,21 +230,10 @@ typedef enum _mvUnitId {
 	DRAM_UNIT_ID,
 	PEX_UNIT_ID,
 	ETH_GIG_UNIT_ID,
-	USB_UNIT_ID,
-	USB3_UNIT_ID,
-	IDMA_UNIT_ID,
 	XOR_UNIT_ID,
-	SATA_UNIT_ID,
-	TDM_UNIT_ID,
 	UART_UNIT_ID,
-	CESA_UNIT_ID,
 	SPI_UNIT_ID,
-	AUDIO_UNIT_ID,
 	SDIO_UNIT_ID,
-	TS_UNIT_ID,
-	XPON_UNIT_ID,
-	BM_UNIT_ID,
-	PNC_UNIT_ID,
 	I2C_UNIT_ID,
 	MAX_UNITS_ID
 } MV_UNIT_ID;
@@ -317,8 +285,6 @@ typedef enum _mvTarget {
 	SPI_CS7,	/* 20 SPI_CS7			*/
 	BOOT_ROM_CS, 	/* 21 BOOT_ROM_CS		*/
 	DEV_BOOCS,	/* 22 DEV_BOOCS			*/
-	PMU_SCRATCHPAD,	/* 23 PMU Scratchpad		*/
-	PNC_BM,		/* 24 PNC + BM 		        */
 	MAX_TARGETS
 } MV_TARGET;
 
@@ -346,7 +312,7 @@ typedef enum _mvTarget {
 	{0xE8, PEX0_TARGET_ID	},		/*  8 PEX0_LANE0_MEM */	\
 	{0xE0, PEX0_TARGET_ID	},		/*  9 PEX0_LANE0_IO */	\
 	{0xFF, 0xFF             },		/* 10 INTER_REGS */	\
-	{0x81, DEV_TARGET_ID    },		/* 11 DFX_INTER_REGS */	\
+	{0x00, 8		},		/* 11 DFX_INTER_REGS */	\
 	{0x01, DEV_TARGET_ID    },		/* 12 DMA_UART */	\
 	{0x1E, DEV_TARGET_ID    },		/* 13 SPI_CS0 */	\
 	{0x5E, DEV_TARGET_ID    },		/* 14 SPI_CS1 */	\
@@ -358,8 +324,6 @@ typedef enum _mvTarget {
 	{0xDF, DEV_TARGET_ID    },		/* 20 SPI_CS7 */	\
 	{0x1D, DEV_TARGET_ID    },		/* 21 BOOT_ROM_CS (Main Boot device )*/	\
 	{0x2F, DEV_TARGET_ID    },		/* 22 DEV_BOOT_CS (Secondary Boot device,)*/	\
-	{0x2D, DEV_TARGET_ID    },		/* 23 PMU_SCRATCHPAD */	\
-	{0x00, PNC_BM_TARGET_ID },		/* 24 PNC_BM */		\
 }
 
 #define TARGETS_NAME_ARRAY	{			\
@@ -372,7 +336,7 @@ typedef enum _mvTarget {
 	"DEVICE_CS2",		/*  6 DEVICE_CS2 */	\
 	"DEVICE_CS3",		/*  7 DEVICE_CS3 */	\
 	"PEX0_MEM",		/*  8 PEX0_MEM */	\
-	"PEX0_IO",		/*  9 PEX0_IO */	\
+	"PEX0_IO",		/*  9 PEX0_IO */		\
 	"INTER_REGS",		/* 10 INTER_REGS */	\
 	"DFX_INTER_REGS",	/* 11 INTER_REGS */	\
 	"DMA_UART",		/* 12 DMA_UART */	\
@@ -386,8 +350,6 @@ typedef enum _mvTarget {
 	"SPI_CS7",		/* 20 SPI_CS7 */	\
 	"BOOT_ROM_CS",		/* 21 BOOT_ROM_CS */	\
 	"DEV_BOOTCS",		/* 22 DEV_BOOCS */	\
-	"PMU_SCRATCHPAD",	/* 23 PMU_SCRATCHPAD */	\
-	"PNC_BM"		/* 24 PNC_BM */		\
 }
 
 
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
index a5a94d3..8b8994c 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
@@ -75,7 +75,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_SEMA_REG_BASE	(0x20500)
 #define MV_MAX_SEMA 	    	128
 #define MV_SEMA_SMI 		50
-#define MV_SEMA_RTC 		51
 #define MV_SEMA_NOR_FLASH 	0
 #define MV_SEMA_BOOT 		1
 #define MV_SEMA_PEX0 		2
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
index 0321d7b..92b2963 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
@@ -107,22 +107,12 @@ typedef enum
 /*#define UART0_T0_CPU1	0x0001
 #define UART1_TO_CPU1	0x0002
 #define PEX0_TO_CPU1	0x0004
-#define PEX1_TO_CPU1	0x0008
 #define GIGA0_TO_CPU1	0x0010
 #define GIGA1_TO_CPU1	0x0020
-#define GIGA2_TO_CPU1	0x0040
-#define GIGA3_TO_CPU1	0x0080
-#define SATA_TO_CPU1	0x0100
 #define XOR_TO_CPU1		0x0200
-#define IDMA_TO_CPU1	0x0400
-#define USB0_TO_CPU1	0x0800
-#define USB1_TO_CPU1    0x1000
-#define USB2_TO_CPU1    0x2000
-#define CESA_TO_CPU1	0x4000
 #define NOR_TO_CPU1		0x8000
 #define NAND_TO_CPU1	0x10000
 #define SPI_TO_CPU1		0x20000
-#define TDM_TO_CPU1		0x40000
 
 #define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
 
@@ -134,17 +124,6 @@ typedef struct __MV_RES_MAP
 
 typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
 
-#ifdef CONFIG_MV_AMP_ENABLE
-
-MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
-MV_BOOL mvUnitMapIsPexMine(int pciIf);
-MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
-MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
-MV_VOID mvUnitMapSetAllMine(void);
-MV_VOID mvUnitMapPrint(void);
-MV_BOOL mvUnitMapIsRsrcLimited(void);
-MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
-#else /* CONFIG_MV_AMP_ENABLE */
 #define mvUnitMapIsMine(rsrc) 		MV_TRUE
 #define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
 #define mvUnitMapIsRsrcLimited 	  	MV_TRUE
@@ -153,6 +132,5 @@ MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
 #define mvUnitMapSetAllMine
 #define mvUnitMapPrint
 #define mvUnitMapSetup(str, strstr_func) MV_TRUE
-#endif /* CONFIG_MV_AMP_ENABLE */
 
 #endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
index 1fc5644..58db349 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
@@ -192,10 +192,6 @@ MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
 	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
 		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
 			continue;
-#ifdef CONFIG_MV_AMP_ENABLE
-		if(target == BOOT_ROM_CS)
-			continue;
-#endif
 
 #if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
 		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
@@ -297,8 +293,8 @@ MV_STATUS mvCpuIfDramInit()
 
 	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
 		if (cs == 0) {
-			printf("%s: TODO when ddr training is ready:\n", __func__);
-			printf("fix SDRAM_SIZE_REG(%d) (currently hard-coded value is 0x3FFFFFE1)\n", cs);
+			mvOsPrintf("%s: TODO when ddr training is ready:\n", __func__);
+			mvOsPrintf("fix SDRAM_SIZE_REG(%d) (currently hard-coded value is 0x3FFFFFE1)\n", cs);
 			MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0x3FFFFFE1 | ((cs << SDRAMWCR_CS_OFFS) & SDRAMWCR_CS_MASK));
 		} else
 			MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0x00FFFFE0 | ((cs << SDRAMWCR_CS_OFFS) & SDRAMWCR_CS_MASK));
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
index b721a00..0c6c14f 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -69,6 +69,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /****************************************/
 /* ARM Control and Status Registers Map */
 /****************************************/
+#include "mvTypes.h"
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "ctrlEnv/mvCtrlEnvRegs.h"
 
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysCntmr.c b/arch/arm/mach-msys/mv_hal_if/mvSysCntmr.c
new file mode 100644
index 0000000..273f752
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysCntmr.c
@@ -0,0 +1,93 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cntmr/mvCntmr.h"
+
+
+/*******************************************************************************
+* mvSysCntmrInit - Initialize the Cntmr subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysCntmrInit(void)
+{
+	MV_CNTMR_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+	halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+	return mvCntmrHalInit(&halData);
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysCntmrApi.h b/arch/arm/mach-msys/mv_hal_if/mvSysCntmrApi.h
new file mode 100644
index 0000000..72827d3
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysCntmrApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_CNTMR_API_H__
+#define __MV_SYS_CNTMR_API_H__
+
+MV_STATUS   mvSysCntmrInit(void);
+
+#endif
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysDdr.c b/arch/arm/mach-msys/mv_hal_if/mvSysDdr.c
new file mode 100644
index 0000000..7eb9f0e
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysDdr.c
@@ -0,0 +1,133 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+
+/*******************************************************************************
+* mvSysDdrSpdRead
+*
+* DESCRIPTION:
+*	System interface for reading DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer to read data into.
+*       size:	Number of bytes to read.
+*
+* OUTPUT:
+*       data:	SPD data.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
+
+/*******************************************************************************
+* mvSysDdrSpdWrite
+*
+* DESCRIPTION:
+*	System interface for writing DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer holding the data to be written.
+*       size:	Number of bytes to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return	mvTwsiWrite(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPci.c b/arch/arm/mach-msys/mv_hal_if/mvSysPci.c
new file mode 100644
index 0000000..b38a995
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysPci.c
@@ -0,0 +1,1270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysPci.h"
+#include "ddr2_3/mvDramIf.h"
+
+/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
+/* register offsets	and its function where its is located.			*/
+/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
+/* describes address remap register offsets					*/
+struct _pciBarRegInfo {
+	MV_U32 funcNum;
+	MV_U32 baseLowRegOffs;
+	MV_U32 baseHighRegOffs;
+	MV_U32 sizeRegOffs;
+	MV_U32 remapLowRegOffs;
+	MV_U32 remapHighRegOffs;
+};
+
+struct _pciBarStatus {
+	enum _mvPCIBars	bar;
+	int		enable;
+};
+
+struct _pciBarStatus pciBarStatusMap[] = {
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	{CS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	{CS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	{CS2_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	{CS3_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	{DEVCS0_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	{DEVCS1_BAR, EN},
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	{DEVCS2_BAR, EN},
+#endif
+	{BOOTCS_BAR, EN},
+	{MEM_INTER_REGS_BAR, EN},
+	{IO_INTER_REGS_BAR, EN},
+	{P2P_MEM0, DIS},
+	{P2P_IO, DIS},
+	{TBL_TERM, TBL_TERM}
+};
+
+
+/* Locals */
+static MV_U32 pciBurstBytes2Reg(MV_U32 size);
+static MV_U32 pciBurstReg2Bytes(MV_U32 size);
+
+static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, enum _mvPCIBars bar,
+					MV_ADDR_WIN *pAddrWin);
+
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, enum _mvPCIBars bar,
+					struct _pciBarRegInfo *pBarRegInfo);
+
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
+
+/* Forward declarations */
+const MV_8 *pciBarNameGet(enum _mvPCIBars bar);
+
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*       This function initiate the PCI interface:
+*       1) Set local bus number. In case of convential PCI it gets the bus
+*          number using mvPciLocalBusNumGet(). In case of PCI-X this
+*          information is read only.
+*       2) Interface device number. In case of conventional PCI it gets the
+*          device number using mvPciLocalDevNumGet(). In case of PCI-X this
+*          information is read only.
+*       3) PCI Arbiter if needed.
+*       4) Enable Master and Slave on PCI interfaces.
+*	5) Open PCI BARs according to default setting.
+*	   Note that PCI bridge (P2P) is NOT initialized.
+*	6) Enable CPU to PCI ordering.
+*
+* INPUT:
+*
+*       pciIf   - PCI interface number.
+*		localBus - Local Bus of the PCI interface to be set
+*		localDev - Local Dev of the PCI interface to be set
+*		bFirstCall - Indicates wether this is the first call of this
+*					 function .
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
+{
+	enum _mvPCIBars		bar, barix = 0;
+	MV_PCI_MODE		pciMode;
+	struct _mvPciProtWin	pciProtWin;
+	struct _mvPciBarWin	pciBarMap[PCI_MAX_BARS];
+	MV_UNIT_WIN_INFO	addrWinMap[MAX_TARGETS + 1];
+	MV_TARGET		target;
+	MV_UNIT_WIN_INFO	*addrDecWin;
+
+	/* Parameter checking  */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	/* device and bus numbers */
+	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
+		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
+		return MV_ERROR;
+	}
+
+	/* First disable all PCI target windows  */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++)
+		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+
+	/* WA CQ 4382*/
+	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BIT15);
+
+	/* Loop over all BARs and copy enabled SDRAM windows only */
+	if (MV_OK != mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1)) {
+		mvOsPrintf("mvPciInit: ERR. mvCtrlAddrWinMapBuild failed\n");
+		return MV_ERROR;
+	}
+
+	for (target = SDRAM_CS0; target <= SDRAM_CS3; target++) {
+		addrDecWin = &addrWinMap[target];
+		if (addrDecWin->enable == MV_TRUE) {
+			pciBarMap[barix].addrWin.baseLow = addrDecWin->addrWin.baseLow;
+			pciBarMap[barix].addrWin.baseHigh = addrDecWin->addrWin.baseHigh;
+			pciBarMap[barix].addrWin.size = addrDecWin->addrWin.size;
+			pciBarMap[barix].enable = EN;
+			barix++;
+		}
+	}
+
+	/* Initialize all non used BARs */
+	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
+		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
+		pciBarMap[bar].addrWin.baseHigh = 0;
+		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
+		pciBarMap[bar].enable = DIS;
+	}
+
+	/* finally fill table with TBL_TERM entry */
+	bar = PCI_MAX_BARS - 1;
+	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
+	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
+	pciBarMap[bar].addrWin.size = TBL_TERM;
+	pciBarMap[bar].enable = TBL_TERM;
+
+
+	/* Memory Mapped Internal Registers BAR can not be disabled.		*/
+	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
+	if (MV_OK != mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR, &pciBarMap[MEM_INTER_REGS_BAR])) {
+		mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	/* Now, go through all targets in default table until table terminator	*/
+	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++) {
+		/* Skip the P2P BARs. They should be configured seperately			*/
+		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
+			continue;
+
+		/* check if the size passed is zero ! */
+		if (0 == pciBarMap[bar].addrWin.size) {
+			/* disable the bar */
+			mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+			continue;
+		}
+
+		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
+			mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet %d failed\n", bar);
+			return MV_ERROR;
+		}
+	}
+
+	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf), PADCR_REMAP_REG_WR_DIS);
+
+	/* configure access control unit 0 to DDR to enhance performance */
+	pciProtWin.addrWin.baseLow = 0;
+	pciProtWin.addrWin.baseHigh = 0;
+	pciProtWin.addrWin.size = mvDramIfSizeGet();
+#ifdef AURORA_IO_CACHE_COHERENCY
+	pciProtWin.attributes.snoop = WT_CACHE_COHER;
+#else
+	pciProtWin.attributes.snoop = NO_CACHE_COHER;
+#endif
+	pciProtWin.attributes.access = ALLOWED;
+	pciProtWin.attributes.write = ALLOWED;
+	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
+	pciProtWin.attributes.readMaxBurst = 128;
+	pciProtWin.attributes.readBurst = 256;
+	pciProtWin.attributes.writeMaxBurst = 128;
+	pciProtWin.attributes.pciOrder = MV_FALSE;
+	pciProtWin.enable = MV_TRUE;
+	if (mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK) {
+		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	mvPciHalInit(pciIf, pciIfmod);
+
+	return MV_OK;
+}
+
+
+
+/*******************************************************************************
+* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
+*
+* DESCRIPTION:
+*       This function sets an address window from PCI to a peripheral
+*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs.
+*       A new PCI BAR window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing PCI to access
+*       the target window.
+*
+* INPUT:
+*       pciIf       - PCI interface number.
+*       bar         - BAR to be accessed by slave.
+*       pAddrBarWin - PCI target window information data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params
+*       MV_ERROR otherwise
+*       (e.g. address window overlapps with other active PCI target window).
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinSet(MV_U32			pciIf,
+				enum _mvPCIBars		bar,
+				struct _mvPciBarWin	*pAddrBarWin)
+{
+	MV_U32 pciData;
+	MV_U32 sizeToReg;
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	struct _pciBarRegInfo barRegInfo;
+
+	size	= pAddrBarWin->addrWin.size;
+	baseLow	= pAddrBarWin->addrWin.baseLow;
+	baseHigh = pAddrBarWin->addrWin.baseHigh;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* if the address windows is disabled , we only disable the appropriare
+	pci bar and ignore other settings */
+
+	if (MV_FALSE == pAddrBarWin->enable) {
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+		return MV_OK;
+	}
+
+	if (0 == pAddrBarWin->addrWin.size) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec */
+	if (MV_TRUE != pciWinIsValid(baseLow, size)) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin)) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Overlap detected for target %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Get size register value according to window size */
+	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
+
+	/* Size parameter validity check */
+	if (-1 == sizeToReg) {
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target			*/
+	if (0 != barRegInfo.sizeRegOffs) {
+		/* Update size register */
+		MV_REG_WRITE(barRegInfo.sizeRegOffs, (sizeToReg << BAR_SIZE_OFFS));
+	}
+
+	/* Read current address */
+	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+				barRegInfo.baseLowRegOffs);
+
+	/* Clear current address */
+	pciData &= ~PBBLR_BASE_MASK;
+	pciData |= (baseLow & PBBLR_BASE_MASK);
+
+	/* Write new address */
+	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+			barRegInfo.baseLowRegOffs, pciData);
+
+	/* Skip base high settings if the BAR has only base low (32-bit) */
+	if (0 != barRegInfo.baseHighRegOffs) {
+		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+				barRegInfo.baseHighRegOffs, baseHigh);
+	}
+
+	/* Enable/disable the BAR */
+	if (MV_TRUE == pAddrBarWin->enable)
+		MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	else
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinGet - Get PCI to peripheral target address window
+*
+* DESCRIPTION:
+*		Get the PCI to peripheral target address window BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*       bar   - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       pAddrBarWin - PCI target window information data structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, enum _mvPCIBars bar,
+			struct _mvPciBarWin *pAddrBarWin)
+{
+	MV_U32			size;
+	MV_U32			baseLow;
+	MV_U32			baseHigh;
+	MV_U32			localBus;
+	MV_U32			localDev;
+	MV_U32			barEnable;
+	struct _pciBarRegInfo	barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Reading Base Low bar */
+	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+				barRegInfo.baseLowRegOffs);
+
+	baseLow &= PBBLR_BASE_MASK;
+
+	/* Skip base high if the BAR has only base low (32-bit) */
+	if (0 != barRegInfo.baseHighRegOffs) {
+		/* Reading Base High */
+		baseHigh = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum,
+					barRegInfo.baseHighRegOffs);
+	} else
+		baseHigh = 0;
+
+	/* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target			*/
+	if (0 != barRegInfo.sizeRegOffs) {
+		/* Reading bar size*/
+		size = ctrlRegToSize((MV_REG_READ(barRegInfo.sizeRegOffs) >> PBSR_SIZE_OFFS),
+					PBBLR_BASE_ALIGNMET);
+	} else
+		size = INTER_REGS_SIZE;
+
+	/* Assign value to user struct */
+	pAddrBarWin->addrWin.baseLow	= baseLow;
+	pAddrBarWin->addrWin.baseHigh	= baseHigh;
+	pAddrBarWin->addrWin.size	= size;
+
+	/* Check if window is enabled   */
+	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	if (~barEnable & (BARER_ENABLE(bar)))
+		pAddrBarWin->enable = MV_TRUE;
+	else
+		pAddrBarWin->enable = MV_FALSE;
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetWinEnable - Enable/disable a PCI BAR window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI BAR window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling PCI accesses for that BAR (before enabling the
+*       window it is tested for overlapping). Otherwise, the window will
+*       be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       bar    - BAR to be accessed by slave.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, enum _mvPCIBars bar, MV_BOOL enable)
+{
+	struct _mvPciBarWin barWin;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS) {
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TRUE == enable) {
+		/* First check for overlap with other enabled windows */
+		/* Get current window */
+		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin)) {
+			mvOsPrintf("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+
+		/* Check for overlapping */
+		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin)) {
+			/* Overlap detected */
+			mvOsPrintf("mvPciTargetWinEnable: ERR. Overlap detected\n");
+			return MV_ERROR;
+		} else
+			/* No Overlap. Enable address decode target window */
+			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	} else
+		/* Disable address decode target window */
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinSet - Set PCI protection access window
+*
+* DESCRIPTION:
+*       This function sets a specified address window with access protection
+*       attributes. If protection structure enables the window the routine will
+*       also enable the protection window.
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - Protection window structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinSet(MV_U32		pciIf,
+			MV_U32			winNum,
+			struct _mvPciProtWin	*pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN)	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec */
+	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow,
+					pProtWin->addrWin.size)) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
+			pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
+
+		return MV_BAD_PARAM;
+	}
+
+	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX) {
+		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
+			pProtWin->attributes.swapType);
+		return MV_BAD_PARAM;
+	}
+
+	/* 1) Calculate protection window base low register value */
+	protBaseLow = pProtWin->addrWin.baseLow;
+
+	/* Setting the appropriate bits according to the passed values */
+	if (MV_TRUE == pProtWin->enable)
+		protBaseLow |= PACBLR_EN;
+	else
+		protBaseLow &= ~PACBLR_EN;
+
+	/* I/O Cache Coherency */
+	protBaseLow |= ((MV_U32)pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
+
+	/* Access protect */
+	if (ALLOWED == pProtWin->attributes.access)
+		protBaseLow &= ~PACBLR_ACCPROT;
+	else
+		protBaseLow |= PACBLR_ACCPROT;
+
+	/* Write Protect */
+	if (ALLOWED == pProtWin->attributes.write)
+		protBaseLow &= ~PACBLR_WRPROT;
+	else
+		protBaseLow |= PACBLR_WRPROT;
+
+	/* PCI slave Data Swap Control */
+	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
+
+	/* Read Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS);
+
+
+	/* Typical PCI read transaction Size. Only valid for PCI conventional */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS);
+
+
+	/* 2) Calculate protection window base high register value */
+	protBaseHigh = pProtWin->addrWin.baseHigh;
+
+	/* 3) Calculate protection window size register value	*/
+	protSize = ctrlSizeToReg(pProtWin->addrWin.size, PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
+
+	/* Write Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE) {
+		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
+		return MV_ERROR;
+	}
+	protSize |= (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (MV_TRUE == pProtWin->attributes.pciOrder)
+		protSize |= PACSR_PCI_ORDERING;
+	else
+		protSize &= ~PACSR_PCI_ORDERING;
+
+	/* Writing protection window walues into registers */
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), protBaseLow);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum), protBaseHigh);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum), protSize);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciProtWinGet - Get PCI protection access window
+*
+* DESCRIPTION:
+*       This function gets a specified address window and access protection
+*       attributes for a specific protection window .
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - pointer to a Protection window structure.
+*
+* OUTPUT:
+*       pProtWin - Protection window structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinGet(MV_U32		pciIf,
+			MV_U32			winNum,
+			struct _mvPciProtWin	*pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN) {
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Writing protection window walues into registers */
+	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum));
+	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf, winNum));
+	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf, winNum));
+
+	/* 1) Get Protection Windows base low */
+	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
+
+	/* Get the appropriate protection attributes according to register bits */
+
+	/* Is Windows enabled ? */
+	if (protBaseLow & PACBLR_EN)
+		pProtWin->enable = MV_TRUE;
+	else
+		pProtWin->enable = MV_FALSE;
+
+
+	/* What is access protect ? */
+	if (protBaseLow & PACBLR_ACCPROT)
+		pProtWin->attributes.access = FORBIDDEN;
+	else
+		pProtWin->attributes.access = ALLOWED;
+
+	/* Is write protect ? */
+	if (protBaseLow & PACBLR_WRPROT)
+		pProtWin->attributes.write = FORBIDDEN;
+	else
+		pProtWin->attributes.write = ALLOWED;
+
+	/* PCI slave Data Swap Control */
+	pProtWin->attributes.swapType = (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
+
+	/* Read Max Burst */
+	pProtWin->attributes.readMaxBurst =
+		pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >> PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. */
+	pProtWin->attributes.readBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >> PACBLR_RDSIZE_OFFS);
+
+
+	/* window base high register value */
+	pProtWin->addrWin.baseHigh = protBaseHigh;
+
+	/*Calculate protection window size register value */
+	pProtWin->addrWin.size = ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS), PACSR_SIZE_ALIGNMENT);
+
+	/* Write Max Burst */
+	pProtWin->attributes.writeMaxBurst = pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >> PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (protSize & PACSR_PCI_ORDERING)
+		pProtWin->attributes.pciOrder = MV_TRUE;
+	else
+		pProtWin->attributes.pciOrder = MV_FALSE;
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinEnable - Enable/disable a PCI protection access window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI protection access window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       protection window, otherwise, the protection window will be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       winNum - Protecion window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN) {
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TRUE == enable)
+		MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), PACBLR_EN);
+	else
+		MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf, winNum), PACBLR_EN);
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetRemap - Set PCI to target address window remap.
+*
+* DESCRIPTION:
+*       The PCI interface supports remap of the BAR original address window.
+*       For each BAR it is possible to define a remap address. For example
+*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
+*       according to remap register but will also be targeted to the
+*       SDRAM CS[0].
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       bar      - Peripheral target enumerator accessed by slave.
+*       pAddrWin - Address window to be checked.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetRemap(MV_U32	pciIf,
+			enum _mvPCIBars	bar,
+			MV_ADDR_WIN	*pAddrWin)
+{
+	struct _pciBarRegInfo barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT)) {
+		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
+			"\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			pciIf,
+			pciBarNameGet(bar),
+			pAddrWin->baseLow,
+			pAddrWin->size);
+		return MV_ERROR;
+	}
+
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Set remap low register value */
+	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
+
+	/* Skip base high settings if the BAR has only base low (32-bit) */
+	if (0 != barRegInfo.remapHighRegOffs)
+		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciWinOverlapDetect - Detect address windows overlapping
+*
+* DESCRIPTION:
+*       This function detects address window overlapping of a given address
+*       window in PCI BARs.
+*
+* INPUT:
+*       pAddrWin - Address window to be checked.
+*       bar      - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, enum _mvPCIBars bar, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32			barEnableReg;
+	MV_U32			targetBar;
+	struct _mvPciBarWin	barAddrWin;
+
+	/* Read base address enable register. Do not check disabled windows */
+	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+
+	for (targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
+		/* don't check our target or illegal targets */
+		if (targetBar == bar)
+			continue;
+
+		/* Do not check disabled windows */
+		if (barEnableReg & (BARER_ENABLE(targetBar)))
+			continue;
+
+		/* Get window parameters */
+		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+
+		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR*/
+		if (((bar == MEM_INTER_REGS_BAR) && (targetBar == IO_INTER_REGS_BAR)) ||
+			((bar == IO_INTER_REGS_BAR) && (targetBar == MEM_INTER_REGS_BAR)))
+			return MV_FALSE;
+		else if (MV_TRUE == mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: BAR %d overlap current %d\n", bar, targetBar);
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* cpuWinIsValid - Check if the given address window is valid
+*
+* DESCRIPTION:
+*	PCI spec restrict BAR base to be aligned to BAR size.
+*	This function checks if the given address window is valid.
+*
+* INPUT:
+*       baseLow - 32bit low base address.
+*       size    - Window size.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
+{
+	/* PCI spec restrict BAR base to be aligned to BAR size */
+	if (MV_IS_NOT_ALIGN(baseLow, size))
+		return MV_ERROR;
+	else
+		return MV_TRUE;
+}
+
+/*******************************************************************************
+* pciBarRegInfoGet - Get BAR register information
+*
+* DESCRIPTION:
+*	PCI BARs registers offsets are inconsecutive.
+*	This function gets a PCI BAR register information like register offsets
+*	and function location of the BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*	bar	  - The PCI BAR in question.
+*
+* OUTPUT:
+*       pBarRegInfo - BAR register info struct.
+*
+* RETURN:
+*	MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
+*
+*******************************************************************************/
+static MV_STATUS pciBarRegInfoGet(MV_U32		pciIf,
+				enum _mvPCIBars		bar,
+				struct _pciBarRegInfo	*pBarRegInfo)
+{
+	switch (bar) {
+	/* Function 0 Bars */
+	#if defined(MV_INCLUDE_SDRAM_CS0)
+	case CS0_BAR:		/* SDRAM chip select 0 bar*/
+		pBarRegInfo->funcNum		= 0;
+		pBarRegInfo->baseLowRegOffs	= PCI_SCS0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_SCS0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_CS0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_CS0_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	#if defined(MV_INCLUDE_SDRAM_CS1)
+	case CS1_BAR:		/* SDRAM chip select 1 bar*/
+		pBarRegInfo->funcNum		= 0;
+		pBarRegInfo->baseLowRegOffs	= PCI_SCS1_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_SCS1_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_CS1_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_CS1_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	case MEM_INTER_REGS_BAR: /* Memory Mapped Internal bar */
+		pBarRegInfo->funcNum		= 0;
+		pBarRegInfo->baseLowRegOffs	= PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
+		pBarRegInfo->baseHighRegOffs	= PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
+		pBarRegInfo->sizeRegOffs	= 0;
+		pBarRegInfo->remapLowRegOffs	= 0;
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+
+	/* Function 1 Bars */
+	#if defined(MV_INCLUDE_SDRAM_CS2)
+	case CS2_BAR:		/* SDRAM chip select 2 bar*/
+		pBarRegInfo->funcNum		= 1;
+		pBarRegInfo->baseLowRegOffs	= PCI_SCS2_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_SCS2_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_CS2_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_CS2_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	#if defined(MV_INCLUDE_SDRAM_CS3)
+	case CS3_BAR:		/* SDRAM chip select 3 bar*/
+		pBarRegInfo->funcNum		= 1;
+		pBarRegInfo->baseLowRegOffs	= PCI_SCS3_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_SCS3_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_CS3_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_CS3_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	#if defined(MV_INCLUDE_DEVICE_CS0)
+	/* Function 2 Bars */
+	case DEVCS0_BAR:	/* Device chip select 0 bar*/
+		pBarRegInfo->funcNum		= 2;
+		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_DEVCS0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	#if defined(MV_INCLUDE_DEVICE_CS1)
+	case DEVCS1_BAR:	/* Device chip select 0 bar*/
+		pBarRegInfo->funcNum		= 2;
+		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS1_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS1_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_DEVCS1_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	#if defined(MV_INCLUDE_DEVICE_CS2)
+	case DEVCS2_BAR:	/* Device chip select 0 bar*/
+		pBarRegInfo->funcNum		= 2;
+		pBarRegInfo->baseLowRegOffs	= PCI_DEVCS2_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_DEVCS2_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_DEVCS2_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+	#endif
+
+	case BOOTCS_BAR:	/* Boot device chip select bar*/
+		pBarRegInfo->funcNum		= 3;
+		pBarRegInfo->baseLowRegOffs	= PCI_BOOTCS_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_BOOTCS_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_BOOTCS_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+
+	/* Function 4 Bars */
+	case P2P_MEM0:		/* P2P memory 0 */
+		pBarRegInfo->funcNum		= 4;
+		pBarRegInfo->baseLowRegOffs	= PCI_P2P_MEM0_BASE_ADDR_LOW;
+		pBarRegInfo->baseHighRegOffs	= PCI_P2P_MEM0_BASE_ADDR_HIGH;
+		pBarRegInfo->sizeRegOffs	= PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
+		break;
+
+	case P2P_IO:		/* P2P IO */
+		pBarRegInfo->funcNum		= 4;
+		pBarRegInfo->baseLowRegOffs	= PCI_P2P_IO_BASE_ADDR;
+		pBarRegInfo->baseHighRegOffs	= 0;
+		pBarRegInfo->sizeRegOffs	= PCI_P2P_IO_BAR_SIZE_REG(pciIf);
+		pBarRegInfo->remapLowRegOffs	= PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+
+	case IO_INTER_REGS_BAR: /* IO Mapped Internal bar */
+		pBarRegInfo->funcNum		= 4;
+		pBarRegInfo->baseLowRegOffs	= PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
+		pBarRegInfo->baseHighRegOffs	= 0;
+		pBarRegInfo->sizeRegOffs	= 0;
+		pBarRegInfo->remapLowRegOffs	= 0;
+		pBarRegInfo->remapHighRegOffs	= 0;
+		break;
+
+	default:
+		mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
+		return MV_ERROR;
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciBarNameGet - Get the string name of PCI BAR.
+*
+* DESCRIPTION:
+*		This function get the string name of PCI BAR.
+*
+* INPUT:
+*       bar - PCI bar number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       pointer to the string name of PCI BAR.
+*
+*******************************************************************************/
+const MV_8 *pciBarNameGet(enum _mvPCIBars bar)
+{
+	switch (bar) {
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	case CS0_BAR:
+		return "CS0_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	case CS1_BAR:
+		return "CS1_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	case CS2_BAR:
+		return "CS2_BAR..............";
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	case CS3_BAR:
+		return "CS3_BAR..............";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	case DEVCS0_BAR:
+		return "DEVCS0_BAR...........";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	case DEVCS1_BAR:
+		return "DEVCS1_BAR...........";
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	case DEVCS2_BAR:
+		return "DEVCS2_BAR...........";
+#endif
+	case BOOTCS_BAR:
+		return "BOOTCS_BAR...........";
+	case MEM_INTER_REGS_BAR:
+		return "MEM_INTER_REGS_BAR...";
+	case IO_INTER_REGS_BAR:
+		return "IO_INTER_REGS_BAR....";
+	case P2P_MEM0:
+		return "P2P_MEM0.............";
+	case P2P_IO:
+		return "P2P_IO...............";
+	default:
+		 return "target unknown";
+	}
+}
+
+/*******************************************************************************
+* mvPciAddrDecShow - Print the PCI address decode map (BARs).
+*
+* DESCRIPTION:
+*		This function print the PCI address decode map (BARs).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvPciAddrDecShow(MV_VOID)
+{
+	struct _mvPciBarWin	win;
+	enum _mvPCIBars		bar;
+	MV_U32			pciIf;
+
+	for (pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++) {
+		mvOsOutput("\n");
+		mvOsOutput("PCI%d:\n", pciIf);
+		mvOsOutput("-----\n");
+
+		for (bar = 0; bar < PCI_MAX_BARS; bar++) {
+			memset(&win, 0, sizeof(struct _mvPciBarWin));
+
+			mvOsOutput("%s ", pciBarNameGet(bar));
+
+			if (mvPciTargetWinGet(pciIf, bar, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("base %08x, ", win.addrWin.baseLow);
+					mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+}
+
+/* convert burst bytes to register value*/
+static MV_U32 pciBurstBytes2Reg(MV_U32 size)
+{
+	MV_U32 ret;
+
+	switch (size) {
+	case 32:
+		ret = 0;
+		break;
+	case 64:
+		ret = 1;
+		break;
+	case 128:
+		ret = 2;
+		break;
+	case 256:
+		ret = 3;
+		break;
+	default:
+		ret = 0xF; /* error */
+	}
+	return ret;
+}
+
+/* convert register value to burst bytes*/
+static MV_U32 pciBurstReg2Bytes(MV_U32 size)
+{
+	MV_U32 ret;
+
+	switch (size) {
+	case 0:
+		ret = 32;
+		break;
+	case 1:
+		ret = 64;
+		break;
+	case 2:
+		ret = 128;
+		break;
+	case 3:
+		ret = 256;
+		break;
+	default:
+		ret = 0x0; /* error */
+	}
+	return ret;
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPci.h b/arch/arm/mach-msys/mv_hal_if/mvSysPci.h
new file mode 100644
index 0000000..29abf28
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysPci.h
@@ -0,0 +1,251 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCSysPCIH
+#define __INCSysPCIH
+
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "pci/mvPci.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvSysPciConfig.h"
+
+#define PCI_MAX_PROT_WIN			6
+
+/* 4KB granularity */
+#define MINIMUM_WINDOW_SIZE			0x1000
+#define MINIMUM_BAR_SIZE			0x1000
+#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
+#define BAR_SIZE_OFFS				12
+#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
+
+#define PCI_IO_WIN_NUM				1 /* Number of PCI_IO windows  */
+#define PCI_MEM_WIN_NUM				4 /* Number of PCI_MEM windows */
+
+#ifndef MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvLib.h"
+enum _mvPCIBars {
+	PCI_BAR_TBL_TERM = -1, /* none valid bar, used as bars list terminator */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	CS0_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	CS1_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	CS2_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	CS3_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEVCS0_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEVCS1_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEVCS2_BAR,
+#endif
+	BOOTCS_BAR,		/* Boot device chip select bar*/
+	MEM_INTER_REGS_BAR,	/* Memory Mapped Internal bar */
+	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
+	P2P_MEM0,		/* P2P memory 0 */
+	P2P_IO,			/* P2P IO */
+	PCI_MAX_BARS
+} MV_PCI_BAR;
+#endif /* MV_ASMLANGUAGE */
+
+#if defined(MV_INCLUDE_SDRAM_CS3)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS3_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS2)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS1)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS0)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
+#endif
+
+
+/****************************************/
+/* PCI Slave Address Decoding registers */
+/****************************************/
+#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
+#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
+#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
+#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
+#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80))
+#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80))
+#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80))
+#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80))
+#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80))
+#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80))
+#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
+#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
+#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
+
+/* PCI Bars Size Registers (PBSR) */
+#define PBSR_SIZE_OFFS				12
+#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
+
+/* Base Address Registers Enable Register (BARER) */
+#define BARER_ENABLE(target)			(1 << (target))
+
+/* PCI Base Address Remap Registers (PBARR) */
+#define PBARR_REMAP_OFFS			12
+#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
+#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
+
+/* PCI DRAM Bar Bank Select Register (PDBBSR) */
+#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
+#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
+
+/* PCI Address Decode Control Register (PADCR)*/
+#define PADCR_REMAP_REG_WR_DIS			BIT0
+#define PADCR_MSG_REG_ACC			BIT3
+
+#define PADCR_VPD_HIGH_ADDR_OFFS		8 /* Bits [31:15] of the VPD address */
+#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
+
+/* PCI Headers Retarget Control Register (PHRCR) */
+#define PHRCR_ENABLE				BIT0
+#define PHRCR_BUFF_SIZE_OFFS			1
+#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_MASK1_OFFS			16
+#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
+
+/* PCI Headers Retarget Base Register (PHRBR) */
+#define PHRBR_BASE_OFFS				16
+#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
+
+/* PCI Headers Retarget Base High Register (PHRBHR) */
+#define PHRBHR_BASE_OFFS			0
+#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
+
+/* This structure describes a PCI BAR. It is also refered as PCI target     */
+/* window to keep consistency with other address decode units in the system */
+struct _mvPciBarWin {
+	MV_ADDR_WIN	addrWin;	/* Address window	*/
+	MV_BOOL		enable;		/* BAR enable/disable	*/
+};
+
+enum _mvPciSnoop {
+	NO_CACHE_COHER = 0,
+	WT_CACHE_COHER,
+	WB_CACHE_COHER
+};
+
+/* This structure describes PCI region attributes */
+struct _mvPciRegionAttr {
+	enum _mvPciSnoop	snoop;		/* Cache Coherenc			*/
+	MV_PROT_RIGHT	access;		/* Access protection			*/
+	MV_PROT_RIGHT	write;		/* Write protection			*/
+	MV_SWAP_TYPE	swapType;	/* Data swap mode for that region	*/
+	MV_U32		readMaxBurst;	/* Read max burst			*/
+	MV_U32		readBurst;	/* Read burst. Conventional PCI only	*/
+	MV_U32		writeMaxBurst;	/* Write max burst			*/
+	MV_BOOL		pciOrder;	/* Hardware support for PCI ordering	*/
+};
+
+/* The PCI slave interface supports configurable access control		*/
+/* It is possible to define up to six address ranges to different	*/
+/* configurations. This structure describes the PCI access region	*/
+struct _mvPciProtWin {
+	MV_ADDR_WIN		addrWin;	/* An address window		*/
+	struct _mvPciRegionAttr	attributes;	/* Window attributes		*/
+	MV_BOOL			enable;		/* Window enabled/disabled	*/
+};
+
+/* Global Functions prototypes */
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, enum _mvPCIBars slaveTarget, struct _mvPciBarWin *pAddrBarWin);
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, enum _mvPCIBars slaveTarget, struct _mvPciBarWin *pAddrBarWin);
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, enum _mvPCIBars slaveTarget, MV_BOOL enable);
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum, struct _mvPciProtWin *pProtWin);
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum, struct _mvPciProtWin *pProtWin);
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, enum _mvPCIBars slaveTarget, MV_ADDR_WIN *pAddrWin);
+MV_VOID mvPciAddrDecShow(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPex.c b/arch/arm/mach-msys/mv_hal_if/mvSysPex.c
new file mode 100644
index 0000000..db1da19
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysPex.c
@@ -0,0 +1,103 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+/*******************************************************************************
+* mvSysPexInit - Initialize the Pex subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
+{
+	MV_PEX_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status == MV_OK)
+		status = mvPexWinInit(pexIf, pexType, addrWinMap);
+
+	if (status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.maxPexIf = mvCtrlPexMaxIfGet();
+		halData.ctrlFamily = mvCtrlDevFamilyIdGet(halData.ctrlModel);
+		status = mvPexInit(pexIf, pexType, &halData);
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysPexApi.h b/arch/arm/mach-msys/mv_hal_if/mvSysPexApi.h
new file mode 100644
index 0000000..6706353
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysPexApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_PEX_API_H__
+#define __MV_SYS_PEX_API_H__
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
+
+#endif
diff --git a/arch/arm/mach-msys/pci.c b/arch/arm/mach-msys/pci.c
new file mode 100644
index 0000000..9a6d739
--- /dev/null
+++ b/arch/arm/mach-msys/pci.c
@@ -0,0 +1,246 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysPci.h"
+#include "pci/mvPci.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x)
+#endif
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+
+	if (mvCtrlPciMaxIfGet() > 1)
+		panic("Single PCI is supported ONLY!");
+
+	mvPciInit(0, MV_PCI_MOD_HOST);
+
+	/* I/O remmap */
+	win.baseLow = 0x0;
+	win.baseHigh = 0x0;
+	mvCpuIfPciRemap(PCI_IF0_IO, &win);
+}
+
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+   read config WA will be removed.
+*/
+static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+				int size, u32 *val)
+{
+	MV_U32 bus_num, func, regOff, dev_no, temp;
+	MV_U32 localBus;
+
+	*val = 0xffffffff;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPciLocalBusNumGet(0);
+	if ((dev_no == 0) && (bus_num == localBus)) {
+		DB(printk(KERN_DEBUG "PCI 0 read from our own dev return 0xffffffff\n"));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	if ((func == 0) && (dev_no < 2))
+		DB(printk(KERN_DEBUG "PCI 0 read: bus = %x dev = %x func = %x regOff = %x",
+			bus_num, dev_no, func, regOff));
+
+	temp = (u32)mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+
+	switch (size) {
+	case 1:
+		temp = (temp >> (8*(where & 0x3))) & 0xff;
+		break;
+
+	case 2:
+		temp = (temp >> (8*(where & 0x2))) & 0xffff;
+		break;
+
+	default:
+		break;
+	}
+
+	*val = temp;
+
+	if ((func == 0) && (dev_no < 2))
+		DB(printk(KERN_DEBUG " got %x\n", temp));
+
+	return 0;
+}
+
+static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+				int size, u32 val)
+{
+	MV_U32 bus_num, func, regOff, dev_no, temp, mask, shift;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	DB(printk(KERN_DEBUG "PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x\n",
+			val, size, bus_num, dev_no, func, regOff));
+	if (size != 4)
+		temp = (u32)mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+	switch (size) {
+	case 1:
+		shift = (8 * (where & 0x3));
+		mask = 0xff;
+		break;
+
+	case 2:
+		shift = (8 * (where & 0x2));
+		mask = 0xffff;
+		break;
+
+	default:
+		shift = 0;
+		mask = 0xffffffff;
+		break;
+	}
+
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
+
+	return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+	.read	= mv_pci0_read_config,
+	.write	= mv_pci0_write_config,
+};
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	sys->map_irq = mv_map_irq;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+		panic("PCI: unable to alloc resources");
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
+	res[0].end   =  mv_pci_io_base_get(0) - IO_SPACE_REMAP + mv_pci_io_size_get(0) - 1;
+	res[0].name  = "PCI0 IO Primary";
+	res[0].flags = IORESOURCE_IO;
+
+	res[1].start =  mv_pci_mem_base_get(0);
+	res[1].end   =  mv_pci_mem_base_get(0) + mv_pci_mem_size_get(0) - 1;
+	res[1].name  = "PCI0 Memory Primary";
+	res[1].flags = IORESOURCE_MEM;
+
+	if (request_resource(&ioport_resource, &res[0]))
+		printk(KERN_ERROR "IO Request resource failed - Pci If %x\n", nr);
+
+	if (request_resource(&iomem_resource, &res[1]))
+		printk(KERN_ERROR "Memory Request resource failed - Pci If %x\n", nr);
+
+	pci_add_resource(&sys->resources, &res[0]);
+	pci_add_resource(&sys->resources, &res[1]);
+	sys->io_offset = 0x0;
+
+	return 1;
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops;
+	struct pci_bus *bus;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	ops = &mv_pci_ops;
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCI0;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle	= pci_std_swizzle,
+	.map_irq	= mv_map_irq,
+	.setup		= mv_pci_setup,
+	.scan		= mv_pci_scan_bus,
+	.preinit	= mv_pci_preinit,
+};
+
+static int __init mv_pci_init(void)
+{
+	MV_U32 ifnum = mvCtrlPciMaxIfGet();
+	if (ifnum) {
+		mv_pci.nr_controllers = ifnum;
+		pci_common_init(&mv_pci);
+	}
+
+	return 0;
+}
+
+subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-msys/pex.c b/arch/arm/mach-msys/pex.c
new file mode 100644
index 0000000..14cf11d
--- /dev/null
+++ b/arch/arm/mach-msys/pex.c
@@ -0,0 +1,598 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "pex/mvPexRegs.h"
+#include "mvSysPexApi.h"
+
+#ifdef MV_DEBUG
+#	define DB(x) x
+#else
+#	define DB(x)
+#endif
+
+#define MV_PEX_MASK_ABCD	(BIT24 | BIT25 | BIT26 | BIT27)
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_4(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_5(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_6(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_7(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_8(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_9(const struct pci_dev *dev, u8 slot, u8 pin);
+
+static struct platform_device mv_pex = {
+	.name		= "mv_pex",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static void *mv_get_irqmap_func[] __initdata = {
+	mv_map_irq_0,
+	mv_map_irq_1,
+	mv_map_irq_2,
+	mv_map_irq_3,
+	mv_map_irq_4,
+	mv_map_irq_5,
+	mv_map_irq_6,
+	mv_map_irq_7,
+	mv_map_irq_8,
+	mv_map_irq_9
+};
+
+void __init mv_pex_preinit(void)
+{
+	static MV_U32 pex0flg = -1;
+	unsigned int pciIf, temp;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pciIf = 0; pciIf < boardPexInfo->boardPexIfNum; pciIf++) {
+		/* Translate logical interface number to physical */
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		printk(KERN_INFO "PCI-E: Checking physical bus #%d (controller #%d): ", pciIf, pexHWInf);
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf)) {
+			printk("KERN_INFO Disabled\n");
+			continue;
+		}
+
+		/* init the PCI interface */
+		temp = mvSysPexInit(pexHWInf, MV_PEX_ROOT_COMPLEX);
+
+		if (MV_NO_SUCH == temp) {
+			printk(KERN_INFO "Enabled - No Link\n");
+
+			/* No Link - shutdown interface */
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pexHWInf, MV_FALSE);
+			continue;
+		} else if ((MV_OK != temp) && (MV_NO_SUCH != temp)) {
+			printk(KERN_INFO "Init FAILED!!!\n");
+			printk(KERN_INFO "PCI-E %d: Init Failed.\n", pexHWInf);
+		}
+
+		printk(KERN_INFO "Enabled - Link UP\n");
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == -1) {
+			mvPexLocalBusNumSet(pexHWInf, 0x0);
+			mvPexLocalDevNumSet(pexHWInf, 0x1);
+			pex0flg = 1;
+		}
+
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pexHWInf), 0);
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
+		if (mv_is_pci_io_mapped()) {
+			pciIoRemap.baseLow = mv_pci_io_base_get() - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0;
+			pciIoRemap.size = mv_pci_io_size_get();
+			mvCpuIfPexRemap(mv_pci_io_target_get(), &pciIoRemap);
+		}
+	}
+}
+
+void mv_pex_reinit(void)
+{
+	static MV_U32 pex0flg = -1;
+	unsigned int pciIf, temp;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pciIf = 0; pciIf < boardPexInfo->boardPexIfNum; pciIf++) {
+		/* Translate logical interface number to physical */
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		/* init the PCI interface */
+		temp = mvSysPexInit(pexHWInf, MV_PEX_ROOT_COMPLEX);
+
+		if (MV_NO_SUCH == temp) {
+			/* No Link - shutdown interface */
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pexHWInf, MV_FALSE);
+			continue;
+		}
+
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == -1) {
+			mvPexLocalBusNumSet(pexHWInf, 0x0);
+			mvPexLocalDevNumSet(pexHWInf, 0x1);
+			pex0flg = 1;
+		}
+
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pexHWInf), 0);
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
+		if (mv_is_pci_io_mapped(pexHWInf)) {
+			pciIoRemap.baseLow = mv_pci_io_base_get() - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0;
+			pciIoRemap.size = mv_pci_io_size_get();
+			mvCpuIfPexRemap(mv_pci_io_target_get(), &pciIoRemap);
+		}
+	}
+}
+
+static int pci_read_cfg(u32 pciIf, u32 bus_num, u32 dev_no,
+			u32 func, u32 where)
+{
+	u32 cfgCmd;
+	u32 regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK
+			| PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	/* Creating PEX address to be passed */
+	cfgCmd	= (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+
+	/* lgacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+			PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the
+	 * read transaction we perform a validity check that the address
+	 * was written
+	 * */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf)))
+		return 0xFFFFFFFF;
+
+	/* cleaning Master Abort */
+	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pciIf, PEX_STATUS_AND_COMMAND),
+			PXSAC_MABORT);
+
+	/* Read the Data returned in the PEX Data register */
+	return  MV_REG_READ(PEX_CFG_DATA_REG(pciIf));
+}
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+   read config WA will be removed.
+*/
+static int mv_pci_read_config(struct pci_bus *bus,
+				unsigned int devfn, int where,
+				int size, u32 *val)
+{
+	u32 bus_num, func, dev_no, temp, localBus;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+	u32 pciIf = sysdata->mv_controller_num;
+
+	*val = 0xffffffff;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* Our local bus is PEX so enable reading only device 0 */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if ((dev_no !=  0) && (bus_num == localBus)) {
+		DB(pr_info("PCI %d device %d illegal on local bus\n", pciIf,
+					dev_no));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn);
+
+	temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
+
+	switch (size) {
+	case 1:
+		temp = (temp >> (8*(where & 0x3))) & 0xff;
+		break;
+
+	case 2:
+		temp = (temp >> (8*(where & 0x2))) & 0xffff;
+		break;
+
+	default:
+		break;
+	}
+
+	*val = temp;
+
+	DB(pr_info("PCI %d read: bus = %x dev = %x", pciIf, bus_num, dev_no));
+	DB(pr_info(" func = %x regOff = %x val = 0x%08x\n", func, where, temp));
+
+	return 0;
+}
+
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+		int where, int size, u32 val)
+{
+	u32 bus_num, func, regOff, dev_no, temp, mask, shift;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
+	u32 pciIf = sysdata->mv_controller_num;
+	u32 cfgCmd;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0xFFFFFFFF;
+
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+
+	/* total of 12 bits: 8 legacy + 4 extended */
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK |
+			PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	if (size != 4)
+		temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
+	else
+		temp = val;
+
+	switch (size) {
+	case 1:
+		shift = (8 * (where & 0x3));
+		mask = 0xff;
+		break;
+	case 2:
+		shift = (8 * (where & 0x2));
+		mask = 0xffff;
+		break;
+	default:
+		shift = 0;
+		mask = 0xffffffff;
+		break;
+	}
+
+	temp = (temp & (~(mask << shift))) | ((val & mask) << shift);
+
+	/* Creating PEX address to be passed */
+	cfgCmd = (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+
+	/* legacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+			PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	DB(pr_info("PCI %d: write data 0x%08x size %x to bus", pciIf, temp, size));
+	DB(pr_info(" %x dev %x func %x offs %x\n", bus_num, dev_no, func, regOff));
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the read
+	 * transaction we perform a validity check that the address was written
+	 */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf))) {
+		pr_info("Error: mv_pci_write_config failed to write\n");
+		return 1;
+	}
+
+	/* Write the Data passed to the PEX Data register */
+	MV_REG_WRITE(PEX_CFG_DATA_REG(pciIf), temp);
+
+	return 0;
+}
+
+
+static struct pci_ops mv_pci_ops = {
+	.read	= mv_pci_read_config,
+	.write	= mv_pci_write_config,
+};
+
+
+int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+	u32 membase, iobase, index = 0;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	/* Translate logical interface number to physical */
+	pexHWInf = boardPexInfo->pexMapping[nr];
+
+	if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+		return 0;
+
+	/* Check if this interface is used or not */
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+		return 0;
+
+	/* Allocate resources memory */
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res) {
+		panic("PCI: unable to alloc resources");
+		return 0;
+	}
+
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	/* Save the H/W if number for this PEX bus */
+	sys->mv_controller_num = pexHWInf;
+	sys->map_irq = mv_get_irqmap_func[sys->mv_controller_num];
+
+	membase = mv_pci_mem_base_get();
+	if (mv_is_pci_io_mapped(sys->mv_controller_num)) {
+		iobase = mv_pci_io_base_get();
+		res[index].start	= iobase - IO_SPACE_REMAP;
+		res[index].end		= iobase - IO_SPACE_REMAP + mv_pci_io_size_get() - 1;
+		res[index].name		= "PCIx IO Primary";
+		res[index].flags	= IORESOURCE_IO;
+
+		if (request_resource(&ioport_resource, &res[index]))
+			printk(KERN_ERROR "IO Request resource failed - Pci If %x\n", nr);
+		else
+			index++;
+	}
+	res[index].start	= membase;
+	res[index].end		= membase + mv_pci_mem_size_get() - 1;
+	res[index].name		= "PCIx Memory Primary";
+	res[index].flags	= IORESOURCE_MEM;
+
+	if (request_resource(&iomem_resource, &res[index]))
+		printk(KERN_ERROR "Memory Request resource failed - Pci If %x\n", nr);
+
+	pci_add_resource(&sys->resources, &res[0]);
+	if (index > 0)
+		pci_add_resource(&sys->resources, &res[1]);
+
+	sys->io_offset = 0x0;
+	return 1;
+}
+
+
+struct pci_bus * __devinit mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops = &mv_pci_ops;
+	struct pci_bus *bus;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexNextHWInf, ifnum;
+
+	bus =  pci_scan_root_bus(NULL, sys->busnr, &mv_pci_ops, sys, &sys->resources);
+
+	/* Set the bus number in the following controller */
+	for (ifnum = (nr+1); ifnum < boardPexInfo->boardPexIfNum; ifnum++) {
+		pexNextHWInf = boardPexInfo->pexMapping[ifnum];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexNextHWInf))
+			continue;
+
+		if (MV_TRUE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexNextHWInf)) {
+			mvPexLocalBusNumSet(pexNextHWInf, (bus->subordinate + 1));
+			mvPexLocalDevNumSet(pexNextHWInf, 0x1);
+			break;
+		}
+	}
+
+	return bus;
+}
+
+
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE0;
+}
+
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE1;
+}
+
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE2;
+}
+
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE3;
+}
+
+static int __init mv_map_irq_4(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE4;
+}
+
+static int __init mv_map_irq_5(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE5;
+}
+
+static int __init mv_map_irq_6(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE6;
+}
+
+static int __init mv_map_irq_7(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE7;
+}
+
+static int __init mv_map_irq_8(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE8;
+}
+
+static int __init mv_map_irq_9(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE9;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle	= pci_std_swizzle,
+	.setup		= mv_pex_setup,
+	.scan		= mv_pex_scan_bus,
+	.preinit	= mv_pex_preinit,
+};
+
+static int mv_pex_probe(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int pex_status[MV_PEX_MAX_IF];
+static int pex_ifnum;
+
+static int mv_pex_suspend(struct platform_device *dev, pm_message_t state)
+{
+	unsigned int pciIf;
+	MV_U32 pexHWInf = 0;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+
+	/* Save PCI Express status Register */
+	for (pciIf = 0; pciIf < pex_ifnum; pciIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		pex_status[pexHWInf] = MV_REG_READ(PEX_STATUS_REG(pexHWInf));
+	}
+
+	return 0;
+}
+
+static int mv_pex_resume(struct platform_device *dev)
+{
+	unsigned int pciIf;
+	MV_U32 pexHWInf = 0;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+
+	mv_pex_reinit();
+
+	/* Restore PCI Express status Register */
+	for (pciIf = 0; pciIf < pex_ifnum; pciIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		MV_REG_WRITE(PEX_STATUS_REG(pexHWInf), pex_status[pexHWInf]);
+	}
+
+	return 0;
+}
+
+static struct platform_driver mv_pex_driver = {
+	.probe		= mv_pex_probe,
+#ifdef CONFIG_PM
+	.suspend	= mv_pex_suspend,
+	.resume		= mv_pex_resume,
+#endif /* CONFIG_PM */
+	.driver = {
+		.name = "mv_pex",
+	},
+};
+
+static int __init mv_pex_init_module(void)
+{
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+
+	mv_pci.nr_controllers = (mvBoardPexInfoGet())->boardPexIfNum;
+	mv_pci.swizzle		= pci_std_swizzle;
+	mv_pci.map_irq		= mv_map_irq_0;
+	mv_pci.setup		= mv_pex_setup;
+	mv_pci.scan		= mv_pex_scan_bus;
+	mv_pci.preinit		= mv_pex_preinit;
+	pci_common_init(&mv_pci);
+	platform_device_register(&mv_pex);
+
+	pex_ifnum = boardPexInfo->boardPexIfNum;
+
+	return platform_driver_register(&mv_pex_driver);
+}
+
+module_init(mv_pex_init_module);
+MODULE_DESCRIPTION("Marvell PEX Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-msys/platsmp.c b/arch/arm/mach-msys/platsmp.c
new file mode 100644
index 0000000..d6b7ad8
--- /dev/null
+++ b/arch/arm/mach-msys/platsmp.c
@@ -0,0 +1,264 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/unified.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "include/mach/smp.h"
+
+#include "irq.h"
+#include "platsmp.h"
+#include "sysmap.h"
+
+unsigned int master_cpu_id = -1;
+unsigned int group_cpu_mask = ((1 << 2) - 1);
+unsigned int mv_cpu_count = 2;
+
+unsigned int master_cpu_id_get(void)
+{
+	if (master_cpu_id == -1)
+		return 0;
+	return master_cpu_id;
+}
+
+unsigned int group_cpu_mask_get(void)
+{
+	return group_cpu_mask;
+}
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void msys_smp_cross_call(const struct cpumask *mask, unsigned int irqnr)
+{
+	unsigned long map = *cpus_addr(*mask);
+	void __iomem *addr = (void __iomem *)(MSYS_SW_TRIG_IRQ);
+
+	map = get_hw_cpu_mask(map);
+
+	writel((((map & 0xf) << 8) | irqnr), addr);
+
+	return;
+}
+
+static inline unsigned int get_sample_at_reset_core_count(void)
+{
+	/* Read the number of availabe CPUs in the SoC */
+	return (MV_REG_READ(SOC_COHERENCY_FABRIC_CFG_REG) & 0xF) + 1;
+}
+
+static unsigned int __init get_core_count(void)
+{
+	return mv_cpu_count;
+}
+
+void __init set_core_count(unsigned int cpu_count)
+{
+	/* Update cpu count */
+	mv_cpu_count = cpu_count;
+
+	/* Update group mask as well */
+	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
+}
+
+/*
+ * Platform intialization routine for seconday CPUs
+ */
+
+
+void  platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+#ifdef	CONFIG_SHEEVA_DEEP_IDLE
+	msys_fabric_restore_deepIdle();
+#endif
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	msys_ipi_init();
+#ifdef CONFIG_PCI_MSI
+	/* Support for MSI interrupts */
+	second_cpu_msi_init();
+#endif
+
+	smp_wmb();
+}
+
+int  boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	MV_U32 reg;
+
+	cpu = get_hw_cpu_id(cpu);
+
+	printk(KERN_INFO "SMP: CPU %d Waking up CPU %d\n", master_cpu_id_get(), cpu);
+
+	/* send ipi to wake cpu in case it is in offline state */
+	msys_smp_cross_call(cpumask_of(cpu), 0);
+
+	/* Set resume control and address */
+	MV_REG_WRITE(MSYS_CPU_RESUME_CTRL_REG, 0x0);
+	MV_REG_WRITE(MSYS_CPU_RESUME_ADDR_REG,
+			virt_to_phys(msys_secondary_startup));
+
+	dsb();
+
+	/* Kick secondary CPUs */
+	reg = MV_REG_READ(MSYS_CPU_RESET_REG(cpu));
+	reg = reg & ~(1 << MSYS_CPU_RESET_OFFS);
+	MV_REG_WRITE(MSYS_CPU_RESET_REG(cpu), reg);
+
+	mb();
+	udelay(10);
+
+	return 0;
+}
+
+static void init_coherency(void)
+{
+	MV_U32 reg;
+	MV_U32 core_bits;
+
+	core_bits = 1 << master_cpu_id_get();
+
+	/* Associate group cores to the same SMP group */
+	reg = MV_REG_READ(SOC_COHERENCY_FABRIC_CFG_REG);
+	reg |= (core_bits << 24);
+	MV_REG_WRITE(SOC_COHERENCY_FABRIC_CFG_REG, reg);
+
+	/* Enable Snooping on coherency fabric */
+	reg = MV_REG_READ(SOC_COHERENCY_FABRIC_CTRL_REG);
+	reg |= (core_bits << 24);
+	MV_REG_WRITE(SOC_COHERENCY_FABRIC_CTRL_REG, reg);
+}
+
+/*
+ * Initialize the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	MV_U32 i;
+	MV_U32 ncores = get_core_count();
+
+	printk(KERN_INFO "SMP: init cpus\n");
+
+	/* Set the HW CPU id of the master core */
+	master_cpu_id = hard_smp_processor_id();
+
+	/* Set CPU address decoding */
+	if (mvCpuIfInit(mv_sys_map())) {
+		printk(KERN_ERR "Cpu Interface initialization failed.\n");
+		return;
+	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(msys_smp_cross_call);
+}
+
+void smp_resume(void)
+{
+	init_coherency();
+
+	msys_ipi_init();
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	int i;
+
+	printk(KERN_INFO"SMP: prepare CPUs (%d cores)\n", ncores);
+
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR "strange CM count of 0? Default to 1\n");
+		ncores = 1;
+	}
+
+	if (ncores > num_possible_cpus()) {
+		printk(KERN_WARNING
+		       "no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, num_possible_cpus());
+		ncores = num_possible_cpus();
+	}
+
+	if ((ncores + master_cpu_id_get()) > num_possible_cpus()) {
+		printk(KERN_WARNING
+		       "Bad core count (%d) for SMP group starting at cpu no (%d). There is no CPU %d. Clipping\n",
+				ncores, master_cpu_id_get(), ncores + master_cpu_id_get());
+		ncores = (num_possible_cpus() - master_cpu_id_get());
+	}
+
+	if (ncores > get_sample_at_reset_core_count())
+		ncores = get_sample_at_reset_core_count();
+
+	/* Adjust core count in case fixing was done */
+	set_core_count(ncores);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+	for (i = 0; i < num_possible_cpus(); i++) {
+		set_cpu_possible(i, false);
+		set_cpu_present(i, false);
+	}
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++) {
+		set_cpu_possible(i, true);
+		set_cpu_present(i, true);
+	}
+
+	if (max_cpus > 1)
+		flush_cache_all();
+
+	init_coherency();
+}
diff --git a/arch/arm/mach-msys/platsmp.h b/arch/arm/mach-msys/platsmp.h
new file mode 100644
index 0000000..615dcd4
--- /dev/null
+++ b/arch/arm/mach-msys/platsmp.h
@@ -0,0 +1,32 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+unsigned int master_cpu_id_get(void);
+unsigned int group_cpu_mask_get(void);
+void msys_secondary_startup(void);
+void percpu_timer_setup(void);
diff --git a/arch/arm/mach-msys/proc_aurora_dbg.c b/arch/arm/mach-msys/proc_aurora_dbg.c
new file mode 100644
index 0000000..b6b9a66
--- /dev/null
+++ b/arch/arm/mach-msys/proc_aurora_dbg.c
@@ -0,0 +1,113 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+static struct proc_dir_entry *aurora_dbg;
+
+unsigned int aurora_core_index(void)
+{
+	unsigned int value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPU ID reg\n" : "=r" (value) : : "memory");
+	return value & 0xF;
+}
+
+/********************************************************************/
+int aurora_dbg_read(char *buffer, char **buffer_location, off_t offset,
+			int buffer_length, int *zero, void *ptr)
+{
+	char *p = buffer;
+	unsigned int val, len;
+
+#ifdef CONFIG_SMP
+	p += sprintf(p, "CPU %d:\n", aurora_core_index());
+#endif
+	__asm("mrc  p15, 1, %0, c15, c1, 1" : "=r" (val));
+	p += sprintf(p, "c1, 1 %x\n", val);
+	__asm("mrc  p15, 1, %0, c15, c1, 2" : "=r" (val));
+	p += sprintf(p, "c1, 2 %x\n", val);
+	__asm("mrc  p15, 1, %0, c15, c2, 0" : "=r" (val));
+	p += sprintf(p, "c2, 0 %x\n", val);
+	__asm("mrc  p15, 1, %0, c15, c2, 1" : "=r" (val));
+	p += sprintf(p, "c2, 1 %x\n", val);
+	__asm("mrc  p15, 1, %0, c15, c1, 0" : "=r" (val));
+	p += sprintf(p, "c1, 0 %x\n", val);
+
+#ifdef CONFIG_PERF_EVENTS
+	__asm("mrc  p15, 0, %0, c9, c12, 0" : "=r" (val));
+	p += sprintf(p, "pmon ctrl %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c12, 1" : "=r" (val));
+	p += sprintf(p, "pmon cntrs en %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c12, 3" : "=r" (val));
+	p += sprintf(p, "pmon cntrs oflow %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c12, 5" : "=r" (val));
+	p += sprintf(p, "pmon cntr sel %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c13, 0" : "=r" (val));
+	p += sprintf(p, "pmon cycle cnt %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c13, 1" : "=r" (val));
+	p += sprintf(p, "pmon evt sel %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c13, 2" : "=r" (val));
+	p += sprintf(p, "pmon cntr val %x\n", val);
+	__asm("mrc  p15, 0, %0, c9, c14, 1" : "=r" (val));
+	p += sprintf(p, "pmon int en %x\n", val);
+#endif
+
+	len = (p - buffer);
+	return len;
+}
+
+/********************************************************************/
+int __init start_aurora_dbg(void)
+{
+	aurora_dbg = create_proc_entry("aurora_dbg", 0666, NULL);
+	aurora_dbg->read_proc = aurora_dbg_read;
+	aurora_dbg->write_proc = NULL;
+	aurora_dbg->nlink = 1;
+	return 0;
+}
+void __exit stop_aurora_dbg(void)
+{
+	remove_proc_entry("aurora_dbg", NULL);
+	return;
+}
+module_init(start_aurora_dbg);
+module_exit(stop_aurora_dbg);
diff --git a/arch/arm/mach-msys/sysmap.c b/arch/arm/mach-msys/sysmap.c
new file mode 100644
index 0000000..f2d719c4
--- /dev/null
+++ b/arch/arm/mach-msys/sysmap.c
@@ -0,0 +1,114 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <asm/mach/map.h>
+
+static struct map_desc MEM_TABLE[] =	{
+	/* no use for pex mem remap */
+	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	INTER_REGS_SIZE,	MT_DEVICE},
+	{ DFX_REGS_VIRT_BASE,		__phys_to_pfn(DFX_REGS_PHYS_BASE),	DFX_REGS_SIZE,		MT_DEVICE},
+	{ PEX0_IO_VIRT_BASE,		__phys_to_pfn(PEX0_IO_PHYS_BASE),	PEX0_IO_SIZE,		MT_DEVICE},
+};
+
+static MV_CPU_DEC_WIN SYSMAP_MSYS[] = {
+	/* base low		base high	size				WinNum		enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS3 */
+	{{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	0x8,		EN},	/* DEVICE_CS0 */
+	{{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS1 */
+	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS3 */
+	{{PEX_MEM_PHYS_BASE,		0,	PEX_MEM_SIZE		},	0x0,		EN},	/* PEX_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
+	{{DFX_REGS_PHYS_BASE,		0,	DFX_REGS_SIZE		},	0x1,		EN},	/* DFX_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS4 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		EN},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		EN},	/* DEV_BOOTCS */
+	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
+};
+
+
+MV_CPU_DEC_WIN *mv_sys_map(void)
+{
+	return SYSMAP_MSYS;
+}
+
+void __init msys_map_io(void)
+{
+	iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+}
+
+u32 mv_pci_mem_base_get(void)
+{
+	return PEX_MEM_PHYS_BASE;
+}
+
+u32 mv_pci_mem_size_get(void)
+{
+	return PEX_MEM_SIZE;
+}
+
+u32 mv_pci_io_base_get(void)
+{
+	return PEX0_IO_PHYS_BASE;
+}
+
+u32 mv_pci_io_size_get(void)
+{
+	return PEX0_IO_SIZE;
+}
+
+MV_TARGET mv_pci_io_target_get(void)
+{
+	return PEX0_IO;
+}
+
+int mv_is_pci_io_mapped(void)
+{
+	/* FIXME: First 8 address decode windows are statically assigned
+	   for 8 PCIE mem BARs.
+	   This is disabled as long that no more windows are available for
+	   I/O BARs
+	*/
+
+	return 0;
+}
diff --git a/arch/arm/mach-msys/sysmap.h b/arch/arm/mach-msys/sysmap.h
new file mode 100644
index 0000000..2d47ed0
--- /dev/null
+++ b/arch/arm/mach-msys/sysmap.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#ifndef __SYSMAP_H
+#define __SYSMAP_H
+
+MV_CPU_DEC_WIN *mv_sys_map(void);
+u32 mv_pci_mem_base_get(void);
+u32 mv_pci_mem_size_get(void);
+u32 mv_pci_io_base_get(void);
+u32 mv_pci_io_size_get(void);
+MV_TARGET mv_pci_io_target_get(void);
+int mv_is_pci_io_mapped(void);
+void __init msys_map_io(void);
+
+#endif /* __SYSMAP_H */
diff --git a/arch/arm/mach-msys/time.c b/arch/arm/mach-msys/time.c
new file mode 100644
index 0000000..c14d115
--- /dev/null
+++ b/arch/arm/mach-msys/time.c
@@ -0,0 +1,404 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "irq.h"
+#include "time.h"
+
+#ifdef CONFIG_SMP
+static struct clock_event_device __percpu **msys_local_clockevent;
+#endif
+
+#define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define TIMER_WD_RELOAD		(MV_CNTMR_REGS_OFFSET + 0x0020)
+#define TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
+#define TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0028)
+
+#define TIMER_EN(x)		(0x0001 << (2 * x))
+#define TIMER_RELOAD_EN(x)	(0x0002 << (2 * x))
+#define TIMER_RELOAD(x)		(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
+#define INT_TIMER_CLR(x)	(~(1 << (8*x)))
+
+#define LCL_TIMER_BASE		(0x21000 | 0x40)
+#define LCL_TIMER_CTRL		(LCL_TIMER_BASE + 0x0000)
+#define LCL_TIMER0_EN		0x0001
+#define LCL_TIMER0_RELOAD_EN	0x0002
+#define LCL_TIMER1_EN		0x0004
+#define LCL_TIMER1_RELOAD_EN	0x0008
+#define LCL_TIMER0_RELOAD	(LCL_TIMER_BASE + 0x0010)
+#define LCL_TIMER0_VAL		(LCL_TIMER_BASE + 0x0014)
+#define LCL_TIMER1_RELOAD	(LCL_TIMER_BASE + 0x0018)
+#define LCL_TIMER1_VAL		(LCL_TIMER_BASE + 0x001c)
+#define LCL_TIMER_WD_RELOAD	(LCL_TIMER_BASE + 0x0020)
+#define LCL_TIMER_WD_VAL	(LCL_TIMER_BASE + 0x0024)
+#define LCL_TIMER_CAUSE		(LCL_TIMER_BASE + 0x0028)
+#define LCL_INT_TIMER0_CLR	~(1 << 0)
+#define LCL_INT_TIMER1_CLR	~(1 << 8)
+#define LCL_TIMER_TURN_25MHZ	(1 << 11)
+
+#define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
+#define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
+#define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
+#define BRIDGE_INT_TIMER(x)	(1 << (24 + x))
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
+static unsigned int soc_timer_id;
+
+static u32 notrace msys_clksrc_read32(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(soc_timer_id));
+	return cyc;
+}
+
+static void __init msys_setup_sched_clock(unsigned long tclk)
+{
+	setup_sched_clock(msys_clksrc_read32, 32, tclk);
+}
+
+/*
+ * Clocksource handling.
+ */
+static cycle_t msys_clksrc_read(struct clocksource *cs)
+{
+	return 0xffffffff - MV_REG_READ(TIMER_VAL(soc_timer_id));
+}
+
+static struct clocksource msys_clksrc = {
+	.name		= "msys_clocksource",
+	.shift		= 20,
+	.rating		= 300,
+	.read		= msys_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Clockevent handling.
+ */
+int msys_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (delta == 0)
+		return -ETIME;
+
+	local_irq_save(flags);
+
+	/* Clear and enable clockevent timer interrupt */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+
+	/*msys_irq_unmask(IRQ_LOCALTIMER);*/
+	msys_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	/* Setup new clockevent timer value */
+	MV_REG_WRITE(LCL_TIMER0_VAL, delta);
+
+	/* Enable the timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u = (u & ~LCL_TIMER0_RELOAD_EN) | LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void msys_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	local_irq_save(flags);
+
+	if ((mode == CLOCK_EVT_MODE_PERIODIC) ||
+	    (mode == CLOCK_EVT_MODE_ONESHOT)) {
+		/* Setup timer to fire at 1/HZ intervals */
+		MV_REG_WRITE(LCL_TIMER0_RELOAD, (ticks_per_jiffy - 1));
+		MV_REG_WRITE(LCL_TIMER0_VAL, (ticks_per_jiffy - 1));
+
+		/* Enable timer interrupt */
+		msys_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+		/* Enable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+
+		if (mode == CLOCK_EVT_MODE_PERIODIC)
+			u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN | LCL_TIMER_TURN_25MHZ);
+		else
+			u |= (LCL_TIMER0_EN | LCL_TIMER_TURN_25MHZ);
+
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	} else {
+		/* Disable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u &= ~LCL_TIMER0_EN;
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+		/* Disable timer interrupt */
+		msys_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+		/* ACK pending timer interrupt */
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	}
+
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device msys_clkevt;
+static irqreturn_t msys_timer_interrupt(int irq, void *dev_id)
+{
+	/* ACK timer interrupt and call event handler */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	msys_clkevt.event_handler(&msys_clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction msys_timer_irq = {
+	.name		= "msys_tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= msys_timer_interrupt,
+	.dev_id		= &msys_clkevt,
+};
+
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit mv_timer_setup(struct clock_event_device *clk, unsigned int fabric_clk)
+{
+	unsigned int cpu = smp_processor_id();
+
+	clk->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	clk->shift		= 32,
+	clk->rating		= 300,
+	clk->set_next_event	= msys_clkevt_next_event,
+	clk->set_mode		= msys_clkevt_mode,
+	clk->cpumask		= cpumask_of(cpu);
+	clk->mult		= div_sc(fabric_clk, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0x1, clk);
+}
+
+/*
+ * Resume timer from suspend to RAM
+ * TODO - need to implement kernel hooks for suspend/resume
+ */
+void msys_timer_resume(void)
+{
+	u32 u;
+
+	pr_info("Resuming MSYS SOC Timer %d\n", soc_timer_id);
+
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) |
+			TIMER_TURN_25MHZ(soc_timer_id));
+	MV_REG_WRITE(TIMER_CTRL, u);
+}
+
+#if defined(CONFIG_SMP) && defined(CONFIG_LOCAL_TIMERS)
+/*
+ * local_timer_ack: checks for a local timer interrupt.
+ *
+ * If a local timer interrupt has occurred, acknowledge and return 1.
+ * Otherwise, return 0.
+ */
+
+int local_timer_ack(void)
+{
+	if (MV_REG_READ(LCL_TIMER_CAUSE) & ~LCL_INT_TIMER0_CLR) {
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+		return 1;
+	}
+	return 0;
+}
+
+static irqreturn_t msys_localtimer_handler(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
+
+	if (local_timer_ack()) {
+		evt->event_handler(evt);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit msys_local_timer_setup(struct clock_event_device *clk)
+{
+	unsigned int fabric_clk = mvCpuL2ClkGet();
+	static int cpu0_flag = -1;
+	int cpu = smp_processor_id();
+	struct clock_event_device **this_cpu_clk;
+
+	if (!msys_local_clockevent) {
+		int err;
+
+		msys_local_clockevent = alloc_percpu(struct clock_event_device *);
+		if (!msys_local_clockevent) {
+			pr_err("msys_local_clockevent: can't allocate memory\n");
+			return 0;
+		}
+		err = request_percpu_irq(IRQ_LOCALTIMER, msys_localtimer_handler,
+				"msys_local_clockevent", msys_local_clockevent);
+		if (err) {
+			pr_err("msys_local_clockevent: can't register interrupt %d (%d)\n",
+				IRQ_LOCALTIMER, err);
+			return 0;
+		}
+	}
+
+	if ((cpu) || (!cpu && (-1 == cpu0_flag))) {
+		ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+		clk->name = "local_timer";
+		clk->irq = IRQ_LOCALTIMER;
+		mv_timer_setup(clk, fabric_clk);
+		this_cpu_clk = __this_cpu_ptr(msys_local_clockevent);
+		*this_cpu_clk = clk;
+		clockevents_register_device(clk);
+
+		if (!cpu)
+			cpu0_flag++;
+	}
+	enable_percpu_irq(clk->irq, 0);
+	return 0;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+/*
+ * take a local timer down
+ */
+void  __cpuexit msys_local_timer_stop(struct clock_event_device *evt)
+{
+	unsigned long flags;
+	u32 u;
+
+	local_irq_save(flags);
+
+	/* Disable timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u &= ~LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+
+	/* Disable timer interrupt */
+	msys_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	local_irq_restore(flags);
+}
+#endif
+
+static struct local_timer_ops msys_local_timer_ops __cpuinitdata = {
+	.setup	= msys_local_timer_setup,
+#ifdef CONFIG_HOTPLUG_CPU
+	.stop	= msys_local_timer_stop,
+#endif
+};
+#endif	/* CONFIG_LOCAL_TIMERS && CONFIG_SMP */
+
+void __init msys_time_init(unsigned int fabric_clk)
+{
+	u32 u;
+
+	soc_timer_id = 0;
+
+	printk(KERN_INFO "Initializing MSYS SOC Timer %d\n", soc_timer_id);
+
+	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+
+	msys_setup_sched_clock(fabric_clk);
+
+	/* Setup free-running clocksource timer (interrupts disabled) */
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
+
+	MV_REG_WRITE(TIMER_CTRL, u);
+	msys_clksrc.mult = clocksource_hz2mult(fabric_clk, msys_clksrc.shift);
+	clocksource_register(&msys_clksrc);
+
+#ifdef CONFIG_SMP
+	{
+#ifdef CONFIG_LOCAL_TIMERS
+		local_timer_register(&msys_local_timer_ops);
+#endif
+		percpu_timer_setup();
+		return;
+	}
+#endif
+	/* Setup clockevent timer (interrupt-driven) */
+	msys_clkevt.name = "msys_tick";
+	msys_clkevt.irq = IRQ_LOCALTIMER;
+	mv_timer_setup(&msys_clkevt, fabric_clk);
+	setup_irq(IRQ_LOCALTIMER, &msys_timer_irq);
+	clockevents_register_device(&msys_clkevt);
+}
+
+void __init msys_timer_init(void)
+{
+	msys_time_init(mvCpuL2ClkGet());
+}
diff --git a/arch/arm/mach-msys/time.h b/arch/arm/mach-msys/time.h
new file mode 100644
index 0000000..ce329d0
--- /dev/null
+++ b/arch/arm/mach-msys/time.h
@@ -0,0 +1,30 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+void __init msys_timer_init(void);
+void __cpuinit percpu_timer_setup(void);
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index ec173d6..593f284 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -394,7 +394,7 @@ config CPU_SHEEVA_PJ4B_V6
 	select DMA_CACHE_RWFO if SMP
 
 config CPU_SHEEVA_PJ4B_V7
-	bool "Support Sheeva processor in V7 mode" if ARCH_ARMADA_XP || ARCH_ARMADA370
+	bool "Support Sheeva processor in V7 mode" if ARCH_ARMADA_XP || ARCH_ARMADA370 || ARCH_MSYS
 	select CPU_V7
 
 endchoice
@@ -434,7 +434,8 @@ config CPU_V6K
 
 # ARMv7
 config CPU_V7
-	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX || ARCH_AVANTA_LP || ARCH_ARMADA38X
+	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX || \
+		ARCH_AVANTA_LP || ARCH_ARMADA38X || ARCH_MSYS
 	select CPU_32v6K
 	select CPU_32v7
 	select CPU_ABRT_EV7
@@ -1092,7 +1093,7 @@ config SHEEVA_ERRATA_ARM_CPU_6136
 config SHEEVA_ERRATA_ARM_CPU_6124
 
         bool "Sheeva Errata 6124: Clean operation might cause data corruption"
-        depends on  CPU_SHEEVA_PJ4B_V7 && (ARMADA_XP_REV_B0 || ARMADA_XP_A0_WITH_B0)
+        depends on  CPU_SHEEVA_PJ4B_V7 && (ARMADA_XP_REV_B0 || ARMADA_XP_A0_WITH_B0 || ARCH_MSYS)
         default y
         help
 		Clean operation might cause data corruption
@@ -1157,7 +1158,7 @@ config ARMADA_DEEP_IDLE_SUPPORT_FAST_EXIT
 
 config CACHE_AURORA_L2
 	bool "Enable Marvell Aurora L2 cache controller"
-	depends on ARCH_ARMADA_XP || ARCH_ARMADA370
+	depends on ARCH_ARMADA_XP || ARCH_ARMADA370 || ARCH_MSYS
 	default y
 	select OUTER_CACHE if ARCH_ARMADA370
 	help
@@ -1188,7 +1189,7 @@ config AURORA_L2_OUTER_WA
 
 config AURORA_SF_ENABLED
         bool "Enable Marvell Aurora Snoop Filter "
-        depends on CPU_SHEEVA_PJ4B_V7 && (ARMADA_XP_REV_A0 || ARMADA_XP_A0_WITH_B0 || ARMADA_XP_REV_B0) && SMP
+        depends on CPU_SHEEVA_PJ4B_V7 && (ARMADA_XP_REV_A0 || ARMADA_XP_A0_WITH_B0 || ARMADA_XP_REV_B0 || ARCH_MSYS) && SMP
         default y
         help
           This option enables Snoop Filter feature.
@@ -1201,7 +1202,7 @@ config ENABLE_UNALINGED_ACCESS_FAULT
 
 config AURORA_IO_CACHE_COHERENCY
 	bool "Enable Marvell Aurora I/O cache coherency"
-	depends on ARCH_ARMADA_XP || ARCH_ARMADA370 || ARCH_AVANTA_LP || ARCH_ARMADA38X
+	depends on ARCH_ARMADA_XP || ARCH_ARMADA370 || ARCH_AVANTA_LP || ARCH_ARMADA38X || ARCH_MSYS
 	default y
 	select HAVE_ARM_SCU
 	help
diff --git a/arch/arm/mm/proc-sheeva_pj4bv7.S b/arch/arm/mm/proc-sheeva_pj4bv7.S
index e45b771..d073166 100644
--- a/arch/arm/mm/proc-sheeva_pj4bv7.S
+++ b/arch/arm/mm/proc-sheeva_pj4bv7.S
@@ -21,6 +21,8 @@
 #elif defined(CONFIG_ARCH_ARMADA370)
 #include <mach/armada370.h>
 #include <mach/kw_macro.h>
+#elif defined(CONFIG_ARCH_MSYS)
+#include <mach/msys.h>
 #endif
 
 #include "proc-macros.S"
@@ -51,17 +53,26 @@ ENTRY(cpu_pj4bv7_proc_init)
 ENDPROC(cpu_pj4bv7_proc_init)
 
 ENTRY(cpu_pj4bv7_proc_fin)
-	
+
 #ifdef CONFIG_CACHE_AURORA_L2
 	mcr	p15, 0, r0, c7, c10, 4		@ Data Synchronization Barrier
 	ldr	r0, =0xffff			@ L2C clean all 16 ways
+#if defined(CONFIG_ARCH_MSYS)
+	ldr	r1, =MSYS_L2_CLEAN_WAY_REG
+#else
 	ldr	r1, =AXP_L2_CLEAN_WAY_REG
+#endif
 	str	r0, [r1]
 	mrc	p15, 0, r0, c0, c0, 5		@ Read CPU core number
 	and	r0, r0, #0xF
 	mov	r1, #0x1
 	lsl	r0, r1, r0
+#if defined(CONFIG_ARCH_MSYS)
+1:	ldr	r1, =MSYS_L2_MNTNC_STAT_REG	@ Read maintanence status to check done per CPU
+#else
 1:	ldr	r1, =AXP_L2_MNTNC_STAT_REG	@ Read maintanence status to check done per CPU
+#endif
+
 	ldr	r1, [r1]
 	tst	r0, r1
 	bne	1b
@@ -72,7 +83,7 @@ ENTRY(cpu_pj4bv7_proc_fin)
 	bic	r0, r0, #0x0006			@ .............ca.
 	mcr	p15, 0, r0, c1, c0, 0		@ disable caches
 	mov	pc, lr
-	
+
 ENDPROC(cpu_pj4bv7_proc_fin)
 
 /*
@@ -103,7 +114,7 @@ ENTRY(cpu_pj4bv7_do_idle)
 #ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4742
 	mcr	p15, 0, r0, c7, c10, 4		@barrier
 #endif
-#endif	
+#endif
 	mov	pc, lr
 ENDPROC(cpu_pj4bv7_do_idle)
 
@@ -169,9 +180,9 @@ ENDPROC(cpu_pj4bv7_switch_mm)
  */
 ENTRY(cpu_pj4bv7_set_pte_ext)
 #ifdef CONFIG_MMU
- 
+
 str	r1, [r0]			@ linux version
- 
+
 #ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
 	mov     r3, #0x7C
 	and     r3, r3, r0
@@ -358,7 +369,7 @@ ENDPROC(cpu_v7_do_resume)
 #endif
 	__CPUINIT
 
-	
+
 /*
 ++ *	__pj4bv7_setup
  *
@@ -378,20 +389,20 @@ __pj4bv7_setup:
 	sheeva_pj4b_config
 
 #if 0
-@ CURRENTLY NOT SUPPORTED 
+@ CURRENTLY NOT SUPPORTED
 defined(CONFIG_SMP)
 	mrc	p15, 0, r0, c1, c0, 1		@ Enable SMP/nAMP mode
 	orr	r0, r0, #0x20
 	mcr	p15, 0, r0, c1, c0, 1
 #if 1
 	mrc 	p15, 1, r0, c15, c2, 0
-	orr	r0, r0, #0x2			@ SMP enable 
+	orr	r0, r0, #0x2			@ SMP enable
 	mcr 	p15, 1, r0, c15, c2, 0
 #endif
 #endif
 
 
-#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_REV_B0)
+#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_REV_B0) || defined(CONFIG_ARCH_MSYS)
 
 #ifdef CONFIG_ARMADA_XP_A0_WITH_B0
 /* Read and save SoC revision */
@@ -425,7 +436,7 @@ defined(CONFIG_SMP)
 1:
 #endif
 	mcr        p15, 1, r0, c15, c1, 1                         /* Write */
-	
+
 /* Auxiliary Functional Modes Control Register 0 */
 	mrc        p15, 1, r0, c15, c2, 0                         /* Read */
 #ifdef CONFIG_SMP
@@ -465,8 +476,8 @@ defined(CONFIG_SMP)
 	orr          r0, r0, #0x40000000                         /* BIT30 L1 Replacement Policy Config--> '1' Strict Round-Robin Replacement Policy  */
 	mcr        p15, 1, r0, c15, c1, 2                         /* Write */
 
-#else 
-#ifdef CONFIG_SMP 
+#else
+#ifdef CONFIG_SMP
 	ALT_SMP(mrc	p15, 0, r0, c1, c0, 1)
 	ALT_UP(mov	r0, #(1 << 6))		@ fake it for UP
 	tst	r0, #(1 << 6)			@ SMP/nAMP mode enabled?
@@ -494,7 +505,7 @@ adr	r12, __pj4bv7_setup_stack		@ the local stack
 	orr	r6, r6, r5, lsr #20-4		@ combine variant and revision
 	ubfx	r0, r0, #4, #12			@ primary part number
 
-	/* Cortex-A8 Errata */ 
+	/* Cortex-A8 Errata */
 	ldr	r10, =0x00000c08		@ Cortex-A8 primary part number
 	teq	r0, r10
 	bne	2f
@@ -563,14 +574,14 @@ adr	r12, __pj4bv7_setup_stack		@ the local stack
 #ifdef CONFIG_MMU
 	mcr	p15, 0, r10, c8, c7, 0		@ invalidate I + D TLBs
 	mcr	p15, 0, r10, c2, c0, 2		@ TTB control register
-			
+
 	ALT_SMP(orr	r4, r4, #TTB_FLAGS_SMP)
 	ALT_UP(orr	r4, r4, #TTB_FLAGS_UP)
 	ALT_SMP(orr	r8, r8, #TTB_FLAGS_SMP)
 	ALT_UP(orr	r8, r8, #TTB_FLAGS_UP)
 
 	mcr	p15, 0, r8, c2, c0, 1		@ load TTB1
-	
+
 	ldr	r5, =PRRR			@ PRRR
 	ldr	r6, =NMRR			@ NMRR
 	mcr	p15, 0, r5, c10, c2, 0		@ write PRRR
@@ -623,15 +634,15 @@ ENTRY(v7_processor_functions)
 	.word	cpu_v7_suspend_size
 	.word	cpu_v7_do_suspend
 	.word	cpu_v7_do_resume
-	
+
 	/*
-	this whole 
+	this whole
 		.word	cpu_v7_suspend_size
 	.word	cpu_v7_do_suspend
 	.word	cpu_v7_do_resume
 	section above is a copy paste from proc-v7.s and need to be revisted
 	*/
-	
+
 	.size	v7_processor_functions, . - v7_processor_functions
 
 	.section ".rodata"
diff --git a/arch/arm/mm/sheeva_pj4b-macros.S b/arch/arm/mm/sheeva_pj4b-macros.S
index 93f56e6..629711b 100644
--- a/arch/arm/mm/sheeva_pj4b-macros.S
+++ b/arch/arm/mm/sheeva_pj4b-macros.S
@@ -13,7 +13,7 @@
 	orr     r0, r0, #(1 << 16)		@ Disable data transfer for clean line.
 	mcr 	p15, 1, r0, c15, c1, 1
 
-	mrc 	p15, 1, r0, c15, c1, 2 
+	mrc 	p15, 1, r0, c15, c1, 2
 	bic     r0, r0, #(1 << 23)		@ Enable fast LDR.
 	orr     r0, r0, #(1 << 25)		@ Disable interleave between normal write and snoop data intervene.
 	orr     r0, r0, #(1 << 27)		@ Disable Critical Word First feature.
@@ -33,11 +33,14 @@
 	mrc 	p15, 1, r0, c15, c1, 2
 	orr     r0, r0, #(1 << 31)		@ Enable Write Evict
 	mcr 	p15, 1, r0, c15, c1, 2
-
+#if defined(CONFIG_ARCH_MSYS)
+	ldr     r0, =MSYS_SNOOP_FILTER_PHYS_REG
+#else
 	ldr     r0, =AXP_SNOOP_FILTER_PHYS_REG
+#endif
         ldr     r10, [r0]
         orr     r10 , r10, #0x1                 @ SF_Enable (bit 0)
-        str     r10,[r0] 
+        str     r10,[r0]
 #endif
 
 	.endm
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index a45ec0d..f703109 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -13,10 +13,10 @@ config JTAG_DEBUG
 
 menu "Marvell SoC Included Features"
 
-if ARMADA_XP || AVANTA_LP || ARMADA_38X
+if ARMADA_XP || AVANTA_LP || ARMADA_38X || ARCH_MSYS
 config MV_INCLUDE_PEX
 	bool "PCI Express Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || AVANTA_LP || ARMADA_38X)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || AVANTA_LP || ARMADA_38X || ARCH_MSYS)
 	default y
 	select MV_PEX_2_1X4 if ARMADA_XP
 	select MV_PEX_3_1X4 if ARMADA_XP
@@ -25,7 +25,7 @@ config MV_INCLUDE_PEX
 
 choice
 	prompt "PEX-0 Mode"
-	depends on MV_INCLUDE_PEX && ARMADA_XP
+	depends on MV_INCLUDE_PEX && (ARMADA_XP || ARCH_MSYS)
 	default MV_PEX_0_4X1
 
 config MV_PEX_0_4X1
@@ -67,7 +67,7 @@ endif
 
 config MV_INCLUDE_PCI
 	bool "PCI Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X || ARCH_MSYS)
 	default n
         help
         Please don't change this configs unless you know what you are doing.
@@ -82,7 +82,7 @@ config MV_INCLUDE_USB
 
 config MV_INCLUDE_XOR
 	bool "XOR Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X || ARCH_MSYS
 	default y
         help
         Please don't change this configs unless you know what you are doing.
@@ -97,7 +97,7 @@ config MV_INCLUDE_CESA
 
 config MV_INCLUDE_NFC
 	bool "Nand Flash Controller Support"
-	depends on MV88F6500 || ARMADA_XP || ARMADA_370 || AVANTA_LP || (ARMADA_38X && MV_CM_NFC)
+	depends on MV88F6500 || ARMADA_XP || ARMADA_370 || AVANTA_LP || (ARMADA_38X && MV_CM_NFC) || ARCH_MSYS
 	default y
         help
 	For Armada38x, the NFC,	Legacy NAND,
@@ -134,7 +134,7 @@ config MV_INCLUDE_TDM
 config MV_INCLUDE_GIG_ETH
 	bool "Giga Ethernet Support"
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
-		   ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X || ARCH_MSYS
 	default y
 
 config MV_INCLUDE_SPI
@@ -159,7 +159,7 @@ config MV_INCLUDE_NOR
 
 config MV_INCLUDE_SDIO
 	bool "SDIO Support"
-	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X
+	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370 || AVANTA_LP || ARMADA_38X || ARCH_MSYS
 	default y
         help
         Please don't change this configs unless you know what you are doing.
@@ -307,15 +307,16 @@ config MV_GPP_MAX_PINS
 	default 70 if MV88F6500
 	default 67 if ARMADA_XP
 	default 67 if ARMADA_370
+	default 34 if ARCH_MSYS
 
 config MV_DCACHE_SIZE
 	hex
-	default 0x8000 if MV78XX0 || ARMADA_XP || ARMADA_370
+	default 0x8000 if MV78XX0 || ARMADA_XP || ARMADA_370 || ARCH_MSYS
 	default 0x4000 if MV88F6500 || MV88F6281
 
 config MV_ICACHE_SIZE
 	hex
-	default 0x8000 if MV78XX0 || ARMADA_XP || ARMADA_370
+	default 0x8000 if MV78XX0 || ARMADA_XP || ARMADA_370 || ARCH_MSYS
 	default 0x4000 if MV88F6500 || MV88F6281
 
 menu "SoC MTD support"
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index e1c38a9..5a69fba 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -525,6 +525,7 @@ armada_xp_rdsrv		MACH_ARMADA_XP_RDSRV	ARMADA_XP_RDSRV		3037
 armada_370		MACH_ARMADA_370		ARMADA_370		3038
 armada_xp_amc		MACH_ARMADA_XP_AMC		ARMADA_XP_AMC		3039
 armada_xp_rd_nas	MACH_ARMADA_XP_RD_NAS	ARMADA_XP_RD_NAS	3500
+msys_bc2		MACH_MSYS_BC2		MSYS_BC2		3035
 tx28			MACH_TX28		TX28			3043
 pcontrol_g20		MACH_PCONTROL_G20	PCONTROL_G20		3062
 vpr200			MACH_VPR200		VPR200			3087
-- 
1.7.5.4

