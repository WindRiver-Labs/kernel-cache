From fab785783dd80e2b7e70b50fcd60294f22bbcbe4 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Tue, 25 Feb 2014 10:16:51 +0200
Subject: [PATCH 1392/1825] a38x: irq: Enable affinity support for MPIC
 controlled IRQs on kernel 3.4.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 10db4003c99d9c629a8c54db30c91c3a48d3378f

	- Use banked CPU registers to control SOC PPI interrupts.
	  This is required for proper operation in SMP mode.
	- Mask all SOC PPI interrupts on start.
	- Enable SOC PPI interrupt in GIC for second CPU.
	- Change type of a variable in GPIO IRQ handler to remove build warnings.

Change-Id: I4b5b47e113888b88dcc52509188f84d38d07196a
Signed-off-by: Michal Mazur <arg@semihalf.com>
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5920
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/irq.c     |   89 +++++++++++++++++++++++++++----------
 arch/arm/mach-armada38x/platsmp.c |   10 ++++
 2 files changed, 75 insertions(+), 24 deletions(-)

diff --git a/arch/arm/mach-armada38x/irq.c b/arch/arm/mach-armada38x/irq.c
index b0d76ef..77e3ae6 100644
--- a/arch/arm/mach-armada38x/irq.c
+++ b/arch/arm/mach-armada38x/irq.c
@@ -27,9 +27,10 @@
 /*
  * CPU-private registers
  */
-#define SOC_PPI_CAUSE(cpu)		(MV_CPUIF_REGS_BASE(cpu) | (0x80))
-#define SOC_PPI_MASK_SET(cpu)		(MV_CPUIF_REGS_BASE(cpu) | CPU_INT_SET_MASK_OFFS)
-#define SOC_PPI_MASK_CLEAR(cpu)		(MV_CPUIF_REGS_BASE(cpu) | CPU_INT_CLEAR_MASK_OFFS)
+#define SOC_PPI_CAUSE			(MV_CPUIF_LOCAL_REGS_OFFSET | (0x80))
+#define SOC_PPI_MASK_SET		(MV_CPUIF_LOCAL_REGS_OFFSET | CPU_INT_SET_MASK_OFFS)
+#define SOC_PPI_MASK_CLEAR		(MV_CPUIF_LOCAL_REGS_OFFSET | CPU_INT_CLEAR_MASK_OFFS)
+#define SOC_PPI_CPU_REG(cpu, reg)	((reg) + ((cpu) ? 0x900 : 0x800))
 #define SOC_PPI_CAUSE_BITS		0x1fffffff
 
 #define SOC_LOCAL_SUM_MASK		0x218c4
@@ -85,7 +86,8 @@ static void a38x_gpio_cascade_irq_handler(u32 gpio_cascade_irq,
 					 struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u32 bit, n, gpio_group, irq, cause, mask;
+	unsigned long cause;
+	u32 bit, n, gpio_group, irq, mask;
 
 	chained_irq_enter(chip, desc);
 
@@ -258,20 +260,11 @@ a38x_cascade_irq_local_summary(int chained_irq, int irq, int nr_irqs)
 /*******************************************************************************
  * CPU-private Peripherals interrupts (PPI)
  */
-static struct a38x_irq_chip_data a38x_ppi_chip_data_g0 = {
+static struct a38x_irq_chip_data a38x_ppi_chip_data = {
 	.regs = {
-		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE(0),
-		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET(0),
-		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR(0),
-	},
-	.mask = SOC_PPI_CAUSE_BITS,
-};
-
-static struct a38x_irq_chip_data a38x_ppi_chip_data_g1 = {
-	.regs = {
-		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE(1),
-		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET(1),
-		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR(1),
+		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR,
 	},
 	.mask = SOC_PPI_CAUSE_BITS,
 };
@@ -294,15 +287,50 @@ static void a38x_ppi_irq_unmask(struct irq_data *d)
 	raw_spin_unlock(&irq_controller_lock);
 }
 
+#ifdef CONFIG_SMP
+static int a38x_ppi_irq_set_affinity(struct irq_data *d,
+		const struct cpumask *mask_val, bool force)
+{
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(d->irq);
+	int cpu, count = 0;
+
+	raw_spin_lock(&irq_controller_lock);
+	for_each_online_cpu(cpu)
+		/*
+		 * Forbid multicore interrupt affinity.
+		 * This is required since the MPIC HW doesn't limit
+		 * several CPUs from acknowledging the same interrupt.
+		 */
+		if ((count == 0) && cpumask_test_cpu(cpu, mask_val)) {
+			writel_relaxed(d->hwirq,
+				       SOC_PPI_CPU_REG(cpu, chd->regs.unmask));
+			count++;
+		} else
+			writel_relaxed(d->hwirq,
+				       SOC_PPI_CPU_REG(cpu, chd->regs.mask));
+	raw_spin_unlock(&irq_controller_lock);
+
+	return IRQ_SET_MASK_OK;
+}
+#endif
+
 static struct irq_chip a38x_ppi_irq_chip = {
+	.name = "a38x_ppi_irq_chip",
 	.irq_mask	= a38x_ppi_irq_mask,
 	.irq_unmask	= a38x_ppi_irq_unmask,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = a38x_ppi_irq_set_affinity,
+#endif
 };
 
 static void a38x_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
 {
 	struct a38x_irq_chip_data *chd = irq_get_chip_data(IRQ_START_PRIV_SOC_PPI);
 	u32 cause, virt_irq;
+#ifdef CONFIG_SMP
+	struct irq_data *irqd;
+	u32 cpuid = whoAmI();
+#endif
 
 	chained_irq_enter(irq_get_chip(irq), desc);
 
@@ -318,8 +346,17 @@ static void a38x_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
 		goto out; /* spurious irq ? */
 	}
 
-	virt_irq = ffs(cause) - 1 + chd->irq_base;
-	generic_handle_irq(virt_irq);
+	while (cause) {
+		virt_irq = ffs(cause) - 1;
+		cause &= ~(1 << virt_irq);
+		virt_irq += chd->irq_base;
+#ifdef CONFIG_SMP
+		irqd = irq_get_irq_data(virt_irq);
+		if (!cpumask_test_cpu(cpuid, irqd->affinity))
+			continue;
+#endif
+		generic_handle_irq(virt_irq);
+	}
 
  out:
 	chained_irq_exit(irq_get_chip(irq), desc);
@@ -328,11 +365,19 @@ static void a38x_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
 static int
 a38x_ppi_irq_domain_map(struct irq_domain *d, u32 irq, irq_hw_number_t hwirq)
 {
+	int cpu;
+	struct a38x_irq_chip_data *chd = d->host_data;
+
 	irq_set_status_flags(irq, IRQ_LEVEL);
 	irq_set_chip_data(irq, d->host_data);
 	irq_set_chip_and_handler(irq, &a38x_ppi_irq_chip, handle_level_irq);
 	set_irq_flags(irq, IRQF_VALID);
 
+	/* Mask SOC PPI interrupts on all cores */
+	for_each_possible_cpu(cpu)
+		writel_relaxed(hwirq,
+			       SOC_PPI_CPU_REG(cpu, chd->regs.mask));
+
 	return 0;
 }
 
@@ -345,11 +390,7 @@ a38x_cascade_irq_ppi(int chained_irq, int irq, int nr_irqs)
 {
 	struct a38x_irq_chip_data *chd;
 
-	if (whoAmI())
-		chd = &a38x_ppi_chip_data_g1;
-	else
-		chd = &a38x_ppi_chip_data_g0;
-
+	chd = &a38x_ppi_chip_data;
 	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
 	if (IS_ERR_VALUE(chd->irq_base))
 		BUG();
diff --git a/arch/arm/mach-armada38x/platsmp.c b/arch/arm/mach-armada38x/platsmp.c
index d67a5e5..6af8a0d 100644
--- a/arch/arm/mach-armada38x/platsmp.c
+++ b/arch/arm/mach-armada38x/platsmp.c
@@ -9,6 +9,7 @@
 #include <linux/smp.h>
 #include <asm/smp_plat.h>
 #include <linux/io.h>
+#include <linux/irq.h>
 
 #include <asm/unified.h>
 #include <asm/smp_scu.h>
@@ -57,7 +58,16 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
+	struct irq_data *irqd;
 	gic_secondary_init(0);
+
+	/*
+	 * Unmask SOC Private Peripheral Interrupt here as it
+	 * cannot be enabled from another CPU.
+	 */
+	irqd = irq_get_irq_data(IRQ_PRIV_MPIC_PPI_IRQ);
+	if (irqd && irqd->chip && irqd->chip->irq_unmask)
+		irqd->chip->irq_unmask(irqd);
 }
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
-- 
1.7.5.4

