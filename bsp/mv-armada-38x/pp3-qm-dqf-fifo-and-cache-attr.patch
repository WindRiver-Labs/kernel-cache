From 9c071694764f0edd69b674dec112e3afa215795e Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Mon, 21 Apr 2014 20:03:07 +0300
Subject: [PATCH 1563/1825] pp3: qm: dqf fifo and cache attr

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4753188982e5d2e3ff810573fdebf507e6297be2

Change-Id: Ia4301aac51ab1ca1343baaa298de64ce938988ff
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7148
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Eliezer Ben Zeev <eliezerb@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/qm/mv_qm.c |   88 ++++++++++++++++++++++-----
 drivers/net/ethernet/marvell/pp3/qm/mv_qm.h |    5 +-
 2 files changed, 77 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
index 5489270..650f444 100644
--- a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
@@ -613,14 +613,46 @@ int qm_dqf_port_data_fifo_set(u32 *port_depth_arr)
 	int rc = -QM_INPUT_NOT_IN_RANGE;
 	struct dqf_Data_FIFO_params_p          reg_Data_FIFO_params_p;
 	u32 reg_base_address, reg_size, reg_offset;
-	u32 port, port_depth_arr_sum = 0, data_fifo_ppc_counter = 0, data_fifo_mac_counter = 0;
-
-	for (port = QM_PORT_MIN; port <= QM_PORT_MAX; port++) {
-		if ((port_depth_arr[port] % GRANULARITY_OF_16_BYTES) != 0)
+	u32 port;
+	u32 mac_port_depth_arr_sum = 0, ppc_port_depth_arr_sum = 0;
+	u32 data_fifo_ppc_counter = 0, data_fifo_mac_counter = 0;
+
+	/*
+	 * Ports that are connected to Mac (ports 3 to 10) share the same fifo between them.
+	 * Each line in the fifo holds 16B that is why depth should be multiplication of 16B.
+	 * Sum of all depth cannot be more than 16KB for z1 and 32KB for A0
+	 */
+	for (port = QM_PORT_MAC_MIN; port <= QM_PORT_MAC_MAX; port++) {
+		if ((port_depth_arr[port] % QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES) != 0) {
+			pr_err("fifo size for port %d is not in %d granularity: %d\n",
+				port, QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES, port_depth_arr[port]);
 			return rc;
-		port_depth_arr_sum = port_depth_arr_sum + port_depth_arr[port];
-		if ((port_depth_arr[port] < QM_PORT_DEPTH_ARR_MIN) || (port_depth_arr_sum > QM_PORT_DEPTH_ARR_SUM_MAX))
+		}
+		mac_port_depth_arr_sum += port_depth_arr[port];
+		if ((port_depth_arr[port]   < QM_PORT_DEPTH_ARR_MIN) ||
+			(mac_port_depth_arr_sum > QM_MAC_FIFO_DEPTH_SIZE)) {
+			pr_err("total fifo size is %d the value you passed exceed this value (%d,%d)\n",
+				QM_MAC_FIFO_DEPTH_SIZE, port, port_depth_arr[port]);
 			return rc;
+		}
+	}
+	/*
+	 * Port 0,1,2 are connected to PPC and they share the same FIFO
+	 * In this fifo there are only 4 lines. Each line holds 144B
+	 */
+	for (port = QM_PORT_PPC_MIN; port <= QM_PORT_PPC_MAX; port++) {
+		if ((port_depth_arr[port] % QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES) != 0) {
+			pr_err("fifo size for port %d is not in %d granularity: %d\n",
+				port, QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES, port_depth_arr[port]);
+			return rc;
+		}
+		ppc_port_depth_arr_sum += port_depth_arr[port];
+		if ((port_depth_arr[port]   < QM_PORT_DEPTH_ARR_MIN) ||
+			(ppc_port_depth_arr_sum > QM_PPC_FIFO_DEPTH_SIZE)) {
+			pr_err("total fifo size is %d the value you passed exceed this value (%d,%d)\n",
+				QM_PPC_FIFO_DEPTH_SIZE, port, port_depth_arr[port]);
+			return rc;
+		}
 	}
 
 	for (port = QM_PORT_MIN; port <= QM_PORT_MAX; port++) {
@@ -629,8 +661,10 @@ int qm_dqf_port_data_fifo_set(u32 *port_depth_arr)
 		reg_offset = qm_reg_offset.dqf.Data_FIFO_params_p * port;
 
 		rc = qm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_Data_FIFO_params_p);
-		if (rc != OK)
+		if (rc != OK) {
+			pr_err("Register read failed\n");
 			return rc;
+		}
 
 		switch (port) {
 		case 0:
@@ -688,6 +722,14 @@ int qm_dqf_port_data_fifo_set(u32 *port_depth_arr)
 			data_fifo_mac_counter += (port_depth_arr[port] / QM_SIZE_OF_PORT_DEPTH_ARR_MAC_IN_BYTES);
 			reg_Data_FIFO_params_p.data_fifo_depth_p  = data_fifo_mac_counter;	/* 0x0400 */
 			break;
+		case 11:
+		case 12:
+		case 13:
+		case 14:
+		case 15: /* Drop Port */
+			/* Ports 11 to 15 has no use of DQ Fifo */
+			continue;
+			break;
 		default:
 			return rc;
 		}
@@ -923,7 +965,7 @@ int qm_dma_cache_attr_def_set(void)
 	hwf_qe_ce_awcache  = QM_HWF_QE_CE_AWCACHE_DEF;	/*  3 for QM_HWF_QE_CE_AWQOS_DEF  */
 	hwf_sfh_pl_awcache = QM_HWF_SFH_PL_AWCACHE_DEF;	/*  3 for QM_HWF_SFH_PL_AWQOS_DEF */
 
-	rc = qm_dma_qos_attr_set(swf_awcache, rdma_awcache, hwf_qe_ce_awcache, hwf_sfh_pl_awcache);
+	rc = qm_dma_cache_attr_set(swf_awcache, rdma_awcache, hwf_qe_ce_awcache, hwf_sfh_pl_awcache);
 	return rc;
 }
 
@@ -936,26 +978,42 @@ int qm_dma_cache_attr_set(u32 swf_awcache, u32 rdma_awcache, u32 hwf_qe_ce_awcac
 	struct dma_AXI_write_attributes_for_hwf_pyld  reg_AXI_write_attributes_for_hwf_pyld;
 	u32 reg_base_address, reg_size, reg_offset;
 
-	if ((swf_awcache       <         QM_SWF_AWCACHE_MIN) || (swf_awcache        >        QM_SWF_AWCACHE_MAX))
+	if ((swf_awcache       <         QM_SWF_AWCACHE_MIN) || (swf_awcache        >        QM_SWF_AWCACHE_MAX)) {
+		pr_err("swf cache write attribute %d is out of range %d..%d\n",
+			swf_awcache, QM_SWF_AWCACHE_MIN, QM_SWF_AWCACHE_MAX);
 		return rc;
-	if ((rdma_awcache      <        QM_RDMA_AWCACHE_MIN) || (rdma_awcache       >       QM_RDMA_AWCACHE_MAX))
+	}
+	if ((rdma_awcache      <        QM_RDMA_AWCACHE_MIN) || (rdma_awcache       >       QM_RDMA_AWCACHE_MAX)) {
+		pr_err("rdma cache write attribute %d is out of range %d..%d\n",
+			rdma_awcache, QM_RDMA_AWCACHE_MIN, QM_RDMA_AWCACHE_MAX);
 		return rc;
-	if ((hwf_qe_ce_awcache <   QM_HWF_QE_CE_AWCACHE_MIN) || (hwf_qe_ce_awcache  >  QM_HWF_QE_CE_AWCACHE_MAX))
+	}
+	if ((hwf_qe_ce_awcache <   QM_HWF_QE_CE_AWCACHE_MIN) || (hwf_qe_ce_awcache  >  QM_HWF_QE_CE_AWCACHE_MAX)) {
+		pr_err("hwf qece cache write attribute %d is out of range %d..%d\n",
+			hwf_qe_ce_awcache, QM_HWF_QE_CE_AWCACHE_MIN, QM_HWF_QE_CE_AWCACHE_MAX);
 		return rc;
-	if ((hwf_sfh_pl_awcache < QM_HWF_SFH_PL_AWCACHE_MIN) || (hwf_sfh_pl_awcache > QM_HWF_SFH_PL_AWCACHE_MAX))
+	}
+	if ((hwf_sfh_pl_awcache < QM_HWF_SFH_PL_AWCACHE_MIN) || (hwf_sfh_pl_awcache > QM_HWF_SFH_PL_AWCACHE_MAX)) {
+		pr_err("swf payload cache write attribute %d is out of range %d..%d\n",
+			hwf_sfh_pl_awcache, QM_HWF_SFH_PL_AWCACHE_MIN, QM_HWF_SFH_PL_AWCACHE_MAX);
 		return rc;
+	}
 
 	reg_base_address =      qm.dma.AXI_write_attributes_for_swf_mode;
 	reg_size   =   qm_reg_size.dma.AXI_write_attributes_for_swf_mode;
 	reg_offset = qm_reg_offset.dma.AXI_write_attributes_for_swf_mode * 0;
 
 	rc = qm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_AXI_write_attributes_for_swf_mode);
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("read register failed\n");
 		return rc;
+	}
 	reg_AXI_write_attributes_for_swf_mode.swf_awcache  = swf_awcache;
 	rc = qm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_AXI_write_attributes_for_swf_mode);
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("write register failed\n");
 		return rc;
+	}
 
 	reg_base_address =      qm.dma.AXI_write_attributes_for_rdma_mode;
 	reg_size   =   qm_reg_size.dma.AXI_write_attributes_for_rdma_mode;
@@ -1003,7 +1061,7 @@ int qm_dma_domain_attr_def_set(void)
 	hwf_qe_ce_awdomain  = QM_HWF_QE_CE_AWDOMAIN_DEF;	/* 0 for QM_HWF_QE_CE_AWDOMAIN_DEF  */
 	hwf_sfh_pl_awdomain = QM_HWF_SFH_PL_AWDOMAIN_DEF;	/* 0 for QM_HWF_SFH_PL_AWDOMAIN_DEF */
 
-	rc = qm_dma_qos_attr_set(swf_awdomain, rdma_awdomain, hwf_qe_ce_awdomain, hwf_sfh_pl_awdomain);
+	rc = qm_dma_domain_attr_set(swf_awdomain, rdma_awdomain, hwf_qe_ce_awdomain, hwf_sfh_pl_awdomain);
 	return rc;
 }
 
diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
index 13e640a..401d6b6 100644
--- a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
@@ -158,8 +158,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define QM_QUEUE_MAX			0x00000200	/*  512 */
 #define QM_PORT_MIN				         0	/*    0 */
 #define QM_PORT_MAX				0x0000000F	/*   15 */
+/* PPC ports are ports 0 to 2 */
 #define QM_PORT_PPC_MIN			QM_PORT_MIN
 #define QM_PORT_PPC_MAX			0x00000002	/*    2 */
+/* eMac, cMac, hMac ports are ports 3 to 10 */
 #define QM_PORT_MAC_MIN			0x00000003	/*    3 */
 #define QM_PORT_MAC_MAX			0x0000000A	/*   10 */
 #define QM_QUEUE_PROFILE_MIN	         1	/*    1 */
@@ -222,7 +224,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define QM_SIZE_OF_PORT_CREDIT_THR_ARR_MAC_IN_BYTES	0x00000010	/*   16 */
 
 #define QM_PORT_DEPTH_ARR_MIN			     0	/*     0 */
-#define QM_PORT_DEPTH_ARR_SUM_MAX	0x00004000	/* 16384 */
+#define QM_MAC_FIFO_DEPTH_SIZE		0x00004000	/* 16384KB for Z1, in A0 would be 32KB */
+#define QM_PPC_FIFO_DEPTH_SIZE		576			/* Bytes, 4 lines of 144Bytes */
 
 #define QM_PORT_CREDIT_THR_ARR_MIN	GRANULARITY_OF_16_BYTES	/*     16 */
 #define QM_PORT_CREDIT_THR_ARR_MAX	(data_fifo_depth_p - 8 * GRANULARITY_OF_16_BYTES)	/* 8 * 16 */
-- 
1.7.5.4

