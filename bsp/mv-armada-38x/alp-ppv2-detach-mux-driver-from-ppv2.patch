From 1fe8eabe802f01611789b75e51a69cad3454b089 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Mon, 1 Jul 2013 15:29:59 +0300
Subject: [PATCH 0749/1825] alp: ppv2: detach mux driver from ppv2

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e4f32aee699b5af4626e8b5202c3ada10dce0b7e

	delete mux files form ppv2
	create new mux directory under mv_drivers_lsp

Change-Id: Ib9bc7fba6a890f20a650d24190dfe5fbd573a8f7
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2378
Reviewed-by: Star_Automation <star@marvell.com>
Reviewed-by: Jonatan Farhadian <yonif@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/Makefile                    |    2 +
 arch/arm/mach-avantalp/config/mvRules.mk           |    7 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile |    8 +
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          | 1329 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.h          |  100 ++
 .../mv_drivers_lsp/mv_mux/mv_mux_sysfs.c           |  244 ++++
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    5 -
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c      |  125 --
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c  | 1115 ----------------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h  |   64 -
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c   |  247 ----
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  172 ++--
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   16 +-
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |   26 +-
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |    4 +-
 15 files changed, 1801 insertions(+), 1663 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c

diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 02aaf7c..d834e3b 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -106,6 +106,8 @@ obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
+obj-y					+= $(LSP_MUX_DIR)/
+
 
 obj-$(CONFIG_SENSORS_ALP)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
diff --git a/arch/arm/mach-avantalp/config/mvRules.mk b/arch/arm/mach-avantalp/config/mvRules.mk
index fd909cc..9530857 100644
--- a/arch/arm/mach-avantalp/config/mvRules.mk
+++ b/arch/arm/mach-avantalp/config/mvRules.mk
@@ -79,6 +79,7 @@ endif
 LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
 LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
 
 # Environment components
 ALP_FAM_DIR	= avanta_lp_family
@@ -100,9 +101,9 @@ HAL_PATH        = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -
 ALP_FAM_PATH	= -I$(LSP_PATH_I)/$(ALP_FAM_DIR)
 QD_PATH         = -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
                   -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
-                     
+
 COMMON_PATH   	= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
- 
+
 OSSERV_PATH     = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
 LSP_PATH        = -I$(LSP_PATH_I)
 CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
@@ -116,7 +117,7 @@ EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(ALP_FAM_PATH) \
 ###################################################################################################
 # defines
 ###################################################################################################
-MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH) 
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
 
 
 ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
new file mode 100644
index 0000000..ff57e5a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the Marvell Key
+#
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+obj-y	+= mv_mux_netdev.o mv_mux_sysfs.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
new file mode 100644
index 0000000..673c9d9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -0,0 +1,1329 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "mv_mux_netdev.h"
+#include "mv_switch/mv_switch.h"
+#include <linux/platform_device.h>
+
+static const struct net_device_ops mv_mux_netdev_ops;
+static struct  mv_mux_eth_port mux_eth_shadow[MV_ETH_MAX_PORTS];
+static struct  mv_mux_switch_port  mux_switch_shadow;
+
+/* ppv2/neta functions that called from mux */
+static struct  mv_mux_eth_ops	*mux_eth_ops;
+
+/* mux functions that called from switch */
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+static struct  mv_switch_mux_ops switch_mux_ops;
+#endif
+
+static inline struct net_device *mv_mux_rx_netdev_get(int port, struct sk_buff *skb);
+static inline int mv_mux_rx_tag_remove(struct net_device *dev, struct sk_buff *skb);
+static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb);
+
+
+/*-----------------------------------------------------------------------------------------*/
+/*----------------------------     MANAGER      -------------------------------------------*/
+/*-----------------------------------------------------------------------------------------*/
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+static int mv_mux_mgr_create(char *name, int gbe_port, int group, MV_MUX_TAG *tag)
+{
+	struct net_device *mux_dev;
+	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	char *unicast;
+
+	mux_dev = mv_mux_netdev_alloc(name, group, tag);
+	if (mux_dev == NULL) {
+		printk(KERN_ERR "%s: mv_mux_netdev_alloc falied\n", __func__);
+		return MV_FAIL;
+	}
+	mv_mux_netdev_add(gbe_port, mux_dev);
+
+	/* update switch group's cookie for mux ops */
+	mv_switch_group_cookie_set(group, mux_dev);
+
+	/* update switch's DB with mux's MAC addresses (bcast, ucast) */
+	unicast = mv_mux_get_mac(mux_dev);
+	mv_switch_mac_addr_set(unicast, group, 1);
+	mv_switch_mac_addr_set(broadcast, group, 1);
+
+	return 0;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_mgr_init(MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int gbe_port)
+{
+	char name[7] = {0, 0, 0, 0, 0, 0, 0};
+	MV_MUX_TAG tag;
+	unsigned int g, groups = mv_switch_group_map_get();
+
+	for (g = 0; g < MV_SWITCH_DB_NUM; g++) {
+		if (MV_BIT_CHECK(groups, g)) {
+			/* get tag data according to switch */
+			mv_switch_tag_get(&tag, preset, vid, tag_mode, g);
+
+			/* assign name */
+			sprintf(name, "mux%d", g);
+
+			/* create new mux device */
+			mv_mux_mgr_create(name, gbe_port, g, &tag);
+		}
+	}
+
+	return 0;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_mgr_probe(int gbe_port)
+{
+	MV_TAG_TYPE tag_mode = mux_switch_shadow.tag_type;
+	MV_SWITCH_PRESET_TYPE preset = mux_switch_shadow.preset;
+	int vid = mux_switch_shadow.vid;
+
+	/* config switch according to preset mode */
+	mv_switch_preset_init(preset, tag_mode, vid);
+
+	/* config mux interfaces according to preset mode */
+	mv_mux_mgr_init(preset, vid, tag_mode, gbe_port);
+
+	/* update netdev port with tag type */
+	mv_mux_tag_type_set(gbe_port, tag_mode);
+
+	if (tag_mode != MV_TAG_TYPE_NONE)
+		if (mux_eth_ops && mux_eth_ops->set_tag_type)
+			/*must be true if (tag_type != none)*/
+			mux_eth_ops->promisc_set(gbe_port);
+
+	mv_switch_interrupt_unmask();
+
+	printk(KERN_ERR "port #%d establish switch connection\n\n", gbe_port);
+
+	return 0;
+}
+#else
+static int mv_mux_mgr_probe(int gbe_port)
+{
+	return 0;
+}
+#endif /*CONFIG_MV_INCLUDE_SWITCH*/
+
+
+/*-----------------------------------------------------------------------------------------*/
+/*----------------------------    MUX DRIVER    -------------------------------------------*/
+/*-----------------------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port)
+{
+	mux_switch_shadow.tag_type = tag;
+	mux_switch_shadow.preset = preset;
+	mux_switch_shadow.vid = vid;
+	mux_switch_shadow.switch_port = switch_port;
+	mux_switch_shadow.gbe_port = gbe_port;
+	mux_switch_shadow.attach = MV_TRUE;
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	/* set mux ops to be used by switch driver */
+	switch_mux_ops.update_link = mv_mux_update_link;
+	mv_switch_mux_ops_set(&switch_mux_ops);
+#endif
+
+	if (mux_eth_shadow[gbe_port].root)
+		/* gbe port already attached */
+		mv_mux_mgr_probe(gbe_port);
+}
+
+
+void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops *ops)
+{
+	/* update root device in shadow */
+	mux_eth_shadow[port].root = root;
+
+	/* update ops structure */
+	mux_eth_ops = ops;
+
+	if (mux_switch_shadow.attach && (mux_switch_shadow.gbe_port == port))
+		/* switch already attached */
+		mv_mux_mgr_probe(port);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_netdev_find(unsigned int dev_idx)
+{
+	int port;
+	struct net_device *root;
+
+	for (port = 0; port < MV_ETH_MAX_PORTS; port++) {
+		root = mux_eth_shadow[port].root;
+
+		if (root && (root->ifindex == dev_idx))
+			return port;
+	}
+	return -1;
+}
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_update_link(void *cookie, int link_up)
+{
+	struct net_device *mux_dev = (struct net_device *)cookie;
+
+	(link_up) ? netif_carrier_on(mux_dev) : netif_carrier_off(mux_dev);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static inline int mv_mux_get_tag_size(MV_TAG_TYPE type)
+{
+	static const int size_arr[] = {0, MV_ETH_MH_SIZE,
+					MV_ETH_DSA_SIZE,
+					MV_TAG_TYPE_EDSA,
+					MV_TAG_TYPE_VLAN};
+	return size_arr[type];
+}
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_rx(struct sk_buff *skb, int port, struct napi_struct *napi)
+
+{
+	struct net_device *mux_dev;
+	int    len;
+
+	mux_dev = mv_mux_rx_netdev_get(port, skb);
+
+	if (mux_dev == NULL)
+		goto out;
+
+	/* mux device is down */
+	if (!(mux_dev->flags & IFF_UP))
+		goto out1;
+
+	/* remove tag*/
+	len = mv_mux_rx_tag_remove(mux_dev, skb);
+	mux_dev->stats.rx_packets++;
+	mux_dev->stats.rx_bytes += skb->len - len;
+
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	if (mux_eth_shadow[port].flags & MV_MUX_F_DBG_RX) {
+		struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
+		printk(KERN_ERR "\n%s - %s: port=%d, cpu=%d\n", mux_dev->name, __func__, pmux_priv->port, smp_processor_id());
+		/* mv_eth_skb_print(skb); */
+		mvDebugMemDump(skb->data, 64, 1);
+	}
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+/*
+#ifdef ETH_SKB_DEBUG
+		mv_eth_skb_check(skb);
+#endif
+*/
+	skb->protocol = eth_type_trans(skb, mux_dev);
+
+	if (mux_dev->features & NETIF_F_GRO) {
+		/*
+		TODO update mux priv gro counters
+		STAT_DBG(pp->stats.rx_gro++);
+		STAT_DBG(pp->stats.rx_gro_bytes += skb->len);
+	`	*/
+		return napi_gro_receive(napi, skb);
+	}
+
+
+	return netif_receive_skb(skb);
+
+out1:
+	mux_dev->stats.rx_dropped++;
+out:
+	kfree_skb(skb);
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
+
+	if (!(netif_running(dev))) {
+		printk(KERN_ERR "!netif_running() in %s\n", __func__);
+		goto out;
+	}
+
+	if (mv_mux_tx_skb_tag_add(dev, skb)) {
+		printk(KERN_ERR "%s: mv_mux_tx_skb_tag_add failed.\n", __func__);
+		goto out;
+	}
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	if (mux_eth_shadow[pmux_priv->port].flags & MV_MUX_F_DBG_TX) {
+		printk(KERN_ERR "\n%s - %s_%lu: port=%d, cpu=%d, in_intr=0x%lx\n",
+			dev->name, __func__, dev->stats.tx_packets, pmux_priv->port, smp_processor_id(), in_interrupt());
+		/* mv_eth_skb_print(skb); */
+		mvDebugMemDump(skb->data, 64, 1);
+	}
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	/* assign the packet to the hw interface */
+	skb->dev = mux_eth_shadow[pmux_priv->port].root;
+
+	/*tell Linux to pass it to its device */
+	return dev_queue_xmit(skb);
+
+out:
+	dev->stats.tx_dropped++;
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Return mux device mac address							   */
+/*-----------------------------------------------------------------------------------------*/
+char *mv_mux_get_mac(struct net_device *mux_dev)
+{
+
+	if (!mux_dev) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return NULL;
+	}
+
+	return mux_dev->dev_addr;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static void mv_mux_set_rx_mode(struct net_device *dev)
+{
+/*
+	printk(KERN_ERR "Invalid operation %s is virtual interface.\n", dev->name);
+*/
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_change_rx_flags(struct net_device *mux_dev, int flags)
+{
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (mux_switch_shadow.attach) {
+		struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
+
+		mv_switch_promisc_set(pmux_priv->idx, (mux_dev->flags & IFF_PROMISC) ? 1 : 0);
+	}
+#endif
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mv_mux_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	/*TODO compleate implementation*/
+	printk(KERN_ERR "Not supported yet.\n");
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_close(struct net_device *dev)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+	netif_stacked_transfer_operstate(root, dev);
+	netif_tx_stop_all_queues(dev);
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (mux_switch_shadow.attach)
+		mv_switch_group_disable(pmux_priv->idx);
+#endif
+	printk(KERN_NOTICE "%s: stopped\n", dev->name);
+
+	return MV_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_open(struct net_device *dev)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	if (!root) {
+		printk(KERN_ERR "%s:Invalid operation, set master before up.\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* if master is close */
+	if (!(root->flags & IFF_UP)) {
+		printk(KERN_ERR "%s:Invalid operation, port %d is down.\n", __func__, pmux_priv->port);
+		return MV_ERROR;
+	}
+
+	netif_stacked_transfer_operstate(root, dev);
+	netif_tx_wake_all_queues(dev);
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (mux_switch_shadow.attach)
+		mv_switch_group_enable(pmux_priv->idx);
+#endif
+
+	printk(KERN_NOTICE "%s: started\n", dev->name);
+
+	return MV_OK;
+
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static int mv_mux_set_mac(struct net_device *dev, void *addr)
+{
+	u8 *mac = &(((u8 *)addr)[2]);  /* skip on first 2B (ether HW addr type) */
+
+	mv_mux_close(dev);
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (mux_switch_shadow.attach) {
+		struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
+
+		mv_switch_mac_update(pmux_priv->idx, dev->dev_addr, mac);
+	}
+#endif
+	memcpy(dev->dev_addr, mac, ETH_ALEN);
+
+	mv_mux_open(dev);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_mtu_change(struct net_device *mux_dev, int mtu)
+{
+	printk(KERN_ERR "Invalid operation %s is virtual port.\n", mux_dev->name);
+	return MV_ERROR;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Create new mux device, if device is allready exist just change tag value                */
+/* mv_mux_netdev_add should called after mv_mux_netdev_alloc                               */
+/*-----------------------------------------------------------------------------------------*/
+struct net_device *mv_mux_netdev_alloc(char *name, int idx, MV_MUX_TAG *tag_cfg)
+{
+	struct net_device *mux_dev;
+	struct mux_netdev *pmux_priv;
+
+	if (name == NULL) {
+		printk(KERN_ERR "%s: mux net device name is missig.\n", __func__);
+		return NULL;
+	}
+
+	mux_dev = dev_get_by_name(&init_net, name);
+
+
+	if (!mux_dev) {
+		/* new net device */
+		mux_dev = alloc_netdev(sizeof(struct mux_netdev), name, ether_setup);
+		if (!mux_dev) {
+			printk(KERN_ERR "%s: out of memory, net device allocation failed.\n", __func__);
+			return NULL;
+		}
+		/* allocation succeed */
+		mux_dev->irq = NO_IRQ;
+		/* must set netdev_ops before registration */
+		mux_dev->netdev_ops = &mv_mux_netdev_ops;
+
+		if (register_netdev(mux_dev)) {
+			printk(KERN_ERR "%s: failed to register %s\n", __func__, mux_dev->name);
+			free_netdev(mux_dev);
+			return NULL;
+		}
+
+	} else
+		dev_put(mux_dev);
+
+	pmux_priv = MV_MUX_PRIV(mux_dev);
+
+	if (tag_cfg == NULL) {
+		memset(pmux_priv, 0, sizeof(struct mux_netdev));
+		pmux_priv->port = -1;
+		pmux_priv->next = NULL;
+	} else{
+		/* next, pp not changed*/
+		pmux_priv->tx_tag = tag_cfg->tx_tag;
+		pmux_priv->rx_tag_ptrn = tag_cfg->rx_tag_ptrn;
+		pmux_priv->rx_tag_mask = tag_cfg->rx_tag_mask;
+	}
+	pmux_priv->idx = idx;
+	return mux_dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Init mux device features								   */
+/*-----------------------------------------------------------------------------------------*/
+static inline void mv_mux_init_features(struct net_device *mux_dev)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	mux_dev->features = root->features;
+	mux_dev->hw_features = root->hw_features;
+	mux_dev->wanted_features = root->wanted_features;
+	mux_dev->vlan_features = root->vlan_features;
+
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mv_mux_set_features(struct net_device *mux_dev, netdev_features_t features)
+{
+
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+	netdev_features_t changed = mux_dev->features ^ features;
+	netdev_features_t old = mux_dev->features;
+
+	if (changed & NETIF_F_TSO)
+		if (!(old & NETIF_F_TSO))
+			/* mux interface want to set tso */
+			if (!(root->features & NETIF_F_TSO))
+				/* master tso is down */
+				return -EOPNOTSUPP;
+
+	if (changed & NETIF_F_IP_CSUM)
+		if (!(old & NETIF_F_IP_CSUM))
+			/* mux interface want to set tx csum */
+			if (!(root->features & NETIF_F_IP_CSUM))
+				/* master tx csum is down */
+				return -EOPNOTSUPP;
+	return MV_OK;
+}
+
+/*----------------------------------------------------------------------------------------*/
+/* Function attache mux device to root device,						  */
+/* Set mux mac address and features according to root device				  */
+/*----------------------------------------------------------------------------------------*/
+static struct net_device *mv_mux_netdev_init(int port, struct net_device *mux_dev)
+{
+	struct mux_netdev *pmux_priv;
+	struct net_device *root = mux_eth_shadow[port].root;
+	int tag_type = mux_eth_shadow[port].tag_type;
+
+
+	if (root == NULL)
+		return NULL;
+
+/*
+	if (pp && !(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
+		printk(KERN_ERR "%s: root device is not connect to linux.\n", __func__);
+		return NULL;
+	}
+*/
+	if (!mux_dev) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return NULL;
+	}
+
+	/* set skb header size , avoid from skb reallocation*/
+	mux_dev->hard_header_len = root->hard_header_len +
+					mv_mux_get_tag_size(tag_type);
+
+	/* Copy MAC address and MTU from root netdevice */
+	mux_dev->mtu = root->mtu;
+	pmux_priv = MV_MUX_PRIV(mux_dev);
+	pmux_priv->port = port;
+	memcpy(mux_dev->dev_addr, root->dev_addr, MV_MAC_ADDR_SIZE);
+
+	/* TODO: handle features */
+	mv_mux_init_features(mux_dev);
+
+	/*SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
+
+	return mux_dev;
+}
+/*-----------------------------------------------------------------------------------------*/
+struct net_device *mv_mux_switch_ptr_get(int port)
+{
+	return mux_eth_shadow[port].switch_dev;
+}
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_tag_type_get(int port)
+{
+	return mux_eth_shadow[port].tag_type;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+struct net_device *mv_mux_netdev_add(int port, struct net_device *mux_dev)
+
+{
+
+	struct net_device *dev_temp;
+	struct net_device *switch_dev;
+
+	struct mux_netdev *pdev;
+
+	if (mux_eth_shadow[port].root == NULL)
+		return NULL;
+
+	mux_dev = mv_mux_netdev_init(port, mux_dev);
+
+	if (mux_dev == NULL)
+		return NULL;
+
+	switch_dev = mux_eth_shadow[port].switch_dev;
+
+	if (switch_dev == NULL) {
+		/* First tag netdev */
+		mux_eth_shadow[port].switch_dev = mux_dev;
+	} else {
+		pdev = MV_MUX_PRIV(switch_dev);
+		while (pdev->next != NULL) {
+			dev_temp = pdev->next;
+			pdev = MV_MUX_PRIV(dev_temp);
+		}
+		pdev->next = mux_dev;
+	}
+	return mux_dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_tag_type_set(int port, int type)
+{
+	unsigned int flgs;
+	struct net_device *root;
+
+
+	if ((type < MV_TAG_TYPE_NONE) || (type >= MV_TAG_TYPE_LAST)) {
+		printk(KERN_INFO "%s: Invalid tag type %d\n", __func__, type);
+		return MV_ERROR;
+	}
+	root = mux_eth_shadow[port].root;
+	/* port not initialized */
+	if (root == NULL)
+		return MV_ERROR;
+
+	flgs = root->flags;
+
+	if (flgs & IFF_UP) {
+		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, root->name);
+		return MV_ERROR;
+	}
+
+	mux_eth_shadow[port].tag_type = type;
+
+	if (mux_eth_ops && mux_eth_ops->set_tag_type)
+		mux_eth_ops->set_tag_type(port, mux_eth_shadow[port].tag_type);
+
+	return MV_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+/* Delete mux device                                                                       */
+/*	remove device from port linked list						   */
+/*	free mux device                                                                    */
+/*-----------------------------------------------------------------------------------------*/
+
+int mv_mux_netdev_delete(struct net_device *mux_dev)
+{
+	struct net_device *pdev_curr, *pdev_prev = NULL;
+	struct mux_netdev *pdev_tmp_curr, *pdev_tmp_prev, *pdev;
+	struct net_device *root;
+	int flgs, port;
+
+	if (mux_dev == NULL) {
+		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
+		return MV_ERROR;
+	}
+	pdev = MV_MUX_PRIV(mux_dev);
+	port = pdev->port;
+
+	root = mux_eth_shadow[pdev->port].root;
+
+	/*not attached to gbe port*/
+	if (root == NULL) {
+		synchronize_net();
+		unregister_netdev(mux_dev);
+		free_netdev(mux_dev);
+		return MV_OK;
+	}
+
+	flgs = mux_dev->flags;
+	if (flgs & IFF_UP) {
+		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, root->name);
+		return MV_ERROR;
+	}
+
+	pdev_curr = mux_eth_shadow[port].switch_dev;
+
+	while (pdev_curr != NULL) {
+
+		pdev_tmp_curr = MV_MUX_PRIV(pdev_curr);
+
+		if (pdev_curr == mux_dev) {
+			if (pdev_curr == mux_eth_shadow[port].switch_dev) {
+				/* first element*/
+				mux_eth_shadow[port].switch_dev = pdev_tmp_curr->next;
+			} else {
+				pdev_tmp_prev = MV_MUX_PRIV(pdev_prev);
+				pdev_tmp_prev->next = pdev_tmp_curr->next;
+			}
+			/* delet current */
+			synchronize_net();
+			unregister_netdev(mux_dev);
+			free_netdev(mux_dev);
+			return MV_OK;
+
+		} else {
+			pdev_prev = pdev_curr;
+			pdev_curr = pdev_tmp_curr->next;
+		}
+	}
+	/* mux_dev not found */
+	return MV_ERROR;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static int mux_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
+{
+	struct net_device *mux_dev, *dev = ptr;
+	struct mux_netdev *pdev_priv;
+	int tag_type;
+	int port = 0;
+	int flgs;
+
+	/*recognize if marvell event */
+	port = mv_mux_netdev_find(dev->ifindex);
+
+	if (port == -1)
+		goto out;
+
+	tag_type = mux_eth_shadow[port].tag_type;
+
+	/* exit - if not mux device */
+	if (tag_type == MV_TAG_TYPE_NONE)
+		goto out;
+
+	switch (event) {
+
+	case NETDEV_CHANGE:
+		mux_dev = mux_eth_shadow[port].switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+			if (mux_switch_shadow.attach) {
+				/* In case of internal switch, link is determined by switch */
+				int link_up = mv_switch_link_status_get(pdev_priv->idx);
+				mv_mux_update_link(mux_dev, link_up);
+			}
+#else
+
+			/* In case of external switch, propagate real device link state to mux devices */
+			/* change state*/
+			netif_stacked_transfer_operstate(dev, mux_dev);
+
+#endif /*CONFIG_MV_INCLUDE_SWITCH*/
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_CHANGEADDR:
+		/* Propagate real device mac adress to mux devices */
+		mux_dev = mux_eth_shadow[port].switch_dev;
+
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+			/* May be called without an actual change */
+			if (!compare_ether_addr(mux_dev->dev_addr, dev->dev_addr)) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			memcpy(mux_dev->dev_addr, dev->dev_addr, ETH_ALEN);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_CHANGEMTU:
+		mux_dev = mux_eth_shadow[port].switch_dev;
+
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+			if (mux_dev->mtu <= dev->mtu) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_set_mtu(mux_dev, dev->mtu);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_FEAT_CHANGE:
+		/* not supported */
+		break;
+
+	case NETDEV_DOWN:
+		/* Master down - Put all mux devices for this dev in the down state too.  */
+		mux_dev = mux_eth_shadow[port].switch_dev;
+
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+			flgs = mux_dev->flags;
+			if (!(flgs & IFF_UP)) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_change_flags(mux_dev, flgs & ~IFF_UP);
+			netif_stacked_transfer_operstate(dev, mux_dev);
+			mux_dev = pdev_priv->next;
+		}
+		break;
+
+	case NETDEV_UP:
+		/* Master up - Put all mux devices for this dev in the up state too.  */
+		mux_dev = mux_eth_shadow[port].switch_dev;
+
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+			flgs = mux_dev->flags;
+			if (flgs & IFF_UP) {
+				mux_dev = pdev_priv->next;
+				continue;
+			}
+			dev_change_flags(mux_dev, flgs | IFF_UP);
+
+			netif_stacked_transfer_operstate(dev, mux_dev);
+			mux_dev = pdev_priv->next;
+		}
+
+		break;
+	} /*switch*/
+out:
+	return NOTIFY_DONE;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static struct notifier_block mux_notifier_block __read_mostly = {
+	.notifier_call = mux_device_event,
+};
+
+/*-----------------------------------------------------------------------------------------*/
+static int __init mux_proto_init(void)
+{
+	int err;
+
+	err = register_netdevice_notifier(&mux_notifier_block);
+
+	if (err < 0)
+		unregister_netdevice_notifier(&mux_notifier_block);
+	return err;
+
+}
+/*-----------------------------------------------------------------------------------------*/
+
+bool mv_mux_netdev_link_status(struct net_device *dev)
+{
+	return netif_carrier_ok(dev) ? true : false;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid)
+{
+
+	mux_cfg->tx_tag.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
+	mux_cfg->rx_tag_ptrn.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
+
+	/*mask priority*/
+	mux_cfg->rx_tag_mask.vlan = MV_32BIT_BE(0xFFFF0FFF);
+
+	mux_cfg->tag_type = MV_TAG_TYPE_VLAN;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg)
+{
+	if (mux_dev) {
+		struct mux_netdev *pmux_priv;
+		pmux_priv = MV_MUX_PRIV(mux_dev);
+		mux_cfg->tx_tag = pmux_priv->tx_tag;
+		mux_cfg->rx_tag_ptrn = pmux_priv->rx_tag_ptrn;
+		mux_cfg->rx_tag_mask = pmux_priv->rx_tag_mask;
+	} else
+		memset(mux_cfg, 0, sizeof(MV_MUX_TAG));
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_mh_netdev_get(int port, MV_TAG *tag)
+{
+	struct net_device *dev = mux_eth_shadow[port].switch_dev;
+	struct mux_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_MUX_PRIV(dev);
+		if ((tag->mh & pdev->rx_tag_mask.mh) == pdev->rx_tag_ptrn.mh)
+			return dev;
+
+		dev = pdev->next;
+	}
+	printk(KERN_ERR "%s: MH=0x%04x match no interfaces\n", __func__, tag->mh);
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_vlan_netdev_get(int port, MV_TAG *tag)
+{
+	struct net_device *dev = mux_eth_shadow[port].switch_dev;
+	struct mux_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_MUX_PRIV(dev);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+		if (mux_eth_shadow[port].flags & MV_MUX_F_DBG_RX)
+			printk(KERN_ERR "pkt tag = 0x%x, rx_tag_ptrn = 0x%x, rx_tag_mask = 0x%x\n",
+				 tag->vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
+#endif
+		if ((tag->vlan & pdev->rx_tag_mask.vlan) ==
+			(pdev->rx_tag_ptrn.vlan & pdev->rx_tag_mask.vlan))
+			return dev;
+
+		dev = pdev->next;
+	}
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
+#endif
+
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_dsa_netdev_get(int port, MV_TAG *tag)
+{
+	/*
+	   MV_TAG.vlan and MV_TAG.dsa size are equal.
+	   MV_TAG type is union.
+	   We can use in the same functins.
+	*/
+
+	return mv_mux_vlan_netdev_get(port, tag);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline struct net_device *mv_mux_edsa_netdev_get(int port, MV_TAG *tag)
+{
+	struct net_device *dev = mux_eth_shadow[port].switch_dev;
+	struct mux_netdev *pdev;
+
+	while (dev != NULL) {
+		pdev = MV_MUX_PRIV(dev);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+		if (mux_eth_shadow[port].flags & MV_MUX_F_DBG_RX)
+			printk(KERN_ERR "pkt tag = 0x%x %x, rx_tag_ptrn = 0x%x %x, rx_tag_mask = 0x%x %x\n",
+				 tag->edsa[0], tag->edsa[1], pdev->rx_tag_ptrn.edsa[0], pdev->rx_tag_ptrn.edsa[1],
+				 pdev->rx_tag_mask.edsa[0], pdev->rx_tag_mask.edsa[1]);
+#endif
+		/* compare tags */
+		if (((tag->edsa[0] & pdev->rx_tag_mask.edsa[0]) ==
+			(pdev->rx_tag_ptrn.edsa[0] & pdev->rx_tag_mask.edsa[0])) &&
+			((tag->edsa[1] & pdev->rx_tag_mask.edsa[1]) ==
+			(pdev->rx_tag_ptrn.edsa[1] & pdev->rx_tag_mask.edsa[1])))
+				return dev;
+
+		dev = pdev->next;
+	}
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
+#endif
+
+	return NULL;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+
+static inline struct net_device *mv_mux_rx_netdev_get(int port, struct sk_buff *skb)
+{
+	struct net_device *dev;
+	MV_TAG tag;
+	MV_U8 *data = skb->data;
+	int tag_type = mux_eth_shadow[port].tag_type;
+
+
+	/* skb->data point to MH */
+	switch (tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		tag.mh = *(MV_U16 *)data;
+		dev = mv_mux_mh_netdev_get(port, &tag);
+		break;
+
+	case MV_TAG_TYPE_VLAN:
+		tag.vlan = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		dev = mv_mux_vlan_netdev_get(port, &tag);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		tag.dsa = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		dev = mv_mux_dsa_netdev_get(port, &tag);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		tag.edsa[0] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
+		tag.edsa[1] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE) + 4);
+		dev = mv_mux_edsa_netdev_get(port, &tag);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, tag_type);
+		return NULL;
+	}
+
+	return dev;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+static inline int mv_mux_mh_skb_remove(struct sk_buff *skb)
+{
+	__skb_pull(skb, MV_ETH_MH_SIZE);
+	return MV_ETH_MH_SIZE;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_vlan_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_VLAN_HLEN, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_VLAN_HLEN);
+
+	return MV_ETH_VLAN_SIZE;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_dsa_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_ETH_DSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_ETH_DSA_SIZE);
+
+	return MV_ETH_DSA_SIZE;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_edsa_skb_remove(struct sk_buff *skb)
+{
+	/* memmove use temporrary array, no overlap problem*/
+	memmove(skb->data + MV_ETH_EDSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
+
+	__skb_pull(skb, MV_ETH_EDSA_SIZE);
+
+	return MV_ETH_EDSA_SIZE;
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_rx_tag_remove(struct net_device *dev, struct sk_buff *skb)
+{
+	int shift = 0;
+	struct mux_netdev *pdev = MV_MUX_PRIV(dev);
+	int tag_type = mux_eth_shadow[pdev->port].tag_type;
+
+	if (pdev->leave_tag == true)
+		return 0;
+
+	switch (tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		break;
+
+	case MV_TAG_TYPE_VLAN:
+		shift = mv_mux_vlan_skb_remove(skb);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		shift = mv_mux_dsa_skb_remove(skb);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		shift = mv_mux_edsa_skb_remove(skb);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, tag_type);
+		return -1;
+	}
+	/* MH exist in packet anycase - Skip it */
+	shift += mv_mux_mh_skb_remove(skb);
+
+	return shift;
+}
+
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
+{
+
+	/* sanity: Check that there is place for MH in the buffer */
+	if (skb_headroom(skb) < MV_ETH_MH_SIZE) {
+		printk(KERN_ERR "%s: skb (%p) doesn't have place for MH, head=%p, data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	/* Prepare place for MH header */
+	__skb_push(skb, MV_ETH_MH_SIZE);
+
+	*((u16 *) skb->data) = mh;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_mh_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mux_netdev *pdev = MV_MUX_PRIV(dev);
+
+	return mv_eth_skb_mh_add(skb, pdev->tx_tag.mh);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_skb_vlan_add(struct sk_buff *skb, unsigned int vlan)
+{
+	unsigned char *pvlan;
+/*
+	TODO: add stat counter to mux_pp
+		mean that there is not enough bytes in header room
+		to push vlan, skb_cow will realloc skb
+
+	if (skb_headroom(skb) < MV_VLAN_HLEN) {
+		mux_skb_tx_realloc++;
+	}
+*/
+	if (skb_cow(skb, MV_VLAN_HLEN)) {
+		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	__skb_push(skb, MV_VLAN_HLEN);
+
+	memmove(skb->data, skb->data + MV_VLAN_HLEN, 2 * MV_MAC_ADDR_SIZE);
+
+	pvlan = skb->data + (2 * MV_MAC_ADDR_SIZE);
+	*(MV_U32 *)pvlan = vlan;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_vlan_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mux_netdev *pdev = MV_MUX_PRIV(dev);
+
+	return mv_mux_skb_vlan_add(skb, pdev->tx_tag.vlan);
+}
+
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_tx_skb_dsa_add(struct net_device *dev, struct sk_buff *skb)
+{
+	/* both DSA and VLAN are 4 bytes tags, placed in the same offset in the packet */
+	return mv_mux_tx_skb_vlan_add(dev, skb);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_skb_edsa_add(struct sk_buff *skb, unsigned int edsaL, unsigned int edsaH)
+{
+	unsigned char *pedsa;
+
+	if (skb_cow(skb, MV_ETH_EDSA_SIZE)) {
+		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
+		       __func__, skb, skb->head, skb->data);
+		return 1;
+	}
+
+	__skb_push(skb, MV_ETH_EDSA_SIZE);
+
+	memmove(skb->data, skb->data + MV_ETH_EDSA_SIZE, 2 * MV_MAC_ADDR_SIZE);
+
+	pedsa = skb->data + (2 * MV_MAC_ADDR_SIZE);
+	*(MV_U32 *)pedsa = edsaL;
+	*((MV_U32 *)pedsa + 1) = edsaH;
+
+	return MV_OK;
+}
+
+static inline int mv_mux_tx_skb_edsa_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mux_netdev *pdev = MV_MUX_PRIV(dev);
+
+	return mv_mux_skb_edsa_add(skb, pdev->tx_tag.edsa[0], pdev->tx_tag.edsa[1]);
+}
+
+/*-----------------------------------------------------------------------------------------*/
+
+static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb)
+{
+	struct mux_netdev *pdev = MV_MUX_PRIV(dev);
+	int tag_type = mux_eth_shadow[pdev->port].tag_type;
+	int err = 0;
+
+	switch (tag_type) {
+
+	case MV_TAG_TYPE_MH:
+		err = mv_mux_tx_skb_mh_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_VLAN:
+		err = mv_mux_tx_skb_vlan_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_DSA:
+		err = mv_mux_tx_skb_dsa_add(dev, skb);
+		break;
+	case MV_TAG_TYPE_EDSA:
+		err = mv_mux_tx_skb_edsa_add(dev, skb);
+		break;
+	default:
+		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, tag_type);
+		err = 1;
+	}
+	return err;
+}
+
+/*--------------------------------------------------------------------------------------*/
+/* Print mux device data								*/
+/*--------------------------------------------------------------------------------------*/
+
+void mv_mux_netdev_print(struct net_device *mux_dev)
+{
+
+	struct mux_netdev *pdev;
+	int tag_type;
+
+
+	if (!mux_dev) {
+		printk(KERN_ERR "%s:device in NULL.\n", __func__);
+		return;
+	}
+
+	if (mv_mux_netdev_find(mux_dev->ifindex) != -1) {
+		printk(KERN_ERR "%s: %s is not mux device.\n", __func__, mux_dev->name);
+		return;
+	}
+
+	pdev = MV_MUX_PRIV(mux_dev);
+
+	if (!pdev || (pdev->port == -1)) {
+		printk(KERN_ERR "%s: device must be conncted to physical port\n", __func__);
+		return;
+	}
+	tag_type = mux_eth_shadow[pdev->port].tag_type;
+	switch (tag_type) {
+
+	case MV_TAG_TYPE_VLAN:
+		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
+			mux_dev->name, pdev->port, pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_dsa=0x%08x, rx_dsa=0x%08x, rx_mask=0x%08x\n",
+			mux_dev->name, pdev->port, pdev, pdev->tx_tag.dsa, pdev->rx_tag_ptrn.dsa, pdev->rx_tag_mask.dsa);
+		break;
+
+	case MV_TAG_TYPE_MH:
+		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mh=0x%04x\n",
+			mux_dev->name, pdev->port, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_edsa=0x%08x %08x, rx_edsa=0x%08x %08x, rx_mask=0x%08x %08x\n",
+			mux_dev->name, pdev->port, pdev, pdev->tx_tag.edsa[1], pdev->tx_tag.edsa[0],
+			pdev->rx_tag_ptrn.edsa[1], pdev->rx_tag_ptrn.edsa[0],
+			pdev->rx_tag_mask.edsa[1], pdev->rx_tag_mask.edsa[0]);
+		break;
+
+	default:
+		printk(KERN_ERR "%s: Error, Unknown tag type\n", __func__);
+	}
+}
+/*--------------------------------------------------------------------------------------*/
+/* Print all port's mux devices data							*/
+/*--------------------------------------------------------------------------------------*/
+void mv_mux_netdev_print_all(int port)
+{
+	struct net_device *dev;
+	struct mux_netdev *dev_priv;
+
+	dev = mux_eth_shadow[port].root;
+
+	if (!dev)
+		return;
+
+	dev = mux_eth_shadow[port].switch_dev;
+
+	while (dev != NULL) {
+		mv_mux_netdev_print(dev);
+		dev_priv = MV_MUX_PRIV(dev);
+		dev = dev_priv->next;
+		printk(KERN_CONT "\n");
+	}
+}
+/*-----------------------------------------------------------------------------------------*/
+int mv_mux_ctrl_dbg_flag(int port, u32 flag, u32 val)
+{
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	struct net_device *root = mux_eth_shadow[port].root;
+	u32 bit_flag = (fls(flag) - 1);
+
+	if (!root)
+		return -ENODEV;
+
+	if (val)
+		set_bit(bit_flag, (unsigned long *)&(mux_eth_shadow[port].flags));
+	else
+		clear_bit(bit_flag, (unsigned long *)&(mux_eth_shadow[port].flags));
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+	return 0;
+}
+/*-----------------------------------------------------------------------------------------*/
+
+static const struct net_device_ops mv_mux_netdev_ops = {
+	.ndo_open		= mv_mux_open,
+	.ndo_stop		= mv_mux_close,
+	.ndo_start_xmit		= mv_mux_xmit,
+	.ndo_set_mac_address	= mv_mux_set_mac,
+	.ndo_do_ioctl		= mv_mux_ioctl,
+	.ndo_set_rx_mode	= mv_mux_set_rx_mode,
+	.ndo_change_rx_flags	= mv_mux_change_rx_flags,
+	.ndo_set_features	= mv_mux_set_features,
+};
+
+module_init(mux_proto_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
new file mode 100644
index 0000000..5295839
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
@@ -0,0 +1,100 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_tag_netdev_h__
+#define __mv_tag_netdev_h__
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/ip.h>
+
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mv802_3.h"
+
+
+struct mux_netdev {
+	int	idx;
+	int	port;
+	bool    leave_tag;
+	MV_TAG  tx_tag;
+	MV_TAG  rx_tag_ptrn;
+	MV_TAG  rx_tag_mask;
+	struct  net_device *next;
+};
+
+#define MV_MUX_PRIV(dev)        ((struct mux_netdev *)(netdev_priv(dev)))
+
+
+struct mv_mux_eth_port {
+	int    tag_type;
+	struct net_device *switch_dev;
+	struct net_device *root;
+	unsigned long flags;
+};
+
+#define MV_MUX_F_DBG_RX_BIT         0
+#define MV_MUX_F_DBG_TX_BIT         1
+
+#define MV_MUX_F_DBG_RX            (1 << MV_MUX_F_DBG_RX_BIT)
+#define MV_MUX_F_DBG_TX            (1 << MV_MUX_F_DBG_TX_BIT)
+
+
+struct mv_mux_switch_port {
+	int    tag_type;
+	int    preset;
+	int    vid;
+	int    switch_port;
+	int    gbe_port;
+	bool   attach;
+};
+
+struct mv_mux_eth_ops {
+	int	(*set_tag_type)(int port, int tag_type);
+	void	(*promisc_set)(int port);
+};
+
+int mv_mux_update_link(void *cookie, int link_up);
+struct net_device *mv_mux_netdev_add(int port, struct net_device *mux_dev);
+struct net_device *mv_mux_netdev_alloc(char *name, int idx, MV_MUX_TAG *tag_cfg);
+char *mv_mux_get_mac(struct net_device *mux_dev);
+int mv_mux_netdev_delete(struct net_device *mux_dev);
+int mv_mux_tag_type_set(int port, int type);
+void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid);
+void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg);
+int mv_mux_rx(struct sk_buff *skb, int port, struct napi_struct *napi);
+void mv_mux_netdev_print(struct net_device *mux_dev);
+void mv_mux_netdev_print_all(int port);
+struct net_device *mv_mux_switch_ptr_get(int port);
+int mv_mux_ctrl_dbg_flag(int port, u32 flag, u32 val);
+void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops *ops);
+void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port);
+
+
+#endif /* __mv_tag_netdev_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
new file mode 100644
index 0000000..a3f4845
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
@@ -0,0 +1,244 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "mv_mux_netdev.h"
+MV_MUX_TAG mux_cfg;
+
+static ssize_t mv_mux_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [if_name]                 > dump         - Dump mux device\n");
+	off += sprintf(buf+off, "echo [if_name] p               > add          - Attach to gbe [p] new virtual interface [if_name]\n");
+	off += sprintf(buf+off, "echo [if_name]                 > del          - Remove virtual interface [if_name]\n");
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo p {0|1|2|3|4}             > tag_type     - Set port [p] tag: 0-NONE, 1-MH, 2-DSA, 3-EDSA, 4-VID\n");
+	off += sprintf(buf+off, "echo [if_name] vid             > mux_vid      - Set virtual interface [if_name] vid value.\n");
+	off += sprintf(buf+off, "echo [if_name] mh mask         > mh_rx        - Set virtual port Marvell header RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] dsa mask        > dsa_rx       - Set virtual port DSA RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] tagL mask       > edsa_low_rx  - Set virtual port EDSA low RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] tagH mask       > edsa_high_rx - Set virtual port EDSA high RX tag and mask\n");
+	off += sprintf(buf+off, "echo [if_name] mh              > mh_tx        - Set virtual port Marvell header tX tag\n");
+	off += sprintf(buf+off, "echo [if_name] dsa             > dsa_tx       - Set virtual port DSA TX tag\n");
+	off += sprintf(buf+off, "echo [if_name] tagH tagL       > edsa_tx      - Set virtual port EDSA TX tag\n");
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	off += sprintf(buf+off, "echo [p] [hex]                 > debug        - bit0:rx, bit1:tx\n");
+#endif
+
+	return off;
+}
+
+
+static ssize_t mv_mux_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+/*
+	const char      *name = attr->attr.name;
+	int             off = 0;
+*/
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	return mv_mux_help(buf);
+}
+
+
+static ssize_t mv_mux_netdev_store(struct device *dev,
+					struct device_attribute *attr, const char *buf, size_t len)
+{
+	struct net_device *mux_dev;
+	const char        *name = attr->attr.name;
+	int               a = 0, b = 0, err = 0;
+	char              dev_name[IFNAMSIZ];
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	sscanf(buf, "%s %x %x", dev_name, &a, &b);
+	mux_dev = dev_get_by_name(&init_net, dev_name);
+
+	if (mux_dev)
+		dev_put(mux_dev);
+
+	if (!strcmp(name, "dump")) {
+		mv_mux_netdev_print(mux_dev);
+
+	} else if (!strcmp(name, "mux_vid")) {
+		mv_mux_vlan_set(&mux_cfg, a);
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "mh_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.mh = a;
+		mux_cfg.rx_tag_mask.mh = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "dsa_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.dsa = a;
+		mux_cfg.rx_tag_mask.dsa = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_low_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.edsa[0] = a;
+		mux_cfg.rx_tag_mask.edsa[0] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_high_rx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.rx_tag_ptrn.edsa[1] = a;
+		mux_cfg.rx_tag_mask.edsa[1] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	}  else if (!strcmp(name, "mh_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.mh = a;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	}  else if (!strcmp(name, "dsa_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.dsa = a;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "edsa_tx")) {
+		mv_mux_cfg_get(mux_dev, &mux_cfg);
+		mux_cfg.tx_tag.edsa[0] = a;
+		mux_cfg.tx_tag.edsa[1] = b;
+		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
+
+	} else if (!strcmp(name, "add")) {
+		err =  mv_mux_netdev_add(a, mux_dev) ? 0 : 1;
+
+	} else if (!strcmp(name, "del"))
+		err = mv_mux_netdev_delete(mux_dev);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_mux_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    a, b;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	a = b = err = 0;
+
+	sscanf(buf, "%x %x", &a, &b);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "tag_type")) {
+		mv_mux_tag_type_set(a, b);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	} else if (!strcmp(name, "debug")) {
+		err = mv_mux_ctrl_dbg_flag(a, MV_MUX_F_DBG_RX,   b & 0x1);
+		err = mv_mux_ctrl_dbg_flag(a, MV_MUX_F_DBG_TX,   b & 0x2);
+#endif
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+static DEVICE_ATTR(add,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(del,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mux_vid,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mh_rx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(dsa_rx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_low_rx,  S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_high_rx, S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mh_tx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(dsa_tx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_tx,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(tag_type,     S_IWUSR, mv_mux_show, mv_mux_store);
+static DEVICE_ATTR(debug,        S_IWUSR, mv_mux_show, mv_mux_store);
+static DEVICE_ATTR(dump,         S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(help,         S_IRUSR, mv_mux_show, NULL);
+
+
+static struct attribute *mv_mux_attrs[] = {
+
+	&dev_attr_add.attr,
+	&dev_attr_del.attr,
+	&dev_attr_mux_vid.attr,
+	&dev_attr_mh_rx.attr,
+	&dev_attr_dsa_rx.attr,
+	&dev_attr_edsa_low_rx.attr,
+	&dev_attr_edsa_high_rx.attr,
+	&dev_attr_mh_tx.attr,
+	&dev_attr_dsa_tx.attr,
+	&dev_attr_edsa_tx.attr,
+	&dev_attr_tag_type.attr,
+	&dev_attr_help.attr,
+	&dev_attr_dump.attr,
+	&dev_attr_debug.attr,
+	NULL
+};
+
+static struct attribute_group mv_mux_group = {
+	.name = "mv_mux",
+	.attrs = mv_mux_attrs,
+};
+
+int __devinit mv_mux_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = &platform_bus;
+	err = sysfs_create_group(&pd->kobj, &mv_mux_group);
+	if (err)
+		pr_err("Init sysfs group %s failed %d\n", mv_mux_group.name, err);
+
+	return err;
+}
+
+
+module_init(mv_mux_sysfs_init);
+
+MODULE_AUTHOR("Uri Eliyahu");
+MODULE_DESCRIPTION("sysfs for marvell GbE");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index 9b7ba1c..cf132ce 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -40,11 +40,6 @@ mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.
 mv_pp2-objs += pme/pme_sysfs.o
 mv_pp2-objs += plcr/plcr_sysfs.o
 
-mv_pp2-objs +=net_dev/mv_mux_netdev.o net_dev/mv_mux_sysfs.o
-
-ifeq ($(CONFIG_MV_INCLUE_SWITCH), y)
-mv_pp2-objs += net_dev/mv_gw_mgr.o
-endif
 
 ccflags-y       += -I$(PLAT_PATH_I)/$(HAL_PP2_DIR)
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
deleted file mode 100644
index 78a6a75..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-
-#include "mvCommon.h"
-#include "mvDebug.h"
-#include "mv_netdev.h"
-#include "mv_mux_netdev.h"
-#include "mv_switch/mv_switch.h"
-
-static struct switch_device_ops	switch_ops;
-static struct mux_device_ops 	mux_ops;
-
-static int mv_gw_mgr_mux_create(char *name, int gbe_port, int group, MV_MUX_TAG *tag)
-{
-	struct net_device *mux_dev;
-	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	char *unicast;
-	struct eth_port *pp = mv_eth_port_by_id(gbe_port);
-
-	mux_dev = mv_mux_netdev_alloc(name, group, tag);
-	if (mux_dev == NULL) {
-		printk(KERN_ERR "%s: mv_mux_netdev_alloc falied\n", __func__);
-		return MV_FAIL;
-	}
-	mv_mux_netdev_add(pp, mux_dev);
-
-	/* update switch group's cookie for mux ops */
-	mv_switch_group_cookie_set(group, mux_dev);
-
-	/* update switch's DB with mux's MAC addresses (bcast, ucast) */
-	unicast = mv_mux_get_mac(mux_dev);
-	mv_switch_mac_addr_set(unicast, group, 1);
-	mv_switch_mac_addr_set(broadcast, group, 1);
-
-	return 0;
-}
-
-static int mv_gw_mgr_mux_init(MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int gbe_port)
-{
-	char name[7] = {0, 0, 0, 0, 0, 0, 0};
-	MV_MUX_TAG tag;
-	unsigned int g, groups = mv_switch_group_map_get();
-
-	for (g = 0; g < MV_SWITCH_DB_NUM; g++) {
-		if (MV_BIT_CHECK(groups, g)) {
-			/* get tag data according to switch */
-			mv_switch_tag_get(&tag, preset, vid, tag_mode, g);
-
-			/* assign name */
-			sprintf(name, "mux%d", g);
-
-			/* create new mux device */
-			mv_gw_mgr_mux_create(name, gbe_port, g, &tag);
-		}
-	}
-
-	return 0;
-}
-
-static int __init mv_gw_mgr_init(void)
-{
-	MV_TAG_TYPE tag_mode;
-	MV_SWITCH_PRESET_TYPE preset;
-	int vid, gbe_port;
-	struct eth_port *pp;
-
-	/* get default switch configuration parameteres for preset init */
-	mv_switch_default_config_get(&tag_mode, &preset, &vid, &gbe_port);
-
-	/* config switch according to preset mode */
-	mv_switch_preset_init(preset, tag_mode, vid);
-
-	/* config mux interfaces according to preset mode */
-	mv_gw_mgr_mux_init(preset, vid, tag_mode, gbe_port);
-
-	/* update netdev port with tag type */
-	pp = mv_eth_port_by_id(gbe_port);
-	mv_mux_tag_type_set(pp, tag_mode);
-	if (tag_mode != MV_TAG_TYPE_NONE)
-		mv_eth_port_promisc_set(gbe_port);
-
-	/* set switch ops to be used by mux driver */
-	switch_ops.group_enable = mv_switch_group_enable;
-	switch_ops.group_disable = mv_switch_group_disable;
-	switch_ops.link_status = mv_switch_link_status_get;
-	switch_ops.mac_update = mv_switch_mac_update;
-	switch_ops.promisc_set = mv_switch_promisc_set;
-	mv_mux_switch_ops_set(&switch_ops);
-
-	/* set mux ops to be used by switch driver */
-	mux_ops.update_link = mv_mux_update_link;
-	mv_switch_mux_ops_set(&mux_ops);
-	mv_switch_interrupt_unmask();
-
-	return 0;
-}
-
-late_initcall(mv_gw_mgr_init);
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
deleted file mode 100644
index 3529182..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
+++ /dev/null
@@ -1,1115 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-
-#include "mvCommon.h"
-#include "mvDebug.h"
-#include "mv_mux_netdev.h"
-#include "mv_netdev.h"
-
-static const struct net_device_ops mv_mux_netdev_ops;
-static inline struct net_device *mv_mux_rx_netdev_get(struct eth_port *pp, struct sk_buff *skb);
-static inline int mv_mux_rx_tag_remove(struct eth_port *pp, struct net_device *dev, struct sk_buff *skb);
-static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb);
-
-static struct switch_device_ops *switch_ops = NULL;
-
-int mv_mux_switch_ops_set(struct switch_device_ops *switch_ops_ptr)
-{
-	switch_ops = switch_ops_ptr;
-
-	return 0;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-int mv_mux_update_link(void *cookie, int link_up)
-{
-	struct net_device *mux_dev = (struct net_device *)cookie;
-
-	(link_up) ? netif_carrier_on(mux_dev) : netif_carrier_off(mux_dev);
-
-	return 0;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-static inline int mv_mux_get_tag_size(MV_TAG_TYPE type)
-{
-	static const int size_arr[] = {0, MV_ETH_MH_SIZE,
-					MV_ETH_DSA_SIZE,
-					MV_TAG_TYPE_EDSA,
-					MV_TAG_TYPE_VLAN};
-	return size_arr[type];
-}
-/*-----------------------------------------------------------------------------------------*/
-
-int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev)
-{
-	struct net_device *dev;
-	struct eth_port *pp = MV_ETH_PRIV(root_dev);
-	int    len;
-
-	dev = mv_mux_rx_netdev_get(pp, skb);
-
-	if (dev == NULL)
-		goto out;
-
-	/* mux device is down */
-	if (!(dev->flags & IFF_UP))
-		goto out1;
-
-	/* remove tag*/
-	len = mv_mux_rx_tag_remove(pp, dev, skb);
-	dev->stats.rx_packets++;
-	dev->stats.rx_bytes += skb->len - len;
-
-
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-	if (pp->dbg_flags & MV_ETH_F_DBG_RX) {
-		printk(KERN_ERR "\n%s - %s: port=%d, cpu=%d\n", dev->name, __func__, pp->port, smp_processor_id());
-		mv_eth_skb_print(skb);
-		mvDebugMemDump(skb->data, 64, 1);
-	}
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
-
-#ifdef ETH_SKB_DEBUG
-		mv_eth_skb_check(skb);
-#endif /* ETH_SKB_DEBUG */
-
-	skb->protocol = eth_type_trans(skb, dev);
-
-	if (dev->features & NETIF_F_GRO) {
-		int group = pp->cpu_config[smp_processor_id()]->napi_group_id;
-
-		/*TODO update mux priv gro counters */
-		STAT_DBG(pp->stats.rx_gro++);
-		STAT_DBG(pp->stats.rx_gro_bytes += skb->len);
-		return napi_gro_receive(pp->napi_group[group]->napi, skb);
-	}
-
-	return netif_receive_skb(skb);
-
-out1:
-	dev->stats.rx_dropped++;
-out:
-	kfree_skb(skb);
-	return 0;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static int mv_mux_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-
-	if (!(netif_running(dev))) {
-		printk(KERN_ERR "!netif_running() in %s\n", __func__);
-		goto out;
-	}
-
-	if (mv_mux_tx_skb_tag_add(dev, skb)) {
-		printk(KERN_ERR "%s: mv_mux_tx_skb_tag_add failed.\n", __func__);
-		goto out;
-	}
-
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-	if (pp->flags & MV_ETH_F_DBG_TX) {
-		printk(KERN_ERR "\n%s - %s_%lu: port=%d, cpu=%d, in_intr=0x%lx\n",
-			dev->name, __func__, dev->stats.tx_packets, pp->port, smp_processor_id(), in_interrupt());
-		mv_eth_skb_print(skb);
-		mvDebugMemDump(skb->data, 64, 1);
-	}
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
-
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
-
-	/* assign the packet to the hw interface */
-	skb->dev = pp->dev;
-
-	/*tell Linux to pass it to its device */
-	return dev_queue_xmit(skb);
-
-out:
-	dev->stats.tx_dropped++;
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-/* Return mux device mac address							   */
-/*-----------------------------------------------------------------------------------------*/
-char *mv_mux_get_mac(struct net_device *mux_dev)
-{
-
-	if (!mux_dev) {
-		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
-		return NULL;
-	}
-
-	return mux_dev->dev_addr;
-}
-/*-----------------------------------------------------------------------------------------*/
-
-static void mv_mux_set_rx_mode(struct net_device *dev)
-{
-/*
-	printk(KERN_ERR "Invalid operation %s is virtual interface.\n", dev->name);
-*/
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-void mv_mux_change_rx_flags(struct net_device *dev, int flags)
-{
-	if (switch_ops && switch_ops->promisc_set) {
-		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
-
-		switch_ops->promisc_set(pmux_priv->idx, (dev->flags & IFF_PROMISC) ? 1 : 0);
-	}
-}
-
-/*-----------------------------------------------------------------------------------------*/
-static int mv_mux_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-	/*TODO compleate implementation*/
-	printk(KERN_ERR "Not supported yet.\n");
-	return 0;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-int mv_mux_close(struct net_device *dev)
-{
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-
-	netif_stacked_transfer_operstate(pp->dev, dev);
-	netif_tx_stop_all_queues(dev);
-
-	if (switch_ops && switch_ops->group_enable) {
-		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
-
-		switch_ops->group_disable(pmux_priv->idx);
-	}
-
-
-	printk(KERN_NOTICE "%s: stopped\n", dev->name);
-
-	return MV_OK;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-int mv_mux_open(struct net_device *dev)
-{
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-
-	if (!pp) {
-		printk(KERN_ERR "%s:Invalid operation, set master before up.\n", __func__);
-		return MV_ERROR;
-	}
-
-	/* if master is close */
-	if (!(pp->dev->flags & IFF_UP)) {
-		printk(KERN_ERR "%s:Invalid operation, port %d is down.\n", __func__, pp->port);
-		return MV_ERROR;
-	}
-
-	netif_stacked_transfer_operstate(pp->dev, dev);
-	netif_tx_wake_all_queues(dev);
-
-	if (switch_ops && switch_ops->group_enable) {
-		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
-
-		switch_ops->group_enable(pmux_priv->idx);
-	}
-
-	printk(KERN_NOTICE "%s: started\n", dev->name);
-
-	return MV_OK;
-
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static int mv_mux_set_mac(struct net_device *dev, void *addr)
-{
-	u8 *mac = &(((u8 *)addr)[2]);  /* skip on first 2B (ether HW addr type) */
-
-	mv_mux_close(dev);
-
-	if (switch_ops && switch_ops->mac_update) {
-		struct eth_netdev *pmux_priv = MV_DEV_PRIV(dev);
-
-		switch_ops->mac_update(pmux_priv->idx, dev->dev_addr, mac);
-	}
-	memcpy(dev->dev_addr, mac, ETH_ALEN);
-
-	mv_mux_open(dev);
-
-	return 0;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-int mv_mux_mtu_change(struct net_device *mux_dev, int mtu)
-{
-	printk(KERN_ERR "Invalid operation %s is virtual port.\n", mux_dev->name);
-	return MV_ERROR;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-/* Create new mux device, if device is allready exist just change tag value                */
-/* mv_mux_netdev_add should called after mv_mux_netdev_alloc                               */
-/*-----------------------------------------------------------------------------------------*/
-struct net_device *mv_mux_netdev_alloc(char* name, int idx, MV_MUX_TAG *tag_cfg)
-{
-	struct net_device *mux_dev;
-	struct eth_netdev *pmux_priv;
-
-	if (name == NULL) {
-		printk(KERN_ERR "%s: mux net device name is missig.\n", __func__);
-		return NULL;
-	}
-
-	mux_dev = dev_get_by_name(&init_net, name);
-
-
-	if (!mux_dev) {
-	/* new net device */
-	mux_dev = alloc_netdev(sizeof(struct eth_netdev), name, ether_setup);
-		if (!mux_dev) {
-			printk(KERN_ERR "%s: out of memory, net device allocation failed.\n", __func__);
-			return NULL;
-		}
-		/* allocation succeed */
-		mux_dev->irq = NO_IRQ;
-		/* must set netdev_ops before registration */
-		mux_dev->netdev_ops = &mv_mux_netdev_ops;
-
-		if (register_netdev(mux_dev)) {
-			printk(KERN_ERR "%s: failed to register %s\n", __func__, mux_dev->name);
-			free_netdev(mux_dev);
-			return NULL;
-		}
-
-	} else
-		dev_put(mux_dev);
-
-	pmux_priv = MV_DEV_PRIV(mux_dev);
-
-	if (tag_cfg == NULL) {
-		memset(pmux_priv, 0, sizeof(struct eth_netdev));
-	} else{
-		/* next, pp not changed*/
-		pmux_priv->tx_tag = tag_cfg->tx_tag;
-		pmux_priv->rx_tag_ptrn = tag_cfg->rx_tag_ptrn;
-		pmux_priv->rx_tag_mask = tag_cfg->rx_tag_mask;
-	}
-	pmux_priv->idx = idx;
-	return mux_dev;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-/* Init mux device features								   */
-/*-----------------------------------------------------------------------------------------*/
-static inline void mv_mux_init_features(struct net_device *mux_dev)
-{
-	struct eth_port *pp = MV_ETH_PRIV(mux_dev);
-
-	mux_dev->features = pp->dev->features;
-
-	mux_dev->hw_features = pp->dev->hw_features;
-	mux_dev->wanted_features = pp->dev->wanted_features;
-
-	mux_dev->vlan_features = pp->dev->vlan_features;
-
-}
-
-/*-----------------------------------------------------------------------------------------*/
-static int mv_mux_set_features(struct net_device *mux_dev, netdev_features_t features)
-{
-	struct eth_port *pp = MV_ETH_PRIV(mux_dev);
-	netdev_features_t changed = mux_dev->features ^ features;
-	netdev_features_t old = mux_dev->features;
-
-	if (changed & NETIF_F_TSO)
-		if (!(old & NETIF_F_TSO))
-			/* mux interface want to set tso */
-			if (!(pp->dev->features & NETIF_F_TSO))
-				/* master tso is down */
-				return -EOPNOTSUPP;
-
-	if (changed & NETIF_F_IP_CSUM)
-		if (!(old & NETIF_F_IP_CSUM))
-			/* mux interface want to set tx csum */
-			if (!(pp->dev->features & NETIF_F_IP_CSUM))
-				/* master tx csum is down */
-				return -EOPNOTSUPP;
-	return MV_OK;
-}
-
-/*----------------------------------------------------------------------------------------*/
-/* Function attache mux device to root device,						  */
-/* Set mux mac address and features according to root device				  */
-/*----------------------------------------------------------------------------------------*/
-static struct net_device *mv_mux_netdev_init(struct net_device *root_dev, struct net_device *mux_dev)
-{
-	struct eth_netdev *pmux_priv;
-	struct eth_port *pp;
-
-	if (root_dev == NULL)
-		return NULL;
-
-	pp = MV_ETH_PRIV(root_dev);
-
-	if (pp && !(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
-		printk(KERN_ERR "%s: root device is not connect to linux.\n", __func__);
-		return NULL;
-	}
-
-	if (!mux_dev) {
-		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
-		return NULL;
-	}
-
-	/* set skb header size , avoid from skb reallocation*/
-	mux_dev->hard_header_len = pp->dev->hard_header_len +
-					mv_mux_get_tag_size(pp->tag_type);
-
-	/* Copy MAC address and MTU from root netdevice */
-	mux_dev->mtu = pp->dev->mtu;
-	pmux_priv = MV_DEV_PRIV(mux_dev);
-	pmux_priv->pp = pp;
-
-	memcpy(mux_dev->dev_addr, pp->dev->dev_addr, MV_MAC_ADDR_SIZE);
-
-	/* TODO: handle features */
-	mv_mux_init_features(mux_dev);
-
-	/*SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
-
-	return mux_dev;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-struct net_device *mv_mux_netdev_add(struct eth_port *pp, struct net_device *mux_dev)
-{
-
-	struct net_device *dev_temp;
-	struct eth_netdev *pdev;
-
-	if (pp == NULL)
-		return NULL;
-
-	mux_dev = mv_mux_netdev_init(pp->dev, mux_dev);
-
-	if (mux_dev == NULL)
-		return NULL;
-
-	if (pp->switch_dev == NULL) {
-		/* First tag netdev */
-		pp->switch_dev = mux_dev;
-	} else {
-		pdev = MV_DEV_PRIV(pp->switch_dev);
-		while (pdev->next != NULL) {
-			dev_temp = pdev->next;
-			pdev = MV_DEV_PRIV(dev_temp);
-		}
-		pdev->next = mux_dev;
-	}
-	return mux_dev;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-int mv_mux_tag_type_set(struct eth_port *pp, int type)
-{
-	unsigned int flgs;
-
-	if ((type < MV_TAG_TYPE_NONE) || (type >= MV_TAG_TYPE_LAST)) {
-		printk(KERN_INFO "%s: Invalid tag type %d\n", __func__, type);
-		return MV_ERROR;
-	}
-
-	if (pp == NULL)
-		return MV_ERROR;
-
-	flgs = pp->dev->flags;
-
-	if (flgs & IFF_UP) {
-		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, pp->dev->name);
-		return MV_ERROR;
-	}
-
-	pp->tag_type = type;
-
-	switch (type) {
-	case MV_TAG_TYPE_MH:
-		mvPp2MhSet(pp->port, MV_PP2_MH);
-		break;
-	case MV_TAG_TYPE_DSA:
-		mvPp2MhSet(pp->port, MV_TAG_TYPE_DSA);
-		break;
-	case MV_TAG_TYPE_EDSA:
-		mvPp2MhSet(pp->port, MV_PP2_DSA_EXT);
-		break;
-	default: /* Do Nothing */
-		break;
-	}
-
-	return MV_OK;
-}
-/*-----------------------------------------------------------------------------------------*/
-/* Delete mux device                                                                       */
-/*	remove device from port linked list						   */
-/*	free mux device                                                                    */
-/*-----------------------------------------------------------------------------------------*/
-int mv_mux_netdev_delete(struct net_device *mux_dev)
-{
-	struct net_device *pdev_curr, *pdev_prev = NULL;
-	struct eth_netdev *pdev_tmp_curr, *pdev_tmp_prev;
-	struct eth_port *pp;
-	int flgs;
-
-	if (mux_dev == NULL) {
-		printk(KERN_ERR "%s: mux net device is NULL.\n", __func__);
-		return MV_ERROR;
-	}
-
-	pp = MV_ETH_PRIV(mux_dev);
-
-	/*not attached to gbe port*/
-	if (pp == NULL) {
-		/*
-		FIXME - crash */
-		synchronize_net();
-		unregister_netdev(mux_dev);
-		free_netdev(mux_dev);
-		return MV_OK;
-	}
-
-	flgs = mux_dev->flags;
-	if (flgs & IFF_UP) {
-		printk(KERN_ERR "%s: root device (%s) must stopped before.\n", __func__, pp->dev->name);
-		return MV_ERROR;
-	}
-
-	pdev_curr = pp->switch_dev;
-
-	while (pdev_curr != NULL) {
-
-		pdev_tmp_curr = MV_DEV_PRIV(pdev_curr);
-
-		if (pdev_curr == mux_dev) {
-			if (pdev_curr == pp->switch_dev) {
-				/* first element*/
-				pp->switch_dev = pdev_tmp_curr->next;
-			} else {
-				pdev_tmp_prev = MV_DEV_PRIV(pdev_prev);
-				pdev_tmp_prev->next = pdev_tmp_curr->next;
-			}
-			/* delet current */
-			/*FIXME - crash*/
-			synchronize_net();
-			unregister_netdev(mux_dev);
-			free_netdev(mux_dev);
-			return MV_OK;
-
-		} else {
-			pdev_prev = pdev_curr;
-			pdev_curr = pdev_tmp_curr->next;
-		}
-	}
-	/* mux_dev not found */
-	return MV_ERROR;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-static int mux_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
-{
-	struct net_device *mux_dev, *dev = ptr;
-	struct eth_netdev *pdev_priv;
-	struct eth_port *priv;
-	int flgs, link_up;
-
-	/*recognize if marvell event */
-	if (!mv_eth_netdev_find(dev->ifindex))
-		goto out;
-
-	priv = MV_ETH_PRIV(dev);
-
-	/* exit - if not mux device */
-	if (priv->tag_type == MV_TAG_TYPE_NONE)
-		goto out;
-
-	switch (event) {
-
-	case NETDEV_CHANGE:
-		mux_dev = priv->switch_dev;
-		while (mux_dev != NULL) {
-			pdev_priv = MV_DEV_PRIV(mux_dev);
-
-			if (switch_ops && (switch_ops->link_status)) {
-				/* In case of internal switch, link is determined by switch */
-				link_up = switch_ops->link_status(pdev_priv->idx);
-				mv_mux_update_link(mux_dev, link_up);
-			} else {
-				/* In case of external switch, propagate real device link state to mux devices */
-				/* change state*/
-				netif_stacked_transfer_operstate(dev, mux_dev);
-			}
-			mux_dev = pdev_priv->next;
-		}
-		break;
-
-	case NETDEV_CHANGEADDR:
-		/* Propagate real device mac adress to mux devices */
-		mux_dev = priv->switch_dev;
-		while (mux_dev != NULL) {
-			pdev_priv = MV_DEV_PRIV(mux_dev);
-			/* May be called without an actual change */
-			if (!compare_ether_addr(mux_dev->dev_addr, dev->dev_addr)) {
-				mux_dev = pdev_priv->next;
-				continue;
-			}
-			memcpy(mux_dev->dev_addr, dev->dev_addr, ETH_ALEN);
-			mux_dev = pdev_priv->next;
-		}
-		break;
-
-	case NETDEV_CHANGEMTU:
-		mux_dev = priv->switch_dev;
-		while (mux_dev != NULL) {
-			pdev_priv = MV_DEV_PRIV(mux_dev);
-			if (mux_dev->mtu <= dev->mtu) {
-				mux_dev = pdev_priv->next;
-				continue;
-			}
-			dev_set_mtu(mux_dev, dev->mtu);
-			mux_dev = pdev_priv->next;
-		}
-		break;
-
-	case NETDEV_FEAT_CHANGE:
-		/* not supported */
-		break;
-
-	case NETDEV_DOWN:
-		/* Master down - Put all mux devices for this dev in the down state too.  */
-		mux_dev = priv->switch_dev;
-		while (mux_dev != NULL) {
-			pdev_priv = MV_DEV_PRIV(mux_dev);
-			flgs = mux_dev->flags;
-			if (!(flgs & IFF_UP)) {
-				mux_dev = pdev_priv->next;
-				continue;
-			}
-			dev_change_flags(mux_dev, flgs & ~IFF_UP);
-			netif_stacked_transfer_operstate(dev, mux_dev);
-			mux_dev = pdev_priv->next;
-		}
-		break;
-
-	case NETDEV_UP:
-		/* Master up - Put all mux devices for this dev in the up state too.  */
-		mux_dev = priv->switch_dev;
-		while (mux_dev != NULL) {
-			pdev_priv = MV_DEV_PRIV(mux_dev);
-			flgs = mux_dev->flags;
-			if (flgs & IFF_UP) {
-				mux_dev = pdev_priv->next;
-				continue;
-			}
-			dev_change_flags(mux_dev, flgs | IFF_UP);
-
-			netif_stacked_transfer_operstate(dev, mux_dev);
-			mux_dev = pdev_priv->next;
-		}
-
-		break;
-	} /*switch*/
-out:
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block mux_notifier_block __read_mostly = {
-	.notifier_call = mux_device_event,
-};
-
-static int __init mux_proto_init(void)
-{
-	int err;
-
-	err = register_netdevice_notifier(&mux_notifier_block);
-
-	if (err < 0)
-		unregister_netdevice_notifier(&mux_notifier_block);
-	return err;
-
-}
-/*-----------------------------------------------------------------------------------------*/
-
-bool mv_mux_netdev_link_status(struct net_device *dev)
-{
-	return netif_carrier_ok(dev) ? true : false;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid)
-{
-
-	mux_cfg->tx_tag.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
-	mux_cfg->rx_tag_ptrn.vlan = MV_32BIT_BE((MV_VLAN_TYPE << 16) | vid);
-
-	/*mask priority*/
-	mux_cfg->rx_tag_mask.vlan = MV_32BIT_BE(0xFFFF0FFF);
-
-	mux_cfg->tag_type = MV_TAG_TYPE_VLAN;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg)
-{
-	if (mux_dev) {
-		struct eth_netdev *pmux_priv;
-		pmux_priv = MV_DEV_PRIV(mux_dev);
-		mux_cfg->tx_tag = pmux_priv->tx_tag;
-		mux_cfg->rx_tag_ptrn = pmux_priv->rx_tag_ptrn;
-		mux_cfg->rx_tag_mask = pmux_priv->rx_tag_mask;
-	} else
-		memset(mux_cfg, 0, sizeof(MV_MUX_TAG));
-}
-/*-----------------------------------------------------------------------------------------*/
-
-static inline struct net_device *mv_mux_mh_netdev_get(struct eth_port *pp, MV_TAG *tag)
-{
-	struct net_device *dev = pp->switch_dev;
-	struct eth_netdev *pdev;
-
-	while (dev != NULL) {
-		pdev = MV_DEV_PRIV(dev);
-		if ((tag->mh & pdev->rx_tag_mask.mh) == pdev->rx_tag_ptrn.mh)
-			return dev;
-
-		dev = pdev->next;
-	}
-	printk(KERN_ERR "%s: MH=0x%04x match no interfaces\n", __func__, tag->mh);
-	return NULL;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline struct net_device *mv_mux_vlan_netdev_get(struct eth_port *pp, MV_TAG *tag)
-{
-	struct net_device *dev = pp->switch_dev;
-	struct eth_netdev *pdev;
-
-	while (dev != NULL) {
-		pdev = MV_DEV_PRIV(dev);
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-		if (pp->flags & MV_ETH_F_DBG_RX)
-			printk(KERN_ERR "pkt tag = 0x%x, rx_tag_ptrn = 0x%x, rx_tag_mask = 0x%x\n",
-				 tag->vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
-#endif
-		if ((tag->vlan & pdev->rx_tag_mask.vlan) ==
-			(pdev->rx_tag_ptrn.vlan & pdev->rx_tag_mask.vlan))
-			return dev;
-
-		dev = pdev->next;
-	}
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
-#endif
-
-	return NULL;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline struct net_device *mv_mux_dsa_netdev_get(struct eth_port *pp, MV_TAG *tag)
-{
-	/*
-	   MV_TAG.vlan and MV_TAG.dsa size are equal.
-	   MV_TAG type is union.
-	   We can use in the same functins.
-	*/
-
-	return mv_mux_vlan_netdev_get(pp, tag);
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline struct net_device *mv_mux_edsa_netdev_get(struct eth_port *pp, MV_TAG *tag)
-{
-	struct net_device *dev = pp->switch_dev;
-	struct eth_netdev *pdev;
-
-	while (dev != NULL) {
-		pdev = MV_DEV_PRIV(dev);
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-		if (pp->flags & MV_ETH_F_DBG_RX)
-			printk(KERN_ERR "pkt tag = 0x%x %x, rx_tag_ptrn = 0x%x %x, rx_tag_mask = 0x%x %x\n",
-				 tag->edsa[0], tag->edsa[1], pdev->rx_tag_ptrn.edsa[0], pdev->rx_tag_ptrn.edsa[1],
-				 pdev->rx_tag_mask.edsa[0], pdev->rx_tag_mask.edsa[1]);
-#endif
-		/* compare tags */
-		if (((tag->edsa[0] & pdev->rx_tag_mask.edsa[0]) ==
-			(pdev->rx_tag_ptrn.edsa[0] & pdev->rx_tag_mask.edsa[0])) &&
-			((tag->edsa[1] & pdev->rx_tag_mask.edsa[1]) ==
-			(pdev->rx_tag_ptrn.edsa[1] & pdev->rx_tag_mask.edsa[1])))
-				return dev;
-
-		dev = pdev->next;
-	}
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
-	printk(KERN_ERR "%s:Error TAG=0x%08x match no interfaces\n", __func__, tag->vlan);
-#endif
-
-	return NULL;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-
-static inline struct net_device *mv_mux_rx_netdev_get(struct eth_port *pp, struct sk_buff *skb)
-{
-	struct net_device *dev;
-	MV_TAG tag;
-	MV_U8 *data = skb->data;
-
-	/* skb->data point to MH */
-
-	switch (pp->tag_type) {
-
-	case MV_TAG_TYPE_MH:
-		tag.mh = *(MV_U16 *)data;
-		dev = mv_mux_mh_netdev_get(pp, &tag);
-		break;
-
-	case MV_TAG_TYPE_VLAN:
-		tag.vlan = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
-		dev = mv_mux_vlan_netdev_get(pp, &tag);
-		break;
-
-	case MV_TAG_TYPE_DSA:
-		tag.dsa = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
-		dev = mv_mux_dsa_netdev_get(pp, &tag);
-		break;
-
-	case MV_TAG_TYPE_EDSA:
-		tag.edsa[0] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE));
-		tag.edsa[1] = *(MV_U32 *)(data + MV_ETH_MH_SIZE + (2 * MV_MAC_ADDR_SIZE) + 4);
-		dev = mv_mux_edsa_netdev_get(pp, &tag);
-		break;
-
-	default:
-		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
-		return NULL;
-	}
-
-	return dev;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-static inline int mv_mux_mh_skb_remove(struct sk_buff *skb)
-{
-	__skb_pull(skb, MV_ETH_MH_SIZE);
-	return MV_ETH_MH_SIZE;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_vlan_skb_remove(struct sk_buff *skb)
-{
-	/* memmove use temporrary array, no overlap problem*/
-	memmove(skb->data + MV_VLAN_HLEN, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
-
-	__skb_pull(skb, MV_VLAN_HLEN);
-
-	return MV_ETH_VLAN_SIZE;
-}
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_dsa_skb_remove(struct sk_buff *skb)
-{
-	/* memmove use temporrary array, no overlap problem*/
-	memmove(skb->data + MV_ETH_DSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
-
-	__skb_pull(skb, MV_ETH_DSA_SIZE);
-
-	return MV_ETH_DSA_SIZE;
-}
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_edsa_skb_remove(struct sk_buff *skb)
-{
-	/* memmove use temporrary array, no overlap problem*/
-	memmove(skb->data + MV_ETH_EDSA_SIZE, skb->data, (2 * MV_MAC_ADDR_SIZE) + MV_ETH_MH_SIZE);
-
-	__skb_pull(skb, MV_ETH_EDSA_SIZE);
-
-	return MV_ETH_EDSA_SIZE;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_rx_tag_remove(struct eth_port *pp, struct net_device *dev, struct sk_buff *skb)
-{
-	int shift = 0;
-	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
-
-	if (pdev->leave_tag == true)
-		return 0;
-
-	switch (pp->tag_type) {
-
-	case MV_TAG_TYPE_MH:
-		break;
-
-	case MV_TAG_TYPE_VLAN:
-		shift = mv_mux_vlan_skb_remove(skb);
-		break;
-
-	case MV_TAG_TYPE_DSA:
-		shift = mv_mux_dsa_skb_remove(skb);
-		break;
-
-	case MV_TAG_TYPE_EDSA:
-		shift = mv_mux_edsa_skb_remove(skb);
-		break;
-
-	default:
-		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
-		return -1;
-	}
-	/* MH exist in packet anycase - Skip it */
-	shift += mv_mux_mh_skb_remove(skb);
-
-	return shift;
-}
-
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
-{
-
-	/* sanity: Check that there is place for MH in the buffer */
-	if (skb_headroom(skb) < MV_ETH_MH_SIZE) {
-		printk(KERN_ERR "%s: skb (%p) doesn't have place for MH, head=%p, data=%p\n",
-		       __func__, skb, skb->head, skb->data);
-		return 1;
-	}
-
-	/* Prepare place for MH header */
-	__skb_push(skb, MV_ETH_MH_SIZE);
-
-	*((u16 *) skb->data) = mh;
-
-	return MV_OK;
-}
-
-static inline int mv_mux_tx_skb_mh_add(struct net_device *dev, struct sk_buff *skb)
-{
-	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
-
-	return mv_eth_skb_mh_add(skb, pdev->tx_tag.mh);
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_skb_vlan_add(struct sk_buff *skb, unsigned int vlan)
-{
-	unsigned char *pvlan;
-/*
-	TODO: add stat counter to mux_pp
-		mean that there is not enough bytes in header room
-		to push vlan, skb_cow will realloc skb
-
-	if (skb_headroom(skb) < MV_VLAN_HLEN) {
-		mux_skb_tx_realloc++;
-	}
-*/
-	if (skb_cow(skb, MV_VLAN_HLEN)) {
-		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
-		       __func__, skb, skb->head, skb->data);
-		return 1;
-	}
-
-	__skb_push(skb, MV_VLAN_HLEN);
-
-	memmove(skb->data, skb->data + MV_VLAN_HLEN, 2 * MV_MAC_ADDR_SIZE);
-
-	pvlan = skb->data + (2 * MV_MAC_ADDR_SIZE);
-	*(MV_U32 *)pvlan = vlan;
-
-	return MV_OK;
-}
-
-static inline int mv_mux_tx_skb_vlan_add(struct net_device *dev, struct sk_buff *skb)
-{
-	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
-
-	return mv_mux_skb_vlan_add(skb, pdev->tx_tag.vlan);
-}
-
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_tx_skb_dsa_add(struct net_device *dev, struct sk_buff *skb)
-{
-	/* both DSA and VLAN are 4 bytes tags, placed in the same offset in the packet */
-	return mv_mux_tx_skb_vlan_add(dev, skb);
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_skb_edsa_add(struct sk_buff *skb, unsigned int edsaL, unsigned int edsaH)
-{
-	unsigned char *pedsa;
-
-	if (skb_cow(skb, MV_ETH_EDSA_SIZE)) {
-		printk(KERN_ERR "%s: skb (%p) headroom < VLAN_HDR, skb_head=%p, skb_data=%p\n",
-		       __func__, skb, skb->head, skb->data);
-		return 1;
-	}
-
-	__skb_push(skb, MV_ETH_EDSA_SIZE);
-
-	memmove(skb->data, skb->data + MV_ETH_EDSA_SIZE, 2 * MV_MAC_ADDR_SIZE);
-
-	pedsa = skb->data + (2 * MV_MAC_ADDR_SIZE);
-	*(MV_U32 *)pedsa = edsaL;
-	*((MV_U32 *)pedsa + 1) = edsaH;
-
-	return MV_OK;
-}
-
-static inline int mv_mux_tx_skb_edsa_add(struct net_device *dev, struct sk_buff *skb)
-{
-	struct eth_netdev *pdev = MV_DEV_PRIV(dev);
-
-	return mv_mux_skb_edsa_add(skb, pdev->tx_tag.edsa[0], pdev->tx_tag.edsa[1]);
-}
-
-/*-----------------------------------------------------------------------------------------*/
-
-static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb)
-{
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-	int err = 0;
-
-	switch (pp->tag_type) {
-
-	case MV_TAG_TYPE_MH:
-		err = mv_mux_tx_skb_mh_add(dev, skb);
-		break;
-	case MV_TAG_TYPE_VLAN:
-		err = mv_mux_tx_skb_vlan_add(dev, skb);
-		break;
-	case MV_TAG_TYPE_DSA:
-		err = mv_mux_tx_skb_dsa_add(dev, skb);
-		break;
-	case MV_TAG_TYPE_EDSA:
-		err = mv_mux_tx_skb_edsa_add(dev, skb);
-		break;
-	default:
-		printk(KERN_ERR "%s: unexpected port mode = %d\n", __func__, pp->tag_type);
-		err = 1;
-	}
-	return err;
-}
-
-/*-----------------------------------------------------------------------------------------*/
-/* Print mux device data 								   */
-/*-----------------------------------------------------------------------------------------*/
-
-void mv_mux_netdev_print(struct net_device *mux_dev)
-{
-
-	struct eth_netdev *pdev;
-	struct eth_port   *pp;
-
-	if (!mux_dev) {
-		printk(KERN_ERR "%s:device in NULL.\n", __func__);
-		return;
-	}
-
-	if (mv_eth_netdev_find(mux_dev->ifindex)) {
-		printk(KERN_ERR "%s: %s is not mux device.\n", __func__, mux_dev->name);
-		return;
-	}
-
-	pdev = MV_DEV_PRIV(mux_dev);
-	pp = MV_ETH_PRIV(mux_dev);
-
-	if (!pdev || !pp) {
-		printk(KERN_ERR "%s: device must be conncted to physical port\n", __func__);
-		return;
-	}
-
-	switch (pp->tag_type) {
-
-	case MV_TAG_TYPE_VLAN:
-		printk(KERN_ERR "pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
-		pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
-		break;
-
-	case MV_TAG_TYPE_DSA:
-		printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%08x, rx_dsa=0x%08x, rx_mask=0x%08x\n",
-			pp, pdev, pdev->tx_tag.dsa, pdev->rx_tag_ptrn.dsa, pdev->rx_tag_mask.dsa);
-		break;
-
-	case MV_TAG_TYPE_MH:
-		printk(KERN_ERR "pp=%p, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mh=0x%04x\n",
-			pp, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
-		break;
-
-	case MV_TAG_TYPE_EDSA:
-		printk(KERN_ERR "pp=%p, pdev=%p: tx_edsa=0x%08x %08x, rx_edsa=0x%08x %08x, rx_mask=0x%08x %08x\n",
-			pp, pdev, pdev->tx_tag.edsa[1], pdev->tx_tag.edsa[0],
-			pdev->rx_tag_ptrn.edsa[1], pdev->rx_tag_ptrn.edsa[0],
-			pdev->rx_tag_mask.edsa[1], pdev->rx_tag_mask.edsa[0]);
-		break;
-
-	default:
-		printk(KERN_ERR "%s: Error, Unknown tag type\n", __func__);
-	}
-}
-/*-----------------------------------------------------------------------------------------*/
-
-static const struct net_device_ops mv_mux_netdev_ops = {
-	.ndo_open		= mv_mux_open,
-	.ndo_stop		= mv_mux_close,
-	.ndo_start_xmit		= mv_mux_xmit,
-	.ndo_set_mac_address	= mv_mux_set_mac,
-	.ndo_do_ioctl		= mv_mux_ioctl,
-	.ndo_set_rx_mode	= mv_mux_set_rx_mode,
-	.ndo_change_rx_flags	= mv_mux_change_rx_flags,
-	.ndo_set_features	= mv_mux_set_features,
-};
-
-module_init(mux_proto_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
deleted file mode 100644
index 3656ed4..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#ifndef __mv_tag_netdev_h__
-#define __mv_tag_netdev_h__
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/ip.h>
-
-#include "mvCommon.h"
-#include "mvTypes.h"
-#include "mvOs.h"
-#include "mv802_3.h"
-#include "mv_netdev.h"
-
-/* operations requested by mux device from switch device */
-struct switch_device_ops {
-	int	(*group_enable)(int group_id);
-	int	(*group_disable)(int group_id);
-	int	(*link_status)(int group_id);
-	int	(*mac_update)(int group_id, unsigned char *old_mac, unsigned char *new_mac);
-	int	(*promisc_set)(int group_id, u8 promisc_on);
-};
-
-int mv_mux_switch_ops_set(struct switch_device_ops *switch_ops_ptr);
-int mv_mux_update_link(void *cookie, int link_up);
-
-struct net_device *mv_mux_netdev_add(struct eth_port *pp, struct net_device *mux_dev);
-struct net_device *mv_mux_netdev_alloc(char* name, int idx, MV_MUX_TAG *tag_cfg);
-char *mv_mux_get_mac(struct net_device *mux_dev);
-int mv_mux_netdev_delete(struct net_device *mux_dev);
-int mv_mux_tag_type_set(struct eth_port *pp, int type);
-void mv_mux_vlan_set(MV_MUX_TAG *mux_cfg, unsigned int vid);
-void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg);
-int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev);
-void mv_mux_netdev_print(struct net_device *mux_dev);
-
-#endif /* __mv_tag_netdev_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
deleted file mode 100644
index ce0e9a2..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_sysfs.c
+++ /dev/null
@@ -1,247 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/platform_device.h>
-
-#include "mv_netdev.h"
-#include "mv_mux_netdev.h"
-MV_MUX_TAG mux_cfg;
-
-static ssize_t mv_mux_help(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [if_name]                 > dump        - Dump mux device\n");
-	off += sprintf(buf+off, "echo [if_name] p               > add          - Attach to gbe [p] new virtual interface [if_name]\n");
-	off += sprintf(buf+off, "echo [if_name]                 > del          - Remove from gbe [p] virtual interface [if_name]\n");
-
-	off += sprintf(buf+off, "\n");
-	off += sprintf(buf+off, "echo p {0|1|2|3|4}             > tag_type     - Set gbe port [p] tag type: 0-NONE, 1-MH, 2-DSA, 3-EDSA, 4-VID.\n");
-	off += sprintf(buf+off, "echo [if_name] vid             > mux_vid      - Set virtual interface [if_name] vid value.\n");
-	off += sprintf(buf+off, "echo [if_name] mh mask         > mh_rx        - Set virtual port Marvell header RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] dsa mask        > dsa_rx       - Set virtual port DSA RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] tagL mask       > edsa_low_rx  - Set virtual port EDSA low RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] tagH mask       > edsa_high_rx - Set virtual port EDSA high RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] mh              > mh_tx        - Set virtual port Marvell header tX tag\n");
-	off += sprintf(buf+off, "echo [if_name] dsa             > dsa_tx       - Set virtual port DSA TX tag\n");
-	off += sprintf(buf+off, "echo [if_name] tagH tagL       > edsa_tx      - Set virtual port EDSA TX tag\n");
-
-	return off;
-}
-
-
-static ssize_t mv_mux_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-/*
-	const char      *name = attr->attr.name;
-	int             off = 0;
-*/
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	return mv_mux_help(buf);
-}
-
-
-static ssize_t mv_mux_netdev_store(struct device *dev,
-					struct device_attribute *attr, const char *buf, size_t len)
-{
-	struct net_device *mux_dev;
-	const char        *name = attr->attr.name;
-	int               a = 0, b = 0, err = 0;
-	char              dev_name[IFNAMSIZ];
-
-	if (!capable(CAP_NET_ADMIN))
-	return -EPERM;
-
-	sscanf(buf, "%s %x %x", dev_name, &a, &b);
-	mux_dev = dev_get_by_name(&init_net, dev_name);
-
-	dev_put(mux_dev);
-
-	if (!strcmp(name, "dump")) {
-		mv_mux_netdev_print(mux_dev);
-
-	} else if (!strcmp(name, "mux_vid")) {
-		mv_mux_vlan_set(&mux_cfg, a);
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "mh_rx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.rx_tag_ptrn.mh = a;
-		mux_cfg.rx_tag_mask.mh = b;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "dsa_rx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.rx_tag_ptrn.dsa = a;
-		mux_cfg.rx_tag_mask.dsa = b;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "edsa_low_rx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.rx_tag_ptrn.edsa[0] = a;
-		mux_cfg.rx_tag_mask.edsa[0] = b;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "edsa_high_rx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.rx_tag_ptrn.edsa[1] = a;
-		mux_cfg.rx_tag_mask.edsa[1] = b;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	}  else if (!strcmp(name, "mh_tx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.tx_tag.mh = a;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	}  else if (!strcmp(name, "dsa_tx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.tx_tag.dsa = a;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "edsa_tx")) {
-		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.tx_tag.edsa[0] = a;
-		mux_cfg.tx_tag.edsa[1] = b;
-		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
-
-	} else if (!strcmp(name, "add")) {
-		struct eth_port *pp = mv_eth_port_by_id(a);
-		err =  mv_mux_netdev_add(pp, mux_dev) ? 0 : 1;
-
-	} else if (!strcmp(name, "del"))
-		err = mv_mux_netdev_delete(mux_dev);
-
-	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
-
-	return err ? -EINVAL : len;
-}
-
-static ssize_t mv_mux_store(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char      *name = attr->attr.name;
-	int             err;
-	unsigned int    a, b;
-	unsigned long   flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	a = b = err = 0;
-
-	sscanf(buf, "%x %x", &a, &b);
-
-	local_irq_save(flags);
-
-	if (!strcmp(name, "tag_type")) {
-		struct eth_port *pp = mv_eth_port_by_id(a);
-		mv_mux_tag_type_set(pp, b);
-	} else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-
-	local_irq_restore(flags);
-
-	if (err)
-		printk(KERN_ERR "%s: error %d\n", __func__, err);
-
-	return err ? -EINVAL : len;
-}
-static DEVICE_ATTR(add,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(del,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(mux_vid,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(mh_rx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(dsa_rx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(edsa_low_rx,  S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(edsa_high_rx, S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(mh_tx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(dsa_tx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(edsa_tx,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(tag_type,     S_IWUSR, mv_mux_show, mv_mux_store);
-static DEVICE_ATTR(dump,         S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(help,         S_IRUSR, mv_mux_show, NULL);
-
-
-static struct attribute *mv_mux_attrs[] = {
-
-	&dev_attr_add.attr,
-	&dev_attr_del.attr,
-	&dev_attr_mux_vid.attr,
-	&dev_attr_mh_rx.attr,
-	&dev_attr_dsa_rx.attr,
-	&dev_attr_edsa_low_rx.attr,
-	&dev_attr_edsa_high_rx.attr,
-	&dev_attr_mh_tx.attr,
-	&dev_attr_dsa_tx.attr,
-	&dev_attr_edsa_tx.attr,
-	&dev_attr_tag_type.attr,
-	&dev_attr_help.attr,
-	&dev_attr_dump.attr,
-	NULL
-};
-
-static struct attribute_group mv_eth_group = {
-	.name = "mux",
-	.attrs = mv_mux_attrs,
-};
-
-int __devinit mv_mux_sysfs_init(void)
-{
-	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	err = sysfs_create_group(&pd->kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
-	return err;
-}
-
-module_init(mv_mux_sysfs_init);
-
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index b24ff84..9916143 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -52,7 +52,7 @@ disclaimer.
 #include "prs/mvPp2PrsHw.h"
 #include "cls/mvPp2Classifier.h"
 
-#include "mv_mux_netdev.h"
+#include "mv_mux/mv_mux_netdev.h"
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
 #include "mv_eth_sysfs.h"
@@ -61,6 +61,8 @@ disclaimer.
 
 #define MV_ETH_TX_PENDING_TIMEOUT_MSEC     1000
 
+static struct mv_mux_eth_ops mux_eth_ops;
+
 static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb);
 
 #ifdef CONFIG_NET_SKB_RECYCLE
@@ -112,8 +114,8 @@ static int  mv_eth_priv_init(struct eth_port *pp, int port);
 static void mv_eth_priv_cleanup(struct eth_port *pp);
 static int  mv_eth_config_get(struct platform_device *pdev, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
-struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
-					struct platform_device *pdev);
+struct net_device *mv_eth_netdev_init(int mtu, u8 *mac, struct platform_device *pdev);
+static int mv_eth_netdev_connect(struct eth_port *pp);
 static void mv_eth_netdev_init_features(struct net_device *dev);
 static netdev_features_t mv_eth_netdev_fix_features(struct net_device *dev, netdev_features_t features);
 
@@ -199,6 +201,31 @@ void mv_eth_ctrl_pnc(int en)
 {
 	mv_eth_pnc_ctrl_en = en;
 }
+
+/*****************************************
+ *            MUX function                *
+ *****************************************/
+static int mv_eth_tag_type_set(int port, int type)
+{
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	switch (type) {
+	case MV_TAG_TYPE_MH:
+		mvPp2MhSet(port, MV_PP2_MH);
+		break;
+	case MV_TAG_TYPE_DSA:
+		mvPp2MhSet(port, MV_TAG_TYPE_DSA);
+		break;
+	case MV_TAG_TYPE_EDSA:
+		mvPp2MhSet(port, MV_PP2_DSA_EXT);
+	default: /* Do Nothing */
+		break;
+	}
+
+	pp->tagged = (type == MV_TAG_TYPE_NONE) ? MV_FALSE : MV_TRUE;
+
+	return 0;
+}
 /*****************************************
  *            NAPI Group API             *
  *****************************************/
@@ -1441,7 +1468,7 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 #endif
 }
 
-static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
+static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct napi_struct *napi)
 {
 	struct net_device *dev = pp->dev;
 	MV_PP2_PHYS_RXQ_CTRL *rx_ctrl = pp->rxq_ctrl[rxq].q;
@@ -1558,8 +1585,8 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 
 		mv_eth_rx_csum(pp, rx_desc, skb);
 
-		if (pp->tag_type != MV_TAG_TYPE_NONE) {
-			mv_mux_rx(skb, dev);
+		if (pp->tagged) {
+			mv_mux_rx(skb, pp->port, napi);
 			STAT_INFO(pp->stats.rx_tagged++);
 			skb = NULL;
 		} else {
@@ -2657,7 +2684,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		if (rx_queue == -1)
 			break;
 
-		count = mv_eth_rx(pp, budget, rx_queue);
+		count = mv_eth_rx(pp, budget, rx_queue, napi);
 		rx_done += count;
 		budget -= count;
 		if (budget > 0)
@@ -2822,6 +2849,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 {
 	u32 port;
 	struct eth_port *pp;
+	struct net_device *dev;
 	int mtu, err, txp, phys_port, speed, force_link = 0;
 	struct mv_pp2_pdata *plat_data = (struct mv_pp2_pdata *)pdev->dev.platform_data;
 	u8 mac[MV_MAC_ADDR_SIZE];
@@ -2831,12 +2859,18 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	printk(KERN_ERR "  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
 			port, plat_data->cpu_mask, plat_data->mtu);
 
-	pp = mv_eth_ports[port] = mvOsMalloc(sizeof(struct eth_port));
-	if (!pp) {
-		printk(KERN_ERR "Error: failed to allocate memory for port %d\n", port);
-		return -ENOMEM;
+	mtu = mv_eth_config_get(pdev, mac);
+
+	dev = mv_eth_netdev_init(mtu, mac, pdev);
+
+	if (dev == NULL) {
+		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+		return -EIO;
 	}
-	memset(pp, 0, sizeof(struct eth_port));
+
+	pp = (struct eth_port *)netdev_priv(dev);
+
+	mv_eth_ports[port] = pp;
 
 	err = mv_eth_priv_init(pp, port);
 	if (err)
@@ -2865,6 +2899,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		pr_err("gbe #%d: unknown speed = %d\n", pp->port, plat_data->speed);
 		return -EIO;
 	}
+
 	/* set port's speed, duplex, fc */
 	if (!MV_PON_PORT(pp->port)) {
 		/* force link, speed and duplex if necessary based on board information */
@@ -2872,7 +2907,6 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		if (err)
 			return err;
 	}
-	mtu = mv_eth_config_get(pdev, mac);
 
 	pr_info("\t%s p=%d: phy=%d,  mtu=%d, mac="MV_MACQUAD_FMT", speed=%s %s\n",
 		MV_PON_PORT(port) ? "pon" : "giga", port, plat_data->phy_addr, mtu,
@@ -2884,12 +2918,12 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		return -EIO;
 	}
 
-	pp->dev = mv_eth_netdev_init(pp, mtu, mac, pdev);
-	if (pp->dev == NULL) {
-		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+	if (mv_eth_netdev_connect(pp) < 0) {
+		printk(KERN_ERR "%s: can't connect to linux\n", __func__);
 		mv_eth_priv_cleanup(pp);
 		return -EIO;
 	}
+
 	/* Default NAPI initialization */
 	/* Create one group for this port, that contains all RXQs and all CPUs - every cpu can process all RXQs */
 	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
@@ -2915,6 +2949,10 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
 			mv_eth_open(pp->dev);
 
+	mux_eth_ops.set_tag_type = mv_eth_tag_type_set;
+	mux_eth_ops.promisc_set = mv_eth_port_promisc_set;
+	mv_mux_eth_attach(pp->port, pp->dev, &mux_eth_ops);
+
 	return 0;
 }
 
@@ -3212,26 +3250,23 @@ static void mv_eth_tx_timeout(struct net_device *dev)
  * mv_eth_netdev_init -- Allocate and initialize net_device    *
  *                   structure                                 *
  ***************************************************************/
-struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
-				struct platform_device *pdev)
+struct net_device *mv_eth_netdev_init(int mtu, u8 *mac, struct platform_device *pdev)
 {
-	int cpu;
 	struct net_device *dev;
-	struct eth_netdev *dev_priv;
-	struct cpu_ctrl	*cpuCtrl;
+	struct eth_port *dev_priv;
 	struct resource *res;
 
-	dev = alloc_etherdev_mq(sizeof(struct eth_netdev), CONFIG_MV_ETH_TXQ);
+	dev = alloc_etherdev_mq(sizeof(struct eth_port), CONFIG_MV_ETH_TXQ);
 	if (!dev)
 		return NULL;
 
-	dev_priv = (struct eth_netdev *)netdev_priv(dev);
+	dev_priv = (struct eth_port *)netdev_priv(dev);
 	if (!dev_priv)
 		return NULL;
 
-	memset(dev_priv, 0, sizeof(struct eth_netdev));
-	dev_priv->pp = pp;
-	pp->dev = dev;
+	memset(dev_priv, 0, sizeof(struct eth_port));
+
+	dev_priv->dev = dev;
 
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	BUG_ON(!res);
@@ -3246,6 +3281,28 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 
 	SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);
 
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	return dev;
+
+}
+
+/***************************************************************
+ * mv_eth_netdev_connect -- Connect device to linux            *
+***************************************************************/
+static int mv_eth_netdev_connect(struct eth_port *pp)
+{
+	struct net_device *dev;
+	struct cpu_ctrl	*cpuCtrl;
+	int cpu;
+
+	if (!pp) {
+		printk(KERN_ERR "failed to register, uninitialized port\n");
+		return -ENODEV;
+	}
+
+	dev = pp->dev;
+
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		cpuCtrl->napi_group_id = -1;
@@ -3253,20 +3310,19 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 		cpuCtrl->cleanup_timer.data = (unsigned long)dev;
 	}
 
-	SET_NETDEV_DEV(dev, &pdev->dev);
-
 	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
-		mv_eth_netdev_init_features(dev);
+		mv_eth_netdev_init_features(pp->dev);
 		if (register_netdev(dev)) {
 			printk(KERN_ERR "failed to register %s\n", dev->name);
 			free_netdev(dev);
-			return NULL;
+			return -ENODEV;
 		} else {
 			printk(KERN_ERR "    o %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
 			printk(KERN_CONT "\n");
 		}
 	}
-	return dev;
+
+	return MV_OK;
 }
 
 bool mv_eth_netdev_find(unsigned int dev_idx)
@@ -4205,8 +4261,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	struct cpu_ctrl	*cpuCtrl;
 	u8	*ext_buf;
 
-	memset(pp, 0, sizeof(struct eth_port));
-
 	/* Default field per cpu initialization */
 	for (i = 0; i < CONFIG_NR_CPUS; i++) {
 		pp->cpu_config[i] = kmalloc(sizeof(struct cpu_ctrl), GFP_KERNEL);
@@ -4398,35 +4452,13 @@ void mv_eth_netdev_print(struct net_device *dev)
 			(unsigned int)(dev->flags), (unsigned int)(dev->flags), netif_running(dev), netif_oper_up(dev));
 
 	if (mv_eth_netdev_find(dev->ifindex)) {
-		struct eth_netdev *pdev = MV_DEV_PRIV(dev);
+		struct eth_port *pp = MV_ETH_PRIV(dev);
 
-		if (pdev)
-			printk(KERN_ERR "pp=%p, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mask=0x%04x\n",
-				MV_ETH_PRIV(dev), pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
-	} else {
+		if (pp)
+			printk(KERN_ERR "pp=%p\n", pp);
+	} else
 		/* mux net device */
-		struct eth_netdev *pdev = MV_DEV_PRIV(dev);
-		struct eth_port   *pp = MV_ETH_PRIV(dev);
-
-		if (pdev && pp) {
-			if (pp->tag_type == MV_TAG_TYPE_VLAN)
-				printk(KERN_ERR "pp=%p, pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
-					pp, pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
-			else if (pp->tag_type == MV_TAG_TYPE_DSA)
-				printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%08x, rx_dsa=0x%08x, rx_mask=0x%08x\n",
-					pp, pdev, pdev->tx_tag.dsa, pdev->rx_tag_ptrn.dsa, pdev->rx_tag_mask.dsa);
-
-			else if (pp->tag_type == MV_TAG_TYPE_MH)
-				printk(KERN_ERR "pp=%p, pdev=%p: tx_dsa=0x%04x, rx_dsa=0x%04x, rx_mask=0x%04x\n",
-					pp, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
-
-			else if (pp->tag_type == MV_TAG_TYPE_EDSA)
-				printk(KERN_ERR "pp=%p, pdev=%p: tx_edsa=0x%08x %08x, rx_edsa=0x%08x %08x, rx_mask=0x%08x %08x\n",
-					pp, pdev, pdev->tx_tag.edsa[1], pdev->tx_tag.edsa[0],
-					pdev->rx_tag_ptrn.edsa[1], pdev->rx_tag_ptrn.edsa[0],
-					pdev->rx_tag_mask.edsa[1], pdev->rx_tag_mask.edsa[0]);
-		}
-	}
+		mv_mux_netdev_print(dev);
 }
 
 void mv_eth_status_print(void)
@@ -4445,12 +4477,10 @@ void mv_eth_status_print(void)
 void mv_eth_port_status_print(unsigned int port)
 {
 	int txp, q;
-	struct net_device *dev;
-	struct eth_netdev *dev_priv;
+
 	struct eth_port *pp = mv_eth_port_by_id(port);
 	struct tx_queue *txq_ctrl;
 	struct cpu_ctrl	*cpuCtrl;
-	static char *tag_type[] = {"NONE", "MH", "DSA", "EDSA", "VLAN"};
 
 	if (!pp)
 		return;
@@ -4537,16 +4567,14 @@ void mv_eth_port_status_print(unsigned int port)
 	mv_eth_napi_groups_print(port);
 
 	/* Print status of all mux_dev for this port */
-	printk(KERN_CONT "TAG type = %s\n", tag_type[pp->tag_type]);
-	dev = pp->switch_dev;
-	while (dev != NULL) {
-		mv_eth_netdev_print(dev);
-		dev_priv = MV_DEV_PRIV(dev);
-		dev = dev_priv->next;
-		printk(KERN_CONT "\n\n");
-	}
+	if (pp->tagged) {
+		printk(KERN_CONT "TAGGED PORT\n\n");
+		mv_mux_netdev_print_all(port);
+	} else
+		printk(KERN_CONT "UNTAGGED PORT\n");
 }
 
+
 /***********************************************************************************
  ***  print port statistics
  ***********************************************************************************/
@@ -4603,7 +4631,7 @@ void mv_eth_port_stats_print(unsigned int port)
 	printk(KERN_ERR "cleanup_timer_event...........%10u\n", stat->cleanup_timer);
 	printk(KERN_ERR "link..........................%10u\n", stat->link);
 	printk(KERN_ERR "netdev_stop...................%10u\n", stat->netdev_stop);
-	if (pp->tag_type != MV_TAG_TYPE_NONE)
+	if (pp->tagged)
 		printk(KERN_ERR "rx_tagged....................%10u\n",  stat->rx_tagged);
 #ifdef CONFIG_MV_ETH_RX_SPECIAL
 	printk(KERN_ERR "rx_special....................%10u\n", stat->rx_special);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 5b07ecd..5f3fd2c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -331,7 +331,7 @@ struct napi_group_ctrl {
 
 struct eth_port {
 	int                 port;
-	int                 tag_type; /* NONE/MH/DSA/EDSA/VLAN */
+	bool                tagged; /* NONE/MH/DSA/EDSA/VLAN */
 	MV_PP2_PORT_CTRL   *port_ctrl;
 	struct rx_queue     *rxq_ctrl;
 	struct tx_queue     *txq_ctrl;
@@ -339,7 +339,6 @@ struct eth_port {
 	int		    first_rxq;
 	int 		    rxq_num;
 	struct net_device   *dev;
-	struct net_device   *switch_dev;
 	rwlock_t            rwlock;
 	struct bm_pool      *pool_long;
 	int                 pool_long_num;
@@ -391,18 +390,7 @@ enum eth_pm_mode {
 	MV_ETH_PM_LAST
 };
 
-struct eth_netdev {
-	int	idx;
-	bool    leave_tag;
-	MV_TAG  tx_tag;
-	MV_TAG  rx_tag_ptrn;
-	MV_TAG  rx_tag_mask;
-	struct eth_port   *pp;
-	struct net_device *next;
-};
-
-#define MV_ETH_PRIV(dev)        (((struct eth_netdev *)(netdev_priv(dev)))->pp)
-#define MV_DEV_PRIV(dev)        ((struct eth_netdev *)(netdev_priv(dev)))
+#define MV_ETH_PRIV(dev)        ((struct eth_port *)(netdev_priv(dev)))
 #define MV_DEV_STAT(dev)        (&((dev)->stats))
 
 /* define which Switch ports are relevant */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index 0d88725..5d1e068 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -41,12 +41,7 @@ disclaimer.
 #include "msApi.h"
 #include "h/platform/gtMiiSmiIf.h"
 #include "mv_switch.h"
-
-#ifdef CONFIG_MV_ETH_NETA
-#include "mv_neta/net_dev/mv_mux_netdev.h"
-#elif defined (CONFIG_MV_ETH_PP2)
-#include "mv_pp2/net_dev/mv_mux_netdev.h"
-#endif
+#include "mv_mux/mv_mux_netdev.h"
 
 unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
 
@@ -56,7 +51,7 @@ unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
 
 static u16 	db_port_mask[MV_SWITCH_DB_NUM];
 static u16 	db_link_mask[MV_SWITCH_DB_NUM];
-static void *	db_cookies[MV_SWITCH_DB_NUM];
+static void	*db_cookies[MV_SWITCH_DB_NUM];
 
 /* uncomment for debug prints */
 /* #define SWITCH_DEBUG */
@@ -85,7 +80,7 @@ static MV_SWITCH_PRESET_TYPE preset;
 static int default_vid;
 static int gbe_port;
 
-static struct mux_device_ops *mux_ops = NULL;
+static struct mv_switch_mux_ops *mux_ops;
 
 static struct tasklet_struct link_tasklet;
 static int switch_irq = -1;
@@ -215,8 +210,7 @@ static int mv_switch_group_state_set(int db, int en)
 				printk(KERN_ERR "gstpSetPortState failed\n");
 				return -1;
 			}
-		}
-		else {
+		} else {
 			if (gstpSetPortState(qd_dev, p, GT_PORT_DISABLE) != GT_OK) {
 				printk(KERN_ERR "gstpSetPortState failed\n");
 				return -1;
@@ -242,7 +236,7 @@ int mv_switch_link_status_get(int db)
 	return (db_link_mask[db] > 0);
 }
 
-int mv_switch_mux_ops_set(struct mux_device_ops *mux_ops_ptr)
+int mv_switch_mux_ops_set(struct mv_switch_mux_ops *mux_ops_ptr)
 {
 	mux_ops = mux_ops_ptr;
 
@@ -855,6 +849,8 @@ int mv_switch_init(struct mv_switch_pdata *plat_data)
 
 	enabled_ports_mask = switch_ports_mask;
 
+	mv_mux_switch_attach(gbe_port, preset, default_vid, tag_mode, plat_data->switch_cpu_port);
+
 #ifdef SWITCH_DEBUG
 	/* for debug: */
 	mv_switch_status_print();
@@ -970,9 +966,8 @@ int mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, in
 		mv_switch_vlan_set(MV_SWITCH_GROUP_VLAN_ID(vid), switch_ports_mask);
 	} else if (preset == MV_PRESET_PER_PORT_VLAN) {
 		for (p = 0; p < qd_dev->numOfPorts; p++)
-			if (MV_BIT_CHECK(switch_ports_mask, p) && (p != qd_cpu_port)) {
+			if (MV_BIT_CHECK(switch_ports_mask, p) && (p != qd_cpu_port))
 				mv_switch_vlan_set(MV_SWITCH_GROUP_VLAN_ID(vid + p), (1 << p));
-			}
 	}
 
 	if (preset == MV_PRESET_TRANSPARENT) {
@@ -1522,9 +1517,8 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* Add port to vtu (used in tx) */
-	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, grp_id, (port_map | (1 << qd_cpu_port)))) {
+	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, grp_id, (port_map | (1 << qd_cpu_port))))
 		printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
-	}
 
 	/* set vtu with each port private vlan id (used in rx) */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
@@ -1630,7 +1624,7 @@ static int mv_switch_probe(struct platform_device *pdev)
 static int mv_switch_remove(struct platform_device *pdev)
 {
 	printk(KERN_INFO "Removing Marvell Switch Driver\n");
-	//unload
+	/* unload */
 
 	return MV_OK;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index 1f384016..359f8ed 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -43,7 +43,7 @@ disclaimer.
 #define MV_SWITCH_VLAN_TO_GROUP(vid)       ((((vid) & 0xf00) >> 8) - 1)
 
 /* operations requested by switch device from mux device */
-struct mux_device_ops {
+struct mv_switch_mux_ops {
 	int	(*update_link)(void *cookie, int link_up);
 };
 
@@ -81,7 +81,7 @@ int		mv_switch_link_status_get(int db);
 int		mv_switch_group_cookie_set(int db, void *cookie);
 int		mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac);
 int		mv_switch_mac_addr_set(unsigned char *mac_addr, unsigned char db, unsigned char op);
-int		mv_switch_mux_ops_set(struct mux_device_ops *mux_ops_ptr);
+int		mv_switch_mux_ops_set(struct mv_switch_mux_ops *mux_ops_ptr);
 int		mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, int vid);
 int		mv_switch_promisc_set(int db, u8 promisc_on);
 #endif /* __mv_switch_h__ */
-- 
1.7.5.4

