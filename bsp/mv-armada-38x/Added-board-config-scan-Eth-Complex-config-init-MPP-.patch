From 9e628de9277b53609117e6509b98b27b5fa117bc Mon Sep 17 00:00:00 2001
From: omri itach <omrii@marvell.com>
Date: Wed, 27 Feb 2013 15:24:40 +0200
Subject: [PATCH 0477/1825] Added board config scan, Eth-Complex config init &
 MPP types selection

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 3590da5fc9a05ae669902147d2a17632ffb5d557

1. added Board configuration readings to S@R Scan- mvCtrlSatrInit (read from EEPROM or Deep Switch)

2. added Ethernet Complex configuration initialization

3. added MPP types selection (acording to S@R & board config)

Change-Id: Ib95eb1a8aa7c58fc01e8b20810668fbd76b927b9
Reviewed-on: http://vgitil04.il.marvell.com:8080/1198
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |  309 +++++++++++++++++++-
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |  133 +++++++++-
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |   80 ++++--
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.h     |    6 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  100 +++++--
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |   42 ++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |   15 +-
 7 files changed, 593 insertions(+), 92 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 5d3aa19..5fb8ec3 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -755,12 +755,271 @@ MV_32 mvBoardMppTypeGet(MV_U32 mppGroupNum)
 	return (MV_U32)board->pBoardMppGroupValue[mppGroupNum];
 }
 
-MV_STATUS mvBoardConfigInit(void)
+MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType)
 {
-/*   read S@R configuration From local array - already filled by mvCtrlSatrInit, and:
- *   1. decide which group types is relevant for mpp init
- *   2. build etherntComplex struct for kosta */
-	return MV_OK;
+	board->pBoardMppGroupValue[mppGroupNum] = groupType;
+}
+
+/*******************************************************************************
+* mvBoardConfigInit - Build board configuration : Eth-Complex & MPP types
+*
+* DESCRIPTION:
+*   read S@R & board configuration From: satrOptionsConfig[] & boardOptionsConfig[],
+*   (initialized  by mvCtrlSatrInit ) and :
+*   1. build etherntComplex configuration
+*   2. decide the relevant MPP group types
+*
+* INPUT:  None.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       if initialized correct return MV_OK, else MV_ERROR
+*
+*******************************************************************************/
+MV_VOID mvBoardConfigInit(void)
+{
+	MV_U32 ethSataComplexOptions = 0x0;
+	MV_ETH_COMPLEX_TOPOLOGY mac0con, mac1con;
+	MV_BOARD_BOOT_SRC bootDev;
+	MV_TDM_UNIT_TYPE tdmDev;
+	MV_BOOL SW_SMI;
+
+	/* Ethernet Complex initialization : */
+	if ( (mac0con = mvBoardMac0ConfigGet()) != MV_ERROR)
+		ethSataComplexOptions |= mac0con;
+	if ( (mac1con = mvBoardMac1ConfigGet()) != MV_ERROR)
+		ethSataComplexOptions |= mac1con;
+
+	if (mac0con == 0x0) /* 00 - MAC0 connected to Switch P6 */
+		ethSataComplexOptions |= MV_ETH_COMPLEX_SW_P6_RGMII0;
+
+	if (mac1con == 0x2) /* 10  MAC1 connected to Switch P4 */
+		ethSataComplexOptions |= MV_ETH_COMPLEX_SW_P4_RGMII1;
+
+	if (mvCtrlConfigGet(MV_CONFIG_PON_SERDES) == 0x0)  /* 0 - PON SerDes connected to PON MAC */
+		ethSataComplexOptions |= MV_ETH_COMPLEX_P2P_MAC_PON_ETH_SERDES;
+
+	board->pBoardModTypeValue->ethSataComplexOpt = ethSataComplexOptions;
+
+	/* MPP Groups initialization : */
+	/* Group 0-1 - Boot device (or if SPI1 boot : Groups 3-4) */
+	bootDev = mvBoardBootDeviceGroupSet(mvCtrlSatRRead(MV_SATR_BOOT_DEVICE));
+
+	/* Group 2 - TDM unit */
+	tdmDev = mvCtrlTdmUnitTypeGet();
+	switch (tdmDev) {
+	case SLIC_LANTIQ_ID:
+		mvBoardMppTypeSet(2, SLIC_LANTIQ_UNIT);
+		break;
+	case SLIC_SILABS_ID:
+		mvBoardMppTypeSet(2, SLIC_SILABS_UNIT);
+		break;
+	case SLIC_ZARLINK_ID:
+		mvBoardMppTypeSet(2, SLIC_ZARLINK_UNIT);
+		break;
+	case SLIC_EXTERNAL_ID:
+		mvBoardMppTypeSet(2, SLIC_EXTERNAL_UNIT);
+		break;
+	}
+
+	/* Groups 3-4  - (only if not Booting from SPI1)*/
+	if (bootDev != MSAR_0_BOOT_SPI1_FLASH) {
+		if (mac1con == 0x0) /* 00 - MAC1 connected to RGMII-1 */
+			mvBoardMppTypeSet(3, GE1_UNIT);
+		else
+			mvBoardMppTypeSet(3, SDIO_UNIT);
+
+		SW_SMI = MV_TRUE; // test if SW or CPU SMI control (omriii : how to decide ?)
+		if (mvCtrlIsLantiqTDM())
+			mvBoardMppTypeSet(4, (SW_SMI ? GE1_SW_SMI_CTRL_TDM_LQ_UNIT : GE1_CPU_SMI_CTRL_TDM_LQ_UNIT));
+		else    /*REF_CLK_OUT*/
+			mvBoardMppTypeSet(4, (SW_SMI ? GE1_SW_SMI_CTRL_REF_CLK_OUT : GE1_CPU_SMI_CTRL_REF_CLK_OUT));
+	}
+
+	/* Groups 5-6-7  - */
+	if (mac0con == 0x2) { /* 10 - MAC0 connected to RGMII-0  */
+		/* omriii: what scenario leads to enable PON_CLK_OUT insted of PON_TX_FAULT?? */
+		mvBoardMppTypeSet(5, GE0_UNIT_PON_TX_FAULT);
+		mvBoardMppTypeSet(6, GE0_UNIT);
+		mvBoardMppTypeSet(7, GE0_UNIT_LED_MATRIX);  /* omriii :when to use GE0_UNIT_UA1_PTP */
+	}else if (mac1con == 0x2) { /* 10  MAC1 connected to Switch P4 */
+		mvBoardMppTypeSet(5, SWITCH_P4_PON_TX_FAULT);
+		mvBoardMppTypeSet(6, SWITCH_P4);
+		mvBoardMppTypeSet(7, SWITCH_P4_LED_MATRIX); /* omriii :when to use SWITCH_P4_UA1_PTP */
+	}
+}
+
+/*******************************************************************************
+* mvBoardBootDeviceGroupSet - test board Boot configuration and set MPP groups
+*
+* DESCRIPTION:
+*   read board BOOT configuration and set MPP groups accordingly
+*	-  Sets groups 0-1 for NAND or SPI0 Boot
+*	   Or   groups 3-4 for SPI1 Boot
+*	- return Selected boot device
+*
+* INPUT:  sarBootDevice - BOOT_DEVICE value from S@R.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       the selected MV_BOARD_BOOT_SRC
+*
+*******************************************************************************/
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_U32 sarBootDevice)
+{
+	MV_SAR_BOOT_TABLE sarTable[] = MV_SAR_TABLE_VAL;
+	MV_SAR_BOOT_TABLE sarBootEntry = sarTable[sarBootDevice];
+	MV_U32 groupType;
+	MV_BOOL SW_SMI;
+
+	switch (sarBootEntry.bootSrc) {
+	case MSAR_0_BOOT_NAND_NEW:
+		mvBoardMppTypeSet(0, NAND_BOOT_V2);
+		mvBoardMppTypeSet(1, NAND_BOOT_V2);
+		return MSAR_0_BOOT_NAND_NEW;
+		break;
+	case MSAR_0_BOOT_NAND_LEGACY:
+		mvBoardMppTypeSet(0, NAND_BOOT_V1);
+		mvBoardMppTypeSet(1, NAND_BOOT_V1);
+		return MSAR_0_BOOT_NAND_LEGACY;
+		break;
+	case MSAR_0_BOOT_SPI_FLASH:
+		if (sarBootEntry.attr1 == MSAR_0_SPI0) {
+			groupType = ((mvCtrlConfigGet(MV_CONFIG_DEVICE_BUS_MODULE) == 0x2) ? SPI0_BOOT_SPDIF_AUDIO : SPI0_BOOT);
+			mvBoardMppTypeSet(0, groupType);
+			mvBoardMppTypeSet(1, groupType);
+			return MSAR_0_BOOT_SPI_FLASH;
+		}else  {                        /* MSAR_0_SPI1 - update Groups 3-4 */
+			mvBoardMppTypeSet(3, SDIO_SPI1_UNIT);
+			SW_SMI = MV_TRUE;       // test if SW or CPU SMI control (omriii : how to decide ?)
+			if (mvCtrlIsLantiqTDM())
+				mvBoardMppTypeSet(4, (SW_SMI ? SPI1_SW_SMI_CTRL_TDM_LQ_UNIT : SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT));
+			else    /*REF_CLK_OUT*/
+				mvBoardMppTypeSet(4, (SW_SMI ? SPI1_SW_SMI_CTRL_REF_CLK_OUT : SPI1_CPU_SMI_CTRL_REF_CLK_OUT));
+			// omriii : if nand/spi0 not for BOOT, enable Audio-SPDIF by default?
+			mvBoardMppTypeSet(0, SPI0_BOOT_SPDIF_AUDIO);
+			mvBoardMppTypeSet(1, SPI0_BOOT_SPDIF_AUDIO);
+			return MSAR_0_BOOT_SPI1_FLASH;
+		}
+		break;
+/* omriii : what to do with the next Boot devices  ?
+        case MSAR_0_BOOT_NOR_FLASH:
+                break;
+        case MSAR_0_BOOT_PROMPT:
+                break;
+        case MSAR_0_BOOT_UART:
+                break;
+        case MSAR_0_BOOT_SATA:
+                break;
+        case MSAR_0_BOOT_PEX:
+                break;
+ */
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMac0ConfigGet - test board configuration and return the correct MAC0 config
+*
+* DESCRIPTION:
+*	test board configuration regarding MAC0
+*	if configured to SGMII-0 , will check which lane is configured to SGMII,
+*	and return its MV_ETH_COMPLEX_TOPOLOGY define
+*	else return error
+*
+* INPUT:  None.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       if configured correct, the MV_ETH_COMPLEX_TOPOLOGY define, else MV_ERROR
+*
+*******************************************************************************/
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac0ConfigGet()
+{
+	switch (mvCtrlConfigGet(MV_CONFIG_MAC0)) {
+	case 0x0:
+		return MV_ETH_COMPLEX_GE_MAC0_SW_P6;
+		break;
+	case 0x1:
+		return MV_ETH_COMPLEX_GE_MAC0_QUAD_PHY_P0;
+		break;
+	case 0x2:
+		return MV_ETH_COMPLEX_GE_MAC0_RGMII0;
+		break;
+	case 0x3:
+		return mvBoardLaneSGMIIGet();
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMac1ConfigGet - test board configuration and return the correct MAC1 config
+*
+* DESCRIPTION:
+*	test board configuration regarding PON_SERDES
+*	if MAC0 is configured to PON SerDes Connection return its MV_ETH_COMPLEX_TOPOLOGY define
+*	else test MV_CONFIG_MAC1 configuration
+*
+* INPUT:  None.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       if configured correct, the MV_ETH_COMPLEX_TOPOLOGY define, else MV_ERROR
+*
+*******************************************************************************/
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet()
+{
+	if (mvCtrlConfigGet(MV_CONFIG_PON_SERDES) == 0x1)
+		return MV_ETH_COMPLEX_GE_MAC1_PON_ETH_SERDES;
+	/* else Scan MAC1 config to decide its connection */
+	switch (mvCtrlConfigGet(MV_CONFIG_MAC1)) {
+	case 0x0:
+		return MV_ETH_COMPLEX_GE_MAC1_RGMII1;
+		break;
+	case 0x1:
+		return MV_ETH_COMPLEX_GE_MAC1_SW_P4;
+		break;
+	case 0x2:
+		return MV_ETH_COMPLEX_GE_MAC1_QUAD_PHY_P3;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardIsLaneSGMII - check if a board lane is configured to SGMII-0
+*
+* DESCRIPTION:
+*	test board configuration regarding lanes-1/2/3
+*	if one of them is configured to SGMII-0 , will return its MV_ETH_COMPLEX_TOPOLOGY define
+*	else return error
+*
+* INPUT:  None.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       value =MV_ETH_COMPLEX_GE_MAC0_COMPHY_1/2/3 if lanes 1/2/3 are SGMII-0 (adaptively)
+*       or -1 if none of them is SGMII-0
+*
+*******************************************************************************/
+MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet()
+{
+	if (mvCtrlConfigGet(MV_CONFIG_LANE1) == 0x1)
+		return MV_ETH_COMPLEX_GE_MAC0_COMPHY_1;
+	else if (mvCtrlConfigGet(MV_CONFIG_LANE2) == 0x0)
+		return MV_ETH_COMPLEX_GE_MAC0_COMPHY_2;
+	else if (mvCtrlConfigGet(MV_CONFIG_LANE3) == 0x1)
+		return MV_ETH_COMPLEX_GE_MAC0_COMPHY_3;
+	else return MV_ERROR;
 }
 
 MV_VOID mvBoardConfigWrite(void)
@@ -1254,6 +1513,34 @@ MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo
 }
 
 /*******************************************************************************
+* mvBoardConfigTypeGet
+*
+* DESCRIPTION:
+*	Return the Config type fields information for a given Config type class.
+*
+* INPUT:
+*	configClass - The Config type field to return the information for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_BOARD_CONFIG_TYPE_INFO struct with mask, offset and register number.
+*
+*******************************************************************************/
+MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo)
+{
+	int i;
+
+	for (i = 0; i < board->numBoardConfigTypes; i++)
+		if (board->pBoardConfigTypes[i].configid == configClass) {
+			*configInfo = board->pBoardConfigTypes[i];
+			return MV_OK;
+		}
+	return MV_ERROR;
+}
+
+/*******************************************************************************
 * mvBoardNandWidthGet -
 *
 * DESCRIPTION: Get the width of the first NAND device in bytes
@@ -1342,7 +1629,7 @@ MV_U32 mvBoardIdGet(MV_VOID)
 }
 
 /*******************************************************************************
-* mvBoardTwsiSatRGet -
+* mvBoardTwsiGet -
 *
 * DESCRIPTION:
 *
@@ -1357,7 +1644,7 @@ MV_U32 mvBoardIdGet(MV_VOID)
 *		reg value
 *
 *******************************************************************************/
-MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
+MV_U8 mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum)
 {
 	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
@@ -1370,8 +1657,8 @@ MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
 
 	/* Read MPP module ID */
 	DB(mvOsPrintf("Board: Read S@R device read\n"));
-	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
-	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(twsiClass, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(twsiClass, devNum);
 
 	twsiSlave.validOffset = MV_TRUE;
 	/* Use offset as command */
@@ -1436,7 +1723,7 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 /*******************************************************************************
  * SatR Configuration functions
  */
-
+# if 0
 MV_U8 mvBoardCpuFreqGet(MV_VOID)
 {
 	MV_U8 sar;
@@ -1492,6 +1779,8 @@ MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
 	return MV_OK;
 }
 
+#endif
+
 MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
 {
 	return 1;
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 446857a..72a0616 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -271,6 +271,13 @@ typedef struct _boardSarInfo {
 	MV_U32 regNum;
 } MV_BOARD_SAR_INFO;
 
+typedef struct _boardConfigTypesInfo {
+	MV_CONFIG_TYPE_ID configid;
+	MV_U32 mask;
+	MV_U32 offset;
+	MV_U32 regNum;
+} MV_BOARD_CONFIG_TYPE_INFO;
+
 typedef enum _boardMacSpeed {
 	BOARD_MAC_SPEED_10M,
 	BOARD_MAC_SPEED_100M,
@@ -351,6 +358,8 @@ typedef struct _boardInfo {
 	MV_DEV_CS_INFO *pDevCsInfo;
 	MV_U8 numBoardSarInfo;
 	MV_BOARD_SAR_INFO *pBoardSarInfo;
+	MV_U8 numBoardConfigTypes;
+	MV_BOARD_CONFIG_TYPE_INFO *pBoardConfigTypes;
 	MV_U8 numBoardTwsiDev;
 	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
 	MV_U8 numBoardMacInfo;
@@ -411,6 +420,119 @@ typedef struct _boardInfo {
 	MV_BOOL moduleAutoDetect;
 } MV_BOARD_INFO;
 
+typedef enum {
+	MSAR_0_BOOT_NOR_FLASH,
+	MSAR_0_BOOT_NAND_NEW,
+	MSAR_0_BOOT_UART,
+	MSAR_0_BOOT_SPI_FLASH,
+	MSAR_0_BOOT_PEX,
+	MSAR_0_BOOT_SATA,
+	MSAR_0_BOOT_NAND_LEGACY,
+	MSAR_0_BOOT_PROMPT,
+	MSAR_0_BOOT_SPI1_FLASH
+} MV_BOARD_BOOT_SRC;
+
+/* Boot device bus width */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS          3
+/* Bus width field meaning for NOR/NAND */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT          (0x0 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT         (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_32BIT         (0x2 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+/* Bus width field meaning for SPI */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT  (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT     (0x0 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+
+/* NAND page size */
+#define MSAR_0_NAND_PAGE_SZ_OFFS                11
+#define MSAR_0_NAND_PAGE_SZ_512B                (0x0 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_2KB                 (0x1 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_4KB                 (0x2 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_8KB                 (0x3 << MSAR_0_NAND_PAGE_SZ_OFFS)
+
+/* NAND ECC */
+#define MSAR_0_NAND_ECC_OFFS                    14
+#define MSAR_0_NAND_ECC_4BIT                    (0x0 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_8BIT                    (0x1 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_12BIT                   (0x2 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_16BIT                   (0x3 << MSAR_0_NAND_ECC_OFFS)
+
+#define MSAR_0_SPI0                             0
+#define MSAR_0_SPI1                             1
+
+typedef struct _mvSARBootTable {
+	MV_BOARD_BOOT_SRC bootSrc;
+	MV_U32 attr1;                           /* Device width/Port */
+	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
+	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
+} MV_SAR_BOOT_TABLE;
+
+#define MV_SAR_TABLE_VAL { \
+/*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*03*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*04*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*05*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*06*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*07*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*08*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*09*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*10*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*11*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*12*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 4, 0 }, \
+/*13*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*14*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 0 }, \
+/*15*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 1 }, \
+/*16*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*17*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*18*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT },	\
+/*19*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT },	\
+/*20*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT }, \
+/*21*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT }, \
+/*22*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT },	\
+/*23*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT },	\
+/*24*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT }, \
+/*25*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT }, \
+/*26*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },	\
+/*27*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },	\
+/*28*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT }, \
+/*29*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT }, \
+/*30*/ { 0,           5,            60,          60           }, \
+/*31*/ { 0,           2,            40,          40           }, \
+/*32*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     2                }, \
+/*33*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
+/*34*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
+/*35*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       3                }, \
+/*36*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B,     3                }, \
+/*37*/ { MSAR_0_BOOT_NAND_LEGACY, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB,       2                }, \
+/*38*/ { 0,           1,            2,            2              }, \
+/*39*/ { 0,           3,            6,            6              }, \
+/*40*/ { 0,           3,            5,            5              }, \
+/*41*/ { 0,           2,            6,            3              }, \
+/*42*/ { 0,           4,            10,          5              }, \
+/*43*/ { 0,           3,            6,            6              }, \
+/*44*/ { 0,           2,            4,            4              }, \
+/*45*/ { 0,           3,            6,            3              }, \
+/*46*/ { 0,           2,            5,            5              }, \
+/*47*/ { MSAR_0_BOOT_PROMPT,         2,            5,            5              }, \
+/*48*/ { MSAR_0_BOOT_UART,               1,            3,            3              }, \
+/*49*/ { MSAR_0_BOOT_SATA,                5,            10,          10           }, \
+/*50*/ { MSAR_0_BOOT_PEX,   3,            8,            4              }, \
+/*51*/ { MSAR_0_BOOT_PEX,   1,            2,            1              }, \
+/*52*/ { 0,           3,            6,            3              }, \
+/*53*/ { 0,           2,            8,            4              }, \
+/*54*/ { 0,           5,            10,          5              }, \
+/*55*/ { 0,           1,            20,          20           }, \
+/*56*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*57*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*58*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*59*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*60*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*61*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*62*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*63*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 40               } \
+}
+
 /* For backward compatability with Legacy mode */
 #define mvBoardSwitchConnectedPortGet(port)	(-1)
 #define mvBoardIsSwitchConnected(port)  	(mvBoardSwitchConnectedPortGet(port) != -1)
@@ -429,6 +551,7 @@ MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
 
 MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum);
 MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo);
+MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo);
 MV_U32 mvBoardTclkGet(MV_VOID);
 MV_U32 mvBoardSysClkGet(MV_VOID);
 MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
@@ -443,6 +566,7 @@ MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum);
 MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
 MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
 MV_32 mvBoardMppTypeGet(MV_U32 mppGroupNum);
+MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType);
 MV_U32 mvBoardGppConfigGet(void);
 MV_32 mvBoardTdmSpiModeGet(MV_VOID);
 MV_U8 mvBoardTdmDevicesCountGet(void);
@@ -462,8 +586,13 @@ MV_32 mvBoardNandWidthGet(void);
 MV_U32 mvBoardIdGet(MV_VOID);
 MV_VOID mvBoardIdSet(MV_VOID);
 MV_U32 mvBoardSledCpuNumGet(MV_VOID);
-
-MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum);
+MV_VOID mvBoardConfigInit(MV_VOID);
+void mvBoardConfigWrite(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac0ConfigGet(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet(MV_VOID);
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_U32 sarBootDevice);
+MV_U8 mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum);
 MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
 
 MV_U8 mvBoardCpuFreqGet(MV_VOID);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
index 1165ec8..083cb09 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -71,25 +71,43 @@
 
 MV_BOARD_SAR_INFO boardSarInfo[] = {
 /* {{MV_SATR_TYPE_ID SarID, MV_U32 Mask, MV_U32 Offset, MV_U32 regNum}} */
-	{ MV_SATR_CPU_FREQ,	       0x003E0000,	      17,		     1	      },
-	{ MV_SATR_CORE_CLK_SELECT,     0x00400000,	      22,		     1	      },
-	{ MV_SATR_CPU1_ENABLE,	       0x00008000,	      15,		     0	      },
-	{ MV_SATR_SSCG_DISABLE,	       0x00000002,	      1,		     0	      },
-	{ MV_SATR_I2C0_Serial_ROM,     0x00000001,	      0,		     0	      },
-	{ MV_SATR_External_CPU_Reset,  0x0,		      0,		     0	      },        /* omriii : check with max the relevance of these fields */
-	{ MV_SATR_External_CORE_Reset, 0x0,		      0,		     0	      },        /* omriii : check with max the relevance of these fields */
-	{ MV_SATR_BOOT_DEVICE,	       0X1F8,		      3,		     0	      },
-	{ MV_SATR_CPU_PLL_XTAL_BYPASS, 0x00000200,	      9,		     0	      },
-	{ MV_SATR_PEX0_CLOCK,	       0x00000400,	      10,		     0	      },
-	{ MV_SATR_PEX1_CLOCK,	       0x00000800,	      11,		     0	      },
-	{ MV_SATR_REF_CLOCK_ENABLE,    0x00000004,	      2,		     0	      },
-	{ MV_SATR_TESTER_OPTIONS,      0x00080000,	      19,		     0	      },
-	{ MV_SATR_CPU0_ENDIANESS,      0x00001000,	      12,		     0	      },
-	{ MV_SATR_CPU0_NMFI,	       0x00002000,	      13,		     0	      },
-	{ MV_SATR_CPU0_THUMB,	       0x00004000,	      14,		     0	      },
-	{ MV_SATR_EFUSE_BYPASS,	       0x00020000,	      17,		     0	      },
-	{ MV_SATR_POR_BYPASS,	       0x00100000,	      20,		     0	      },
-	{ MV_SATR_BOARD_ID,	       0xF0,		      4,		     1	      },
+	{ MV_SATR_CPU_FREQ,		 0x003E0000,		  17,		       1		 },
+	{ MV_SATR_CORE_CLK_SELECT,	 0x00400000,		  22,		       1		 },
+	{ MV_SATR_CPU1_ENABLE,		 0x00008000,		  15,		       0		 },
+	{ MV_SATR_SSCG_DISABLE,		 0x00000002,		  1,		       0		 },
+	{ MV_SATR_I2C0_Serial_ROM,	 0x00000001,		  0,		       0		 },
+	{ MV_SATR_External_CPU_Reset,	 0x0,			  0,		       0		 },     /* omriii : ask max the relevance of these fields */
+	{ MV_SATR_External_CORE_Reset,	 0x0,			  0,		       0		 },     /* omriii : ask max the relevance of these fields */
+	{ MV_SATR_BOOT_DEVICE,		 0X1F8,			  3,		       0		 },
+	{ MV_SATR_CPU_PLL_XTAL_BYPASS,	 0x00000200,		  9,		       0		 },
+	{ MV_SATR_PEX0_CLOCK,		 0x00000400,		  10,		       0		 },
+	{ MV_SATR_PEX1_CLOCK,		 0x00000800,		  11,		       0		 },
+	{ MV_SATR_REF_CLOCK_ENABLE,	 0x00000004,		  2,		       0		 },
+	{ MV_SATR_TESTER_OPTIONS,	 0x00080000,		  19,		       0		 },
+	{ MV_SATR_CPU0_ENDIANESS,	 0x00001000,		  12,		       0		 },
+	{ MV_SATR_CPU0_NMFI,		 0x00002000,		  13,		       0		 },
+	{ MV_SATR_CPU0_THUMB,		 0x00004000,		  14,		       0		 },
+	{ MV_SATR_EFUSE_BYPASS,		 0x00020000,		  17,		       0		 },
+	{ MV_SATR_POR_BYPASS,		 0x00100000,		  20,		       0		 },
+	{ MV_SATR_BOARD_ID,		 0xF0,			  4,		       1		 },
+	{ MV_SATR_WRITE_CPU_FREQ,	 0X1F,			  0,		       0		 },
+	{ MV_SATR_WRITE_CORE_CLK_SELECT, 0x1,			  0,		       1		 },
+	{ MV_SATR_WRITE_CPU1_ENABLE,	 0x2,			  1,		       1		 },
+	{ MV_SATR_WRITE_SSCG_DISABLE,	 0x4,			  2,		       1		 },
+};
+
+MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[] = {
+/* {{MV_CONFIG_TYPE_ID ConfigID, MV_U32 Mask, MV_U32 Offset, MV_U32 regNum}} */
+	{ MV_CONFIG_MAC0,	       0x3,		 0,		   0 }, /* Reg#0, BITS [0:1] */
+	{ MV_CONFIG_MAC1,	       0xC,		 2,		   0 }, /* Reg#0, BITS [2:3] */
+	{ MV_CONFIG_PON_SERDES,	       0x10,		 4,		   0 }, /* Reg#0, BITS [4] */
+	{ MV_CONFIG_PON_BEN_POLARITY,  0x20,		 5,		   0 }, /* Reg#0, BITS [5] */
+	{ MV_CONFIG_SGMII0_CAPACITY,   0x40,		 6,		   0 }, /* Reg#0, BITS [6] */
+	{ MV_CONFIG_SGMII1_CAPACITY,   0x80,		 7,		   0 }, /* Reg#0, BITS [7] */
+	{ MV_CONFIG_LANE1,	       0x3,		 0,		   1 }, /* Reg#1, BITS [0:1] */
+	{ MV_CONFIG_LANE2,	       0x4,		 2,		   1 }, /* Reg#1, BITS [2] */
+	{ MV_CONFIG_LANE3,	       0X18,		 3,		   1 }, /* Reg#1, BITS [3:4] */
+	{ MV_CONFIG_DEVICE_BUS_MODULE, 0x60,		 5,		   1 }, /* Reg#1, BITS [5:6] */
 };
 
 /*******************************************************************************
@@ -150,23 +168,23 @@ MV_BOARD_INFO avanta_lp_fpga_board_info = {
 
 MV_BOARD_TWSI_INFO db88f6600InfoBoardTwsiDev[] = {
 	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
-	{ BOARD_DEV_TWSI_SATR,	      0x4C,	   ADDR7_BIT	       },
-	{ BOARD_DEV_TWSI_SATR,	      0x4D,	   ADDR7_BIT	       },
-	{ BOARD_DEV_TWSI_EEPROM,      0x54,	   ADDR7_BIT	       },
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x21,	   ADDR7_BIT	       },
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x22,	   ADDR7_BIT	       },       /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x24,	   ADDR7_BIT	       },       /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
+	{ BOARD_DEV_TWSI_SATR,	      0x4C,	   ADDR7_BIT			     },
+	{ BOARD_DEV_TWSI_SATR,	      0x4D,	   ADDR7_BIT			     },
+	{ BOARD_DEV_TWSI_EEPROM,      0x54,	   ADDR7_BIT			     },
+	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x21,	   ADDR7_BIT			     },
+	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x22,	   ADDR7_BIT			     }, /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
+	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x24,	   ADDR7_BIT			     }, /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
 };
 MV_BOARD_MAC_INFO db88f6600InfoBoardMacInfo[] = {
 	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_U8 boardEthSmiAddr}} */
-	{ BOARD_MAC_SPEED_AUTO, 0x8		     },
-	{ BOARD_MAC_SPEED_AUTO, 0x9		     },
-	{ N_A,			N_A		     }
+	{ BOARD_MAC_SPEED_AUTO, 0x8						       },
+	{ BOARD_MAC_SPEED_AUTO, 0x9						       },
+	{ N_A,			N_A						       }
 };
 MV_BOARD_MPP_TYPE_INFO db88f6600InfoBoardModTypeInfo[] = {
 	{
 		.boardMppTdm = MV_BOARD_AUTO,
-		.ethSataComplexOpt = 0x0,
+		.ethSataComplexOpt = DB_88F6660_ETH_DEFAULT,
 		.ethPortsMode = 0x0
 	}
 };
@@ -200,6 +218,8 @@ MV_BOARD_INFO db88f6600_board_info = {
 	.pDevCsInfo			= 0,
 	.numBoardSarInfo		= ARRSZ(boardSarInfo),
 	.pBoardSarInfo			= boardSarInfo,
+	.numBoardConfigTypes		= ARRSZ(boardConfigTypesInfo),
+	.pBoardConfigTypes		= boardConfigTypesInfo,
 	.numBoardTwsiDev		= ARRSZ(db88f6600InfoBoardTwsiDev),
 	.pBoardTwsiDev			= db88f6600InfoBoardTwsiDev,
 	.numBoardMacInfo		= ARRSZ(db88f6600InfoBoardMacInfo),
@@ -378,4 +398,4 @@ MV_BOARD_INFO avanta_lp_customer_board_info = {
 MV_BOARD_INFO *boardInfoTbl[] = {
 	&avanta_lp_fpga_board_info,
 	&db88f6600_board_info,
-};
\ No newline at end of file
+};
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
index dd5e95d..94d9243 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
@@ -113,7 +113,7 @@ typedef enum _mvBoardId {
 /* default MPP Types */
 #define DB_88F6600_GROUP_0_TYPE         NAND_BOOT_V2
 #define DB_88F6600_GROUP_1_TYPE         NAND_BOOT_V2
-#define DB_88F6600_GROUP_2_TYPE         TDM_LQ_UNIT
+#define DB_88F6600_GROUP_2_TYPE         SLIC_LANTIQ_UNIT
 #define DB_88F6600_GROUP_3_TYPE         GE1_UNIT
 #define DB_88F6600_GROUP_4_TYPE         GE1_CPU_SMI_CTRL_TDM_LQ_UNIT
 #define DB_88F6600_GROUP_5_TYPE         SWITCH_P4_PON_TX_FAULT
@@ -121,6 +121,8 @@ typedef enum _mvBoardId {
 #define DB_88F6600_GROUP_7_TYPE         SWITCH_P4_LED_MATRIX
 #define DB_88F6600_GROUP_8_TYPE         LED_MATRIX_PTP
 
+#define DB_88F6660_ETH_DEFAULT (MV_ETH_COMPLEX_GE_MAC0_SW_P6 | MV_ETH_COMPLEX_GE_MAC1_RGMII1 | MV_ETH_COMPLEX_SW_P0_QUAD_PHY_P0 | MV_ETH_COMPLEX_SW_P3_QUAD_PHY_P3 | MV_ETH_COMPLEX_SW_P4_RGMII1)
+
 #define DB_88F6600_GPP_OUT_ENA_LOW      0x0
 #define DB_88F6600_GPP_OUT_ENA_MID      0x0
 #define DB_88F6600_GPP_OUT_ENA_HIGH     0x0
@@ -156,4 +158,4 @@ typedef enum _mvBoardId {
 
 #endif  /* MV_ASMLANGUAGE */
 
-#endif  /* __INCmvBoardEnvSpech */
\ No newline at end of file
+#endif  /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 542d956..303b1de 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -123,7 +123,8 @@ typedef struct _ctrlEnvInfo {
 
 CTRL_ENV_INFO ctrlEnvInfo = {};
 
-MV_U32 satrOptionsConfig[MV_SATR_MAX_OPTION];
+MV_U32 satrOptionsConfig[MV_SATR_READ_MAX_OPTION];
+MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
 
 MV_U32 mvCtrlGetCpuNum(MV_VOID)
 {
@@ -187,9 +188,11 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 			i++;
 		}
 	}
-
+	/* Use S@R and board config info, to Build Eth-Complex config & MPP group types */
 	mvBoardConfigInit();
-	mvBoardConfigWrite(); /* write MPP's config and Board general config */
+
+	/* write MPP's config and Board general config */
+	mvBoardConfigWrite();
 
 	/* disable all GPIO interrupts */
 	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
@@ -229,7 +232,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCtrlSatRWrite(MV_SATR_TYPE_ID satrField, MV_U8 val)
 {
-	if (satrField < MV_SATR_MAX_OPTION) {
+	if (satrField < MV_SATR_READ_MAX_OPTION) {
 		//TwsiSATRWrite (satrField , val);
 		satrOptionsConfig[satrField] = val;      /* simulate dummy write instead of TWSI - will be removed */
 		//if ( val==TwsiSATRRead (satrField) )
@@ -259,13 +262,34 @@ MV_U32 mvCtrlSatRWrite(MV_SATR_TYPE_ID satrField, MV_U8 val)
 *******************************************************************************/
 MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
 {
-	if (satrField < MV_SATR_MAX_OPTION)
+	if (satrField < MV_SATR_READ_MAX_OPTION)
 		return satrOptionsConfig[satrField];
 	else
 		return MV_ERROR;
 }
 
 /*******************************************************************************
+* mvCtrlBoardConfigGet
+*
+* DESCRIPTION: Read Board configuration Field
+*
+* INPUT: configField - Field description enum
+*
+* OUTPUT: None
+*
+* RETURN:
+*	if field is valid - returns requested Board configuration field value
+*
+*******************************************************************************/
+MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField)
+{
+	if (configField < MV_CONFIG_TYPE_MAX_OPTION)
+		return boardOptionsConfig[configField];
+	else
+		return MV_ERROR;
+}
+
+/*******************************************************************************
 * mvCtrlSatrInit
 *
 * DESCRIPTION: Initialize S@R configuration
@@ -282,28 +306,46 @@ MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
 *******************************************************************************/
 void mvCtrlSatrInit(void)
 {
-	MV_U8 tempVal = 0;
-	MV_BOARD_SAR_INFO info;
+	MV_U8 tempVal[2];
+	MV_BOARD_SAR_INFO sInfo;
+	MV_BOARD_CONFIG_TYPE_INFO cInfo;
 	int i = 0;
 
-	/* initialize all S@R fields to -1 (MV_ERROR) */
-	for (i = 0; i < MV_SATR_MAX_OPTION; i++)
+	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
+	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++)
 		satrOptionsConfig[i] = MV_ERROR;
 
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++)
+		boardOptionsConfig[i] = MV_ERROR;
+
 	/* detect board ID to determine which S@R fields are relevant */
 	//boardID=mvBoardIdGet();
 
-	for (i = 0; i < MV_SATR_MAX_OPTION; i++) {
-		if ( MV_OK == mvBoardSarInfoGet(i, &info)) {
-			tempVal = (MV_REG_READ(MPP_SAMPLE_AT_RESET(info.regNum)) & (info.mask) >> info.offset);
-			satrOptionsConfig[info.sarid] = tempVal;
+	/* Read Sample @ Reset configuration, memory access read : */
+	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++) {
+		if ( MV_OK == mvBoardSarInfoGet(i, &sInfo)) {
+			tempVal[0] = MV_REG_READ(MPP_SAMPLE_AT_RESET(sInfo.regNum));
+			satrOptionsConfig[sInfo.sarid] = ((tempVal[0]  & (sInfo.mask)) >> sInfo.offset);
 		}
 	}
 
-	/*omriii: temp: simulate dummy twsi initalizations */
-	for (i = 0; i < MV_SATR_MAX_OPTION; i++)
-		satrOptionsConfig[i] = i % 3;
-	/*omriii temp: simulate dummy initalizations */
+	/*Read rest of Board Configuration, EEPROM / Deep Switch access read : */
+	tempVal[0] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 0);               /* EEPROM Reg#0 */
+	tempVal[1] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 1);               /* EEPROM Reg#1 */
+	if (((MV_8)MV_ERROR == (MV_8)tempVal[0]) || ((MV_8)MV_ERROR == (MV_8)tempVal[1]) ) { /* EEPROM is not valid , data is jumpered to deep switch- read from there */
+		tempVal[0] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 0, 0);  /* Deep Switch Reg#0 */
+		tempVal[1] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 0, 1);  /* Deep Switch Reg#1 */
+		/* omriii : verify reads from BOARD_DEV_TWSI_IO_EXPANDER are correct */
+	}
+
+	if (((MV_8)MV_ERROR == (MV_8)tempVal[0]) || ((MV_8)MV_ERROR == (MV_8)tempVal[1]))       /* Deep Switch reading failed - omriii : use defaults (which iszeros for all fields) ??? */
+		tempVal[0] = tempVal[1] = 0x0;
+
+	/* Save values Locally */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++)
+		if ( MV_OK == mvBoardConfigTypeGet(i, &cInfo))
+			boardOptionsConfig[cInfo.configid] = ((tempVal[cInfo.regNum] & (cInfo.mask)) >> cInfo.offset);
+
 }
 
 /*******************************************************************************
@@ -595,7 +637,6 @@ MV_U32 mvCtrlSdioSupport(MV_VOID)
 
 #endif
 
-#if defined(MV_INCLUDE_TDM)
 /*******************************************************************************
 * mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
 *
@@ -654,14 +695,15 @@ MV_U32 mvCtrlTdmMaxGet(MV_VOID)
 *******************************************************************************/
 MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(MV_VOID)
 {
-	return TDM_LQ_UNIT; /* omriii: FIXME */
-
-/*	implement a scan process for all 4 units, and return the enum for the correct unit being used
- *      TDM_LQ_UNIT
-        TDM_SL_UNIT
-        TDM_ZL_UNIT
-        TDM_EXT_UNIT
- */
+	if (mvCtrlIsLantiqTDM())
+		return SLIC_LANTIQ_ID;  /* omriii: FIXME */
+	else if (mvCtrlIsZarlinkTDM())
+		return SLIC_ZARLINK_ID;
+	else if (mvCtrlIsSiliconLabsTDM())
+		return SLIC_SILABS_ID;
+	else if (mvCtrlIsExternalTDM())
+		return SLIC_EXTERNAL_ID;
+	else return MV_ERROR;
 }
 
 /*******************************************************************************
@@ -685,8 +727,6 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 	return MV_TDM_IRQ_NUM;
 }
 
-#endif /* MV_INCLUDE_TDM */
-
 /*******************************************************************************
 * mvCtrlModelGet - Get Marvell controller device model (Id)
 *
@@ -1185,7 +1225,7 @@ MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment) /* kostaz: FIXME: remov
 MV_BOOL mvCtrlIsLantiqTDM(MV_VOID)
 {
 	/* implement Scan process */
-	return MV_TRUE;
+	return MV_FALSE;
 }
 
 /*******************************************************************************
@@ -1756,4 +1796,4 @@ static const MV_U8 serdesCfg[][8] = SERDES_CFG;
 MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
 {
 	return MV_ERROR;
-}
\ No newline at end of file
+}
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 77e0aae..ab82afa 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -98,9 +98,27 @@ typedef enum _mvSatRTypeID {
 	MV_SATR_POR_BYPASS,
 	MV_SATR_TESTER_OPTIONS,
 	MV_SATR_BOARD_ID,
-	MV_SATR_MAX_OPTION
+	MV_SATR_READ_MAX_OPTION,
+	MV_SATR_WRITE_CPU_FREQ,
+	MV_SATR_WRITE_CORE_CLK_SELECT,
+	MV_SATR_WRITE_CPU1_ENABLE,
+	MV_SATR_WRITE_SSCG_DISABLE
 } MV_SATR_TYPE_ID;
 
+typedef enum _mvConfigTypeID {
+	MV_CONFIG_MAC0,
+	MV_CONFIG_MAC1,
+	MV_CONFIG_PON_SERDES,
+	MV_CONFIG_PON_BEN_POLARITY,
+	MV_CONFIG_SGMII0_CAPACITY,
+	MV_CONFIG_SGMII1_CAPACITY,
+	MV_CONFIG_LANE1,
+	MV_CONFIG_LANE2,
+	MV_CONFIG_LANE3,
+	MV_CONFIG_DEVICE_BUS_MODULE,
+	MV_CONFIG_TYPE_MAX_OPTION
+} MV_CONFIG_TYPE_ID;
+
 /* 0 for Auto scan mode, 1 for manual. */
 #define MV_INTERNAL_SWITCH_SMI_SCAN_MODE        0
 
@@ -147,9 +165,9 @@ typedef enum {
 	MV_ETH_COMPLEX_GE_MAC1_PON_ETH_SERDES = 0x200,
 	MV_ETH_COMPLEX_SW_P0_QUAD_PHY_P0 =      0x400,
 	MV_ETH_COMPLEX_SW_P3_QUAD_PHY_P3 =      0x800,
-	MV_ETH_COMPLEX_SW_P4_RGMII0     =       0x1000,
+	MV_ETH_COMPLEX_SW_P6_RGMII0     =       0x1000,
 	MV_ETH_COMPLEX_P2P_MAC_PON_ETH_SERDES = 0x2000,
-	MV_ETH_COMPLEX_SW_P4_RMGII0     =       0x4000
+	MV_ETH_COMPLEX_SW_P4_RGMII1     =       0x4000
 } MV_ETH_COMPLEX_TOPOLOGY;
 
 typedef enum {
@@ -214,13 +232,7 @@ typedef struct _boardSerdesConf {
 MV_U32 mvCtrlSatRWrite(MV_SATR_TYPE_ID satrField, MV_U8 val);
 MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField);
 void mvCtrlSatrInit(MV_VOID);
-MV_STATUS mvBoardConfigInit(MV_VOID);
-void mvBoardConfigWrite(MV_VOID);
-MV_BOOL mvCtrlIsLantiqTDM(MV_VOID);
-MV_BOOL mvCtrlIsZarlinkTDM(MV_VOID);
-MV_BOOL mvCtrlIsExternalTDM(MV_VOID);
-MV_BOOL mvCtrlIsSiliconLabsTDM(MV_VOID);
-
+MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
@@ -257,12 +269,14 @@ MV_U32 mvCtrlNandSupport(MV_VOID);
 #if defined(MV_INCLUDE_SDIO)
 MV_U32 mvCtrlSdioSupport(MV_VOID);
 #endif
-#if defined(MV_INCLUDE_TDM)
 MV_U32 mvCtrlTdmSupport(MV_VOID);
 MV_U32 mvCtrlTdmMaxGet(MV_VOID);
-MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_BOOL mvCtrlIsLantiqTDM(MV_VOID);
+MV_BOOL mvCtrlIsZarlinkTDM(MV_VOID);
+MV_BOOL mvCtrlIsExternalTDM(MV_VOID);
+MV_BOOL mvCtrlIsSiliconLabsTDM(MV_VOID);
 MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID);
-#endif
 
 MV_U16 mvCtrlModelGet(MV_VOID);
 MV_U8 mvCtrlRevGet(MV_VOID);
@@ -292,4 +306,4 @@ MV_U32 mvCtrlDDRBudWidth(MV_VOID);
 MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
 MV_BOOL mvCtrlDDRECC(MV_VOID);
 
-#endif /* __INCmvCtrlEnvLibh */
\ No newline at end of file
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index ce36513..39ed3f1 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -331,10 +331,10 @@ typedef enum {
 }
 
 typedef enum {
-	TDM_LQ_UNIT,
-	TDM_SL_UNIT,
-	TDM_ZL_UNIT,
-	TDM_EXT_UNIT,
+	SLIC_LANTIQ_UNIT,
+	SLIC_SILABS_UNIT,
+	SLIC_ZARLINK_UNIT,
+	SLIC_EXTERNAL_UNIT
 } MV_GROUP_2_TYPE;
 
 #define MPP_GROUP_3_TYPE { \
@@ -431,6 +431,13 @@ typedef enum {
 }
 
 /* This enumerator defines the Marvell Units ID      */
+typedef enum {
+	SLIC_LANTIQ_ID,
+	SLIC_SILABS_ID,
+	SLIC_ZARLINK_ID,
+	SLIC_EXTERNAL_ID
+} MV_TDM_UNIT_TYPE;
+
 typedef enum _mvUnitId {
 	DRAM_UNIT_ID,
 	PEX_UNIT_ID,
-- 
1.7.5.4

