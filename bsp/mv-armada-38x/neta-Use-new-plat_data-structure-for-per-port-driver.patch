From 5e0a97276552c098de7ca5d858fb397af818d896 Mon Sep 17 00:00:00 2001
From: Yoni Farhadia <yonif@marvell.com>
Date: Sun, 15 Sep 2013 10:14:02 +0200
Subject: [PATCH 0986/1825] neta: Use new plat_data structure for per port
 driver initialization

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1753b57d3c4debccde5b9da7bd2e267d261aa6a8

        - Use plat_data for per port initialization
        - Merged from ALP code

Change-Id: I25f5f76f1bc3007b100ee4f12b049f46b863e51e
Signed-off-by: Yoni Farhadia <yonif@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada370/Makefile                   |    1 -
 arch/arm/mach-armada370/core.c                     |  120 ++++-
 arch/arm/mach-armada370/export.c                   |   18 +
 arch/arm/mach-armadaxp/Makefile                    |    1 -
 arch/arm/mach-armadaxp/core.c                      |  210 ++++++--
 arch/arm/mach-armadaxp/export.c                    |   15 +
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c  |   19 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c   |    1 -
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |  553 +++++++++----------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |   17 +-
 include/linux/mv_neta.h                            |   47 ++-
 11 files changed, 626 insertions(+), 376 deletions(-)

diff --git a/arch/arm/mach-armada370/Makefile b/arch/arm/mach-armada370/Makefile
index 7349ead..36e27dd 100644
--- a/arch/arm/mach-armada370/Makefile
+++ b/arch/arm/mach-armada370/Makefile
@@ -71,7 +71,6 @@ armada370-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
 
 
 # NETA Giga driver
-armada370-$(CONFIG_MV_ETH_NETA)         += $(HAL_IF_DIR)/mvSysNeta.o
 obj-$(CONFIG_MV_ETH_NETA)		+= $(LSP_NETA_DIR)/
 
 armada370-$(CONFIG_MV_INCLUDE_CESA)     += $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaDebug.o       \
diff --git a/arch/arm/mach-armada370/core.c b/arch/arm/mach-armada370/core.c
index c51af27..7ffc497 100644
--- a/arch/arm/mach-armada370/core.c
+++ b/arch/arm/mach-armada370/core.c
@@ -22,6 +22,7 @@
 #include <linux/string.h>
 #include <linux/sysdev.h>
 #include <linux/mbus.h>
+#include <linux/ethtool.h>
 #include <asm/mach/time.h>
 #include <linux/clocksource.h>
 #include <mach/hardware.h>
@@ -36,6 +37,7 @@
 #include <asm/mach/map.h>
 #include <mach/system.h>
 
+#include <linux/etherdevice.h>
 #include <linux/tty.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
@@ -72,6 +74,7 @@
 #endif
 
 #include <plat/mv_xor.h>
+#include <linux/mv_neta.h>
 
 /* I2C */
 #include <linux/i2c.h>
@@ -118,8 +121,8 @@ MV_U32 mvTclk = 166666667;
 MV_U32 mvSysclk = 200000000;
 
 #ifdef CONFIG_MV_INCLUDE_GIG_ETH
-MV_U8 mvMacAddr[CONFIG_MV_ETH_PORTS_NUM][6];
-MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
+MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
+MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = {0};
 #endif
 
 /*
@@ -202,13 +205,11 @@ static int __init parse_tag_mv_uboot(const struct tag *tag)
 	bit_mask_config = tag->u.mv_uboot.bit_mask_config;
 
 #ifdef CONFIG_MV_INCLUDE_GIG_ETH
-	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+	for (i = 0; i < MV_UBOOT_ETH_PORTS; i++) {
 #if defined (CONFIG_OVERRIDE_ETH_CMDLINE)
 		memset(mvMacAddr[i], 0, 6);
 		mvMtu[i] = 0;
 #else
-printk(">>>>>>>Tag MAC %02x:%02x:%02x:%02x:%02x:%02x\n", tag->u.mv_uboot.macAddr[i][5], tag->u.mv_uboot.macAddr[i][4],
-	tag->u.mv_uboot.macAddr[i][3], tag->u.mv_uboot.macAddr[i][2], tag->u.mv_uboot.macAddr[i][1], tag->u.mv_uboot.macAddr[i][0]);
 		memcpy(mvMacAddr[i], tag->u.mv_uboot.macAddr[i], 6);
 		mvMtu[i] = tag->u.mv_uboot.mtu[i];
 #endif
@@ -604,23 +605,110 @@ static struct platform_device mv88fx_eth = {
 	.id             = 0,
 	.num_resources  = 0,
 };
-#elif defined(CONFIG_MV_ETH_NETA)
-static struct platform_device mv88fx_neta = {
-	.name           = "mv88fx_neta",
-	.id             = 0,
-	.num_resources  = 0,
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+static void mv_neta_giga_pdev_register(struct platform_device *pdev)
+{
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
+	int speed, port = pdev->id;
+
+	/* Global Parameters */
+	plat_data->ctrl_model = mvCtrlModelGet();
+	plat_data->ctrl_rev = mvCtrlRevGet();
+	plat_data->pclk = mvCpuPclkGet();
+	plat_data->tclk = mvBoardTclkGet();
+	plat_data->max_port = mvCtrlEthMaxPortGet();
+	plat_data->max_cpu = mvCtrlEthMaxCPUsGet();
+	/* Per port parameters */
+	plat_data->cpu_mask  = (1 << nr_cpu_ids) - 1;
+	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->is_sgmii = mvBoardIsPortInSgmii(port);
+	plat_data->is_rgmii = mvBoardIsPortInRgmii(port);
+	plat_data->duplex = DUPLEX_FULL;
+
+	if (port < MV_UBOOT_ETH_PORTS) {
+		plat_data->mtu = mvMtu[port];
+		if (plat_data->mtu == 0)
+			plat_data->mtu = 1500;
+		memcpy(plat_data->mac_addr, mvMacAddr[port], 6);
+		if (is_zero_ether_addr(plat_data->mac_addr))
+			pr_warning("Warning: port #%d - zero MAC address\n", port);
+	} else {
+		plat_data->mtu = 1500;
+		memset(plat_data->mac_addr, 0, 6);
+	}
+	speed = mvBoardMacSpeedGet(port);
+	switch (speed) {
+	case BOARD_MAC_SPEED_10M:
+		plat_data->speed = SPEED_10;
+		break;
+	case BOARD_MAC_SPEED_100M:
+		plat_data->speed = SPEED_100;
+		break;
+	case BOARD_MAC_SPEED_1000M:
+		plat_data->speed = SPEED_1000;
+		break;
+	case BOARD_MAC_SPEED_AUTO:
+	default:
+		plat_data->speed = 0;
+		break;
+	}
+	pr_info("Register platform device: %s_%d\n", pdev->name, pdev->id);
+	platform_device_register(pdev);
+}
+static struct resource mv_neta_ge0_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE0_FIC,
+		.end            = IRQ_AURORA_GBE0_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
 };
-#else
-#error "Ethernet Mode is not defined (should be Legacy or NETA)"
-#endif /* Ethernet mode: legacy or NETA */
+static struct mv_neta_pdata mv_neta_ge0_pdata = {
+	.mtu = 1500,
+	.phy_addr = 0,
+};
+static struct platform_device mv_neta_ge0_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id		= 0,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge0_resources),
+	.resource       = mv_neta_ge0_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge0_pdata,
+	},
+};
+static struct resource mv_neta_ge1_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE1_FIC,
+		.end            = IRQ_AURORA_GBE1_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge1_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+};
+static struct platform_device mv_neta_ge1_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge1_resources),
+	.resource       = mv_neta_ge1_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge1_pdata,
+	},
+};
+#endif /* CONFIG_MV_ETH_NETA || CONFIG_MV_ETH_NETA_MODULE */
 
 static void __init eth_init(void)
 {
 #if defined(CONFIG_MV_ETH_LEGACY)
 	platform_device_register(&mv88fx_eth);
-#elif defined(CONFIG_MV_ETH_NETA)
-	platform_device_register(&mv88fx_neta);
-#endif /* Ethernet mode: legacy or NETA */
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+	mv_neta_giga_pdev_register(&mv_neta_ge0_plat);
+	mv_neta_giga_pdev_register(&mv_neta_ge1_plat);
+#endif /* CONFIG_MV_ETH_NETA) || CONFIG_MV_ETH_NETA_MODULE */
 }
 #endif /* CONFIG_MV_ETHERNET */
 
diff --git a/arch/arm/mach-armada370/export.c b/arch/arm/mach-armada370/export.c
index ed5eebd..19de9a2 100644
--- a/arch/arm/mach-armada370/export.c
+++ b/arch/arm/mach-armada370/export.c
@@ -35,6 +35,7 @@ extern u32 mvSysclk;
 
 EXPORT_SYMBOL(mv_early_printk);
 EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlPwrClckSet);
 EXPORT_SYMBOL(mvCtrlModelRevGet);
 EXPORT_SYMBOL(mvTclk);
 EXPORT_SYMBOL(mvSysclk);
@@ -61,6 +62,7 @@ EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
 EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
 EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
 EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+EXPORT_SYMBOL(mvLog2);
 
 #include "spi/mvSpiCmnd.h"
 EXPORT_SYMBOL(mvSpiWriteThenWrite);
@@ -201,3 +203,19 @@ EXPORT_SYMBOL(TRC_OUTPUT);
 EXPORT_SYMBOL(TRC_START);
 EXPORT_SYMBOL(TRC_RELEASE);
 #endif
+#include "mvList.h"
+EXPORT_SYMBOL(mvListCreate);
+EXPORT_SYMBOL(mvListDestroy);
+
+#include "mvStack.h"
+EXPORT_SYMBOL(mvStackCreate);
+EXPORT_SYMBOL(mvStackDelete);
+EXPORT_SYMBOL(mvStackStatus);
+
+#include "eth-phy/mvEthPhy.h"
+EXPORT_SYMBOL(mvEthPhyRestartAN);
+EXPORT_SYMBOL(mvEthPhyDisableAN);
+EXPORT_SYMBOL(mvEthPhyRegRead);
+EXPORT_SYMBOL(mvEthPhyRegWrite);
+EXPORT_SYMBOL(mvEthPhyAdvertiseSet);
+EXPORT_SYMBOL(mvEthPhyAdvertiseGet);
diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index fb396c0..93c6209 100755
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -70,7 +70,6 @@ armadaxp-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
 
 
 # NETA Giga driver
-armadaxp-$(CONFIG_MV_ETH_NETA)          += $(HAL_IF_DIR)/mvSysNeta.o
 obj-$(CONFIG_MV_ETH_NETA)		+= $(LSP_NETA_DIR)/
 
 armadaxp-$(CONFIG_MV_INCLUDE_CESA) 	+= $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaDebug.o 	\
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 20d163c..995c406 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -31,12 +31,14 @@
 #include <asm/mach-types.h>
 
 #include <linux/memblock.h>
+#include <linux/ethtool.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/map.h>
 #include <mach/system.h>
 
+#include <linux/etherdevice.h>
 #include <linux/tty.h>
 #include <linux/platform_device.h>
 #include <linux/serial_core.h>
@@ -44,7 +46,6 @@
 #include <linux/serial_8250.h>
 #include <linux/serial_reg.h>
 #include <linux/ata_platform.h>
-#include <linux/mv_neta.h>
 #include <asm/serial.h>
 #include <plat/cache-aurora-l2.h>
 
@@ -72,6 +73,7 @@
 #endif
 
 #include <plat/mv_xor.h>
+#include <linux/mv_neta.h>
 
 /* I2C */
 #include <linux/i2c.h>
@@ -119,7 +121,6 @@ extern u32 mv_crypto_virt_base_get(u8 chan);
 #endif
 extern void axp_init_irq(void);
 extern void __init set_core_count(unsigned int cpu_count);
-extern unsigned int group_cpu_mask;
 
 /* for debug putstr */
 static char arr[256];
@@ -127,11 +128,10 @@ MV_U32 mvTclk = 166666667;
 MV_U32 mvSysclk = 200000000;
 
 #ifdef CONFIG_MV_INCLUDE_GIG_ETH
-MV_U8 mvMacAddr[CONFIG_MV_ETH_PORTS_NUM][6];
-MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
+MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
+MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = {0};
 #endif
 
-
 /*
  * Helpers to get DDR bank info
  */
@@ -229,7 +229,7 @@ static int __init parse_tag_mv_uboot(const struct tag *tag)
 	gBoardId =  (mvUbootVer & 0xff);
 
 #ifdef CONFIG_MV_INCLUDE_GIG_ETH
-	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+	for (i = 0; i < MV_UBOOT_ETH_PORTS; i++) {
 #if defined (CONFIG_OVERRIDE_ETH_CMDLINE)
 		memset(mvMacAddr[i], 0, 6);
 		mvMtu[i] = 0;
@@ -730,61 +730,165 @@ static struct platform_device mv88fx_eth = {
 	.id		= 0,
 	.num_resources	= 0,
 };
-#elif defined(CONFIG_MV_ETH_NETA)
-static struct platform_device mv88fx_neta = {
-	.name		= "mv88fx_neta",
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+static void mv_neta_giga_pdev_register(struct platform_device *pdev)
+{
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
+	int speed, port = pdev->id;
+
+	/* Global Parameters */
+	plat_data->ctrl_model = mvCtrlModelGet();
+	plat_data->ctrl_rev = mvCtrlRevGet();
+	plat_data->pclk = mvCpuPclkGet();
+	plat_data->tclk = mvBoardTclkGet();
+	plat_data->max_port = mvCtrlEthMaxPortGet();
+	plat_data->max_cpu = mvCtrlEthMaxCPUsGet();
+	/* Per port parameters */
+	plat_data->cpu_mask  = (1 << nr_cpu_ids) - 1;
+	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->is_sgmii = mvBoardIsPortInSgmii(port);
+	plat_data->is_rgmii = mvBoardIsPortInRgmii(port);
+	plat_data->duplex = DUPLEX_FULL;
+
+	if (port < MV_UBOOT_ETH_PORTS) {
+		plat_data->mtu = mvMtu[port];
+		if (plat_data->mtu == 0)
+			plat_data->mtu = 1500;
+		memcpy(plat_data->mac_addr, mvMacAddr[port], 6);
+		if (is_zero_ether_addr(plat_data->mac_addr))
+			pr_warning("Warning: port #%d - zero MAC address\n", port);
+	} else {
+		plat_data->mtu = 1500;
+		memset(plat_data->mac_addr, 0, 6);
+	}
+	speed = mvBoardMacSpeedGet(port);
+	switch (speed) {
+	case BOARD_MAC_SPEED_10M:
+		plat_data->speed = SPEED_10;
+		break;
+	case BOARD_MAC_SPEED_100M:
+		plat_data->speed = SPEED_100;
+		break;
+	case BOARD_MAC_SPEED_1000M:
+		plat_data->speed = SPEED_1000;
+		break;
+	case BOARD_MAC_SPEED_AUTO:
+	default:
+		plat_data->speed = 0;
+		break;
+	}
+	pr_info("Register platform device: %s_%d\n", pdev->name, pdev->id);
+	platform_device_register(pdev);
+}
+static struct resource mv_neta_ge0_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE0_FIC,
+		.end            = IRQ_AURORA_GBE0_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge0_pdata = {
+	.mtu = 1500,
+	.phy_addr = 0,
+};
+static struct platform_device mv_neta_ge0_plat = {
+	.name           = MV_NETA_PORT_NAME,
 	.id		= 0,
-	.num_resources	= 0,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge0_resources),
+	.resource       = mv_neta_ge0_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge0_pdata,
+	},
 };
-#else
-#error "Ethernet Mode is not defined (should be Legacy or NETA)"
-#endif /* Ethernet mode: legacy or NETA */
+static struct resource mv_neta_ge1_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE1_FIC,
+		.end            = IRQ_AURORA_GBE1_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge1_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+};
+static struct platform_device mv_neta_ge1_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge1_resources),
+	.resource       = mv_neta_ge1_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge1_pdata,
+	},
+};
+static struct resource mv_neta_ge2_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE2_FIC,
+		.end            = IRQ_AURORA_GBE2_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge2_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+};
+static struct platform_device mv_neta_ge2_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id             = 2,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge2_resources),
+	.resource       = mv_neta_ge2_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge2_pdata,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge3_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+};
+static struct resource mv_neta_ge3_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE3_FIC,
+		.end            = IRQ_AURORA_GBE3_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct platform_device mv_neta_ge3_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id             = 3,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge3_resources),
+	.resource       = mv_neta_ge3_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge3_pdata,
+	},
+};
+#endif /* CONFIG_MV_ETH_NETA || CONFIG_MV_ETH_NETA_MODULE */
 
 static void __init eth_init(void)
 {
- struct netaSmpGroupStruct *netaSmpGroupStruct;
-        int cpu, found = 0, portMask;
-
-        netaSmpGroupStruct = kzalloc(sizeof(struct netaSmpGroupStruct), GFP_KERNEL);
-
-        if (!netaSmpGroupStruct) {
-                        printk(KERN_ERR "no memory for private data\n");
-                        return;
-        }
-        else {
-
-#ifdef  CONFIG_SMP
-                netaSmpGroupStruct->cpuMask  = group_cpu_mask;
-#else
-                netaSmpGroupStruct->cpuMask  = 1;
-#endif
-
-                portMask  = (mvUnitMapIsMine(ETH0) == MV_TRUE);
-                portMask |= (mvUnitMapIsMine(ETH1) == MV_TRUE) << 1;
-                portMask |= (mvUnitMapIsMine(ETH2) == MV_TRUE) << 2;
-                portMask |= (mvUnitMapIsMine(ETH3) == MV_TRUE) << 3;
-
-                netaSmpGroupStruct->portMask = portMask;
-        }
-
-        for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
-                if (MV_BIT_CHECK(netaSmpGroupStruct->cpuMask, cpu))
-                        found = 1;
-        }
-        if (!found) {
-                printk(KERN_ERR "%s: cpuMask does not contain any of the CPUs \n", __func__);
-                printk(KERN_ERR "%s: not initializing network driver\n", __func__);
-                return;
-        }
-        mv88fx_neta.dev.platform_data = netaSmpGroupStruct;
-
 #if defined(CONFIG_MV_ETH_LEGACY)
         platform_device_register(&mv88fx_eth);
-#elif defined(CONFIG_MV_ETH_NETA)
-        platform_device_register(&mv88fx_neta);
-#endif /* Ethernet mode: legacy or NETA */
-}
+#endif /* CONFIG_MV_ETH_LEGACY */
 
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+	if ((mvUnitMapIsMine(ETH0) == MV_TRUE) &&
+	    (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 0))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge0_plat);
+	}
+	if ((mvUnitMapIsMine(ETH1) == MV_TRUE) &&
+		(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 1))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge1_plat);
+	}
+	if ((mvUnitMapIsMine(ETH2) == MV_TRUE) &&
+		(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 2))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge2_plat);
+	}
+	if ((mvUnitMapIsMine(ETH3) == MV_TRUE) &&
+		(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 0))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge3_plat);
+	}
+#endif /* CONFIG_MV_ETH_NETA) || CONFIG_MV_ETH_NETA_MODULE */
+}
 #endif /* CONFIG_MV_ETHERNET */
 
 
diff --git a/arch/arm/mach-armadaxp/export.c b/arch/arm/mach-armadaxp/export.c
index 9f74008..dfcba5d 100644
--- a/arch/arm/mach-armadaxp/export.c
+++ b/arch/arm/mach-armadaxp/export.c
@@ -35,6 +35,7 @@ extern u32 mvSysclk;
 
 EXPORT_SYMBOL(mv_early_printk);
 EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlPwrClckSet);
 EXPORT_SYMBOL(mvCtrlModelRevGet);
 EXPORT_SYMBOL(mvTclk);
 EXPORT_SYMBOL(mvSysclk);
@@ -61,6 +62,7 @@ EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
 EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
 EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
 EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+EXPORT_SYMBOL(mvLog2);
 
 #ifdef CONFIG_MV_INCLUDE_SPI
 #include "spi/mvSpiCmnd.h"
@@ -214,3 +216,16 @@ EXPORT_SYMBOL(mvBmVirtBase);
 #include "mvList.h"
 EXPORT_SYMBOL(mvListCreate);
 EXPORT_SYMBOL(mvListDestroy);
+
+#include "mvStack.h"
+EXPORT_SYMBOL(mvStackCreate);
+EXPORT_SYMBOL(mvStackDelete);
+EXPORT_SYMBOL(mvStackStatus);
+
+#include "eth-phy/mvEthPhy.h"
+EXPORT_SYMBOL(mvEthPhyRestartAN);
+EXPORT_SYMBOL(mvEthPhyDisableAN);
+EXPORT_SYMBOL(mvEthPhyRegRead);
+EXPORT_SYMBOL(mvEthPhyRegWrite);
+EXPORT_SYMBOL(mvEthPhyAdvertiseSet);
+EXPORT_SYMBOL(mvEthPhyAdvertiseGet);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
index 3c9111f..55f2ef1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_sysfs.c
@@ -598,7 +598,7 @@ static struct attribute_group mv_eth_group = {
 	.attrs = mv_eth_attrs,
 };
 
-int __devinit mv_eth_sysfs_init(void)
+int mv_eth_sysfs_init(void)
 {
 	int err;
 	struct device *pd;
@@ -623,9 +623,18 @@ out:
 	return err;
 }
 
-module_init(mv_eth_sysfs_init);
+int mv_eth_sysfs_exit(void)
+{
+	struct device *pd;
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "neta");
+	if (!pd) {
+		printk(KERN_ERR"%s: cannot find neta device\n", __func__);
+		return -1;
+	}
+
+	sysfs_remove_group(&pd->kobj, &mv_eth_group);
+/*	remove_group_kobj_put(&pd->kobj, &mv_eth_group); */
 
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
index 7b0f8ae..4fb776a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
@@ -48,7 +48,6 @@ disclaimer.
 #include "mv_switch.h"
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
-static int mv_eth_start(struct net_device *dev);
 static int mv_eth_set_mac_addr_internals(struct net_device *dev, void *addr);
 
 /***********************************************************
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index 20c7a3b..e984856 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -141,7 +141,7 @@ static int mv_eth_rxq_fill(struct eth_port *pp, int rxq, int num);
 static void mv_eth_config_show(void);
 static int  mv_eth_priv_init(struct eth_port *pp, int port);
 static void mv_eth_priv_cleanup(struct eth_port *pp);
-static int  mv_eth_config_get(struct eth_port *pp, u8 *mac);
+static int  mv_eth_config_get(struct platform_device *pdev, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
 struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 					struct platform_device *pdev);
@@ -275,7 +275,7 @@ void set_cpu_affinity(struct eth_port *pp, MV_U32 cpuAffinity, int group)
 	/* First, read affinity of the target group, in case it contains CPUs */
 	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
 		cpuCtrl = pp->cpu_config[cpu];
-		if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))
+		if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))
 			continue;
 		if (cpuCtrl->napiCpuGroup == group) {
 			rxqAffinity = MV_REG_READ(NETA_CPU_MAP_REG(pp->port, cpu)) & 0xff;
@@ -301,7 +301,7 @@ int group_has_cpus(struct eth_port *pp, int group)
 	struct cpu_ctrl	*cpuCtrl;
 
 	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
-		if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))
+		if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))
 			continue;
 
 		cpuCtrl = pp->cpu_config[cpu];
@@ -335,7 +335,7 @@ void set_rxq_affinity(struct eth_port *pp, MV_U32 rxqAffinity, int group)
 	}
 
 	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
-		if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))
+		if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))
 			continue;
 		tmpRxqAffinity = rxqAffinity;
 
@@ -888,7 +888,7 @@ int	mv_eth_cpu_txq_mask_set(int port, int cpu, int txqMask)
 		return MV_FAIL;
 	}
 
-	if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))	{
+	if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))	{
 		printk(KERN_ERR "%s:Error- Cpu #%d masked for port  #%d\n", __func__, cpu, port);
 		return -EINVAL;
 	}
@@ -1420,6 +1420,7 @@ int mv_eth_skb_recycle(struct sk_buff *skb)
 		return 0;
 	}
 	STAT_DBG(pool->stats.skb_recycled_err++);
+
 	/* printk(KERN_ERR "mv_eth_skb_recycle failed: pool=%d, pkt=%p, skb=%p\n", pkt->pool, pkt, skb); */
 err:
 	mvOsFree(pkt);
@@ -3081,126 +3082,172 @@ static MV_STATUS mv_eth_bm_pools_init(void)
 	return MV_OK;
 }
 
+static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int en_force)
+{
+	if (en_force) {
+		if (mvNetaSpeedDuplexSet(port, port_speed, MV_ETH_DUPLEX_FULL)) {
+			printk(KERN_ERR "mvEthSpeedDuplexSet failed\n");
+			return -EIO;
+		}
+		if (mvNetaFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
+			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
+			return -EIO;
+		}
+		if (mvNetaForceLinkModeSet(port, 1, 0)) {
+			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
+			return -EIO;
+		}
+	} else {
+		if (mvNetaForceLinkModeSet(port, 0, 0)) {
+			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
+			return -EIO;
+		}
+		if (mvNetaSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
+			printk(KERN_ERR "mvEthSpeedDuplexSet failed\n");
+			return -EIO;
+		}
+		if (mvNetaFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
+			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
 /* Note: call this function only after mv_eth_ports_num is initialized */
-static int mv_eth_load_network_interfaces(MV_U32 portMask, MV_U32 cpuMask,
-						struct platform_device *pdev)
+static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 {
 	u32 port, dev_i = 0;
 	struct eth_port *pp;
 	int mtu, err;
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
 	u8 mac[MV_MAC_ADDR_SIZE];
 
-	printk(KERN_ERR "  o Loading network interface(s)\n");
+	port = pdev->id;
 
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		if (!(MV_BIT_CHECK(portMask, port)))
-			continue;
+	printk(KERN_ERR "  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
+			port, plat_data->cpu_mask, plat_data->mtu);
 
-		if (!mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port)) {
-			printk(KERN_ERR "\n  o Warning: GbE port %d is powered off\n\n", port);
-			continue;
-		}
-		if (!MV_PON_PORT(port) && !mvBoardIsGbEPortConnected(port)) {
-			printk(KERN_ERR "\n  o Warning: GbE port %d is not connected to PHY/RGMII/Switch, skip initialization\n\n",
-					port);
-			continue;
-		}
-
-		pp = mv_eth_ports[port] = mvOsMalloc(sizeof(struct eth_port));
-		if (!pp) {
-			printk(KERN_ERR "Error: failed to allocate memory for port %d\n", port);
-			return -ENOMEM;
-		}
+	pp = mv_eth_ports[port] = mvOsMalloc(sizeof(struct eth_port));
+	if (!pp) {
+		printk(KERN_ERR "Error: failed to allocate memory for port %d\n", port);
+		return -ENOMEM;
+	}
+	memset(pp, 0, sizeof(struct eth_port));
 
-		err = mv_eth_priv_init(pp, port);
-		pp->cpuMask = cpuMask;
+	pp->plat_data = plat_data;
+	pp->cpu_mask = plat_data->cpu_mask;
+	err = mv_eth_priv_init(pp, port);
+	if (err)
+		return err;
 
+	/* set port's speed, duplex, fc */
+	if (!MV_PON_PORT(pp->port)) {
+		/* force link, speed and duplex if necessary (e.g. Switch is connected) based on board information */
+		switch (plat_data->speed) {
+		case SPEED_10:
+			err = mv_eth_port_link_speed_fc(pp->port, MV_ETH_SPEED_10, 1);
+			break;
+		case SPEED_100:
+			err = mv_eth_port_link_speed_fc(pp->port, MV_ETH_SPEED_100, 1);
+			break;
+		case SPEED_1000:
+			err = mv_eth_port_link_speed_fc(pp->port, MV_ETH_SPEED_1000, 1);
+			break;
+		case 0:
+			err = mv_eth_port_link_speed_fc(pp->port, MV_ETH_SPEED_AN, 0);
+			break;
+		default:
+			/* do nothing */
+			break;
+		}
 		if (err)
 			return err;
+	}
 
+	if (mv_eth_hal_init(pp)) {
+		printk(KERN_ERR "%s: can't init eth hal\n", __func__);
+		mv_eth_priv_cleanup(pp);
+		return -EIO;
+	}
+#ifdef CONFIG_MV_ETH_HWF
+	mvNetaHwfInit(port);
+#endif /* CONFIG_MV_ETH_HWF */
 
 #ifdef CONFIG_MV_ETH_PMT
-		if (MV_PON_PORT(port))
-			mvNetaPmtInit(port, (MV_NETA_PMT *)ioremap(PMT_PON_PHYS_BASE, PMT_MEM_SIZE));
-		else
-			mvNetaPmtInit(port, (MV_NETA_PMT *)ioremap(PMT_GIGA_PHYS_BASE + port * 0x40000, PMT_MEM_SIZE));
+	if (MV_PON_PORT(port))
+		mvNetaPmtInit(port, (MV_NETA_PMT *)ioremap(PMT_PON_PHYS_BASE, PMT_MEM_SIZE));
+	else
+		mvNetaPmtInit(port, (MV_NETA_PMT *)ioremap(PMT_GIGA_PHYS_BASE + port * 0x40000, PMT_MEM_SIZE));
 #endif /* CONFIG_MV_ETH_PMT */
 
 #ifdef CONFIG_MV_ETH_SWITCH
-		if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-			int status = mv_eth_switch_config_get(mv_eth_initialized, port);
-
-			if (status < 0) {
-				printk(KERN_ERR "\nWarning: port %d - Invalid netconfig string\n", port);
-				mv_eth_priv_cleanup(pp);
-				continue;
-			} else if (status == 0) {	/* User selected to work with Gateway driver    */
-				clear_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
-			} else if (status == 1) {
-				/* User selected to work without Gateway driver */
-				clear_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
-				printk(KERN_ERR "  o Working in External Switch mode\n");
-				ext_switch_port_mask = mv_switch_link_detection_init();
-			}
-		}
-
-		if (pp->flags & MV_ETH_F_SWITCH) {
-			set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
-			mtu = switch_net_config[port].mtu;
-			if (mv_switch_init(RX_PKT_SIZE(mtu), SWITCH_CONNECTED_PORTS_MASK)) {
-				printk(KERN_ERR "\nWarning: port %d - Switch initialization failed\n", port);
-				mv_eth_priv_cleanup(pp);
-				continue;
-			}
-		} else
-#endif /* CONFIG_MV_ETH_SWITCH */
-			mtu = mv_eth_config_get(pp, mac);
-
-		printk(KERN_ERR "\t%s p=%d: mtu=%d, mac=%p\n", MV_PON_PORT(port) ? "pon" : "giga", port, mtu, mac);
+	if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
+		int status = mv_eth_switch_config_get(/*mv_eth_initialized*/ 0, port);
 
-		if (mv_eth_hal_init(pp)) {
-			printk(KERN_ERR "%s: can't init eth hal\n", __func__);
+		if (status < 0) {
+			printk(KERN_ERR "\nWarning: port %d - Invalid netconfig string\n", port);
 			mv_eth_priv_cleanup(pp);
 			return -EIO;
+		} else if (status == 0) {	/* User selected to work with Gateway driver    */
+			clear_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
+		} else if (status == 1) {
+			/* User selected to work without Gateway driver */
+			clear_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
+			printk(KERN_ERR "  o Working in External Switch mode\n");
+			ext_switch_port_mask = mv_switch_link_detection_init();
 		}
-#ifdef CONFIG_MV_ETH_SWITCH
-		if (pp->flags & MV_ETH_F_SWITCH) {
-			int queue = CONFIG_MV_ETH_RXQ_DEF;
-
-			mv_eth_switch_netdev_first = dev_i;
-			dev_i = mv_eth_switch_netdev_init(pp, dev_i, pdev);
-			if (dev_i < (mv_eth_switch_netdev_first + switch_net_config[port].netdev_max)) {
-				printk(KERN_ERR "%s: can't create netdevice for switch\n", __func__);
-				mv_eth_priv_cleanup(pp);
-				return -EIO;
-			}
-			mv_eth_switch_netdev_last = dev_i - 1;
+	}
 
-			/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch */
-			mv_eth_port_promisc_set(pp->port, queue);
-			handle_group_affinity(port);
+	if (pp->flags & MV_ETH_F_SWITCH) {
+		int queue = CONFIG_MV_ETH_RXQ_DEF;
 
-			continue;
+		set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
+		mtu = switch_net_config[port].mtu;
+		if (mv_switch_init(RX_PKT_SIZE(mtu), SWITCH_CONNECTED_PORTS_MASK)) {
+			printk(KERN_ERR "\nWarning: port %d - Switch initialization failed\n", port);
+			mv_eth_priv_cleanup(pp);
+			return -EIO;
 		}
-#endif /* CONFIG_MV_ETH_SWITCH */
 
-		mv_net_devs[dev_i] = mv_eth_netdev_init(pp, mtu, mac, pdev);
-		if (!mv_net_devs[dev_i]) {
-			printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+		mv_eth_switch_netdev_first = dev_i;
+		dev_i = mv_eth_switch_netdev_init(pp, dev_i, pdev);
+		if (dev_i < (mv_eth_switch_netdev_first + switch_net_config[port].netdev_max)) {
+			printk(KERN_ERR "%s: can't create netdevice for switch\n", __func__);
 			mv_eth_priv_cleanup(pp);
 			return -EIO;
 		}
-		pp->dev = mv_net_devs[dev_i];
-		dev_i++;
+		mv_eth_switch_netdev_last = dev_i - 1;
+
+		/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch */
+		mv_eth_port_promisc_set(pp->port, queue);
 		handle_group_affinity(port);
+
+		return MV_OK;
 	}
+#endif /* CONFIG_MV_ETH_SWITCH */
 
-	mv_net_devs_num = dev_i;
+	mtu = mv_eth_config_get(pdev, mac);
 
-	return MV_OK;
-}
+	printk(KERN_ERR "\t%s p=%d: mtu=%d, mac=" MV_MACQUAD_FMT "\n",
+		MV_PON_PORT(port) ? "pon" : "giga", port, mtu, MV_MACQUAD(mac));
+
+	mv_net_devs[dev_i] = mv_eth_netdev_init(pp, mtu, mac, pdev);
+	if (!mv_net_devs[dev_i]) {
+		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+		mv_eth_priv_cleanup(pp);
+		return -EIO;
+	}
+	pp->dev = mv_net_devs[dev_i];
+	dev_i++;
+	handle_group_affinity(port);
 
+	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
+	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
+		mv_eth_open(pp->dev);
 
+	return MV_OK;
+}
 
 int mv_eth_resume_network_interfaces(struct eth_port *pp)
 {
@@ -3209,7 +3256,7 @@ int mv_eth_resume_network_interfaces(struct eth_port *pp)
 	if (!MV_PON_PORT(pp->port)) {
 		int phyAddr;
 		/* Set the board information regarding PHY address */
-		phyAddr = mvBoardPhyAddrGet(pp->port);
+		phyAddr = pp->plat_data->phy_addr;
 		mvNetaPhyAddrSet(pp->port, phyAddr);
 	}
 	mvNetaPortDisable(pp->port);
@@ -3314,7 +3361,7 @@ static int mv_eth_resume_rxq_txq(struct eth_port *pp, int mtu)
 	int rxq, txp, txq = 0;
 
 
-	if (mvBoardIsPortInSgmii(pp->port))
+	if (pp->plat_data->is_sgmii)
 		MV_REG_WRITE(SGMII_SERDES_CFG_REG(pp->port), pp->sgmii_serdes);
 
 	for (txp = 0; txp < pp->txp_num; txp++)
@@ -3416,7 +3463,7 @@ int mv_eth_port_resume(int port)
 		printk(KERN_ERR "%s: port %d is not suspend.\n", __func__, port);
 		return MV_ERROR;
 	}
-	mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), mvBoardIsPortInRgmii(port));
+	mvNetaPortPowerUp(port, pp->plat_data->is_sgmii, pp->plat_data->is_rgmii);
 
 	mv_eth_win_init(port);
 
@@ -3424,23 +3471,19 @@ int mv_eth_port_resume(int port)
 
 	/* only once for all ports*/
 	if (pm_flag == 0) {
-
 #ifdef CONFIG_MV_ETH_BM
-		{
-			struct bm_pool *ppool;
-			int pool;
+		struct bm_pool *ppool;
+		int pool;
 
-			mvBmControl(MV_START);
+		mvBmControl(MV_START);
 
-			mvBmRegsInit();
+		mvBmRegsInit();
 
-			for (pool = 0; pool < MV_ETH_BM_POOLS; pool++) {
-				ppool = &mv_eth_pool[pool];
-				if (mv_eth_bm_pool_restore(ppool)) {
-					printk(KERN_ERR "%s: port #%d pool #%d resrote failed.\n",
-						__func__, port, pool);
-					return MV_ERROR;
-				}
+		for (pool = 0; pool < MV_ETH_BM_POOLS; pool++) {
+			ppool = &mv_eth_pool[pool];
+			if (mv_eth_bm_pool_restore(ppool)) {
+				printk(KERN_ERR "%s: port #%d pool #%d resrote failed.\n", __func__, port, pool);
+				return MV_ERROR;
 			}
 		}
 #endif /*CONFIG_MV_ETH_BM*/
@@ -3482,6 +3525,34 @@ int mv_eth_port_resume(int port)
 	return MV_OK;
 }
 
+void    mv_eth_hal_shared_init(struct mv_neta_pdata *plat_data)
+{
+	MV_NETA_HAL_DATA halData;
+
+	memset(&halData, 0, sizeof(halData));
+
+	halData.maxPort = plat_data->max_port;
+	halData.pClk = plat_data->pclk;
+	halData.tClk = plat_data->tclk;
+	halData.maxCPUs = plat_data->max_cpu;
+	halData.cpuMask = plat_data->cpu_mask;
+	halData.iocc = arch_is_coherent();
+	halData.ctrlModel = plat_data->ctrl_model;
+	halData.ctrlRev = plat_data->ctrl_rev;
+#ifdef CONFIG_MV_ETH_BM
+	halData.bmPhysBase = PNC_BM_PHYS_BASE;
+	halData.bmVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_BM */
+
+#ifdef CONFIG_MV_ETH_PNC
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_PNC */
+
+	mvNetaHalInit(&halData);
+
+	return;
+}
 
 
 /***********************************************************
@@ -3533,7 +3604,7 @@ int mv_eth_port_suspend(int port)
 		return MV_ERROR;
 	}
 
-	if (mvBoardIsPortInSgmii(pp->port))
+	if (pp->plat_data->is_sgmii)
 		pp->sgmii_serdes = MV_REG_READ(SGMII_SERDES_CFG_REG(port));
 
 	if (pp->flags & MV_ETH_F_STARTED) {
@@ -3599,68 +3670,48 @@ int	mv_eth_wol_mode_set(int port, int mode)
 }
 
 /***********************************************************
- * mv_eth_probe --                                         *
+ * mv_eth_shared_probe --                                         *
  *   main driver initialization. loading the interfaces.   *
  ***********************************************************/
-static int mv_eth_probe(struct platform_device *pdev)
+static int	mv_eth_shared_probe(struct mv_neta_pdata *plat_data)
 {
-	u32 port;
-	struct eth_port *pp;
 	int size;
-	MV_U32 port_mask, cpu_mask;
-
-	if (pdev->dev.platform_data) {
-		port_mask = ((struct netaSmpGroupStruct *)pdev->dev.platform_data)->portMask;
-		cpu_mask =  ((struct netaSmpGroupStruct *)pdev->dev.platform_data)->cpuMask;
-	} else {
-		port_mask = (1 << CONFIG_MV_ETH_PORTS_NUM) - 1;
-		cpu_mask = (1 << CONFIG_NR_CPUS) - 1;
-	}
-	printk(KERN_INFO "%s: port_mask=0x%x, cpu_mask=0x%x \n", __func__, port_mask, cpu_mask);
 
 #ifdef ETH_SKB_DEBUG
 	memset(mv_eth_skb_debug, 0, sizeof(mv_eth_skb_debug));
 	spin_lock_init(&skb_debug_lock);
 #endif
 
-	if (!mv_eth_initialized) {
-		mvSysNetaInit(port_mask, cpu_mask); /* init MAC Unit */
+	mv_eth_sysfs_init();
 
-		mv_eth_ports_num = mvCtrlEthMaxPortGet();
-		if (mv_eth_ports_num > CONFIG_MV_ETH_PORTS_NUM)
-			mv_eth_ports_num = CONFIG_MV_ETH_PORTS_NUM;
+	/* init MAC Unit */
+	mv_eth_hal_shared_init(plat_data);
 
-		mv_net_devs_max = mv_eth_ports_num;
+	mv_eth_ports_num = plat_data->max_port;
+	if (mv_eth_ports_num > CONFIG_MV_ETH_PORTS_NUM)
+		mv_eth_ports_num = CONFIG_MV_ETH_PORTS_NUM;
 
+	mv_net_devs_max = MV_ETH_MAX_NETDEV_NUM;
 #ifdef CONFIG_MV_ETH_SWITCH
-		mv_net_devs_max += (CONFIG_MV_ETH_SWITCH_NETDEV_NUM - 1);
+	mv_net_devs_max += (CONFIG_MV_ETH_SWITCH_NETDEV_NUM - 1);
 #endif /* CONFIG_MV_ETH_SWITCH */
 
-		mv_eth_config_show();
+	mv_eth_config_show();
 
-		size = mv_eth_ports_num * sizeof(struct eth_port *);
-		mv_eth_ports = mvOsMalloc(size);
-		if (!mv_eth_ports)
-			goto oom;
-
-		memset(mv_eth_ports, 0, size);
+	size = mv_eth_ports_num * sizeof(struct eth_port *);
+	mv_eth_ports = mvOsMalloc(size);
+	if (!mv_eth_ports)
+		goto oom;
 
-		/* Allocate array of pointers to struct net_device */
-		size = mv_net_devs_max * sizeof(struct net_device *);
-		mv_net_devs = mvOsMalloc(size);
-		if (!mv_net_devs)
-			goto oom;
+	memset(mv_eth_ports, 0, size);
 
-		memset(mv_net_devs, 0, size);
-	}
+	/* Allocate array of pointers to struct net_device */
+	size = mv_net_devs_max * sizeof(struct net_device *);
+	mv_net_devs = mvOsMalloc(size);
+	if (!mv_net_devs)
+		goto oom;
 
-#ifdef CONFIG_MV_ETH_PNC
-	if (mv_eth_pnc_ctrl_en) {
-		if (pnc_default_init())
-			printk(KERN_ERR "%s: Warning PNC init failed\n", __func__);
-	} else
-		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
-#endif /* CONFIG_MV_ETH_PNC */
+	memset(mv_net_devs, 0, size);
 
 	if (mv_eth_bm_pools_init())
 		goto oom;
@@ -3672,38 +3723,15 @@ static int mv_eth_probe(struct platform_device *pdev)
 	}
 #endif /* CONFIG_MV_INCLUDE_SWITCH */
 
-	if (!mv_eth_initialized) {
-		if (mv_eth_load_network_interfaces(port_mask, cpu_mask, pdev))
-			goto oom;
-	}
-
-#ifdef CONFIG_MV_ETH_HWF
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		if (mv_eth_ports[port])
-			mvNetaHwfInit(port);
-	}
-#endif /* CONFIG_MV_ETH_HWF */
-
-	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		pp = mv_eth_port_by_id(port);
-
-		if (pp) {
-			if (!(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
-				if (pp->flags & MV_ETH_F_SWITCH)
-					printk(KERN_ERR "%s: a GbE port using the Gateway driver cannot be disconnected from Linux\n",
-							__func__);
-				else
-					mv_eth_open(pp->dev);
-			}
-		}
-	}
-
-	if (!mv_eth_initialized)
-		mv_eth_cpu_counters_init();
-
+#ifdef CONFIG_MV_ETH_PNC
+	if (mv_eth_pnc_ctrl_en) {
+		if (pnc_default_init())
+			printk(KERN_ERR "%s: Warning PNC init failed\n", __func__);
+	} else
+		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
+#endif /* CONFIG_MV_ETH_PNC */
 
-	printk(KERN_ERR "\n");
+	mv_eth_cpu_counters_init();
 
 	mv_eth_initialized = 1;
 
@@ -3720,83 +3748,38 @@ oom:
 	return -ENOMEM;
 }
 
-
-static int mv_eth_config_get(struct eth_port *pp, MV_U8 *mac_addr)
+/***********************************************************
+ * mv_eth_probe --                                         *
+ *   main driver initialization. loading the interfaces.   *
+ ***********************************************************/
+static int mv_eth_probe(struct platform_device *pdev)
 {
-	char *mac_str = NULL;
-	u8 zero_mac[MV_MAC_ADDR_SIZE] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-	int mtu;
-
-	switch (pp->port) {
-	case 0:
-		if (mvMtu[0] != 0)
-			mtu = mvMtu[0];
-		else
-			mtu = CONFIG_MV_ETH_0_MTU;
-
-		/* use default MAC address from Kconfig only if the MAC address we got is all 0 */
-		if (memcmp(mvMacAddr[0], zero_mac, MV_MAC_ADDR_SIZE) == 0)
-			mac_str = CONFIG_MV_ETH_0_MACADDR;
-		else
-			memcpy(mac_addr, mvMacAddr[0], MV_MAC_ADDR_SIZE);
-
-		break;
-
-#if (CONFIG_MV_ETH_PORTS_NUM > 1)
-	case 1:
-		if (mvMtu[1] != 0)
-			mtu = mvMtu[1];
-		else
-			mtu = CONFIG_MV_ETH_1_MTU;
-
-		/* use default MAC address from Kconfig only if the MAC address we got is all 0 */
-		if (memcmp(mvMacAddr[1], zero_mac, MV_MAC_ADDR_SIZE) == 0)
-			mac_str = CONFIG_MV_ETH_1_MACADDR;
-		else
-			memcpy(mac_addr, mvMacAddr[1], MV_MAC_ADDR_SIZE);
+	int port = pdev->id;
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
 
-		break;
-#endif /* CONFIG_MV_ETH_PORTS_NUM > 1 */
-
-#if (CONFIG_MV_ETH_PORTS_NUM > 2)
-	case 2:
-		if (mvMtu[2] != 0)
-			mtu = mvMtu[2];
-		else
-			mtu = CONFIG_MV_ETH_2_MTU;
+	if (!mv_eth_initialized) {
+		if (mv_eth_shared_probe(plat_data))
+			return -ENODEV;
+	}
+	mvNetaPortPowerUp(port, plat_data->is_sgmii, plat_data->is_rgmii);
+	mv_eth_win_init(port);
 
-		/* use default MAC address from Kconfig only if the MAC address we got is all 0 */
-		if (memcmp(mvMacAddr[2], zero_mac, MV_MAC_ADDR_SIZE) == 0)
-			mac_str = CONFIG_MV_ETH_2_MACADDR;
-		else
-			memcpy(mac_addr, mvMacAddr[2], MV_MAC_ADDR_SIZE);
-		break;
-#endif /* CONFIG_MV_ETH_PORTS_NUM > 2 */
+	if (mv_eth_load_network_interfaces(pdev))
+		return -ENODEV;
 
-#if (CONFIG_MV_ETH_PORTS_NUM > 3)
-	case 3:
-		if (mvMtu[3] != 0)
-			mtu = mvMtu[3];
-		else
-			mtu = CONFIG_MV_ETH_3_MTU;
+	printk(KERN_ERR "\n");
 
-		/* use default MAC address from Kconfig only if the MAC address we got is all 0 */
-		if (memcmp(mvMacAddr[3], zero_mac, MV_MAC_ADDR_SIZE) == 0)
-			mac_str = CONFIG_MV_ETH_3_MACADDR;
-		else
-			memcpy(mac_addr, mvMacAddr[3], MV_MAC_ADDR_SIZE);
+	return 0;
+}
 
-		break;
-#endif /* CONFIG_MV_ETH_PORTS_NUM > 3 */
+static int mv_eth_config_get(struct platform_device *pdev, MV_U8 *mac_addr)
+{
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
 
-	default:
-		printk(KERN_ERR "eth_get_config: Unexpected port number %d\n", pp->port);
-		return MV_ERROR;
-	}
-	if ((mac_str != NULL) && (mac_addr != NULL))
-		mvMacStrToHex(mac_str, mac_addr);
+	if (mac_addr)
+		memcpy(mac_addr, plat_data->mac_addr, MV_MAC_ADDR_SIZE);
 
-	return mtu;
+	return plat_data->mtu;
 }
 
 /***********************************************************
@@ -3976,7 +3959,7 @@ int mv_eth_hal_init(struct eth_port *pp)
 		int phyAddr;
 
 		/* Set the board information regarding PHY address */
-		phyAddr = mvBoardPhyAddrGet(pp->port);
+		phyAddr = pp->plat_data->phy_addr;
 		mvNetaPhyAddrSet(pp->port, phyAddr);
 	}
 
@@ -4290,7 +4273,7 @@ void mv_eth_napi_group_show(int port)
 		printk(KERN_INFO "group=%d:\n", group);
 		for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
 			cpuCtrl = pp->cpu_config[cpu];
-			if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))
+			if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))
 				continue;
 			if (cpuCtrl->napiCpuGroup == group) {
 				printk(KERN_INFO "   CPU%d ", cpu);
@@ -4579,7 +4562,6 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	struct cpu_ctrl	*cpuCtrl;
 	int rxq, txp, txq, num, err = 0;
 	int pkt_size = RX_PKT_SIZE(mtu);
-	MV_BOARD_MAC_SPEED mac_speed;
 
 	if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
 		STAT_ERR(pp->stats.state_err++);
@@ -4598,7 +4580,7 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	if (mv_eth_ctrl_is_tx_enabled(pp)) {
 		int cpu;
 		for_each_possible_cpu(cpu) {
-			if (!(MV_BIT_CHECK(pp->cpuMask, cpu)))
+			if (!(MV_BIT_CHECK(pp->cpu_mask, cpu)))
 				continue;
 
 			cpuCtrl = pp->cpu_config[cpu];
@@ -4746,32 +4728,6 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	mvNetaHwfEnable(pp->port, 1);
 #endif /* CONFIG_MV_ETH_HWF */
 
-	if (!MV_PON_PORT(pp->port)) {
-		/* force link, speed and duplex if necessary (e.g. Switch is connected) based on board information */
-		mac_speed = mvBoardMacSpeedGet(pp->port);
-		switch (mac_speed) {
-		case BOARD_MAC_SPEED_10M:
-			err = mv_force_port_link_speed_fc(pp->port, MV_ETH_SPEED_10, 1);
-			if (err)
-				goto out;
-			break;
-		case BOARD_MAC_SPEED_100M:
-			err = mv_force_port_link_speed_fc(pp->port, MV_ETH_SPEED_100, 1);
-			if (err)
-				goto out;
-			break;
-		case BOARD_MAC_SPEED_1000M:
-			err = mv_force_port_link_speed_fc(pp->port, MV_ETH_SPEED_1000, 1);
-			if (err)
-				goto out;
-			break;
-		case BOARD_MAC_SPEED_AUTO:
-		default:
-			/* do nothing */
-			break;
-		}
-	}
-
 	/* start the hal - rx/tx activity */
 	status = mvNetaPortEnable(pp->port);
 	if (status == MV_OK)
@@ -4902,7 +4858,7 @@ int mv_eth_stop_internals(struct eth_port *pp)
 		int cpu;
 		for_each_possible_cpu(cpu) {
 			cpuCtrl = pp->cpu_config[cpu];
-			if (MV_BIT_CHECK(pp->cpuMask, cpu))
+			if (MV_BIT_CHECK(pp->cpu_mask, cpu))
 				if (MV_BIT_CHECK(cpuCtrl->cpuTxqMask, cpuCtrl->txq))
 					mv_eth_ctrl_txq_cpu_own(pp->port, pp->txp, cpuCtrl->txq, 0, cpu);
 		}
@@ -5269,8 +5225,8 @@ int mv_eth_txq_tos_map_set(int port, int txq, int cpu, unsigned int tos)
 		return -EINVAL;
 	}
 
-	if (!(MV_BIT_CHECK(pp->cpuMask, cpu))) {
-		printk(KERN_ERR "%s:Error, cpu #%d is masked \n", __func__, cpu);
+	if (!(MV_BIT_CHECK(pp->cpu_mask, cpu))) {
+		printk(KERN_ERR "%s: Error, cpu #%d is masked\n", __func__, cpu);
 		return -EINVAL;
 	}
 	if ((tos > 0xFF) || (tos < 0)) {
@@ -5317,8 +5273,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	struct cpu_ctrl	*cpuCtrl;
 	u8	*ext_buf;
 
-	memset(pp, 0, sizeof(struct eth_port));
-
 	/* Default field per cpu initialization */
 	for (i = 0; i < CONFIG_NR_CPUS; i++) {
 		pp->cpu_config[i] = kmalloc(sizeof(struct cpu_ctrl), GFP_KERNEL);
@@ -5643,7 +5597,7 @@ void mv_eth_port_status_print(unsigned int port)
 		int cpu;
 		for_each_possible_cpu(cpu) {
 			cpuCtrl = pp->cpu_config[cpu];
-			if (MV_BIT_CHECK(pp->cpuMask, cpu))
+			if (cpuCtrl != NULL)
 				printk(KERN_ERR "  %d:   %d   0x%08x   %d    0x%02x    0x%02x    0x%02x    %d\n",
 					cpu, cpuCtrl->txq, cpuCtrl->causeRxTx, test_bit(NAPI_STATE_SCHED, &cpuCtrl->napi->state),
 					cpuCtrl->cpuTxqMask, cpuCtrl->cpuTxqOwner,
@@ -6238,15 +6192,29 @@ int mv_eth_resume(struct platform_device *pdev)
 
 #endif	/*CONFIG_CPU_IDLE*/
 
+static int mv_eth_shared_remove(void)
+{
+	mv_eth_sysfs_exit();
+	return 0;
+}
+
 static int mv_eth_remove(struct platform_device *pdev)
 {
-	printk(KERN_INFO "Removing Marvell Ethernet Driver\n");
-	return MV_OK;
+	int port = pdev->id;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	printk(KERN_INFO "Removing Marvell Ethernet Driver - port #%d\n", port);
+	if (pp == NULL)
+		printk(KERN_ERR "Not Found\n");
+
+	mv_eth_priv_cleanup(pp);
+
+	return 0;
 }
 
 static void mv_eth_shutdown(struct platform_device *pdev)
 {
-    printk(KERN_INFO "Shutting Down Marvell Ethernet Driver\n");
+	printk(KERN_INFO "Shutting Down Marvell Ethernet Driver\n");
 }
 
 static struct platform_driver mv_eth_driver = {
@@ -6258,21 +6226,24 @@ static struct platform_driver mv_eth_driver = {
 	.resume = mv_eth_resume,
 #endif /* CONFIG_CPU_IDLE */
 	.driver = {
-		.name = "mv88fx_neta",
+		.name = MV_NETA_PORT_NAME,
 	},
 };
 
 static int __init mv_eth_init_module(void)
 {
-	return platform_driver_register(&mv_eth_driver);
+	int err = platform_driver_register(&mv_eth_driver);
+
+	return err;
 }
 module_init(mv_eth_init_module);
 
-static void __exit mv_eth_cleanup_module(void)
+static void __exit mv_eth_exit_module(void)
 {
 	platform_driver_unregister(&mv_eth_driver);
+	mv_eth_shared_remove();
 }
-module_exit(mv_eth_cleanup_module);
+module_exit(mv_eth_exit_module);
 
 
 MODULE_DESCRIPTION("Marvell Ethernet Driver - www.marvell.com");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 7ca79c1..6bc1ff2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -42,6 +42,7 @@ disclaimer.
 #include "bm/mvBmRegs.h"
 #include "bm/mvBm.h"
 
+#define MV_ETH_MAX_NETDEV_NUM	24
 
 /******************************************************
  * driver statistics control --                       *
@@ -355,6 +356,7 @@ struct cpu_ctrl {
 
 struct eth_port {
 	int                 port;
+	struct mv_neta_pdata *plat_data;
 	MV_NETA_PORT_CTRL   *port_ctrl;
 	struct rx_queue     *rxq_ctrl;
 	struct tx_queue     *txq_ctrl;
@@ -406,11 +408,12 @@ struct eth_port {
 	int     (*tx_special_check)(int port, struct net_device *dev, struct sk_buff *skb,
 					struct mv_eth_tx_spec *tx_spec_out);
 #endif /* CONFIG_MV_ETH_TX_SPECIAL */
-	MV_U32 cpuMask;
-	MV_U32 rx_indir_table[256];
-	struct cpu_ctrl	*cpu_config[CONFIG_NR_CPUS];
-	MV_U32  sgmii_serdes;
-	int	wol_mode;
+
+	MV_U32              cpu_mask;
+	MV_U32              rx_indir_table[256];
+	struct cpu_ctrl	    *cpu_config[CONFIG_NR_CPUS];
+	MV_U32              sgmii_serdes;
+	int	                wol_mode;
 };
 
 struct eth_netdev {
@@ -729,6 +732,8 @@ int     mv_eth_switch_port_del(struct net_device *dev, int port);
 /******************************************************
  * Function prototypes --                             *
  ******************************************************/
+int         mv_eth_sysfs_init(void);
+int         mv_eth_sysfs_exit(void);
 int         mv_eth_stop(struct net_device *dev);
 int         mv_eth_change_mtu(struct net_device *dev, int mtu);
 int         mv_eth_check_mtu_internals(struct net_device *dev, int mtu);
@@ -758,6 +763,7 @@ int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
 
 int         mv_eth_rx_reset(int port);
 int         mv_eth_txp_reset(int port, int txp);
+int         mv_eth_txq_clean(int port, int txp, int txq);
 
 MV_STATUS   mv_eth_rx_pkts_coal_set(int port, int rxq, MV_U32 value);
 MV_STATUS   mv_eth_rx_time_coal_set(int port, int rxq, MV_U32 value);
@@ -782,6 +788,7 @@ void        mv_eth_netdev_print(struct net_device *netdev);
 void        mv_eth_status_print(void);
 void        mv_eth_port_status_print(unsigned int port);
 void        mv_eth_port_stats_print(unsigned int port);
+void        mv_eth_pool_status_print(int pool);
 
 void        mv_eth_set_noqueue(struct net_device *dev, int enable);
 
diff --git a/include/linux/mv_neta.h b/include/linux/mv_neta.h
index b5f2391..bd2fdb7 100644
--- a/include/linux/mv_neta.h
+++ b/include/linux/mv_neta.h
@@ -66,9 +66,50 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef LINUX_MV_NETA_H
 #define LINUX_MV_NETA_H
 
-struct netaSmpGroupStruct {
-	MV_U32 portMask;
-	MV_U32 cpuMask;
+#define MV_NETA_PORT_NAME	"mv_neta_port"
+struct mv_neta_pdata {
+	/* Global parameters common for all ports */
+	unsigned int  tclk;
+	unsigned int  pclk;
+	int           max_port;
+	int           max_cpu;
+	unsigned int  ctrl_model;
+	unsigned int  ctrl_rev;
+
+	/* Per port parameters */
+	unsigned int  cpu_mask;
+	int           mtu;
+
+	/* Whether a PHY is present, and if yes, at which address. */
+	int      phy_addr;
+
+	/* Use this MAC address if it is valid */
+	u8       mac_addr[6];
+
+	/*
+	* If speed is 0, autonegotiation is enabled.
+	*   Valid values for speed: 0, SPEED_10, SPEED_100, SPEED_1000.
+	*   Valid values for duplex: DUPLEX_HALF, DUPLEX_FULL.
+	*/
+	int      speed;
+	int      duplex;
+
+	/* Port configuration: indicates if this port is LB, and if PCS block is active */
+	int	     lb_enable;
+	int	     is_sgmii;
+	int	     is_rgmii;
+
+	/*
+	* How many RX/TX queues to use.
+	*/
+	int      rx_queue_count;
+	int      tx_queue_count;
+
+	/*
+	* Override default RX/TX queue sizes if nonzero.
+	*/
+	int      rx_queue_size;
+	int      tx_queue_size;
 };
 
 
-- 
1.7.5.4

