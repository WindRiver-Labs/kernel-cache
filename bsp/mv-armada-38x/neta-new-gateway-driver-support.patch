From 7ac20ec42aab03de3b5402dbf08134af65a3d788 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Tue, 8 Oct 2013 17:08:04 +0200
Subject: [PATCH 1016/1825] neta: new gateway driver support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f14ed8f47f689a6e4b8eb635e40b0471de71d519

	- Remove old gateway driver
	- Add mux driver support
	- Support 3 preset modes (transparent, single, per_port)
	- Support link switch event only in polling mode
	- Use global tag type instead neta tag type

Change-Id: If0ae9c3f224566598de7b1edb733f34c6c10cfdc
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada370/Makefile                   |    1 +
 arch/arm/mach-armada370/config/mvRules.mk          |    1 +
 arch/arm/mach-armada370/core.c                     |  119 +++-
 arch/arm/mach-armadaxp/Makefile                    |    1 +
 arch/arm/mach-armadaxp/config/mvRules.mk           |    1 +
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |    8 +
 .../arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig |   42 -
 .../plat-armada/mv_drivers_lsp/mv_neta/Makefile    |    4 -
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c |  789 --------------------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c   |    8 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c   |   17 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |  481 ++++---------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |   62 +--
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |    2 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   18 +-
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |   82 ++-
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |    3 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     |   10 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |   10 +-
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c     |   10 +-
 20 files changed, 377 insertions(+), 1292 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c

diff --git a/arch/arm/mach-armada370/Makefile b/arch/arm/mach-armada370/Makefile
index ab960ce..81f8391 100644
--- a/arch/arm/mach-armada370/Makefile
+++ b/arch/arm/mach-armada370/Makefile
@@ -94,6 +94,7 @@ armada370-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
 armada370-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
 
 obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
+obj-y					+= $(LSP_MUX_DIR)/
 
 # drivers part
 
diff --git a/arch/arm/mach-armada370/config/mvRules.mk b/arch/arm/mach-armada370/config/mvRules.mk
index 19e8f36..9880937 100644
--- a/arch/arm/mach-armada370/config/mvRules.mk
+++ b/arch/arm/mach-armada370/config/mvRules.mk
@@ -98,6 +98,7 @@ endif
 LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
 LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
 LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
 
 # Environment components
diff --git a/arch/arm/mach-armada370/core.c b/arch/arm/mach-armada370/core.c
index 7ffc497..75d9452 100644
--- a/arch/arm/mach-armada370/core.c
+++ b/arch/arm/mach-armada370/core.c
@@ -61,7 +61,9 @@
 #include "gpp/mvGpp.h"
 #include "plat/gpio.h"
 #include "cpu/mvCpu.h"
-
+#if defined(CONFIG_MV_INCLUDE_SWITCH)
+#include <linux/mv_switch.h>
+#endif
 #if defined(CONFIG_MV_INCLUDE_SDIO)
 #include "sdmmc/mvSdmmc.h"
 #include <plat/mvsdio.h>
@@ -699,6 +701,116 @@ static struct platform_device mv_neta_ge1_plat = {
 };
 #endif /* CONFIG_MV_ETH_NETA || CONFIG_MV_ETH_NETA_MODULE */
 
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+char *mv_switch_str;
+
+static int mv_switch_cmdline_config(char *s)
+{
+	mv_switch_str = s;
+	return 1;
+}
+__setup("switch_config=", mv_switch_cmdline_config);
+
+static void mv_switch_parse_cmd_line(char *str, MV_SWITCH_PRESET_TYPE *preset, MV_TAG_TYPE *tag_mode)
+{
+	int len, curr = 0;
+
+	/* default values */
+	*preset = MV_PRESET_TRANSPARENT;
+	*tag_mode = MV_TAG_TYPE_NONE;
+
+	if (!str || !strcmp(str, "none"))
+		return;
+
+	len = strlen(str);
+
+	/* Parse tag mode */
+	if ((len >= 2) && (((str[curr] == 'm') && (str[curr + 1] == 'h')) ||
+		((str[curr] == 'M') && (str[curr + 1] == 'H')))) {
+			*tag_mode = MV_TAG_TYPE_MH;
+			curr += 2;
+	} else if ((len >= 3) && (((str[curr] == 'd') && (str[curr + 1] == 's') && (str[curr + 2] == 'a'))
+			|| ((str[curr] == 'D') && (str[curr + 1] == 'S') && (str[curr + 2] == 'A')))) {
+		*tag_mode = MV_TAG_TYPE_DSA;
+		curr += 3;
+	} else
+		return;
+
+	if (str[curr++] != ',')
+		return;
+
+	/* Parse preset mode */
+	if (!strcmp(str + curr, "per_port"))
+		*preset = MV_PRESET_PER_PORT_VLAN;
+	else if (!strcmp(str + curr, "single"))
+		*preset = MV_PRESET_SINGLE_VLAN;
+}
+
+static void mv_switch_pdev_register(struct platform_device *pdev)
+{
+	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
+
+	/* check if switch is connected to GBE port */
+	if (mvBoardSwitchConnectedPortGet(0) != -1)
+		plat_data->gbe_port = 0;
+	else if (mvBoardSwitchConnectedPortGet(1) != -1)
+		plat_data->gbe_port = 1;
+	else
+		return;
+
+	/* get board configuration */
+	plat_data->phy_addr = mvBoardPhyAddrGet(plat_data->gbe_port);
+	plat_data->switch_cpu_port = mvBoardSwitchCpuPortGet(plat_data->index);
+	plat_data->smi_scan_mode = mvBoardSmiScanModeGet(plat_data->index);
+	plat_data->connected_port_mask = 0xf | (1 << plat_data->switch_cpu_port);
+	/*plat_data->connected_port_mask = mvBoardSwitchPortsMaskGet(0);*/
+	plat_data->forced_link_port_mask = 0x20;/*mvBoardSwitchPortForceLinkGet(0);*/
+	plat_data->switch_irq = -1;/*use polling, mvBoardSwitchIrqGet();*/
+	/* parse switch command line parametes (preset and tag mode) */
+	mv_switch_parse_cmd_line(mv_switch_str, &plat_data->preset, &plat_data->tag_mode);
+
+	platform_device_register(pdev);
+}
+
+static struct resource mv_switch0_resources[] = {
+	{
+		.start          = 0,
+		.end            = 0,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_switch_pdata mv_switch0_plat_data = {
+	.index = 0,
+	.phy_addr = -1,
+	.gbe_port = 0,
+	.gephy_on_port = -1,
+	.switch_cpu_port = 5,
+	.tag_mode = MV_TAG_TYPE_MH,
+	.preset = MV_PRESET_PER_PORT_VLAN,
+	.vid = 0,
+	.port_mask = 0x7f,
+	.connected_port_mask = 0x2f,
+	.mtu = 1500,
+	.is_speed_2000 = 0,
+};
+
+static struct platform_device mv_switch0_plat_dev = {
+	.name           = MV_SWITCH_SOHO_NAME,
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(mv_switch0_resources),
+	.resource       = mv_switch0_resources,
+	.dev            = {
+		.platform_data = &mv_switch0_plat_data,
+	},
+};
+
+static void __init switch_init(void)
+{
+	mv_switch_pdev_register(&mv_switch0_plat_dev);
+}
+#endif /* CONFIG_MV_INCLUDE_SWITCH */
+
 static void __init eth_init(void)
 {
 #if defined(CONFIG_MV_ETH_LEGACY)
@@ -709,6 +821,11 @@ static void __init eth_init(void)
 	mv_neta_giga_pdev_register(&mv_neta_ge0_plat);
 	mv_neta_giga_pdev_register(&mv_neta_ge1_plat);
 #endif /* CONFIG_MV_ETH_NETA) || CONFIG_MV_ETH_NETA_MODULE */
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	switch_init();
+#endif /* CONFIG_MV_INCLUDE_SWITCH */
+
 }
 #endif /* CONFIG_MV_ETHERNET */
 
diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index d7126de..f9a744d 100755
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -110,6 +110,7 @@ obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
+obj-y                                   += $(LSP_MUX_DIR)/
 obj-$(CONFIG_SENSORS_ARMADA)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
 
diff --git a/arch/arm/mach-armadaxp/config/mvRules.mk b/arch/arm/mach-armadaxp/config/mvRules.mk
index c409d0c..0b607c7 100644
--- a/arch/arm/mach-armadaxp/config/mvRules.mk
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -98,6 +98,7 @@ endif
 LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
 LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
 LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
 LSP_IPC_DIR       = $(PLAT_DRIVERS)/mv_ipc/linux_amp
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index 1cccb41..ed3e963 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -203,6 +203,7 @@ void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops
 		/* switch already attached */
 		mv_mux_mgr_probe(port);
 }
+EXPORT_SYMBOL(mv_mux_eth_attach);
 
 void mv_mux_eth_detach(int port)
 {
@@ -216,6 +217,7 @@ void mv_mux_eth_detach(int port)
 	/* clear port data */
 	memset(&mux_eth_shadow[port], 0, sizeof(struct mv_mux_eth_port));
 }
+EXPORT_SYMBOL(mv_mux_eth_detach);
 /*-----------------------------------------------------------------------------------------*/
 
 int mv_mux_netdev_find(unsigned int dev_idx)
@@ -307,6 +309,7 @@ out:
 	kfree_skb(skb);
 	return 0;
 }
+EXPORT_SYMBOL(mv_mux_rx);
 
 /*-----------------------------------------------------------------------------------------*/
 
@@ -467,6 +470,8 @@ static int mv_mux_set_mac(struct net_device *dev, void *addr)
 
 	mv_mux_close(dev);
 
+	/*TODO: update parser/PNC - mac filtering*/
+
 #ifdef CONFIG_MV_INCLUDE_SWITCH
 	if (mux_switch_shadow.attach) {
 		struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
@@ -1378,6 +1383,8 @@ void mv_mux_netdev_print(struct net_device *mux_dev)
 		printk(KERN_ERR "%s: Error, Unknown tag type\n", __func__);
 	}
 }
+EXPORT_SYMBOL(mv_mux_netdev_print);
+
 /*--------------------------------------------------------------------------------------*/
 /* Print all port's mux devices data							*/
 /*--------------------------------------------------------------------------------------*/
@@ -1400,6 +1407,7 @@ void mv_mux_netdev_print_all(int port)
 		printk(KERN_CONT "\n");
 	}
 }
+EXPORT_SYMBOL(mv_mux_netdev_print_all);
 /*-----------------------------------------------------------------------------------------*/
 int mv_mux_ctrl_dbg_flag(int port, u32 flag, u32 val)
 {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
index edbb853..8066885 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Kconfig
@@ -819,48 +819,6 @@ config MV_PON_TXQ_DEF
 
 endmenu
 
-menu "Switch support"
-
-config MV_ETH_SWITCH
-        bool "Switch support"
-	depends on MV_INCLUDE_SWITCH
-        ---help---
-	Choose this option to support Gigabit Ethernet Controller connected to
-        on-board QuarterDeck switch family
-
-config  MV_ETH_SWITCH_NETDEV_NUM
-	int "Maximum number of subnets on switch ports"
-	depends on MV_ETH_SWITCH
-	default 4
-	---help---
-	Valid range range from 1 to BOARD_ETH_SWITCH_PORT_NUM
-
-config  MV_ETH_SWITCH_NETCONFIG_0
-	string "Switch network configuration for GbE port 0"
-	depends on MV_ETH_SWITCH
-	default "3,(00:11:66:11:66:11,0)(00:22:77:22:77:22,1:2:3:4),mtu=1500"
-	---help---
-	 Set the network configuration when giga port connected to switch.
-         For each interface, define the interface
-	 name, MAC address and participating ports.
-
-config  MV_ETH_SWITCH_NETCONFIG_1
-	string "Switch network configuration for GbE port 1"
-	depends on MV_ETH_SWITCH
-	default "0"
-	---help---
-	 Set the network configuration when giga port connected to switch.
-         For each interface, define the interface
-	 name, MAC address and participating ports.
-
-config  MV_ETH_SWITCH_LINK
-	bool "Link status change indications"
-	depends on MV_ETH_SWITCH
-	default y
-	---help---
-	  Support Phy link status change indications.
-endmenu
-
 menu "ERRATA / WA"
 
 config MV_ETH_ERRATA_SMI_ACCESS
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
index facb14e..3175bd1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
@@ -63,8 +63,4 @@ ifeq ($(CONFIG_MV_PON),y)
 mv_neta-objs += mv_pon_sysfs.o
 endif
 
-ifeq ($(CONFIG_MV_ETH_SWITCH),y)
-mv_neta-objs += net_dev/mv_eth_switch.o
-endif
-
 obj-$(CONFIG_MV_ETH_NETA) += mv_neta.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
deleted file mode 100644
index c811da4..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
+++ /dev/null
@@ -1,789 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-
-#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/pci.h>
-#include <linux/ip.h>
-#include <linux/in.h>
-#include <linux/tcp.h>
-#include <linux/version.h>
-#include <net/ip.h>
-#include <net/xfrm.h>
-
-#include "mvOs.h"
-#include "dbg-trace.h"
-#include "mvSysHwConfig.h"
-#include "boardEnv/mvBoardEnvLib.h"
-#ifdef MV_INCLUDE_ETH_COMPLEX
-#include "ctrlEnv/mvCtrlEthCompLib.h"
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-#include "gbe/mvNeta.h"
-
-#include "mv_switch.h"
-#include "mv_netdev.h"
-
-extern int mv_net_devs_num;
-
-/* Example: "mv_net_config=4,(00:99:88:88:99:77,0)(00:55:44:55:66:77,1:2:3:4)(00:11:22:33:44:55,),mtu=1500" */
-static char			*net_config_str[CONFIG_MV_ETH_PORTS_NUM] = {NULL};
-struct mv_eth_switch_config     switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
-
-static int                      mv_eth_switch_started = 0;
-unsigned int                    switch_enabled_ports = 0;
-
-/* Required to get the configuration string from the Kernel Command Line */
-int mv_eth0_cmdline_config(char *s);
-__setup("mv_net_config=", mv_eth0_cmdline_config);
-
-int mv_eth0_cmdline_config(char *s)
-{
-	net_config_str[MV_ETH_PORT_0] = s;
-	return 1;
-}
-
-int mv_eth1_cmdline_config(char *s);
-__setup("mv_net_config1=", mv_eth1_cmdline_config);
-
-int mv_eth1_cmdline_config(char *s)
-{
-	net_config_str[MV_ETH_PORT_1] = s;
-	return 1;
-}
-
-
-/* Local function prototypes */
-static int mv_eth_check_open_bracket(char **p_net_config)
-{
-	if (**p_net_config == '(') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find opening bracket\n");
-	return -EINVAL;
-}
-
-static int mv_eth_check_closing_bracket(char **p_net_config)
-{
-	if (**p_net_config == ')') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find closing bracket\n");
-	return -EINVAL;
-}
-
-static int mv_eth_check_comma(char **p_net_config)
-{
-	if (**p_net_config == ',') {
-		(*p_net_config)++;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error: could not find comma\n");
-	return -EINVAL;
-}
-
-static int mv_eth_netconfig_mac_addr_get(char **p_net_config, int idx, int port)
-{
-	int     num;
-	char *config_str = *p_net_config;
-	MV_U32  mac[MV_MAC_ADDR_SIZE];
-
-	/* the MAC address should look like: 00:99:88:88:99:77 */
-	/* that is, 6 two-digit numbers, separated by :        */
-	num = sscanf(config_str, "%2x:%2x:%2x:%2x:%2x:%2x",
-		&mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
-	if (num == MV_MAC_ADDR_SIZE) {
-		while (--num >= 0)
-			switch_net_config[port].mac_addr[idx][num] = (mac[num] & 0xFF);
-
-		(*p_net_config) = config_str + 17;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing MAC address from command line\n");
-	return -EINVAL;
-}
-
-static int mv_eth_netconfig_ports_get(char **p_net_config, int idx, int port)
-{
-	char ch;
-	char *config_str = *p_net_config;
-	int  sw_port, mask = 0, status = -EINVAL;
-
-	/* the switch port list should look like this: */
-	/* example 0: )         - no ports */
-	/* example 1: 0)        - single port 0 */
-	/* example 2: 1:2:3:4)  - multiple ports */
-
-	while (1) {
-		ch = *config_str++;
-
-		if (ch == ')') {
-			/* Finished */
-			status = 0;
-			break;
-		}
-		sw_port = mvCharToDigit(ch);
-		if (sw_port < 0)
-			break;
-
-		/* TBD - Check sw_port validity */
-		mask |= (1 << sw_port);
-
-		if (*config_str == ':')
-			config_str++;
-	}
-	*p_net_config = config_str;
-
-	if (status == 0) {
-		switch_net_config[port].board_port_map[idx] = mask;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing switch port mask from command line\n");
-	return -EINVAL;
-}
-
-/* the mtu value is constructed as follows: */
-/* mtu=value                                */
-static int  mv_eth_netconfig_mtu_get(char **p_net_config, int port)
-{
-	unsigned int mtu;
-
-	if (strncmp(*p_net_config, "mtu=", 4) == 0) {
-		*p_net_config += 4;
-		mtu = strtol(*p_net_config, p_net_config, 10);
-		if (mtu > 0) {
-			switch_net_config[port].mtu = mtu;
-			printk(KERN_ERR "      o MTU set to %d.\n", mtu);
-			return 0;
-		}
-		printk(KERN_ERR "Syntax error while parsing mtu value from command line\n");
-		return -EINVAL;
-	}
-
-	switch_net_config[port].mtu = 1500;
-	printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
-	return 0;
-}
-
-static int mv_eth_netconfig_max_get(char **p_net_config, int port)
-{
-	char num = **p_net_config;
-	int netdev_num;
-
-	netdev_num = mvCharToDigit(num);
-	if (netdev_num >= 0) {
-		switch_net_config[port].netdev_max = netdev_num;
-		(*p_net_config) += 1;
-		return 0;
-	}
-	printk(KERN_ERR "Syntax error while parsing number of netdevs from command line\n");
-	return -EINVAL;
-}
-
-int mv_eth_switch_config_get(int use_existing_config, int port)
-{
-	char *p_net_config;
-	int i = 0;
-
-	if ((port != MV_ETH_PORT_0) && (port != MV_ETH_PORT_1))	{
-		printk(KERN_ERR "%s: invalid port number %d\n", __func__, port);
-		return -EINVAL;
-	}
-
-	if (!use_existing_config) {
-		memset(&(switch_net_config[port]), 0, sizeof((switch_net_config[port])));
-
-		if (net_config_str[port] != NULL) {
-			printk(KERN_ERR "      o Using UBoot netconfig string for port %d\n", port);
-		} else {
-			printk(KERN_ERR "      o Using default netconfig string from Kconfig for port %d\n", port);
-			if (port == MV_ETH_PORT_0)
-				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_0;
-			else if (port == MV_ETH_PORT_1)
-				net_config_str[port] = CONFIG_MV_ETH_SWITCH_NETCONFIG_1;
-		}
-		printk(KERN_ERR "        net_config_str[%d]: %s\n", port, net_config_str[port]);
-
-		p_net_config = net_config_str[port];
-		if (mv_eth_netconfig_max_get(&p_net_config, port))
-			return -EINVAL;
-
-		/* check restriction: at least one of the configuration strings must be 0 */
-		if ((net_config_str[MV_ETH_PORT_0] != NULL) &&
-		    (net_config_str[MV_ETH_PORT_1] != NULL) &&
-		    (switch_net_config[MV_ETH_PORT_0].netdev_max != 0) &&
-		    (switch_net_config[MV_ETH_PORT_1].netdev_max != 0)) {
-			printk(KERN_ERR "%s: cannot have both GbE ports using the Gateway driver, change mv_net_config\n", __func__);
-			return -EINVAL;
-		}
-
-		if (switch_net_config[port].netdev_max == 0)
-			return 1;
-
-		if (switch_net_config[port].netdev_max > CONFIG_MV_ETH_SWITCH_NETDEV_NUM) {
-			printk(KERN_ERR "Too large number of netdevs (%d) in command line: cut to %d\n",
-				switch_net_config[port].netdev_max, CONFIG_MV_ETH_SWITCH_NETDEV_NUM);
-			switch_net_config[port].netdev_max = CONFIG_MV_ETH_SWITCH_NETDEV_NUM;
-		}
-
-		if (mv_eth_check_comma(&p_net_config))
-			return -EINVAL;
-
-		for (i = 0; (i < CONFIG_MV_ETH_SWITCH_NETDEV_NUM) && (*p_net_config != '\0'); i++) {
-			if (mv_eth_check_open_bracket(&p_net_config))
-				return -EINVAL;
-
-			if (mv_eth_netconfig_mac_addr_get(&p_net_config, i, port))
-				return -EINVAL;
-
-			if (mv_eth_check_comma(&p_net_config))
-				return -EINVAL;
-
-			if (mv_eth_netconfig_ports_get(&p_net_config, i, port))
-				return -EINVAL;
-
-			switch_net_config[port].netdev_cfg++;
-
-			/* If we have a comma after the closing bracket, then interface */
-			/* definition is done.                                          */
-			if (*p_net_config == ',') {
-				p_net_config++;
-				break;
-			}
-		}
-
-		/* there is a chance the previous loop did not end because a comma was found but because	*/
-		/* the maximum number of interfaces was reached, so check for the comma now.		*/
-		if (i == CONFIG_MV_ETH_SWITCH_NETDEV_NUM)
-			if (mv_eth_check_comma(&p_net_config))
-				return -EINVAL;
-
-		if (*p_net_config != '\0') {
-			if (mv_eth_netconfig_mtu_get(&p_net_config, port))
-				return -EINVAL;
-		} else {
-			switch_net_config[port].mtu = 1500;
-			printk(KERN_ERR "      o Using default MTU %d\n", switch_net_config[port].mtu);
-		}
-
-		/* at this point, we have parsed up to CONFIG_MV_ETH_SWITCH_NETDEV_NUM, and the mtu value */
-		/* if the net_config string is not finished yet, then its format is invalid */
-		if (*p_net_config != '\0') {
-			printk(KERN_ERR "Switch netconfig string is too long: %s\n", p_net_config);
-			return -EINVAL;
-		}
-	} else {
-		/* leave most of the configuration as-is, but update MAC addresses */
-		/* MTU is saved in mv_eth_switch_change_mtu */
-
-		/* Note: at this point, since this is a re-init, mv_eth_switch_netdev_first */
-		/* and mv_eth_switch_netdev_last, as well as mv_net_devs[], are valid.      */
-		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-			if (mv_net_devs[i] != NULL)
-				memcpy(switch_net_config[port].mac_addr[i - mv_eth_switch_netdev_first],
-					mv_net_devs[i]->dev_addr, MV_MAC_ADDR_SIZE);
-		}
-
-		if (switch_net_config[port].netdev_max == 0)
-			return 1;
-	}
-
-	return 0;
-}
-
-int    mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct sockaddr *addr = (struct sockaddr *)mac;
-
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EADDRNOTAVAIL;
-
-	/* remove old mac addr from VLAN DB */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 0);
-
-	memcpy(dev->dev_addr, addr->sa_data, MV_MAC_ADDR_SIZE);
-
-	/* add new mac addr to VLAN DB */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 1);
-
-	printk(KERN_ERR "mv_eth_switch: %s change mac address to %02x:%02x:%02x:%02x:%02x:%02x\n",
-		dev->name, *(dev->dev_addr), *(dev->dev_addr+1), *(dev->dev_addr+2),
-		*(dev->dev_addr+3), *(dev->dev_addr+4), *(dev->dev_addr+5));
-
-	return 0;
-}
-
-void    mv_eth_switch_set_multicast_list(struct net_device *dev)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-
-	if (dev->flags & IFF_PROMISC) {
-		/* promiscuous mode - connect the CPU port to the VLAN (port based + 802.1q) */
-		/* printk(KERN_ERR "mv_eth_switch: setting promiscuous mode\n"); */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 1))
-			printk(KERN_ERR "mv_switch_promisc_set to 1 failed\n");
-	} else {
-		/* not in promiscuous mode - disconnect the CPU port to the VLAN (port based + 802.1q) */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 0))
-			printk(KERN_ERR "mv_switch_promisc_set to 0 failed\n");
-
-		if (dev->flags & IFF_ALLMULTI) {
-			/* allmulticast - not supported. There is no way to tell the Switch to accept only	*/
-			/* the multicast addresses but not Unicast addresses, so the alternatives are:	*/
-			/* 1) Don't support multicast and do nothing					*/
-			/* 2) Support multicast with same implementation as promiscuous			*/
-			/* 3) Don't rely on Switch for MAC filtering, but use PnC			*/
-			/* Currently option 1 is selected						*/
-			printk(KERN_ERR "mv_eth_switch: setting all-multicast mode is not supported\n");
-		}
-
-		/* Add or delete specific multicast addresses:						*/
-		/* Linux provides a list of the current multicast addresses for the device.		*/
-		/* First, we delete all the multicast addresses in the ATU.				*/
-		/* Then we add the specific multicast addresses Linux provides.				*/
-		if (mv_switch_all_multicasts_del(MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id)))
-			printk(KERN_ERR "mv_eth_switch: mv_switch_all_multicasts_del failed\n");
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
-		if (!netdev_mc_empty(dev)) {
-			struct netdev_hw_addr *ha;
-
-			netdev_for_each_mc_addr(ha, dev) {
-				mv_switch_mac_addr_set(ha->addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#else
-		{
-			int i;
-			struct dev_mc_list *curr_addr = dev->mc_list;
-
-			/* accept specific multicasts */
-			for (i = 0; i < dev->mc_count; i++, curr_addr = curr_addr->next) {
-				if (!curr_addr)
-					break;
-
-				/*
-				printk(KERN_ERR "Setting MC = %02X:%02X:%02X:%02X:%02X:%02X\n",
-				curr_addr->dmi_addr[0], curr_addr->dmi_addr[1], curr_addr->dmi_addr[2],
-				curr_addr->dmi_addr[3], curr_addr->dmi_addr[4], curr_addr->dmi_addr[5]);
-				*/
-				mv_switch_mac_addr_set(curr_addr->dmi_addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#endif /* KERNEL_VERSION >= 2.6.34 */
-	}
-}
-
-int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu)
-{
-	int i;
-	struct eth_port *priv = MV_ETH_PRIV(dev);
-
-	/* All gateway interfaces must be down before changing MTU */
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (netif_running(mv_net_devs[i]))) {
-			printk(KERN_ERR "All gateway interfaces must be down before changing MTU. %s is not down\n", mv_net_devs[i]->name);
-			return -EPERM;
-		}
-	}
-
-	if (dev->mtu != mtu) {
-		int old_mtu = dev->mtu;
-
-		mtu = mv_eth_check_mtu_valid(dev, mtu);
-		if (mtu < 0)
-			return -EPERM;
-
-		if (mv_eth_change_mtu_internals(dev, mtu))
-			return -EPERM;
-
-		printk(KERN_NOTICE "%s: change mtu %d (pkt-size %d) to %d (pkt-size %d)\n",
-			dev->name, old_mtu, RX_PKT_SIZE(old_mtu),
-			dev->mtu, RX_PKT_SIZE(dev->mtu));
-	}
-
-	if (switch_net_config[priv->port].mtu != mtu) {
-		mv_switch_jumbo_mode_set(RX_PKT_SIZE(mtu));
-		switch_net_config[priv->port].mtu = mtu;
-	}
-
-	return 0;
-}
-
-int    mv_eth_switch_start(struct net_device *dev)
-{
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	unsigned char broadcast[MV_MAC_ADDR_SIZE] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	int i;
-	int group;
-
-	/* Check that MTU value is identical for all gateway interfaces */
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i]->mtu != dev->mtu)) {
-			printk(KERN_ERR "All gateway devices must have same MTU\n");
-			return -EPERM;
-		}
-	}
-
-	/* in default link is down */
-	netif_carrier_off(dev);
-
-	/* Stop the TX queue - it will be enabled upon PHY status change after link-up interrupt/timer */
-	netif_tx_stop_all_queues(dev);
-
-	/* start upper layer accordingly with ports_map */
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-	dev_priv->link_map = 0;
-	mv_switch_link_update_event(dev_priv->port_map, 1);
-#else
-	dev_priv->link_map = dev_priv->port_map;
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
-	if (mv_eth_switch_started == 0)	{
-		/* fill rx buffers, start rx/tx activity, set coalescing */
-		if (mv_eth_start_internals(priv, dev->mtu) != 0) {
-			printk(KERN_ERR "%s: start internals failed\n", dev->name);
-			goto error;
-		}
-
-		/* enable polling on the port, must be used after netif_poll_disable */
-		for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-			napi_enable(priv->napiGroup[group]);
-
-		/* connect to port interrupt line */
-		if (request_irq(dev->irq, mv_eth_isr, IRQF_DISABLED|IRQF_SAMPLE_RANDOM, "mv_eth", priv)) {
-			printk(KERN_ERR "cannot request irq %d for %s port %d\n",
-				dev->irq, dev->name, priv->port);
-			for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-				napi_disable(priv->napiGroup[group]);
-			goto error;
-		}
-
-		/* unmask interrupts */
-		mv_eth_interrupts_unmask(priv);
-		smp_call_function_many(cpu_online_mask, (smp_call_func_t)mv_eth_interrupts_unmask, (void *)priv, 1);
-	}
-
-	mv_eth_switch_started++;
-
-	/* Add our MAC addr to the VLAN DB at switch level to forward packets with this DA   */
-	/* to CPU port by using the tunneling feature. The device is always in promisc mode. */
-	mv_switch_mac_addr_set(dev->dev_addr, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id), (1 << dev_priv->cpu_port), 1);
-
-	/* We also need to allow L2 broadcasts comming up for this interface */
-	mv_switch_mac_addr_set(broadcast, MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-			(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-
-	printk(KERN_ERR "%s: started (on switch)\n", dev->name);
-	return 0;
-
-error:
-	printk(KERN_ERR "%s: start failed\n", dev->name);
-	return -1;
-}
-
-int     mv_eth_switch_stop(struct net_device *dev)
-{
-	struct eth_port *priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct cpu_ctrl *cpuCtrl;
-	int group, cpu;
-
-	/* stop upper layer */
-	netif_carrier_off(dev);
-	netif_tx_stop_all_queues(dev);
-
-	/* stop switch from forwarding packets from this VLAN toward CPU port */
-	mv_switch_atu_db_flush(MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id));
-
-	/* It is possible that the interface is in promiscuous mode */
-	/* If so, the CPU port is connected with port based VLAN to the other ports, and */
-	/* we must disconnect it now to stop the Switch from forwarding packets to the CPU */
-	/* when the interface is down. */
-	/* mv_eth_switch_set_multicast_list will be called anyway by Linux when we do ifconfig up */
-	/* and will re-set the promiscuous feature if needed */
-	if (dev->flags & IFF_PROMISC) {
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 0))
-			printk(KERN_ERR "mv_switch_promisc_set to 0 failed\n");
-	}
-	mv_eth_switch_started--;
-
-	if (mv_eth_switch_started == 0)	{
-		/* first make sure that the port finished its Rx polling - see tg3 */
-		/* otherwise it may cause issue in SMP, one CPU is here and the other is doing the polling */
-		/* and both of it are messing with the descriptors rings!! */
-		for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
-			napi_disable(priv->napiGroup[group]);
-
-		/* stop tx/rx activity, mask all interrupts, relese skb in rings,*/
-		mv_eth_stop_internals(priv);
-		for_each_possible_cpu(cpu) {
-			cpuCtrl = priv->cpu_config[cpu];
-			del_timer(&cpuCtrl->tx_done_timer);
-			clear_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags));
-			del_timer(&cpuCtrl->cleanup_timer);
-			clear_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags));
-		}
-		if (dev->irq != 0)
-			free_irq(dev->irq, priv);
-	}
-	printk(KERN_NOTICE "%s: stopped\n", dev->name);
-
-	return 0;
-}
-
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-
-void mv_eth_switch_interrupt_unmask(int qsgmii_module, int gephy_on_port)
-{
-#ifdef MV_INCLUDE_ETH_COMPLEX
-	MV_U32 reg;
-
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_MASK_REG);
-
-	if (qsgmii_module) {
-		reg |= (MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
-
-	if (gephy_on_port >= 0)
-		reg |= MV_ETHCOMP_GEPHY_INT_MASK;
-
-	reg |= MV_ETHCOMP_SWITCH_INT_MASK;
-
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_MASK_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-}
-
-void mv_eth_switch_interrupt_clear(int qsgmii_module, int gephy_on_port)
-{
-#ifdef MV_INCLUDE_ETH_COMPLEX
-	MV_U32 reg;
-
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_CAUSE_REG);
-
-	if (qsgmii_module) {
-		reg &= ~(MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
-
-	if (gephy_on_port >= 0)
-		reg &= ~MV_ETHCOMP_GEPHY_INT_MASK;
-
-	reg &= ~MV_ETHCOMP_SWITCH_INT_MASK;
-
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_CAUSE_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
-}
-
-void mv_eth_switch_update_link(unsigned int p, unsigned int link_up)
-{
-	struct eth_netdev *dev_priv = NULL;
-	struct eth_port *priv = NULL;
-	int i = 0;
-	unsigned int prev_ports_link = 0;
-
-	for (i = 0; i < mv_net_devs_num; i++) {
-
-		if (mv_net_devs[i] == NULL)
-			break;
-
-		priv = MV_ETH_PRIV(mv_net_devs[i]);
-		if (priv == NULL)
-			break;
-
-		if (!(priv->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)))
-			continue;
-
-		dev_priv = MV_DEV_PRIV(mv_net_devs[i]);
-		if (dev_priv == NULL)
-			break;
-
-		if ((dev_priv->port_map & (1 << p)) == 0)
-			continue;
-
-		prev_ports_link = dev_priv->link_map;
-
-		if (link_up)
-			dev_priv->link_map |= (1 << p);
-		else
-			dev_priv->link_map &= ~(1 << p);
-
-		if ((prev_ports_link != 0) && (dev_priv->link_map == 0) && netif_running(mv_net_devs[i])) {
-			/* link down */
-			netif_carrier_off(mv_net_devs[i]);
-			netif_tx_stop_all_queues(mv_net_devs[i]);
-			printk(KERN_ERR "%s: link down\n", mv_net_devs[i]->name);
-		} else if ((prev_ports_link == 0) && (dev_priv->link_map != 0) && netif_running(mv_net_devs[i])) {
-			/* link up */
-			if (mv_eth_ctrl_is_tx_enabled(priv) == 1) {
-				netif_carrier_on(mv_net_devs[i]);
-				netif_tx_wake_all_queues(mv_net_devs[i]);
-				printk(KERN_ERR "%s: link up\n", mv_net_devs[i]->name);
-			}
-		}
-	}
-}
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
-int     mv_eth_switch_port_add(struct net_device *dev, int port)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	int i, switch_port, err = 0;
-
-	if (dev_priv == NULL) {
-		printk(KERN_ERR "%s is not connected to the switch\n", dev->name);
-		return 1;
-	}
-
-	if (netif_running(dev)) {
-		printk(KERN_ERR "%s must be down to change switch ports map\n", dev->name);
-		return 1;
-	}
-
-	switch_port = mvBoardSwitchPortGet(0, port);
-
-	if (switch_port < 0) {
-		printk(KERN_ERR "Switch port %d can't be added\n", port);
-		return 1;
-	}
-
-	if (MV_BIT_CHECK(switch_enabled_ports, switch_port)) {
-		printk(KERN_ERR "Switch port %d is already enabled\n", port);
-		return 0;
-	}
-
-	/* Update data base */
-	dev_priv->port_map |= (1 << switch_port);
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] |= (1 << switch_port);
-	}
-	switch_enabled_ports |= (1 << switch_port);
-	dev_priv->tx_vlan_mh = cpu_to_be16((MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id) << 12) | dev_priv->port_map);
-
-	err = mv_switch_port_add(switch_port, dev_priv->vlan_grp_id, dev_priv->port_map);
-	if (!err)
-		printk(KERN_ERR "%s: Switch port #%d mapped\n", dev->name, port);
-
-	return err;
-}
-
-int     mv_eth_switch_port_del(struct net_device *dev, int port)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-	struct eth_port	*priv = MV_ETH_PRIV(dev);
-	int i, switch_port, err = 0;
-
-	if (dev_priv == NULL) {
-		printk(KERN_ERR "%s is not connected to the switch\n", dev->name);
-		return 1;
-	}
-
-	if (netif_running(dev)) {
-		printk(KERN_ERR "%s must be down to change switch ports map\n", dev->name);
-		return 1;
-	}
-
-	switch_port = mvBoardSwitchPortGet(0, port);
-
-	if (switch_port < 0) {
-		printk(KERN_ERR "Switch port %d can't be added\n", port);
-		return 1;
-	}
-
-	if (!MV_BIT_CHECK(switch_enabled_ports, switch_port)) {
-		printk(KERN_ERR "Switch port %d is already disabled\n", port);
-		return 0;
-	}
-
-	if (!MV_BIT_CHECK(dev_priv->port_map, switch_port)) {
-		printk(KERN_ERR "Switch port %d is not mapped on %s\n", port, dev->name);
-		return 0;
-	}
-
-	/* Update data base */
-	dev_priv->port_map &= ~(1 << switch_port);
-	for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-		if ((mv_net_devs[i] != NULL) && (mv_net_devs[i] == dev))
-			switch_net_config[priv->port].board_port_map[i - mv_eth_switch_netdev_first] &= ~(1 << switch_port);
-	}
-	dev_priv->link_map &= ~(1 << switch_port);
-	switch_enabled_ports &= ~(1 << switch_port);
-	dev_priv->tx_vlan_mh = cpu_to_be16((MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id) << 12) | dev_priv->port_map);
-
-	err = mv_switch_port_del(switch_port, dev_priv->vlan_grp_id, dev_priv->port_map);
-	if (!err)
-		printk(KERN_ERR "%s: Switch port #%d unmapped\n", dev->name, port);
-
-	return err;
-}
-
-void    mv_eth_switch_status_print(int port)
-{
-	int i;
-	struct eth_port *pp = mv_eth_port_by_id(port);
-	struct net_device *dev;
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		printk(KERN_ERR "ethPort=%d: mv_eth_switch status - pp=%p, flags=0x%lx\n", port, pp, pp->flags);
-
-		printk(KERN_ERR "mtu=%d, netdev_max=%d, netdev_cfg=%d, first=%d, last=%d\n",
-			switch_net_config[port].mtu, switch_net_config[port].netdev_max, switch_net_config[port].netdev_cfg,
-			mv_eth_switch_netdev_first, mv_eth_switch_netdev_last);
-
-		for (i = 0; i < switch_net_config[port].netdev_cfg; i++) {
-			printk(KERN_ERR "MAC="MV_MACQUAD_FMT", board_port_map=0x%x\n",
-				MV_MACQUAD(switch_net_config[port].mac_addr[i]), switch_net_config[port].board_port_map[i]);
-		}
-		for (i = mv_eth_switch_netdev_first; i <= mv_eth_switch_netdev_last; i++) {
-			dev = mv_eth_netdev_by_id(i);
-			if (dev)
-				mv_eth_netdev_print(dev);
-		}
-	} else
-		printk(KERN_ERR "ethPort=%d: switch is not connected - pp=%p, flags=0x%lx\n", port, pp, pp->flags);
-}
-
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
index 9098ea6..25a06e2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
@@ -66,7 +66,7 @@ disclaimer.
 
 static int isSwitch(struct eth_port *priv)
 {
-	return (priv->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH));
+	return priv->tagged;
 }
 
 
@@ -435,18 +435,12 @@ int mv_eth_tool_nway_reset(struct net_device *netdev)
 u32 mv_eth_tool_get_link(struct net_device *netdev)
 {
 	struct eth_port     *pp = MV_ETH_PRIV(netdev);
-	struct eth_netdev   *dev_priv = MV_DEV_PRIV(netdev);
 
 	if (pp == NULL) {
 		printk(KERN_ERR "interface %s is not supported\n", netdev->name);
 		return -EOPNOTSUPP;
 	}
 
-	if (isSwitch(pp)) {
-		if (dev_priv == NULL)
-			return -EOPNOTSUPP;
-		return (dev_priv->link_map != 0);
-	}
 #ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(pp->port))
 		return mv_pon_link_status();
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
index 4fb776a..d53a4c3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
@@ -44,10 +44,6 @@ disclaimer.
 
 #include "mv_netdev.h"
 
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-#include "mv_switch.h"
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
 static int mv_eth_set_mac_addr_internals(struct net_device *dev, void *addr);
 
 /***********************************************************
@@ -78,24 +74,13 @@ static int mv_eth_start(struct net_device *dev)
 		for (group = 0; group < CONFIG_MV_ETH_NAPI_GROUPS; group++)
 			napi_enable(priv->napiGroup[group]);
 
-
-	if ((priv->flags & MV_ETH_F_LINK_UP) && !(priv->flags & MV_ETH_F_EXT_SWITCH)) {
-
+	if (priv->flags & MV_ETH_F_LINK_UP) {
 		if (mv_eth_ctrl_is_tx_enabled(priv)) {
 			netif_carrier_on(dev);
 			netif_tx_wake_all_queues(dev);
 		}
 		printk(KERN_NOTICE "%s: link up\n", dev->name);
 	}
-#ifdef CONFIG_MV_ETH_SWITCH_LINK
-	if (priv->flags & MV_ETH_F_EXT_SWITCH) {
-		struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-
-		dev_priv->link_map = 0;
-		mv_switch_link_update_event(dev_priv->port_map, 1);
-	}
-#endif /* CONFIG_MV_ETH_SWITCH_LINK */
-
 	if (priv->flags & MV_ETH_F_CONNECT_LINUX) {
 		/* connect to port interrupt line */
 		if (request_irq(dev->irq, mv_eth_isr, (IRQF_DISABLED|IRQF_SAMPLE_RANDOM), "mv_eth", priv)) {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index 9b764f9..8f4bdfd 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -50,15 +50,13 @@ disclaimer.
 #include "pnc/mvPnc.h"
 #include "pnc/mvTcam.h"
 #include "pmt/mvPmt.h"
-
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-#include "mv_switch.h"
-#endif
+#include "mv_mux/mv_mux_netdev.h"
 
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
 #include "mv_eth_sysfs.h"
 #include "cpu/mvCpuCntrs.h"
+static struct mv_mux_eth_ops mux_eth_ops;
 
 #ifdef CONFIG_MV_CPU_PERF_CNTRS
 MV_CPU_CNTRS_EVENT	*event0 = NULL;
@@ -116,9 +114,7 @@ extern unsigned int switch_enabled_ports;
 
 struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 struct eth_port **mv_eth_ports;
-struct net_device **mv_net_devs;
 
-int mv_net_devs_num = 0;
 int mv_ctrl_txdone = CONFIG_MV_ETH_TXDONE_COAL_PKTS;
 EXPORT_SYMBOL(mv_ctrl_txdone);
 
@@ -126,7 +122,6 @@ EXPORT_SYMBOL(mv_ctrl_txdone);
  * Static declarations
  */
 static int mv_eth_ports_num = 0;
-static int mv_net_devs_max = 0;
 
 static int mv_eth_initialized = 0;
 
@@ -144,7 +139,7 @@ static int  mv_eth_priv_init(struct eth_port *pp, int port);
 static void mv_eth_priv_cleanup(struct eth_port *pp);
 static int  mv_eth_config_get(struct platform_device *pdev, u8 *mac);
 static int  mv_eth_hal_init(struct eth_port *pp);
-struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
+struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
 					struct platform_device *pdev);
 static void mv_eth_netdev_init_features(struct net_device *dev);
 
@@ -263,6 +258,22 @@ static void mv_eth_adaptive_rx_update(struct eth_port *pp)
 	}
 }
 
+/*****************************************
+ *            MUX function                *
+ *****************************************/
+
+static int mv_eth_tag_type_set(int port, int type)
+{
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
+	if ((type == MV_TAG_TYPE_MH) || (type == MV_TAG_TYPE_DSA) || (type == MV_TAG_TYPE_EDSA))
+		mvNetaMhSet(port, type);
+
+	pp->tagged = (type == MV_TAG_TYPE_NONE) ? MV_FALSE : MV_TRUE;
+
+	return 0;
+}
+
 void set_cpu_affinity(struct eth_port *pp, MV_U32 cpuAffinity, int group)
 {
 	int cpu;
@@ -475,14 +486,6 @@ struct eth_port *mv_eth_port_by_id(unsigned int port)
 	return NULL;
 }
 
-struct net_device *mv_eth_netdev_by_id(unsigned int idx)
-{
-	if (idx < mv_net_devs_num)
-		return mv_net_devs[idx];
-
-	return NULL;
-}
-
 static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
 {
 	/* sanity: Check that there is place for MH in the buffer */
@@ -500,6 +503,12 @@ static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
 	return 0;
 }
 
+static inline int mv_eth_mh_skb_skip(struct sk_buff *skb)
+{
+	__skb_pull(skb, MV_ETH_MH_SIZE);
+	return MV_ETH_MH_SIZE;
+}
+
 void mv_eth_ctrl_txdone(int num)
 {
 	mv_ctrl_txdone = num;
@@ -513,18 +522,13 @@ int mv_eth_ctrl_flag(int port, u32 flag, u32 val)
 	if (!pp)
 		return -ENODEV;
 
-	if ((flag == MV_ETH_F_MH) && (pp->flags & MV_ETH_F_SWITCH)) {
-		printk(KERN_ERR "Error: cannot change Marvell Header on a port used by the Gateway driver\n");
-		return -EPERM;
-	}
-
 	if (val)
 		set_bit(bit_flag, &(pp->flags));
 	else
 		clear_bit(bit_flag, &(pp->flags));
 
 	if (flag == MV_ETH_F_MH)
-		mvNetaMhSet(pp->port, val ? MV_NETA_MH : MV_NETA_MH_NONE);
+		mvNetaMhSet(pp->port, val ? MV_TAG_TYPE_MH : MV_TAG_TYPE_NONE);
 
 	return 0;
 }
@@ -1061,98 +1065,6 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_set_features = mv_eth_netdev_set_features,
 };
 
-#ifdef CONFIG_MV_ETH_SWITCH
-
-static const struct net_device_ops mv_switch_netdev_ops = {
-	.ndo_open = mv_eth_switch_start,
-	.ndo_stop = mv_eth_switch_stop,
-	.ndo_start_xmit = mv_eth_tx,
-	.ndo_set_rx_mode = mv_eth_switch_set_multicast_list,
-	.ndo_set_mac_address = mv_eth_switch_set_mac_addr,
-	.ndo_change_mtu = mv_eth_switch_change_mtu,
-	.ndo_tx_timeout = mv_eth_tx_timeout,
-};
-
-int mv_eth_switch_netdev_first = 0;
-int mv_eth_switch_netdev_last = 0;
-
-static inline struct net_device *mv_eth_switch_netdev_get(struct eth_port *pp, struct eth_pbuf *pkt)
-{
-	MV_U8 *data;
-	int db_num;
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		data = pkt->pBuf + pkt->offset;
-
-		/* bits[4-7] of MSB in Marvell header */
-		db_num = ((*data) >> 4);
-
-		return mv_net_devs[mv_eth_switch_netdev_first + db_num];
-	}
-	return pp->dev;
-}
-
-
-void mv_eth_switch_priv_update(struct net_device *netdev, int i)
-{
-	struct eth_netdev *dev_priv;
-	struct eth_port *pp = MV_ETH_PRIV(netdev);
-	int print_flag, port, switch_port;
-
-	/* Update dev_priv structure */
-	dev_priv = MV_DEV_PRIV(netdev);
-	dev_priv->port_map = 0;
-	dev_priv->link_map = 0;
-
-	print_flag = 1;
-	for (port = 0; port < BOARD_ETH_SWITCH_PORT_NUM; port++) {
-		if (switch_net_config[pp->port].board_port_map[i] & (1 << port)) {
-			if (print_flag) {
-				printk(KERN_CONT ". Interface ports: ");
-				print_flag = 0;
-			}
-			printk(KERN_CONT "%d ", port);
-			switch_port = mvBoardSwitchPortGet(MV_SWITCH_ID_0, port);
-			if (switch_port >= 0) {
-				dev_priv->port_map |= (1 << switch_port);
-				switch_enabled_ports |= (1 << switch_port);
-			}
-		}
-	}
-	printk(KERN_CONT "\n");
-	dev_priv->group = i;
-	dev_priv->vlan_grp_id = MV_SWITCH_GROUP_VLAN_ID(i);	/* e.g. 0x100, 0x200... */
-	dev_priv->tx_vlan_mh = cpu_to_be16((i << 12) | dev_priv->port_map);
-	dev_priv->cpu_port = mvBoardSwitchCpuPortGet(MV_SWITCH_ID_0);
-
-	mv_eth_switch_vlan_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port);
-}
-
-
-int mv_eth_switch_netdev_init(struct eth_port *pp, int dev_i,
-				struct platform_device *pdev)
-{
-	int i;
-	struct net_device *netdev;
-
-	switch_enabled_ports = 0;
-
-	for (i = 0; i < switch_net_config[pp->port].netdev_max; i++) {
-		netdev = mv_eth_netdev_init(pp, switch_net_config[pp->port].mtu, switch_net_config[pp->port].mac_addr[i],
-						pdev);
-		if (netdev == NULL) {
-			printk(KERN_ERR "mv_eth_switch_netdev_init: can't create netdevice\n");
-			break;
-		}
-		mv_net_devs[dev_i++] = netdev;
-
-		mv_eth_switch_priv_update(netdev, i);
-
-	}
-	return dev_i;
-}
-
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 void mv_eth_link_status_print(int port)
 {
@@ -1748,7 +1660,7 @@ inline struct neta_rx_desc *mv_eth_rx_prefetch(struct eth_port *pp, MV_NETA_RXQ_
 }
 #endif /* CONFIG_MV_ETH_RX_DESC_PREFETCH */
 
-static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
+static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct napi_struct *napi)
 {
 	struct net_device *dev;
 	MV_NETA_RXQ_CTRL *rx_ctrl = pp->rxq_ctrl[rxq].q;
@@ -1816,16 +1728,12 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		prefetch(pkt->pBuf + pkt->offset + CPU_D_CACHE_LINE_SIZE);
 #endif /* CONFIG_MV_ETH_RX_PKT_PREFETCH */
 
-#ifdef CONFIG_MV_ETH_SWITCH
-		dev = mv_eth_switch_netdev_get(pp, pkt);
-#else
 		dev = pp->dev;
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 		STAT_DBG(pp->stats.rxq[rxq]++);
 		dev->stats.rx_packets++;
 
-		rx_bytes = rx_desc->dataSize - (MV_ETH_CRC_SIZE + MV_ETH_MH_SIZE);
+		rx_bytes = rx_desc->dataSize - MV_ETH_CRC_SIZE;
 		dev->stats.rx_bytes += rx_bytes;
 
 #ifndef CONFIG_MV_ETH_PNC
@@ -1873,7 +1781,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		if (pp->flags & MV_ETH_F_NFP_EN) {
 			MV_STATUS status;
 
-			pkt->bytes = rx_bytes + MV_ETH_MH_SIZE;
+			pkt->bytes = rx_bytes;
 			pkt->offset = NET_SKB_PAD;
 
 			status = mv_eth_nfp(pp, rxq, rx_desc, pkt, pool);
@@ -1890,16 +1798,13 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		/* Linux processing */
 		skb = (struct sk_buff *)(pkt->osInfo);
 
-		skb->data += MV_ETH_MH_SIZE;
-		skb->tail += (rx_bytes + MV_ETH_MH_SIZE);
-		skb->len = rx_bytes;
+		/* Linux processing */
+		__skb_put(skb, rx_bytes);
 
 #ifdef ETH_SKB_DEBUG
 		mv_eth_skb_check(skb);
 #endif /* ETH_SKB_DEBUG */
 
-		skb->protocol = eth_type_trans(skb, dev);
-
 #ifdef CONFIG_NET_SKB_RECYCLE
 		if (mv_eth_is_recycle()) {
 			skb->skb_recycle = mv_eth_skb_recycle;
@@ -1908,8 +1813,17 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 		}
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
-		if (skb)
-			mv_eth_rx_csum(pp, rx_desc, skb);
+		mv_eth_rx_csum(pp, rx_desc, skb);
+
+		if (pp->tagged) {
+			mv_mux_rx(skb, pp->port, napi);
+			STAT_DBG(pp->stats.rx_tagged++);
+			skb = NULL;
+		} else {
+			dev->stats.rx_bytes -= mv_eth_mh_skb_skip(skb);
+			skb->protocol = eth_type_trans(skb, dev);
+		}
+
 
 #ifdef CONFIG_MV_ETH_GRO
 		if (skb && (dev->features & NETIF_F_GRO)) {
@@ -1947,12 +1861,11 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 {
 	struct eth_port *pp = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 	int frags = 0;
 	bool tx_spec_ready = false;
 	struct mv_eth_tx_spec tx_spec;
 	u32 tx_cmd;
-	u16 mh;
+
 	struct tx_queue *txq_ctrl = NULL;
 	struct neta_tx_desc *tx_desc;
 	unsigned long flags = 0;
@@ -2014,12 +1927,7 @@ static int mv_eth_tx(struct sk_buff *skb, struct net_device *dev)
 	frags = skb_shinfo(skb)->nr_frags + 1;
 
 	if (tx_spec.flags & MV_ETH_F_MH) {
-		if (tx_spec.flags & MV_ETH_F_SWITCH)
-			mh = dev_priv->tx_vlan_mh;
-		else
-			mh = pp->tx_mh;
-
-		if (mv_eth_skb_mh_add(skb, mh)) {
+		if (mv_eth_skb_mh_add(skb, pp->tx_mh)) {
 			frags = 0;
 			goto out;
 		}
@@ -2269,7 +2177,6 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev,
 	skb_frag_t *skb_frag_ptr;
 	const struct tcphdr *th = tcp_hdr(skb);
 	struct eth_port *priv = MV_ETH_PRIV(dev);
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
 	MV_U16 *mh = NULL;
 	int i;
 
@@ -2331,13 +2238,8 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev,
 		total_len -= data_left;
 		txq_ctrl->txq_count++;
 
-		if (tx_spec->flags & MV_ETH_F_MH) {
-			if (tx_spec->flags & MV_ETH_F_SWITCH)
-				mh = &dev_priv->tx_vlan_mh;
-			else
-				mh = &priv->tx_mh;
-		}
-
+		if (tx_spec->flags & MV_ETH_F_MH)
+			mh = &priv->tx_mh;
 		/* prepare packet headers: MAC + IP + TCP */
 		size = mv_eth_tso_build_hdr_desc(tx_desc, priv, skb, txq_ctrl, mh,
 					hdr_len, data_left, tcp_seq, ip_id, total_len);
@@ -3040,14 +2942,14 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		if (rx_queue == -1)
 			break;
 
-		count = mv_eth_rx(pp, budget, rx_queue);
+		count = mv_eth_rx(pp, budget, rx_queue, napi);
 		rx_done += count;
 		budget -= count;
 		if (budget > 0)
 			causeRxTx &= ~((1 << rx_queue) << NETA_CAUSE_RXQ_OCCUP_DESC_OFFS);
 	}
 #else
-	rx_done = mv_eth_rx(pp, budget, CONFIG_MV_ETH_RXQ_DEF);
+	rx_done = mv_eth_rx(pp, budget, CONFIG_MV_ETH_RXQ_DEF, napi);
 	budget -= rx_done;
 #endif /* (CONFIG_MV_ETH_RXQ > 1) */
 
@@ -3142,21 +3044,21 @@ static void mv_eth_cpu_counters_init(void)
 #endif /* CONFIG_MV_CPU_PERF_CNTRS */
 }
 
-void mv_eth_port_promisc_set(int port, int queue)
+void mv_eth_port_promisc_set(int port)
 {
 #ifdef CONFIG_MV_ETH_PNC
 	/* Accept all */
 	if (mv_eth_pnc_ctrl_en) {
-		pnc_mac_me(port, NULL, queue);
+		pnc_mac_me(port, NULL, CONFIG_MV_ETH_RXQ_DEF);
 		pnc_mcast_all(port, 1);
 	} else {
 		printk(KERN_ERR "%s: PNC control is disabled\n", __func__);
 	}
 #else /* Legacy parser */
 	mvNetaRxUnicastPromiscSet(port, MV_TRUE);
-	mvNetaSetUcastTable(port, queue);
-	mvNetaSetSpecialMcastTable(port, queue);
-	mvNetaSetOtherMcastTable(port, queue);
+	mvNetaSetUcastTable(port, CONFIG_MV_ETH_RXQ_DEF);
+	mvNetaSetSpecialMcastTable(port, CONFIG_MV_ETH_RXQ_DEF);
+	mvNetaSetOtherMcastTable(port, CONFIG_MV_ETH_RXQ_DEF);
 #endif /* CONFIG_MV_ETH_PNC */
 }
 
@@ -3214,6 +3116,8 @@ static MV_STATUS mv_eth_bm_pools_init(void)
 
 static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int en_force)
 {
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
 	if (en_force) {
 		if (mvNetaSpeedDuplexSet(port, port_speed, MV_ETH_DUPLEX_FULL)) {
 			printk(KERN_ERR "mvEthSpeedDuplexSet failed\n");
@@ -3227,6 +3131,9 @@ static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int
 			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
 			return -EIO;
 		}
+
+		set_bit(MV_ETH_F_FORCE_LINK_BIT, &(pp->flags));
+
 	} else {
 		if (mvNetaForceLinkModeSet(port, 0, 0)) {
 			printk(KERN_ERR "mvEthForceLinkModeSet failed\n");
@@ -3240,6 +3147,8 @@ static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int
 			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
 			return -EIO;
 		}
+
+		clear_bit(MV_ETH_F_FORCE_LINK_BIT, &(pp->flags));
 	}
 	return 0;
 }
@@ -3247,9 +3156,10 @@ static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int
 /* Note: call this function only after mv_eth_ports_num is initialized */
 static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 {
-	u32 port, dev_i = 0;
+	u32 port;
 	struct eth_port *pp;
 	int mtu, err;
+	struct net_device *dev;
 	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
 	u8 mac[MV_MAC_ADDR_SIZE];
 
@@ -3258,18 +3168,19 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	printk(KERN_ERR "  o Loading network interface(s) for port #%d: cpu_mask=0x%x, mtu=%d\n",
 			port, plat_data->cpu_mask, plat_data->mtu);
 
-	pp = mv_eth_ports[port] = mvOsMalloc(sizeof(struct eth_port));
-	if (!pp) {
-		printk(KERN_ERR "Error: failed to allocate memory for port %d\n", port);
-		return -ENOMEM;
+	mtu = mv_eth_config_get(pdev, mac);
+	dev = mv_eth_netdev_init(mtu, mac, pdev);
+	if (!dev) {
+		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
+		mv_eth_priv_cleanup(pp);
+		return -EIO;
 	}
-	memset(pp, 0, sizeof(struct eth_port));
+
+	pp = (struct eth_port *)netdev_priv(dev);
 
 	pp->plat_data = plat_data;
 	pp->cpu_mask = plat_data->cpu_mask;
-	err = mv_eth_priv_init(pp, port);
-	if (err)
-		return err;
+	mv_eth_ports[port] = pp;
 
 	/* set port's speed, duplex, fc */
 	if (!MV_PON_PORT(pp->port)) {
@@ -3311,67 +3222,15 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 		mvNetaPmtInit(port, (MV_NETA_PMT *)ioremap(PMT_GIGA_PHYS_BASE + port * 0x40000, PMT_MEM_SIZE));
 #endif /* CONFIG_MV_ETH_PMT */
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-		int status = mv_eth_switch_config_get(/*mv_eth_initialized*/ 0, port);
-
-		if (status < 0) {
-			printk(KERN_ERR "\nWarning: port %d - Invalid netconfig string\n", port);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		} else if (status == 0) {	/* User selected to work with Gateway driver    */
-			clear_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
-		} else if (status == 1) {
-			/* User selected to work without Gateway driver */
-			clear_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
-			printk(KERN_ERR "  o Working in External Switch mode\n");
-			ext_switch_port_mask = mv_switch_link_detection_init();
-		}
-	}
-
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		int queue = CONFIG_MV_ETH_RXQ_DEF;
-
-		set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
-		mtu = switch_net_config[port].mtu;
-		if (mv_switch_init(RX_PKT_SIZE(mtu), SWITCH_CONNECTED_PORTS_MASK)) {
-			printk(KERN_ERR "\nWarning: port %d - Switch initialization failed\n", port);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		}
-
-		mv_eth_switch_netdev_first = dev_i;
-		dev_i = mv_eth_switch_netdev_init(pp, dev_i, pdev);
-		if (dev_i < (mv_eth_switch_netdev_first + switch_net_config[port].netdev_max)) {
-			printk(KERN_ERR "%s: can't create netdevice for switch\n", __func__);
-			mv_eth_priv_cleanup(pp);
-			return -EIO;
-		}
-		mv_eth_switch_netdev_last = dev_i - 1;
-
-		/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch */
-		mv_eth_port_promisc_set(pp->port, queue);
-		handle_group_affinity(port);
-
-		return MV_OK;
-	}
-#endif /* CONFIG_MV_ETH_SWITCH */
-
-	mtu = mv_eth_config_get(pdev, mac);
-
 	printk(KERN_ERR "\t%s p=%d: mtu=%d, mac=" MV_MACQUAD_FMT "\n",
 		MV_PON_PORT(port) ? "pon" : "giga", port, mtu, MV_MACQUAD(mac));
 
-	mv_net_devs[dev_i] = mv_eth_netdev_init(pp, mtu, mac, pdev);
-	if (!mv_net_devs[dev_i]) {
-		printk(KERN_ERR "%s: can't create netdevice\n", __func__);
-		mv_eth_priv_cleanup(pp);
-		return -EIO;
-	}
-	pp->dev = mv_net_devs[dev_i];
-	dev_i++;
 	handle_group_affinity(port);
 
+	mux_eth_ops.set_tag_type = mv_eth_tag_type_set;
+	mux_eth_ops.promisc_set = mv_eth_port_promisc_set;
+	mv_mux_eth_attach(pp->port, pp->dev, &mux_eth_ops);
+
 	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
 	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
 		mv_eth_open(pp->dev);
@@ -3393,14 +3252,13 @@ int mv_eth_resume_network_interfaces(struct eth_port *pp)
 	mvNetaDefaultsSet(pp->port);
 
 	if (pp->flags & MV_ETH_F_MH)
-		mvNetaMhSet(pp->port, MV_NETA_MH);
+		mvNetaMhSet(pp->port, MV_TAG_TYPE_MH);
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch */
-		mv_eth_port_promisc_set(pp->port, CONFIG_MV_ETH_RXQ_DEF);
+	/*TODO: remove to mv_mux_resume */
+	if (pp->tagged) {
+		/* set this port to be in promiscuous mode. MAC filtering is performed by the Switch/Mux */
+		mv_eth_port_promisc_set(pp->port);
 	}
-#endif /* CONFIG_MV_ETH_SWITCH */
 
 	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
 		/* set queue mask per cpu */
@@ -3899,11 +3757,6 @@ static int	mv_eth_shared_probe(struct mv_neta_pdata *plat_data)
 	if (mv_eth_ports_num > CONFIG_MV_ETH_PORTS_NUM)
 		mv_eth_ports_num = CONFIG_MV_ETH_PORTS_NUM;
 
-	mv_net_devs_max = MV_ETH_MAX_NETDEV_NUM;
-#ifdef CONFIG_MV_ETH_SWITCH
-	mv_net_devs_max += (CONFIG_MV_ETH_SWITCH_NETDEV_NUM - 1);
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 	mv_eth_config_show();
 
 	size = mv_eth_ports_num * sizeof(struct eth_port *);
@@ -3913,24 +3766,9 @@ static int	mv_eth_shared_probe(struct mv_neta_pdata *plat_data)
 
 	memset(mv_eth_ports, 0, size);
 
-	/* Allocate array of pointers to struct net_device */
-	size = mv_net_devs_max * sizeof(struct net_device *);
-	mv_net_devs = mvOsMalloc(size);
-	if (!mv_net_devs)
-		goto oom;
-
-	memset(mv_net_devs, 0, size);
-
 	if (mv_eth_bm_pools_init())
 		goto oom;
 
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-	if ((mvBoardSwitchConnectedPortGet(0) != -1) || (mvBoardSwitchConnectedPortGet(1) != -1)) {
-		if (mv_switch_load(SWITCH_CONNECTED_PORTS_MASK))
-			printk(KERN_ERR "\nWarning: Switch load failed\n");
-	}
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
-
 #ifdef CONFIG_MV_ETH_PNC
 	if (mv_eth_pnc_ctrl_en) {
 		if (pnc_default_init())
@@ -3953,9 +3791,6 @@ oom:
 	if (mv_eth_ports)
 		mvOsFree(mv_eth_ports);
 
-	if (mv_net_devs)
-		mvOsFree(mv_net_devs);
-
 	printk(KERN_ERR "%s: out of memory\n", __func__);
 	return -ENOMEM;
 }
@@ -3973,7 +3808,17 @@ static int mv_eth_probe(struct platform_device *pdev)
 		if (mv_eth_shared_probe(plat_data))
 			return -ENODEV;
 	}
+/*
+	if(port == 0)
+		mvNetaPortPowerUp(port, 0, 1);
+	else if (port == 1);
+		mvNetaPortPowerUp(port, 0, 1);
+
+	printk(KERN_ERR " port = %d is_sgmii = %d, is_rgmii=%d\n", port ,plat_data->is_sgmii, plat_data->is_rgmii);
+*/
+
 	mvNetaPortPowerUp(port, plat_data->is_sgmii, plat_data->is_rgmii);
+
 	mv_eth_win_init(port);
 
 	if (mv_eth_load_network_interfaces(pdev))
@@ -4013,57 +3858,37 @@ static void mv_eth_tx_timeout(struct net_device *dev)
  * mv_eth_netdev_init -- Allocate and initialize net_device    *
  *                   structure                                 *
  ***************************************************************/
-struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
+struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
 				struct platform_device *pdev)
 {
 	int cpu, i;
 	struct net_device *dev;
-	struct eth_dev_priv *dev_priv;
+	struct eth_port *pp;
 	struct cpu_ctrl	*cpuCtrl;
+	int port = pdev->id;
 
-	dev = alloc_etherdev_mq(sizeof(struct eth_dev_priv), CONFIG_MV_ETH_TXQ);
+	dev = alloc_etherdev_mq(sizeof(struct eth_port), CONFIG_MV_ETH_TXQ);
 	if (!dev)
 		return NULL;
 
-	dev_priv = (struct eth_dev_priv *)netdev_priv(dev);
-	if (!dev_priv)
+	pp = (struct eth_port *)netdev_priv(dev);
+	if (!pp)
 		return NULL;
 
-	memset(dev_priv, 0, sizeof(struct eth_dev_priv));
-	dev_priv->port_p = pp;
-
-	dev->irq = NET_TH_RXTX_IRQ_NUM(pp->port);
+	memset(pp, 0, sizeof(struct eth_port));
+	pp->dev = dev;
+	dev->irq = NET_TH_RXTX_IRQ_NUM(port);
 
 	dev->mtu = mtu;
 	memcpy(dev->dev_addr, mac, MV_MAC_ADDR_SIZE);
 	dev->tx_queue_len = CONFIG_MV_ETH_TXQ_DESC;
 	dev->watchdog_timeo = 5 * HZ;
+	dev->netdev_ops = &mv_eth_netdev_ops;
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)) {
-
-		if (pp->flags & MV_ETH_F_SWITCH)
-			dev->netdev_ops = &mv_switch_netdev_ops;
-		else
-			dev->netdev_ops = &mv_eth_netdev_ops;
-
-		dev_priv->netdev_p = mvOsMalloc(sizeof(struct eth_netdev));
-		if (!dev_priv->netdev_p) {
-			printk(KERN_ERR "failed to allocate eth_netdev\n");
-			free_netdev(dev);
-			return NULL;
-		}
-		memset(dev_priv->netdev_p, 0, sizeof(struct eth_netdev));
-		/* For correct link information of Linux interface: */
-		if (pp->flags & MV_ETH_F_EXT_SWITCH) {
-			dev_priv->netdev_p->port_map = ext_switch_port_mask;
-			dev_priv->netdev_p->link_map = 0;
-		}
-	} else
-#endif /* CONFIG_MV_ETH_SWITCH */
-		dev->netdev_ops = &mv_eth_netdev_ops;
-
-	SET_ETHTOOL_OPS(dev, &mv_eth_tool_ops);
+	if (mv_eth_priv_init(pp, port)) {
+		mv_eth_priv_cleanup(pp);
+		return NULL;
+	}
 
 	/* Default NAPI initialization */
 	for (i = 0; i < CONFIG_MV_ETH_NAPI_GROUPS; i++) {
@@ -4102,12 +3927,8 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 #endif /* CONFIG_MV_ETH_GRO_DEF */
 
 			printk(KERN_ERR "    o %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
-#ifdef CONFIG_MV_ETH_SWITCH
-			if (!(pp->flags & MV_ETH_F_SWITCH))
-				printk(KERN_CONT "\n");
-#else
+
 			printk(KERN_CONT "\n");
-#endif
 		}
 	}
 	return dev;
@@ -4115,52 +3936,18 @@ struct net_device *mv_eth_netdev_init(struct eth_port *pp, int mtu, u8 *mac,
 
 bool mv_eth_netdev_find(unsigned int dev_idx)
 {
-	int i;
+	int port;
 
-	for (i = 0; i < mv_net_devs_num; i++) {
-		if (mv_net_devs && mv_net_devs[i] && (mv_net_devs[i]->ifindex == dev_idx))
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		struct eth_port *pp = mv_eth_port_by_id(port);
+
+		if (pp && pp->dev && (pp->dev->ifindex == dev_idx))
 			return true;
 	}
 	return false;
 }
 EXPORT_SYMBOL(mv_eth_netdev_find);
 
-void mv_eth_netdev_update(int dev_index, struct eth_port *pp)
-{
-	int i;
-	struct eth_dev_priv *dev_priv;
-
-#ifdef CONFIG_MV_ETH_SWITCH
-	struct eth_netdev *eth_netdev_priv;
-#endif /* CONFIG_MV_ETH_SWITCH */
-	struct net_device *dev = mv_net_devs[dev_index];
-
-	dev_priv = (struct eth_dev_priv *)netdev_priv(dev); /* assuming dev_priv has to be valid here */
-
-	dev_priv->port_p = pp;
-
-	dev->irq = NET_TH_RXTX_IRQ_NUM(pp->port);
-
-	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
-		for (i = 0; i < CONFIG_MV_ETH_NAPI_GROUPS; i++)
-			netif_napi_add(dev, pp->napiGroup[i], mv_eth_poll, pp->weight);
-	}
-
-	printk(KERN_ERR "    o %s, ifindex = %d, GbE port = %d", dev->name, dev->ifindex, pp->port);
-
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & MV_ETH_F_SWITCH) {
-		eth_netdev_priv = MV_DEV_PRIV(dev);
-		mv_eth_switch_priv_update(dev, MV_SWITCH_VLAN_TO_GROUP(eth_netdev_priv->vlan_grp_id));
-	} else {
-		printk(KERN_CONT "\n");
-	}
-#else
-	printk(KERN_CONT "\n");
-#endif /* CONFIG_MV_ETH_SWITCH */
-}
-
-
 int mv_eth_hal_init(struct eth_port *pp)
 {
 	int rxq, txp, txq, size, cpu;
@@ -4227,7 +4014,7 @@ int mv_eth_hal_init(struct eth_port *pp)
 	}
 
 	if (pp->flags & MV_ETH_F_MH)
-		mvNetaMhSet(pp->port, MV_NETA_MH);
+		mvNetaMhSet(pp->port, MV_TAG_TYPE_MH);
 
 	/* Configure defaults */
 	pp->autoneg_cfg  = AUTONEG_ENABLE;
@@ -4615,6 +4402,8 @@ no_mem:
 
 static int mv_force_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int en_force)
 {
+	struct eth_port *pp = mv_eth_port_by_id(port);
+
 	if (en_force) {
 		if (mvNetaForceLinkModeSet(port, 1, 0)) {
 			printk(KERN_ERR "mvNetaForceLinkModeSet failed\n");
@@ -4628,6 +4417,9 @@ static int mv_force_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, i
 			printk(KERN_ERR "mvNetaFlowCtrlSet failed\n");
 			return -EIO;
 		}
+		printk(KERN_ERR "*************FORCE LINK**************\n");
+		set_bit(MV_ETH_F_FORCE_LINK_BIT, &(pp->flags));
+
 	} else {
 		if (mvNetaForceLinkModeSet(port, 0, 0)) {
 			printk(KERN_ERR "mvNetaForceLinkModeSet failed\n");
@@ -4641,6 +4433,9 @@ static int mv_force_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, i
 			printk(KERN_ERR "mvNetaFlowCtrlSet failed\n");
 			return -EIO;
 		}
+		printk(KERN_ERR "*************CLEAR FORCE LINK**************\n");
+
+		clear_bit(MV_ETH_F_FORCE_LINK_BIT, &(pp->flags));
 	}
 	return 0;
 }
@@ -5554,12 +5349,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	}
 #endif /* CONFIG_MV_PON */
 
-#ifdef CONFIG_MV_INCLUDE_SWITCH
-	if (mvBoardSwitchConnectedPortGet(port) != -1) {
-		set_bit(MV_ETH_F_SWITCH_BIT, &(pp->flags));
-		set_bit(MV_ETH_F_EXT_SWITCH_BIT, &(pp->flags));
-	}
-#endif /* CONFIG_MV_INCLUDE_SWITCH */
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		memset(&cpuCtrl->tx_done_timer, 0, sizeof(struct timer_list));
@@ -5701,17 +5490,18 @@ void mv_eth_netdev_print(struct net_device *dev)
 			netif_running(dev), netif_oper_up(dev));
 
 	if (mv_eth_netdev_find(dev->ifindex)) {
-		struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-		if (dev_priv)
-			printk(KERN_ERR "group=%d, tx_vlan_mh=0x%04x, switch_port_map=0x%x, switch_port_link_map=0x%x\n",
-					dev_priv->group, dev_priv->tx_vlan_mh, dev_priv->port_map, dev_priv->link_map);
-		printk(KERN_ERR "\n");
-	}
+		struct eth_port *pp = MV_ETH_PRIV(dev);
+
+		if (pp)
+			printk(KERN_ERR "pp=%p\n", pp);
+	} else
+		/* mux net device */
+		mv_mux_netdev_print(dev);
 }
 
 void mv_eth_status_print(void)
 {
-	printk(KERN_ERR "totals: ports=%d, devs=%d\n", mv_eth_ports_num, mv_net_devs_num);
+	printk(KERN_ERR "totals: ports=%d\n", mv_eth_ports_num);
 
 #ifdef CONFIG_NET_SKB_RECYCLE
 	printk(KERN_ERR "SKB recycle = %s\n", mv_ctrl_recycle ? "Enabled" : "Disabled");
@@ -5737,7 +5527,7 @@ void mv_eth_port_status_print(unsigned int port)
 
 	printk(KERN_ERR "\n");
 	printk(KERN_ERR "port=%d, flags=0x%lx, rx_weight=%d\n", port, pp->flags, pp->weight);
-	if ((!(pp->flags & MV_ETH_F_SWITCH)) && (pp->flags & MV_ETH_F_CONNECT_LINUX))
+	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
 		printk(KERN_ERR "%s: ", pp->dev->name);
 	else
 		printk(KERN_ERR "port %d: ", port);
@@ -5853,10 +5643,12 @@ void mv_eth_port_status_print(unsigned int port)
 	if (pp->dev)
 		mv_eth_netdev_print(pp->dev);
 
-#ifdef CONFIG_MV_ETH_SWITCH
-	if (pp->flags & MV_ETH_F_SWITCH)
-		mv_eth_switch_status_print(port);
-#endif /* CONFIG_MV_ETH_SWITCH */
+	if (pp->tagged) {
+		printk(KERN_CONT "TAGGED PORT\n\n");
+		mv_mux_netdev_print_all(port);
+	} else
+		printk(KERN_CONT "UNTAGGED PORT\n");
+
 }
 
 /***********************************************************************************
@@ -6138,7 +5930,7 @@ static int mv_eth_port_cleanup(int port)
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
 	/* Clear Marvell Header related modes - will be set again if needed on re-init */
-	mvNetaMhSet(port, MV_NETA_MH_NONE);
+	mvNetaMhSet(port, MV_TAG_TYPE_NONE);
 
 	/* Clear any forced link, speed and duplex */
 	mv_force_port_link_speed_fc(port, MV_ETH_SPEED_AN, 0);
@@ -6421,6 +6213,9 @@ int mv_eth_resume(struct platform_device *pdev)
 
 	}
 
+	if (pp->tagged)
+		mv_mux_eth_detach(pp->port);
+
 	return MV_OK;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 65d0842..4e78ad8 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -212,6 +212,7 @@ struct port_stats {
 
 #ifdef CONFIG_MV_ETH_STAT_DBG
 	u32 rxq[CONFIG_MV_ETH_RXQ];
+	u32 rx_tagged;
 	u32 rxq_fill[CONFIG_MV_ETH_RXQ];
 	u32 rx_netif;
 	u32 rx_nfp;
@@ -238,20 +239,20 @@ struct port_stats {
 
 /* Masks used for pp->flags */
 #define MV_ETH_F_STARTED_BIT        0
-#define MV_ETH_F_SWITCH_BIT         1	/* port is connected to the Switch using the Gateway driver */
-#define MV_ETH_F_MH_BIT             2
-#define MV_ETH_F_NO_PAD_BIT         3
-#define MV_ETH_F_DBG_RX_BIT         4
-#define MV_ETH_F_DBG_TX_BIT         5
-#define MV_ETH_F_EXT_SWITCH_BIT	    6	/* port is connected to the Switch without the Gateway driver */
-#define MV_ETH_F_CONNECT_LINUX_BIT  7	/* port is connected to Linux netdevice */
-#define MV_ETH_F_LINK_UP_BIT        8
-#define MV_ETH_F_DBG_DUMP_BIT       9
-#define MV_ETH_F_DBG_ISR_BIT        10
-#define MV_ETH_F_DBG_POLL_BIT       11
-#define MV_ETH_F_NFP_EN_BIT         12
-#define MV_ETH_F_SUSPEND_BIT        13
-#define MV_ETH_F_STARTED_OLD_BIT    14 /*STARTED_BIT value before suspend */
+#define MV_ETH_F_MH_BIT             1
+#define MV_ETH_F_NO_PAD_BIT         2
+#define MV_ETH_F_DBG_RX_BIT         3
+#define MV_ETH_F_DBG_TX_BIT         4
+#define MV_ETH_F_EXT_SWITCH_BIT	    5	/* port is connected to the Switch without the Gateway driver */
+#define MV_ETH_F_CONNECT_LINUX_BIT  6	/* port is connected to Linux netdevice */
+#define MV_ETH_F_LINK_UP_BIT        7
+#define MV_ETH_F_DBG_DUMP_BIT       8
+#define MV_ETH_F_DBG_ISR_BIT        9
+#define MV_ETH_F_DBG_POLL_BIT       10
+#define MV_ETH_F_NFP_EN_BIT         11
+#define MV_ETH_F_SUSPEND_BIT        12
+#define MV_ETH_F_STARTED_OLD_BIT    13 /*STARTED_BIT value before suspend */
+#define MV_ETH_F_FORCE_LINK_BIT     14
 
 
 #define MV_ETH_F_STARTED           (1 << MV_ETH_F_STARTED_BIT)
@@ -269,6 +270,7 @@ struct port_stats {
 #define MV_ETH_F_NFP_EN            (1 << MV_ETH_F_NFP_EN_BIT)
 #define MV_ETH_F_SUSPEND           (1 << MV_ETH_F_SUSPEND_BIT)
 #define MV_ETH_F_STARTED_OLD       (1 << MV_ETH_F_STARTED_OLD_BIT)
+#define MV_ETH_F_FORCE_LINK        (1 << MV_ETH_F_FORCE_LINK_BIT)
 
 /* Masks used for cpu_ctrl->flags */
 #define MV_ETH_F_TX_DONE_TIMER_BIT  0
@@ -356,6 +358,7 @@ struct cpu_ctrl {
 
 struct eth_port {
 	int                 port;
+	bool                tagged; /* NONE/MH/DSA/EDSA/VLAN */
 	struct mv_neta_pdata *plat_data;
 	MV_NETA_PORT_CTRL   *port_ctrl;
 	struct rx_queue     *rxq_ctrl;
@@ -430,8 +433,7 @@ struct eth_dev_priv {
 	struct eth_netdev   *netdev_p;
 };
 
-#define MV_ETH_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->port_p)
-#define MV_DEV_PRIV(dev)        (((struct eth_dev_priv *)(netdev_priv(dev)))->netdev_p)
+#define MV_ETH_PRIV(dev)        ((struct eth_port *)(netdev_priv(dev)))
 #define MV_DEV_STAT(dev)        (&((dev)->stats))
 
 /* define which Switch ports are relevant */
@@ -501,7 +503,7 @@ extern struct eth_port **mv_eth_ports;
 static inline void mv_eth_interrupts_unmask(struct eth_port *pp)
 {
 	/* unmask interrupts */
-	if (!(pp->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH)))
+	if (!test_bit(MV_ETH_F_FORCE_LINK_BIT, &(pp->flags)))
 		MV_REG_WRITE(NETA_INTR_MISC_MASK_REG(pp->port), NETA_CAUSE_LINK_CHANGE_MASK);
 
 	MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port),
@@ -703,32 +705,6 @@ static inline void mv_eth_rxq_refill(struct eth_port *pp, int rxq,
 	}
 }
 
-
-#ifdef CONFIG_MV_ETH_SWITCH
-struct mv_eth_switch_config {
-	int             mtu;
-	int             netdev_max;
-	int             netdev_cfg;
-	unsigned char   mac_addr[CONFIG_MV_ETH_SWITCH_NETDEV_NUM][MV_MAC_ADDR_SIZE];
-	u16             board_port_map[CONFIG_MV_ETH_SWITCH_NETDEV_NUM];
-};
-
-extern int  mv_eth_switch_netdev_first, mv_eth_switch_netdev_last;
-extern struct mv_eth_switch_config      switch_net_config[CONFIG_MV_ETH_PORTS_NUM];
-extern struct net_device **mv_net_devs;
-
-int     mv_eth_switch_config_get(int use_existing_config, int port);
-int     mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac);
-void    mv_eth_switch_set_multicast_list(struct net_device *dev);
-int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu);
-int     mv_eth_switch_start(struct net_device *dev);
-int     mv_eth_switch_stop(struct net_device *dev);
-void    mv_eth_switch_status_print(int port);
-int     mv_eth_switch_port_add(struct net_device *dev, int port);
-int     mv_eth_switch_port_del(struct net_device *dev, int port);
-
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 /******************************************************
  * Function prototypes --                             *
  ******************************************************/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index f04d7e1..a2cb47d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -333,7 +333,7 @@ int mv_eth_open(struct net_device *dev)
 			printk(KERN_ERR "%s: mvPrsMacDaAccept failed\n", dev->name);
 				return -1;
 		}
-		if (mvPp2PrsTagModeSet(phyPort, MV_PP2_MH)) {
+		if (mvPp2PrsTagModeSet(phyPort, MV_TAG_TYPE_MH)) {
 			printk(KERN_ERR "%s: mvPp2PrsTagModeSet failed\n", dev->name);
 				return -1;
 		}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 9a1bd77..16f6c18 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -197,18 +197,8 @@ static int mv_eth_tag_type_set(int port, int type)
 {
 	struct eth_port *pp = mv_eth_port_by_id(port);
 
-	switch (type) {
-	case MV_TAG_TYPE_MH:
-		mvPp2MhSet(port, MV_PP2_MH);
-		break;
-	case MV_TAG_TYPE_DSA:
-		mvPp2MhSet(port, MV_TAG_TYPE_DSA);
-		break;
-	case MV_TAG_TYPE_EDSA:
-		mvPp2MhSet(port, MV_PP2_DSA_EXT);
-	default: /* Do Nothing */
-		break;
-	}
+	if ((type == MV_TAG_TYPE_MH) || (type == MV_TAG_TYPE_DSA) || (type == MV_TAG_TYPE_EDSA))
+		mvPp2MhSet(port, type);
 
 	pp->tagged = (type == MV_TAG_TYPE_NONE) ? MV_FALSE : MV_TRUE;
 
@@ -3626,7 +3616,7 @@ int mv_eth_hal_init(struct eth_port *pp)
 	}
 
 	if (pp->tx_spec.flags & MV_ETH_TX_F_MH)
-		mvPp2MhSet(pp->port, MV_PP2_MH);
+		mvPp2MhSet(pp->port, MV_TAG_TYPE_MH);
 
 	/* Configure defaults */
 	pp->autoneg_cfg = AUTONEG_ENABLE;
@@ -5079,7 +5069,7 @@ static int mv_eth_port_cleanup(int port)
 	mv_eth_pool_cleanup(port, pp->hwf_pool_short);
 
 	/* Clear Marvell Header related modes - will be set again if needed on re-init */
-	mvPp2MhSet(port, MV_PP2_MH_NONE);
+	mvPp2MhSet(port, MV_TAG_TYPE_NONE);
 
 	/* Clear any forced link, speed and duplex */
 	mv_eth_port_link_speed_fc(port, MV_ETH_SPEED_AN, 0);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index 8514d5c..5f279cb 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -43,14 +43,12 @@ disclaimer.
 #include "mv_switch.h"
 #include "mv_mux/mv_mux_netdev.h"
 
-unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
-
 #define MV_SWITCH_DEF_INDEX     0
 #define MV_ETH_PORT_0           0
 #define MV_ETH_PORT_1           1
 
-static u16 	db_port_mask[MV_SWITCH_DB_NUM];
-static u16 	db_link_mask[MV_SWITCH_DB_NUM];
+static u16	db_port_mask[MV_SWITCH_DB_NUM];
+static u16	db_link_mask[MV_SWITCH_DB_NUM];
 static void	*db_cookies[MV_SWITCH_DB_NUM];
 
 /* uncomment for debug prints */
@@ -73,8 +71,8 @@ static GT_QD_DEV qddev, *qd_dev = NULL;
 static GT_SYS_CONFIG qd_cfg;
 
 static int qd_cpu_port = -1;
-static int enabled_ports_mask = 0;
-static int switch_ports_mask = 0;
+static int enabled_ports_mask;
+static int switch_ports_mask;
 static MV_TAG_TYPE tag_mode;
 static MV_SWITCH_PRESET_TYPE preset;
 static int default_vid;
@@ -89,6 +87,9 @@ static struct timer_list switch_link_timer;
 
 static spinlock_t switch_lock;
 
+static unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
+
+#ifdef CONFIG_AVANTA_LP
 static GT_BOOL mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int *data)
 {
 	unsigned long flags;
@@ -108,7 +109,26 @@ static GT_BOOL mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int
 
 	return GT_TRUE;
 }
+#else
+static GT_BOOL mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int *data)
+{
+	unsigned long flags;
+	unsigned short tmp;
+	MV_STATUS status;
 
+	spin_lock_irqsave(&switch_lock, flags);
+	status = mvEthPhyRegRead(phy, reg, &tmp);
+	spin_unlock_irqrestore(&switch_lock, flags);
+	*data = tmp;
+
+	if (status == MV_OK)
+		return GT_TRUE;
+
+	return GT_FALSE;
+}
+#endif
+
+#ifdef CONFIG_AVANTA_LP
 static GT_BOOL mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int data)
 {
 	unsigned long flags;
@@ -126,6 +146,24 @@ static GT_BOOL mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned in
 
 	return GT_TRUE;
 }
+#else
+static GT_BOOL mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int data)
+{
+	unsigned long flags;
+	unsigned short tmp;
+	MV_STATUS status;
+
+	spin_lock_irqsave(&switch_lock, flags);
+	tmp = (unsigned short)data;
+	status = mvEthPhyRegWrite(phy, reg, tmp);
+	spin_unlock_irqrestore(&switch_lock, flags);
+
+	if (status == MV_OK)
+		return GT_TRUE;
+
+	return GT_FALSE;
+}
+#endif
 
 static int mv_switch_port_db_get(int port)
 {
@@ -174,7 +212,8 @@ int mv_switch_tag_get(MV_MUX_TAG *tag, MV_SWITCH_PRESET_TYPE preset, int vid, MV
 					tag->rx_tag_mask.mh = MV_16BIT_BE(0xf000);
 					tag->tx_tag.mh = MV_16BIT_BE(((vid + p) << 12) | (1 << p));
 				} else if (tag_mode == MV_TAG_TYPE_DSA) {
-					tag->rx_tag_ptrn.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid + p));
+					tag->rx_tag_ptrn.dsa =
+						MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid + p));
 					tag->rx_tag_mask.dsa = MV_32BIT_BE(0xff000f00);
 					tag->tx_tag.dsa = MV_32BIT_BE(0xc8000000 | MV_SWITCH_GROUP_VLAN_ID(vid + p));
 				}
@@ -350,6 +389,8 @@ int mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, uns
 	GT_VTU_ENTRY vtu_entry;
 	unsigned int p;
 
+	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+	vtu_entry.sid = 1;
 	vtu_entry.vid = vlan_id;
 	vtu_entry.DBNum = db_num;
 	vtu_entry.vidPriOverride = GT_FALSE;
@@ -440,7 +481,9 @@ int mv_switch_vlan_set(u16 vlan_grp_id, u16 port_map)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* set vtu with group vlan id (used in tx) */
-	if (mv_switch_vlan_in_vtu_set(vlan_grp_id, MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id), port_map | (1 << qd_cpu_port)) != 0)
+	if (mv_switch_vlan_in_vtu_set(vlan_grp_id,
+					MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
+					 port_map | (1 << qd_cpu_port)) != 0)
 		printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 
 	/* set vtu with each port private vlan id (used in rx) */
@@ -596,6 +639,7 @@ int mv_switch_jumbo_mode_set(int max_size)
 int mv_switch_load(struct mv_switch_pdata *plat_data)
 {
 	int p;
+	GT_STU_ENTRY	stuEntry;
 
 	printk(KERN_ERR "  o Loading Switch QuarterDeck driver\n");
 
@@ -614,7 +658,7 @@ int mv_switch_load(struct mv_switch_pdata *plat_data)
 	qd_cfg.BSPFunctions.semDelete = NULL;
 	qd_cfg.BSPFunctions.semTake = NULL;
 	qd_cfg.BSPFunctions.semGive = NULL;
-	qd_cfg.initPorts = GT_FALSE;
+	qd_cfg.initPorts = GT_TRUE;
 	qd_cfg.cpuPortNum = plat_data->switch_cpu_port;
 	if (plat_data->smi_scan_mode == 1) {
 		qd_cfg.mode.baseAddr = 0;
@@ -632,6 +676,11 @@ int mv_switch_load(struct mv_switch_pdata *plat_data)
 	qd_dev = &qddev;
 	qd_cpu_port = qd_cfg.cpuPortNum;
 
+	/* WA - Create dummy entry in STU table  */
+	memset(&stuEntry, 0, sizeof(GT_STU_ENTRY));
+	stuEntry.sid = 1; /* required: ((sid > 0) && (sid < 0x3F)) */
+	gstuAddEntry(qd_dev, &stuEntry);
+
 	printk(KERN_ERR "    o Device ID     : 0x%x\n", qd_dev->deviceId);
 	printk(KERN_ERR "    o No. of Ports  : %d\n", qd_dev->numOfPorts);
 	printk(KERN_ERR "    o CPU Port      : %ld\n", qd_dev->cpuPortNum);
@@ -842,13 +891,16 @@ int mv_switch_init(struct mv_switch_pdata *plat_data)
 	case GT_88E6161:
 	case GT_88E6165:
 	case GT_88E6171:
+	case GT_88E6172:
+	case GT_88E6176:
 	case GT_88E6351:
 	case GT_88E6352:
 		break;		/* do nothing */
 
 	default:
 		for (p = 0; p < qd_dev->numOfPorts; p++) {
-			if ((p != qd_cpu_port) && ((p))) {
+			if ((p != qd_cpu_port) &&
+				MV_BIT_CHECK(plat_data->connected_port_mask, p)) {
 				if (gprtSetPhyReg(qd_dev, p, 22, 0x1FFA)) {
 					/* Configure Register 22 LED0 to 0xA for Link/Act */
 					printk(KERN_ERR "gprtSetPhyReg failed (port=%d)\n", p);
@@ -1014,6 +1066,7 @@ int mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, in
 
 void mv_switch_interrupt_mask(void)
 {
+#ifdef CONFIG_AVANTA_LP
 	MV_U32 reg;
 
 	reg = MV_REG_READ(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/);
@@ -1021,10 +1074,12 @@ void mv_switch_interrupt_mask(void)
 	reg &= ~0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
 
 	MV_REG_WRITE(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/, reg);
+#endif
 }
 
 void mv_switch_interrupt_unmask(void)
 {
+#ifdef CONFIG_AVANTA_LP
 	MV_U32 reg;
 
 	reg = MV_REG_READ(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/);
@@ -1032,10 +1087,12 @@ void mv_switch_interrupt_unmask(void)
 	reg |= 0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
 
 	MV_REG_WRITE(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/, reg);
+#endif
 }
 
 void mv_switch_interrupt_clear(void)
 {
+#ifdef CONFIG_AVANTA_LP
 	MV_U32 reg;
 
 	reg = MV_REG_READ(0x18950/*MV_ETHCOMP_INT_MAIN_CAUSE_REG*/);
@@ -1043,9 +1100,10 @@ void mv_switch_interrupt_clear(void)
 	reg &= ~0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
 
 	MV_REG_WRITE(0x18950/*MV_ETHCOMP_INT_MAIN_CAUSE_REG*/, reg);
+#endif
 }
 
-unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
+static unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
 {
 	unsigned int p;
 	static int link_init_done = 0;
@@ -1119,7 +1177,6 @@ unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
 
 	return connected_phys_mask;
 
-	return 0;
 }
 
 int mv_switch_tos_get(unsigned char tos)
@@ -1632,7 +1689,6 @@ int mv_switch_port_del(int switch_port)
 static int mv_switch_probe(struct platform_device *pdev)
 {
 	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
-
 	/* load switch driver, force link on cpu port */
 	mv_switch_load(plat_data);
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index fb64339..aa00147 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -72,7 +72,8 @@ int     mv_switch_all_multicasts_del(int db_num);
 int     mv_switch_port_add(int switch_port, u16 vlan_grp_id);
 int     mv_switch_port_del(int switch_port);
 
-int		mv_switch_default_config_get(MV_TAG_TYPE *tag_mode, MV_SWITCH_PRESET_TYPE *preset, int *vid, int *gbe_port);
+int		mv_switch_default_config_get(MV_TAG_TYPE *tag_mode,
+						MV_SWITCH_PRESET_TYPE *preset, int *vid, int *gbe_port);
 int		mv_switch_tag_get(MV_MUX_TAG *tag, MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int db);
 unsigned int	mv_switch_group_map_get(void);
 int		mv_switch_group_restart_autoneg(int db);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
index 0b248fd8..90babe0 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -1155,7 +1155,7 @@ MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool)
 }
 /*-------------------------------------------------------------------------------*/
 
-MV_STATUS mvPp2MhSet(int port, MV_PP2_MH_MODE mh)
+MV_STATUS mvPp2MhSet(int port, MV_TAG_TYPE mh)
 {
 	MV_U32 regVal;
 
@@ -1163,18 +1163,18 @@ MV_STATUS mvPp2MhSet(int port, MV_PP2_MH_MODE mh)
 	/* Clear relevant fields */
 	regVal &= ~(MV_PP2_DSA_EN_MASK | MV_PP2_MH_EN_MASK);
 	switch (mh) {
-	case MV_PP2_MH_NONE:
+	case MV_TAG_TYPE_NONE:
 		break;
 
-	case MV_PP2_MH:
+	case MV_TAG_TYPE_MH:
 		regVal |= MV_PP2_MH_EN_MASK;
 		break;
 
-	case MV_PP2_DSA:
+	case MV_TAG_TYPE_DSA:
 		regVal |= MV_PP2_DSA_EN_MASK;
 		break;
 
-	case MV_PP2_DSA_EXT:
+	case MV_TAG_TYPE_EDSA:
 		regVal |= MV_PP2_DSA_EXTENDED;
 
 	default:
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index 9e724fb..162d081 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -67,6 +67,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "mvTypes.h"
 #include "mvCommon.h"
+#include "mv802_3.h"
 #include "mvOs.h"
 #include "mvSysEthConfig.h"
 #include "mvPp2GbeRegs.h"
@@ -100,13 +101,6 @@ typedef struct eth_pbuf {
 	MV_U16 vlanId;
 } MV_ETH_PKT;
 
-typedef enum {
-	MV_PP2_MH_NONE = 0,
-	MV_PP2_MH = 1,
-	MV_PP2_DSA = 2,
-	MV_PP2_DSA_EXT = 3
-} MV_PP2_MH_MODE;
-
 /************************** Port + Queue Control Structures ******************************/
 typedef struct {
 	char *pFirst;
@@ -583,7 +577,7 @@ MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize);
 MV_STATUS mvPp2RxqBmPoolSet(int port, int rxq, int shortPool, int longPool);
 MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool);
 
-MV_STATUS mvPp2MhSet(int port, MV_PP2_MH_MODE mh);
+MV_STATUS mvPp2MhSet(int port, MV_TAG_TYPE mh);
 
 MV_STATUS mvPp2RxFifoInit(int portNum);
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
index 8109ddd..cdaf528 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
@@ -990,7 +990,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 
 	switch (type) {
 
-	case MV_PP2_DSA_EXT:
+	case MV_TAG_TYPE_EDSA:
 		/* Add port to EDSA entries */
 		mvPp2PrsDsaTagSet(port, 1, TAGGED, EDSA);
 		mvPp2PrsDsaTagSet(port, 1, UNTAGGED, EDSA);
@@ -1000,7 +1000,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 
 		break;
 
-	case MV_PP2_DSA:
+	case MV_TAG_TYPE_DSA:
 		/* Add port to DSA entries */
 		mvPp2PrsDsaTagSet(port, 1, TAGGED, DSA);
 		mvPp2PrsDsaTagSet(port, 1, UNTAGGED, DSA);
@@ -1011,8 +1011,8 @@ int mvPp2PrsTagModeSet(int port, int type)
 
 		break;
 
-	case MV_PP2_MH:
-	case MV_PP2_MH_NONE:
+	case MV_TAG_TYPE_MH:
+	case MV_TAG_TYPE_NONE:
 
 		/* remove port form EDSA and DSA entries */
 		mvPp2PrsDsaTagSet(port, 0, TAGGED, DSA);
@@ -1023,7 +1023,7 @@ int mvPp2PrsTagModeSet(int port, int type)
 		break;
 
 	default:
-		POS_RANGE_VALIDATE(type, MV_PP2_DSA_EXT);
+		POS_RANGE_VALIDATE(type, MV_TAG_TYPE_EDSA);
 	}
 
 	return MV_OK;
-- 
1.7.5.4

