From 21cad9b896cd20411631a373467a3d8187ee6b46 Mon Sep 17 00:00:00 2001
From: Piotr Ziecik <kosmo@semihalf.com>
Date: Wed, 5 Feb 2014 10:49:08 +0100
Subject: [PATCH 1378/1825] alp: ipc_dfev: Introduce "ipc_handle" parameter to
 ipc_dfev API calls.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9ad14007b8bf734d0eb3d922fe0c741f6eb95397

	The newly introduced IPC handle parameter allows to distingish
	sides of IPC connection in non-AMP environment.

	To maitain compatibility the handle was also added to AMP implementation,
	in which it is not used.

Change-Id: I6a4283d8eb2eeaa8ebd92c0aea4af4208d8fddbf
Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5835
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/include/plat/ipc_dfev.h       |   44 +++++++------
 .../mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c        |   66 +++++++++++--------
 .../mv_drivers_lsp/mv_phone/slic/dfev_if.c         |   24 ++++---
 3 files changed, 75 insertions(+), 59 deletions(-)

diff --git a/arch/arm/plat-armada/include/plat/ipc_dfev.h b/arch/arm/plat-armada/include/plat/ipc_dfev.h
index 5a20eaf..34e9058 100644
--- a/arch/arm/plat-armada/include/plat/ipc_dfev.h
+++ b/arch/arm/plat-armada/include/plat/ipc_dfev.h
@@ -26,6 +26,8 @@
 /* Maximum buffer size for wideband, 2-channel audio */
 #define IPC_DFEV_DATA_BUFFER_SIZE	(2 * 2 * IPC_DFEV_DATA_BUFFER_SAMPLES)
 
+struct ipc_dfev_ctrl_handle;
+
 struct ipc_dfev_ctrl_msg {
 	unsigned int	size;
 	unsigned char	payload[IPC_DFEV_CTRL_BUFFER_SIZE];
@@ -36,6 +38,8 @@ struct ipc_dfev_ctrl_ops {
 	void (*ipc_dfev_event_callback)(struct ipc_dfev_ctrl_msg *msg);
 };
 
+struct ipc_dfev_data_handle;
+
 struct ipc_dfev_data_msg {
 	unsigned int	wideband;
 	unsigned short	samples[IPC_DFEV_DATA_BUFFER_SIZE];
@@ -52,31 +56,31 @@ enum ipc_dfev_mode {
 };
 
 /* Control Path Interface */
-extern int ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+extern struct ipc_dfev_ctrl_handle *ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
 				struct ipc_dfev_ctrl_ops *ipc_dfev_ctrl_ops);
-extern void ipc_dfev_ctrl_exit(void);
-extern int ipc_dfev_ctrl_poll(void);
+extern void ipc_dfev_ctrl_exit(struct ipc_dfev_ctrl_handle *handle);
+extern int ipc_dfev_ctrl_poll(struct ipc_dfev_ctrl_handle *handle);
 
-extern struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(void);
-extern void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_msg *msg);
+extern struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(struct ipc_dfev_ctrl_handle *handle);
+extern void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg);
 
-extern int ipc_dfev_send_command(struct ipc_dfev_ctrl_msg *msg);
-extern int ipc_dfev_send_event(struct ipc_dfev_ctrl_msg *msg);
+extern int ipc_dfev_send_command(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg);
+extern int ipc_dfev_send_event(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg);
 
 /* Data Path Interface */
-extern int ipc_dfev_data_init(enum ipc_dfev_mode mode,
+extern struct ipc_dfev_data_handle *ipc_dfev_data_init(enum ipc_dfev_mode mode,
 				struct ipc_dfev_data_ops *ipc_dfev_data_ops);
-extern void ipc_dfev_data_exit(void);
-extern int ipc_dfev_data_poll_rx(void);
-extern int ipc_dfev_data_poll_tx(void);
-extern int ipc_dfev_data_poll_return(void);
-
-extern struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(void);
-extern void ipc_dfev_data_msg_put(struct ipc_dfev_data_msg *msg);
-
-extern int ipc_dfev_send_rx(struct ipc_dfev_data_msg *msg);
-extern int ipc_dfev_send_rx_return(struct ipc_dfev_data_msg *msg);
-extern int ipc_dfev_send_tx(struct ipc_dfev_data_msg *msg);
-extern int ipc_dfev_send_tx_return(struct ipc_dfev_data_msg *msg);
+extern void ipc_dfev_data_exit(struct ipc_dfev_data_handle *handle);
+extern int ipc_dfev_data_poll_rx(struct ipc_dfev_data_handle *handle);
+extern int ipc_dfev_data_poll_tx(struct ipc_dfev_data_handle *handle);
+extern int ipc_dfev_data_poll_return(struct ipc_dfev_data_handle *handle);
+
+extern struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(struct ipc_dfev_data_handle *handle);
+extern void ipc_dfev_data_msg_put(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg);
+
+extern int ipc_dfev_send_rx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_rx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_tx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_tx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg);
 
 #endif /* _IPC_DFEV_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c
index 842e09b..3d91047 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c
@@ -80,12 +80,21 @@ struct ipc_dfev_data_pool {
 	struct ipc_dfev_data_buffer	*fifo[IPC_DFEV_DATA_BUFFERS];
 };
 
+static struct ipc_dfev_ctrl_handle {
+	int				dummy;
+} ipc_dfev_ctrl_handle;
+
+static struct ipc_dfev_data_handle {
+	int				dummy;
+} ipc_dfev_data_handle;
+
 static struct ipc_dfev_ctrl_ops *ipc_dfev_ctrl_ops;
 static struct ipc_dfev_data_ops *ipc_dfev_data_ops;
 
 static struct ipc_dfev_ctrl_pool ipc_dfev_ctrl_pool;
 static struct ipc_dfev_data_pool ipc_dfev_data_pool;
 
+
 #define ipc_dfev_init_pool(ch, perror)					\
 	do {								\
 		unsigned int i;						\
@@ -175,11 +184,11 @@ static int ipc_dfev_open_channel(MV_U32 linkId, MV_U32 chId,
 /*
  * Control Path API
  */
-int ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+struct ipc_dfev_ctrl_handle *ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
 					struct ipc_dfev_ctrl_ops *ctrl_ops)
 {
 	if (ctrl_ops == NULL)
-		return -EINVAL;
+		return NULL;
 
 	/* Wait for IPC link */
 	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID))
@@ -193,27 +202,28 @@ int ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
 		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
 		break;
 	default:
-		return -EINVAL;
+		return NULL;
 	}
 
 	ipc_dfev_ctrl_ops = ctrl_ops;
-	return 0;
+
+	return &ipc_dfev_ctrl_handle;
 }
 EXPORT_SYMBOL(ipc_dfev_ctrl_init);
 
-void ipc_dfev_ctrl_exit(void)
+void ipc_dfev_ctrl_exit(struct ipc_dfev_ctrl_handle *handle)
 {
 	ipc_dfev_ctrl_ops = NULL;
 }
 EXPORT_SYMBOL(ipc_dfev_ctrl_exit);
 
-int ipc_dfev_ctrl_poll(void)
+int ipc_dfev_ctrl_poll(struct ipc_dfev_ctrl_handle *handle)
 {
 	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
 }
 EXPORT_SYMBOL(ipc_dfev_ctrl_poll);
 
-struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(void)
+struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(struct ipc_dfev_ctrl_handle *handle)
 {
 	struct ipc_dfev_ctrl_buffer *buffer = NULL;
 
@@ -226,7 +236,7 @@ struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(void)
 }
 EXPORT_SYMBOL(ipc_dfev_ctrl_msg_get);
 
-void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_msg *msg)
+void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
 {
 	struct ipc_dfev_ctrl_buffer *buffer;
 
@@ -235,13 +245,13 @@ void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_msg *msg)
 }
 EXPORT_SYMBOL(ipc_dfev_ctrl_msg_put);
 
-int ipc_dfev_send_command(struct ipc_dfev_ctrl_msg *msg)
+int ipc_dfev_send_command(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_COMMAND, IPC_DFEV_CTRL_CHAN_ID, msg);
 }
 EXPORT_SYMBOL(ipc_dfev_send_command);
 
-int ipc_dfev_send_event(struct ipc_dfev_ctrl_msg *msg)
+int ipc_dfev_send_event(struct ipc_dfev_ctrl_handle *handle, struct ipc_dfev_ctrl_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_EVENT, IPC_DFEV_CTRL_CHAN_ID, msg);
 }
@@ -258,13 +268,13 @@ static int ipc_dfev_ctrl_msg_handler(MV_IPC_MSG *msg)
 		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_command_callback)
 			ipc_dfev_ctrl_ops->ipc_dfev_command_callback(message);
 		else
-			ipc_dfev_ctrl_msg_put(message);
+			ipc_dfev_ctrl_msg_put(NULL, message);
 		break;
 	case IPC_DFEV_MSG_TYPE_EVENT:
 		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_event_callback)
 			ipc_dfev_ctrl_ops->ipc_dfev_event_callback(message);
 		else
-			ipc_dfev_ctrl_msg_put(message);
+			ipc_dfev_ctrl_msg_put(NULL, message);
 		break;
 	default:
 		pr_err("IPC DFEV: Unknown ctrl message type %u!\n", msg->type);
@@ -277,11 +287,11 @@ static int ipc_dfev_ctrl_msg_handler(MV_IPC_MSG *msg)
 /*
  * Data Path API
  */
-int ipc_dfev_data_init(enum ipc_dfev_mode mode,
+struct ipc_dfev_data_handle *ipc_dfev_data_init(enum ipc_dfev_mode mode,
 					struct ipc_dfev_data_ops *data_ops)
 {
 	if (data_ops == NULL)
-		return -EINVAL;
+		return NULL;
 
 	/* Wait for IPC link */
 	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID) ||
@@ -302,21 +312,21 @@ int ipc_dfev_data_init(enum ipc_dfev_mode mode,
 		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
 		break;
 	default:
-		return -EINVAL;
+		return NULL;
 	}
 
 	ipc_dfev_data_ops = data_ops;
-	return 0;
+	return &ipc_dfev_data_handle;
 }
 EXPORT_SYMBOL(ipc_dfev_data_init);
 
-void ipc_dfev_data_exit(void)
+void ipc_dfev_data_exit(struct ipc_dfev_data_handle *handle)
 {
 	ipc_dfev_data_ops = NULL;
 }
 EXPORT_SYMBOL(ipc_dfev_data_exit);
 
-struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(void)
+struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(struct ipc_dfev_data_handle *handle)
 {
 	struct ipc_dfev_data_buffer *buffer = NULL;
 
@@ -329,7 +339,7 @@ struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(void)
 }
 EXPORT_SYMBOL(ipc_dfev_data_msg_get);
 
-void ipc_dfev_data_msg_put(struct ipc_dfev_data_msg *msg)
+void ipc_dfev_data_msg_put(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
 {
 	struct ipc_dfev_data_buffer *buffer;
 
@@ -338,43 +348,43 @@ void ipc_dfev_data_msg_put(struct ipc_dfev_data_msg *msg)
 }
 EXPORT_SYMBOL(ipc_dfev_data_msg_put);
 
-int ipc_dfev_send_tx(struct ipc_dfev_data_msg *msg)
+int ipc_dfev_send_tx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_TX_CHAN_ID, msg);
 }
 EXPORT_SYMBOL(ipc_dfev_send_tx);
 
-int ipc_dfev_send_rx(struct ipc_dfev_data_msg *msg)
+int ipc_dfev_send_rx(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RX_CHAN_ID, msg);
 }
 EXPORT_SYMBOL(ipc_dfev_send_rx);
 
-int ipc_dfev_send_tx_return(struct ipc_dfev_data_msg *msg)
+int ipc_dfev_send_tx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
 }
 EXPORT_SYMBOL(ipc_dfev_send_tx_return);
 
-int ipc_dfev_send_rx_return(struct ipc_dfev_data_msg *msg)
+int ipc_dfev_send_rx_return(struct ipc_dfev_data_handle *handle, struct ipc_dfev_data_msg *msg)
 {
 	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
 }
 EXPORT_SYMBOL(ipc_dfev_send_rx_return);
 
-int ipc_dfev_data_poll_rx(void)
+int ipc_dfev_data_poll_rx(struct ipc_dfev_data_handle *handle)
 {
 	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
 }
 EXPORT_SYMBOL(ipc_dfev_data_poll_rx);
 
-int ipc_dfev_data_poll_tx(void)
+int ipc_dfev_data_poll_tx(struct ipc_dfev_data_handle *handle)
 {
 	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
 }
 EXPORT_SYMBOL(ipc_dfev_data_poll_tx);
 
-int ipc_dfev_data_poll_return(void)
+int ipc_dfev_data_poll_return(struct ipc_dfev_data_handle *handle)
 {
 	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
 }
@@ -391,13 +401,13 @@ static void ipc_dfev_data_handler(MV_IPC_MSG *msg)
 		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_rx_callback)
 			ipc_dfev_data_ops->ipc_dfev_rx_callback(message);
 		else
-			ipc_dfev_data_msg_put(message);
+			ipc_dfev_data_msg_put(NULL, message);
 		break;
 	case IPC_DFEV_MSG_TYPE_TX:
 		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_tx_callback)
 			ipc_dfev_data_ops->ipc_dfev_tx_callback(message);
 		else
-			ipc_dfev_data_msg_put(message);
+			ipc_dfev_data_msg_put(NULL, message);
 		break;
 	default:
 		pr_err("IPC DFEV: Unknown data message type %u!\n", msg->type);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/dfev_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/dfev_if.c
index 5dd6b57..de4a9b5 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/dfev_if.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/dfev_if.c
@@ -68,6 +68,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <plat/ipc_dfev.h>
 #include "../tdm/tal.h"
 
+static struct ipc_dfev_data_handle *ipc_handle;
 static int pcm_active;
 static int wideband;
 
@@ -75,12 +76,12 @@ static void dfev_if_rx_callback(struct ipc_dfev_data_msg *msg)
 {
 	if (pcm_active) {
 		tal_mmp_rx((unsigned char *)msg->samples, sizeof(msg->samples));
-		if (ipc_dfev_send_rx(msg)) {
+		if (ipc_dfev_send_rx(ipc_handle, msg)) {
 			pr_err("%s(): Data RX message lost!\n", __func__);
-			ipc_dfev_data_msg_put(msg);
+			ipc_dfev_data_msg_put(ipc_handle, msg);
 		}
 	} else {
-		ipc_dfev_data_msg_put(msg);
+		ipc_dfev_data_msg_put(ipc_handle, msg);
 	}
 }
 
@@ -88,12 +89,12 @@ static void dfev_if_tx_callback(struct ipc_dfev_data_msg *msg)
 {
 	if (pcm_active) {
 		tal_mmp_tx((unsigned char *)msg->samples, sizeof(msg->samples));
-		if (ipc_dfev_send_tx(msg)) {
+		if (ipc_dfev_send_tx(ipc_handle, msg)) {
 			pr_err("%s(): Data TX message lost!\n", __func__);
-			ipc_dfev_data_msg_put(msg);
+			ipc_dfev_data_msg_put(ipc_handle, msg);
 		}
 	} else {
-		ipc_dfev_data_msg_put(msg);
+		ipc_dfev_data_msg_put(ipc_handle, msg);
 	}
 }
 
@@ -118,7 +119,8 @@ static MV_STATUS dfev_if_init(tal_params_t *tal_params)
 		return MV_ERROR;
 	}
 
-	if (ipc_dfev_data_init(IPC_DFEV_MODE_INTERRUPT, &dfev_if_data_ops))
+	ipc_handle = ipc_dfev_data_init(IPC_DFEV_MODE_INTERRUPT, &dfev_if_data_ops);
+	if (ipc_handle == NULL)
 		return MV_ERROR;
 
 	return MV_OK;
@@ -126,7 +128,7 @@ static MV_STATUS dfev_if_init(tal_params_t *tal_params)
 
 static void dfev_if_exit(void)
 {
-	ipc_dfev_data_exit();
+	ipc_dfev_data_exit(ipc_handle);
 }
 
 static void dfev_if_pcm_start(void)
@@ -135,7 +137,7 @@ static void dfev_if_pcm_start(void)
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(msg); i++) {
-		msg[i] = ipc_dfev_data_msg_get();
+		msg[i] = ipc_dfev_data_msg_get(ipc_handle);
 		if (!msg[i]) {
 			pr_err("%s(): Data message allocation error!\n", __func__);
 			break;
@@ -147,8 +149,8 @@ static void dfev_if_pcm_start(void)
 
 	pcm_active = 1;
 
-	ipc_dfev_send_rx(msg[1]);
-	ipc_dfev_send_tx(msg[0]);
+	ipc_dfev_send_rx(ipc_handle, msg[1]);
+	ipc_dfev_send_tx(ipc_handle, msg[0]);
 
 	dfev_if_rx_callback(msg[2]);
 	dfev_if_tx_callback(msg[3]);
-- 
1.7.5.4

