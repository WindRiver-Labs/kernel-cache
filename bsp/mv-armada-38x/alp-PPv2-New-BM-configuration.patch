From 082bae9f2e8f8562eb39826959c653a3d9412b94 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Wed, 3 Jul 2013 14:25:38 +0300
Subject: [PATCH 0764/1825] alp: PPv2: New BM configuration

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit c54b2998627e51eb4ec4b451e230f3522c7d6b41

	- Support new BM configuration in compile and run time
	- Two new modes for pool assignment for GBE ports
		- Per port mode
		- Separate SWF and HWF mode
	- Add runtime API to change the default configuration

Change-Id: I35c7f97f891f4379c4de6ff635d021d8cb997179
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2409
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |  390 +--------
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    1 -
 .../mv_drivers_lsp/mv_pp2/bm/mv_eth_bm.c           |  276 ------
 .../mv_pp2/net_dev/mv_eth_bm_sysfs.c               |   47 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  904 +++++++++++---------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |  102 ++-
 6 files changed, 622 insertions(+), 1098 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/bm/mv_eth_bm.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index 3a92148..21d54bc 100755
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -25,381 +25,41 @@ config MV_ETH_HWF
 
 menu "BM configuration"
 
-config MV_ETH_BM_0_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #0"
-	default 0
-	---help---
-	0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_1_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #1"
-	default 0
-        ---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_2_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #2"
-	default 0
-	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_3_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #3"
-	default 256
-	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_4_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #4"
-	default 0
-	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_5_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #5"
-	default 0
-	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_6_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #6"
-	default 0
-	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
-
-config MV_ETH_BM_7_PKT_SIZE
-	depends on MV_ETH_PP2
-	int "Packet size [bytes] can use buffers from pool #7"
-	default 256
+choice
+	prompt "BM pool assignment mode"
+	default MV_ETH_BM_SWF_HWF_MODE
 	---help---
-        0 - means that packet size for the pool will be defined accordingly
-        with MTU of the port that use this pool.
+	Determines how BM pools are divided among GBE ports
 
-menuconfig  MV_ETH_BM_PORT_0
-        depends on MV_ETH_PP2
-        bool "BM configuration for GbE #0"
-        default y
-        ---help---
-
-config  MV_ETH_BM_PORT_0_LONG_POOL
-	int "Long BM pool for GbE #0"
-	depends on MV_ETH_BM_PORT_0
-	range -1 7
-	default 0
+config MV_ETH_BM_SWF_HWF_MODE
+	bool "SWF / HWF seperation"
 	---help---
-	BM pool to be used for GbE #0 port to process long packets
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_PORT_0_SHORT_POOL
-        int "Short BM pool for GbE #0"
-        depends on MV_ETH_BM_PORT_0
-        range 0 7
-        default 3
-	---help---
-	BM pool to be used for GbE #0 port to process short packets
-
-config  MV_ETH_BM_PORT_0_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #0"
-        depends on MV_ETH_BM_PORT_0
-        range 128 16384
-        default 2048
-        ---help---
-	Number of long buffers allocated for this port.
+	BM pools are not shared between SWF and HWF.
+	Short pools are shared between all ports.
+	When BM pool is used only by HWF, then SW can allocate smaller buffers for same packet size
+	Configuration is changable in Run-Time
 
-config  MV_ETH_BM_PORT_0_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #0"
-        depends on MV_ETH_BM_PORT_0 && (MV_ETH_BM_PORT_0_LONG_POOL != MV_ETH_BM_PORT_0_SHORT_POOL)
-        range 128 16384
-        default 3072
+config MV_ETH_BM_PER_PORT_MODE
+	bool "Per Port"
 	---help---
-        Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_PORT_1
-        depends on MV_ETH_PP2
-        bool "BM configuration for GbE #1"
-        default y
-        ---help---
-
-config  MV_ETH_BM_PORT_1_LONG_POOL
-        int "Long BM pool for GbE #1"
-        depends on MV_ETH_BM_PORT_1
-	range -1 7
-        default 1
-        ---help---
-        BM pool to be used for GbE #1 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_PORT_1_SHORT_POOL
-        int "Short BM pool for GbE #1"
-        depends on MV_ETH_BM_PORT_1
-        range 0 7
-        default 3
-        ---help---
-        BM pool to be used for GbE #1 port to process short packets.
-
-config  MV_ETH_BM_PORT_1_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #1"
-        depends on MV_ETH_BM_PORT_1
-        range 128 16384
-        default 2048
-        ---help---
-	Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_PORT_1_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #1"
-        depends on MV_ETH_BM_PORT_1 && (MV_ETH_BM_PORT_1_LONG_POOL != MV_ETH_BM_PORT_1_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-	Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_PORT_2
-        depends on MV_ETH_PP2
-        bool "BM configuration for GbE #2"
-        default y
-        ---help---
-
-config  MV_ETH_BM_PORT_2_LONG_POOL
-        int "Long BM pool for GbE #2"
-        depends on MV_ETH_BM_PORT_2
-        range -1 7
-        default 2
-        ---help---
-        BM pool to be used for GbE #2 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_PORT_2_SHORT_POOL
-        int "Short BM pool for GbE #2"
-        depends on MV_ETH_BM_PORT_2
-        range 0 7
-        default 3
-        ---help---
-	BM pool to be used for GbE #2 port to process short packets.
-
-config  MV_ETH_BM_PORT_2_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #2"
-        depends on MV_ETH_BM_PORT_2
-        range 128 16384
-        default 2048
-        ---help---
-        Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_PORT_2_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #2"
-        depends on MV_ETH_BM_PORT_2 && (MV_ETH_BM_PORT_2_LONG_POOL != MV_ETH_BM_PORT_2_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-        Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_PORT_3
-        depends on MV_ETH_PP2
-        bool "BM configuration for GbE #3"
-        default y
-        ---help---
-
-config  MV_ETH_BM_PORT_3_LONG_POOL
-        int "Long BM pool for GbE #3"
-        depends on MV_ETH_BM_PORT_3
-        range -1 7
-        default 2
-        ---help---
-        BM pool to be used for GbE #3 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_PORT_3_SHORT_POOL
-        int "Short BM pool for GbE #3"
-        depends on MV_ETH_BM_PORT_3
-        range 0 7
-        default 3
-        ---help---
-	BM pool to be used for GbE #3 port to process short packets.
-
-config  MV_ETH_BM_PORT_3_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #3"
-        depends on MV_ETH_BM_PORT_3
-        range 128 16384
-        default 2048
-        ---help---
-        Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_PORT_3_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #3"
-        depends on MV_ETH_BM_PORT_3 && (MV_ETH_BM_PORT_3_LONG_POOL != MV_ETH_BM_PORT_3_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-        Number of short buffers allocated for this port.
+	BM pools are shared beteen HWF and SWF.
+	BM pools are not shared between different ports.
+	When BM pool is used only by HWF, then SW can allocate smaller buffers for same packet size
+	Configuration is changable in Run-Time
 
-menuconfig  MV_ETH_BM_HWF_PORT_0
-        depends on (MV_ETH_PP2 && MV_ETH_HWF)
-        bool "BM HWF configuration for GbE #0"
-        default y
-        ---help---
+endchoice
 
-config  MV_ETH_BM_HWF_PORT_0_LONG_POOL
-	int "Long BM pool for GbE #0"
-	depends on MV_ETH_BM_HWF_PORT_0
-	range -1 7
-	default 4
+config MV_ETH_BM_LONG_BUF_NUM
+	int "number of buffers for BM long pool"
+	default 1024
 	---help---
-	BM pool to be used for GbE #0 port to process long packets
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_HWF_PORT_0_SHORT_POOL
-        int "Short BM pool for GbE #0"
-        depends on MV_ETH_BM_HWF_PORT_0
-        range 0 7
-        default 7
-	---help---
-	BM pool to be used for GbE #0 port to process short packets
-
-config  MV_ETH_BM_HWF_PORT_0_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #0"
-        depends on MV_ETH_BM_HWF_PORT_0
-        range 128 16384
-        default 2048
-        ---help---
-	Number of long buffers allocated for this port.
+	The number of long buffers is relevant for all long BM pools
 
-config  MV_ETH_BM_HWF_PORT_0_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #0"
-        depends on MV_ETH_BM_HWF_PORT_0 && (MV_ETH_BM_HWF_PORT_0_LONG_POOL != MV_ETH_BM_HWF_PORT_0_SHORT_POOL)
-        range 128 16384
-        default 3072
+config MV_ETH_BM_SHORT_BUF_NUM
+	int "number of buffers for BM short pool"
+	default 2048
 	---help---
-        Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_HWF_PORT_1
-        depends on (MV_ETH_PP2 && MV_ETH_HWF)
-        bool "BM HWF configuration for GbE #1"
-        default y
-        ---help---
-
-config  MV_ETH_BM_HWF_PORT_1_LONG_POOL
-        int "Long BM pool for GbE #1"
-        depends on MV_ETH_BM_HWF_PORT_1
-	range -1 7
-        default 5
-        ---help---
-        BM pool to be used for GbE #1 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_HWF_PORT_1_SHORT_POOL
-        int "Short BM pool for GbE #1"
-        depends on MV_ETH_BM_HWF_PORT_1
-        range 0 7
-        default 7
-        ---help---
-        BM pool to be used for GbE #1 port to process short packets.
-
-config  MV_ETH_BM_HWF_PORT_1_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #1"
-        depends on MV_ETH_BM_HWF_PORT_1
-        range 128 16384
-        default 2048
-        ---help---
-	Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_HWF_PORT_1_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #1"
-        depends on MV_ETH_BM_HWF_PORT_1 && (MV_ETH_BM_HWF_PORT_1_LONG_POOL != MV_ETH_BM_HWF_PORT_1_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-	Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_HWF_PORT_2
-        depends on (MV_ETH_PP2 && MV_ETH_HWF)
-        bool "BM HWF configuration for GbE #2"
-        default y
-        ---help---
-
-config  MV_ETH_BM_HWF_PORT_2_LONG_POOL
-        int "Long BM pool for GbE #2"
-        depends on MV_ETH_BM_HWF_PORT_2
-        range -1 7
-        default 6
-        ---help---
-        BM pool to be used for GbE #2 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_HWF_PORT_2_SHORT_POOL
-        int "Short BM pool for GbE #2"
-        depends on MV_ETH_BM_HWF_PORT_2
-        range 0 7
-        default 7
-        ---help---
-	BM pool to be used for GbE #2 port to process short packets.
-
-config  MV_ETH_BM_HWF_PORT_2_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #2"
-        depends on MV_ETH_BM_HWF_PORT_2
-        range 128 16384
-        default 2048
-        ---help---
-        Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_HWF_PORT_2_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #2"
-        depends on MV_ETH_BM_HWF_PORT_2 && (MV_ETH_BM_HWF_PORT_2_LONG_POOL != MV_ETH_BM_HWF_PORT_2_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-        Number of short buffers allocated for this port.
-
-menuconfig  MV_ETH_BM_HWF_PORT_3
-        depends on (MV_ETH_PP2 && MV_ETH_HWF)
-        bool "BM HWF configuration for GbE #3"
-        default y
-        ---help---
-
-config  MV_ETH_BM_HWF_PORT_3_LONG_POOL
-        int "Long BM pool for GbE #3"
-        depends on MV_ETH_BM_HWF_PORT_3
-        range -1 7
-        default 6
-        ---help---
-        BM pool to be used for GbE #3 port to process long packets.
-	-1 means that port will choose BM pool closest to required buffers size.
-
-config  MV_ETH_BM_HWF_PORT_3_SHORT_POOL
-        int "Short BM pool for GbE #3"
-        depends on MV_ETH_BM_HWF_PORT_3
-        range 0 7
-        default 7
-        ---help---
-	BM pool to be used for GbE #3 port to process short packets.
-
-config  MV_ETH_BM_HWF_PORT_3_LONG_BUF_NUM
-        int "Number of buffers for Long pool of GbE #3"
-        depends on MV_ETH_BM_HWF_PORT_3
-        range 128 16384
-        default 2048
-        ---help---
-        Number of long buffers allocated for this port.
-
-config  MV_ETH_BM_HWF_PORT_3_SHORT_BUF_NUM
-        int "Number of buffers for Short pool of GbE #3"
-        depends on MV_ETH_BM_HWF_PORT_3 && (MV_ETH_BM_HWF_PORT_3_LONG_POOL != MV_ETH_BM_HWF_PORT_3_SHORT_POOL)
-        range 128 16384
-        default 3072
-        ---help---
-        Number of short buffers allocated for this port.
+	The number of short buffers is relevant for all short BM pools
 
 endmenu
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index cf132ce..d9f49ae 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -34,7 +34,6 @@ mv_pp2-objs += net_dev/mv_eth_rx_sysfs.o net_dev/mv_eth_tx_sysfs.o net_dev/mv_et
 mv_pp2-objs += net_dev/mv_eth_napi_sysfs.o net_dev/mv_eth_pme_sysfs.o net_dev/mv_eth_pon_sysfs.o
 mv_pp2-objs += net_dev/mv_eth_bm_sysfs.o net_dev/mv_eth_qos_sysfs.o
 
-mv_pp2-objs += bm/mv_eth_bm.o
 mv_pp2-objs += prs/prs_low_sysfs.o prs/prs_high_sysfs.o
 mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.o cls/cls_mc_sysfs.o
 mv_pp2-objs += pme/pme_sysfs.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/bm/mv_eth_bm.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/bm/mv_eth_bm.c
deleted file mode 100644
index d618d4c..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/bm/mv_eth_bm.c
+++ /dev/null
@@ -1,276 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-
-
-#include "gbe/mvPp2Gbe.h"
-#include "bm/mvBm.h"
-
-#include "net_dev/mv_netdev.h"
-
-typedef struct {
-	int             pool_pkt_size[MV_BM_POOLS];
-	MV_BM_CONFIG	port_config[MV_ETH_MAX_PORTS];
-	MV_U8		pool_hwf_mask;
-} MV_ETH_BM_CONFIG;
-
-static MV_ETH_BM_CONFIG mv_eth_bm_config;
-
-int mv_eth_bm_config_is_hwf_pool(int pool)
-{
-	return (mv_eth_bm_config.pool_hwf_mask & (1 << pool));
-}
-
-int mv_eth_bm_config_pkt_size_get(int pool)
-{
-	if ((pool < 0) || (pool >= MV_BM_POOLS))
-		return -EINVAL;
-
-	return mv_eth_bm_config.pool_pkt_size[pool];
-}
-
-int mv_eth_bm_config_pkt_size_set(int pool, int pkt_size)
-{
-	if ((pool < 0) || (pool >= MV_BM_POOLS))
-		return -EINVAL;
-
-	mv_eth_bm_config.pool_pkt_size[pool] = pkt_size;
-	return 0;
-}
-
-int mv_eth_bm_config_long_pool_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].longPool;
-}
-
-int mv_eth_bm_config_hwf_long_pool_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].hwfLongPool;
-}
-
-
-int mv_eth_bm_config_long_buf_num_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].longBufNum;
-}
-
-int mv_eth_bm_config_hwf_long_buf_num_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].hwfLongBufNum;
-}
-
-
-int mv_eth_bm_config_short_pool_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].shortPool;
-}
-
-int mv_eth_bm_config_hwf_short_pool_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].hwfShortPool;
-}
-
-int mv_eth_bm_config_short_buf_num_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].shortBufNum;
-}
-
-int mv_eth_bm_config_hwf_short_buf_num_get(int port)
-{
-	if (mvPp2PortCheck(port))
-		return -EINVAL;
-
-	return mv_eth_bm_config.port_config[port].hwfShortBufNum;
-}
-/* Once time call: init configuration structure accordingly with compile time parameters */
-MV_STATUS mv_eth_bm_config_get(void)
-{
-	MV_BM_CONFIG *bmConfig;
-	int           port;
-
-	mv_eth_bm_config.pool_hwf_mask = 0;
-
-	mv_eth_bm_config.pool_pkt_size[0] = CONFIG_MV_ETH_BM_0_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[1] = CONFIG_MV_ETH_BM_1_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[2] = CONFIG_MV_ETH_BM_2_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[3] = CONFIG_MV_ETH_BM_3_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[4] = CONFIG_MV_ETH_BM_4_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[5] = CONFIG_MV_ETH_BM_5_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[6] = CONFIG_MV_ETH_BM_6_PKT_SIZE;
-	mv_eth_bm_config.pool_pkt_size[7] = CONFIG_MV_ETH_BM_7_PKT_SIZE;
-
-#ifdef CONFIG_MV_ETH_BM_PORT_0
-	port = 0;
-	bmConfig = &mv_eth_bm_config.port_config[port];
-	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
-	bmConfig->valid = 1;
-	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_0_LONG_POOL;
-	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL;
-	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_0_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_0_LONG_POOL)
-	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_0_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_0_LONG_POOL */
-
-#ifdef CONFIG_MV_ETH_BM_HWF_PORT_0
-	bmConfig->hwfLongPool = CONFIG_MV_ETH_BM_HWF_PORT_0_LONG_POOL;
-	bmConfig->hwfShortPool = CONFIG_MV_ETH_BM_HWF_PORT_0_SHORT_POOL;
-	bmConfig->hwfLongBufNum = CONFIG_MV_ETH_BM_HWF_PORT_0_LONG_BUF_NUM;
-
-	mv_eth_bm_config.pool_hwf_mask |= ((1 << bmConfig->hwfLongPool) | (1 << bmConfig->hwfShortPool));
-#if (CONFIG_MV_ETH_BM_HWF_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_0_LONG_POOL)
-	bmConfig->hwfShortBufNum = CONFIG_MV_ETH_BM_HWF_PORT_0_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_0_LONG_POOL */
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_0 */
-#endif /* CONFIG_MV_ETH_BM_PORT_0 */
-
-#ifdef CONFIG_MV_ETH_BM_PORT_1
-	port = 1;
-	bmConfig = &mv_eth_bm_config.port_config[port];
-	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
-	bmConfig->valid = 1;
-	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_1_LONG_POOL;
-	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL;
-	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_1_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_1_LONG_POOL)
-	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_1_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_1_LONG_POOL */
-
-#ifdef CONFIG_MV_ETH_BM_HWF_PORT_1
-	bmConfig->hwfLongPool = CONFIG_MV_ETH_BM_HWF_PORT_1_LONG_POOL;
-	bmConfig->hwfShortPool = CONFIG_MV_ETH_BM_HWF_PORT_1_SHORT_POOL;
-	bmConfig->hwfLongBufNum = CONFIG_MV_ETH_BM_HWF_PORT_1_LONG_BUF_NUM;
-
-	mv_eth_bm_config.pool_hwf_mask |= ((1 << bmConfig->hwfLongPool) | (1 << bmConfig->hwfShortPool));
-#if (CONFIG_MV_ETH_BM_HWF_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_1_LONG_POOL)
-	bmConfig->hwfShortBufNum = CONFIG_MV_ETH_BM_HWF_PORT_1_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_1_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_1_LONG_POOL */
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_1 */
-#endif /* CONFIG_MV_ETH_BM_PORT_1 */
-
-#ifdef CONFIG_MV_ETH_BM_PORT_2
-	port = 2;
-	bmConfig = &mv_eth_bm_config.port_config[port];
-	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
-	bmConfig->valid = 1;
-	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_2_LONG_POOL;
-	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL;
-	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_2_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_2_LONG_POOL)
-	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_2_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_2_LONG_POOL */
-
-#ifdef CONFIG_MV_ETH_BM_HWF_PORT_2
-	bmConfig->hwfLongPool = CONFIG_MV_ETH_BM_HWF_PORT_2_LONG_POOL;
-	bmConfig->hwfShortPool = CONFIG_MV_ETH_BM_HWF_PORT_2_SHORT_POOL;
-	bmConfig->hwfLongBufNum = CONFIG_MV_ETH_BM_HWF_PORT_2_LONG_BUF_NUM;
-
-	mv_eth_bm_config.pool_hwf_mask |= ((1 << bmConfig->hwfLongPool) | (1 << bmConfig->hwfShortPool));
-#if (CONFIG_MV_ETH_BM_HWF_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_2_LONG_POOL)
-	bmConfig->hwfShortBufNum = CONFIG_MV_ETH_BM_HWF_PORT_2_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_2_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_2_LONG_POOL */
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_2 */
-#endif /* CONFIG_MV_ETH_BM_PORT_2 */
-
-#ifdef CONFIG_MV_ETH_BM_PORT_3
-	port = 3;
-	bmConfig = &mv_eth_bm_config.port_config[port];
-	memset(bmConfig, 0, sizeof(MV_BM_CONFIG));
-	bmConfig->valid = 1;
-	bmConfig->longPool = CONFIG_MV_ETH_BM_PORT_3_LONG_POOL;
-	bmConfig->shortPool = CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL;
-	bmConfig->longBufNum = CONFIG_MV_ETH_BM_PORT_3_LONG_BUF_NUM;
-
-#if (CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_3_LONG_POOL)
-	bmConfig->shortBufNum = CONFIG_MV_ETH_BM_PORT_3_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_PORT_3_SHORT_POOL != CONFIG_MV_ETH_BM_PORT_3_LONG_POOL */
-
-#ifdef CONFIG_MV_ETH_BM_HWF_PORT_3
-	bmConfig->hwfLongPool = CONFIG_MV_ETH_BM_HWF_PORT_3_LONG_POOL;
-	bmConfig->hwfShortPool = CONFIG_MV_ETH_BM_HWF_PORT_3_SHORT_POOL;
-	bmConfig->hwfLongBufNum = CONFIG_MV_ETH_BM_HWF_PORT_3_LONG_BUF_NUM;
-
-	mv_eth_bm_config.pool_hwf_mask |= ((1 << bmConfig->hwfLongPool) | (1 << bmConfig->hwfShortPool));
-#if (CONFIG_MV_ETH_BM_HWF_PORT_0_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_3_LONG_POOL)
-	bmConfig->hwfShortBufNum = CONFIG_MV_ETH_BM_HWF_PORT_3_SHORT_BUF_NUM;
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_3_SHORT_POOL != CONFIG_MV_ETH_BM_HWF_PORT_3_LONG_POOL */
-#endif /* CONFIG_MV_ETH_BM_HWF_PORT_3 */
-#endif /* CONFIG_MV_ETH_BM_PORT_3 */
-
-	return MV_OK;
-}
-
-void mv_eth_bm_config_print(void)
-{
-	int           i;
-	MV_BM_CONFIG *bmConfig;
-
-	mvOsPrintf("BM compile time configuration\n");
-	for (i = 0; i < MV_BM_POOLS; i++)
-		mvOsPrintf("pool %d: pkt_size = %d bytes\n", i, mv_eth_bm_config.pool_pkt_size[i]);
-
-	mvOsPrintf("\n");
-	mvOsPrintf("port:  longPool  shortPool  longBufNum  shortBufNum   hwfLongPool  hwfShortPool  hwfLongBufNum  hwfShortBufNum\n");
-	for (i = 0; i < MV_ETH_MAX_PORTS; i++) {
-		bmConfig = &mv_eth_bm_config.port_config[i];
-		if (bmConfig->valid)
-			mvOsPrintf("  %2d:   %4d       %4d        %4d         %4d      %4d          %4d           %4d            %4d\n",
-				i, bmConfig->longPool, bmConfig->shortPool, bmConfig->longBufNum, bmConfig->shortBufNum,
-				bmConfig->hwfLongPool, bmConfig->hwfShortPool, bmConfig->hwfLongBufNum, bmConfig->hwfShortBufNum);
-	}
-	mvOsPrintf("\n");
-}
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
index b059b4f..3540bd4 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
@@ -40,11 +40,14 @@ static ssize_t mv_eth_help(char *buf)
 {
 	int off = 0;
 
-	off += sprintf(buf+off, "echo [pool]                         > poolRegs       - print BM pool registers\n");
-	off += sprintf(buf+off, "echo [pool]                         > poolStatus     - print BM pool status\n");
-	off += sprintf(buf+off, "echo [pool] [size]                  > poolSize       - set packet size <size> to BM pool <pool>\n");
-	off += sprintf(buf+off, "echo [port] [short_num] [long_num]  > portSwfBuffNum - set buffers num for port's long and short pool\n");
-	off += sprintf(buf+off, "echo [port] [short_num] [long_num]  > portHwfBuffNum - set buffers num for port's long and short pool\n");
+	off += sprintf(buf+off, "echo [pool]           > poolRegs     - print BM pool registers\n");
+	off += sprintf(buf+off, "echo [pool]           > poolStatus   - print BM pool status\n");
+	off += sprintf(buf+off, "echo [pool] [size]    > poolSize     - set packet size <size> to BM pool <pool>\n");
+	off += sprintf(buf+off, "echo [pool] [buf_num] > poolBufNum   - set buffers num for BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]    > longPool     - set port's long BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]    > shortPool    - set port's short BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]    > hwfLongPool  - set port's HWF long BM pool\n");
+	off += sprintf(buf+off, "echo [port] [pool]    > hwfShortPool - set port's HWF short BM pool\n");
 
 	return off;
 }
@@ -67,15 +70,15 @@ static ssize_t mv_eth_port_store(struct device *dev,
 {
 	const char      *name = attr->attr.name;
 	int             err;
-	unsigned int    p, v, v1;
+	unsigned int    p, v;
 	unsigned long   flags;
 
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
 	/* Read port and value */
-	err = p = v = v1 = 0;
-	sscanf(buf, "%d %d %d", &p, &v, &v1);
+	err = p = v = 0;
+	sscanf(buf, "%d %d", &p, &v);
 
 	local_irq_save(flags);
 
@@ -85,10 +88,16 @@ static ssize_t mv_eth_port_store(struct device *dev,
 		mv_eth_pool_status_print(p);
 	} else if (!strcmp(name, "poolSize")) {
 		err = mv_eth_ctrl_pool_size_set(p, v);
-	} else if (!strcmp(name, "portSwfBuffNum")) {
-		err = mv_eth_ctrl_port_buf_num_set(p, v, v1);
-	} else if (!strcmp(name, "portHwfBuffNum")) {
-		err = mv_eth_ctrl_port_hwf_buf_num_set(p, v, v1);
+	} else if (!strcmp(name, "poolBufNum")) {
+		err = mv_eth_ctrl_pool_buf_num_set(p, v);
+	} else if (!strcmp(name, "longPool")) {
+		err = mv_eth_ctrl_long_pool_set(p, v);
+	} else if (!strcmp(name, "shortPool")) {
+		err = mv_eth_ctrl_short_pool_set(p, v);
+	} else if (!strcmp(name, "hwfLongPool")) {
+		err = mv_eth_ctrl_hwf_long_pool_set(p, v);
+	} else if (!strcmp(name, "hwfShortPool")) {
+		err = mv_eth_ctrl_hwf_short_pool_set(p, v);
 	} else {
 		err = 1;
 		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
@@ -106,16 +115,22 @@ static DEVICE_ATTR(help,		S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(poolRegs,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(poolStatus,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(poolSize,		S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(portHwfBuffNum,	S_IWUSR, NULL, mv_eth_port_store);
-static DEVICE_ATTR(portSwfBuffNum,	S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(poolBufNum,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(longPool,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(shortPool,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(hwfLongPool,		S_IWUSR, NULL, mv_eth_port_store);
+static DEVICE_ATTR(hwfShortPool,	S_IWUSR, NULL, mv_eth_port_store);
 
 static struct attribute *mv_eth_bm_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_poolRegs.attr,
 	&dev_attr_poolStatus.attr,
 	&dev_attr_poolSize.attr,
-	&dev_attr_portHwfBuffNum.attr,
-	&dev_attr_portSwfBuffNum.attr,
+	&dev_attr_poolBufNum.attr,
+	&dev_attr_longPool.attr,
+	&dev_attr_shortPool.attr,
+	&dev_attr_hwfLongPool.attr,
+	&dev_attr_hwfShortPool.attr,
 	NULL
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 8bc49ad..f6fa582 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -124,6 +124,7 @@ static int mv_eth_pool_add(int pool, int buf_num);
 static int mv_eth_pool_free(int pool, int num);
 static int mv_eth_pool_destroy(int pool);
 
+static struct bm_pool *mv_eth_pool_use(int pool, enum mv_eth_bm_type type, int pkt_size);
 #ifdef CONFIG_MV_ETH_TSO
 int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_spec *tx_spec,
 			struct txq_cpu_ctrl *txq_ctrl, struct aggr_tx_queue *aggr_txq_ctrl);
@@ -468,6 +469,27 @@ struct eth_port *mv_eth_port_by_id(unsigned int port)
 	return NULL;
 }
 
+/* return the first port in port_mask that is up, or -1 if all ports are down */
+static int mv_eth_port_up_get(unsigned int port_mask)
+{
+	int port;
+	struct eth_port *pp;
+
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		if (!((1 << port) & port_mask))
+			continue;
+
+		pp = mv_eth_port_by_id(port);
+		if (pp == NULL)
+			continue;
+
+		if (pp->flags & MV_ETH_F_STARTED)
+			return port;
+	}
+
+	return -1;
+}
+
 static inline int mv_eth_skb_mh_add(struct sk_buff *skb, u16 mh)
 {
        /* sanity: Check that there is place for MH in the buffer */
@@ -546,132 +568,262 @@ int mv_eth_ctrl_dbg_flag(int port, u32 flag, u32 val)
 	return 0;
 }
 
-/* Set number of buffers for this port's HWF long pool */
-/* Add or remove buffers to this pool accordingly      */
-int mv_eth_ctrl_port_hwf_buf_num_set(int port, int hwf_long_num, int hwf_short_num)
+/* mv_eth_ctrl_pool_buf_num_set					*
+ *     - Set number of buffers for BM pool			*
+ *     - Add or remove buffers to this pool accordingly		*/
+int mv_eth_ctrl_pool_buf_num_set(int pool, int buf_num)
+{
+	unsigned long flags = 0;
+	struct bm_pool *ppool;
+
+	if ((pool < 0) || (pool >= MV_ETH_BM_POOLS)) {
+		pr_err("%s: Invalid pool number (%d)\n", __func__, pool);
+		return -1;
+	}
+
+	ppool = &mv_eth_pool[pool];
+	if (ppool == NULL) {
+		pr_err("%s: BM pool %d is not initialized\n", __func__, pool);
+		return -1;
+	}
+
+	MV_ETH_LOCK(&ppool->lock, flags);
+	if (ppool->buf_num > buf_num)
+		mv_eth_pool_free(pool, ppool->buf_num - buf_num);
+	else
+		mv_eth_pool_add(pool, buf_num - ppool->buf_num);
+	MV_ETH_UNLOCK(&ppool->lock, flags);
+
+	return 0;
+}
+
+/* mv_eth_ctrl_pool_size_set				*
+ *     - Set pkt_size for the pool			*
+ *     - All ports using this pool must be stopped	*
+ *     - Re-allocate all buffers			*/
+int mv_eth_ctrl_pool_size_set(int pool, int pkt_size)
 {
+	unsigned long flags = 0;
+	struct eth_port *pp;
+	struct bm_pool *ppool = &mv_eth_pool[pool];
+	int port, buf_size, pkts_num;
+
+	port = mv_eth_port_up_get(ppool->port_map);
+	if (port != -1) {
+		pr_err("%s: Can't change pool %d buffer size, while port %d is up\n",
+			__func__, pool, port);
+		return -EINVAL;
+	}
+
+	for (port = 0; port < mv_eth_ports_num; port++) {
+		if (!((1 << port) & ppool->port_map))
+			continue;
+
+		pp = mv_eth_port_by_id(port);
+		if (pp == NULL)
+			continue;
+
+		/* If this pool is used as long pool, then it is expected that MTU will be larger than packet size */
+		if (MV_ETH_BM_POOL_IS_LONG(ppool->type) && (RX_PKT_SIZE(pp->dev->mtu) > pkt_size))
+			pr_warn("%s: port %d MTU (%d) is smaller than requested packet size (%d)\n",
+				__func__, port, RX_PKT_SIZE(pp->dev->mtu), pkt_size);
+	}
+
+	MV_ETH_LOCK(&ppool->lock, flags);
+	pkts_num = ppool->buf_num;
+	mv_eth_pool_free(pool, pkts_num);
+	ppool->pkt_size = pkt_size;
+	mv_eth_pool_add(pool, pkts_num);
+
+	buf_size = MV_ETH_BM_POOL_IS_HWF(ppool->type) ? RX_HWF_BUF_SIZE(pkt_size) : RX_BUF_SIZE(pkt_size);
+	mvBmPoolBufSizeSet(pool, buf_size);
+	MV_ETH_UNLOCK(&ppool->lock, flags);
+
+	pr_info("%s: BM pool %d, new packet size = %d, new buffer size = %d\n", __func__, pool, pkt_size, buf_size);
+
+	return 0;
+}
+
+int mv_eth_ctrl_long_pool_set(int port, int pool)
+{
+	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
+	struct bm_pool *old_pool;
 
 	if (pp == NULL) {
-		printk(KERN_INFO "port doenst not exist (%d) in %s\n" , port, __func__);
+		pr_err("%s: port %d doenst not exist\n" , __func__, port);
 		return -EINVAL;
 	}
 
 	if (pp->flags & MV_ETH_F_STARTED) {
-		printk(KERN_ERR "Port %d must be stopped before\n", port);
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
 		return -EINVAL;
 	}
-	if (pp->hwf_pool_long != NULL) {
-		/* Update number of buffers in existing pool (allocate or free) */
-		if (pp->hwf_pool_long_num > hwf_long_num)
-			mv_eth_pool_free(pp->hwf_pool_long->pool, pp->hwf_pool_long_num - hwf_long_num);
-		else if (hwf_long_num > pp->hwf_pool_long_num)
-			mv_eth_pool_add(pp->hwf_pool_long->pool, hwf_long_num - pp->hwf_pool_long_num);
-	}
-	pp->hwf_pool_long_num = hwf_long_num;
 
-	if (pp->hwf_pool_short != NULL) {
-		/* Update number of buffers in existing pool (allocate or free) */
-		if (pp->hwf_pool_short_num > hwf_short_num)
-			mv_eth_pool_free(pp->hwf_pool_short->pool, pp->hwf_pool_short_num - hwf_short_num);
-		else if (hwf_short_num > pp->hwf_pool_short_num)
-			mv_eth_pool_add(pp->hwf_pool_short->pool, hwf_short_num - pp->hwf_pool_short_num);
+	old_pool = pp->pool_long;
+	if (old_pool) {
+		if (old_pool->pool == pool)
+			return 0;
+
+		if (pp->hwf_pool_long != pp->pool_long) {
+			/* detach port from old pool */
+			old_pool->port_map &= ~(1 << port);
+			if (!old_pool->port_map) {
+				MV_ETH_LOCK(&old_pool->lock, flags);
+				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
+
+				old_pool->type = MV_ETH_BM_FREE;
+				old_pool->pkt_size = 0;
+
+				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
+				MV_ETH_UNLOCK(&old_pool->lock, flags);
+			}
+		}
 	}
-	pp->hwf_pool_short_num = hwf_short_num;
+	pp->pool_long = mv_eth_pool_use(pool, MV_ETH_BM_SWF_LONG, RX_PKT_SIZE(pp->dev->mtu));
+	if (!pp->pool_long)
+		return -EINVAL;
+	MV_ETH_LOCK(&pp->pool_long->lock, flags);
+	pp->pool_long->port_map |= (1 << port);
+	MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
 
 	return 0;
 }
 
-/* Set number of buffers for this port's SWF long pool */
-/* Add or remove buffers to this pool accordingly      */
-int mv_eth_ctrl_port_buf_num_set(int port, int long_num, int short_num)
+int mv_eth_ctrl_short_pool_set(int port, int pool)
 {
+	unsigned long flags = 0;
 	struct eth_port *pp = mv_eth_port_by_id(port);
+	struct bm_pool *old_pool;
 
 	if (pp == NULL) {
-		printk(KERN_INFO "port doesn't not exist (%d) in %s\n" , port, __func__);
+		pr_err("%s: port %d doenst not exist\n" , __func__, port);
 		return -EINVAL;
 	}
 
 	if (pp->flags & MV_ETH_F_STARTED) {
-		printk(KERN_ERR "Port %d must be stopped before\n", port);
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
 		return -EINVAL;
 	}
-	if (pp->pool_long != NULL) {
-		/* Update number of buffers in existing pool (allocate or free) */
-		if (pp->pool_long_num > long_num)
-			mv_eth_pool_free(pp->pool_long->pool, pp->pool_long_num - long_num);
-		else if (long_num > pp->pool_long_num)
-			mv_eth_pool_add(pp->pool_long->pool, long_num - pp->pool_long_num);
-	}
-	pp->pool_long_num = long_num;
 
-	if (pp->pool_short != NULL) {
-		/* Update number of buffers in existing pool (allocate or free) */
-		if (pp->pool_short_num > short_num)
-			mv_eth_pool_free(pp->pool_short->pool, pp->pool_short_num - short_num);
-		else if (short_num > pp->pool_short_num)
-			mv_eth_pool_add(pp->pool_short->pool, short_num - pp->pool_short_num);
+	old_pool = pp->pool_short;
+	if (old_pool) {
+		if (old_pool->pool == pool)
+			return 0;
+
+		if (pp->hwf_pool_short != pp->pool_short) {
+			/* detach port from old pool */
+			old_pool->port_map &= ~(1 << port);
+			if (!old_pool->port_map) {
+				MV_ETH_LOCK(&old_pool->lock, flags);
+				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
+
+				old_pool->type = MV_ETH_BM_FREE;
+				old_pool->pkt_size = 0;
+
+				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
+				MV_ETH_UNLOCK(&old_pool->lock, flags);
+			}
+		}
 	}
-	pp->pool_short_num = short_num;
+	pp->pool_short = mv_eth_pool_use(pool, MV_ETH_BM_SWF_SHORT, MV_ETH_BM_SHORT_BUFF_SIZE);
+	if (!pp->pool_short)
+		return -EINVAL;
+	MV_ETH_LOCK(&pp->pool_short->lock, flags);
+	pp->pool_short->port_map |= (1 << port);
+	MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
 
 	return 0;
 }
 
-/* Set pkt_size for the pool. Check that pool not in use (all ports are stopped) */
-/* Free all buffers from the pool */
-/* Detach the pool from all ports */
-int mv_eth_ctrl_pool_size_set(int pool, int pkt_size)
+int mv_eth_ctrl_hwf_long_pool_set(int port, int pool)
 {
-	int port;
-	struct bm_pool *ppool;
-	struct eth_port *pp;
+	unsigned long flags = 0;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+	struct bm_pool *old_pool;
 
-	if ((pool < 0) || (pool >= MV_ETH_BM_POOLS))
+	if (pp == NULL) {
+		pr_err("%s: port %d doenst not exist\n" , __func__, port);
 		return -EINVAL;
+	}
 
-	ppool = &mv_eth_pool[pool];
+	if (pp->flags & MV_ETH_F_STARTED) {
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
+		return -EINVAL;
+	}
 
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		/* Check that all ports using this pool are stopped */
-		if (ppool->port_map & (1 << port)) {
-			pp = mv_eth_port_by_id(port);
-			if (pp == NULL)
-				continue;
+	old_pool = pp->hwf_pool_long;
+	if (old_pool) {
+		if (old_pool->pool == pool)
+			return 0;
+
+		if (pp->hwf_pool_long != pp->pool_long) {
+			/* detach port from old pool */
+			old_pool->port_map &= ~(1 << port);
+			if (!old_pool->port_map) {
+				MV_ETH_LOCK(&old_pool->lock, flags);
+				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
+
+				old_pool->type = MV_ETH_BM_FREE;
+				old_pool->pkt_size = 0;
 
-			if (pp->flags & MV_ETH_F_STARTED) {
-				printk(KERN_ERR "Port %d use pool #%d and must be stopped before change pkt_size\n",
-					port, pool);
-				return -EINVAL;
+				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
+				MV_ETH_UNLOCK(&old_pool->lock, flags);
 			}
 		}
 	}
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		/* Free all buffers and detach pool */
-		if (ppool->port_map & (1 << port)) {
-			pp = mv_eth_port_by_id(port);
-			if (pp == NULL)
-				continue;
+	pp->hwf_pool_long = mv_eth_pool_use(pool, MV_ETH_BM_HWF_LONG, RX_PKT_SIZE(pp->dev->mtu));
+	if (!pp->hwf_pool_long)
+		return -EINVAL;
+	MV_ETH_LOCK(&pp->hwf_pool_long->lock, flags);
+	pp->hwf_pool_long->port_map |= (1 << port);
+	MV_ETH_UNLOCK(&pp->hwf_pool_long->lock, flags);
 
-			if (ppool == pp->pool_long) {
-				mv_eth_pool_free(pool, pp->pool_long_num);
-				ppool->port_map &= ~(1 << pp->port);
-				pp->pool_long = NULL;
-			}
-			if (ppool == pp->pool_short) {
-				mv_eth_pool_free(pool, pp->pool_short_num);
-				ppool->port_map &= ~(1 << pp->port);
-				pp->pool_short = NULL;
+	return 0;
+}
+
+int mv_eth_ctrl_hwf_short_pool_set(int port, int pool)
+{
+	unsigned long flags = 0;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+	struct bm_pool *old_pool;
+
+	if (pp == NULL) {
+		pr_err("%s: port %d doenst not exist\n" , __func__, port);
+		return -EINVAL;
+	}
+
+	if (pp->flags & MV_ETH_F_STARTED) {
+		pr_err("%s: port %d must be stopped before\n", __func__, port);
+		return -EINVAL;
+	}
+
+	old_pool = pp->hwf_pool_short;
+	if (old_pool) {
+		if (old_pool->pool == pool)
+			return 0;
+
+		if (pp->hwf_pool_short != pp->pool_short) {
+			/* detach port from old pool */
+			old_pool->port_map &= ~(1 << port);
+			if (!old_pool->port_map) {
+				MV_ETH_LOCK(&old_pool->lock, flags);
+				mv_eth_pool_free(old_pool->pool, old_pool->buf_num);
+
+				old_pool->type = MV_ETH_BM_FREE;
+				old_pool->pkt_size = 0;
+
+				mvPp2BmPoolBufSizeSet(old_pool->pool, 0);
+				MV_ETH_UNLOCK(&old_pool->lock, flags);
 			}
 		}
 	}
-	ppool->pkt_size = pkt_size;
-
-	mv_eth_bm_config_pkt_size_set(pool, pkt_size);
-	if (pkt_size == 0)
-		mvBmPoolBufSizeSet(pool, 0);
-	else
-		mvBmPoolBufSizeSet(pool, RX_BUF_SIZE(pkt_size));
+	pp->hwf_pool_short = mv_eth_pool_use(pool, MV_ETH_BM_HWF_SHORT, MV_ETH_BM_SHORT_BUFF_SIZE);
+	if (!pp->hwf_pool_short)
+		return -EINVAL;
+	MV_ETH_LOCK(&pp->hwf_pool_short->lock, flags);
+	pp->hwf_pool_short->port_map |= (1 << port);
+	MV_ETH_UNLOCK(&pp->hwf_pool_short->lock, flags);
 
 	return 0;
 }
@@ -1275,41 +1427,6 @@ inline u32 mv_eth_txq_done(struct eth_port *pp, struct tx_queue *txq_ctrl)
 }
 EXPORT_SYMBOL(mv_eth_txq_done);
 
-static int mv_eth_attach_long_pool(struct eth_port *pp, struct bm_pool *new_pool, int pkts_num, int pkt_size)
-{
-	struct bm_pool **port_long_pool;
-	int num, buffer_size, is_hwf = new_pool->is_hwf;
-
-	buffer_size = (is_hwf) ? RX_HWF_BUF_SIZE(pkt_size) : RX_BUF_SIZE(pkt_size);
-#ifdef CONFIG_MV_ETH_HWF
-	port_long_pool = (is_hwf) ? &pp->hwf_pool_long : &pp->pool_long;
-#else
-	port_long_pool = &pp->pool_long;
-#endif /* CONFIG_MV_ETH_HWF */
-
-	if (new_pool->pkt_size == 0) {
-		new_pool->pkt_size = pkt_size;
-		mvPp2BmPoolBufSizeSet(new_pool->pool, buffer_size);
-	}
-	if (new_pool->pkt_size < pkt_size) {
-		printk(KERN_ERR "%s FAILED: port=%d, long pool #%d, pkt_size=%d less than required %d\n",
-				__func__, pp->port, new_pool->pool, new_pool->pkt_size, pkt_size);
-		return 1;
-	}
-
-	*port_long_pool = new_pool;
-	new_pool->port_map |= (1 << pp->port);
-
-	num = mv_eth_pool_add(new_pool->pool, pkts_num);
-	if (num != pkts_num) {
-		printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d, only %d of %d allocated\n",
-		       __func__, new_pool->pool, new_pool->pkt_size, num, pkts_num);
-		return 1;
-	}
-
-	return 0;
-}
-
 inline struct eth_pbuf *mv_eth_pool_get(struct bm_pool *pool)
 {
 	struct eth_pbuf *pkt = NULL;
@@ -2239,18 +2356,16 @@ static int mv_eth_pool_free(int pool, int num)
 	struct eth_pbuf *pkt;
 	int i = 0, buff_size;
 	struct bm_pool *ppool = &mv_eth_pool[pool];
-	unsigned long flags = 0;
 	bool free_all = false;
 
-	MV_ETH_LOCK(&ppool->lock, flags);
-
 	if (num >= ppool->buf_num) {
 		/* Free all buffers from the pool */
 		free_all = true;
 		num = ppool->buf_num;
 	}
 
-	buff_size = (ppool->is_hwf) ? RX_HWF_BUF_SIZE(ppool->pkt_size) : RX_BUF_SIZE(ppool->pkt_size);
+	buff_size = MV_ETH_BM_POOL_IS_HWF(ppool->type) ?
+		RX_HWF_BUF_SIZE(ppool->pkt_size) : RX_BUF_SIZE(ppool->pkt_size);
 
 	if (mv_eth_pool_bm(ppool)) {
 		while (i < num) {
@@ -2264,7 +2379,7 @@ static int mv_eth_pool_free(int pool, int num)
 			pkt = (struct eth_pbuf *)MV_32BIT_LE((MV_U32)pkt);
 #endif /* !CONFIG_MV_ETH_BE_WA */
 
-			if (!ppool->is_hwf) {
+			if (!MV_ETH_BM_POOL_IS_HWF(ppool->type)) {
 				if (pkt)
 					mv_eth_pkt_free(pkt);
 			} else if (pkt) { /* HWF pool */
@@ -2279,7 +2394,7 @@ static int mv_eth_pool_free(int pool, int num)
 
 	ppool->buf_num -= num;
 
-	if (ppool->is_hwf)
+	if (MV_ETH_BM_POOL_IS_HWF(ppool->type))
 		return i;
 
 	/* Free buffers from the pool stack too */
@@ -2297,7 +2412,7 @@ static int mv_eth_pool_free(int pool, int num)
 		}
 		pkt = (struct eth_pbuf *)mvStackPop(ppool->stack);
 		if (pkt) {
-			if (!ppool->is_hwf)
+			if (!MV_ETH_BM_POOL_IS_HWF(ppool->type))
 				mv_eth_pkt_free(pkt);
 			else /* HWF packet - no skb */
 				mvOsFree(pkt);
@@ -2308,8 +2423,6 @@ static int mv_eth_pool_free(int pool, int num)
 		printk(KERN_ERR "stack pool #%d: pkt_size=%4d, buf_size=%4d - %d of %d buffers free\n",
 			pool, ppool->pkt_size, buff_size, i, num);
 
-	MV_ETH_UNLOCK(&ppool->lock, flags);
-
 	return i;
 }
 
@@ -2355,7 +2468,8 @@ static int mv_eth_pool_add(int pool, int buf_num)
 	}
 
 	bm_pool = &mv_eth_pool[pool];
-	buff_size = (bm_pool->is_hwf) ? RX_HWF_BUF_SIZE(bm_pool->pkt_size) : RX_BUF_SIZE(bm_pool->pkt_size);
+	buff_size = MV_ETH_BM_POOL_IS_HWF(bm_pool->type) ?
+				RX_HWF_BUF_SIZE(bm_pool->pkt_size) : RX_BUF_SIZE(bm_pool->pkt_size);
 
 	/* Check buffer size */
 	if (bm_pool->pkt_size == 0) {
@@ -2366,7 +2480,6 @@ static int mv_eth_pool_add(int pool, int buf_num)
 
 	/* Insure buf_num is smaller than capacity */
 	if ((buf_num < 0) || ((buf_num + bm_pool->buf_num) > (bm_pool->capacity))) {
-
 		printk(KERN_ERR "%s: can't add %d buffers into bm_pool=%d: capacity=%d, buf_num=%d\n",
 		       __func__, buf_num, pool, bm_pool->capacity, bm_pool->buf_num);
 		return 0;
@@ -2381,7 +2494,7 @@ static int mv_eth_pool_add(int pool, int buf_num)
 			break;
 		}
 
-		if (!bm_pool->is_hwf) {
+		if (!MV_ETH_BM_POOL_IS_HWF(bm_pool->type)) {
 			skb = mv_eth_skb_alloc(bm_pool, pkt);
 			if (!skb) {
 				kfree(pkt);
@@ -2410,38 +2523,37 @@ static int mv_eth_pool_add(int pool, int buf_num)
 
 void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *pPhysAddr)
 {
-		MV_ULONG			physAddr;
-		void				*pVirt;
-		MV_STATUS			status;
+	MV_ULONG physAddr;
+	void *pVirt;
+	MV_STATUS status;
 
-		pVirt = mvOsIoUncachedMalloc(NULL, sizeof(MV_U32) * capacity, &physAddr, NULL);
-		if (pVirt == NULL) {
-			mvOsPrintf("%s: Can't allocate %d bytes for Long pool #%d\n",
-					__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), pool);
-			return NULL;
-		}
+	pVirt = mvOsIoUncachedMalloc(NULL, sizeof(MV_U32) * capacity, &physAddr, NULL);
+	if (pVirt == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for Long pool #%d\n",
+				__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), pool);
+		return NULL;
+	}
 
-		/* Pool address must be MV_BM_POOL_PTR_ALIGN bytes aligned */
-		if (MV_IS_NOT_ALIGN((unsigned)pVirt, MV_BM_POOL_PTR_ALIGN)) {
-			mvOsPrintf("memory allocated for BM pool #%d is not %d bytes aligned\n",
-						pool, MV_BM_POOL_PTR_ALIGN);
-			mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
-			return NULL;
-		}
-		status = mvBmPoolInit(pool, physAddr, capacity);
-		if (status != MV_OK) {
-			mvOsPrintf("%s: Can't init #%d BM pool. status=%d\n", __func__, pool, status);
-			mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
-			return NULL;
-		}
+	/* Pool address must be MV_BM_POOL_PTR_ALIGN bytes aligned */
+	if (MV_IS_NOT_ALIGN((unsigned)pVirt, MV_BM_POOL_PTR_ALIGN)) {
+		mvOsPrintf("memory allocated for BM pool #%d is not %d bytes aligned\n",
+					pool, MV_BM_POOL_PTR_ALIGN);
+		mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
+		return NULL;
+	}
+	status = mvBmPoolInit(pool, physAddr, capacity);
+	if (status != MV_OK) {
+		mvOsPrintf("%s: Can't init #%d BM pool. status=%d\n", __func__, pool, status);
+		mvOsIoCachedFree(NULL, sizeof(MV_U32) * capacity, physAddr, pVirt, 0);
+		return NULL;
+	}
 
-		/*mvBmPoolEnable(pool);*/
-		mvBmPoolControl(pool, MV_START);
+	mvBmPoolControl(pool, MV_START);
 
-		if (pPhysAddr != NULL)
-			*pPhysAddr = physAddr;
+	if (pPhysAddr != NULL)
+		*pPhysAddr = physAddr;
 
-		return pVirt;
+	return pVirt;
 }
 
 static MV_STATUS mv_eth_pool_create(int pool, int capacity)
@@ -2469,6 +2581,7 @@ static MV_STATUS mv_eth_pool_create(int pool, int capacity)
 	}
 
 	bm_pool->pool = pool;
+	bm_pool->type = MV_ETH_BM_FREE;
 	bm_pool->capacity = capacity;
 	bm_pool->pkt_size = 0;
 	bm_pool->buf_num = 0;
@@ -2477,6 +2590,93 @@ static MV_STATUS mv_eth_pool_create(int pool, int capacity)
 	return MV_OK;
 }
 
+/* mv_eth_pool_use:							*
+ *	- notify the driver that BM pool is being used as specific type	*
+ *	- Allocate / Free buffers if necessary				*
+ *	- Returns the used pool pointer in case of success		*
+ *	- Parameters:							*
+ *		- pool: BM pool that is being used			*
+ *		- type: type of usage (SWF/HWF/MIXED long/short)	*
+ *		- pkt_size: pool requsted packet size			*/
+static struct bm_pool *mv_eth_pool_use(int pool, enum mv_eth_bm_type type, int pkt_size)
+{
+	unsigned long flags = 0;
+	struct bm_pool *new_pool;
+	int num;
+
+	new_pool = &mv_eth_pool[pool];
+
+	if ((MV_ETH_BM_POOL_IS_SHORT(new_pool->type) && MV_ETH_BM_POOL_IS_LONG(type))
+		|| (MV_ETH_BM_POOL_IS_SHORT(type) && MV_ETH_BM_POOL_IS_LONG(new_pool->type))) {
+		pr_err("%s FAILED: BM pool can't be used as short and long at the same time\n", __func__);
+		return NULL;
+	}
+
+	MV_ETH_LOCK(&new_pool->lock, flags);
+
+	if (new_pool->type == MV_ETH_BM_FREE)
+		new_pool->type = type;
+	else if (MV_ETH_BM_POOL_IS_SWF(new_pool->type) && MV_ETH_BM_POOL_IS_HWF(type))
+		new_pool->type = MV_ETH_BM_POOL_IS_LONG(type) ? MV_ETH_BM_MIXED_LONG : MV_ETH_BM_MIXED_SHORT;
+
+	/* Check if buffer allocation is needed, there are 3 cases:			*
+	 *	1. BM pool was used only by HWF, and will be used by SWF as well	*
+	 *	2. BM pool is used as long pool, but packet size doesn't match MTU	*
+	 *	3. BM pool hasn't being used yet					*/
+	if ((MV_ETH_BM_POOL_IS_HWF(new_pool->type) && MV_ETH_BM_POOL_IS_SWF(type))
+		|| (MV_ETH_BM_POOL_IS_LONG(type) && (pkt_size > new_pool->pkt_size))
+		|| (new_pool->pkt_size == 0)) {
+		int port, pkts_num;
+
+		/* If there are ports using this pool, they must be stopped before allocation */
+		port = mv_eth_port_up_get(new_pool->port_map);
+		if (port != -1) {
+			pr_err("%s: port %d use pool %d and must be stopped before buffer re-allocation\n",
+				__func__, port, new_pool->pool);
+			MV_ETH_UNLOCK(&new_pool->lock, flags);
+			return NULL;
+		}
+
+		/* if pool is empty, then set default buffers number		*
+		 * if pool is not empty, then we must free all the buffers	*/
+		pkts_num = new_pool->buf_num;
+		if (pkts_num == 0)
+			pkts_num = (MV_ETH_BM_POOL_IS_LONG(type)) ?
+				CONFIG_MV_ETH_BM_LONG_BUF_NUM : CONFIG_MV_ETH_BM_SHORT_BUF_NUM;
+		else
+			mv_eth_pool_free(new_pool->pool, pkts_num);
+
+		/* Check if pool has moved to SWF and HWF shared mode */
+		if ((MV_ETH_BM_POOL_IS_HWF(new_pool->type) && !MV_ETH_BM_POOL_IS_HWF(type))
+			|| (MV_ETH_BM_POOL_IS_HWF(type) && !MV_ETH_BM_POOL_IS_HWF(new_pool->type)))
+			new_pool->type = MV_ETH_BM_POOL_IS_LONG(type) ? MV_ETH_BM_MIXED_LONG : MV_ETH_BM_MIXED_SHORT;
+
+		/* Update packet size (in case of MTU larger than current ot new pool) */
+		if ((new_pool->pkt_size == 0)
+			|| (MV_ETH_BM_POOL_IS_LONG(type) && (pkt_size > new_pool->pkt_size)))
+			new_pool->pkt_size = pkt_size;
+
+		/* Allocate buffers for this pool */
+		num = mv_eth_pool_add(new_pool->pool, pkts_num);
+		if (num != pkts_num) {
+			pr_err("%s FAILED: pool=%d, pkt_size=%d, only %d of %d allocated\n",
+				__func__, new_pool->pool, new_pool->pkt_size, num, pkts_num);
+			MV_ETH_UNLOCK(&new_pool->lock, flags);
+			return NULL;
+		}
+
+	}
+
+	if (MV_ETH_BM_POOL_IS_HWF(new_pool->type))
+		mvPp2BmPoolBufSizeSet(new_pool->pool, RX_HWF_BUF_SIZE(new_pool->pkt_size));
+	else
+		mvPp2BmPoolBufSizeSet(new_pool->pool, RX_BUF_SIZE(new_pool->pkt_size));
+
+	MV_ETH_UNLOCK(&new_pool->lock, flags);
+
+	return new_pool;
+}
+
 /* Interrupt handling */
 irqreturn_t mv_eth_isr(int irq, void *dev_id)
 {
@@ -2746,12 +2946,9 @@ void mv_eth_port_filtering_cleanup(int port)
 
 static MV_STATUS mv_eth_bm_pools_init(void)
 {
-	int i, j, buff_size;
+	int i, j;
 	MV_STATUS status;
 
-	/* Get compile time configuration */
-	mv_eth_bm_config_get();
-
 	/* Create all pools with maximum capacity */
 	for (i = 0; i < MV_ETH_BM_POOLS; i++) {
 		status = mv_eth_pool_create(i, MV_BM_POOL_CAP_MAX);
@@ -2761,53 +2958,73 @@ static MV_STATUS mv_eth_bm_pools_init(void)
 				mv_eth_pool_destroy(j);
 			return status;
 		}
-		mv_eth_pool[i].pkt_size = mv_eth_bm_config_pkt_size_get(i);
 
-		if (mv_eth_bm_config_is_hwf_pool(i)) {
-			mv_eth_pool[i].is_hwf = 1;
-			buff_size = RX_HWF_BUF_SIZE(mv_eth_pool[i].pkt_size);
-		} else
-			buff_size = RX_BUF_SIZE(mv_eth_pool[i].pkt_size);
+		mv_eth_pool[i].pkt_size = 0;
+		mv_eth_pool[i].type = MV_ETH_BM_FREE;
 
-		if (mv_eth_pool[i].pkt_size == 0)
-			mvPp2BmPoolBufSizeSet(i, 0);
-		else
-			mvPp2BmPoolBufSizeSet(i, buff_size);
+		mvPp2BmPoolBufSizeSet(i, 0);
 	}
 	return 0;
 }
 
+int mv_eth_swf_bm_pool_init(struct eth_port *pp, int mtu)
+{
+	unsigned long flags = 0;
+	int pkt_size = RX_PKT_SIZE(mtu);
+
+	if (pp->pool_long == NULL) {
+		pp->pool_long = mv_eth_pool_use(MV_ETH_BM_SWF_LONG_POOL(pp->port),
+							MV_ETH_BM_SWF_LONG, pkt_size);
+		if (pp->pool_long == NULL)
+			return -1;
+
+		MV_ETH_LOCK(&pp->pool_long->lock, flags);
+		pp->pool_long->port_map |= (1 << pp->port);
+		MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
+	}
+
+	if (pp->pool_short == NULL) {
+		pp->pool_short = mv_eth_pool_use(MV_ETH_BM_SWF_SHORT_POOL(pp->port),
+							MV_ETH_BM_SWF_SHORT, MV_ETH_BM_SHORT_BUFF_SIZE);
+		if (pp->pool_short == NULL)
+			return -1;
+
+		MV_ETH_LOCK(&pp->pool_short->lock, flags);
+		pp->pool_short->port_map |= (1 << pp->port);
+		MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
+	}
+
+	return 0;
+}
+
 #ifdef CONFIG_MV_ETH_HWF
 int mv_eth_hwf_bm_pool_init(struct eth_port *pp, int mtu)
 {
-	int num = 0, pkt_size = RX_PKT_SIZE(mtu);
+	unsigned long flags = 0;
+	int pkt_size = RX_PKT_SIZE(mtu);
 
 	if (pp->hwf_pool_long == NULL) {
-		struct bm_pool *new_pool = &mv_eth_pool[mv_eth_bm_config_hwf_long_pool_get(pp->port)];
-
-		if (mv_eth_attach_long_pool(pp, new_pool, pp->hwf_pool_long_num, pkt_size)) {
-			printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d, only %d of %d allocated\n",
-			       __func__, new_pool->pool, new_pool->pkt_size, num, pp->hwf_pool_long_num);
+		pp->hwf_pool_long = mv_eth_pool_use(MV_ETH_BM_HWF_LONG_POOL(pp->port),
+							MV_ETH_BM_HWF_LONG, pkt_size);
+		if (pp->hwf_pool_long == NULL)
 			return -1;
-		}
+
+		MV_ETH_LOCK(&pp->hwf_pool_long->lock, flags);
+		pp->hwf_pool_long->port_map |= (1 << pp->port);
+		MV_ETH_UNLOCK(&pp->hwf_pool_long->lock, flags);
 	}
 
 	if (pp->hwf_pool_short == NULL) {
-		pp->hwf_pool_short = &mv_eth_pool[mv_eth_bm_config_hwf_short_pool_get(pp->port)];
-		pp->hwf_pool_short->port_map |= (1 << pp->port);
-
-		mvPp2BmPoolBufSizeSet(pp->hwf_pool_short->pool, RX_HWF_BUF_SIZE(pp->hwf_pool_short->pkt_size));
+		pp->hwf_pool_short = mv_eth_pool_use(MV_ETH_BM_HWF_SHORT_POOL(pp->port),
+							MV_ETH_BM_HWF_SHORT, MV_ETH_BM_SHORT_BUFF_SIZE);
+		if (pp->hwf_pool_short == NULL)
+			return -1;
 
-		num = mv_eth_pool_add(pp->hwf_pool_short->pool, pp->hwf_pool_short_num);
-		if (num != pp->hwf_pool_short_num) {
-			printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d, only %d of %d allocated\n",
-			       __func__, pp->hwf_pool_short->pool, pp->hwf_pool_short->pkt_size, num, pp->hwf_pool_short_num);
-			return -ENOMEM;
-		}
+		MV_ETH_LOCK(&pp->hwf_pool_short->lock, flags);
+		pp->hwf_pool_short->port_map |= (1 << pp->port);
+		MV_ETH_UNLOCK(&pp->hwf_pool_short->lock, flags);
 	}
 
-	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
-
 	return 0;
 }
 #endif /* CONFIG_MV_ETH_HWF */
@@ -3502,37 +3719,6 @@ void mv_eth_priv_cleanup(struct eth_port *pp)
 	/* TODO */
 }
 
-static struct bm_pool *mv_eth_long_pool_get(struct eth_port *pp, int pkt_size)
-{
-	int             pool, i;
-	struct bm_pool	*bm_pool, *temp_pool = NULL;
-	unsigned long   flags = 0;
-
-	/* look for free pool pkt_size == 0. First check pool == pp->port */
-	/* if no free pool choose larger than required */
-	for (i = 0; i < MV_ETH_BM_POOLS; i++) {
-		pool = (pp->port + i) % MV_ETH_BM_POOLS;
-		bm_pool = &mv_eth_pool[pool];
-
-		MV_ETH_LOCK(&bm_pool->lock, flags);
-
-		if (bm_pool->pkt_size == 0) {
-			/* found free pool */
-
-			MV_ETH_UNLOCK(&bm_pool->lock, flags);
-			return bm_pool;
-		}
-		if (bm_pool->pkt_size >= pkt_size && !bm_pool->is_hwf) {
-			if (temp_pool == NULL)
-				temp_pool = bm_pool;
-			else if (bm_pool->pkt_size < temp_pool->pkt_size)
-				temp_pool = bm_pool;
-		}
-		MV_ETH_UNLOCK(&bm_pool->lock, flags);
-	}
-	return temp_pool;
-}
-
 static int mv_eth_rxq_fill(struct eth_port *pp, int rxq, int num)
 {
 	mvPp2RxqNonOccupDescAdd(pp->port, rxq, num);
@@ -3682,8 +3868,7 @@ MV_STATUS mv_eth_tx_done_ptks_coal_set(int port, int txp, int txq, MV_U32 value)
 int mv_eth_start_internals(struct eth_port *pp, int mtu)
 {
 	unsigned int status;
-	int rxq, txp, txq, num, err = 0;
-	int pkt_size = RX_PKT_SIZE(mtu);
+	int rxq, txp, txq, err = 0;
 
 	if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
 		STAT_ERR(pp->stats.state_err++);
@@ -3699,72 +3884,17 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 		mv_pon_mtu_config(RX_PKT_SIZE(mtu));
 #endif
 
+	err = mv_eth_swf_bm_pool_init(pp, mtu);
+	if (err)
+		goto out;
 #ifdef CONFIG_MV_ETH_HWF
-	mv_eth_hwf_bm_pool_init(pp, mtu);
-#endif /* CONFIG_MV_ETH_HWF */
-
-	/* Allocate buffers for Long buffers pool */
-	if (pp->pool_long == NULL) {
-		struct bm_pool *new_pool;
-		int long_pool = mv_eth_bm_config_long_pool_get(pp->port);
-
-		/* check if config pool is good */
-		if ((long_pool != -1) &&
-				((mv_eth_pool[long_pool].pkt_size == 0) ||
-				(mv_eth_pool[long_pool].pkt_size >= pkt_size)))
-			new_pool = &mv_eth_pool[long_pool];
-		else
-			new_pool = mv_eth_long_pool_get(pp, pkt_size);
-
-		if (new_pool == NULL) {
-			printk(KERN_ERR "%s FAILED: port=%d, Can't find pool for pkt_size=%d\n",
-			       __func__, pp->port, pkt_size);
-			err = -ENOMEM;
-			goto out;
-		}
-		if (new_pool->is_hwf) {
-			printk(KERN_ERR "%s FAILED: port=%d, pool#%d is already used by HWF\n",
-			       __func__, pp->port, new_pool->pool);
-			err = -EINVAL;
-			goto out;
-		}
-
-		if (mv_eth_attach_long_pool(pp, new_pool, pp->pool_long_num, pkt_size))
-			goto out;
-	}
-
-	if (pp->pool_short == NULL) {
-		int short_pool = mv_eth_bm_config_short_pool_get(pp->port);
+	err = mv_eth_hwf_bm_pool_init(pp, mtu);
+	if (err)
+		goto out;
 
-		/* Allocate packets for short pool */
-		if (short_pool < 0) {
-			err = -EINVAL;
-			goto out;
-		}
-		pp->pool_short = &mv_eth_pool[short_pool];
-		if (pp->pool_short->is_hwf) {
-			printk(KERN_ERR "%s FAILED: port=%d, pool#%d is already used by HWF\n",
-			       __func__, pp->port, pp->pool_short->pool);
-			err = -EINVAL;
-			goto out;
-		}
-		pp->pool_short->port_map |= (1 << pp->port);
-		if (pp->pool_short->pool != pp->pool_long->pool) {
-			num = mv_eth_pool_add(pp->pool_short->pool, pp->pool_short_num);
-			if (num != pp->pool_short_num) {
-				printk(KERN_ERR "%s FAILED: pool=%d, pkt_size=%d - %d of %d buffers added\n",
-					   __func__, short_pool, pp->pool_short->pkt_size, num, pp->pool_short_num);
-				err = -ENOMEM;
-				goto out;
-			}
-			mvPp2BmPoolBufSizeSet(pp->pool_short->pool, RX_BUF_SIZE(pp->pool_short->pkt_size));
-		} else {
-			int dummy_short_pool = (pp->pool_short->pool + 1) % MV_BM_POOLS;
+	mvPp2PortHwfBmPoolSet(pp->port, pp->hwf_pool_short->pool, pp->hwf_pool_long->pool);
+#endif /* CONFIG_MV_ETH_HWF */
 
-			/* To disable short pool we choose unused pool and set pkt size to 0 (buffer size = pkt offset) */
-			mvPp2BmPoolBufSizeSet(dummy_short_pool, NET_SKB_PAD);
-		}
-	}
 
 	for (rxq = 0; rxq < pp->rxq_num; rxq++) {
 		if (pp->rxq_ctrl[rxq].q == NULL) {
@@ -3929,45 +4059,22 @@ int mv_eth_check_mtu_valid(struct net_device *dev, int mtu)
 /* Check if MTU can be changed */
 int mv_eth_check_mtu_internals(struct net_device *dev, int mtu)
 {
-	int i, pkt_size = RX_PKT_SIZE(mtu);
 	struct eth_port *pp = MV_ETH_PRIV(dev);
-	struct bm_pool	*new_pool = NULL, *port_pool;
+	struct bm_pool *port_pool;
 
 	if (!pp)
 		return -EPERM;
 
 	port_pool = pp->pool_long;
 
-	/* long pool is not shared with other ports */
-	if ((port_pool) && (port_pool->port_map == (1 << pp->port)))
+	if (!port_pool)
 		return 0;
 
-	new_pool = mv_eth_long_pool_get(pp, pkt_size);
-
-	/* there is a pool suitable for new port's mtu */
-	if (new_pool)
+	/* long pool is not shared with other ports */
+	if ((port_pool) && (port_pool->port_map == (1 << pp->port)))
 		return 0;
 
-	/* we must use the current long pool - need to check that all other ports using this pool are stopped */
-	if (!port_pool)
-		return -EPERM;
-
-	for (i = 0; i < mv_eth_ports_num; i++) {
-		/* Check that all ports using this pool are stopped */
-		if (port_pool->port_map & (1 << i)) {
-			pp = mv_eth_port_by_id(i);
-			if ((pp == NULL) || (pp->port == i))
-				continue;
-
-			if (pp->flags & MV_ETH_F_STARTED) {
-				printk(KERN_ERR "Port %d use pool #%d and must be stopped before changing mtu\n",
-					pp->port, port_pool->pool);
-				return -EPERM;
-			}
-		}
-	}
-
-	return 0;
+	return 1;
 }
 
 /***********************************************************
@@ -3978,9 +4085,9 @@ int mv_eth_check_mtu_internals(struct net_device *dev, int mtu)
  ***********************************************************/
 int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 {
-	struct bm_pool *new_pool = NULL, *port_pool;
+	struct bm_pool *port_pool;
 	struct eth_port *pp = MV_ETH_PRIV(dev);
-	int pkt_size = RX_PKT_SIZE(mtu), pkts_num = pp->pool_long_num;
+	int pkt_size = RX_PKT_SIZE(mtu), pkts_num;
 
 	if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
 		STAT_ERR(pp->stats.state_err++);
@@ -4006,75 +4113,39 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 
 	/* for now, hwf long pool must not be shared with other ports */
 	if (port_pool) {
+		pkts_num = port_pool->buf_num;
 		if (port_pool->port_map == (1 << pp->port)) {
 			/* refill pool with updated buffer size */
 			mv_eth_pool_free(port_pool->pool, pkts_num);
-			port_pool->pkt_size = 0;
-			if (mv_eth_attach_long_pool(pp, port_pool, pkts_num, pkt_size))
-				return -1;
+			port_pool->pkt_size = pkt_size;
+			mv_eth_pool_add(port_pool->pool, pkts_num);
 		} else {
 			printk(KERN_ERR "%s: port %d, HWF long pool is shared with other ports.\n", __func__, pp->port);
 			return -1;
 		}
 	}
-#endif /* CONFIG_MV_ETH_HWF */
-
-	port_pool = pp->pool_long;
-
-	/* long pool is not shared with other ports */
-	if ((port_pool) && (port_pool->port_map == (1 << pp->port))) {
-		/* refill pool with updated buffer size */
-		mv_eth_pool_free(port_pool->pool, pkts_num);
-		port_pool->pkt_size = 0;
-		if (mv_eth_attach_long_pool(pp, port_pool, pkts_num, pkt_size))
-			return -1;
 
+	/* Check if SWF and HWF of this port are using the same pool */
+	if (port_pool == pp->pool_long)
 		goto mtu_out;
-	}
+#endif /* CONFIG_MV_ETH_HWF */
 
-	/* find new pool according to new mtu */
-	new_pool = mv_eth_long_pool_get(pp, pkt_size);
-	if (new_pool && (new_pool != port_pool)) {
-		/* dettach old pool, attach new pool */
-		mv_eth_pool_free(port_pool->pool, pkts_num);
-		port_pool->port_map &= ~(1 << pp->port);
+	port_pool = pp->pool_long;
 
-		if (mv_eth_attach_long_pool(pp, new_pool, pkts_num, pkt_size))
+	/* for now, swf long pool must not be shared with other ports */
+	if (port_pool) {
+		pkts_num = port_pool->buf_num;
+		if (port_pool->port_map == (1 << pp->port)) {
+			/* refill pool with updated buffer size */
+			mv_eth_pool_free(port_pool->pool, pkts_num);
+			port_pool->pkt_size = pkt_size;
+			mv_eth_pool_add(port_pool->pool, pkts_num);
+		} else {
+			printk(KERN_ERR "%s: port %d, SWF long pool is shared with other ports.\n", __func__, pp->port);
 			return -1;
-		goto mtu_out;
-	}
-
-	printk(KERN_ERR "%s: port %d, couldn't find any suitable BM pool got mtu=%d.\n", __func__, pp->port, mtu);
-	return -1;
-
-	/* TODO for now, skip code below for handling shared pools - we will support it later */
-	/* must use current pool */
-/*	if (!port_pool) {
-		printk(KERN_ERR "%s: port %d, couldn't find any suitable BM pool got mtu=%d.\n", __func__, pp->port, mtu);
-		return -1;
-	}
-	for (i = 0; i < mv_eth_ports_num; i++) {
-*/
-		/* Check that all ports using this pool are stopped */
-/*		if (port_pool->port_map & (1 << i)) {
-			tmp = mv_eth_port_by_id(i);
-			if ((tmp == NULL) || (pp->port == i))
-				continue;
-
-			if (tmp->flags & MV_ETH_F_STARTED) {
-				printk(KERN_ERR "Port %d use pool #%d and must be stopped before changing mtu\n",
-					tmp->port, port_pool->pool);
-				return -EPERM;
-			}
 		}
 	}
-*/
-	/* refill pool with updated buffer size */
-/*	mv_eth_pool_free(port_pool->pool, pkts_num);
-	port_pool->pkt_size = 0;
-	if (mv_eth_attach_long_pool(pp, port_pool, pkts_num, pkt_size))
-		return -1;
-*/
+
 mtu_out:
 	dev->mtu = mtu;
 
@@ -4284,24 +4355,6 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 
 	pp->flags = 0;
 
-	pp->pool_long_num = mv_eth_bm_config_long_buf_num_get(port);
-	if (pp->pool_long_num > MV_BM_POOL_CAP_MAX)
-		pp->pool_long_num = MV_BM_POOL_CAP_MAX;
-
-	pp->pool_short_num = mv_eth_bm_config_short_buf_num_get(port);
-	if (pp->pool_short_num > MV_BM_POOL_CAP_MAX)
-		pp->pool_short_num = MV_BM_POOL_CAP_MAX;
-#ifdef CONFIG_MV_ETH_HWF
-	pp->hwf_pool_long_num = mv_eth_bm_config_hwf_long_buf_num_get(pp->port);
-	if (pp->hwf_pool_long_num > MV_BM_POOL_CAP_MAX)
-		pp->hwf_pool_long_num = MV_BM_POOL_CAP_MAX;
-
-	pp->hwf_pool_short_num = mv_eth_bm_config_hwf_short_buf_num_get(pp->port);
-	if (pp->hwf_pool_short_num > MV_BM_POOL_CAP_MAX)
-		pp->hwf_pool_short_num = MV_BM_POOL_CAP_MAX;
-#endif /* CONFIG_MV_ETH_HWF */
-
-
 	for (i = 0; i < 64; i++)
 		pp->txq_dscp_map[i] = MV_ETH_TXQ_INVALID;
 #ifdef CONFIG_MV_ETH_TX_SPECIAL
@@ -4399,32 +4452,68 @@ void mv_eth_napi_groups_print(int port)
  ***********************************************************************************/
 void mv_eth_pool_status_print(int pool)
 {
+	const char *type;
 	struct bm_pool *bm_pool = &mv_eth_pool[pool];
+	int buf_size = MV_ETH_BM_POOL_IS_HWF(bm_pool->type) ?
+			RX_HWF_BUF_SIZE(bm_pool->pkt_size) : RX_BUF_SIZE(bm_pool->pkt_size);
 
-	printk(KERN_ERR "\nRX Pool #%d: pkt_size=%d, owned by: %s, BM-HW support - %s\n",
-	       pool, bm_pool->pkt_size, bm_pool->is_hwf ? "HWF" : "SW", mv_eth_pool_bm(bm_pool) ? "Yes" : "No");
+	switch (bm_pool->type) {
+	case MV_ETH_BM_FREE:
+		type = "MV_ETH_BM_FREE";
+		break;
+	case MV_ETH_BM_SWF_LONG:
+		type = "MV_ETH_BM_SWF_LONG";
+		break;
+	case MV_ETH_BM_SWF_SHORT:
+		type = "MV_ETH_BM_SWF_SHORT";
+		break;
+	case MV_ETH_BM_HWF_LONG:
+		type = "MV_ETH_BM_HWF_LONG";
+		break;
+	case MV_ETH_BM_HWF_SHORT:
+		type = "MV_ETH_BM_HWF_SHORT";
+		break;
+	case MV_ETH_BM_MIXED_LONG:
+		type = "MV_ETH_BM_MIXED_LONG";
+		break;
+	case MV_ETH_BM_MIXED_SHORT:
+		type = "MV_ETH_BM_MIXED_SHORT";
+		break;
+	default:
+		type = "Unknown";
+	}
 
-	printk(KERN_ERR "bm_pool=%p, stack=%p, capacity=%d, buf_num=%d, port_map=0x%x missed=%d\n",
-	       bm_pool->bm_pool, bm_pool->stack, bm_pool->capacity, bm_pool->buf_num,
-		   bm_pool->port_map, bm_pool->missed);
+	pr_info("\nBM Pool #%d: pool type = %s\n", pool, type);
+	pr_info("     packet size = %d,  buffer size = %d,  buffers num = %d\n",
+			bm_pool->pkt_size, buf_size, bm_pool->buf_num);
+	pr_info("     bm_pool=%p, stack=%p, capacity=%d, buf_num=%d, port_map=0x%x missed=%d\n",
+			bm_pool->bm_pool, bm_pool->stack, bm_pool->capacity, bm_pool->buf_num,
+			bm_pool->port_map, bm_pool->missed);
 
 #ifdef CONFIG_MV_ETH_STAT_ERR
-	printk(KERN_ERR "Errors: skb_alloc_oom=%u, stack_empty=%u, stack_full=%u\n",
+	pr_info("     Errors: skb_alloc_oom=%u, stack_empty=%u, stack_full=%u\n",
 	       bm_pool->stats.skb_alloc_oom, bm_pool->stats.stack_empty, bm_pool->stats.stack_full);
 #endif /* #ifdef CONFIG_MV_ETH_STAT_ERR */
 
 #ifdef CONFIG_MV_ETH_STAT_DBG
-	printk(KERN_ERR "skb_alloc_ok=%u, bm_put=%u, stack_put=%u, stack_get=%u\n",
+	pr_info("     skb_alloc_ok=%u, bm_put=%u, stack_put=%u, stack_get=%u\n",
 	       bm_pool->stats.skb_alloc_ok, bm_pool->stats.bm_put, bm_pool->stats.stack_put, bm_pool->stats.stack_get);
 
-	printk(KERN_ERR "skb_recycled_ok=%u, skb_recycled_err=%u\n",
+	pr_info("     skb_recycled_ok=%u, skb_recycled_err=%u\n",
 	       bm_pool->stats.skb_recycled_ok, bm_pool->stats.skb_recycled_err);
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 
-	if (bm_pool->stack)
+	if (bm_pool->stack) {
+		pr_info("     "); /* indent */
 		mvStackStatus(bm_pool->stack, 0);
+	}
 
 	memset(&bm_pool->stats, 0, sizeof(bm_pool->stats));
+
+#ifdef CONFIG_MV_ETH_STAT_ERR
+	pr_info("     Errors: skb_alloc_oom=%u, stack_empty=%u, stack_full=%u\n",
+	       bm_pool->stats.skb_alloc_oom, bm_pool->stats.stack_empty, bm_pool->stats.stack_full);
+#endif /* #ifdef CONFIG_MV_ETH_STAT_ERR */
 }
 
 
@@ -4774,6 +4863,7 @@ void mv_eth_port_stats_print(unsigned int port)
 
 static int mv_eth_port_cleanup(int port)
 {
+	unsigned long flags = 0;
 	int txp, txq, rxq, i;
 	struct eth_port *pp;
 	struct tx_queue *txq_ctrl;
@@ -4832,17 +4922,29 @@ static int mv_eth_port_cleanup(int port)
 
 	/* Free buffer pools */
 	if (pp->pool_long) {
-		mv_eth_pool_free(pp->pool_long->pool, pp->pool_long_num);
 		pp->pool_long->port_map &= ~(1 << pp->port);
-		if (!pp->pool_long->port_map)
-			pp->pool_long->is_hwf = 0;
+		if (!pp->pool_long->port_map) {
+			MV_ETH_LOCK(&pp->pool_long->lock, flags);
+			mv_eth_pool_free(pp->pool_long->pool, pp->pool_long->buf_num);
+			pp->pool_long->type = MV_ETH_BM_FREE;
+			pp->pool_long->pkt_size = 0;
+
+			mvPp2BmPoolBufSizeSet(pp->pool_long->pool, 0);
+			MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
+		}
 		pp->pool_long = NULL;
 	}
 	if (pp->pool_short) {
-		mv_eth_pool_free(pp->pool_short->pool, pp->pool_short_num);
 		pp->pool_short->port_map &= ~(1 << pp->port);
-		if (!pp->pool_short->port_map)
-			pp->pool_short->is_hwf = 0;
+		if (!pp->pool_short->port_map) {
+			MV_ETH_LOCK(&pp->pool_short->lock, flags);
+			mv_eth_pool_free(pp->pool_short->pool, pp->pool_short->buf_num);
+			pp->pool_short->type = MV_ETH_BM_FREE;
+			pp->pool_short->pkt_size = 0;
+
+			mvPp2BmPoolBufSizeSet(pp->pool_short->pool, 0);
+			MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
+		}
 		pp->pool_short = NULL;
 	}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 5f3fd2c..f7c5bad 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -341,14 +341,10 @@ struct eth_port {
 	struct net_device   *dev;
 	rwlock_t            rwlock;
 	struct bm_pool      *pool_long;
-	int                 pool_long_num;
 	struct bm_pool      *pool_short;
-	int                 pool_short_num;
 #ifdef CONFIG_MV_ETH_HWF
 	struct bm_pool      *hwf_pool_long;
-	int                 hwf_pool_long_num;
 	struct bm_pool      *hwf_pool_short;
-	int                 hwf_pool_short_num;
 #endif /* CONFIG_MV_ETH_HWF */
 	struct napi_group_ctrl *napi_group[MV_ETH_MAX_RXQ];
 	unsigned long       flags;	/* MH, TIMER, etc. */
@@ -393,13 +389,7 @@ enum eth_pm_mode {
 #define MV_ETH_PRIV(dev)        ((struct eth_port *)(netdev_priv(dev)))
 #define MV_DEV_STAT(dev)        (&((dev)->stats))
 
-/* define which Switch ports are relevant */
-#define SWITCH_CONNECTED_PORTS_MASK	0x7F
-
-#define MV_SWITCH_ID_0			0
-#define MV_ETH_PORT_0			0
-#define MV_ETH_PORT_1			1
-
+/* BM specific defines */
 struct pool_stats {
 #ifdef CONFIG_MV_ETH_STAT_ERR
 	u32 skb_alloc_oom;
@@ -417,36 +407,67 @@ struct pool_stats {
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 };
 
-struct bm_pool {
-	int         pool;
-	int 	    is_hwf;
-	int         capacity;
-	int         buf_num;
-	int         pkt_size;
-	u32         *bm_pool;
-	MV_STACK    *stack;
-	spinlock_t  lock;
-	u32         port_map;
-	int         missed;		/* FIXME: move to stats */
-	struct pool_stats  stats;
-};
+/* BM pool assignment */
+#ifdef CONFIG_MV_ETH_BM_PER_PORT_MODE
+/* #port   SWF long   SWF short   HWF long   HWF short *
+ *   0         0          1           0           1    *
+ *   1         2          3           2           3    *
+ *   2         4          5           4           5    *
+ *   3         6          7           6           7    */
+#define MV_ETH_BM_SWF_LONG_POOL(port)		(port << 1)
+#define MV_ETH_BM_SWF_SHORT_POOL(port)		((port << 1) + 1)
+#define MV_ETH_BM_HWF_LONG_POOL(port)		(MV_ETH_BM_SWF_LONG_POOL(port))
+#define MV_ETH_BM_HWF_SHORT_POOL(port)		(MV_ETH_BM_SWF_SHORT_POOL(port))
+#else /* CONFIG_MV_ETH_BM_SWF_HWF_MODE */
+/* #port   SWF long   SWF short   HWF long   HWF short *
+ *   0         0          3           4           7    *
+ *   1         1          3           5           7    *
+ *   2         2          3           6           7    *
+ *   3         2          3           6           7    */
+#define MV_ETH_BM_SWF_LONG_POOL(port)		((port > 2) ? 2 : port)
+#define MV_ETH_BM_SWF_SHORT_POOL(port)		(3)
+#define MV_ETH_BM_HWF_LONG_POOL(port)		((port > 2) ? 6 : (port + 4))
+#define MV_ETH_BM_HWF_SHORT_POOL(port)		(7)
+#endif
 
 #define MV_ETH_BM_POOLS	        MV_BM_POOLS
 #define mv_eth_pool_bm(p)       (p->bm_pool)
 
-MV_STATUS mv_eth_bm_config_get(void);
-int mv_eth_bm_config_is_hwf_pool(int pool);
-int mv_eth_bm_config_pkt_size_get(int pool);
-int mv_eth_bm_config_pkt_size_set(int pool, int pkt_size);
-int mv_eth_bm_config_short_pool_get(int port);
-int mv_eth_bm_config_short_buf_num_get(int port);
-int mv_eth_bm_config_long_pool_get(int port);
-int mv_eth_bm_config_long_buf_num_get(int port);
-int mv_eth_bm_config_hwf_short_pool_get(int port);
-int mv_eth_bm_config_hwf_short_buf_num_get(int port);
-int mv_eth_bm_config_hwf_long_pool_get(int port);
-int mv_eth_bm_config_hwf_long_buf_num_get(int port);
-void mv_eth_bm_config_print(void);
+enum mv_eth_bm_type {
+	MV_ETH_BM_FREE,		/* BM pool is not being used by any port		   */
+	MV_ETH_BM_SWF_LONG,	/* BM pool is being used by SWF as long pool		   */
+	MV_ETH_BM_SWF_SHORT,	/* BM pool is being used by SWF as short pool		   */
+	MV_ETH_BM_HWF_LONG,	/* BM pool is being used by HWF as long pool		   */
+	MV_ETH_BM_HWF_SHORT,	/* BM pool is being used by HWF as short pool		   */
+	MV_ETH_BM_MIXED_LONG,	/* BM pool is being used by both HWF and SWF as long pool  */
+	MV_ETH_BM_MIXED_SHORT	/* BM pool is being used by both HWF and SWF as short pool */
+};
+
+/* Macros for using mv_eth_bm_type */
+#define MV_ETH_BM_POOL_IS_HWF(type)	((type == MV_ETH_BM_HWF_LONG) || (type == MV_ETH_BM_HWF_SHORT))
+#define MV_ETH_BM_POOL_IS_SWF(type)	((type == MV_ETH_BM_SWF_LONG) || (type == MV_ETH_BM_SWF_SHORT))
+#define MV_ETH_BM_POOL_IS_MIXED(type)	((type == MV_ETH_BM_MIXED_LONG) || (type == MV_ETH_BM_MIXED_SHORT))
+#define MV_ETH_BM_POOL_IS_SHORT(type)	((type == MV_ETH_BM_SWF_SHORT) || (type == MV_ETH_BM_HWF_SHORT)\
+									|| (type == MV_ETH_BM_MIXED_SHORT))
+#define MV_ETH_BM_POOL_IS_LONG(type)	((type == MV_ETH_BM_SWF_LONG) || (type == MV_ETH_BM_HWF_LONG)\
+									|| (type == MV_ETH_BM_MIXED_LONG))
+
+/* Default size of packet size for short pools */
+#define MV_ETH_BM_SHORT_BUFF_SIZE	256
+
+struct bm_pool {
+	int			pool;
+	enum mv_eth_bm_type	type;
+	int			capacity;
+	int			buf_num;
+	int			pkt_size;
+	u32			*bm_pool;
+	MV_STACK		*stack;
+	spinlock_t		lock;
+	u32			port_map;
+	int			missed;		/* FIXME: move to stats */
+	struct			pool_stats stats;
+};
 
 extern struct bm_pool mv_eth_pool[MV_ETH_BM_POOLS];
 extern struct eth_port **mv_eth_ports;
@@ -772,9 +793,12 @@ int         mv_eth_ctrl_tx_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_dbg_flag(int port, u32 flag, u32 val);
 int	    mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size, int hwf_size);
 int         mv_eth_ctrl_rxq_size_set(int port, int rxq, int value);
-int         mv_eth_ctrl_port_buf_num_set(int port, int long_num, int short_num);
-int         mv_eth_ctrl_port_hwf_buf_num_set(int port, int hwf_long_num, int hwf_short_num);
+int	    mv_eth_ctrl_pool_buf_num_set(int pool, int buf_num);
 int         mv_eth_ctrl_pool_size_set(int pool, int pkt_size);
+int	    mv_eth_ctrl_long_pool_set(int port, int pool);
+int	    mv_eth_ctrl_short_pool_set(int port, int pool);
+int	    mv_eth_ctrl_hwf_long_pool_set(int port, int pool);
+int	    mv_eth_ctrl_hwf_short_pool_set(int port, int pool);
 int         mv_eth_ctrl_set_poll_rx_weight(int port, u32 weight);
 void        mv_eth_tx_desc_print(struct pp2_tx_desc *desc);
 void        mv_eth_pkt_print(struct eth_pbuf *pkt);
-- 
1.7.5.4

