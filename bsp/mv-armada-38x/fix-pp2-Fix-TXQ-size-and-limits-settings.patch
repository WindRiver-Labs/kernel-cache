From de6698378d90847b9df7abf6004285783922760f Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Sun, 29 Jun 2014 11:51:12 -0400
Subject: [PATCH 1748/1825] fix: pp2: Fix TXQ size and limits settings

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5240c9e36f5f83f6ab0f1848da1dfdeb06c72556

	- Fix JIRA bug: SYSTEMSW-665
	- Setting TXQ size will reset HWF and SWF limits
	- Update help description in gbe/tx sysfs directory

Change-Id: I63f9080ec7054eba663e213e290592c416d0ff14
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8765
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |    2 +-
 .../mv_pp2/net_dev/mv_eth_tx_sysfs.c               |   24 ++--
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  130 +++++++++-----------
 3 files changed, 71 insertions(+), 85 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index 65f5b23..7cd583c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -113,7 +113,7 @@ config MV_ETH_TXQ_DEF
 
 config MV_ETH_TXQ_HWF_DESC
 	int "Number of HWF Tx descriptors"
-	depends on MV_ETH_PP2
+	depends on (MV_ETH_PP2 && !MV_ETH_PP2_1)
 	default 16
         ---help---
 	The number of HWF dedicated Tx descriptors in each Tx queue.
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
index d69fe7a..358da87 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
@@ -45,21 +45,21 @@ static ssize_t mv_eth_help(char *buf)
 #ifdef CONFIG_MV_ETH_PP2_1
 	off += sprintf(buf+off, "echo [p] [txp] [txq]             > pTxqCounters  - show TXQ Counters for port <p/txp/txq> where <txq> range [0..7]\n");
 #endif
-	off += sprintf(buf+off, "echo [p] [txp] [txq]            > pTxqRegs      - show TXQ registers for port <p/txp/txq> where <txq> range [0..7]\n");
-	off += sprintf(buf+off, "echo [txq]                      > gTxqRegs      - show TXQ registers for global <txq> range [0..255]\n");
-	off += sprintf(buf+off, "echo [cpu]                      > aggrTxqRegs   - show Aggregation TXQ registers for <cpu> range [0..max]\n");
-	off += sprintf(buf+off, "echo [cpu] [v]                  > aggrTxqShow   - show aggregated TXQ descriptors ring for <cpu>.\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]        > txqShow       - show TXQ descriptors ring for <p/txp/txq>. v: 0-brief, 1-full\n");
-	off += sprintf(buf+off, "echo [p] [hex]                  > txFlags       - bits: 0-no_pad, 1-mh, 2-hw_cmd\n");
-	off += sprintf(buf+off, "echo [p] [hex]                  > txMH          - set 2 bytes of Marvell Header for transmit\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [cpu]      > txqDef        - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]        > txqSize       - set descriptor Q size <v>, and HWF share <hwf> for <p/txp/txq>.\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq]             > pTxqRegs      - show TXQ registers for port <p/txp/txq> where <txq> range [0..7]\n");
+	off += sprintf(buf+off, "echo [txq]                       > gTxqRegs      - show TXQ registers for global <txq> range [0..255]\n");
+	off += sprintf(buf+off, "echo [cpu]                       > aggrTxqRegs   - show Aggregation TXQ registers for <cpu> range [0..max]\n");
+	off += sprintf(buf+off, "echo [cpu] [v]                   > aggrTxqShow   - show aggregated TXQ descriptors ring for <cpu>.\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]         > txqShow       - show TXQ descriptors ring for <p/txp/txq>. v: 0-brief, 1-full\n");
+	off += sprintf(buf+off, "echo [p] [hex]                   > txFlags       - set TX flags. bits: 0-no_pad, 1-mh, 2-hw_cmd\n");
+	off += sprintf(buf+off, "echo [p] [hex]                   > txMH          - set 2 bytes of Marvell Header for transmit\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [cpu]       > txqDef        - set default <txp/txq> for packets sent to port <p> by <cpu>\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]         > txqSize       - set TXQ size <v> for <p/txp/txq>.\n");
 #ifdef CONFIG_MV_ETH_PP2_1
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf] [swf] > txqLimit      - set HWF <hwf> and SWF <swf> share for <p/txp/txq>.\n");
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]         > txqChunk      - set <txp/txq> SWF request chunk size [v] for port <p>\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf] [swf] > txqLimit      - set HWF <hwf> and SWF <swf> limits for <p/txp/txq>.\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [v]         > txqChunk      - set SWF request chunk [v] for <p/txp/txq>\n");
 
 #else
-	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf]       > txqLimit       - set HWF share <hwf> for <p/txp/txq>.\n");
+	off += sprintf(buf+off, "echo [p] [txp] [txq] [hwf]       > txqLimit      - set HWF limit <hwf> for <p/txp/txq>.\n");
 #endif
 	return off;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 46b7836..4be5512 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -945,6 +945,33 @@ int mv_eth_ctrl_rxq_size_set(int port, int rxq, int value)
 	return 0;
 }
 
+static void mv_pp2_txq_size_set(struct tx_queue *txq_ctrl, int txq_size)
+{
+	int cpu;
+	struct txq_cpu_ctrl *txq_cpu_ptr;
+
+	txq_ctrl->txq_size = txq_size;
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	txq_ctrl->rsvd_chunk = MV_ETH_CPU_DESC_CHUNK;
+	txq_ctrl->hwf_size = txq_ctrl->txq_size - (nr_cpu_ids * txq_ctrl->rsvd_chunk);
+	txq_ctrl->swf_size = txq_ctrl->txq_size - 2 * (nr_cpu_ids * txq_ctrl->rsvd_chunk);
+
+	for_each_possible_cpu(cpu) {
+		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
+
+		txq_cpu_ptr->txq_size = txq_ctrl->txq_size;
+	}
+#else
+	txq_ctrl->hwf_size = CONFIG_MV_ETH_TXQ_HWF_DESC;
+
+	for_each_possible_cpu(cpu) {
+		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
+
+		txq_cpu_ptr->txq_size = (txq_ctrl->txq_size - txq_ctrl->hwf_size) / nr_cpu_ids;
+	}
+#endif /* CONFIG_MV_ETH_PP2_1 */
+}
 
 /* set <txp/txq> SWF request chunk size */
 int mv_eth_ctrl_txq_chunk_set(int port, int txp, int txq, int chunk_size)
@@ -952,19 +979,22 @@ int mv_eth_ctrl_txq_chunk_set(int port, int txp, int txq, int chunk_size)
 	struct tx_queue *txq_ctrl;
 	struct eth_port *pp = mv_eth_port_by_id(port);
 
-
 	if (pp == NULL) {
 		printk(KERN_INFO "port does not exist (%d) in %s\n" , port, __func__);
 		return -EINVAL;
 	}
 
 	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
-
 	if (!txq_ctrl) {
 		printk(KERN_INFO "queue does not exist (%d) in %s\n" , port, __func__);
 		return -EINVAL;
 	}
-
+	/* chunk_size must be less than swf_size */
+	if (chunk_size > txq_ctrl->swf_size) {
+		pr_err("Chunk size %d must be less or equal than swf size %d\n",
+			chunk_size, txq_ctrl->swf_size);
+		return -EINVAL;
+	}
 	txq_ctrl->rsvd_chunk = chunk_size;
 
 	return MV_OK;
@@ -985,41 +1015,39 @@ int mv_eth_ctrl_txq_limits_set(int port, int txp, int txq, int hwf_size, int swf
 
 	pp = mv_eth_port_by_id(port);
 	if (pp == NULL) {
-		printk(KERN_INFO "port does not exist (%d) in %s\n" , port, __func__);
+		pr_err("port does not exist (%d) in %s\n" , port, __func__);
 		return -EINVAL;
 	}
 
 	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
 
 	if (!txq_ctrl) {
-		printk(KERN_INFO "queue is null %s\n", __func__);
+		pr_err("queue is null %s\n", __func__);
 		return -EINVAL;
 	}
 
 	txq_size = txq_ctrl->txq_size;
 
-#ifdef CONFIG_MV_ETH_PP2_1
-	if (hwf_size < swf_size) {
-		printk(KERN_ERR "Invalid size params, swf size must be less than hwf size\n");
+	if (txq_size < hwf_size) {
+		pr_err("invalid hwf size, must be less or equal to txq size (%d)\n", txq_size);
 		return -EINVAL;
 	}
-#endif
 
-	if (txq_size < hwf_size) {
-		printk(KERN_ERR "invalid hwf size, must be less or equal to txq size (%d)\n", txq_size);
+	if (hwf_size % 16 != 0) {
+		pr_err("invalid hwf size, must be aligned to 16\n");
 		return -EINVAL;
 	}
 
-	if (hwf_size % 16 != 0) {
-		printk(KERN_ERR "invalid hwf size, must be aligned to 16\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	if (hwf_size < swf_size) {
+		pr_err("Invalid size params, swf size must be less than hwf size\n");
 		return -EINVAL;
 	}
+	txq_ctrl->swf_size = swf_size;
+#endif /* CONFIG_MV_ETH_PP2_1 */
 
 	txq_ctrl->hwf_size = hwf_size;
 
-#ifdef CONFIG_MV_ETH_PP2_1
-	txq_ctrl->swf_size = swf_size;
-#endif
 	mvPp2TxqHwfSizeSet(port, txp, txq, hwf_size);
 
 	return 0;
@@ -1027,9 +1055,7 @@ int mv_eth_ctrl_txq_limits_set(int port, int txp, int txq, int hwf_size, int swf
 
 int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size)
 {
-	int cpu, cpu_size;
 	struct tx_queue *txq_ctrl;
-	struct txq_cpu_ctrl *txq_cpu_ptr;
 	struct eth_port *pp;
 
 	if (mvPp2TxpCheck(port, txp))
@@ -1055,18 +1081,11 @@ int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size)
 	}
 
 	txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
-
 	if (!txq_ctrl) {
 		pr_err("TXQ is not exist\n");
 		return -EINVAL;
 	}
 
-	if ((txq_ctrl->q) && (txq_size < txq_ctrl->hwf_size)) {
-		pr_err("Invalid TXQ size %d, must be greater than HWF size (%d)\n",
-			txq_size, txq_ctrl->hwf_size);
-		return -EINVAL;
-	}
-
 	if ((txq_ctrl->q) && (txq_ctrl->txq_size != txq_size)) {
 		/* Clean and Reset of txq is required when TXQ ring size is changed */
 		mv_eth_txq_clean(port, txp, txq);
@@ -1076,24 +1095,8 @@ int mv_eth_ctrl_txq_size_set(int port, int txp, int txq, int txq_size)
 		mvPp2TxqReset(port, txp, txq);
 		mv_eth_txq_delete(pp, txq_ctrl);
 	}
+	mv_pp2_txq_size_set(txq_ctrl, txq_size);
 
-	txq_ctrl->txq_size = txq_size;
-
-	/* right now, all cpus have same size */
-	/* relevant only for ppv2.1 */
-	cpu_size = (txq_ctrl->txq_size - txq_ctrl->hwf_size) / CONFIG_NR_CPUS;
-
-#ifdef CONFIG_MV_ETH_PP2_1
-	for_each_possible_cpu(cpu) {
-		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
-		txq_cpu_ptr->txq_size = txq_size;
-	}
-#else
-	for_each_possible_cpu(cpu) {
-		txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
-		txq_cpu_ptr->txq_size = cpu_size;
-	}
-#endif
 	/* New TXQ will be created during mv_eth_start_internals */
 	return 0;
 }
@@ -4113,9 +4116,8 @@ EXPORT_SYMBOL(mv_eth_netdev_find);
 
 int mv_eth_hal_init(struct eth_port *pp)
 {
-	int rxq, txp, txq, size, cpu;
+	int rxq, txp, txq, size;
 	struct tx_queue *txq_ctrl;
-	struct txq_cpu_ctrl *txq_cpu_ptr;
 	struct rx_queue *rxq_ctrl;
 
 	/* Init port */
@@ -4137,36 +4139,11 @@ int mv_eth_hal_init(struct eth_port *pp)
 		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++) {
 			txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
 
-			txq_ctrl->q = NULL;
 			txq_ctrl->txp = txp;
 			txq_ctrl->txq = txq;
-			txq_ctrl->txq_size = CONFIG_MV_ETH_TXQ_DESC;
-			txq_ctrl->hwf_size = CONFIG_MV_ETH_TXQ_HWF_DESC;
-
-#ifdef CONFIG_MV_ETH_PP2_1
-			txq_ctrl->rsvd_chunk = MV_ETH_CPU_DESC_CHUNK;
-			txq_ctrl->hwf_size =
-				txq_ctrl->txq_size - (nr_cpu_ids * txq_ctrl->rsvd_chunk);
-			txq_ctrl->swf_size =
-				txq_ctrl->hwf_size - (nr_cpu_ids * txq_ctrl->rsvd_chunk);
-#endif
-			for_each_possible_cpu(cpu) {
-				txq_cpu_ptr = &txq_ctrl->txq_cpu[cpu];
-				txq_cpu_ptr->shadow_txq = NULL;
-#ifdef CONFIG_MV_ETH_PP2_1
-				/* In default, all CPUs and TXQs have same chunk size */
-				txq_cpu_ptr->txq_size = CONFIG_MV_ETH_TXQ_DESC;
-				txq_cpu_ptr->reserved_num = 0;
-#else
-				txq_cpu_ptr->txq_size =
-					(CONFIG_MV_ETH_TXQ_DESC - CONFIG_MV_ETH_TXQ_HWF_DESC) / nr_cpu_ids;
-#endif
-				txq_cpu_ptr->txq_count = 0;
-				txq_cpu_ptr->shadow_txq_put_i = 0;
-				txq_cpu_ptr->shadow_txq_get_i = 0;
-			}
-
 			txq_ctrl->txq_done_pkts_coal = mv_ctrl_txdone;
+
+			mv_pp2_txq_size_set(txq_ctrl, CONFIG_MV_ETH_TXQ_DESC);
 		}
 	}
 
@@ -5350,16 +5327,25 @@ void mv_eth_port_status_print(unsigned int port)
 		}
 		pr_cont("\n");
 
+#ifdef CONFIG_MV_ETH_PP2_1
 		pr_info("txq_swf_desc(num) [%2d.q]   = ", txp);
 		for (q = 0; q < CONFIG_MV_ETH_TXQ; q++) {
 			txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + q];
-			pr_cont("%4d ", txq_ctrl->txq_cpu[0].txq_size);
+			pr_cont("%4d ", txq_ctrl->swf_size);
 		}
 		pr_info("txq_rsvd_chunk(num) [%2d.q] = ", txp);
 		for (q = 0; q < CONFIG_MV_ETH_TXQ; q++) {
 			txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + q];
 			pr_cont("%4d ", txq_ctrl->rsvd_chunk);
 		}
+#else
+		pr_info("txq_swf_desc(num) [%2d.q]   = ", txp);
+		for (q = 0; q < CONFIG_MV_ETH_TXQ; q++) {
+			txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + q];
+			pr_cont("%4d ", txq_ctrl->txq_cpu[0].txq_size);
+		}
+#endif /* CONFIG_MV_ETH_PP2_1 */
+
 		pr_cont("\n");
 	}
 	pr_info("\n");
-- 
1.7.5.4

