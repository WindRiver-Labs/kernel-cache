From 2bf8e523af5697fb13613792c50230ca3b8261d0 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 26 Jun 2013 15:42:25 -0400
Subject: [PATCH 0734/1825] PPv2: sysfs: cleanup sysfs code for PP2 network
 driver

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 7e4503257d290b0f41b73a016aca649b9b957032

	- Add functions mv_eth_sysfs_init and mv_eth_sysfs_exit to mv_netdev.c
	- Delete MODULE_??? defines from all sysfs files
	- Code cleanup

Change-Id: I1e9bee0dde6a34d913c591d9b395bc7641413eb8
Reviewed-on: http://vgitil04.il.marvell.com:8080/2357
Reviewed-by: Star_Automation <star@marvell.com>
Reviewed-by: Jonatan Farhadian <yonif@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c         |   36 +--
 .../mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c         |   33 +--
 .../mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c         |   35 +--
 .../mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c       |   61 ++---
 .../mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c          |   35 +--
 .../mv_pp2/net_dev/mv_eth_bm_sysfs.c               |   24 +-
 .../mv_pp2/net_dev/mv_eth_napi_sysfs.c             |   21 +-
 .../mv_pp2/net_dev/mv_eth_pme_sysfs.c              |   21 +-
 .../mv_pp2/net_dev/mv_eth_pon_sysfs.c              |   22 +-
 .../mv_pp2/net_dev/mv_eth_qos_sysfs.c              |   23 +-
 .../mv_pp2/net_dev/mv_eth_rx_sysfs.c               |   21 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   77 +++---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h   |   58 ++++-
 .../mv_pp2/net_dev/mv_eth_tx_sched_sysfs.c         |   22 +-
 .../mv_pp2/net_dev/mv_eth_tx_sysfs.c               |   20 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   64 ++++-
 .../mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c        |   39 +--
 .../mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c          |   39 +--
 .../mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c     |   32 +--
 .../mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c      |   33 +--
 .../mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c          |  281 --------------------
 21 files changed, 338 insertions(+), 659 deletions(-)
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
index bcc9360..8f858a7 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls2_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "../../../mv_hal/pp2/cls/mvPp2Cls2Hw.h"
+#include "cls/mvPp2Cls2Hw.h"
 
 
 static MV_PP2_CLS_C2_QOS_ENTRY		qos_entry;
@@ -301,34 +301,20 @@ static struct attribute_group cls2_group = {
 	.attrs = cls2_attrs,
 };
 
-int __devinit cls2_sysfs_init(void)
+int mv_pp2_cls2_sysfs_init(struct kobject *pp2_kobj)
 {
-	int err;
-	struct device *pd;
+	int err = 0;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &cls2_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", cls2_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &cls2_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(cls2_sysfs_init);
-
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("cls engine C2 for Marvell NetA2");
-MODULE_LICENSE("GPL");
+int mv_pp2_cls2_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &cls2_group);
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
index e96fe903..ab5bae2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls3_sysfs.c
@@ -340,34 +340,21 @@ static struct attribute_group cls3_group = {
 	.attrs = cls3_attrs,
 };
 
-int __devinit cls3_sysfs_init(void)
+int mv_pp2_cls3_sysfs_init(struct kobject *pp2_kobj)
 {
-	int err;
-	struct device *pd;
+	int err = 0;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &cls3_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", cls3_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &cls3_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(cls3_sysfs_init);
+int mv_pp2_cls3_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &cls3_group);
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("cls engine C3 for Marvell NetA2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
index 20a1309..43c0130 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls4_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "../../../mv_hal/pp2/cls/mvPp2Cls4Hw.h"
+#include "pp2/cls/mvPp2Cls4Hw.h"
 
 
 static MV_PP2_CLS_C4_ENTRY		C4;
@@ -241,34 +241,21 @@ static struct attribute_group cls4_group = {
 	.attrs = cls4_attrs,
 };
 
-int __devinit cls4_sysfs_init(void)
+int mv_pp2_cls4_sysfs_init(struct kobject *pp2_kobj)
 {
-	int err;
-	struct device *pd;
+	int err = 0;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &cls4_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", cls4_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &cls4_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(cls4_sysfs_init);
+int mv_pp2_cls4_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &cls4_group);
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("cls engine C4 for Marvell PP2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
index 1667e93..346dfd3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_mc_sysfs.c
@@ -39,27 +39,25 @@ disclaimer.
 
 static MV_PP2_MC_ENTRY		mc;
 
-
-
 static ssize_t mv_mc_help(char *buf)
 {
 	int off = 0;
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		  sw_dump 		- Dump software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "cat		  hw_dump 		- Dump all hardware entries.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat	        sw_dump      - Dump software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "cat	        hw_dump      - Dump all hardware entries.\n");
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
-	off += scnprintf(buf + off, PAGE_SIZE, "echo i		> hw_write		- Write software entry into hardware <i>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo i		> hw_read 		- Read entry <i> from hardware into software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> sw_clear		- Clear software entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo 1		> hw_clear_all		- Clear all multicast table entries in hardware.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo i	      > hw_write     - Write software entry into hardware <i>.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo i	      > hw_read      - Read entry <i> from hardware into software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1	      > sw_clear     - Clear software entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo 1	      > hw_clear_all - Clear all multicast table entries in hardware.\n");
 
-	off += scnprintf(buf + off, PAGE_SIZE, "echo prio en	> mc_sw_prio		- Set modified priority enable <en> and value <prio> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo dscp en	> mc_sw_dscp		- Set modified DSCP enable <en> and value <dscp> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo gpid en	> mc_sw_gpid		- Set modified GemPortID enable <en> and value <gpid> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo d i        > mc_sw_modif             - Set modification data pointer <d> and instruction pointer <i> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo q		> mc_sw_queue		- Set Queue <q> value to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo en		> mc_sw_hwf		- Set HWF enabled <en=1> or disable <en=0> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE, "echo next	> mc_sw_next		- Set next pointer <next> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo prio en  > mc_sw_prio   - Set priority enable <en> and value <prio> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo dscp en  > mc_sw_dscp   - Set DSCP enable <en> and value <dscp> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo gpid en  > mc_sw_gpid   - Set GemPortID enable <en> and value <gpid> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo d i      > mc_sw_modif  - Set modification data <d> and command <i> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo q	      > mc_sw_queue  - Set Queue <q> value to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo en	      > mc_sw_hwf    - Set HWF enabled <en=1> or disable <en=0> to sw entry.\n");
+	off += scnprintf(buf + off, PAGE_SIZE, "echo next     > mc_sw_next   - Set next pointer <next> to sw entry.\n");
 
 	off += scnprintf(buf + off, PAGE_SIZE, "\n");
 
@@ -174,34 +172,21 @@ static struct attribute_group mc_group = {
 	.attrs = mc_attrs,
 };
 
-int __devinit mc_sysfs_init(void)
+int mv_pp2_mc_sysfs_init(struct kobject *pp2_kobj)
 {
-	int err;
-	struct device *pd;
+	int err = 0;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &mc_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mc_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &mc_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(mc_sysfs_init);
+int mv_pp2_mc_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &mc_group);
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("Multicast table for Marvell PP2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
index eac7442..8327730 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cls/cls_sysfs.c
@@ -34,7 +34,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mvCommon.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "../../../mv_hal/pp2/cls/mvPp2ClsHw.h"
+#include "pp2/cls/mvPp2ClsHw.h"
 
 static MV_PP2_CLS_LKP_ENTRY	lkp_entry;
 static MV_PP2_CLS_FLOW_ENTRY	flow_entry;
@@ -291,34 +291,21 @@ static struct attribute_group cls_group = {
 	.attrs = cls_attrs,
 };
 
-int __devinit cls_sysfs_init(void)
+int mv_pp2_cls_sysfs_init(struct kobject *pp2_kobj)
 {
-	int err;
-	struct device *pd;
+	int err = 0;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &cls_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", cls_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &cls_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(cls_sysfs_init);
+int mv_pp2_cls_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &cls_group);
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("cls for Marvell NetA2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
index fdcf946..b059b4f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_bm_sysfs.c
@@ -109,7 +109,7 @@ static DEVICE_ATTR(poolSize,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(portHwfBuffNum,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(portSwfBuffNum,	S_IWUSR, NULL, mv_eth_port_store);
 
-static struct attribute *mv_eth_attrs[] = {
+static struct attribute *mv_eth_bm_attrs[] = {
 	&dev_attr_help.attr,
 	&dev_attr_poolRegs.attr,
 	&dev_attr_poolStatus.attr,
@@ -119,26 +119,26 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_bm_group = {
 	.name = "bm",
-	.attrs = mv_eth_attrs,
+	.attrs = mv_eth_bm_attrs,
 };
 
-int mv_eth_bm_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_bm_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
+	err = sysfs_create_group(pp2_kobj, &mv_eth_bm_group);
+	if (err)
 		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+int mv_pp2_bm_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &mv_eth_bm_group);
+
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_napi_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_napi_sysfs.c
index 40dd6e3..2125295 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_napi_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_napi_sysfs.c
@@ -146,26 +146,25 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_napi_group = {
 	.name = "napi",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_napi_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_napi_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &mv_eth_napi_group);
+	if (err)
+		pr_err("sysfs group i%s failed %d\n", mv_eth_napi_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+int mv_pp2_napi_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_napi_group);
 
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
index 3b9456e..a63faad 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pme_sysfs.c
@@ -109,26 +109,25 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group gbe_pme_group = {
 	.name = "pme",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_pme_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_gbe_pme_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &gbe_pme_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", gbe_pme_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+int mv_pp2_gbe_pme_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &gbe_pme_group);
 
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
index de42d73..a3d4beb 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_pon_sysfs.c
@@ -119,26 +119,24 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_pon_group = {
 	.name = "pon",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_pon_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_pon_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &mv_eth_pon_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_pon_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
-
+int mv_pp2_pon_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_pon_group);
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_qos_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_qos_sysfs.c
index 0a31f44..361746e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_qos_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_qos_sysfs.c
@@ -132,25 +132,24 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_qos_group = {
 	.name = "qos",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_qos_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_qos_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
+	err = sysfs_create_group(gbe_kobj, &mv_eth_qos_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_qos_group.name, err);
+
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
-
+int mv_pp2_qos_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_qos_group);
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
index 2e6ef15f..b373c67 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_rx_sysfs.c
@@ -157,26 +157,25 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_rx_group = {
 	.name = "rx",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_rx_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_rx_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &mv_eth_rx_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_rx_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+int mv_pp2_rx_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_rx_group);
 
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 9dbba68..1480d96 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -37,7 +37,6 @@ disclaimer.
 #include "mv_netdev.h"
 #include "mv_eth_sysfs.h"
 
-static struct kobject *pp2_kobj;
 
 static ssize_t mv_eth_help(char *buf)
 {
@@ -79,12 +78,10 @@ static ssize_t mv_eth_show(struct device *dev,
 	if (!capable(CAP_NET_ADMIN))
 		return -EPERM;
 
-	if (!strcmp(name, "addrDec")) {
-		/*mvPp2AddressDecodeRegsPrint();*/
+	if (!strcmp(name, "addrDec"))
 		mvPp2AddrDecodeRegs();
-	} else {
+	else
 		off = mv_eth_help(buf);
-	}
 
 	return off;
 }
@@ -281,57 +278,49 @@ static struct attribute_group mv_eth_group = {
 	.attrs = mv_eth_attrs,
 };
 
-int __devinit mv_eth_sysfs_init(void)
+static struct kobject *gbe_kobj;
+
+int mv_pp2_gbe_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
 
-	if (!pd) {
-		printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	pp2_kobj = kobject_create_and_add("gbe", &pd->kobj);
-	if (!pp2_kobj) {
+	gbe_kobj = kobject_create_and_add("gbe", pp2_kobj);
+	if (!gbe_kobj) {
 		printk(KERN_ERR"%s: cannot create gbe kobject\n", __func__);
 		return -ENOMEM;
 	}
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
+	err = sysfs_create_group(gbe_kobj, &mv_eth_group);
 	if (err) {
 		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
+		return err;
 	}
 
-	mv_eth_bm_sysfs_init(pp2_kobj);
-
-	mv_eth_napi_sysfs_init(pp2_kobj);
-
-	mv_eth_rx_sysfs_init(pp2_kobj);
+	mv_pp2_bm_sysfs_init(gbe_kobj);
+	mv_pp2_napi_sysfs_init(gbe_kobj);
+	mv_pp2_rx_sysfs_init(gbe_kobj);
+	mv_pp2_tx_sysfs_init(gbe_kobj);
+	mv_pp2_tx_sched_sysfs_init(gbe_kobj);
+	mv_pp2_qos_sysfs_init(gbe_kobj);
+	mv_pp2_pon_sysfs_init(gbe_kobj);
+	mv_pp2_gbe_pme_sysfs_init(gbe_kobj);
 
-	mv_eth_tx_sysfs_init(pp2_kobj);
-
-	mv_eth_tx_sched_sysfs_init(pp2_kobj);
-
-	mv_eth_qos_sysfs_init(pp2_kobj);
-
-	mv_eth_pon_sysfs_init(pp2_kobj);
-
-	mv_eth_pme_sysfs_init(pp2_kobj);
-
-out:
 	return err;
 }
 
-module_init(mv_eth_sysfs_init);
-
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
-
+int mv_pp2_gbe_sysfs_exit(struct kobject *pp2_kobj)
+{
+	mv_pp2_gbe_pme_sysfs_exit(gbe_kobj);
+	mv_pp2_pon_sysfs_exit(gbe_kobj);
+	mv_pp2_qos_sysfs_init(gbe_kobj);
+	mv_pp2_tx_sched_sysfs_init(gbe_kobj);
+	mv_pp2_tx_sysfs_init(gbe_kobj);
+	mv_pp2_rx_sysfs_init(gbe_kobj);
+	mv_pp2_napi_sysfs_init(gbe_kobj);
+	mv_pp2_bm_sysfs_exit(pp2_kobj);
+
+	sysfs_remove_group(pp2_kobj, &mv_eth_group);
+/*      remove_group_kobj_put(&pd->kobj, &mv_eth_group); */
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
index e6b6196..870bf82 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
@@ -28,20 +28,62 @@ disclaimer.
 #ifndef __mv_eth_sysfs_h__
 #define __mv_eth_sysfs_h__
 
-int mv_eth_bm_sysfs_init(struct kobject *pp2_kobj);
+int mv_mux_sysfs_init(struct kobject *pp2_kobj);
 
-int mv_eth_napi_sysfs_init(struct kobject *pp2_kobj);
+/* Subdirectories of pp2 menu */
+int mv_pp2_prs_low_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_prs_low_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_rx_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_prs_high_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_prs_high_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_tx_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_tx_sched_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls2_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls2_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_qos_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls3_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls3_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_pon_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls4_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_cls4_sysfs_exit(struct kobject *pp2_kobj);
 
-int mv_eth_pme_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_mc_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_mc_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_pme_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_pme_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_plcr_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_plcr_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_gbe_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_gbe_sysfs_exit(struct kobject *pp2_kobj);
+
+/* Subdirectories of gbe menu */
+int mv_pp2_bm_sysfs_init(struct kobject *gbe_kobj);
+int mv_pp2_bm_sysfs_exit(struct kobject *gbe_kobj);
+
+int mv_pp2_napi_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_napi_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_rx_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_rx_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_tx_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_tx_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_tx_sched_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_tx_sched_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_qos_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_qos_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_pon_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_pon_sysfs_exit(struct kobject *pp2_kobj);
+
+int mv_pp2_gbe_pme_sysfs_init(struct kobject *gbe_kobj);
+int mv_pp2_gbe_pme_sysfs_exit(struct kobject *gbe_kobj);
 
 #endif /* __mv_eth_sysfs_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sched_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sched_sysfs.c
index eb78caf..a9ab8d8 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sched_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sched_sysfs.c
@@ -128,26 +128,24 @@ static struct attribute *mv_eth_attrs[] = {
 	NULL
 };
 
-static struct attribute_group mv_eth_group = {
+static struct attribute_group mv_eth_tx_sched_group = {
 	.name = "tx_sched",
 	.attrs = mv_eth_attrs,
 };
 
-int mv_eth_tx_sched_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_tx_sched_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &mv_eth_tx_sched_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_tx_sched_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
-
+int mv_pp2_tx_sched_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_tx_sched_group);
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
index 7b912e3..e96c513 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tx_sysfs.c
@@ -176,21 +176,21 @@ static struct attribute_group mv_eth_tx_group = {
 	.attrs = mv_eth_tx_attrs,
 };
 
-int mv_eth_tx_sysfs_init(struct kobject *pp2_kobj)
+int mv_pp2_tx_sysfs_init(struct kobject *gbe_kobj)
 {
 	int err;
 
-	err = sysfs_create_group(pp2_kobj, &mv_eth_tx_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
+	err = sysfs_create_group(gbe_kobj, &mv_eth_tx_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", mv_eth_tx_group.name, err);
 
-out:
 	return err;
 }
 
-MODULE_AUTHOR("Kostya Belezko");
-MODULE_DESCRIPTION("sysfs for marvell GbE");
-MODULE_LICENSE("GPL");
+int mv_pp2_tx_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_tx_group);
+
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 03cffc6..1282600 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -57,6 +57,7 @@ disclaimer.
 #include "mv_mux_netdev.h"
 #include "mv_netdev.h"
 #include "mv_eth_tool.h"
+#include "mv_eth_sysfs.h"
 
 #define MV_ETH_MAX_NAPI_GROUPS	MV_ETH_MAX_RXQ
 
@@ -2941,9 +2942,8 @@ int mv_eth_port_resume(int port)
  * mv_eth_win_init --                                      *
  *   Win initilization                                     *
  ***********************************************************/
-void 	mv_eth_win_init()
+void	mv_eth_win_init(void)
 {
-
 	MV_UNIT_WIN_INFO *addrWinMap;
 	MV_STATUS status;
 	int i;
@@ -2996,10 +2996,61 @@ int	mv_eth_pm_mode_set(int port, int mode)
 	return 0;
 }
 
+static void mv_eth_sysfs_exit(void)
+{
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	if (!pd) {
+		printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
+		return;
+	}
+	mv_pp2_pme_sysfs_exit(&pd->kobj);
+	mv_pp2_plcr_sysfs_exit(&pd->kobj);
+	mv_pp2_mc_sysfs_exit(&pd->kobj);
+	mv_pp2_cls4_sysfs_exit(&pd->kobj);
+	mv_pp2_cls3_sysfs_exit(&pd->kobj);
+	mv_pp2_cls2_sysfs_exit(&pd->kobj);
+	mv_pp2_cls_sysfs_exit(&pd->kobj);
+	mv_pp2_prs_low_sysfs_exit(&pd->kobj);
+	mv_pp2_prs_high_sysfs_exit(&pd->kobj);
+	mv_pp2_gbe_sysfs_exit(&pd->kobj);
+}
+
+static int mv_eth_sysfs_init(void)
+{
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	if (!pd) {
+		platform_device_register_simple("pp2", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
+	}
+
+	if (!pd) {
+		printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
+		return -1;
+	}
+
+	mv_pp2_gbe_sysfs_init(&pd->kobj);
+	mv_pp2_prs_low_sysfs_init(&pd->kobj);
+	mv_pp2_prs_high_sysfs_init(&pd->kobj);
+	mv_pp2_cls_sysfs_init(&pd->kobj);
+	mv_pp2_cls2_sysfs_init(&pd->kobj);
+	mv_pp2_cls3_sysfs_init(&pd->kobj);
+	mv_pp2_cls4_sysfs_init(&pd->kobj);
+	mv_pp2_mc_sysfs_init(&pd->kobj);
+	mv_pp2_plcr_sysfs_init(&pd->kobj);
+	mv_pp2_pme_sysfs_init(&pd->kobj);
+
+	return 0;
+}
 static int	mv_eth_shared_probe(void)
 {
 	int size, cpu;
 
+	mv_eth_sysfs_init();
+
 	/* init MAC Unit */
 	mvSysPp2Init();
 	mv_eth_config_show();
@@ -3681,6 +3732,8 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 	/* start the hal - rx/tx activity */
 
 	clear_bit(MV_ETH_F_LINK_UP_BIT, &(pp->flags));
+
+	status = MV_NOT_READY;
 	if (!MV_PON_PORT(pp->port))
 		status = mvPp2PortEnable(pp->port);
 #ifdef CONFIG_MV_INCLUDE_PON
@@ -4909,13 +4962,14 @@ int mv_eth_resume(struct platform_device *pdev)
 
 static int mv_eth_remove(struct platform_device *pdev)
 {
-    printk(KERN_INFO "Removing Marvell Ethernet Driver\n");
-    return 0;
+	printk(KERN_INFO "Removing Marvell Ethernet Driver\n");
+	mv_eth_sysfs_exit();
+	return 0;
 }
 
 static void mv_eth_shutdown(struct platform_device *pdev)
 {
-    printk(KERN_INFO "Shutting Down Marvell Ethernet Driver\n");
+	printk(KERN_INFO "Shutting Down Marvell Ethernet Driver\n");
 }
 
 static struct platform_driver mv_eth_driver = {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
index 4b5abfc..d0fccff 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/plcr/plcr_sysfs.c
@@ -185,34 +185,21 @@ static struct attribute_group plcr_group = {
 	.attrs = plcr_attrs,
 };
 
-int __devinit plcr_sysfs_init(void)
+int mv_pp2_plcr_sysfs_init(struct kobject *pp2_kobj)
 {
-		int err;
-		struct device *pd;
-
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-		if (!pd) {
-			platform_device_register_simple("pp2", -1, NULL, 0);
-			pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-		}
-
-		if (!pd) {
-			printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
-			pd = &platform_bus;
-		}
-
-		err = sysfs_create_group(&pd->kobj, &plcr_group);
-		if (err) {
-			printk(KERN_INFO "sysfs group failed %d\n", err);
-			goto out;
-		}
-out:
-		return err;
+	int err;
+
+	err = sysfs_create_group(pp2_kobj, &plcr_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", plcr_group.name, err);
+
+	return err;
 }
 
-module_init(plcr_sysfs_init);
+int mv_pp2_plcr_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &plcr_group);
 
-MODULE_AUTHOR("Dima Epshtein");
-MODULE_DESCRIPTION("PLCR sysfs for Marvell PPv2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
index cf748d5..1d4ff30 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/pme/pme_sysfs.c
@@ -301,34 +301,21 @@ static struct attribute_group pme_group = {
 	.attrs = pme_attrs,
 };
 
-int __devinit pme_sysfs_init(void)
+int mv_pp2_pme_sysfs_init(struct kobject *pp2_kobj)
 {
-		int err;
-		struct device *pd;
-
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-		if (!pd) {
-			platform_device_register_simple("pp2", -1, NULL, 0);
-			pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-		}
-
-		if (!pd) {
-			printk(KERN_ERR"%s: cannot find pp2 device\n", __func__);
-			pd = &platform_bus;
-		}
-
-		err = sysfs_create_group(&pd->kobj, &pme_group);
-		if (err) {
-			printk(KERN_INFO "sysfs group failed %d\n", err);
-			goto out;
-		}
-out:
-		return err;
+	int err;
+
+	err = sysfs_create_group(pp2_kobj, &pme_group);
+	if (err)
+		printk(KERN_INFO "sysfs group %s failed %d\n", pme_group.name, err);
+
+	return err;
 }
 
-module_init(pme_sysfs_init);
+int mv_pp2_pme_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &pme_group);
 
-MODULE_AUTHOR("Dima Epshtein");
-MODULE_DESCRIPTION("PME for Marvell PPv2");
-MODULE_LICENSE("GPL");
+	return 0;
+}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
index 9330b39..4df9b66 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_high_sysfs.c
@@ -187,33 +187,21 @@ static struct attribute_group prs_high_group = {
 	.attrs = prs_high_attrs,
 };
 
-int __devinit prs_high_sysfs_init(void)
+int mv_pp2_prs_high_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err;
-	struct device *pd;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &prs_high_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", prs_high_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &prs_high_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(prs_high_sysfs_init);
+int mv_pp2_prs_high_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &prs_high_group);
+
+	return 0;
+}
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("prs for Marvell Ppv2");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
index 2cec5f4..dacbb5f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_low_sysfs.c
@@ -248,33 +248,22 @@ static struct attribute_group prs_low_group = {
 	.attrs = prs_low_attrs,
 };
 
-int __devinit prs_low_sysfs_init(void)
+int mv_pp2_prs_low_sysfs_init(struct kobject *pp2_kobj)
 {
 	int err;
-	struct device *pd;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
+	err = sysfs_create_group(pp2_kobj, &prs_low_group);
+	if (err)
+		pr_err("sysfs group %s failed %d\n", prs_low_group.name, err);
 
-	err = sysfs_create_group(&pd->kobj, &prs_low_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
 	return err;
 }
 
-module_init(prs_low_sysfs_init);
+int mv_pp2_prs_low_sysfs_exit(struct kobject *pp2_kobj)
+{
+	sysfs_remove_group(pp2_kobj, &prs_low_group);
+
+	return 0;
+}
+
 
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("prs for Marvell NetA2");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
deleted file mode 100644
index d9dc89d..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/prs/prs_sysfs.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include "mvOs.h"
-#include "mvCommon.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "pp2/prs/mvPp2PrsHw.h"
-#include "pp2/prs/mvPp2Prs.h"
-
-
-static  MV_PP2_PRS_ENTRY pe;
-
-
-static ssize_t mv_prs_low_help(char *buf)
-{
-	int off = 0;
-
-	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          sw_dump       - dump parser SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_dump       - dump all valid HW entries\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "cat          hw_regs       - dump parser registers.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
-
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_write    - write parser SW entry into HW place <id>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_read     - read parser entry <id> into SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo 1       > sw_clear    - clear parser SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo id      > hw_inv      - invalidate parser entry <id> in hw.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo         > hw_inv_all  - invalidate all parser entries in HW.\n");
-
-	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
-
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p m     > t_port      - add<m=1> or delete<m=0> port<p> in SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo pmap    > t_port_map  - set port map <pmap> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > t_ai        - update ainfo value <v> with mask <m> in SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo o d m   > t_byte      - set byte of data <d> with mask <m> and offset <o> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > t_lu        - set lookup id <v> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > s_ri        - set result info value <v> with mask <m> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v m     > s_ai        - set ainfo value <v> with mask <m> to sw entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_next_lu   - set next lookup id value <v> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_shift     - set packet shift value <v> for next lookup to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo t v     > s_offs      - set offset value <v> for type <t> to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_lu_done   - set (v=1) or clear (v=0) lookup done bit to SW entry.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo v       > s_fid_gen   - set (v=1) or clear (v=0) flowid generate bit in SW entry.\n");
-
-	off += scnprintf(buf + off, PAGE_SIZE - off, "echo p l m o > hw_frst_itr - set values for first iteration port <p>, lookupid <l>, \n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "				  max loops <m>, init offs <o>.\n");
-	off += scnprintf(buf + off, PAGE_SIZE - off, "\n");
-
-	return off;
-}
-
-
-static ssize_t mv_prs_low_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	const char      *name = attr->attr.name;
-	int             off = 0;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-	if (!strcmp(name, "hw_dump"))
-		mvPp2PrsHwDump();
-	else if (!strcmp(name, "sw_dump"))
-		mvPp2PrsSwDump(&pe);
-	else if (!strcmp(name, "hw_regs"))
-		mvPp2PrsHwRegsDump();
-	else
-		off += mv_prs_low_help(buf);
-
-	return off;
-}
-
-static ssize_t mv_prs_low_store_signed(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char    *name = attr->attr.name;
-	int  err = 0, a = 0, b = 0, c = 0, d = 0;
-	unsigned long flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	sscanf(buf, "%d %d %d %d", &a, &b, &c, &d);
-	local_irq_save(flags);
-
-	if (!strcmp(name, "s_shift"))
-		mvPp2PrsSwSramShiftSet(&pe, a, SRAM_OP_SEL_SHIFT_ADD);
-	else if (!strcmp(name, "s_offs"))
-		mvPp2PrsSwSramOffsetSet(&pe, a, b, SRAM_OP_SEL_SHIFT_ADD);
-	else if (!strcmp(name, "hw_frst_itr"))
-		mvPp2PrsHwPortInit(a, b, c, d);
-	else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-	local_irq_restore(flags);
-
-	if (err)
-		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
-
-	return err ? -EINVAL : len;
-}
-
-
-static ssize_t mv_prs_low_store_unsigned(struct device *dev,
-				   struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char    *name = attr->attr.name;
-	unsigned int  err = 0, a = 0, b = 0, c = 0;
-	unsigned long flags;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	sscanf(buf, "%x %x %x", &a, &b, &c);
-
-	local_irq_save(flags);
-
-	if (!strcmp(name, "hw_write")) {
-		pe.index = a;
-		mvPp2PrsHwWrite(&pe);
-	} else if (!strcmp(name, "hw_read")) {
-		pe.index = a;
-		mvPp2PrsHwRead(&pe);
-	} else if (!strcmp(name, "sw_clear"))
-		mvPp2PrsSwClear(&pe);
-	else if (!strcmp(name, "hw_inv"))
-		mvPp2PrsHwInv(a);
-	else if (!strcmp(name, "hw_inv_all"))
-		mvPp2PrsHwInvAll();
-	else if (!strcmp(name, "t_port"))
-		mvPp2PrsSwTcamPortSet(&pe, a, b);
-	else if (!strcmp(name, "t_port_map"))
-		mvPp2PrsSwTcamPortMapSet(&pe, a);
-	else if (!strcmp(name, "t_lu"))
-		mvPp2PrsSwTcamLuSet(&pe, a);
-	else if (!strcmp(name, "t_ai"))
-		mvPp2PrsSwTcamAiUpdate(&pe, a, b);
-	else if (!strcmp(name, "t_byte"))
-		mvPp2PrsSwTcamByteSet(&pe, a, b, c);
-	else if (!strcmp(name, "s_ri"))
-		mvPp2PrsSwSramRiUpdate(&pe, a, b);
-	else if (!strcmp(name, "s_ai"))
-		mvPp2PrsSwSramAiUpdate(&pe, a, b);
-	else if (!strcmp(name, "s_next_lu"))
-		mvPp2PrsSwSramNextLuSet(&pe, a);
-	else if (!strcmp(name, "s_lu_done"))
-		(a == 1) ? 	mvPp2PrsSwSramLuDoneSet(&pe) :
-				mvPp2PrsSwSramLuDoneClear(&pe);
-	else if (!strcmp(name, "s_fid_gen"))
-		(a == 1) ?	mvPp2PrsSwSramFlowidGenSet(&pe) :
-				mvPp2PrsSwSramFlowidGenClear(&pe);
-	else {
-		err = 1;
-		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
-	}
-	local_irq_restore(flags);
-
-	if (err)
-		printk(KERN_ERR "%s: <%s>, error %d\n", __func__, attr->attr.name, err);
-
-	return err ? -EINVAL : len;
-}
-
-
-static DEVICE_ATTR(hw_dump,		S_IRUSR, mv_prs_low_show, NULL);
-static DEVICE_ATTR(sw_dump,		S_IRUSR, mv_prs_low_show, NULL);
-static DEVICE_ATTR(help,		S_IRUSR, mv_prs_low_show, NULL);
-static DEVICE_ATTR(hw_regs,		S_IRUSR, mv_prs_low_show, NULL);
-static DEVICE_ATTR(sw_clear,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_write,    	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_read,     	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_inv,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_inv_all, 		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_byte,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_port,      	S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_port_map,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(t_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(s_ri,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(s_ai,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(s_next_lu,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(s_shift,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
-static DEVICE_ATTR(s_offs,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
-static DEVICE_ATTR(s_lu_done,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(s_fid_gen,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_unsigned);
-static DEVICE_ATTR(hw_frst_itr,		S_IWUSR, mv_prs_low_show, mv_prs_low_store_signed);
-
-
-
-static struct attribute *prs_low_attrs[] = {
-    &dev_attr_hw_dump.attr,
-    &dev_attr_sw_dump.attr,
-    &dev_attr_hw_regs.attr,
-    &dev_attr_hw_write.attr,
-    &dev_attr_hw_read.attr,
-    &dev_attr_hw_inv.attr,
-    &dev_attr_hw_inv_all.attr,
-    &dev_attr_sw_clear.attr,
-    &dev_attr_t_byte.attr,
-    &dev_attr_t_port.attr,
-    &dev_attr_t_port_map.attr,
-    &dev_attr_t_ai.attr,
-    &dev_attr_t_lu.attr,
-    &dev_attr_s_ri.attr,
-    &dev_attr_s_ai.attr,
-    &dev_attr_s_next_lu.attr,
-    &dev_attr_s_shift.attr,
-    &dev_attr_s_offs.attr,
-    &dev_attr_s_lu_done.attr,
-    &dev_attr_s_fid_gen.attr,
-    &dev_attr_hw_frst_itr.attr,
-    &dev_attr_help.attr,
-    NULL
-};
-
-static struct attribute_group prs_low_group = {
-	.name = "prsLow",
-	.attrs = prs_low_attrs,
-};
-
-int __devinit prs_low_sysfs_init(void)
-{
-	int err;
-	struct device *pd;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
-		pd = &platform_bus;
-	}
-
-	err = sysfs_create_group(&pd->kobj, &prs_low_group);
-	if (err) {
-		printk(KERN_INFO "sysfs group failed %d\n", err);
-		goto out;
-	}
-out:
-	return err;
-}
-
-module_init(prs_low_sysfs_init);
-
-MODULE_AUTHOR("Uri Eliyahu");
-MODULE_DESCRIPTION("prs for Marvell Ppv2");
-MODULE_LICENSE("GPL");
-
-- 
1.7.5.4

