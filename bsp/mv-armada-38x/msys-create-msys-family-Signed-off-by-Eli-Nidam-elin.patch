From 904a9d81e5394782457e4773f4d8017461c66e43 Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Wed, 11 Sep 2013 11:08:54 +0200
Subject: [PATCH 0985/1825] msys: create msys family Signed-off-by: Eli Nidam
 <elini@marvell.com>

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit a4d901ebac6a36da9b15802912f4cb686128a03d

Change-Id: If7e1159d1790ea23b6234f88eeaab7973e64bbcc
Reviewed-on: http://vgitil04.il.marvell.com:8080/3476
Reviewed-by: Igor Patrik <igorp@marvell.com>
Reviewed-by: Eli Nidam <elini@marvell.com>
Tested-by: Eli Nidam <elini@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.c | 1604 ++++++++++++++++++++
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.h |  335 ++++
 .../msys_family/boardEnv/mvBoardEnvSpec.c          |  268 ++++
 .../msys_family/boardEnv/mvBoardEnvSpec.h          |  200 +++
 arch/arm/mach-msys/msys_family/cpu/mvCpu.c         |  308 ++++
 arch/arm/mach-msys/msys_family/cpu/mvCpu.h         |  112 ++
 .../msys_family/ctrlEnv/mvCtrlEnvAddrDec.c         |  376 +++++
 .../msys_family/ctrlEnv/mvCtrlEnvAddrDec.h         |  194 +++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvAsm.h   |   97 ++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   | 1478 ++++++++++++++++++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h   |  216 +++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h  |  358 +++++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h  |  394 +++++
 .../mach-msys/msys_family/ctrlEnv/mvSemaphore.c    |  124 ++
 .../mach-msys/msys_family/ctrlEnv/mvSemaphore.h    |  106 ++
 arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h |  158 ++
 .../msys_family/ctrlEnv/sys/mvAhbToMbus.c          |  750 +++++++++
 .../msys_family/ctrlEnv/sys/mvAhbToMbus.h          |   96 ++
 .../msys_family/ctrlEnv/sys/mvAhbToMbusRegs.h      |  143 ++
 .../mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c    |  946 ++++++++++++
 .../mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.h    |  122 ++
 .../msys_family/ctrlEnv/sys/mvCpuIfInit.S          |  167 ++
 .../msys_family/ctrlEnv/sys/mvCpuIfRegs.h          |  356 +++++
 arch/arm/mach-msys/msys_family/device/mvDevice.c   |  291 ++++
 arch/arm/mach-msys/msys_family/device/mvDevice.h   |   99 ++
 .../mach-msys/msys_family/device/mvDeviceRegs.h    |  268 ++++
 26 files changed, 9566 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
 create mode 100644 arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
 create mode 100644 arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-msys/msys_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-msys/msys_family/cpu/mvCpu.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.c
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAsm.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.c
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbusRegs.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.h
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100644 arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
 create mode 100644 arch/arm/mach-msys/msys_family/device/mvDevice.c
 create mode 100644 arch/arm/mach-msys/msys_family/device/mvDevice.h
 create mode 100644 arch/arm/mach-msys/msys_family/device/mvDeviceRegs.h

diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
new file mode 100644
index 0000000..d497076
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,1604 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPex.h"
+#include "device/mvDevice.h"
+#include "neta/gbe/mvEthRegs.h"
+#include "gpp/mvGppRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#define DB1(x)	x
+#else
+#define DB(x)
+#define DB1(x)
+#endif
+
+extern MV_BOARD_INFO *boardInfoTbl[];
+#define BOARD_INFO(boardId)	boardInfoTbl[boardId - BOARD_ID_BASE]
+
+/* Locals */
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+
+/*******************************************************************************
+* mvBoardEnvInit - Init board
+*
+* DESCRIPTION:
+*		In this function the board environment take care of device bank
+*		initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_U32 nandDev;
+	MV_U32 norDev;
+	MV_U32 I2C_conf;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardEnvInit:Board unknown.\n");
+		return;
+	}
+
+	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+	if (nandDev != 0xFFFFFFFF) {
+		/* Set NAND interface access parameters */
+		nandDev = BOOT_CS;
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), BOARD_INFO(boardId)->nandFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), BOARD_INFO(boardId)->nandFlashWriteParams);
+		MV_REG_WRITE(DEV_NAND_CTRL_REG, BOARD_INFO(boardId)->nandFlashControl);
+	}
+
+	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+	if (norDev != 0xFFFFFFFF) {
+		/* Set NOR interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), BOARD_INFO(boardId)->norFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), BOARD_INFO(boardId)->norFlashWriteParams);
+		MV_REG_WRITE(DEV_BUS_SYNC_CTRL, 0x11);
+	}
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), BOARD_INFO(boardId)->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), BOARD_INFO(boardId)->gppOutValMid);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValMid);
+
+	/* Set GPP Out Enable */
+	mvGppTypeSet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValMid);
+
+	/* set acess to DFX */
+	I2C_conf = MV_REG_READ(I2C_CONFIC_DEBUG_REG);
+	I2C_conf &= ICDR_UINIT_ID_MASK;
+	I2C_conf |= 8; /* acess to DFX */
+	MV_REG_WRITE(I2C_CONFIC_DEBUG_REG,I2C_conf);
+	/* open windows to DFX */
+	MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(1), 0x000f0081);
+	MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(1), DFX_REGS_BASE);
+}
+/*******************************************************************************
+* mvBoardModelGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns 16bit describing board model.
+*       Board model is constructed of one byte major and minor numbers in the
+*       following manner:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardModelGet(MV_VOID)
+{
+	MV_U8 modelId;
+	if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 0, 0, &modelId)) {
+		mvOsWarning();
+		return INVALID_BAORD_ID;
+	}
+        return (MV_U16)modelId;
+}
+/*******************************************************************************
+* mbBoardRevlGet - Get Board revision
+*
+* DESCRIPTION:
+*       This function returns a 32bit describing the board revision.
+*       Board revision is constructed of 4bytes. 2bytes describes major number
+*       and the other 2bytes describes minor munber.
+*       For example for board revision 3.4 the function will return
+*       0x00030004.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardRevGet(MV_VOID)
+{
+	return (mvBoardIdGet() & 0xFFFF);
+}
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsSPrintf(pNameBuff, "Board unknown.\n");
+		return MV_ERROR;
+	}
+	mvOsSPrintf(pNameBuff, "%s", BOARD_INFO(boardId)->boardName);
+	return MV_OK;
+}
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+	return MV_TRUE;
+}
+/*******************************************************************************
+* mvBoardIsPortInGmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in GMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
+*
+* DESCRIPTION:
+*       This routine returns the Switch CPU port.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the Switch CPU port, -1 if the switch is not connected.
+*
+*******************************************************************************/
+MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardSwitchCpuPortGet: Board unknown.\n");
+		return -1;
+	}
+	if ((BOARD_INFO(boardId)->switchInfoNum == 0) || (switchIdx >= BOARD_INFO(boardId)->switchInfoNum))
+		return -1;
+
+	return BOARD_INFO(boardId)->pSwitchInfo[switchIdx].cpuPort;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+/*******************************************************************************
+* mvBoardQuadPhyAddr0Get - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardQuadPhyAddr0Get: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr0;
+}
+
+/*******************************************************************************
+* mvBoardPhyLinkCryptPortAddrGet - Get the phy gbe address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyLinkCryptPortAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].LinkCryptPortAddr;
+}
+
+MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum)
+{
+	return !mvBoardIsPortInGmii(ethPortNum);
+}
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMacSpeedGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardTclkGet - Get the board Tclk (Controller clock)
+*
+* DESCRIPTION:
+*       This routine extract the controller core clock.
+*       This function uses the controller counters to make identification.
+*		Note: In order to avoid interference, make sure task context switch
+*		and interrupts will not occure during this function operation
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 freq_tbl[] = {
+	360000000, /* 0 */
+	220000000, /* 1 */
+	250000000, /* 2 */
+	400000000, /* 3 */
+	500000000, /* 4 */
+	520000000, /* 5 */
+	450000000, /* 6 */
+	0xFFFFFFFF /* 7  reserved */
+};
+
+MV_U32 mvBoardTclkGet(MV_VOID)
+{
+	MV_U32  freq;
+
+	freq = MSAR_CORE_CLK(0, MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
+
+	return freq_tbl[freq];
+}
+
+/*******************************************************************************
+* mvBoardSysClkGet - Get the board SysClk (CPU bus clock , i.e. DDR clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU bus clock.
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardSysClkGet(MV_VOID)
+{
+	MV_U32 idx;
+
+	idx = MSAR_CORE_CLK(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)),
+			    MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
+
+	return freq_tbl[idx];
+}
+
+/*******************************************************************************
+* mvBoarGpioPinGet - mvBoarGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		gppClass - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
+{
+	MV_U32 boardId, i;
+	MV_U32 indexFound = 0;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardRTCGpioPinGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == gppClass) {
+			if (indexFound == index)
+				return (MV_U32) BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+		}
+	}
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardReset - mvBoardReset
+*
+* DESCRIPTION:
+*			Reset the board
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvBoardReset(MV_VOID)
+{
+	MV_32 resetPin;
+
+	/* Get gpp reset pin if define */
+	resetPin = mvBoardResetGpioPinGet();
+	if (resetPin != MV_ERROR)
+		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
+	else
+	{
+		/* No gpp reset pin was found, try to reset using system reset out */
+		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
+		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
+	}
+}
+
+/*******************************************************************************
+* mvBoardResetGpioPinGet - mvBoardResetGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardResetGpioPinGet(MV_VOID)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_RESET, 0);
+}
+
+/*******************************************************************************
+* mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
+*
+* DESCRIPTION:
+*		This function returns a 32-bit mask of GPP pins that connected to
+*		interrupt generating sources on board.
+*		For example if UART channel A is hardwired to GPP pin 8 and
+*		UART channel B is hardwired to GPP pin 4 the fuinction will return
+*		the value 0x000000110
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		See description. The function return -1 if board is not identified.
+*
+*******************************************************************************/
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGpioIntMaskGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	switch (gppGrp) {
+	case (0):
+		return BOARD_INFO(boardId)->intsGppMaskLow;
+		break;
+	case (1):
+		return BOARD_INFO(boardId)->intsGppMaskMid;
+		break;
+	case (2):
+		return BOARD_INFO(boardId)->intsGppMaskHigh;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*	MPP settings are derived from board design.
+*	MPP group consist of 8 MPPs. An MPP group represents MPP
+*	control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	MV_U32 boardId;
+	MV_U32 mppMod;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	mppMod = BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod;
+	if (mppMod >= BOARD_INFO(boardId)->numBoardMppConfigValue)
+		mppMod = 0; /* default */
+
+	return BOARD_INFO(boardId)->pBoardMppConfigValue[mppMod].mppGroup[mppGroupNum];
+}
+
+/*******************************************************************************
+* mvBoardGppConfigGet
+*
+* DESCRIPTION:
+*	Get board configuration according to the input configuration GPP's.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The value of the board configuration GPP's.
+*
+*******************************************************************************/
+MV_U32 mvBoardGppConfigGet(void)
+{
+	MV_U32 boardId, i;
+	MV_U32 result = 0;
+	MV_U32 gpp;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGppConfigGet: Board unknown.\n");
+		return 0;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
+			gpp = BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			result <<= 1;
+			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
+		}
+	}
+	return result;
+
+}
+
+/*******************************************************************************
+* mvBoardModuleTypePrint
+*
+* DESCRIPTION:
+*	Print on-board detected modules.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
+{
+	return;
+}
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
+{
+	return;
+}
+
+/*******************************************************************************
+* mvBoardIsGbEPortConnected
+*
+* DESCRIPTION:
+*	Checks if a given GbE port is actually connected to the GE-PHY, internal Switch or any RGMII module.
+*
+* INPUT:
+*	port - GbE port number (0 or 1).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_TRUE if port is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum)
+{
+	switch (ethPortNum) {
+	case 0:
+	case 1:
+		break;
+	case 2:
+	case 3:
+	default:
+		return MV_FALSE;
+	}
+
+	return MV_TRUE;
+}
+
+/* Board devices API managments */
+
+/*******************************************************************************
+* mvBoardGetDeviceNumber - Get number of device of some type on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		number of those devices else the function returns 0
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devNum;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGetDeviceNumber:Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devNum].devClass == devClass)
+			foundIndex++;
+	}
+
+	return foundIndex;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBaseAddr - Get base address of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*	Base address else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinBaseLowGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBusWidth - Get Bus width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		Bus width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->busWidth;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWidth - Get dev width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		dev width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->devWidth;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWinSize - Get the window size of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		window size else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinSizeGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* boardGetDevEntry - returns the entry pointer of a device on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devIndex;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("boardGetDevEntry: Board unknown.\n");
+		return NULL;
+	}
+
+	for (devIndex = START_DEV_CS; devIndex < BOARD_INFO(boardId)->numBoardDeviceIf; devIndex++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devIndex].devClass == devClass) {
+			if (foundIndex == devNum)
+				return &(BOARD_INFO(boardId)->pDevCsInfo[devIndex]);
+			foundIndex++;
+		}
+	}
+
+	/* device not found */
+	return NULL;
+}
+
+/*******************************************************************************
+* boardGetDevCSNum
+*
+* DESCRIPTION:
+*	Return the device's chip-select number.
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->deviceCS;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrTypeGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address type for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address type.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+	}
+	return (MV_ERROR);
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+	}
+	return (0xFF);
+}
+
+/*******************************************************************************
+* mvBoardNandWidthGet -
+*
+* DESCRIPTION: Get the width of the first NAND device in bytes
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: 1, 2, 4 or MV_ERROR
+*
+*
+*******************************************************************************/
+MV_32 mvBoardNandWidthGet(void)
+{
+	MV_U32 devNum;
+	MV_U32 devWidth;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		devWidth = mvBoardGetDeviceWidth(devNum, BOARD_DEV_NAND_FLASH);
+		if (devWidth != MV_ERROR)
+			return (devWidth / 8);
+	}
+
+	/* NAND wasn't found */
+	return MV_ERROR;
+}
+
+MV_U32 gBoardId = -1;
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       This function sets the board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       void
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_VOID)
+{
+	mvOsPrintf("mvBoardIdSet: Board ID ir read only must be defined in PLD!\n");
+}
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	MV_U8 boadId;
+	if (gBoardId == -1) {
+		if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 1, 0, &boadId)) {
+			mvOsWarning();
+			return INVALID_BAORD_ID;
+		}
+		switch (boadId) {
+		case 0: gBoardId = RD_98DX4051_ID; break;
+		case 1: gBoardId = DB_98DX4251_BP_ID; break;
+		default:
+			mvOsWarning();
+			return INVALID_BAORD_ID;
+		}
+	}
+	return gBoardId;
+}
+/*******************************************************************************
+* mvBoardTwsiRead -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       TWSI class id
+*	device num - one of three devices
+*	reg num - 0 or 1
+*	pointer for output data
+* OUTPUT:
+*		reg value.
+*
+* RETURN:
+*		status OK or Error
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiRead(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(class1, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(class1, devNum);
+
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.validOffset = MV_TRUE;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, pData, 1)) {
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read TWSI succeded,(0x%x)\n", *pData));
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvBoardTwsiWrite -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       TWSI class id
+*	device num - one of three devices
+*	reg num - 0 or 1
+*	input reg data
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		status OK or Error
+*******************************************************************************/
+MV_STATUS mvBoardTwsiWrite(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(class1, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(class1, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB1(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	SatR bios index - 0,1,2
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRGet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
+{
+	MV_BOARD_TWSI_CLASS twsiClass = BOARD_DEV_TWSI_SATR + satrIndex;
+
+	return mvBoardTwsiRead(twsiClass, devNum, regNum, pData);
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	return mvBoardTwsiWrite(BOARD_DEV_TWSI_SATR + satrIndex, devNum, regNum, regVal);
+}
+
+/*******************************************************************************
+* SatR Configuration functions
+*******************************************************************************/
+//MV_U8 mvBoardFabFreqGet(MV_VOID)
+MV_U8 mvBoardCoreFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+	MV_STATUS rc1;
+
+	rc1 = mvBoardTwsiSatRGet(1, 0, 0, &sar0);
+	if (MV_ERROR == rc1)
+		return MV_ERROR;
+
+	return ( sar0 & 0x7);
+}
+
+/*******************************************************************************/
+//MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal)
+MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+	MV_STATUS rc1;
+
+	rc1 = mvBoardTwsiSatRGet(1, 0, 0,&sar0);
+	if (MV_ERROR == rc1)
+		return MV_ERROR;
+
+	sar0 &= ~(0x7);
+	sar0 |= (freqVal & 0x7);
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write core Freq S@R fail\n"));
+		return MV_ERROR;
+	}
+
+
+	DB(mvOsPrintf("Board: Write core FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuFreqGet(MV_VOID)
+{
+	MV_U8 sar1, sar2;
+	MV_STATUS rc1;
+	MV_STATUS rc2;
+
+	rc1 = mvBoardTwsiSatRGet(1, 0, 0, &sar1);
+	rc2 = mvBoardTwsiSatRGet(2, 0, 0, &sar2);
+	if ((MV_ERROR == rc1) || (MV_ERROR == rc2))
+		return MV_ERROR;
+
+	return ((((sar2 & 0x1)) << 3) | ((sar1 & 0x18) >> 3));
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar1, sar2;
+	MV_STATUS rc1;
+	MV_STATUS rc2;
+
+	rc1 = mvBoardTwsiSatRGet(1, 0, 0, &sar1);
+	rc2 = mvBoardTwsiSatRGet(2, 0, 0, &sar2);
+	if ((MV_ERROR == rc1) || (MV_ERROR == rc2))
+		return MV_ERROR;
+
+	sar1 &= ~0x18;
+	sar2 &= ~0x1;
+	sar1 |= ((freqVal & 0x03) << 3);
+	sar2 |= ((freqVal & 0x04) >> 2);
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, 0, sar1)) {
+		DB1(mvOsPrintf("Board: Write CpuFreq(1) S@R fail\n"));
+		return MV_ERROR;
+	}
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, 0, sar2)) {
+		DB1(mvOsPrintf("Board: Write CpuFreq(2) S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write CpuFreq S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardTmFreqGet(MV_VOID)
+{
+	MV_U8 sar2;
+	MV_STATUS rc2;
+
+	rc2 = mvBoardTwsiSatRGet(2, 0, 0, &sar2);
+	if (MV_ERROR == rc2)
+		return MV_ERROR;
+
+	return ((sar2 & 0x0E) >> 1);
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardTmFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar2;
+	MV_STATUS rc2;
+
+	rc2 = mvBoardTwsiSatRGet(2, 0, 0, &sar2);
+	if (MV_ERROR == rc2)
+		return MV_ERROR;
+
+	sar2 &= ~0xE;
+	sar2 |= ((freqVal & 0x07) << 1);
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, 0, sar2)) {
+		DB1(mvOsPrintf("Board: Write TM-Freq S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write TM-Freq S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardBootDevGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_STATUS rc;
+
+	rc = mvBoardTwsiSatRGet(3, 0, 0, &sar);
+	if (MV_ERROR == rc)
+		return MV_ERROR;
+
+	return (sar & 0x7);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardBootDevSet(MV_U8 val)
+{
+	MV_U8 sar;
+	MV_STATUS rc;
+
+	rc = mvBoardTwsiSatRGet(3, 0, 0, &sar);
+	if (MV_ERROR == rc)
+		return MV_ERROR;
+
+	sar &= ~(0x7);
+	sar |= (val & 0x7);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write BootDev S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDev S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************
+* End of SatR Configuration functions
+*******************************************************************************/
+
+/*******************************************************************************
+* mvBoardMppModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through MPP lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardMppModulesScan(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardOtherModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through SERDES/LVDS/... lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardOtherModulesScan(void)
+{
+	return MV_OK;
+}
+/*******************************************************************************
+* mvBoardIsSwitchModuleConnected
+*
+* DESCRIPTION:
+*	Check if switch module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSwitchModuleConnected(void)
+{
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardPexInfoGet - Get board PEX Info
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*******************************************************************************/
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	return &BOARD_INFO(boardId)->boardPexInfo;
+}
+
+/*******************************************************************************
+* mvBoardDebugLeg - Set the board debug Leds
+*
+* DESCRIPTION: turn on/off status leds.
+* 	       Note: assume MPP leds are part of group 0 only.
+*
+* INPUT:
+*       hexNum - Number to be displayed in hex by Leds.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardDebugLed(MV_U32 hexNum)
+{
+	MV_U32 val[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 mask[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 digitMask;
+	MV_U32 i, pinNum, gppGroup;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (BOARD_INFO(boardId)->pLedGppPin == NULL)
+		return;
+
+	hexNum &= (1 << BOARD_INFO(boardId)->activeLedsNumber) - 1;
+
+	for (i = 0, digitMask = 1; i < BOARD_INFO(boardId)->activeLedsNumber; i++, digitMask <<= 1) {
+			pinNum = BOARD_INFO(boardId)->pLedGppPin[i];
+			gppGroup = pinNum / 32;
+			if (hexNum & digitMask)
+				val[gppGroup]  |= (1 << (pinNum - gppGroup * 32));
+			mask[gppGroup] |= (1 << (pinNum - gppGroup * 32));
+	}
+
+	for (gppGroup = 0; gppGroup < MV_GPP_MAX_GROUP; gppGroup++) {
+		/* If at least one bit is set in the mask, update the whole GPP group */
+		if (mask[gppGroup])
+			mvGppValueSet(gppGroup, mask[gppGroup], BOARD_INFO(boardId)->ledsPolarity == 0 ?
+					val[gppGroup] : ~val[gppGroup]);
+	}
+
+}
+/*******************************************************************************
+* mvBoardCpuCoresNumGet - Get number of CPU
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit number of CPU - 0 for UP
+*
+*******************************************************************************/
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
+{
+	return 0;
+}
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
new file mode 100644
index 0000000..8063cf7
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,335 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+/* DUART stuff for Tclk detection only */
+#define DUART_BAUD_RATE			115200
+#define MAX_CLOCK_MARGINE		5000000	/* Maximum detected clock margine */
+
+#define MV_BOARD_MAX_MPP		9	/* number of MPP conf registers */
+#define MV_BOARD_NAME_LEN  		0x20
+
+typedef enum _devBoardMppTypeClass {
+	MV_BOARD_AUTO = 0,
+	MV_BOARD_MII_GMII,
+	MV_BOARD_OTHER
+} MV_BOARD_MPP_TYPE_CLASS;
+
+typedef struct _boardModuleTypeInfo {
+	MV_U32 boardMppMod;
+} MV_BOARD_MODULE_TYPE_INFO;
+
+typedef enum _devBoardClass {
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER
+} MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass {
+	BOARD_DEV_TWSI_PLD,
+	BOARD_DEV_TWSI_ZARLINK,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_DEV_TWSI_INIT_EPROM,
+	BOARD_DEV_TWSI_PCA9555_IO_EXPANDER,
+	BOARD_DEV_TWSI_PCA9548_IO_MUX
+} MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass {
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+	BOARD_GPP_SDIO_POWER,
+	BOARD_GPP_SDIO_DETECT,
+	BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_CONF,
+	BOARD_GPP_OTHER
+} MV_BOARD_GPP_CLASS;
+
+typedef struct _devCsInfo {
+	MV_U8 deviceCS;
+	MV_U32 params;
+	MV_U32 devClass;	/* MV_BOARD_DEV_CLASS */
+	MV_U8 devWidth;
+	MV_U8 busWidth;
+} MV_DEV_CS_INFO;
+
+typedef struct _boardSwitchInfo {
+	MV_32 switchIrq;
+	MV_32 switchPort[BOARD_ETH_SWITCH_PORT_NUM];
+	MV_32 cpuPort;
+	MV_32 connectedPort[MV_ETH_MAX_PORTS];
+	MV_32 smiScanMode;
+	MV_32 quadPhyAddr;
+	MV_U32 forceLinkMask; /* Bitmask of switch ports to have force link (1Gbps) */
+} MV_BOARD_SWITCH_INFO;
+
+typedef struct _boardGppInfo {
+	MV_BOARD_GPP_CLASS devClass;
+	MV_U8 gppPinNum;
+} MV_BOARD_GPP_INFO;
+
+typedef struct _boardTwsiInfo {
+	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 twsiDevAddr;
+	MV_U8 twsiDevAddrType;
+} MV_BOARD_TWSI_INFO;
+
+typedef enum _boardMacSpeed {
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO
+} MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo {
+	MV_BOARD_MAC_SPEED boardMacSpeed;
+	MV_U8	boardEthSmiAddr;
+	MV_U16	LinkCryptPortAddr;
+	MV_U8	boardEthSmiAddr0;
+} MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo {
+	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
+} MV_BOARD_MPP_INFO;
+
+typedef struct _boardPexUnitCfg {
+	MV_PEX_UNIT_CFG 	pexCfg;
+	MV_U8			pexLaneStat[4];	/* 1: enabled, 2: disabled */
+} MV_BOARD_PEX_UNIT_CFG;
+
+typedef struct _boardPexInfo {
+	MV_PEXIF_INDX 		pexMapping[MV_PEX_MAX_IF];
+	MV_BOARD_PEX_UNIT_CFG 	pexUnitCfg[MV_PEX_MAX_UNIT];
+	MV_U32			boardPexIfNum;
+} MV_BOARD_PEX_INFO;
+
+typedef struct _boardInfo {
+	char boardName[MV_BOARD_NAME_LEN];
+	MV_U8 numBoardMppTypeValue;
+	MV_BOARD_MODULE_TYPE_INFO *pBoardModTypeValue;
+	MV_U8 numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO *pBoardMppConfigValue;
+	MV_U32 intsGppMaskLow;
+	MV_U32 intsGppMaskMid;
+	MV_U32 intsGppMaskHigh;
+	MV_U8 numBoardDeviceIf;
+	MV_DEV_CS_INFO *pDevCsInfo;
+	MV_U8 numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
+	MV_U8 numBoardMacInfo;
+	MV_BOARD_MAC_INFO *pBoardMacInfo;
+	MV_U8 numBoardGppInfo;
+	MV_BOARD_GPP_INFO *pBoardGppInfo;
+	MV_U8 activeLedsNumber;
+	MV_U8 *pLedGppPin;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+
+	MV_U8	pmuPwrUpPolarity;
+	MV_U32	pmuPwrUpDelay;
+	/* GPP values */
+	MV_U32 gppOutEnValLow;
+	MV_U32 gppOutEnValMid;
+	MV_U32 gppOutEnValHigh;
+	MV_U32 gppOutValLow;
+	MV_U32 gppOutValMid;
+	MV_U32 gppOutValHigh;
+	MV_U32 gppPolarityValLow;
+	MV_U32 gppPolarityValMid;
+	MV_U32 gppPolarityValHigh;
+
+	/* External Switch Configuration */
+	MV_BOARD_SWITCH_INFO *pSwitchInfo;
+	MV_U32 switchInfoNum;
+
+	/* NAND init params */
+	MV_U32 nandFlashReadParams;
+	MV_U32 nandFlashWriteParams;
+	MV_U32 nandFlashControl;
+	MV_BOARD_PEX_INFO	boardPexInfo;	/* filled in runtime */
+	MV_U32 norFlashReadParams;
+	MV_U32 norFlashWriteParams;
+
+} MV_BOARD_INFO;
+
+MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U16 mvBoardModelGet(MV_VOID);
+MV_U16 mvBoardRevGet(MV_VOID);
+MV_STATUS mvBoardNameGet(char *pNameBuff);
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum);
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+
+MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum);
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
+MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
+MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardSysClkGet(MV_VOID);
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+MV_VOID mvBoardReset(MV_VOID);
+MV_32 mvBoardResetGpioPinGet(MV_VOID);
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
+MV_U32 mvBoardGppConfigGet(void);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_32 mvBoardNandWidthGet(void);
+MV_U32 mvBoardIdGet(MV_VOID);
+MV_VOID mvBoardIdSet(MV_VOID);
+MV_U32 mvBoardSledCpuNumGet(MV_VOID);
+
+MV_STATUS mvBoardTwsiRead(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
+MV_STATUS mvBoardTwsiSatRGet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
+MV_U8 mvBoardBootDevGet(MV_VOID);
+MV_STATUS mvBoardBootDevSet(MV_U8 val);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
+MV_STATUS mvBoardConIdSet(MV_U16 conf);
+MV_U16 mvBoardConfIdGet(MV_VOID);
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf);
+MV_U16 mvBoardDramBusWidthGet(MV_VOID);
+MV_U8 mvBoardCoreFreqGet(MV_VOID);
+MV_U8 mvBoardTmFreqGet(MV_VOID);
+MV_STATUS mvBoardTmFreqSet(MV_U8 freqVal);
+MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal);
+
+MV_STATUS mvBoardMppModulesScan(void);
+MV_STATUS mvBoardOtherModulesScan(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_BOOL mvBoardIsSwitchModuleConnected(void);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_BOOL mvBoardIsGMIIModuleConnected(void);
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
+MV_STATUS mvBoardConfIdSet(MV_U16 conf);
+MV_U16 mvBoardPexModeGet(MV_VOID);
+MV_STATUS mvBoardPexModeSet(MV_U16 conf);
+MV_VOID mvBoardDebugLed(MV_U32 hexNum);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
new file mode 100644
index 0000000..3163dcd
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,268 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPexRegs.h"
+
+#define ARRSZ(x)	(sizeof(x)/sizeof(x[0]))
+
+/**********************/
+/* BOBCAT2-DB BOARD */
+/**********************/
+#define DB_98DX4251_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_98DX4251_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_98DX4251_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_98DX4251_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_98DX4251_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_TWSI_INFO	db98DX4251InfoBoardTwsiDev[] = {
+/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_PLD, 0x30, ADDR7_BIT},		/* Access to control PLD reg file */
+	{BOARD_DEV_TWSI_ZARLINK, 0x18, ADDR7_BIT},		/* Access to Zarlink 	*/
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},         /* SatR bios 0		*/
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},         /* SatR bios 1		*/
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},          /* SatR bios 2		*/
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT},          /* SatR bios 3		*/
+	{BOARD_DEV_TWSI_INIT_EPROM, 0x50, ADDR7_BIT},          /* Serial Ini EPROM	*/
+	{BOARD_DEV_TWSI_PCA9555_IO_EXPANDER, 0x20, ADDR7_BIT},          /* Qsgmii/sfp mux control PCA9555 IO expander */
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x70, ADDR7_BIT},          /* PCA9548 I2C mux 0	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x71, ADDR7_BIT},          /* PCA9548 I2C mux 1	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x75, ADDR7_BIT}          /* PCA9548 I2C mux 2	*/
+};
+
+MV_BOARD_MAC_INFO db98DX4251InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0 	  , 0x0 },
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0	  , 0x1 },
+};
+
+MV_BOARD_MODULE_TYPE_INFO db98DX4251InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+	}
+};
+
+MV_BOARD_GPP_INFO db98DX4251InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+	/*{BOARD_GPP_RESET,       47},*/
+};
+
+MV_DEV_CS_INFO db98DX4251InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db98DX4251InfoBoardMppConfigValue[] = {
+	{ {
+	DB_98DX4251_MPP0_7,
+	DB_98DX4251_MPP8_15,
+	DB_98DX4251_MPP16_23,
+	DB_98DX4251_MPP24_31,
+	DB_98DX4251_MPP32_39,
+	} },
+};
+
+MV_BOARD_INFO db98DX4251Info = {
+	.boardName			= "DB-98DX4251-BP",
+	.numBoardMppTypeValue		= ARRSZ(db98DX4251InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db98DX4251InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db98DX4251InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db98DX4251InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db98DX4251InfoBoardDeCsInfo),
+	.pDevCsInfo			= db98DX4251InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db98DX4251InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db98DX4251InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db98DX4251InfoBoardMacInfo),
+	.pBoardMacInfo			= db98DX4251InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db98DX4251InfoBoardGppInfo),
+	.pBoardGppInfo			= db98DX4251InfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_98DX4251_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_98DX4251_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= 0,
+	.gppOutValLow			= DB_98DX4251_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_98DX4251_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= 0,
+	.gppPolarityValLow		= DB_98DX4251_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_98DX4251_GPP_POL_MID,
+	.gppPolarityValHigh		= 0,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_98DX4251_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_98DX4251_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_98DX4251_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= DB_98DX4251_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_98DX4251_BOARD_NOR_WRITE_PARAMS
+};
+
+/*****************************/
+/* BobCat2 RD 98DX4051 BOARD */
+/*****************************/
+#define RD_98DX4051_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_98DX4051_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_98DX4051_BOARD_NAND_CONTROL			0x01c00543
+
+MV_BOARD_MAC_INFO rd98DX4051InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_1000M, 0x0, 0x0, 0x0},
+	{BOARD_MAC_SPEED_1000M, 0x1, 0x0, 0x1},
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd98DX4051InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+	}
+};
+
+MV_DEV_CS_INFO rd98DX4051InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd98DX4051InfoBoardMppConfigValue[] = {
+	{ {
+		RD_98DX4051_MPP0_7,
+		RD_98DX4051_MPP8_15,
+		RD_98DX4051_MPP16_23,
+		RD_98DX4051_MPP24_31,
+		RD_98DX4051_MPP32_39,
+	} }
+};
+MV_U8	rd98DX4051InfoBoardDebugLedIf[] = {17, 18, 19};
+
+MV_BOARD_INFO rd98DX4051Info = {
+ .boardName				= "RD-98DX4051-SERVER",
+ .numBoardMppTypeValue			= ARRSZ(rd98DX4051InfoBoardModTypeInfo),
+ .pBoardModTypeValue			= rd98DX4051InfoBoardModTypeInfo,
+ .numBoardMppConfigValue		= ARRSZ(rd98DX4051InfoBoardMppConfigValue),
+ .pBoardMppConfigValue			= rd98DX4051InfoBoardMppConfigValue,
+ .intsGppMaskLow			= 0,
+ .intsGppMaskMid			= 0,
+ .intsGppMaskHigh			= 0,
+ .numBoardDeviceIf			= ARRSZ(rd98DX4051InfoBoardDeCsInfo),
+ .pDevCsInfo				= rd98DX4051InfoBoardDeCsInfo,
+ .numBoardTwsiDev			= 0,
+ .pBoardTwsiDev				= NULL,
+ .numBoardMacInfo			= ARRSZ(rd98DX4051InfoBoardMacInfo),
+ .pBoardMacInfo				= rd98DX4051InfoBoardMacInfo,
+ .numBoardGppInfo			= 0,
+ .pBoardGppInfo				= NULL,
+	.activeLedsNumber		= ARRSZ(rd98DX4051InfoBoardDebugLedIf),
+ .pLedGppPin				= rd98DX4051InfoBoardDebugLedIf,
+ .ledsPolarity				= 0,
+
+ /* GPP values */
+ .gppOutEnValLow			= RD_98DX4051_GPP_OUT_ENA_LOW,
+ .gppOutEnValMid			= RD_98DX4051_GPP_OUT_ENA_MID,
+ .gppOutEnValHigh			= 0,
+ .gppOutValLow				= RD_98DX4051_GPP_OUT_VAL_LOW,
+ .gppOutValMid				= RD_98DX4051_GPP_OUT_VAL_MID,
+ .gppOutValHigh				= 0,
+ .gppPolarityValLow			= RD_98DX4051_GPP_POL_LOW,
+ .gppPolarityValMid			= RD_98DX4051_GPP_POL_MID,
+ .gppPolarityValHigh			= 0,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+
+ /* NAND init params */
+ .nandFlashReadParams			= RD_98DX4051_BOARD_NAND_READ_PARAMS,
+ .nandFlashWriteParams			= RD_98DX4051_BOARD_NAND_WRITE_PARAMS,
+ .nandFlashControl			= RD_98DX4051_BOARD_NAND_CONTROL
+};
+
+
+/*********************************************************************************/
+
+MV_BOARD_INFO *boardInfoTbl[] = {
+	&db98DX4251Info,
+	&rd98DX4051Info
+};
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..aa7040f
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,200 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+
+/* Board specific configuration */
+/* ============================ */
+
+/* boards ID numbers */
+#define BOARD_ID_BASE				0x0
+
+/* New board ID numbers */
+#define RD_98DX4051_ID				(BOARD_ID_BASE)
+#define DB_98DX4251_BP_ID			(RD_98DX4051_ID + 1)
+#define MV_MAX_BOARD_ID				(DB_98DX4251_BP_ID + 1)
+#define INVALID_BAORD_ID			0xFFFF
+
+/******************/
+/* DB-98DX4251-BP */
+/******************/
+#define DB_98DX4251_MPP0_7			0x22242222
+#define DB_98DX4251_MPP8_15			0x11122222
+#define DB_98DX4251_MPP16_23			0x44444044
+#define DB_98DX4251_MPP24_31			0x14444444
+#define DB_98DX4251_MPP32_39			0x00000001
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+0       SPI_MOSI 		(out)
+1       SPI_MISO 		(in)
+2       SPI_SCK 		(out)
+3       SPI_CS0n 		(out)
+4       DEV_CSn[0] 		(out) NF CS (Boot)
+5       SD_CMD 			(in/out)
+6       SD_CLK 			(out)
+7       SD_D[0] 		(in/out)
+8       SD_D[1] 		(in/out)
+9       SD_D[2] 		(in/out)
+10      SD_D[3] 		(in/out)
+11      UART1_RXD 		(in)
+12      UART1_TXD 		(out)
+13      INTERRUPT_OUTn		(out)
+14      I2C_SCL 		(in/out)
+15      I2C_SDA 		(in/out)
+
+16      DEV_Oen_NF_Ren 		(out)
+17      DEV_CLK_OUT 		(out) Test point
+18      GPIO[18] 		(in/out) INT_in / SD_WP / VC2_GPP
+19      NF_RBn 			(in)
+20      DEV_WEn[0]		(out)
+21      DEV_AD[0] 		(in/out)
+22      DEV_AD[1] 		(in/out)
+23      DEV_AD[2] 		(in/out)
+24      DEV_AD[3] 		(in/out)
+25      DEV_AD[4] 		(in/out)
+26      DEV_AD[5] 		(in/out)
+27      DEV_AD[6] 		(in/out)
+28      DEV_AD[7] 		(in/out)
+29      NF_CLE_DEV_A[0] 	(out)
+30      NF_ALE_DEV_A[1] 	(out)
+31      SLV_SMI_MDC 		(in)
+32      SLV_SMI_MDIO 		(in/out)
+
+
+
+*/
+#define DB_98DX4251_GPP_OUT_ENA_LOW		(~(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 | BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30 ))
+#define DB_98DX4251_GPP_OUT_ENA_MID		(~(0))
+
+#define DB_98DX4251_GPP_OUT_VAL_LOW		(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 | BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30 )
+#define DB_98DX4251_GPP_OUT_VAL_MID		0x0
+
+#define DB_98DX4251_GPP_POL_LOW			0x0
+#define DB_98DX4251_GPP_POL_MID			0x0
+
+/*******************/
+/* RD-98DX4051 */
+/*******************/
+#define RD_98DX4051_MPP0_7			0x22242222
+#define RD_98DX4051_MPP8_15			0x11022222
+#define RD_98DX4051_MPP16_23			0x44440004
+#define RD_98DX4051_MPP24_31			0x34444444
+#define RD_98DX4051_MPP32_39			0x00000003
+
+/* GPPs
+MPP#	NAME	 	IN/OUT
+----------------------------------------------
+0	SPI_MOSI 	(out)
+1	SPI_MISO 	(in)
+2	SPI_SCK  	(out)
+3	SPI_CS0n 	(out)
+4	DEV_CSn[0] 	(out)
+5	SD_CMD 		(in/out)
+6	SD_CLK 		(out)
+7	SD_D[0] 	(in/out)
+8	SD_D[1] 	(in/out)
+9	SD_D[2] 	(in/out)
+10	SD_D[3] 	(in/out)
+11	UART1_RXD 	(in)
+12	UART1_TXD 	(out)
+13	GPIO[13]	(in/out)
+14	I2C_SCL 	(in/out)
+15	I2C_SDA 	(in/out)
+
+16	DEV_Oen_NF_Ren	(out)
+17	GPIO[17] 	(in/out)
+18	GPIO[18] 	(in/out)
+19	GPIO[19] 	(in/out)
+20	DEV_WEn[0]	(out)
+21	DEV_AD[0] 	(in/out)
+22      DEV_AD[1] 	(in/out)
+23      DEV_AD[2] 	(in/out)
+24      DEV_AD[3] 	(in/out)
+25      DEV_AD[4] 	(in/out)
+26      DEV_AD[5] 	(in/out)
+27      DEV_AD[6] 	(in/out)
+28      DEV_AD[7] 	(in/out)
+29      NF_CLE_DEV_A[0] (out)
+30      NF_ALE_DEV_A[1] (out)
+31      MST_SMI_MDC 	(out)
+32	MST_SMI_MDIO 	(in/out)
+*/
+
+#define RD_98DX4051_GPP_OUT_ENA_LOW		(~(BIT1 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 | BIT16 | BIT20 | BIT29 | BIT30 | BIT31))
+#define RD_98DX4051_GPP_OUT_ENA_MID		(~(0))
+
+#define RD_98DX4051_GPP_OUT_VAL_LOW		(BIT1 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 | BIT16 | BIT20 | BIT29 | BIT30 | BIT31)
+#define RD_98DX4051_GPP_OUT_VAL_MID		(0)
+
+#define RD_98DX4051_GPP_POL_LOW			0x0
+#define RD_98DX4051_GPP_POL_MID			0x0
+
+#endif /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.c b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
new file mode 100644
index 0000000..c39d8e6
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
@@ -0,0 +1,308 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals */
+/*******************************************************************************
+* mvCpuPclkGet - Get the CPU pClk (pipe clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU core clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz;
+	MV_U32 coreClockTbl[8] = MV_CORE_CLK_TBL;
+	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
+
+	idx = MSAR_CORE_CLK(0, sar2);
+	freqMhz = coreClockTbl[idx] * 1000000;
+	return freqMhz;
+}
+/*******************************************************************************
+* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU L2 clock.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuL2ClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz;
+	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
+	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
+
+	idx = MSAR_CPU_DDR_CLK(0, sar2);
+	freqMhz = clockRatioTbl[idx].cpuFreq * 1000000;
+	return freqMhz;
+}
+
+/*******************************************************************************
+* mvCpuNameGet - Get CPU name
+*
+* DESCRIPTION:
+*       This function returns a string describing the CPU model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*       None.
+*******************************************************************************/
+MV_VOID mvCpuNameGet(char *pNameBuff)
+{
+	MV_U32 cpuModel;
+	MV_U32 archType;
+
+	cpuModel = mvOsCpuPartGet();
+	archType = mvOsCpuThumbEEGet();
+	/* The CPU module is indicated in the Processor Version Register (PVR) */
+	switch (cpuModel & 0xfff) {
+	case CPU_PART_ARM_V6UP:
+	case CPU_PART_ARM_V7UP:
+	case CPU_PART_MRVLPJ4B_UP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_MRVLPJ4B_MP:
+	case CPU_PART_ARM_V6MP:
+			if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v6", mvOsCpuRevGet());
+		break;
+	default:
+		mvOsSPrintf(pNameBuff, "??? (0x%04x) (Rev %d)", cpuModel, mvOsCpuRevGet());
+		break;
+	}			/* switch  */
+
+	return;
+}
+
+#define MV_PROC_STR_SIZE 50
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_ECC_MASK) == CL2ACR_ECC_EN)
+		mvOsSPrintf(buf, "L2 ECC Enabled");
+	else
+		mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2ParityMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PARITY_MASK) == CL2ACR_PARITY_EN)
+		mvOsSPrintf(buf, "L2 Parity Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Parity Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	if (regVal & CL2CR_L2_EN_MASK)
+		mvOsSPrintf(buf, "L2 Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PFU_MASK) == CL2ACR_PFU_DIS)
+		mvOsSPrintf(buf, "L2 Prefetch Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_FORCE_WA_MASK) == CL2ACR_FORCE_NO_WA)
+		mvOsSPrintf(buf, "L2 Write Allocate Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Write Allocate Enabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = 0;
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register */
+	if (regVal & BIT29)
+		mvOsSPrintf(buf, "CPU Streaming Enabled");
+	else
+		mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+	MV_U32 regVal = 0;
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register0 */
+	mvOsPrintf("Extra Features Reg[0] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (regVal));	/* Read Marvell extra features register1 */
+	mvOsPrintf("Extra Features Reg[1] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal));	/* Read Control register */
+	mvOsPrintf("Control Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal));	/* Read Main ID register */
+	mvOsPrintf("Main ID Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal));	/* Read Cache Type register */
+	mvOsPrintf("Cache Type Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	mvOsPrintf("L2 Control Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	mvOsPrintf("L2 Auxilary Control Reg = 0x%x\n", regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+	MV_U32 count = 0;
+
+	MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+	MV_8 L2_En_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+	MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+	MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Parity_str[MV_PROC_STR_SIZE];
+
+	mvCpuIfGetL2Mode(L2_En_str);
+	mvCpuIfGetL2EccMode(L2_ECC_str);
+	mvCpuIfGetL2ParityMode(L2_Parity_str);
+	mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+	mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+	mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+	mvCpuIfPrintCpuRegs();
+
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Parity_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+	return count;
+}
+
+/*******************************************************************************
+* whoAmI - Get the CPU ID
+*
+* DESCRIPTION:
+*       This function returns CPU ID in multiprocessor system
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       none.
+*
+* RETURN:
+*       CPU ID.
+*******************************************************************************/
+unsigned int whoAmI(void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPUID reg\n" : "=r"(value) : : "memory");
+	return (value & 0x7);
+}
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.h b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
new file mode 100644
index 0000000..c4e38d6
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#ifndef MV_ASMLANGUAGE
+#include "mvOs.h"
+#endif
+
+#define MASTER_CPU 0
+/* defines */
+#define CPU_PART_MRVL131                0x131
+#define CPU_PART_ARM926                 0x926
+#define CPU_PART_ARM946                 0x946
+#define CPU_PART_MRVL_A9                0xC09
+#define CPU_PART_MRVL571                0x571
+#define CPU_PART_MRVL521                0x521
+
+#define CPU_PART_ARM_V6UP               0xb76
+#define CPU_PART_ARM_V7UP               0xc08
+#define CPU_PART_ARM_V6MP               0xb02
+
+#define CPU_PART_MRVLPJ4B_UP               0x581
+#define CPU_PART_MRVLPJ4B_MP               0x584
+
+#define MV_CPU_ARM_CLK_ELM_SIZE	    12
+#define MV_CPU_ARM_CLK_RATIO_OFF    8
+#define MV_CPU_ARM_CLK_DDR_OFF	    4
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClkRatio {
+	MV_U32	vco2cpu;	/* VCO:PCLK0(CPU) clock ratio */
+	MV_U32	vco2l2c;	/* VCO:NB(L2 cache) clock ratio */
+	MV_U32	vco2hcl;	/* VCO:HCLK(DDR controller) clock ratio */
+	MV_U32	vco2ddr;	/* VCO:DDR(DDR memory) clock ratio */
+
+} MV_CPU_ARM_CLK_RATIO;
+
+MV_U32  mvCpuPclkGet(MV_VOID);
+MV_VOID mvCpuNameGet(char *pNameBuff);
+MV_U32  mvCpuL2ClkGet(MV_VOID);
+MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+MV_U32  whoAmI(MV_VOID);
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.c
new file mode 100644
index 0000000..a34dba4
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -0,0 +1,376 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvCtrlEnvAddrDec.h - Marvell controller address decode library
+*
+* DESCRIPTION:
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "sys/mvCpuIf.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* Default Attributes array */
+MV_TARGET_ATTRIB mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
+
+/*******************************************************************************
+* mvCtrlAttribGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	targetAttrib->attrib = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib;
+	targetAttrib->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib  = targetAttrib->attrib;
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId= targetAttrib->targetId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlGetAttrib -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == targetAttrib->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == targetAttrib->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlTargetByWinInfoGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == unitWinInfo->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == unitWinInfo->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlAddrWinMapBuild
+*
+* DESCRIPTION:
+*	Build the windows address decoding table, to be used for initializing
+*	the unit's address decoding windows.
+*
+* INPUT:
+*	pAddrWinMap: An array to hold the address decoding windows parameters.
+*	len: Number of entries in pAddrWinMap.
+*
+* OUTPUT:
+*	pAddrWinMap: Address window information.
+*
+* RETURN:
+*	MV_BAD_PARAM: input array is smaller than needed to store all window
+*	addresses.
+*	MV_ERROR: Otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i, j;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+	MV_U64 startAddr, endAddr;
+	MV_UNIT_WIN_INFO ioDdrWin[MV_DRAM_MAX_CS];
+	MV_U32 base;
+	MV_U64 size;
+
+	/* Check size of CPU address win table */
+	if (len <= MAX_TARGETS) {
+		mvOsPrintf("mvCtrlAddrWinMapBuild() - Table size too small.\n");
+		return MV_BAD_PARAM;
+	}
+
+	/* Prepare an array of DRAM info */
+	base = 0x0;
+	j = 0;
+	for (i = SDRAM_CS0; i <= SDRAM_CS3; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK) {
+			if (status == MV_NO_SUCH) {
+				ioDdrWin[i].enable = MV_FALSE;
+				continue;
+			} else {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCpuIfTargetWinGet() failed.\n");
+				return MV_ERROR;
+			}
+		}
+
+		/* As all IO address decode windows support only 32-bit
+		** addresses, limit the DRAM base / size to 4GB max.
+		*/
+		startAddr = (MV_U64)((((MV_U64)cpuAddrDecWin.addrWin.baseHigh << 32ll)) +
+				(MV_U64)cpuAddrDecWin.addrWin.baseLow);
+		endAddr = (MV_U64)(startAddr + (MV_U64)cpuAddrDecWin.addrWin.size) - 1;
+		if (endAddr > 0xFFFFFFFFll) {
+			if (startAddr <= 0xFFFFFFFFll)
+				cpuAddrDecWin.addrWin.size = (0x100000000ll -
+						cpuAddrDecWin.addrWin.baseLow);
+			else
+				cpuAddrDecWin.enable = MV_FALSE;
+		}
+
+		if (cpuAddrDecWin.enable == MV_FALSE)
+			continue;
+
+		/* If the endAddr passes minBase, then we need to split
+		** this window to several windows up to minBase.
+		** For example: minBase=0xE0000000, and CS0=2, CS1=2G,
+		** Then we need to split the windwos as follows:
+		** Win0: CS-0, 2GB (Base 0x0)
+		** win1: CS-1, 1GB (Base 0x80000000)
+		** Win2: CS-1, 0.5GB (Base 0xC0000000)
+		*/
+		if (endAddr > MV_DRAM_IO_RESERVE_BASE)
+			/* Need to cut down this CS to IO reserve base
+			** address.
+			*/
+			size = MV_DRAM_IO_RESERVE_BASE -
+				cpuAddrDecWin.addrWin.baseLow;
+		else
+			size = cpuAddrDecWin.addrWin.size;
+
+		if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+			mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+					"mvCtrlAttribGet() failed.\n");
+			return MV_ERROR;
+		}
+		/* Now, spread the last CS into several windows, and make sure
+		** that each of has a power-of-2 size.
+		*/
+		while (size != 0) {
+			ioDdrWin[j].enable = MV_TRUE;
+			ioDdrWin[j].attrib = targetAttrib.attrib;
+			ioDdrWin[j].targetId = targetAttrib.targetId;
+			ioDdrWin[j].addrWin.baseHigh = 0;
+			if (MV_IS_POWER_OF_2(size))
+				ioDdrWin[j].addrWin.size = size;
+			else
+				ioDdrWin[j].addrWin.size = (MV_U64)(1ll << (MV_U64)mvLog2(size));
+			size -= ioDdrWin[j].addrWin.size;
+			ioDdrWin[j].addrWin.baseLow = base;
+			base += ioDdrWin[j].addrWin.size;
+			j++;
+		}
+		/* Support only up to 4 DRAM address decode windows in the
+		** units. */
+		if (j == MV_DRAM_MAX_CS)
+			break;
+	}
+
+	for (; j < MV_DRAM_MAX_CS; j++)
+		ioDdrWin[j].enable = MV_FALSE;
+
+	/* Fill in the pAddrWinMap fields       */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (MV_TARGET_IS_DRAM(i)) {
+			pAddrWinMap[i].addrWin.baseLow = ioDdrWin[i].addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh = ioDdrWin[i].addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size = ioDdrWin[i].addrWin.size;
+			pAddrWinMap[i].enable = ioDdrWin[i].enable;
+			pAddrWinMap[i].attrib = ioDdrWin[i].attrib;
+			pAddrWinMap[i].targetId = ioDdrWin[i].targetId;
+		} else {
+			status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+			if (status != MV_OK) {
+				if (status == MV_NO_SUCH) {
+					pAddrWinMap[i].enable = MV_FALSE;
+					continue;
+				} else {
+					mvOsPrintf("mvCtrlAddrWinMapBuild()"
+					" - mvCpuIfTargetWinGet() failed.\n");
+					return MV_ERROR;
+				}
+			}
+
+			pAddrWinMap[i].addrWin.baseLow =
+				cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh =
+				cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size =
+				cpuAddrDecWin.addrWin.size;
+			pAddrWinMap[i].enable = cpuAddrDecWin.enable;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+						"mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinMap[i].attrib = targetAttrib.attrib;
+			pAddrWinMap[i].targetId = targetAttrib.targetId;
+		}
+	}
+	pAddrWinMap[i].addrWin.baseLow = TBL_TERM;
+	pAddrWinMap[i].addrWin.baseHigh = TBL_TERM;
+	pAddrWinMap[i].addrWin.size = TBL_TERM;
+	pAddrWinMap[i].enable = TBL_TERM;
+	pAddrWinMap[i].attrib = TBL_TERM;
+	pAddrWinMap[i].targetId = TBL_TERM;
+
+	return MV_OK;
+}
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK)
+			continue;
+
+		if ((physAddr >= cpuAddrDecWin.addrWin.baseLow) &&
+		    (physAddr < cpuAddrDecWin.addrWin.baseLow + cpuAddrDecWin.addrWin.size)) {
+			/* Found */
+			pAddrWinInfo->addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinInfo->addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinInfo->addrWin.size = cpuAddrDecWin.addrWin.size;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinInfo->attrib = targetAttrib.attrib;
+			pAddrWinInfo->targetId = targetAttrib.targetId;
+			return MV_OK;
+		}
+	}
+	/* not found */
+	return MV_NOT_FOUND;
+}
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.h
new file mode 100644
index 0000000..dcecd06
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAddrDech
+#define __INCmvCtrlEnvAddrDech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+
+/* defines  */
+/* DUnit attributes */
+#define ATMWCR_WIN_DUNIT_CS0_OFFS		0
+#define ATMWCR_WIN_DUNIT_CS0_MASK		BIT0
+#define ATMWCR_WIN_DUNIT_CS0_REQ		(0 << ATMWCR_WIN_DUNIT_CS0_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS1_OFFS		1
+#define ATMWCR_WIN_DUNIT_CS1_MASK		BIT1
+#define ATMWCR_WIN_DUNIT_CS1_REQ 		(0 << ATMWCR_WIN_DUNIT_CS1_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS2_OFFS		2
+#define ATMWCR_WIN_DUNIT_CS2_MASK		BIT2
+#define ATMWCR_WIN_DUNIT_CS2_REQ 		(0 << ATMWCR_WIN_DUNIT_CS2_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS3_OFFS		3
+#define ATMWCR_WIN_DUNIT_CS3_MASK		BIT3
+#define ATMWCR_WIN_DUNIT_CS3_REQ 		(0 << ATMWCR_WIN_DUNIT_CS3_OFFS)
+
+/* RUnit (Device)  attributes */
+#define ATMWCR_WIN_RUNIT_DEVCS0_OFFS		0
+#define ATMWCR_WIN_RUNIT_DEVCS0_MASK		BIT0
+#define ATMWCR_WIN_RUNIT_DEVCS0_REQ		(0 << ATMWCR_WIN_RUNIT_DEVCS0_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS1_OFFS		1
+#define ATMWCR_WIN_RUNIT_DEVCS1_MASK		BIT1
+#define ATMWCR_WIN_RUNIT_DEVCS1_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS1_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS2_OFFS		2
+#define ATMWCR_WIN_RUNIT_DEVCS2_MASK		BIT2
+#define ATMWCR_WIN_RUNIT_DEVCS2_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS2_OFFS)
+
+#define ATMWCR_WIN_RUNIT_BOOTCS_OFFS		4
+#define ATMWCR_WIN_RUNIT_BOOTCS_MASK		BIT4
+#define ATMWCR_WIN_RUNIT_BOOTCS_REQ 		(0 << ATMWCR_WIN_RUNIT_BOOTCS_OFFS)
+
+/* LMaster (PCI)  attributes */
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS		0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_MASK		BIT0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP		(0 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_BYTE_NO_SWP		(1 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+
+
+#define ATMWCR_WIN_LUNIT_WORD_SWP_OFFS		1
+#define ATMWCR_WIN_LUNIT_WORD_SWP_MASK		BIT1
+#define ATMWCR_WIN_LUNIT_WORD_SWP		(0 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_WORD_NO_SWP		(1 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+
+#define ATMWCR_WIN_LUNIT_NO_SNOOP		BIT2
+
+#define ATMWCR_WIN_LUNIT_TYPE_OFFS		3
+#define ATMWCR_WIN_LUNIT_TYPE_MASK		BIT3
+#define ATMWCR_WIN_LUNIT_TYPE_IO		(0 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+#define ATMWCR_WIN_LUNIT_TYPE_MEM		(1 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+
+#define ATMWCR_WIN_LUNIT_FORCE64_OFFS		4
+#define ATMWCR_WIN_LUNIT_FORCE64_MASK		BIT4
+#define ATMWCR_WIN_LUNIT_FORCE64		(0 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+#define ATMWCR_WIN_LUNIT_ORDERING_OFFS		6
+#define ATMWCR_WIN_LUNIT_ORDERING_MASK		BIT6
+#define ATMWCR_WIN_LUNIT_ORDERING		(1 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+/* PEX Attributes */
+#define ATMWCR_WIN_PEX_TYPE_OFFS		3
+#define ATMWCR_WIN_PEX_TYPE_MASK		BIT3
+#define ATMWCR_WIN_PEX_TYPE_IO			(0 << ATMWCR_WIN_PEX_TYPE_OFFS)
+#define ATMWCR_WIN_PEX_TYPE_MEM			(1 << ATMWCR_WIN_PEX_TYPE_OFFS)
+
+/* typedefs */
+
+/* Unsupported attributes for address decode:                               */
+/* 2) PCI0/1_REQ64n control                                                 */
+
+typedef struct _mvTargetAttrib {
+	MV_U8			attrib;			/* chip select attributes */
+	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
+} MV_TARGET_ATTRIB;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin {
+    MV_TARGET	target;         /* Target for addr decode window        */
+    MV_ADDR_WIN	addrWin;        /* Address window of target             */
+    MV_BOOL	enable;         /* Window enable/disable                */
+} MV_DEC_WIN;
+
+typedef struct _mvDecWinParams {
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+} MV_DEC_WIN_PARAMS;
+
+
+/* mvCtrlEnvAddrDec API list */
+
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo);
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, MV_DEC_WIN_PARAMS *pWinParam);
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, MV_DEC_WIN *pAddrDecWin);
+
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len);
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvCtrlEnvAddrDech */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAsm.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAsm.h
new file mode 100644
index 0000000..1a14a79
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAsmh
+#define __INCmvCtrlEnvAsmh
+#include "pex/mvPexRegs.h"
+
+#define CHIP_BOND_REG			0x18238
+#define PCKG_OPT_MASK_AS 		#3
+#define PXCCARI_REVID_MASK_AS		#PXCCARI_REVID_MASK
+
+/* Read device ID into toReg bits 15:0 from 0xd0000000 */
+/* defines  */
+#define MV_DV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_DV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read device ID into toReg bits 15:0 from 0xf1000000*/
+#define MV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read Revision into toReg bits 7:0 0xd0000000*/
+#define MV_DV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_DV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+/* Read Revision into toReg bits 7:0 0xf1000000*/
+#define MV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+#endif /* __INCmvCtrlEnvAsmh */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100644
index 0000000..fbe0dad
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,1478 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvSysEthConfig.h"
+
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+#include "eth/mvEth.h"
+#else
+#include "neta/gbe/mvNeta.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA */
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+#include "xor/mvXor.h"
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+#include "sata/CoreDriver/mvSata.h"
+#endif
+#if defined(MV_INCLUDE_USB)
+#include "usb/mvUsb.h"
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+#include "mvSysTdmConfig.h"
+#endif
+
+#include "ddr2_3/mvDramIfRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+MV_U32 mvCtrlGetCpuNum(MV_VOID)
+{
+	return 2;
+}
+MV_BOOL mvCtrlIsValidSatR(MV_VOID)
+{
+	return MV_TRUE;
+}
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+	MV_U32 mppGroup;
+	MV_U32 mppVal;
+	MV_U32 i, gppMask;
+
+
+	/* Disable MBus Error Propagation */
+	MV_REG_BIT_RESET(SOC_COHERENCY_FABRIC_CTRL_REG, BIT8);
+
+	/* Use Background sync barrier (polling) for I/O cache coherency */
+	MV_REG_BIT_SET(SOC_CIB_CTRL_CFG_REG, BIT8);
+
+	/* MPP Init - scan which modeule is connected */
+	mvBoardMppModulesScan();
+
+	/* Read MPP config values from board level and write MPP options to HW */
+	for (mppGroup = 0; mppGroup < MV_MPP_MAX_GROUP; mppGroup++) {
+		mppVal = mvBoardMppGet(mppGroup);	/* get pre-defined values */
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+	/* disable all GPIO interrupts */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+	}
+
+	/* clear all int */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++)
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+
+	/* Set gpp interrupts as needed */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		gppMask = mvBoardGpioIntMaskGet(i);
+		mvGppTypeSet(i, gppMask , (MV_GPP_IN & gppMask));
+		mvGppPolaritySet(i, gppMask , (MV_GPP_IN_INVERT & gppMask));
+	}
+
+	/* Scan for other modules (SERDES/LVDS/...) */
+	mvBoardOtherModulesScan();
+
+	/* Update interfaces configuration based on above scan */
+	if (MV_OK != mvCtrlSerdesPhyConfig())
+		mvOsPrintf("mvCtrlEnvInit: Can't init some or all SERDES lanes\n");
+
+
+	mvOsDelay(100);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+	MV_U32 ret;
+
+	if (mppGroup >= MV_MPP_MAX_GROUP)
+		mppGroup = 0;
+
+	ret = MPP_CONTROL_REG(mppGroup);
+
+	return ret;
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
+{
+	return MV_PEX_MAX_IF;
+}
+#endif
+
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPciMaxIfGet(MV_VOID)
+{
+	return 0;
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	return MV_ETH_MAX_PORTS;
+}
+
+/*******************************************************************************
+* mvCtrlEthMaxCPUsGet - Get Marvell controller number of CPUs.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of CPUs.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of CPUs.
+*
+*******************************************************************************/
+MV_U8 mvCtrlEthMaxCPUsGet(MV_VOID)
+{
+	return 2;
+}
+
+
+#if defined(MV_INCLUDE_SATA)
+/*******************************************************************************
+* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of Sata ports.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of Sata ports.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
+{
+	return 0;
+}
+#endif
+
+#if defined(MV_INCLUDE_IDMA)
+/*******************************************************************************
+* mvCtrlIdmaMaxChanGet - Get Marvell controller number of IDMA channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of IDMA channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of IDMA channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID)
+{
+	return MV_IDMA_MAX_CHAN;
+}
+
+/*******************************************************************************
+* mvCtrlIdmaMaxUnitGet - Get Marvell controller number of IDMA units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of IDMA units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of IDMA units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID)
+{
+	return MV_IDMA_MAX_UNIT;
+}
+#endif /* MV_INCLUDE_IDMA */
+
+#if defined(MV_INCLUDE_XOR)
+/*******************************************************************************
+* mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
+{
+	return MV_XOR_MAX_CHAN;
+}
+
+/*******************************************************************************
+* mvCtrlXorMaxUnitGet - Get Marvell controller number of XOR units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
+{
+	return MV_XOR_MAX_UNIT;
+}
+
+#endif
+
+#if defined(MV_INCLUDE_USB)
+/*******************************************************************************
+* mvCtrlUsbHostMaxGet - Get number of Marvell Usb  controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB  controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsbMaxGet(void)
+{
+	return BC2_MAX_USB_PORTS;
+}
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND)
+/*******************************************************************************
+* mvCtrlNandSupport - Return if this controller has integrated NAND flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if NAND is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlNandSupport(MV_VOID)
+{
+	return BC2_NAND;
+}
+#endif
+
+#if defined(MV_INCLUDE_SDIO)
+/*******************************************************************************
+* mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SDIO is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlSdioSupport(MV_VOID)
+{
+	return BC2_SDIO;
+}
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmSupport(MV_VOID)
+{
+	return BC2_TDM;
+}
+
+/*******************************************************************************
+* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       The number of TDM ports in device.
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmMaxGet(MV_VOID)
+{
+	return BC2_MAX_TDM_PORTS;
+}
+
+/*******************************************************************************
+* mvCtrlTdmTypeGet
+*
+* DESCRIPTION:
+*	Return the TDM unit type being compiled in.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TDM unit type.
+*
+*******************************************************************************/
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID)
+{
+	return TDM_UNIT_32CH;
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitIrqGet
+*
+* DESCRIPTION:
+*	Return the TDM unit IRQ number depending on the TDM unit compilation
+*	options.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+******************************************************************************/
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
+{
+	return MV_TDM_IRQ_NUM;
+}
+
+#endif /* if defined(MV_INCLUDE_TDM) */
+
+/*******************************************************************************
+* mvCtrlModelGet - Get Marvell controller device model (Id)
+*
+* DESCRIPTION:
+*       This function returns 16bit describing the device model (ID) as defined
+*       in PCI Device and Vendor ID configuration register offset 0x0.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit desscribing Marvell controller ID
+*
+*******************************************************************************/
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	return MV_BOBCAT2_DEV_ID;
+}
+
+/*******************************************************************************
+* mvCtrlRevGet - Get Marvell controller device revision number
+*
+* DESCRIPTION:
+*       This function returns 8bit describing the device revision as defined
+*       in PCI Express Class Code and Revision ID Register.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit desscribing Marvell controller revision number
+*
+*******************************************************************************/
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	MV_U8 revNum;
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Check pex power state */
+	MV_U32 pexPower;
+	pexPower = mvCtrlPwrClckGet(PEX_UNIT_ID, 0);
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_TRUE);
+#endif
+	revNum = (MV_U8) MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PCI_CLASS_CODE_AND_REVISION_ID));
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Return to power off state */
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_FALSE);
+#endif
+	return ((revNum & PCCRIR_REVID_MASK) >> PCCRIR_REVID_OFFS);
+}
+
+/*******************************************************************************
+* mvCtrlNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlNameGet(char *pNameBuff)
+{
+	mvOsSPrintf(pNameBuff, "%s", SOC_NAME_PREFIX);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlModelRevGet - Get Controller Model (Device ID) and Revision
+*
+* DESCRIPTION:
+*       This function returns 32bit value describing both Device ID and Revision
+*       as defined in PCI Express Device and Vendor ID Register and device revision
+*	    as defined in PCI Express Class Code and Revision ID Register.
+
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing both controller device ID and revision number
+*
+*******************************************************************************/
+MV_U32 mvCtrlModelRevGet(MV_VOID)
+{
+	return ((mvCtrlModelGet() << 16) | mvCtrlRevGet());
+}
+
+/*******************************************************************************
+* mvCtrlModelRevNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
+{
+	mvCtrlNameGet(pNameBuff);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlDevFamilyIdGet - Get Device ID
+*
+* DESCRIPTION:
+*       This function returns Device ID.
+*
+* INPUT:
+*       ctrlModel.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board Device ID number, '-1' if Device ID is undefined.
+*
+*******************************************************************************/
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
+{
+	return MV_BOBCAT2_DEV_ID;
+}
+
+static const char *cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
+{
+	if (target >= MAX_TARGETS)
+		return "target unknown";
+
+	return cntrlName[target];
+}
+
+/*******************************************************************************
+* mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
+*
+* DESCRIPTION:
+*		This function print the PEX address decode map (BARs and windows).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
+{
+	MV_PEX_BAR pexBar;
+	MV_PEX_DEC_WIN win;
+	MV_U32 pexIf;
+	MV_U32 bar, winNum;
+
+	MV_U32 pexHWInf = 0;
+
+	for (pexIf = 0; pexIf < MV_PEX_MAX_IF; pexIf++) {
+		pexHWInf = pexIf;
+
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("PEX%d:\n", pexHWInf);
+		mvOsOutput("-----\n");
+
+		mvOsOutput("\nPex Bars \n\n");
+
+		for (bar = 0; bar < PEX_MAX_BARS; bar++) {
+			memset(&pexBar, 0, sizeof(MV_PEX_BAR));
+
+			mvOsOutput("%s ", pexBarNameGet(bar));
+
+			if (mvPexBarGet(pexHWInf, bar, &pexBar) == MV_OK) {
+				if (pexBar.enable) {
+					mvOsOutput("base %08x, ", pexBar.addrWin.baseLow);
+					if (pexBar.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(pexBar.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+		mvOsOutput("\nPex Decode Windows\n\n");
+
+		for (winNum = 0; winNum < PEX_MAX_TARGET_WIN - 2; winNum++) {
+			memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+			mvOsOutput("win%d - ", winNum);
+
+			if (mvPexTargetWinRead(pexHWInf, winNum, &win) == MV_OK) {
+				if (win.winInfo.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win.winInfo)),
+						   win.winInfo.addrWin.baseLow);
+					mvOsOutput("....");
+					mvSizePrint(win.winInfo.addrWin.size);
+
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("default win - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_DEFAULT, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("Expansion ROM - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_EXP_ROM, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvUnitAddrDecShow - Print the Unit's address decode map.
+*
+* DESCRIPTION:
+*       This is a generic function for printing the different unit's address
+*	decode map.
+*
+* INPUT:
+*       unit	- The unit to print the address decode for.
+*	name	- The unit's name.
+*	winGetFuncPtr - A pointer to the HAL's window get function.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId, const char *name, MV_WIN_GET_FUNC_PTR winGetFuncPtr)
+{
+	MV_UNIT_WIN_INFO win;
+	MV_U32 unit, i;
+
+	for (unit = 0; unit < numUnits; unit++) {
+
+		if (MV_FALSE == mvCtrlPwrClckGet(unitId, unit))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("%s %d:\n", name, unit);
+		mvOsOutput("----\n");
+
+		for (i = 0; i < 16; i++) {
+			memset(&win, 0, sizeof(MV_UNIT_WIN_INFO));
+
+			mvOsOutput("win%d - ", i);
+
+			if (winGetFuncPtr(unit, i, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win)),
+						   win.addrWin.baseLow);
+					mvOsOutput("....");
+					if (win.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* mvCtrlAddrDecShow - Print the Controller units address decode map.
+*
+* DESCRIPTION:
+*		This function the Controller units address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlAddrDecShow(MV_VOID)
+{
+	mvCpuIfAddDecShow();
+	mvAhbToMbusAddDecShow();
+#if defined(MV_INCLUDE_PEX)
+	mvCtrlPexAddrDecShow();
+#endif
+#if defined(MV_INCLUDE_USB)
+	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
+#endif
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#else
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
+#endif /* MV_ETH_LEGACY */
+#endif /* MV_INCLUDE_GIG_ETH */
+
+#if defined(MV_INCLUDE_XOR)
+	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
+#endif
+#if defined(MV_INCLUDE_SATA)
+	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
+#endif
+}
+
+/*******************************************************************************
+* ctrlSizeToReg - Extract size value for register assignment.
+*
+* DESCRIPTION:
+*       Address decode size parameter must be programed from LSB to MSB as
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
+*       value of 0x00ff specifies 256x64k = 16 MB).
+*       This function extract the size value from the size parameter according
+*       to given aligment paramter. For example for size 0x1000000 (16MB) and
+*       aligment 0x10000 (64KB) the function will return 0x00FF.
+*
+* INPUT:
+*       size - Size.
+*       alignment - Size alignment. Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size register value correspond to size parameter.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 retVal;
+
+	/* Check size parameter alignment               */
+	if ((0 == size) || (MV_IS_NOT_ALIGN(size, alignment))) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
+		return -1;
+	}
+
+	/* Take out the "alignment" portion out of the size parameter */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+	/* and size is 0x1000000 (16MB) for example     */
+	while (alignment & 1) {	/* Check that alignmet LSB is set       */
+		size = (size >> 1);	/* If LSB is set, move 'size' one bit to right      */
+		alignment = (alignment >> 1);
+	}
+
+	/* If after the alignment first '0' was met we still have '1' in                */
+	/* it then aligment is invalid (not power of 2)                                 */
+	if (alignment) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", (MV_U32) alignment));
+		return -1;
+	}
+
+	/* Now the size is shifted right according to aligment: 0x0100                  */
+	size--;			/* Now the size is a sequance of '1': 0x00ff                    */
+	retVal = size;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	while (size & 1)	/* Check that LSB is set    */
+		size = (size >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (size) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", size));
+		return -1;
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+* ctrlRegToSize - Extract size value from register value.
+*
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*       according to given aligment paramter. For example for register size
+*       value 0xff and aligment 0x10000 the function will return 0x01000000.
+*
+* INPUT:
+*       regSize   - Size as in register format.	See ctrlSizeToReg.
+*       alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
+{
+	MV_U32 temp;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff            */
+
+	while (temp & 1)	/* Check that LSB is set                                    */
+		temp = (temp >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (temp) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n", regSize));
+		return -1;
+	}
+
+	/* Check that aligment is a power of two                                        */
+	temp = alignment - 1;	/* Now the alignmet is a sequance of '1' (0xffff)          */
+
+	while (temp & 1)	/* Check that alignmet LSB is set                           */
+		temp = (temp >> 1);	/* If LSB is set, move 'size' one bit to right      */
+
+	/* If after the 'temp' first '0' was met we still have '1' in 'temp'            */
+	/* then 'temp' is invalid (not power of 2)                                      */
+	if (temp) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", alignment));
+		return -1;
+	}
+
+	regSize++;		/* Now the size is 0x0100                                       */
+
+	/* Add in the "alignment" portion to the register size parameter                */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+
+	while (alignment & 1) {	/* Check that alignmet LSB is set                       */
+		regSize = (regSize << 1);	/* LSB is set, move 'size' one bit left     */
+		alignment = (alignment >> 1);
+	}
+
+	return regSize;
+}
+
+/*******************************************************************************
+* ctrlSizeRegRoundUp - Round up given size
+*
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
+*       restrictions of size format given an aligment parameter.
+*		to given aligment paramter. For example for size parameter 0xa1000 and
+*		aligment 0x1000 the function will return 0xFF000.
+*
+* INPUT:
+*       size - Size.
+*		alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size value correspond to size in register.
+*******************************************************************************/
+MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 msbBit = 0;
+	MV_U32 retSize;
+
+	/* Check if size parameter is already comply with restriction   */
+	if (!(-1 == ctrlSizeToReg(size, alignment)))
+		return size;
+
+	while (size) {
+		size = (size >> 1);
+		msbBit++;
+	}
+
+	retSize = (1 << msbBit);
+
+	if (retSize < alignment)
+		return alignment;
+	else
+		return retSize;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNOR
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from NOR flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MSAR_BOOT_MODE(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)), 0);
+
+	if (satr == SAR1_BOOT_FROM_NOR)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromSPI
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from SPI flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MSAR_BOOT_MODE(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)), 0);
+
+	if (satr == SAR1_BOOT_FROM_SPI)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNAND
+*
+* DESCRIPTION:
+*       Check if device is confiogured to boot from NAND flash according to the SAR
+*	registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from NAND.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MSAR_BOOT_MODE(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)), 0);
+
+	if (satr == SAR1_BOOT_FROM_NAND)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckSet - Set Power State for specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+
+		break;
+#endif
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrClckGet - Get Power State of specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	MV_BOOL state = MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if ((reg & PMC_PEXSTOPCLOCK_MASK) == PMC_PEXSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if ((reg & PMC_GESTOPCLOCK_MASK(index)) == PMC_GESTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if ((reg & PMC_SDIOSTOPCLOCK_MASK) == PMC_SDIOSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+#else
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	return;
+}
+
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	return MV_TRUE;
+}
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (1 << REG_SDRAM_CONFIG_DDR_BUS_OFFS)) ? 64 : 32;
+}
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x20184);
+
+	return (reg & 0x1) ? MV_FALSE : MV_TRUE;
+}
+
+MV_BOOL mvCtrlDDRECC(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_ECC_OFFS)) ? MV_TRUE : MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlSerdesPhyConfig
+*
+* DESCRIPTION:
+*	Configure Serdes MUX and init PHYs connected to SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Status
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
+{
+	MV_U32		socCtrlReg;
+	MV_STATUS	status = MV_OK;
+	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
+
+/* this is a mapping of the final power management clock gating control register value @ 0x18220.*/
+	MV_U32	powermngmntctrlregmap = 0x0;
+	MV_U32	tmpcounter = 0;
+
+	/* Check if no SERDESs available - FPGA */
+
+	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
+	socCtrlReg = MV_REG_READ(SOC_CTRL_REG);
+
+	if ((socCtrlReg & 1) == 0)
+		boardPexInfo->pexUnitCfg[0].pexCfg = PEX_BUS_DISABLED;
+	else {
+		boardPexInfo->pexUnitCfg[0].pexCfg = PEX_BUS_MODE_X1;
+		boardPexInfo->pexMapping[0] = 0;
+		boardPexInfo->boardPexIfNum++;
+		boardPexInfo->pexUnitCfg[0].pexLaneStat[0] = 0x1;
+		powermngmntctrlregmap |= PMC_PEXSTOPCLOCK_EN;
+	}
+
+	powermngmntctrlregmap |= PMC_GESTOPCLOCK_EN(1);
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	powermngmntctrlregmap |= PMC_GESTOPCLOCK_EN(0); ; /* Enabling port GE0 always since we need SMI 0 to access other PHYs*/
+
+
+	/* Hard core enable SDIO, XOR, device clock cause we don't support this at this momemt*/
+	powermngmntctrlregmap |= BIT24 | BIT22 | BIT17 ;
+	DB(mvOsPrintf("%s:Shutting down unused interfaces:\n", __func__));
+	/*now report everything to the screen*/
+	for (tmpcounter = 0; tmpcounter < 4; tmpcounter++) {
+		if (!(powermngmntctrlregmap & (1 << (4 - tmpcounter)))) {
+			/*mvOsOutput("       GBE%d\n", tmpcounter );*/
+			DB(mvOsPrintf("%s:       GBE%d\n", __func__, tmpcounter));
+			mvCtrlPwrClckSet(ETH_GIG_UNIT_ID, tmpcounter, MV_FALSE);
+		}
+	}
+	if (!(powermngmntctrlregmap & PMC_PEXSTOPCLOCK_EN)) {
+		DB(mvOsPrintf("%s:       PEX%d.%d\n", __func__, tmpcounter>>2, tmpcounter % 4));
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_FALSE);
+	}
+
+/*this code is valid for all devices after Z1*/
+	/*apply clock gatting*/
+	MV_REG_WRITE(POWER_MNG_CTRL_REG, MV_REG_READ(POWER_MNG_CTRL_REG) & powermngmntctrlregmap);
+#endif /* defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+
+	return status;
+}
+
+/*******************************************************************************
+* mvCtrlGetJuncTemp
+*
+* DESCRIPTION:
+*       Read temperature, calibrate at first time the TSEN
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Tj value.
+*******************************************************************************/
+MV_U32 mvCtrlGetJuncTemp(MV_VOID)
+{
+#if 0
+	MV_32 reg = 0;
+	/* init the TSEN sensor once */
+	if ((MV_REG_READ(TEMPERATURE_SENSOR_MSB_CTRL_REG) & TSEN_OTF_CALIB_MSK) == 0) {
+		MV_REG_BIT_SET(TSEN_CONF_REG, TSEN_OTF_CALIB_MSK);
+
+		reg = MV_REG_READ(TEMPERATURE_SENSOR_MSB_CTRL_REG);
+		reg &= ~(TSMC_UNIT_CONTROL_MASK);
+		reg |= (TSMC_UNIT_CONTROL_AVR << TSMC_UNIT_CONTROL_OFS)
+		MV_REG_WRITE(TEMPERATURE_SENSOR_MSB_CTRL_REG, reg);
+
+
+		/* Do not start calibration sequence */
+		MV_REG_BIT_RESET(TSEN_CONF_REG, TSEN_CONF_START_CALIB_MASK);
+
+		/* Initiate Soft Reset*/
+		MV_REG_BIT_SET(TSEN_CONF_REG, TSEN_CONF_SOFT_RESET_MASK);
+		mvOsDelay(1);
+
+		/* Exit from Soft Reset*/
+		MV_REG_BIT_RESET(TSEN_CONF_REG, TSEN_CONF_SOFT_RESET_MASK);
+		mvOsDelay(10);
+	}
+
+	reg = MV_REG_READ(TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+#ifdef ERRATA_FE_982377
+	{ /* Internal CPU Temperature Read Out Stability */
+		int reg1, reg2, reg3, i;
+		for (i = 0; i < 20; i++) {
+			reg1 = MV_REG_READ(TSEN_STATUS_REG);
+			reg1 = (reg1 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			reg2 = MV_REG_READ(TSEN_STATUS_REG);
+			reg2 = (reg2 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			reg3 = MV_REG_READ(TSEN_STATUS_REG);
+			reg3 = (reg3 & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+			if ((reg1 == reg2) && (reg1 == reg3)) {
+				reg = reg1;
+				break;
+			}
+		}
+	}
+#endif
+	return (3153000 - (10000 * reg)) / 13825;
+#endif
+	return -1;
+}
+
+/*******************************************************************************
+* mvCtrlGetPexActive
+*
+* DESCRIPTION:
+*	fill input boolean array of pex interface
+*
+* INPUT:
+*       pPexActive - pointer to boolean array (size is max pex IF).
+*	size	   - array size
+*
+* OUTPUT:
+*        boolean array - true or false if pex exists
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+void mvCtrlGetPexActive(MV_BOOL *pPexActive, int size)
+{
+	if (size == 0)
+		return;
+	pPexActive[0] = MV_TRUE;
+}
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100644
index 0000000..80f1d2b
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,216 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+/* includes */
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+/*#include "boardEnv/mvBoardEnvLib.h"*/
+
+/* 0 for Auto scan mode, 1 for manual. */
+#define MV_INTERNAL_SWITCH_SMI_SCAN_MODE	0
+
+/* typedefs */
+typedef MV_STATUS(*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+
+typedef enum {
+	PEX_BUS_DISABLED	= 0,
+	PEX_BUS_MODE_X1		= 1,
+	PEX_BUS_MODE_X4		= 2,
+	PEX_BUS_MODE_X8		= 3
+} MV_PEX_UNIT_CFG;
+
+
+/* BIOS Modes related defines */
+
+#define SAR0_BOOTWIDTH_OFFSET	3
+#define SAR0_BOOTWIDTH_MASK		(0x3 << SAR0_BOOTWIDTH_OFFSET)
+#define SAR0_BOOTSRC_OFFSET		5
+#define SAR0_BOOTSRC_MASK		(0xF << SAR0_BOOTSRC_OFFSET)
+
+#define SAR0_L2_SIZE_OFFSET		19
+#define SAR0_L2_SIZE_MASK		(0x3 << SAR0_L2_SIZE_OFFSET)
+#define SAR0_CPU_FREQ_OFFSET	21
+#define SAR0_CPU_FREQ_MASK		(0x7 << SAR0_CPU_FREQ_OFFSET)
+#define SAR0_FABRIC_FREQ_OFFSET	24
+#define SAR0_FABRIC_FREQ_MASK	(0xF << SAR0_FABRIC_FREQ_OFFSET)
+#define SAR0_CPU0CORE_OFFSET	31
+#define SAR0_CPU0CORE_MASK		(0x1 << SAR0_CPU0CORE_OFFSET)
+#define SAR1_CPU0CORE_OFFSET	0
+#define SAR1_CPU0CORE_MASK		(0x1 << SAR1_CPU0CORE_OFFSET)
+
+#define PEX_CLK_100MHZ_OFFSET	2
+#define PEX_CLK_100MHZ_MASK     (0x1 << PEX_CLK_100MHZ_OFFSET)
+
+#define SAR1_CPU_CORE_OFFSET	3
+#define SAR1_CPU_CORE_MASK		(0x3 << SAR1_CPU_CORE_OFFSET)
+#define SAR1_FABRIC_MODE_OFFSET	19
+#define SAR1_FABRIC_MODE_MASK	(0x1 << SAR1_FABRIC_MODE_OFFSET)
+#define SAR1_CPU_MODE_OFFSET	20
+#define SAR1_CPU_MODE_MASK		(0x1 << SAR1_CPU_MODE_OFFSET)
+
+#define SAR_CPU_FAB_GET(cpu, fab)	(((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+#define BIOS_MODES_NUM			4
+
+typedef struct {
+	char *name;
+	MV_U16 confId;
+	MV_U16 code;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreq;
+	MV_U8 AltfabricFreq;
+	MV_U8 fabricFreqMode;
+	MV_U8 cpuEna;
+	MV_U8 cpuEndianess;
+	MV_U8 dramBusWidth;
+	MV_U8 bootSource;
+	MV_U8 bootWidth;
+} MV_BIOS_MODE;
+
+/* mcspLib.h API list */
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32	mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32	mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPexMaxIfGet()	(0)
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+MV_U32	mvCtrlPciMaxIfGet(MV_VOID);
+#else
+#define mvCtrlPciIfMaxIfGet()	(mvCtrlPexMaxIfGet())
+#endif
+
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
+#if defined(MV_INCLUDE_IDMA)
+MV_U32 mvCtrlIdmaMaxUnitGet(MV_VOID);
+MV_U32 mvCtrlIdmaMaxChanGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+MV_U32	  mvCtrlNandSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32	  mvCtrlSdioSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
+#endif
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID   mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32	  ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32	  ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32	  ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32	  mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_BOOL	  mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_BOOL	  mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID);
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+MV_U32 mvCtrlGetJuncTemp(MV_VOID);
+void mvCtrlGetPexActive(MV_BOOL *pPexActive, int size);
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100644
index 0000000..ac09996
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,358 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0 	PEX0_MEM
+#define PCI0_MEM0	PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID		0x008
+#define PCCRIR_REVID_OFFS			0		/* Revision ID */
+#define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM				56
+
+
+/* Coherent Fabric Control and Status */
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/* PMU_NFABRIC PMU_NFABRIC PMU_UNIT_SERVICE Units */
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_REG		(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x4)
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_PWR_DOWN	(1 << 20)
+
+#define MV_L2C_NFABRIC_PWR_DOWN_FLOW_CTRL_REG	(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x8)
+
+#define PM_CONTROL_AND_CONFIG_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x4)
+#define PM_CONTROL_AND_CONFIG_DFS_REQ		(1 << 18)
+#define PM_CONTROL_AND_CONFIG_PWDDN_REQ		(1 << 16)
+#define PM_CONTROL_AND_CONFIG_L2_PWDDN		(1 << 20)
+
+#define PM_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0xc)
+#define PM_STATUS_AND_MASK_CPU_IDLE_WAIT	(1 << 16)
+#define PM_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT	(1 << 17)
+#define PM_STATUS_AND_MASK_IRQ_WAKEUP		(1 << 20)
+#define PM_STATUS_AND_MASK_FIQ_WAKEUP		(1 << 21)
+#define PM_STATUS_AND_MASK_DBG_WAKEUP		(1 << 22)
+#define PM_STATUS_AND_MASK_IRQ_MASK		(1 << 24)
+#define PM_STATUS_AND_MASK_FIQ_MASK		(1 << 25)
+
+#define PM_EVENT_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x20)
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_OFFS			1
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_MASK_OFFS		17
+
+#define PM_CPU_BOOT_ADDR_REDIRECT(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x24)
+
+
+/* TODO - verify, the manual has no description */
+#define PMC_CPUSTOPMEM_OFFS(id)			((id) < 4 ? (id) * 3 : 0)
+#define PMC_CPUSTOPMEM_MASK(id)			(7 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
+
+#define PMC_IDMASTOPMEM_OFFS			12
+#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
+
+#define PMC_LCDSTOPMEM_OFFS			0
+#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
+
+#define PMC_PMUSTOPMEM_OFFS			0
+#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
+
+
+/*  Power Management Clock Gating Control Register	*/
+#define POWER_MNG_CTRL_REG			0x18220
+#define L2C_MTCMOS_CONTROL_0_REG    0x22F00
+#define L2C_MTCMOS_CONTROL_1_REG    0x22F04
+
+#define PMC_PEXSTOPCLOCK_OFFS			5
+#define PMC_PEXSTOPCLOCK_MASK			(1 << PMC_PEXSTOPCLOCK_OFFS)
+#define PMC_PEXSTOPCLOCK_EN			(1 << PMC_PEXSTOPCLOCK_OFFS)
+#define PMC_PEXSTOPCLOCK_STOP			(0 << PMC_PEXSTOPCLOCK_OFFS)
+
+#define PMC_SDIOSTOPCLOCK_OFFS			17
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_RUNITSTOPCLOCK_OFFS			24
+#define PMC_RUNITSTOPCLOCK_MASK			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_EN			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_STOP			(0 << PMC_RUNITSTOPCLOCK_OFFS)
+
+#define PMC_XORSTOPCLOCK_OFFS			22
+#define PMC_XORSTOPCLOCK_MASK			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_EN			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_STOP			(0 << PMC_XORSTOPCLOCK_OFFS)
+
+#define PMC_GESTOPCLOCK_OFFS(port)		(4 - (port))
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+
+/* Controler environment registers offsets */
+
+#define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
+
+/* Sample at Reset */
+//#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
+
+#define DFX_DEVICE_SAR_REG(x)			(0xf8200 +(x*4))
+
+#define MSAR_CORE_CLK(sar1, sar2)		(((sar2) >> 21) & 0x7)		/* PLL 0 config */
+#define MSAR_CPU_DDR_CLK(sar1, sar2)		(((sar2) >> 18) & 0x7)		/* PLL 1 config */
+#define MSAR_TM_CLK(sar1, sar2)			(((sar2) >> 15) & 0x7)		/* PLL 2 config */
+#define MSAR_BOOT_MODE(sar1, sar2)		(((sar1) >> 13) & 0x7)		/* boot from */
+#define MSAR_DEVICE_MODE(sar1, sar2)		(((sar1) >>  0) & 0xFF)		/* DEVICE ID field */
+
+#define SAR1_BOOT_FROM_NOR			0
+#define SAR1_BOOT_FROM_NAND			1
+#define SAR1_BOOT_FROM_UART			2
+#define SAR1_BOOT_FROM_SPI			3
+#define SAR1_BOOT_FROM_PCI			4
+#define SAR1_BOOT_FROM_NO_BOOT			5
+#define SAR1_BOOT_FROM_UART_DBG			6
+#define SAR1_BOOT_FROM_DISABLE			7
+
+#define DFX_CORE_DIVCLK_CONTROL0_REG		0xF8268 /*/Cider/EBU/Bobcat2/Bobcat2 {Current}/
+							Reset and Init Controller/
+								DFX Server Units -
+								BC2 specific registers/Device Control 6 */
+#define CORE_DIVCLK_RELOAD_FORCE_OFFS		21
+#define CORE_DIVCLK_RELOAD_FORCE_MASK		(0x7F << CORE_DIVCLK_RELOAD_FORCE_OFFS)
+#define CORE_DIVCLK_RELOAD_FORCE_VAL		(0x40 << CORE_DIVCLK_RELOAD_FORCE_OFFS)
+
+#define DFX_CORE_DIVCLK_RELOAD_REG		0xF8270 /*/Cider/EBU/Bobcat2/Bobcat2 {Current}/
+								Reset and Init Controller/
+								DFX Server Units - BC2 specific registers/
+								Device Control 8	*/
+
+#define CORE_DIVCLK_RELOAD_RATIO_OFFS		8
+#define CORE_DIVCLK_RELOAD_RATIO_MASK		(2 << CORE_DIVCLK_RELOAD_RATIO_OFFS)
+
+#define NAND_ECC_DIVCKL_RATIO_OFFS		6
+#define NAND_ECC_DIVCKL_RATIO_MASK		(0xF << NAND_ECC_DIVCKL_RATIO_OFFS)
+#define NAND_ECC_DIVCKL_RATIO_VAL		(0x8 << NAND_ECC_DIVCKL_RATIO_OFFS)
+
+#define CORE_DIV_CLK_CTRL(num)			(DFX_CORE_DIVCLK_CONTROL0_REG + ((num) * 0x4))
+
+
+#define DFX_TEMPERATURE_SENSOR_LSB_CTRL_REG		0xF8070
+#define DFX_TEMPERATURE_SENSOR_MSB_CTRL_REG		0xF8074
+#define DFX_TEMPERATURE_SENSOR_STATUS_REG		0xF8078
+/* definition for caculate Temperature */
+#define TEMPERATURE_OFFSET        (596)
+#define TEMPERATURE_FACTOR        (2154)
+#define TEMPERATURE_FACTOR_DIV    (1000)
+
+#define TSMC_UNIT_CONTROL_OFS		28
+#define TSMC_UNIT_CONTROL_MASK		(7 << TSMC_UNIT_CONTROL_OFS)
+#define TSMC_UNIT_CONTROL_SENSOR0	0
+#define TSMC_UNIT_CONTROL_SENSOR1       1
+#define TSMC_UNIT_CONTROL_SENSOR2       2
+#define TSMC_UNIT_CONTROL_SENSOR3       3
+#define TSMC_UNIT_CONTROL_SENSOR4       4
+#define TSMC_UNIT_CONTROL_HOTTEST 	6
+#define TSMC_UNIT_CONTROL_AVR 	6
+
+#define TSEN_SW_RESET_OFS 		7	/* SW reset */
+#define TSEN_SW_RESETMSK 		(1 << TSEN_SW_RESET_OFS)
+#define TSEN_PWD_OFS 			6	/* power down */
+#define TSEN_PWD_MSK 			(1 << TSEN_PWD_OFS)
+#define TSEN_SLEEP_OFS 			5
+#define TSEN_SLEEP_MSK 			(1 << TSEN_SLEEP_OFS)
+
+#define TSEN_OTF_CALIB_OFS 	4
+#define TSEN_OTF_CALIB_MSK 	(1 << TSEN_OTF_CALIB_OFS)
+
+
+
+
+
+
+
+/*****************/
+/*  registers */
+/*****************/
+#define  I2C_CONFIC_DEBUG_REG	0x1180c
+#define	ICDR_UINIT_ID_MASK	0x0F
+#define ICDR_UNIT_ID_4_DFX	0x0f
+
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+
+
+#ifndef MV_ASMLANGUAGE
+
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+		((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+		((target >= PEX0_MEM) && (target <= PEX0_IO))
+
+#define MV_TARGET_IS_PEX(target)	MV_TARGET_IS_PEX0(target)
+
+#define MV_TARGET_IS_DEVICE(target)	((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_PCI_DRAM_BAR_TO_DRAM_TARGET(bar)   0
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0		PEX0_MEM
+#define PCI_IF0_IO		PEX0_IO
+
+/* This enumerator defines the Marvell controller target ID  (see Address map) */
+typedef enum _mvTargetId {
+    DRAM_TARGET_ID	= 0,	/* Port 0 -> DRAM interface		*/
+    DEV_TARGET_ID	= 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+    PEX0_TARGET_ID	= 4,	/* Port 4 -> PCI Express 0 		*/
+    CRYPT_TARGET_ID	= 9,	/* Port 9 --> Crypto Engine SRAM	*/
+    PNC_BM_TARGET_ID	= 12,  	/* Port 12 -> PNC + BM Unit		*/
+    MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+
+/*
+	This enum should reflect the units numbers in register
+	space which we will need when accessing the HW
+*/
+
+typedef enum {
+	PEX0_0x4	= 0,
+	PEXIF_MAX	= 1
+} MV_PEXIF_INDX;
+
+typedef struct {
+	MV_U32 	cpuFreq;
+	MV_U32 	ddrFreq;
+	MV_STATUS internalFreq;
+} MV_CPUDDR_MODE;
+
+typedef struct {
+	MV_U32 	tmFreq;
+	MV_U32 	ddr3Freq;
+	MV_STATUS internalFreq;
+} MV_TM_MODE;
+
+#define MV_CORE_CLK_TBL	{	\
+	360, 220, 		\
+	250, 400,               \
+	500, 520,               \
+	450                     \
+}
+
+#define MV_CPU_DDR_CLK_TBL {	\
+	{ 400, 400, MV_FALSE},  \
+	{ 533, 533, MV_TRUE},   \
+	{ 667, 667, MV_FALSE},  \
+	{ 800, 800, MV_FALSE},  \
+	{1000, 500, MV_TRUE},   \
+	{1200, 600, MV_TRUE},   \
+	{1333, 666, MV_TRUE}    \
+}
+#define MV_TM_CLK_TBL	{ 	\
+	{   0,   0, MV_TRUE},   \
+	{ 400, 800, MV_FALSE},  \
+	{ 466, 933, MV_FALSE},  \
+	{ 333, 667, MV_FALSE},  \
+	{   0,   0, MV_TRUE},   \
+	{ -1, 800, MV_TRUE},    \
+	{ -1, 933, MV_TRUE}     \
+}
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100644
index 0000000..c1af8e1
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,394 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX				"Bobcat2"
+
+/*
+ * Bobcat2 Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET			(0x0)
+#define MV_AURORA_L2_REGS_OFFSET		(0x8000)
+
+#define MV_DEV_BUS_REGS_OFFSET			(0x10400)
+#define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
+
+#define MV_UART_REGS_OFFSET(chanNum)		(0x12000 + (chanNum * 0x100))
+
+#define MV_MPP_REGS_OFFSET			(0x18000)
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x80))
+
+#define MV_MISC_REGS_OFFSET			(0x18200)
+#define MV_MBUS_REGS_OFFSET			(0x20000)
+#define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
+#define MV_CNTMR_REGS_OFFSET			(0x20300)
+#define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)		(0x21800 + (cpu) * 0x100)
+#define MV_PMU_NFABRIC_UNIT_SERV_OFFSET		(0x22000)
+#define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
+
+#if defined(MV_ETH_LEGACY)
+	#define MV_ETH_BASE_ADDR		(0x72000)
+#else
+	#define MV_ETH_BASE_ADDR		(0x70000)
+#endif
+#define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR + (port)* 0x40000 )
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(0x40000)
+
+#define MV_XOR_REGS_OFFSET(unit)		(0xF0000)
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_REGS_OFFSET			(0x60800)
+#endif
+#define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
+#define MV_NFC_REGS_OFFSET			(0xD0000)
+#define MV_BM_REGS_OFFSET			(0xC0000)
+#define MV_PNC_REGS_OFFSET			(0xC8000)
+#define MV_SDMMC_REGS_OFFSET			(0xD4000)
+
+
+#define MV_ETH_SMI_PORT   0
+/*
+ * Miscellanuous Controller Configurations
+ */
+
+#define AVS_CONTROL2_REG			0x20868
+#define AVS_LOW_VDD_LIMIT			0x20860
+
+#define INTER_REGS_SIZE				_1M
+#define DFX_REGS_SIZE				_1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)		((ch) + 3)
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS				33
+#define MV_GPP_MAX_GROUP    			2 	/* group == configuration register? */
+#define MV_CNTMR_MAX_COUNTER 			8 	/* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
+
+
+#define MV_UART_MAX_CHAN			2
+
+#define MV_XOR_MAX_UNIT				1 /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN         		2 /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
+
+#if defined(MV_INCLUDE_IDMA)
+#define MV_IDMA_MAX_UNIT			0 /* IDMA unit == IDMA engine */
+#define MV_IDMA_MAX_CHAN			0 /* total channels for all units together */
+#endif
+
+#define MV_SATA_MAX_CHAN			0
+
+#define MV_MPP_MAX_GROUP			2
+
+#define MV_DRAM_MAX_CS				4
+#define MV_SPI_MAX_CS				8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+ #define MV_PCI_MAX_IF				1
+ #define MV_PCI_START_IF			0
+ #define PCI_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PCI_HOST_DEV_NUM(pciIf)               0
+#else
+ #define MV_PCI_MAX_IF				0
+ #define MV_PCI_START_IF			0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF				1
+#define MV_PEX_MAX_UNIT				1
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF				MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces 	*/
+#define MV_IDMA_MAX_CHAN			2
+#define BC2_MAX_USB_PORTS			0
+#define BC2_NAND				1
+#define BC2_SDIO				1
+#define MV_DEVICE_MAX_CS      			4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS 			BC2_MAX_USB_PORTS
+#endif
+
+
+/* This define describes the maximum number of supported Ethernet ports */
+/* TODO - verify all these numbers */
+#define MV_ETH_VERSION 				4 /* for Legacy mode */
+#define MV_NETA_VERSION				1 /* for NETA mode */
+#define MV_ETH_MAX_PORTS			2
+#define MV_ETH_MAX_RXQ              		8
+#define MV_ETH_MAX_TXQ              		8
+#define MV_ETH_TX_CSUM_MAX_SIZE 		9800
+#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
+#define BOARD_ETH_SWITCH_PORT_NUM		2
+
+/* New GMAC module is used */
+#define MV_ETH_GMAC_NEW
+/* New WRR/EJP module is used */
+#define MV_ETH_WRR_NEW
+/* IPv6 parsing support for Legacy parser */
+#define MV_ETH_LEGACY_PARSER_IPV6
+/* New PNC module - extra fields */
+#define MV_ETH_PNC_NEW
+/* PNC Load Balancing support */
+#define MV_ETH_PNC_LB
+
+#define MV_MV_98DX_ETH_MAX_PORT			2
+
+/* This define describes the the support of USB */
+#define MV_USB_VERSION  			1
+
+#define MV_SPI_VERSION				2
+
+#define MV_INCLUDE_SDRAM_CS0
+#define MV_INCLUDE_SDRAM_CS1
+#define MV_INCLUDE_SDRAM_CS2
+#define MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED	0	/* Used to mark unused entry */
+
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_32CH_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	SDIO_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,        /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*  0 SDRAM chip select 0	*/
+	SDRAM_CS1,	/*  1 SDRAM chip select 1	*/
+	SDRAM_CS2,	/*  2 SDRAM chip select 2	*/
+	SDRAM_CS3,	/*  3 SDRAM chip select 3	*/
+	DEVICE_CS0,	/*  4 Device chip select 0	*/
+	DEVICE_CS1,	/*  5 Device chip select 1	*/
+	DEVICE_CS2,	/*  6 Device chip select 2	*/
+	DEVICE_CS3,	/*  7 Device chip select 3	*/
+	PEX0_MEM,	/*  8 PCI Express 0 Memory	*/
+	PEX0_IO,	/*  9 PCI Express 0 IO		*/
+	INTER_REGS,	/* 10 Internal registers	*/
+	DFX_REGS,	/* 11 DFX Internal registers	*/
+	DMA_UART,	/* 12 DMA based UART request	*/
+	SPI_CS0,	/* 13 SPI_CS0			*/
+	SPI_CS1,	/* 14 SPI_CS1			*/
+	SPI_CS2,	/* 15 SPI_CS2			*/
+	SPI_CS3,	/* 16 SPI_CS3			*/
+	SPI_CS4,	/* 17 SPI_CS4			*/
+	SPI_CS5,	/* 18 SPI_CS5			*/
+	SPI_CS6,	/* 19 SPI_CS6			*/
+	SPI_CS7,	/* 20 SPI_CS7			*/
+	BOOT_ROM_CS, 	/* 21 BOOT_ROM_CS		*/
+	DEV_BOOCS,	/* 22 DEV_BOOCS			*/
+	PMU_SCRATCHPAD,	/* 23 PMU Scratchpad		*/
+	PNC_BM,		/* 24 PNC + BM 		        */
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR		0x1E
+#define DRAM_CS1_ATTR		0x1D
+#define DRAM_CS2_ATTR		0x1B
+#define DRAM_CS3_ATTR		0x17
+#else
+#define DRAM_CS0_ATTR		0x0E
+#define DRAM_CS1_ATTR		0x0D
+#define DRAM_CS2_ATTR		0x0B
+#define DRAM_CS3_ATTR		0x07
+#endif
+
+#define TARGETS_DEF_ARRAY	{			\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID   },	/*  0 SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID   },	/*  1 SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID   },	/*  2 SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID   },	/*  3 SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID    },		/*  4 DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID    },		/*  5 DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID    },		/*  6 DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID    },		/*  7 DEVICE_CS3 */	\
+	{0xE8, PEX0_TARGET_ID	},		/*  8 PEX0_LANE0_MEM */	\
+	{0xE0, PEX0_TARGET_ID	},		/*  9 PEX0_LANE0_IO */	\
+	{0xFF, 0xFF             },		/* 10 INTER_REGS */	\
+	{0x81, DEV_TARGET_ID    },		/* 11 DFX_INTER_REGS */	\
+	{0x01, DEV_TARGET_ID    },		/* 12 DMA_UART */	\
+	{0x1E, DEV_TARGET_ID    },		/* 13 SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID    },		/* 14 SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID    },		/* 15 SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID    },		/* 16 SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID    },		/* 17 SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID    },		/* 18 SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID    },		/* 19 SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID    },		/* 20 SPI_CS7 */	\
+	{0x1D, DEV_TARGET_ID    },		/* 21 BOOT_ROM_CS (Main Boot device )*/	\
+	{0x2F, DEV_TARGET_ID    },		/* 22 DEV_BOOT_CS (Secondary Boot device,)*/	\
+	{0x2D, DEV_TARGET_ID    },		/* 23 PMU_SCRATCHPAD */	\
+	{0x00, PNC_BM_TARGET_ID },		/* 24 PNC_BM */		\
+}
+
+#define TARGETS_NAME_ARRAY	{			\
+	"SDRAM_CS0",    	/*  0 SDRAM_CS0 */	\
+	"SDRAM_CS1",    	/*  1 SDRAM_CS1 */	\
+	"SDRAM_CS2",    	/*  2 SDRAM_CS1 */	\
+	"SDRAM_CS3",    	/*  3 SDRAM_CS1 */	\
+	"DEVICE_CS0",		/*  4 DEVICE_CS0 */	\
+	"DEVICE_CS1",		/*  5 DEVICE_CS1 */	\
+	"DEVICE_CS2",		/*  6 DEVICE_CS2 */	\
+	"DEVICE_CS3",		/*  7 DEVICE_CS3 */	\
+	"PEX0_MEM",		/*  8 PEX0_MEM */	\
+	"PEX0_IO",		/*  9 PEX0_IO */	\
+	"INTER_REGS",		/* 10 INTER_REGS */	\
+	"DFX_INTER_REGS",	/* 11 INTER_REGS */	\
+	"DMA_UART",		/* 12 DMA_UART */	\
+	"SPI_CS0",		/* 13 SPI_CS0 */	\
+	"SPI_CS1",		/* 14 SPI_CS1 */	\
+	"SPI_CS2",		/* 15 SPI_CS2 */	\
+	"SPI_CS3",		/* 16 SPI_CS3 */	\
+	"SPI_CS4",		/* 17 SPI_CS4 */	\
+	"SPI_CS5",		/* 18 SPI_CS5 */	\
+	"SPI_CS6",		/* 19 SPI_CS6 */	\
+	"SPI_CS7",		/* 20 SPI_CS7 */	\
+	"BOOT_ROM_CS",		/* 21 BOOT_ROM_CS */	\
+	"DEV_BOOTCS",		/* 22 DEV_BOOCS */	\
+	"PMU_SCRATCHPAD",	/* 23 PMU_SCRATCHPAD */	\
+	"PNC_BM"		/* 24 PNC_BM */		\
+}
+
+
+
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.c
new file mode 100644
index 0000000..d71df4e
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.c
@@ -0,0 +1,124 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+
+MV_BOOL mvSemaLock(MV_32 num)
+{
+	MV_U32 tmp;
+	MV_U32 cpuId;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	cpuId = whoAmI();
+	do
+	{
+		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	} while ((tmp & 0xFF) != cpuId);
+	return MV_TRUE;
+}
+
+MV_BOOL mvSemaTryLock(MV_32 num)
+{
+	MV_U32 tmp;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	if ((tmp & 0xFF) != whoAmI())
+	{
+		return MV_FALSE;
+	}
+	else
+		return MV_TRUE;
+}
+
+MV_BOOL mvSemaUnlock(MV_32 num)
+{
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+	return MV_TRUE;
+}
+
+MV_32 mvReadAmpReg(int regId)
+{
+	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+}
+
+MV_32 mvWriteAmpReg(int regId, MV_32 value)
+{
+	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
+}
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
new file mode 100644
index 0000000..a5a94d3
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvSemaphore.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvsemaphore_h
+#define mvsemaphore_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+#define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
+#define ADR_WIN_EN_REG			0
+
+#define MV_SEMA_REG_BASE	(0x20500)
+#define MV_MAX_SEMA 	    	128
+#define MV_SEMA_SMI 		50
+#define MV_SEMA_RTC 		51
+#define MV_SEMA_NOR_FLASH 	0
+#define MV_SEMA_BOOT 		1
+#define MV_SEMA_PEX0 		2
+#define MV_SEMA_BRIDGE 		3
+#define MV_SEMA_IRQ 		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_L2		6
+#define MV_SEMA_TWSI		7
+#define MV_SEMA_ADR_WIN		8
+
+#define MV_SEMA_BARRIER(cpu)	(50 + cpu)
+
+
+MV_BOOL mvSemaLock(MV_32 num);
+MV_BOOL mvSemaTryLock(MV_32 num);
+MV_BOOL mvSemaUnlock(MV_32 num);
+MV_32   mvReadAmpReg(int regId);
+MV_32 	mvWriteAmpReg(int regId, MV_32 value);
+
+/* Turn on HW semapores only if AMP is enabled */
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock
+#define mvSemaTryLock
+#define mvSemaUnlock
+#define mvHwBarrier
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvsemaphore_h */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
new file mode 100644
index 0000000..0321d7b
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvUnitMap.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvUnitMap_h
+#define mvUnitMap_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+typedef enum
+{
+	UART0=0,
+	UART1,
+	PEX0,
+	PEX1,
+	PEX2,
+	PEX3,
+	ETH0,
+	ETH1,
+	ETH2,
+	ETH3,
+	XOR0,
+	XOR1,
+	USB0,
+	USB1,
+	USB2,
+	I2C0,
+	I2C1,
+	SATA,
+	CESA,
+	NOR,
+	NAND,
+	SPI,
+	TDM,
+	SDIO,
+	LCD,
+	HWMON,
+	RTC,
+	GPIO,
+	MSTR,
+	MAX_UNITS
+} MV_SOC_UNIT;
+
+/* binary flags for mvSocUnitMapFillTableFormBitMap */
+/*#define UART0_T0_CPU1	0x0001
+#define UART1_TO_CPU1	0x0002
+#define PEX0_TO_CPU1	0x0004
+#define PEX1_TO_CPU1	0x0008
+#define GIGA0_TO_CPU1	0x0010
+#define GIGA1_TO_CPU1	0x0020
+#define GIGA2_TO_CPU1	0x0040
+#define GIGA3_TO_CPU1	0x0080
+#define SATA_TO_CPU1	0x0100
+#define XOR_TO_CPU1		0x0200
+#define IDMA_TO_CPU1	0x0400
+#define USB0_TO_CPU1	0x0800
+#define USB1_TO_CPU1    0x1000
+#define USB2_TO_CPU1    0x2000
+#define CESA_TO_CPU1	0x4000
+#define NOR_TO_CPU1		0x8000
+#define NAND_TO_CPU1	0x10000
+#define SPI_TO_CPU1		0x20000
+#define TDM_TO_CPU1		0x40000
+
+#define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
+
+typedef struct __MV_RES_MAP
+{
+	int	isMine;
+	char*	unitName;
+} MV_RES_MAP;
+
+typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapIsPexMine(int pciIf);
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
+MV_VOID mvUnitMapSetAllMine(void);
+MV_VOID mvUnitMapPrint(void);
+MV_BOOL mvUnitMapIsRsrcLimited(void);
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
+#else /* CONFIG_MV_AMP_ENABLE */
+#define mvUnitMapIsMine(rsrc) 		MV_TRUE
+#define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
+#define mvUnitMapIsRsrcLimited 	  	MV_TRUE
+#define mvUnitMapSetRsrcLimited(limit)
+#define mvUnitMapSetMine(rsrc)
+#define mvUnitMapSetAllMine
+#define mvUnitMapPrint
+#define mvUnitMapSetup(str, strstr_func) MV_TRUE
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
new file mode 100644
index 0000000..1cc1aa3
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -0,0 +1,750 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvCpuIfRegs.h"
+
+#undef MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* typedefs */
+
+/* CPU address remap registers offsets are inconsecutive. This struct		*/
+/* describes address remap register offsets					*/
+typedef struct _ahbToMbusRemapRegOffs {
+	MV_U32 lowRegOffs;	/* Low 32-bit remap register offset             */
+	MV_U32 highRegOffs;	/* High 32 bit remap register offset            */
+} AHB_TO_MBUS_REMAP_REG_OFFS;
+
+/* locals   */
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs);
+
+/*******************************************************************************
+* mvAhbToMbusInit - Initialize Ahb To Mbus Address Map !
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK laways.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusInit(void)
+{
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinSet - Set CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*       This function sets
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified winNum address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the winNum window, allowing CPU to access
+*       the winNum window.
+*
+* INPUT:
+*       winNum      - Windows number.
+*       pAddrDecWin - CPU winNum window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU winNum window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU winNum window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the winNum is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 sizeToReg;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinSet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvAhbToMbusWinSet:Error setting AHB to MBUS window %d to "
+			   "target %s.\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			   winNum,
+			   mvCtrlTargetNameGet(pAddrDecWin->target),
+			   pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	/* Size parameter validity check.                       */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.size, ATMWCR_WIN_SIZE_ALIGNMENT)) {
+		mvOsPrintf("mvAhbToMbusWinSet: Failed, size not aligned to 0x%x.\n", ATMWCR_WIN_SIZE_ALIGNMENT);
+		return MV_BAD_PARAM;
+	}
+
+	/* Write to address decode Base Address Register        */
+	decRegs.baseReg = (pAddrDecWin->addrWin.baseLow & ATMWBR_BASE_MASK);
+
+	/* Get size register value according to window size     */
+	sizeToReg = (pAddrDecWin->addrWin.size / ATMWCR_WIN_SIZE_ALIGNMENT) - 1;
+
+	/* set size                                             */
+	decRegs.ctrlReg = (sizeToReg << ATMWCR_WIN_SIZE_OFFS);
+
+	/* enable\Disable */
+	if (MV_TRUE == pAddrDecWin->enable)
+		decRegs.ctrlReg |= ATMWCR_WIN_ENABLE;
+	else
+		decRegs.ctrlReg &= ~ATMWCR_WIN_ENABLE;
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* set attributes */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_ATTR_MASK;
+	decRegs.ctrlReg |= targetAttribs.attrib << ATMWCR_WIN_ATTR_OFFS;
+	/* set target ID */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_TARGET_MASK;
+	decRegs.ctrlReg |= targetAttribs.targetId << ATMWCR_WIN_TARGET_OFFS;
+
+#if !defined(MV_RUN_FROM_FLASH)
+	/* To be on the safe side we disable the window before writing the  */
+	/* new values.                                                      */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		mvAhbToMbusWinEnable(winNum, MV_FALSE);
+#endif
+
+	/* 3) Write to address decode Base Address Register                   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), decRegs.baseReg);
+	else
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
+
+
+	/* Internal register space have no size */
+	/* register. Do not perform size register assigment for those targets   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
+		/* Write to address decode Size Register                                */
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), decRegs.ctrlReg);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinGet - Get CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral winNum address window.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU winNum window information data structure.
+*
+* RETURN:
+*       MV_OK if winNum exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_U32 sizeRegVal;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal register space size have no size register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+	else
+		decRegs.ctrlReg = 0;
+
+	/* Read base and size   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	else
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_INTEREG_REG);
+
+	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseLow = decRegs.baseReg & ATMWBR_BASE_MASK;
+	sizeRegVal = (decRegs.ctrlReg & ATMWCR_WIN_SIZE_MASK) >> ATMWCR_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * ATMWCR_WIN_SIZE_ALIGNMENT;
+
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN) {
+		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
+		pAddrDecWin->target = INTER_REGS;
+		pAddrDecWin->enable = MV_TRUE;
+
+		return MV_OK;
+	}
+
+	if (decRegs.ctrlReg & ATMWCR_WIN_ENABLE)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	if (-1 == pAddrDecWin->addrWin.size)
+		return MV_ERROR;
+
+	/* attrib and targetId */
+	targetAttrib.attrib = (decRegs.ctrlReg & ATMWCR_WIN_ATTR_MASK) >> ATMWCR_WIN_ATTR_OFFS;
+	targetAttrib.targetId = (decRegs.ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetGet - Get Window number associated with target
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	if (INTER_REGS == target)
+		return MV_AHB_TO_MBUS_INTREG_WIN;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_TRUE) {
+			if (decWin.target == target)
+				return winNum;
+		}
+	}
+
+	return 0xFFFFFFFF;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinAvailGet - Get First Available window number.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinAvailGet(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_FALSE)
+			return winNum;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other winNum window.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinEnable: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal registers bar can't be disable or enabled */
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+		return (enable ? MV_OK : MV_ERROR);
+
+
+	if (enable == MV_TRUE) {
+		/* enable the window */
+		MV_REG_BIT_SET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	} else {
+		/* Disable address decode winNum window                             */
+		MV_REG_BIT_RESET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*       After a CPU address hits one of PCI address decode windows there is an
+*       option to remap the address to a different one. For example, CPU
+*       executes a read from PCI winNum window address 0x1200.0000. This
+*       can be modified so the address on the PCI bus would be 0x1400.0000
+*       Using the PCI address remap mechanism.
+*
+* INPUT:
+*       winNum      - Peripheral winNum enumerator. Must be a PCI winNum.
+*       pAddrDecWin - CPU winNum window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if winNum is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddr;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegOffs;
+	MV_U32 effectiveBaseAddress = 0, baseAddrValue = 0, windowSizeValue = 0;
+
+	/* Get registers offsets of given winNum                */
+	if (MV_NO_SUCH == ahbToMbusRemapRegOffsGet(winNum, &remapRegOffs))
+		return 0xffffffff;
+
+	/* 1) Set address remap low */
+	baseAddr = pAddrWin->baseLow;
+
+	/* Check base address aligment                                  */
+	/*
+	   if (MV_IS_NOT_ALIGN(baseAddr, ATMWRLR_REMAP_LOW_ALIGNMENT))
+	   {
+	   mvOsPrintf("mvAhbToMbusPciRemap: Warning. Target base 0x%x unaligned\n",
+	   baseAddr);
+	   return MV_ERROR;
+	   }
+	 */
+
+	/* BaseLow[31:16] => base register [31:16]              */
+	baseAddr = baseAddr & ATMWRLR_REMAP_LOW_MASK;
+
+	MV_REG_WRITE(remapRegOffs.lowRegOffs, baseAddr);
+	MV_REG_WRITE(remapRegOffs.highRegOffs, pAddrWin->baseHigh);
+
+	baseAddrValue = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	windowSizeValue = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+
+	baseAddrValue &= ATMWBR_BASE_MASK;
+	windowSizeValue &= ATMWCR_WIN_SIZE_MASK;
+
+	/* Start calculating the effective Base Address */
+	effectiveBaseAddress = baseAddrValue;
+
+	/* The effective base address will be combined from the chopped (if any)
+	   remap value (according to the size value and remap mechanism) and the
+	   window's base address */
+	effectiveBaseAddress |= (((windowSizeValue) | 0xffff) & pAddrWin->baseLow);
+	/* If the effectiveBaseAddress exceed the window boundaries return an
+	   invalid value. */
+
+	if (effectiveBaseAddress > (baseAddrValue + (windowSizeValue | 0xffff))) {
+		mvOsPrintf("mvAhbToMbusPciRemap: Error\n");
+		return 0xffffffff;
+	}
+
+	return effectiveBaseAddress;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetSwap - Swap AhbToMbus windows between targets
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       target1      - CPU Interface target 1
+*       target2      - CPU Interface target 2
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if targets are illigal, or if one of the targets is not
+*	    associated to a valid window .
+*       MV_OK otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2)
+{
+	MV_U32 winNum1, winNum2;
+	MV_AHB_TO_MBUS_DEC_WIN winDec1, winDec2, winDecTemp;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegs1, remapRegs2;
+	MV_U32 remapBaseLow1 = 0, remapBaseLow2 = 0;
+	MV_U32 remapBaseHigh1 = 0, remapBaseHigh2 = 0;
+
+	/* Check parameters */
+	if (target1 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	if (target2 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum1 = mvAhbToMbusWinTargetGet(target1);
+
+	if (winNum1 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target1, winNum1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum2 = mvAhbToMbusWinTargetGet(target2);
+	if (winNum2 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target2, winNum2);
+		return MV_ERROR;
+	}
+
+	/* now Get original values of both Windows */
+	if (MV_OK != mvAhbToMbusWinGet(winNum1, &winDec1)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinGet(winNum2, &winDec2)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* disable both windows */
+	if (MV_OK != mvAhbToMbusWinEnable(winNum1, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable window %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinEnable(winNum2, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable windo %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* now swap targets */
+
+	/* first save winDec2 values */
+	winDecTemp.addrWin.baseHigh = winDec2.addrWin.baseHigh;
+	winDecTemp.addrWin.baseLow = winDec2.addrWin.baseLow;
+	winDecTemp.addrWin.size = winDec2.addrWin.size;
+	winDecTemp.enable = winDec2.enable;
+	winDecTemp.target = winDec2.target;
+
+	/* winDec2 = winDec1 */
+	winDec2.addrWin.baseHigh = winDec1.addrWin.baseHigh;
+	winDec2.addrWin.baseLow = winDec1.addrWin.baseLow;
+	winDec2.addrWin.size = winDec1.addrWin.size;
+	winDec2.enable = winDec1.enable;
+	winDec2.target = winDec1.target;
+
+	/* winDec1 = winDecTemp */
+	winDec1.addrWin.baseHigh = winDecTemp.addrWin.baseHigh;
+	winDec1.addrWin.baseLow = winDecTemp.addrWin.baseLow;
+	winDec1.addrWin.size = winDecTemp.addrWin.size;
+	winDec1.enable = winDecTemp.enable;
+	winDec1.target = winDecTemp.target;
+
+	/* now set the new values */
+	mvAhbToMbusWinSet(winNum1, &winDec1);
+	mvAhbToMbusWinSet(winNum2, &winDec2);
+
+	/* now we will treat the remap windows if exist */
+
+	/* now check if one or both windows has a remap window
+	   as well after the swap ! */
+
+	/* if a window had a remap value differnt than the base value
+	   before the swap , then after the swap the remap value will be
+	   equal to the base value unless both windows has a remap windows */
+
+	/* first get old values */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		remapBaseLow1 = MV_REG_READ(remapRegs1.lowRegOffs);
+		remapBaseHigh1 = MV_REG_READ(remapRegs1.highRegOffs);
+	}
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		remapBaseLow2 = MV_REG_READ(remapRegs2.lowRegOffs);
+		remapBaseHigh2 = MV_REG_READ(remapRegs2.highRegOffs);
+	}
+
+	/* now do the swap */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+			/* Two windows has a remap !!! so swap */
+
+			MV_REG_WRITE(remapRegs2.highRegOffs, remapBaseHigh1);
+			MV_REG_WRITE(remapRegs2.lowRegOffs, remapBaseLow1);
+
+			MV_REG_WRITE(remapRegs1.highRegOffs, remapBaseHigh2);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, remapBaseLow2);
+		} else {
+			/* remap == base */
+			MV_REG_WRITE(remapRegs1.highRegOffs, winDec1.addrWin.baseHigh);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, winDec1.addrWin.baseLow);
+		}
+	} else if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		/* remap == base */
+		MV_REG_WRITE(remapRegs2.highRegOffs, winDec2.addrWin.baseHigh);
+		MV_REG_WRITE(remapRegs2.lowRegOffs, winDec2.addrWin.baseLow);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ahbToMbusRemapRegOffsGet - Get CPU address remap register offsets
+*
+* DESCRIPTION:
+* 		CPU to PCI address remap registers offsets are inconsecutive.
+*		This function returns PCI address remap registers offsets.
+*
+* INPUT:
+*       winNum - Address decode window number. See MV_U32 enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*		MV_ERROR if winNum is not a PCI one.
+*
+*******************************************************************************/
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs)
+{
+	switch (winNum) {
+	case 0:
+	case 1:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 2:
+	case 3:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	default:
+		pRemapRegs->lowRegOffs = 0;
+		pRemapRegs->highRegOffs = 0;
+
+		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		return MV_NO_SUCH;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusAddDecShow - Print the AHB to MBus bridge address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN win;
+	MV_U32 winNum;
+	mvOsOutput("\n");
+	mvOsOutput("AHB To MBUS Bridge:\n");
+	mvOsOutput("-------------------\n");
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		memset(&win, 0, sizeof(MV_AHB_TO_MBUS_DEC_WIN));
+
+		mvOsOutput("win%d - ", winNum);
+
+		if (mvAhbToMbusWinGet(winNum, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("%s base %08x, ", mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+				mvOsOutput("....");
+				mvSizePrint(win.addrWin.size);
+
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		}
+	}
+}
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.h
new file mode 100644
index 0000000..f91ee59
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -0,0 +1,96 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbush
+#define __INCmvAhbToMbush
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* defines  */
+
+typedef struct _mvAhbtoMbusDecWin {
+	MV_TARGET	target;
+	MV_ADDR_WIN	addrWin;    /* An address window*/
+	MV_BOOL		enable;     /* Address decode window is enabled/disabled    */
+
+} MV_AHB_TO_MBUS_DEC_WIN;
+
+/* mvAhbToMbus.h API list */
+
+MV_STATUS mvAhbToMbusInit(MV_VOID);
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
+MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
+MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
+
+MV_VOID   mvAhbToMbusAddDecShow(MV_VOID);
+
+#endif /* __INCmvAhbToMbush */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbusRegs.h
new file mode 100644
index 0000000..a4a2c62
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -0,0 +1,143 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbusRegsh
+#define __INCmvAhbToMbusRegsh
+
+#define MAX_AHB_TO_MBUS_WINS			21
+#define MAX_AHB_TO_MBUS_REMAP_WINS		8
+#define MV_AHB_TO_MBUS_INTREG_WIN		20
+
+/***********************/
+/* AHB TO MBUS WINDOWS */
+/***********************/
+/* Window-X Control Registers */
+#define AHB_TO_MBUS_WIN_CTRL_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + winNum * 0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x90 + (winNum-8)*0x08))
+#define ATMWCR_WIN_ENABLE			BIT0
+#define ATMWCR_WIN_TARGET_OFFS			4
+#define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
+#define ATMWCR_WIN_ATTR_OFFS			8
+#define ATMWCR_WIN_ATTR_MASK			(0xff << ATMWCR_WIN_ATTR_OFFS)
+#define ATMWCR_WIN_SIZE_OFFS			16
+#define ATMWCR_WIN_SIZE_MASK			(0xffff << ATMWCR_WIN_SIZE_OFFS)
+#define ATMWCR_WIN_SIZE_ALIGNMENT		0x10000
+
+/* Window-X Base Register */
+#define AHB_TO_MBUS_WIN_BASE_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x4 + winNum*0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x94 + (winNum-8)*0x08))
+#define ATMWBR_BASE_OFFS			16
+#define ATMWBR_BASE_MASK			(0xffff << 	ATMWBR_BASE_OFFS)
+#define ATMWBR_BASE_ALIGNMENT			0x10000
+
+/* Window-X Remap Low Register */
+#define AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x8 + winNum*0x10) : \
+						 (0))
+#define ATMWRLR_REMAP_LOW_OFFS			16
+#define ATMWRLR_REMAP_LOW_MASK			(0xffff << ATMWRLR_REMAP_LOW_OFFS)
+#define ATMWRLR_REMAP_LOW_ALIGNMENT		0x10000
+
+/* Window-X Remap Hi Register */
+#define AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0xC + winNum*0x10) : \
+						 (0))
+#define ATMWRHR_REMAP_HIGH_OFFS			0
+#define ATMWRHR_REMAP_HIGH_MASK			(0xffffffff << ATMWRHR_REMAP_HIGH_OFFS)
+
+/*****************************/
+/* INTERNAL REGISTERS WINDOW */
+/*****************************/
+/* Internal Registers Base Address in set to be window 20 */
+#define AHB_TO_MBUS_WIN_INTEREG_REG		(MV_MBUS_REGS_OFFSET + 0x80)
+
+/************************/
+/* SDRAM DECODE WINDOWS */
+/************************/
+/* All DRAM Window definitions are declared under the ddr2_3 HAL */
+
+/****************************/
+/* SRAM (L2) DECODE WINDOWS */
+/****************************/
+#define SRAM_WIN_CTRL_REG(winNum)		(MV_MBUS_REGS_OFFSET + 0x240 + winNum * 0x4)
+#define SRAMWCR_ENABLE				BIT0
+#define SRAMWCR_SIZE_OFFS			8
+#define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
+#define SRAMWCR_BASE_OFFS			16
+#define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+#define SRAMWCR_MAX_WIN_WAYS			8
+
+/**********************/
+/* MBUS BRIDGE WINDOW */
+/**********************/
+#define MBUS_BRIDGE_WIN_CTRL_REG		(MV_MBUS_REGS_OFFSET + 0x250)
+#define BRIDGWCR_ENABLE				BIT0
+#define BRIDGWCR_SIZE_OFFS			16
+#define BRIDGWCR_SIZE_MASK			(0xFFFF << BRIDGWCR_SIZE_OFFS)
+#define MBUS_BRIDGE_WIN_BASE_REG		(MV_MBUS_REGS_OFFSET + 0x254)
+
+#endif /* __INCmvAhbToMbusRegsh */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
new file mode 100644
index 0000000..c2da768
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.c
@@ -0,0 +1,946 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+/*#include "cpu/mvCpu.h" *//* whoAmI() */
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "ddr2_3/mvDramIf.h"
+#include "ddr2_3/mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+
+/*#define MV_DEBUG*/
+/* defines  */
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals   */
+/* static functions */
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
+
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+	MV_32 diff;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		if(win.enable == cpuAddrWinMap->enable)
+		{
+			if(win.enable)
+			{
+				diff  = (win.addrWin.baseLow  - cpuAddrWinMap->addrWin.baseLow);
+				diff |= (win.addrWin.baseHigh - cpuAddrWinMap->addrWin.baseHigh);
+				diff |= (win.addrWin.size     - cpuAddrWinMap->addrWin.size);
+				/*TODO - Need to compare the window attributes as well */
+
+				if(diff)
+				{
+					mvOsOutput("mvCpuIfVerify: Mismatched window size in target %d\n", target);
+					return MV_ERROR;
+				}
+			}
+		}
+		else
+		{
+			mvOsOutput("mvCpuIfVerify: Mismatched enable field in target %d\n", target);
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCpuIfInitForCpu - Initialize Controller CPU interface
+*
+* DESCRIPTION:
+*       This function initialize Controller CPU interface:
+*       1. Set CPU interface configuration registers.
+*       2. Set CPU master Pizza arbiter control according to static
+*          configuration described in configuration file.
+*       3. Opens CPU address decode windows. DRAM windows are assumed to be
+*		   already set (auto detection).
+*
+* INPUT:
+*       cpu      	- CPU id.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_U32 regVal, i;
+	MV_TARGET target;
+	MV_ADDR_WIN addrWin;
+	MV_U32 minBase = 0xFFFFFFFF;
+	MV_U32 minSize;
+
+	if (cpuAddrWinMap == NULL) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. cpuAddrWinMap == NULL\n"));
+		return MV_ERROR;
+	}
+
+	/* Set IO Bypass base address and size according to the cpuAddrWinMap */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (DIS == cpuAddrWinMap[target].enable) ||
+		    (target == INTER_REGS))
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow == 0)
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow < minBase)
+			minBase = cpuAddrWinMap[target].addrWin.baseLow;
+	}
+	if (minBase != 0x0) {
+		minSize = 0xFFFFFFFF - minBase + 1;
+		if (!MV_IS_POWER_OF_2(minSize)) {
+			/* Round up to next power of 2. */
+			minSize = (1 << (mvLog2(minSize) + 1));
+			minBase = 0xFFFFFFFF - minSize + 1;
+		}
+
+		/* Now write the base and size */
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_BASE_REG, minBase);
+		/* Align window size to 64KB */
+		regVal = (minSize / SDRAMWBR_BASE_ALIGNMENT) - 1;
+		regVal = (regVal << 16) | 0x1;
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_CTRL_REG, regVal);
+	}
+
+	/* Set CPU Configuration register */
+	regVal = MV_REG_READ(CPU_CONFIG_REG(cpu));
+	regVal &= ~CPU_CONFIG_DEFAULT_MASK;
+	regVal |= CPU_CONFIG_DEFAULT;
+	MV_REG_WRITE(CPU_CONFIG_REG(cpu), regVal);
+
+	for (i = 0; i < MAX_AHB_TO_MBUS_WINS-2; i++)
+		mvAhbToMbusWinEnable(i, MV_FALSE);
+
+	/* First disable all CPU target windows  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
+			continue;
+#ifdef CONFIG_MV_AMP_ENABLE
+		if(target == BOOT_ROM_CS)
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+#if defined(MV_RUN_FROM_FLASH)
+		/* Don't disable the boot device.                               */
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+		mvCpuIfTargetWinEnable(MV_CHANGE_BOOT_CS(target), MV_FALSE);
+	}
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
+	target = DEV_BOOCS;
+
+	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+		return MV_ERROR;
+	}
+
+	addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+	addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+	if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+		DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+			      cpuAddrWinMap[target].winNum));
+	}
+#endif /* MV_RUN_FROM_FLASH */
+
+	/* Go through all targets in user table until table terminator                  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+
+#if defined(MV_RUN_FROM_FLASH)
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+
+		/* if DRAM auto sizing is used do not initialized DRAM target windows,  */
+		/* assuming this already has been done earlier.                         */
+#ifdef	MV_DRAM_AUTO_SIZE
+		if (MV_TARGET_IS_DRAM(target))
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		else {
+			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+				return MV_ERROR;
+			}
+			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+				DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+					      cpuAddrWinMap[target].winNum));
+			}
+		}
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	return mvCpuIfInitForCpu(whoAmI(), cpuAddrWinMap);
+}
+
+
+/*******************************************************************************
+* mvCpuIfDramInit - Initialize Controller DRAM Fastpath windows
+*
+* DESCRIPTION:
+*       This function initialize Controller DRAM Fastpath windows
+*		It takes the CS size information from the 0x1500 scratch registers
+*		and sets the correct windows sizes and base addresses accordingly
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfDramInit()
+{
+	MV_U64 base = 0;
+	MV_U32 size, cs, temp;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+/*		if (size > 0 && base < SDRAM_MAX_ADDR) { */
+		if (size != 0) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Set Base Address */
+			temp = (base & 0xFF000000ll) | ((base >> 32) & 0xF);
+			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
+
+			/* Check if out of max window size and resize the window */
+#if 0
+			if (base+size > SDRAM_MAX_ADDR) {
+				size = SDRAM_MAX_ADDR - base - 1;
+				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
+			}
+#endif
+			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
+			temp |= (size & SDRAM_ADDR_MASK);
+
+			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
+			base += ((MV_U64)size + 1);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSet - Set CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI0_MEM0)
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing CPU to access
+*       the target window.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - CPU target window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU target window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU target window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the target is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 existingWinNum;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		/* copy relevant data to MV_DRAM_DEC_WIN structure */
+		addrDecWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		addrDecWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		addrDecWin.addrWin.size = pAddrDecWin->addrWin.size;
+		addrDecWin.enable = pAddrDecWin->enable;
+
+		if (mvDramIfWinSet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvDramIfWinSet Failed\n");
+			return MV_ERROR;
+		}
+	} else {
+		/* copy relevant data to MV_AHB_TO_MBUS_DEC_WIN structure */
+		decWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		decWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		decWin.addrWin.size = pAddrDecWin->addrWin.size;
+		decWin.enable = pAddrDecWin->enable;
+		decWin.target = target;
+
+		existingWinNum = mvAhbToMbusWinTargetGet(target);
+
+		/* check if there is already another Window configured
+		   for this target */
+		if ((existingWinNum < MAX_AHB_TO_MBUS_WINS) && (existingWinNum != pAddrDecWin->winNum)) {
+			/* if we want to enable the new window number
+			   passed by the user , then the old one should
+			   be disabled */
+			if (MV_TRUE == pAddrDecWin->enable) {
+				/* be sure it is disabled */
+				mvAhbToMbusWinEnable(existingWinNum, MV_FALSE);
+			}
+		}
+
+		if (mvAhbToMbusWinSet(pAddrDecWin->winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvAhbToMbusWinSet Failed\n");
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinGet - Get CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral target address window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU target window information data structure.
+*
+* RETURN:
+*       MV_OK if target exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_U32 winNum = 0xffffffff;
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinGet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinGet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to get window target %d\n", target);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = addrDecWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = (MV_U64)addrDecWin.addrWin.size;
+		pAddrDecWin->enable = addrDecWin.enable;
+		pAddrDecWin->winNum = target;
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return MV_NO_SUCH;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: mvAhbToMbusWinGet Failed at winNum = %d\n", __func__, winNum);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = decWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = decWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = decWin.addrWin.size;
+		pAddrDecWin->enable = decWin.enable;
+		pAddrDecWin->winNum = winNum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       target - Peripheral target enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other target window.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable)
+{
+	MV_U32 winNum, temp;
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinEnable: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* get the window and check if it exist */
+	temp = mvCpuIfTargetWinGet(target, &addrDecWin);
+	if (MV_NO_SUCH == temp) {
+		return (enable ? MV_ERROR : MV_OK);
+	} else if (MV_OK != temp) {
+		mvOsPrintf("%s: ERR. Getting target %d failed.\n", __func__, target);
+		return MV_ERROR;
+	}
+
+	/* check overlap */
+	if (MV_TRUE == enable) {
+		if (MV_TRUE == cpuTargetWinOverlap(target, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("%s: ERR. Target %d overlap\n", __func__, target));
+			return MV_ERROR;
+		}
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinEnable(target, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: mvDramIfWinEnable Failed at \n");
+			return MV_ERROR;
+		}
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return (enable ? MV_ERROR : MV_OK);
+
+		if (mvAhbToMbusWinEnable(winNum, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to enable window = %d\n", winNum);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSizeGet - Get CPU target address window size
+*
+* DESCRIPTION:
+*		Get the size of CPU-to-peripheral target window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit size. Function also returns '0' if window is closed.
+*		Function returns 0xFFFFFFFF in case of an error.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinSizeGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet: target %d is illegal\n", target);
+		return 0;
+	}
+
+	/* Get the winNum window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet:ERR. Getting target %d failed.\n", target);
+		return 0;
+	}
+
+	/* Check if window is enabled   */
+	if (addrDecWin.enable == MV_TRUE)
+		return (addrDecWin.addrWin.size);
+	else
+		return 0;	/* Window disabled. return 0 */
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseLowGet - Get CPU target address window base low
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target low base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit low base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseLowGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0xffffffff;
+
+	return (addrDecWin.addrWin.baseLow);
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseHighGet - Get CPU target address window base high
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target high base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit high base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseHighGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseHighGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0;
+
+	return (addrDecWin.addrWin.baseHigh);
+}
+
+
+/*******************************************************************************
+* mvCpuIfSramWinDisable
+*
+* DESCRIPTION:
+*	Disable the SRAM windows.
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID)
+{
+	MV_U32 i;
+
+	for (i = 0; i < 4; i++)
+		MV_REG_WRITE(SRAM_WIN_CTRL_REG(i), SRAM_WIN_CTRL_DEFAULT_VAL);
+
+	return MV_OK;
+}
+
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfPexRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pexTarget   - Peripheral target enumerator. Must be a PEX target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PEX one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (!MV_TARGET_IS_PEX0(pexTarget)) {
+		mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+		return 0xffffffff;
+	}
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pexTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCpuIfPciRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pciTarget   - Peripheral target enumerator. Must be a PCI target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPciRemap(MV_TARGET pciIfTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pciIfTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+/*******************************************************************************
+* mvCpuIfTargetOfBaseAddressGet - Get the target according to base address
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       baseAddress -  base address to be checked
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the target number that baseAddress belongs to or MAX_TARGETS is not
+*       found
+*
+*******************************************************************************/
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				if ((baseAddress >= win.addrWin.baseLow) &&
+				    (baseAddress < win.addrWin.baseLow + win.addrWin.size))
+					break;
+			}
+		} else
+			return MAX_TARGETS;
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* cpuTargetWinOverlap - Detect CPU address decode windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case CPU address decode
+*       windows overlapps.
+*       This function detects CPU address decode windows overlapping of a
+*       specified target. The function does not check the target itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlaps current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 targetNum;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_STATUS status;
+
+	for (targetNum = 0; targetNum < MAX_TARGETS; targetNum++) {
+		/* don't check our target or illegal targets */
+		if (targetNum == target)
+			continue;
+
+		/* Get window parameters        */
+		status = mvCpuIfTargetWinGet(targetNum, &addrDecWin);
+		if (MV_NO_SUCH == status)
+			continue;
+
+		if (MV_OK != status) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: ERR. TargetWinGet failed\n"));
+			return MV_TRUE;
+		}
+
+		/* Do not check disabled windows        */
+		if (MV_FALSE == addrDecWin.enable)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: Required target %d overlap current %d\n",
+				      target, targetNum));
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCpuIfAddDecShow - Print the CPU address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfAddDecShow(MV_VOID)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	mvOsOutput("\n");
+	mvOsOutput("CPU Interface\n");
+	mvOsOutput("-------------\n");
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		mvOsOutput("%s ", mvCtrlTargetNameGet(target));
+		mvOsOutput("....");
+
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("base %01x%08x, ", win.addrWin.baseHigh, win.addrWin.baseLow);
+				mvSizePrint(win.addrWin.size);
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		} else if (mvCpuIfTargetWinGet(target, &win) == MV_NO_SUCH) {
+			mvOsOutput("no such\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCpuIfLvdsPadsEnable
+*
+* DESCRIPTION:
+*	Enable / Disable the LVDS pads.
+*
+* INPUT:
+*	enable - MV_TRUE to enable the pads, MV_FALSE to disable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable)
+{
+	MV_U32 reg;
+	MV_U32 i;
+
+	reg = MV_REG_READ(LVDS_PADS_CTRL_REG);
+
+	for (i = 0; i < 5; i++) {
+		reg &= ~LVDS_PADS_CONF_PD_MASK(i);
+		reg |= LVDS_PADS_CONF_PD_EN(i, enable);
+	}
+
+	MV_REG_WRITE(LVDS_PADS_CTRL_REG, reg);
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.h b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.h
new file mode 100644
index 0000000..f5ed71f
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIf.h
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfInit.S b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..655d01b
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvCommon.h"
+#include "mvOsAsm.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+	mov     r11, LR     		/* Save link register */
+	b       done
+#if 0
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+	/* goto calcConfigReg if device is 6281/6282 */
+	ldr     r5, =MV88F6281_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* goto calcConfigReg if device is 6192/6190 */
+	ldr     r5, =MV88F6192_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* Else 6180 */
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_CPUCLCK_MASK_6180
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3_1
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4_1
+	beq    setConfigReg
+	b    setConfigReg
+
+calcConfigReg:
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4
+	beq    setConfigReg
+
+	/* Else */
+	ldr    r4, =0
+
+setConfigReg:
+	/* Read CPU Config register */
+	MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+	ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+	and    r7, r7, r5       /* Clear register fields */
+	orr    r7, r7, r4       /* Set the values according to the findings */
+	MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+#endif
+
+done:
+	mov     PC, r11         /* r11 is saved link register */
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
new file mode 100644
index 0000000..b721a00
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -0,0 +1,356 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE		(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
+#define CPU_RESET_REG(cpu)			(MV_CPUIF_SHARED_REGS_BASE + (0x800+(cpu)*8))
+#define CPU_RESUME_CTRL_REG			(MV_CPUIF_SHARED_REGS_BASE + (0x988))
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define CPU_L2_BLOCK_ALLOCATION_REG             (MV_L2C_REGS_BASE + 0x78c)
+#define CPU_L2_DATA_LOCKDOWN_REG(cpu)           (MV_L2C_REGS_BASE + 0x900 + (cpu)*0x8)
+#define CPU_L2_INSTRUCTION_LOCKDOWN_REG(cpu)    (MV_L2C_REGS_BASE + 0x904 + (cpu)*0x8)
+#define CPU_IO_BRIDGE_LOCKDOWN_REG              (MV_L2C_REGS_BASE + 0x984)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CFU_CFG_REG                                (MV_COHERENCY_FABRIC_REGS_BASE + 0x28)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+#define CFU_CFG_REG				(MV_COHERENCY_FABRIC_REGS_BASE + 0x28)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
+#define CL2_DUAL_EVICTION		(0x1 << 4)
+#define CL2_PARITY_ENABLE		(0x1 << 21)
+#define CL2_InvalEvicLineUCErr          (0x1 << 22)
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)			(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)			(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_IRQ_OFFS		28
+#define CPU_INT_SOURCE_CONTROL_IRQ_MASK		(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS )
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG	(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+#define CPU_SNOOP_FILTER_CTRL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x20)
+
+#define MV_IRQ_NR							116
+
+
+/*******************************************/
+/* ARM Doorbell Registers Map		   */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ						(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG					(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+
+#endif /* __INCmvCpuIfRegsh */
diff --git a/arch/arm/mach-msys/msys_family/device/mvDevice.c b/arch/arm/mach-msys/msys_family/device/mvDevice.c
new file mode 100644
index 0000000..74c7f27
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/device/mvDevice.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "device/mvDevice.h"
+
+/* defines  */
+#ifdef DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvDevPramSet - Set device interface bank parameters
+*
+* DESCRIPTION:
+*       This function sets a device bank parameters to a given device.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*       *pDevParams - Device bank parameter struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+	if (pDevParams->turnOff > MAX_DBP_TURNOFF) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->turnOff out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2First > MAX_DBP_ACC2FIRST) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2First out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2Next > MAX_DBP_ACC2NEXT) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2Next out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->ale2Wr > MAX_DBP_ALE2WR) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrLow > MAX_DBP_WRLOW) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrHigh > MAX_DBP_WRHIGH) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->badrSkew << DBP_BADRSKEW_OFFS) > DBP_BADRSKEW_2CYCLE) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->badrSkew out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->deviceWidth != 8) && (pDevParams->deviceWidth != 16) && (pDevParams->deviceWidth != 32)) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth out of range\n"));
+		return MV_ERROR;
+	}
+
+	/* devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device)); */
+	/* setting values */
+	devParam |= DBP_TURNOFF_SET(pDevParams->turnOff);
+	devParam |= DBP_ACC2FIRST_SET(pDevParams->acc2First);
+	devParam |= DBP_ACC2NEXT_SET(pDevParams->acc2Next);
+	devParam |= ((pDevParams->badrSkew & DBP_BADRSKEW_MASK) << DBP_BADRSKEW_OFFS);
+
+	switch (pDevParams->deviceWidth) {
+	case 8:
+		devParam |= DBP_DEVWIDTH_8BIT;
+		break;
+	case 16:
+		devParam |= DBP_DEVWIDTH_16BIT;
+		break;
+	case 32:
+		devParam |= DBP_DEVWIDTH_32BIT;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	MV_REG_WRITE(DEV_BANK_PARAM_REG(device), devParam);
+
+	devParam = 0;
+	devParam |= DBP_ALE2WR_SET(pDevParams->ale2Wr);
+	devParam |= DBP_WRLOW_SET(pDevParams->wrLow);
+	devParam |= DBP_WRHIGH_SET(pDevParams->wrHigh);
+	MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(device), devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevPramget - Get device interface bank parameters
+*
+* DESCRIPTION:
+*       This function retrieves a device bank parameter settings.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       *pDevParams - Device bank parameter struct.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	pDevParams->turnOff = DBP_TURNOFF_GET(devParam);
+	pDevParams->acc2First = DBP_ACC2FIRST_GET(devParam);
+	pDevParams->acc2Next = DBP_ACC2NEXT_GET(devParam);
+	pDevParams->badrSkew = (devParam & DBP_BADRSKEW_MASK) >> DBP_BADRSKEW_OFFS;
+
+	switch (devParam & DBP_DEVWIDTH_MASK) {
+	case DBP_DEVWIDTH_8BIT:
+		pDevParams->deviceWidth = 8;
+		break;
+	case DBP_DEVWIDTH_16BIT:
+		pDevParams->deviceWidth = 16;
+		break;
+	case DBP_DEVWIDTH_32BIT:
+		pDevParams->deviceWidth = 32;
+		break;
+	default:
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth non valid value\n"));
+		return MV_ERROR;
+		break;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG_WR(device));
+	pDevParams->ale2Wr = DBP_ALE2WR_GET(devParam);
+	pDevParams->wrLow = DBP_WRLOW_GET(devParam);
+	pDevParams->wrHigh = DBP_WRHIGH_GET(devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevWidthGet - Get device width parameter
+*
+* DESCRIPTION:
+*       This function gets width parameter of a given device.
+*
+* INPUT:
+*       device - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Device width in bits (8,16,32...).
+*
+*******************************************************************************/
+MV_U32 mvDevWidthGet(MV_DEVICE device)
+{
+	MV_U32 devParam;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	devParam = (devParam & DBP_DEVWIDTH_MASK) >> DBP_DEVWIDTH_OFFS;
+
+	return (MV_U32) (0x8 << devParam);
+
+}
+
+/*******************************************************************************
+* mvDevNandDevCsSet - Set NAND chip-select, care mode and init sequence
+*
+* DESCRIPTION:
+*       This function set the NAND flash controller registers with NAND
+*       device chip-select.
+*
+* INPUT:
+*       devNum   - Device number. See MV_DEVICE enumerator.
+*       careMode - NAND device care mode (0 = Don't care, '1' = care).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode)
+{
+	MV_U32 nfCtrlReg;	/* NAND Flash Control Register */
+
+	/* Set chip select */
+	nfCtrlReg = MV_REG_READ(DEV_NAND_CTRL_REG);
+
+	nfCtrlReg |= (DINFCR_NF_CS_MASK(device));
+
+	if (careMode)
+		nfCtrlReg |= (DINFCR_NF_ACT_CE_MASK(device));
+	else
+		nfCtrlReg &= ~(DINFCR_NF_ACT_CE_MASK(device));
+
+	MV_REG_WRITE(DEV_NAND_CTRL_REG, nfCtrlReg);
+}
diff --git a/arch/arm/mach-msys/msys_family/device/mvDevice.h b/arch/arm/mach-msys/msys_family/device/mvDevice.h
new file mode 100644
index 0000000..2f7d33f
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/device/mvDevice.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceH
+#define __INCmvDeviceH
+
+#include "device/mvDeviceRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* This structure describes device interface parameters to be assigned to   */
+/* device bank parameter                                                    */
+typedef struct _mvDeviceParam {
+				/* boundary values */
+    MV_U32       turnOff;	/* 0x0 - 0xf       */
+    MV_U32       acc2First;	/* 0x0 - 0x1f      */
+    MV_U32       acc2Next;	/* 0x0 - 0x1f      */
+    MV_U32       ale2Wr;	/* 0x0 - 0xf       */
+    MV_U32       wrLow;		/* 0x0 - 0xf       */
+    MV_U32       wrHigh;	/* 0x0 - 0xf       */
+    MV_U32       badrSkew;	/* 0x0 - 0x2       */
+    MV_U32       deviceWidth;	/* in Bytes        */
+} MV_DEVICE_PARAM;
+
+
+/* mvDevPramSet - Set device interface bank parameters */
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevPramget - Get device interface bank parameters */
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevWidthGet - Get device width parameter*/
+MV_U32 mvDevWidthGet(MV_DEVICE device);
+
+/* mvDevNandDevCsSet - Set the NAND flash control registers with NAND device- */
+/* select and care mode */
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode);
+
+#endif /* #ifndef __INCmvDeviceH */
diff --git a/arch/arm/mach-msys/msys_family/device/mvDeviceRegs.h b/arch/arm/mach-msys/msys_family/device/mvDeviceRegs.h
new file mode 100644
index 0000000..413abd8
--- /dev/null
+++ b/arch/arm/mach-msys/msys_family/device/mvDeviceRegs.h
@@ -0,0 +1,268 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceRegsH
+#define __INCmvDeviceRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_DEVICE_MAX_XBAR_TIMEOUT  0x0FFF
+/* registers offsets */
+
+static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
+{
+	switch (num) {
+	case (DEV_BOOCS):
+		return MV_DEV_BUS_REGS_OFFSET + 0x00;
+	case (DEVICE_CS0):
+		return MV_DEV_BUS_REGS_OFFSET + 0x08;
+	case (DEVICE_CS1):
+		return MV_DEV_BUS_REGS_OFFSET + 0x10;
+#ifdef MV_INCLUDE_DEVICE_CS2
+	case (DEVICE_CS2):
+		return MV_DEV_BUS_REGS_OFFSET + 0x18;
+#endif
+#ifdef MV_INCLUDE_DEVICE_CS3
+	case (DEVICE_CS3):
+		return MV_DEV_BUS_REGS_OFFSET + 0x20;
+#endif
+	default:
+		return 0xFFFFFFFF;
+	}
+}
+
+#define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
+
+/* Device Bank Parameters register fields (DBP_REG)*/
+/* Boot Device Bank Parameters (DBP) register fields (DEV_BOOT_BANK_PARAM_REG)*/
+/* DBP_XXX_MASK_HIGH is the offset of the extend bit from the msb of the input value */
+
+#define DBP_TURNOFF_OFFS_LOW		0
+#define DBP_TURNOFF_MASK_LOW		0x3F
+#define MAX_DBP_TURNOFF			0xf
+
+
+#define DBP_TURNOFF_SET(value)			\
+((value & DBP_TURNOFF_MASK_LOW) << DBP_TURNOFF_OFFS_LOW)
+
+#define DBP_TURNOFF_GET(value)			\
+((value >> DBP_TURNOFF_OFFS_LOW) & DBP_TURNOFF_MASK_LOW)
+
+#define DBP_ACC2FIRST_OFFS_LOW		6
+#define DBP_ACC2FIRST_MASK_LOW		0x3f
+#define MAX_DBP_ACC2FIRST		0x3f
+
+#define DBP_ACC2FIRST_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2FIRST_GET(value)			\
+((value >> DBP_ACC2FIRST_OFFS_LOW) & DBP_ACC2FIRST_MASK_LOW)
+
+#define DBP_ACC2NEXT_OFFS_LOW		17
+#define DBP_ACC2NEXT_MASK_LOW		0x3f
+#define MAX_DBP_ACC2NEXT		0x3f
+
+#define DBP_ACC2NEXT_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2NEXT_GET(value)			\
+((value >> DBP_ACC2NEXT_OFFS_LOW) & DBP_ACC2NEXT_MASK_LOW)
+
+#define DBP_DEVWIDTH_OFFS		30 /* Device Width */
+#define DBP_DEVWIDTH_MASK		(0x3 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_8BIT		(0x0 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_16BIT		(0x1 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_32BIT		(0x2 << DBP_DEVWIDTH_OFFS)
+
+#define DBP_BADRSKEW_OFFS		28
+#define DBP_BADRSKEW_MASK		(0x3 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_NOGAP		(0x0 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_1CYCLE		(0x1 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_2CYCLE		(0x2 << DBP_BADRSKEW_OFFS)
+
+
+#define DBP_ALE2WR_OFFS_LOW		0
+#define DBP_ALE2WR_MASK_LOW		0x3f
+#define MAX_DBP_ALE2WR			0x3F
+
+#define DBP_ALE2WR_SET(value)			\
+((value & DBP_ALE2WR_MASK_LOW) << DBP_ALE2WR_OFFS_LOW)
+
+#define DBP_ALE2WR_GET(value)			\
+((value >> DBP_ALE2WR_OFFS_LOW) & DBP_ALE2WR_MASK_LOW)
+
+#define DBP_WRLOW_OFFS_LOW		8
+#define DBP_WRLOW_MASK_LOW		0x3F
+#define MAX_DBP_WRLOW			0x3F
+
+#define DBP_WRLOW_SET(value)			\
+((value & DBP_WRLOW_MASK_LOW) << DBP_WRLOW_OFFS_LOW)
+
+#define DBP_WRLOW_GET(value)			\
+((value >> DBP_WRLOW_OFFS_LOW) & DBP_WRLOW_MASK_LOW)
+
+#define DBP_WRHIGH_OFFS_LOW		16
+#define DBP_WRHIGH_MASK_LOW		0x3F
+#define MAX_DBP_WRHIGH			0x3F
+
+#define DBP_WRHIGH_SET(value)			\
+((value & DBP_WRHIGH_MASK_LOW) << DBP_WRHIGH_OFFS_LOW)
+
+#define DBP_WRHIGH_GET(value)			\
+((value >> DBP_WRHIGH_OFFS_LOW) & DBP_WRHIGH_MASK_LOW)
+
+
+/* Device Interface Control register fields (DIC) (DIC_REG)*/
+#define DIC_TIMEOUT_OFFS 	0 /* Timeout Timer Preset Value. */
+#define DIC_TIMEOUT_MASK 	(0xffff << DIC_TIMEOUT_OFFS)
+#define MAX_DIC_TIMEOUT		0xffff
+
+/* NAND Flash Control register fields (NF) (NF_REG)*/
+#define NF_BOOTCS_OFFS			0 /* Define if BOOTCS is connected to NAND Flash */
+#define NF_BOOT_MASK			(1 << NF_BOOTCS_OFFS)
+#define NF_BOOT_NC			(0 << NF_BOOTCS_OFFS)
+#define NF_BOOT_C			(1 << NF_BOOTCS_OFFS)
+
+#define NF_BOOTCS_CE_ACT_OFFS		1 /* Define if NAND Flash on BOOTCS is CE care or CE don't care */
+#define NF_BOOTCS_CE_ACT_MASK 		(1 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_NCARE		(0 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_CARE		(1 << NF_BOOTCS_CE_ACT_OFFS)
+
+#define NF_CS0_OFFS			2 /* Define if CS0 is connected to NAND Flash */
+#define NF_CS0_MASK			(1 << NF_CS0_OFFS)
+#define NF_CS0_NC			(0 << NF_CS0_OFFS)
+#define NF_CS0_C			(1 << NF_CS0_OFFS)
+
+#define NF_CS0_CE_ACT_OFFS		3 /* Define if NAND Flash on CS0 is CE care or CE don't care */
+#define NF_CS0_CE_ACT_MASK 		(1 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_NCARE		(0 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_CARE		(1 << NF_CS0_CE_ACT_OFFS)
+
+#define NF_CS1_OFFS			4 /* Define if CS1 is connected to NAND Flash */
+#define NF_CS1_MASK			(1 << NF_CS1_OFFS)
+#define NF_CS1_NC			(0 << NF_CS1_OFFS)
+#define NF_CS1_C			(1 << NF_CS1_OFFS)
+
+#define NF_CS1_CE_ACT_OFFS		5 /* Define if NAND Flash on CS1 is CE care or CE don't care */
+#define NF_CS1_CE_ACT_MASK		(1 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_NCARE		(0 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_CARE		(1 << NF_CS1_CE_ACT_OFFS)
+
+#define NF_CS2_OFFS			6 /* Define if CS2 is connected to NAND Flash */
+#define NF_CS2_MASK			(1 << NF_CS2_OFFS)
+#define NF_CS2_NC			(0 << NF_CS2_OFFS)
+#define NF_CS2_C			(1 << NF_CS2_OFFS)
+
+#define NF_CS2_CE_ACT_OFFS		7 /* Define if NAND Flash on CS2 is CE care or CE don't care */
+#define NF_CS2_CE_ACT_MASK		(1 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_NCARE		(0 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_CARE		(1 << NF_CS2_CE_ACT_OFFS)
+
+#define NF_INIT_SEQ_OFFS		8 /* NAND Flash initialization sequence */
+#define NF_INIT_SEQ_MASK		(1 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_EN			(0 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_DIS			(1 << NF_INIT_SEQ_OFFS)
+
+#define NF_OE_HIGHW_OFFS		9 /* NAND Flash OE high width in core clocks units (value + 1) */
+#define NF_OE_HIGHW_MASK		(0x1f << NF_OE_HIGHW_OFFS)
+#define MAX_OE_HIGHW			(0x1f << NF_OE_HIGHW_OFFS)
+
+#define NF_TREADY_OFFS			14 /* NAND Flash time ready in core clocks units (value + 1) */
+#define NF_TREADY_MASK			(0x1f << NF_TREADY_OFFS)
+#define MAX_TREADY			(0x1f << NF_TREADY_OFFS)
+
+#define NF_OE_TCTRL_OFFS		19 /* NAND Flash OE toggle control */
+#define NF_OE_TCTRL_MASK		(1 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_1_CYC_AFT		(0 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_SAME_CYC		(1 << NF_OE_TCTRL_OFFS)
+
+#define NF_CS3_OFFS			20 /* Define if CS3 is connected to NAND Flash */
+#define NF_CS3_MASK			(1 << NF_CS3_OFFS)
+#define NF_CS3_NC			(0 << NF_CS3_OFFS)
+#define NF_CS3_C			(1 << NF_CS3_OFFS)
+
+#define NF_CS3_CE_ACT_OFFS		21 /* Define if NAND Flash on CS3 is CE care or CE don't care */
+#define NF_CS3_CE_ACT_MASK		(1 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_NCARE		(0 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_CARE		(1 << NF_CS3_CE_ACT_OFFS)
+
+
+/* Device Interface NAND Flash Control Register (DINFCR) */
+#define DINFCR_NF_CS_MASK(csNum)         \
+(csNum == BOOT_CS) ?  0x1 : ((csNum == DEV_CS3) ? (0x1 << 20) : (0x1 << (((csNum+1) % MV_DEV_MAX_CS) * 2)))
+
+
+#define DINFCR_NF_ACT_CE_MASK(csNum)     \
+(csNum == DEV_CS3) ? (0x2 << 20) : (0x2 << (((csNum+1) % MV_DEV_MAX_CS) * 2))
+
+#define NAND_ACTCEBOOT_BIT	BIT1
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCmvDeviceRegsH */
-- 
1.7.5.4

