From 3b14a818461a046a85068b4c760bf52f154a44c2 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Mon, 10 Jun 2013 14:37:45 +0300
Subject: [PATCH 0752/1825] ALP: Add support for SMP (CPU1 enable WA)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 606331780be05d7c0dd0d0a5f94e9c502c306814

	Due to internal bootrom issue, CPU[1] initial jump code
	(four instructions) should be placed in SoC SRAM memory.
	Furthermore, MMU and SoC memory windows should be configured
	appropriately to enable CPU[1] to boot.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: If16479c5267baca480a37a1a4d9e377e2424ea39
Reviewed-on: http://vgitil04.il.marvell.com:8080/2199
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/kernel/smp.c                              |    4 -
 arch/arm/mach-avantalp/Kconfig                     |    5 ++
 .../avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c     |   57 +++++++++++++++++--
 .../avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h     |    1 +
 arch/arm/mach-avantalp/ca9x2.h                     |    8 +++
 arch/arm/mach-avantalp/core.c                      |   59 ++++++++++++++++++--
 arch/arm/mach-avantalp/headsmp.S                   |   18 ++++++
 arch/arm/mach-avantalp/platsmp.c                   |   13 ++--
 8 files changed, 142 insertions(+), 23 deletions(-)

diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 037348f..1c99d49 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -415,10 +415,6 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	/*
 	 * are we trying to boot more cores than exist?
 	 */
-
-early_printk("oooooooo: %s:%d ~~~~~~~~~~~~~~\n", __func__, __LINE__);
-early_printk("oooooooo: %s:%d max_cpus = %d, ncores = %d \n", __func__, __LINE__, max_cpus, ncores);
-
 	if (max_cpus > ncores)
 		max_cpus = ncores;
 	if (ncores > 1 && max_cpus) {
diff --git a/arch/arm/mach-avantalp/Kconfig b/arch/arm/mach-avantalp/Kconfig
index 4230b11..8d2941b 100644
--- a/arch/arm/mach-avantalp/Kconfig
+++ b/arch/arm/mach-avantalp/Kconfig
@@ -6,6 +6,11 @@ config  MV_HAL_RULES_PATH
 	help
 	  No help currently.
 
+config ALP_CPU1_ENABLE_WA
+	depends on SMP
+	bool "SMP CPU1 Enable WA"
+	default y
+
 menu "Marvell Avanta Options"
 
 config AVANTA_LP
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
index 71fa514..ccddfcf 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -227,9 +227,8 @@ MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
 	MV_TARGET_ATTRIB targetAttrib;
 	MV_U32 sizeRegVal;
 
-	/* Parameter checking   */
 	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
-		mvOsPrintf("mvAhbToMbusWinGet: ERR. Invalid winNum %d\n", winNum);
+		mvOsPrintf("%s: Error: Invalid winNum %d\n", __func__, winNum);
 		return MV_NOT_SUPPORTED;
 	}
 
@@ -254,7 +253,6 @@ MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
 		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
 		pAddrDecWin->target = INTER_REGS;
 		pAddrDecWin->enable = MV_TRUE;
-
 		return MV_OK;
 	}
 
@@ -275,6 +273,53 @@ MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
 	return MV_OK;
 }
 
+/*
+ * Straight forward function what returns _only_ the index of the
+ * memory window according to provided SoC target.
+ */
+MV_STATUS mvAhbToMbusWinNumByTargetGet(MV_TARGET target, MV_U32 *pWinNum)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_U32 winNum, ctrlReg, targetId;
+
+	if (pWinNum == NULL) {
+		mvOsPrintf("%s: Error: pWinNum is NULL\n", __func__);
+		return MV_FAIL;
+	}
+
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("%s: Error: target %d is illegal\n", __func__, target);
+		return MV_FAIL;
+	}
+
+	if (target == INTER_REGS) {
+		*pWinNum = MV_AHB_TO_MBUS_INTREG_WIN;
+		return MV_OK;
+	}
+
+	if (mvCtrlAttribGet(target, &targetAttribs) != MV_OK) {
+		mvOsPrintf("%s: Error: mvCtrlAttribGet(target = %d) failed\n",
+			   __func__, target);
+		return MV_FAIL;
+	}
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+		targetId = (ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+		if (targetId == targetAttribs.targetId) {
+			*pWinNum = winNum;
+			return MV_OK;
+		}
+
+	}
+
+	return MV_FAIL;
+}
+
 /*******************************************************************************
 * mvAhbToMbusWinTargetGet - Get Window number associated with target
 *
@@ -292,9 +337,8 @@ MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
 	MV_AHB_TO_MBUS_DEC_WIN decWin;
 	MV_U32 winNum;
 
-	/* Check parameters */
 	if (target >= MAX_TARGETS) {
-		mvOsPrintf("mvAhbToMbusWinTargetGet: target %d is illegal\n", target);
+		mvOsPrintf("%s: Error: target %d is illegal\n", __func__, target);
 		return 0xffffffff;
 	}
 
@@ -306,7 +350,8 @@ MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
 			continue;
 
 		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
-			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			mvOsPrintf("%s: Error: mvAhbToMbusWinGet(winNum = %d) failed\n",
+				   __func__, winNum);
 			return 0xffffffff;
 		}
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
index 864463c..b5969a0 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -84,6 +84,7 @@ MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
 MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
 MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
 MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinNumByTargetGet(MV_TARGET target, MV_U32 *pWinNum);
 MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
 MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
 MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
diff --git a/arch/arm/mach-avantalp/ca9x2.h b/arch/arm/mach-avantalp/ca9x2.h
index 5e4a738..a865abe 100644
--- a/arch/arm/mach-avantalp/ca9x2.h
+++ b/arch/arm/mach-avantalp/ca9x2.h
@@ -1,6 +1,14 @@
 #ifndef __MACH_MV_CA9X2_H
 #define __MACH_MV_CA9X2_H
 
+#if defined(CONFIG_SMP) && defined(CONFIG_ALP_CPU1_ENABLE_WA)
+void alp_secondary_startup(void);
+void alp_smp_cpu1_enable_wa(void);
+
+extern void *alp_smp_cpu1_enable_code_start;
+extern void *alp_smp_cpu1_enable_code_end;
+#endif
+
 /*
  * Physical base addresses
  */
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index a9f93f0..641b905 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -1211,7 +1211,49 @@ extern void printascii(const char *);
 
 extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
 
-/*
+/*******************************************************************************
+ * SMP WA to enable CPU1
+ * Note: This function is called before PUnit IO windows are configured.
+ */
+#if defined(CONFIG_SMP) && defined(CONFIG_ALP_CPU1_ENABLE_WA)
+
+void alp_smp_cpu1_enable_wa(void)
+{
+	MV_AHB_TO_MBUS_DEC_WIN mbus_win;
+	u32 code_len, win_num, sram_phys_base = 0xFFFF0000;
+	void __iomem *sram_virt_base;
+
+	mbus_win.target			= CRYPT0_ENG;
+	mbus_win.addrWin.baseLow	= sram_phys_base;
+	mbus_win.addrWin.baseHigh	= 0x0;
+	mbus_win.addrWin.size		= SZ_64K;
+	mbus_win.enable			= MV_TRUE;
+
+	if (mvAhbToMbusWinNumByTargetGet(CRYPT0_ENG, &win_num) != MV_OK) {
+		pr_err("%s: Error: mvAhbToMbusWinNumByTargetGet(target = %d) failed\n",
+		       __func__, CRYPT0_ENG);
+		return;
+	}
+
+	if (mvAhbToMbusWinSet(win_num, &mbus_win) != MV_OK) {
+		pr_err("%s: Error: mvAhbToMbusWinSet(win_num = %d) failed\n",
+		       __func__, win_num);
+		return;
+	}
+
+	sram_virt_base = ioremap(sram_phys_base, SZ_64K);
+
+	code_len = 4 * (&alp_smp_cpu1_enable_code_end - &alp_smp_cpu1_enable_code_start);
+	memcpy(sram_virt_base, &alp_smp_cpu1_enable_code_start, code_len);
+}
+#else
+void alp_smp_cpu1_enable_wa(void)
+{
+	/* nothing */
+}
+#endif
+
+/*******************************************************************************
  * IOCC sync implementation
  */
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
@@ -1260,7 +1302,7 @@ static void alp_iocc_wa_setup_punit_win(ulong phys0, ulong phys1, MV_TARGET targ
 	u32 win_num;
 
 	win_num = mvAhbToMbusWinAvailGet();
-	if (win_num > 7 || win_num == 0xffffffff) {
+	if (win_num >= MAX_AHB_TO_MBUS_REMAP_WINS || win_num == 0xffffffff) {
 		pr_err("%s: Error: No free PUnit window (win_num = 0x%x)\n",
 		       __func__, win_num);
 		return;
@@ -1273,7 +1315,8 @@ static void alp_iocc_wa_setup_punit_win(ulong phys0, ulong phys1, MV_TARGET targ
 	mbus_win.enable			= MV_TRUE;
 
 	if (mvAhbToMbusWinSet(win_num, &mbus_win) != MV_OK) {
-		pr_err("%s: Error: mvAhbToMbusWinSet failed\n", __func__);
+		pr_err("%s: Error: mvAhbToMbusWinSet(win_num = %d) failed\n",
+		       __func__, win_num);
 		return;
 	}
 
@@ -1281,7 +1324,8 @@ static void alp_iocc_wa_setup_punit_win(ulong phys0, ulong phys1, MV_TARGET targ
 	remap_win.baseHigh = 0;		/* remap high base */
 
 	if (mvAhbToMbusWinRemap(win_num, &remap_win) == 0xffffffff) {
-		pr_err("%s: Error:mvAhbToMbusWinRemap failed\n", __func__);
+		pr_err("%s: Error: mvAhbToMbusWinRemap(win_num = %d) failed\n",
+		       __func__, win_num);
 		return;
 	}
 }
@@ -1325,13 +1369,16 @@ void dma_io_sync(void)
  */
 static void __init alp_iocc_init(void)
 {
-#if !defined(CONFIG_SMP) && defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+
+#if !defined(CONFIG_SMP)
 	void __iomem *scu_base =
 		(void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 	scu_enable(scu_base);
 #endif
 
 	alp_iocc_wa_init();
+#endif
 }
 
 static void __init alp_l2x0_cache_init(void)
@@ -1393,7 +1440,7 @@ static void __init alp_board_init(void)
 
 static void board_restart(char mode, const char *cmd)
 {
-	printk(KERN_NOTICE "Reseting...\n");
+	pr_notice("Reseting...\n");
 	mvBoardReset();
 
 	/* This should never be reached */
diff --git a/arch/arm/mach-avantalp/headsmp.S b/arch/arm/mach-avantalp/headsmp.S
index e7df510..52ee3a0 100644
--- a/arch/arm/mach-avantalp/headsmp.S
+++ b/arch/arm/mach-avantalp/headsmp.S
@@ -3,6 +3,24 @@
 
 	__INIT
 
+#ifdef CONFIG_ALP_CPU1_ENABLE_WA
+
+#define CPU_RESUME_ADDR_REG 0xf10182d4
+
+.global alp_smp_cpu1_enable_code_start
+.global alp_smp_cpu1_enable_code_end
+
+ENTRY(alp_smp_cpu1_enable_code_start)
+alp_smp_cpu1_enable_code_start:
+	ldr	r0, [pc, #4]
+	ldr	r1, [r0]
+	mov	pc, r1
+	.word	CPU_RESUME_ADDR_REG
+alp_smp_cpu1_enable_code_end:
+ENDPROC(alp_smp_cpu1_enable_code_end)
+
+#endif /* CONFIG_ALP_CPU1_ENABLE_WA */
+
 /*
  * This provides a "holding pen" into which all secondary cores are held
  * until we're ready for them to initialise.
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index e7afd21..1fd3f95 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -23,8 +23,7 @@
 #include "core.h"
 
 unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
-
-extern void alp_secondary_startup(void);
+static void __iomem *scu_base = (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 
 /*
  * Initialise the CPU possible map early - this describes the CPUs
@@ -32,7 +31,7 @@ extern void alp_secondary_startup(void);
  */
 void __init smp_init_cpus(void)
 {
-	int i, ncores = scu_get_core_count(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+	int i, ncores = scu_get_core_count(scu_base);
 
 	if (ncores > nr_cpu_ids) {
 		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
@@ -48,13 +47,13 @@ void __init smp_init_cpus(void)
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int ncores = scu_get_core_count(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
-
 	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
 	 */
-	scu_enable(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
+	scu_enable(scu_base);
+
+	alp_smp_cpu1_enable_wa();
 
 	/*
 	 * Write the address of secondary startup into the
@@ -63,7 +62,7 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * secondary CPU branches to this address.
 	 */
 	writel(virt_to_phys(alp_secondary_startup),
-	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG);
+	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG(1));
 }
 
 /*
-- 
1.7.5.4

