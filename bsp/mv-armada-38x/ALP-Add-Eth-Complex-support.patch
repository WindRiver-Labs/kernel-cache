From cc9cf706be8677f1fece61e46f36c117dcc31006 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Thu, 16 May 2013 08:48:42 +0300
Subject: [PATCH 0655/1825] ALP: Add Eth Complex support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit dedbc2eb1c06d0565341960cdcf143304e413c59

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: Ie636b48e133167a669af89ca1d0a804ab9bf0a08
Reviewed-on: http://vgitil04.il.marvell.com:8080/1824
Reviewed-by: Star_Automation <star@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   93 ++-
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    8 +-
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |   57 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |    4 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |   33 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    1 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c    |  836 +++++++-------------
 .../avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h    |   86 ++-
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c     |   35 +-
 arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h     |   18 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |    3 -
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c |   95 ++-
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h |   12 +-
 .../plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h    |    3 +
 14 files changed, 603 insertions(+), 681 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index a2aa4ed..7c636e8 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -298,7 +298,6 @@ MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
 *******************************************************************************/
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
 {
-
 #if defined(CONFIG_MACH_AVANTA_LP_FPGA)
 	return 8;
 #endif
@@ -958,7 +957,7 @@ MV_STATUS mvBoardSwitchInfoUpdate(MV_VOID)
 	MV_U32 i, ethComplexOptions = mvBoardEthComplexConfigGet();
 
 	/* Update board switch information according to Ethernet Complex init */
-	if ((!mvBoardIsInternalSwitchConnected(0)) && (!mvBoardIsInternalSwitchConnected(1))) {
+	if (mvBoardIsInternalSwitchConnected() == MV_FALSE) {
 		board->switchInfoNum = 0;
 		return MV_OK;
 	}
@@ -1228,7 +1227,7 @@ MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet()
 }
 
 /*******************************************************************************
-* mvBoardIsInternalSwitchConnected
+* mvBoardIsInternalSwitchConnectedToPort
 *
 * DESCRIPTION:
 *       This routine returns port's connection status
@@ -1243,7 +1242,7 @@ MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet()
 *       1 - if ethPortNum is connected to switch, 0 otherwise
 *
 *******************************************************************************/
-MV_STATUS mvBoardIsInternalSwitchConnected(MV_U32 ethPortNum)
+MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum)
 {
 	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
 
@@ -1262,6 +1261,33 @@ MV_STATUS mvBoardIsInternalSwitchConnected(MV_U32 ethPortNum)
 }
 
 /*******************************************************************************
+* mvBoardIsInternalSwitchConnected
+*
+* DESCRIPTION:
+*       This routine returns port's connection status
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 - if ethPortNum is connected to switch, 0 otherwise
+*
+*******************************************************************************/
+MV_STATUS mvBoardIsInternalSwitchConnected(void)
+{
+	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
+
+	if ((ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6) ||
+	    (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
 * mvBoardSwitchConnectedPortGet -
 *
 * DESCRIPTION:
@@ -1278,14 +1304,12 @@ MV_STATUS mvBoardIsInternalSwitchConnected(MV_U32 ethPortNum)
 *******************************************************************************/
 MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort)
 {
-
 	if (board->switchInfoNum == 0)
 		return -1;
 
 	return board->pSwitchInfo[0].connectedPort[ethPort];
 }
 
-
 /*******************************************************************************
 * mvBoardSwitchPortsMaskGet -
 *
@@ -1301,12 +1325,24 @@ MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort)
 * RETURN:
 *
 *******************************************************************************/
-MV_8 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
+MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
 {
-	if ((board->switchInfoNum == 0) || (switchIdx >= board->switchInfoNum))
-	return -1;
+	MV_U32 mask = 0, c = mvBoardEthComplexConfigGet();
+
+	if (c & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
+		mask |= BIT0;
+	if (c & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+		mask |= BIT1;
+	if (c & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
+		mask |= BIT2;
+	if (c & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
+		mask |= BIT3;
+	if ((c & MV_ETHCOMP_SW_P4_2_RGMII0) || (c & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		mask |= BIT4;
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		mask |= BIT6;
 
-	return board->pSwitchInfo[switchIdx].connectedPortMask;
+	return mask;
 }
 
 /*******************************************************************************
@@ -1327,12 +1363,10 @@ MV_8 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_32 mvBoardInternalQuadPhyAddrGet(MV_U32 switchIdx)
 {
-
 	if ((board->switchInfoNum == 0) || (switchIdx >= board->switchInfoNum))
 		return -1;
 
 	return board->pSwitchInfo[switchIdx].internalQuadPhyAddr;
-
 }
 
 /*******************************************************************************
@@ -1353,8 +1387,7 @@ MV_32 mvBoardInternalQuadPhyAddrGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx)
 {
-
-	if ( board->switchInfoNum == 0 || switchIdx >= board->switchInfoNum )
+	if (board->switchInfoNum == 0 || switchIdx >= board->switchInfoNum)
 		return (MV_U32)MV_ERROR;
 
 	return board->pSwitchInfo[switchIdx].forceLinkMask;
@@ -2069,16 +2102,16 @@ MV_STATUS mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_TYPE_ID ioClass, MV_BOARD_IO_E
 * mvBoardExtPhyBufferSelect - enable/disable buffer status
 *
 * DESCRIPTION:
-*       This function enables/disabke the buffer status - according to Boolean input
+*	This function enables/disables the buffer status.
 *
 * INPUT:
-*       enable - Boolean to indicate requested status
+*	enable - Boolean to indicate requested status
 *
 * OUTPUT:
-*       None.
+*	None.
 *
 * RETURN:
-*       None.
+*	None.
 *
 *******************************************************************************/
 MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable)
@@ -2092,7 +2125,6 @@ MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable)
 	return MV_FALSE;
 }
 
-
 /*******************************************************************************
 * mvBoardNandWidthGet -
 *
@@ -2529,24 +2561,31 @@ MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
 * mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
 *
 * DESCRIPTION:
-*       This routine returns the Switch CPU port if connected , -1 else.
+*	This routine returns the Switch CPU port if connected, -1 else.
 *
 * INPUT:
-*       switchIdx - index of the switch. Only 0 is supported.
+*	switchIdx - index of the switch. Only 0 is supported.
 *
 * OUTPUT:
-*       None.
+*	None.
 *
 * RETURN:
-*       the Switch CPU port, -1 if the switch is not connected.
+*	the Switch CPU port, -1 if the switch is not connected.
 *
 *******************************************************************************/
-MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
+MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
 {
-	if ((board->switchInfoNum == 0) || (switchIdx >= board->switchInfoNum))
-		return -1;
+	MV_U32 c = board->pBoardModTypeValue->ethSataComplexOpt;
+	MV_U32 cpuPort = -1;
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		cpuPort = 6;
+	else if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
+		cpuPort = 4;
+	else
+		mvOsPrintf("%s: Error: No CPU port.\n", __func__);
 
-	return board->pSwitchInfo[switchIdx].cpuPort;
+	return cpuPort;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 233d081..b4a454c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -456,7 +456,8 @@ MV_STATUS mvBoardOtherModulesScan(void);
 MV_BOOL mvBoardIsPexModuleConnected(void);
 MV_BOOL mvBoardIsSetmModuleConnected(void);
 MV_BOOL mvBoardIsSwitchModuleConnected(void);
-MV_STATUS mvBoardIsInternalSwitchConnected(MV_U32 ethPortNum);
+MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum);
+MV_STATUS mvBoardIsInternalSwitchConnected(void);
 MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx);
 MV_BOOL mvBoardIsLvdsModuleConnected(void);
 MV_BOOL mvBoardIsLcdDviModuleConnected(void);
@@ -464,16 +465,15 @@ MV_BOOL mvBoardIsGMIIModuleConnected(void);
 MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
 MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
-MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
 MV_32 mvBoardSwitchIrqGet(void);
 MV_BOOL mvBoardIsQsgmiiModuleConnected(void);
 MV_32 mvBoardGePhySwitchPortGet(void);
 MV_32 mvBoardRgmiiASwitchPortGet(void);
 MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
-MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
+MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
 MV_32 mvBoardSwitchIrqGet(MV_VOID);
 MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort);
-MV_8 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
+MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
 MV_BOOL mvBoardConfigAutoDetectEnabled(void);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
 MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
index a8f8eeb..a6d11a0 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -286,23 +286,26 @@ MV_BOARD_INFO db88f6660_board_info = {
 
 MV_BOARD_TWSI_INFO db88f6650InfoBoardTwsiDev[] = {
 	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
-	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_SATR,		1,	0x4E,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_EEPROM,	0,	0x54,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_IO_EXPANDER,	0,	0x21,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_IO_EXPANDER,	2,	0x24,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	ADDR7_BIT },
+	{ BOARD_DEV_TWSI_SATR,		1,	0x4E,	ADDR7_BIT },
+	{ BOARD_DEV_TWSI_EEPROM,	0,	0x54,	ADDR7_BIT },
+	{ BOARD_DEV_TWSI_IO_EXPANDER,	0,	0x21,	ADDR7_BIT },
+	{ BOARD_DEV_TWSI_IO_EXPANDER,	2,	0x24,	ADDR7_BIT },
 };
+
 MV_BOARD_MAC_INFO db88f6650InfoBoardMacInfo[] = {
 	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
-	{ BOARD_MAC_SPEED_AUTO, 0x0									},
-	{ BOARD_MAC_SPEED_AUTO, 0x1									},
-	{ N_A,			N_A									}
+	{ BOARD_MAC_SPEED_AUTO, 0x0 },
+	{ BOARD_MAC_SPEED_AUTO, 0x3 },
+	{ N_A,			N_A },
 };
+
 MV_BOARD_MPP_TYPE_INFO db88f6650InfoBoardModTypeInfo[] = {
 	{
 		.boardMppSlic = MV_BOARD_AUTO,
-		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC1_2_RGMII1 | MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0,
-		.ethPortsMode = 0x0
+		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0 |
+				     MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3,
+		.ethPortsMode = 0x0,
 	}
 };
 
@@ -315,28 +318,28 @@ MV_DEV_CS_INFO db88f6650InfoBoardDeCsInfo[] = {
 
 MV_BOARD_MPP_INFO db88f6650InfoBoardMppConfigValue[] = {
 	{ {
-		  DB_88F6650_MPP0_7,
-		  DB_88F6650_MPP8_15,
-		  DB_88F6650_MPP16_23,
-		  DB_88F6650_MPP24_31,
-		  DB_88F6650_MPP32_39,
-		  DB_88F6650_MPP40_47,
-		  DB_88F6650_MPP48_55,
-		  DB_88F6650_MPP56_63,
-		  DB_88F6650_MPP64_67,
+		DB_88F6650_MPP0_7,
+		DB_88F6650_MPP8_15,
+		DB_88F6650_MPP16_23,
+		DB_88F6650_MPP24_31,
+		DB_88F6650_MPP32_39,
+		DB_88F6650_MPP40_47,
+		DB_88F6650_MPP48_55,
+		DB_88F6650_MPP56_63,
+		DB_88F6650_MPP64_67,
 	 } }
 };
 
 MV_BOARD_SWITCH_INFO db88f6650InfoBoardSwitchValue[] = {
 	{
-	 .switchIrq = 29,	/* set to -1 for timer operation */
-	 .switchPort = {0, 1, 2, 3, 4, -1, -1},
-	 .cpuPort = 6,
-	 .connectedPort = {6, -1},
-	 .internalQuadPhyAddr = 0,
-	 .connectedPortMask= ( BIT0| BIT1| BIT2| BIT3| BIT4| BIT6),
-	 .forceLinkMask = 0x0
-	 }
+		.switchIrq = 29,	/* set to -1 for timer operation */
+		.switchPort = {0, 1, 2, 3, 4, -1, -1},
+		.cpuPort = 6,
+		.connectedPort = {6, -1},
+		.internalQuadPhyAddr = 0,
+		 .connectedPortMask = (BIT0 | BIT1 | BIT2 | BIT3 | BIT6),
+		.forceLinkMask = 0x0,
+	}
 };
 
 MV_BOARD_INFO db88f6650_board_info = {
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 18d16f2..99bf51b 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -280,7 +280,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 		mvGppPolaritySet(i, gppMask, (MV_GPP_IN_INVERT & gppMask));
 	}
 
-	mvEthCompInit();
+	mvEthComplexInit(mvBoardEthComplexConfigGet());
 	return MV_OK;
 }
 
@@ -383,7 +383,7 @@ MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
 	MV_U8 groupTypeSelect = 0;
 
 	if (! ((smiCtrl == SWITCH_SMI_CTRL) || (smiCtrl == CPU_SMI_CTRL)) ) {
-		DB(mvOsPrintf("mvCtrlSMISet: SMI ctrl initialize fail \n"));;
+		DB(mvOsPrintf("mvCtrlSMISet: SMI ctrl initialize failed\n"));
 		return;
 	}
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 6a88e6c..391ade3 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -181,23 +181,24 @@ typedef enum _mvSwapType {
  * Define the different Ethernet complex sources for the RGMIIA/B and
  * the FE/GE phy interfaces.
  */
-
-/* Define the different Ethernet & Sata complex connection options */
 typedef enum {
-	MV_ETHCOMP_GE_MAC0_2_SW_P6		=	0x1,
-	MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0		=	0x2,
-	MV_ETHCOMP_GE_MAC0_2_RGMII0		=	0x4,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_1		=	0x8,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_2		=	0x10,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_3		=	0x20,
-	MV_ETHCOMP_GE_MAC1_2_SW_P4		=	0x40,
-	MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3		=	0x80,
-	MV_ETHCOMP_GE_MAC1_2_RGMII1		=	0x100,
-	MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES	=	0x200,
-	MV_ETHCOMP_SW_P0_2_GE_PHY_P0		=	0x400,
-	MV_ETHCOMP_SW_P3_2_GE_PHY_P3		=	0x800,
-	MV_ETHCOMP_SW_P4_2_RGMII0		=	0x1000,
-	MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES	=	0x2000,
+	MV_ETHCOMP_SW_P0_2_GE_PHY_P0		=	BIT0,
+	MV_ETHCOMP_SW_P1_2_GE_PHY_P1		=	BIT1,
+	MV_ETHCOMP_SW_P2_2_GE_PHY_P2		=	BIT2,
+	MV_ETHCOMP_SW_P3_2_GE_PHY_P3		=	BIT3,
+	MV_ETHCOMP_SW_P4_2_RGMII0		=	BIT4,
+	/* Switch port 5 does not exist, ==> BIT5 is omitted */
+	MV_ETHCOMP_GE_MAC0_2_SW_P6		=	BIT6,
+	MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0		=	BIT7,
+	MV_ETHCOMP_GE_MAC0_2_RGMII0		=	BIT8,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_1		=	BIT9,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_2		=	BIT10,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_3		=	BIT11,
+	MV_ETHCOMP_GE_MAC1_2_SW_P4		=	BIT12,
+	MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3		=	BIT13,
+	MV_ETHCOMP_GE_MAC1_2_RGMII1		=	BIT14,
+	MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES	=	BIT15,
+	MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES	=	BIT16,
 } MV_ETH_COMPLEX_TOPOLOGY;
 
 typedef enum {
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index 314fbe2..fc05271 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -90,6 +90,7 @@ extern "C" {
 #define MV_MPP_REGS_OFFSET                      (0x18000)
 #define MV_GPP_REGS_OFFSET(unit)                (0x18100 + ((unit) * 0x40))
 #define MV_MISC_REGS_OFFSET                     (0x18200)
+#define MV_COMMON_PHY_REGS_OFFSET               (0x18300)
 #define MV_CLK_CMPLX_REGS_OFFSET        	(0x18700)
 #define MV_ETH_COMPLEX_OFFSET			(0x18900)
 #define MV_MBUS_REGS_OFFSET                     (0x20000)
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
index 32927aa..46606df 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
@@ -65,635 +65,401 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <mvCommon.h>
 #include <mvOs.h>
 #include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "ctrlEnv/mvCtrlEthCompLib.h"
+#include "mvCtrlEthCompLib.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
 #include "boardEnv/mvBoardEnvLib.h"
 #include "pp2/gmac/mvEthGmacRegs.h"
 #include "pp2/gbe/mvPp2Gbe.h"
 
-static MV_BOOL gEthComplexSkipInit = MV_FALSE;
-
-/******************************************************************************
-* mvEthCompSkipInitSet
-*
-* DESCRIPTION:
-*	Configure the eth-complex to skip initialization.
-*
-* INPUT:
-*	skip - MV_TRUE to skip initialization.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-void mvEthCompSkipInitSet(MV_BOOL skip)
+static void mvEthComplexGbePhySrcSet(MV_U32 phy, MV_U32 src)
 {
-	gEthComplexSkipInit = skip;
-	return;
-}
+	MV_U32 reg;
 
-/******************************************************************************
-* mvEthCompMac2SwitchConfig
-*
-* DESCRIPTION:
-*	Configure ethernet complex for MAC0/1 to switch ports 4/6 mode.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration bitmap.
-*	muxCfgOnly - MV_TRUE: Configure only the ethernet complex mux'es and
-*		     skip other switch reset configurations.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompMac2SwitchConfig(MV_U32 ethCompCfg, MV_BOOL muxCfgOnly)
-{
-	return MV_OK;
-}
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy);
 
-/******************************************************************************
-* mvEthCompSwitchReset
-*
-* DESCRIPTION:
-*	Reset switch device after being configured by ethernet complex functions.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration bitmap.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompSwitchReset(MV_U32 ethCompCfg)
-{
-	return MV_OK;
+	src <<= ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy);
+	src &= ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
 }
 
-/******************************************************************************
-* mvEthCompMac2RgmiiConfig
-*
-* DESCRIPTION:
-*	Configure ethernet complex for MAC0/1 to RGMII output.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration bitmap.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompMac2RgmiiConfig(MV_U32 ethCompCfg)
+static MV_U32 mvEthComplexSwPortSrcCalc(MV_U32 swPort, enum mvSwPortSrc src)
 {
-	return MV_OK;
+	MV_U32 val = 0x0;
+
+	if (swPort != 0 && swPort != 3 && swPort != 4 && swPort != 6) {
+		mvOsPrintf("%s: Wrong switch port (%d)\n",
+			   __func__, swPort);
+		return 0x0;
+	}
+
+	switch (swPort) {
+	case 0:
+	case 3:
+		if (src == ETHC_SW_PORT_SRC_GBE_PHY)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_NC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	case 4:
+		if (src == ETHC_SW_PORT_SRC_MPP)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_GBE_MAC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	case 6:
+		if (src == ETHC_SW_PORT_SRC_GBE_MAC)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_NC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	}
+
+	return val;
 }
 
-/******************************************************************************
-* mvEthCompSwP56ToRgmiiConfig
-*
-* DESCRIPTION:
-*	Configure ethernet complex for Switch port 5 or 6 to RGMII output.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration bitmap.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompSwP56ToRgmiiConfig(MV_U32 ethCompCfg)
+static void mvEthComplexSwPortSrcSet(MV_U32 swPort, MV_U32 src)
 {
-	return MV_OK;
-}
+	MV_U32 reg;
 
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_SW_PORT_SRC_MASK(swPort);
 
-/******************************************************************************
-* mvEthCompSataConfig
-*
-* DESCRIPTION:
-*	Configure ethernet complex for sata port output.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration bitmap.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompSataConfig(MV_U32 ethCompCfg)
-{
-	return MV_OK;
-}
+	src <<= ETHCC_SW_PORT_SRC_OFFSET(swPort);
+	src &= ETHCC_SW_PORT_SRC_MASK(swPort);
 
-/******************************************************************************
-* mvEthCompShutdownIf
-*
-* DESCRIPTION:
-*	Shutdown ethernet complex interfaces.
-*
-* INPUT:
-*	integSwitch	- MV_TRUE to shutdown the integrated switch.
-*	gePhy		- MV_TRUE to shutdown the GE-PHY
-*	fePhy		- MV_TRUE to shutdown the 3xFE PHY.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompShutdownIf(MV_BOOL integSwitch, MV_BOOL gePhy, MV_BOOL fePhy)
-{
-	return MV_OK;
-}
+	reg |= src;
 
-/******************************************************************************
-* mvEthCompGopPhySmiAutoPollSet
-*
-* DESCRIPTION:
-* 	Disables hardware PHY polling mode.
-* 	Relevant for SMI Interface0.
-* 	Used for Auto-Negotiation and PHY configuration of the PHY devices
-* 	connected to ports 0 through 11. Stops the Auto-Negotiation process
-* 	on SMI Interface0. When the CPU accesses a PHY via SMI Interface0,
-* 	this bit must be set to 1 when a 88E1112 is connected to one of the ports.
-* 	NOTE: Although the device ignores the information read from the
-* 	PHY registers, it keeps polling these registers.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-#if 0 /* This bit does not work !!! */
-static void mvEthCompGopPhySmiAutoPollSet(MV_BOOL enable)
-{
-	if (enable == MV_TRUE)
-		MV_REG_BIT_RESET(ETH_PHY_AN_CFG0_REG(0),
-				 ETH_PHY_AN_CFG0_STOP_AN_SMI0_MASK);
-	else
-		MV_REG_BIT_SET  (ETH_PHY_AN_CFG0_REG(0),
-				 ETH_PHY_AN_CFG0_STOP_AN_SMI0_MASK);
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
 }
-#endif
-
-/******************************************************************************
-* mvEthCompGopPhySmiAddrSet
-*
-* DESCRIPTION:
-*	Perform basic setup that is needed before configuring the eth-complex
-*	registers.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompGopPhySmiAddrSet(MV_U32 port, MV_U32 smiAddr)
+
+static void mvEthComplexGbePortSrcSet(MV_U32 port, MV_U32 src)
 {
 	MV_U32 reg;
 
-	/*
-	 * Set PHY SMI address: set PcsPhyAddress to PHY SMI address.
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL0_REG(port));
-	reg &= ~ETHCGPC0_PCS_PHY_ADDR_MASK;
-	smiAddr &= ETHCGPC0_PCS_PHY_ADDR_MASK;
-	reg |= (smiAddr << ETHCGPC0_PCS_PHY_ADDR_OFFSET);
-	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL0_REG(port), reg);
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GBE_MAC_SRC_MASK(port);
+
+	src <<= ETHCC_GBE_MAC_SRC_OFFSET(port);
+	src &= ETHCC_GBE_MAC_SRC_MASK(port);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
 }
 
-/******************************************************************************
-* mvEthCompMacSetReset
-*
-* DESCRIPTION:
-* 	None.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-void mvEthCompMacSetReset(MV_U32 port, MV_BOOL enable)
+/*
+ * Set speed Gbe Port 0 when it is connected to switch port 6
+ */
+static void mvEthComplexGbeToSwitchSpeedSet(MV_ETH_PORT_SPEED speed)
 {
-	MV_U32 reg, mask;
+	MV_U32 reg;
+
+	if (speed != MV_ETH_SPEED_1000 && speed != MV_ETH_SPEED_2000) {
+		mvOsPrintf("%s: wrong speed (%d)\n", __func__, speed);
+		return;
+	}
 
-	if (enable == MV_TRUE)
-		mask = 0x1;
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GE_MAC0_SW_PORT_6_SPEED_MASK;
+
+	if (speed == MV_ETH_SPEED_2000)
+		reg |= (0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET);
 	else
-		mask = 0x0;
-
-	/*
-	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
-	 */
-	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
-	reg &= ~ETH_GMAC_PORT_RESET_MASK;
-	reg |= (mask << ETH_GMAC_PORT_RESET_BIT);
-	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
+		reg |= (0x0 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+
+	if (speed == MV_ETH_SPEED_2000) {
+		reg = MV_REG_READ(MV_ETHCOMP_SW_CONFIG_RESET_CTRL);
+		reg &= ~ETHSCRC_PORT_2G_SELECT_MASK;
+		reg |= (0x1 << ETHSCRC_PORT_2G_SELECT_OFFSET);
+		MV_REG_WRITE(MV_ETHCOMP_SW_CONFIG_RESET_CTRL, reg);
+	}
 }
 
-/******************************************************************************
-* mvEthCompPreInit
-*
-* DESCRIPTION:
-*	Perform basic setup that is needed before configuring the eth-complex
-*	registers.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompPreInit(MV_U32 ethCompCfg, MV_U32 smiAddr)
+static void mvEthComplexPortDpClkSrcSet(MV_U32 port, MV_U32 src)
 {
-#if 0
-	mvEthCompMacSetReset(GBE_PORT(0), MV_TRUE);
-	mvEthCompMacSetReset(GBE_PORT(1), MV_TRUE);
-#endif
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
 
-	/* mvEthCompGopPhySmiAutoPollSet(MV_FALSE); <--- does not works according to Eran Maor !!! */
+	src <<= ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port);
+	src &= ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
 
-	mvEthCompGopPhySmiAddrSet(GBE_PORT(0), smiAddr);
-	mvEthCompGopPhySmiAddrSet(GBE_PORT(1), smiAddr);
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
 }
 
-/******************************************************************************
-* mvEthCompPostInit
-*
-* DESCRIPTION:
-*	Perform basic setup that is needed after configuring the eth-complex
-*	registers.
-*
-* INPUT:
-*	ethCompCfg - Ethernet complex configuration.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompPostInit(MV_U32 ethCompCfg)
+static void mvEthComplexGopDevEnable(void)
 {
-	/* mvEthCompGopPhySmiAutoPollSet(MV_FALSE); <--- does not works according to Eran Maor !!! */
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	reg &= ~ETHCGCS_GOP_ENABLE_DEV_MASK;
+	reg |= (0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
 }
 
-/******************************************************************************
-* mvEthCompMacSetAutoNegMode
-*
-* DESCRIPTION:
-* 	None.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompMacSetAutoNegMode(MV_U32 macId)
+static void mvEthComplexSwResetSet(MV_BOOL setReset)
 {
 	MV_U32 reg;
 
-	/*
-	 * When working on AN mode, set the following:
-	 * 'AnFcEn'		=> 'AnFcEnable'
-	 * 'PauseAdv'		=> 'Support_Flow_Control'
-	 * 'AnSpeedEn'		=> 'Enable_Update'
-	 * 'AnDuplexEn'		=> 'AnDuplexEnable'
-	 * 'SetFullDuplex'	=> 'Full_duplex'
-	 */
+	reg = MV_REG_READ(MV_ETHCOMP_SW_CONFIG_RESET_CTRL);
+	reg &= ~ETHSCRC_SWITCH_RESET_MASK;
 
-	reg = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(macId));
+	if (setReset == MV_TRUE)
+		reg |= (0x0 << ETHSCRC_SWITCH_RESET_OFFSET);
+	else
+		reg |= (0x1 << ETHSCRC_SWITCH_RESET_OFFSET);
 
-	/* 'AnFcEn'		=> 'AnFcEnable' */
-	reg &= ~ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
-	reg |= (0x1 << ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_BIT);
+	MV_REG_WRITE(MV_ETHCOMP_SW_CONFIG_RESET_CTRL, reg);
+}
 
-	/* 'PauseAdv'		=> 'Support_Flow_Control' */
-	reg &= ~ETH_FLOW_CONTROL_ADVERTISE_MASK;
-	reg |= (0x1 << ETH_FLOW_CONTROL_ADVERTISE_BIT);
+static void mvEthComplexComPhySelectorSet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
 
-	/* 'AnSpeedEn'		=> 'Enable_Update' */
-	reg &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
-	reg |= (0x1 << ETH_ENABLE_SPEED_AUTO_NEG_BIT);
+	reg = MV_REG_READ(MV_COMMON_PHY_SELECTORS_REG);
+	reg &= ~ETHCPS_COMPHY_SELECTOR_MASK(phy);
 
-	/* 'AnDuplexEn'		=> 'AnDuplexEnable' */
-	reg &= ~ETH_ENABLE_DUPLEX_AUTO_NEG_MASK;
-	reg |= (0x1 << ETH_ENABLE_DUPLEX_AUTO_NEG_BIT);
+	val <<= ETHCPS_COMPHY_SELECTOR_OFFSET(phy);
+	val &= ETHCPS_COMPHY_SELECTOR_MASK(phy);
 
-	/* 'SetFullDuplex'	=> 'Full_duplex' */
-	reg &= ~ETH_SET_FULL_DUPLEX_MASK;
-	reg |= (0x1 << ETH_SET_FULL_DUPLEX_BIT);
+	reg |= val;
 
-	MV_REG_WRITE(ETH_GMAC_AN_CTRL_REG(macId), reg);
+	MV_REG_WRITE(MV_COMMON_PHY_SELECTORS_REG, reg);
 }
 
-/******************************************************************************
-* mvEthCompMac0ToGePhyConfig
-*
-* DESCRIPTION:
-*	This flow assumes Auto Negotionation (AN) between MAC and GE PHY.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompMacToGePhyConfig(MV_U32 port, MV_U32 phy, MV_U32 ethCompCfg)
+static void mvEthComplexGbePhyPowerSet(MV_U32 phy, MV_BOOL setPowerUp)
 {
 	MV_U32 reg;
 
-	if ((ethCompCfg & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0) == 0)
-		return;
-
-	/*----------------------------------------------------------------------
-	 * GE MAC 0 to GE PHY Port 0
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PHY_POWER_DOWN_MASK;
 
-	/* Set 'GbEPhyPort0Source' field in Ethernet Complex Control 0 reg to 0x0 */
-	reg &= ~ETHCC_GBE_PHY_PORT_0_SRC_MASK;
-	reg |= (0x0 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET);
+	if (setPowerUp == MV_TRUE)
+		reg |= (0x0 << ETHCGPC1_PHY_POWER_DOWN_OFFSET);
+	else
+		reg |= (0x3 << ETHCGPC1_PHY_POWER_DOWN_OFFSET);
 
-	/* Set 'GeMAC0Source' field in Ethernet Complex Control 0 reg to 0x2 */
-	reg &= ~ETHCC_GBE_MAC0_SRC_MASK;
-	reg |= (0x2 << ETHCC_GBE_MAC0_SRC_OFFSET);
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
 
-	/* Set 'SwitchPort6Source' field in Ethernet Complex Control 0 to 0x0 'UC' */
-	reg &= ~ETHCC_SW_PORT_6_SRC_MASK;
-	reg |= (0x0 << ETHCC_SW_PORT_6_SRC_OFFSET);
+static void mvEthComplexGbePhyPowerCycle(MV_U32 phy)
+{
+	mvEthComplexGbePhyPowerSet(phy, MV_FALSE);
+	mvOsDelay(100);
+	mvEthComplexGbePhyPowerSet(phy, MV_TRUE);
+}
 
-	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+static void mvEthComplexGbePhyPdConfigEdetASet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
 
-	/*----------------------------------------------------------------------
-	 * Set 'Port[0/1]DpClkSource' field in Ports Group Control and Status to 0x1
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
-	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
-	reg |= (0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port));
-	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PD_CFG_EDED_A_MASK;
 
-	/*----------------------------------------------------------------------
-	 * GE PHY configuration
-	 */
+	val <<= ETHCGPC1_PD_CFG_EDED_A_OFFSET;
+	val &= ETHCGPC1_PD_CFG_EDED_A_MASK;
 
-	/* Set PHY SMI address: set PcsPhyAddress to PHY SMI address.
-	 * Note: it is set in pre-init function.
-	 */
+	reg |= val;
 
-	/* Set PdConfigEdetA field */
-	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
-	reg &= ~ETHCGPC1_PD_CFG_EDED_A_MASK;
-	reg |= (0x0 << ETHCGPC1_PD_CFG_EDED_A_OFFSET);
 	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
+
+static void mvEthComplexGbePhyPsEnaXcSSet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
 
-	/* Set PsEnaXcS field */
 	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
 	reg &= ~ETHCGPC1_PS_ENA_XCS_MASK;
-	reg |= (0x0 << ETHCGPC1_PS_ENA_XCS_OFFSET);
+
+	val <<= ETHCGPC1_PS_ENA_XCS_OFFSET;
+	val &= ETHCGPC1_PS_ENA_XCS_MASK;
+
+	reg |= val;
+
 	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
 
-	mvOsDelay(200);
+static void mvEthComplexGbePhyResetSet(MV_BOOL setReset)
+{
+	MV_U32 reg;
 
-	/* Set 'DPLLReset' field in Quad Gbe PHY Common Control and Status
-	 * register to 'Normal Operation'.
-	 */
 	reg = MV_REG_READ(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG);
+
 	reg &= ~ETHQPCS_DPLL_RESET_MASK;
-	reg |= (0x1 << ETHQPCS_DPLL_RESET_OFFSET);
-	MV_REG_WRITE(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG, reg);
+	reg &= ~ETHQPCS_RESET_MASK;
 
-	mvOsDelay(20);
+	if (setReset == MV_TRUE) {
+		reg |= (0x0 << ETHQPCS_RESET_OFFSET);
+		reg |= (0x0 << ETHQPCS_DPLL_RESET_OFFSET);
+	} else {
+		reg |= (0x1 << ETHQPCS_RESET_OFFSET);
+		reg |= (0x1 << ETHQPCS_DPLL_RESET_OFFSET);
+	}
 
-	/* Set 'Reset' field in Quad Gbe PHY Common Control and Status
-	 * register to 'Normal'.
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG);
-	reg &= ~ETHQPCS_RESET_MASK;
-	reg |= (0x1 << ETHQPCS_RESET_OFFSET);
 	MV_REG_WRITE(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG, reg);
+}
 
-	/*----------------------------------------------------------------------
-	 * GOP init
-	 */
-
-	/* GOP works NOT in SGMII, ==> set 'PcsEn' field in
-	 * Port MAC Control Register2 to 'Not_working'.
-	 */
-	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
-	reg &= ETH_GMAC_PCS_ENABLE_MASK;
-	reg |= (0 << ETH_GMAC_PCS_ENABLE_BIT);
-	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
-
-	/*
-	 * When working with GbE PHY:
-	 * Set 'PeriodicXonEn' field in Port MAC Control Register 1 to 'Disabled'.
-	 */
-	reg = MV_REG_READ(ETH_GMAC_CTRL_1_REG(port));
-	reg &= ~ETH_GMAC_PERIODIC_XON_EN_MASK;
-	reg |= (0x0 << ETH_GMAC_PERIODIC_XON_EN_BIT);
-	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), reg);
-
-	/*
-	 * Working in Auto Negotiation (AN) mode
-	 */
-	mvEthCompMacSetAutoNegMode(port);
-
-	/*
-	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
-	 */
-	mvEthCompMacSetReset(port, MV_FALSE);
+static void mvEthComplexGopInit(int port, int isSgmii, int isPeriodicXon, int isAN)
+{
+	mvEthPortSgmiiSet(port, isSgmii);
+	mvEthPortPeriodicXonSet(port, isPeriodicXon);
+
+	if (isAN)
+		mvEthPortLinkSpeedFlowCtrl(port, MV_ETH_SPEED_AN, 0);
+	else
+		mvEthPortLinkSpeedFlowCtrl(port, MV_ETH_SPEED_1000, 1);
+
+	mvEthPortResetSet(port, MV_FALSE);
 }
 
-/******************************************************************************
-* mvEthCompMacRgmii1Config
-*
-* DESCRIPTION:
-* 	None.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	None.
-*******************************************************************************/
-static void mvEthCompMacRgmii1Config(MV_U32 port, MV_U32 ethCompCfg)
+static void mvEthComplexMacToSwPort(MV_U32 port, MV_U32 swPort,
+				    MV_ETH_PORT_SPEED speed)
 {
-	MV_U32 reg;
+	MV_U32 src;
 
-	if ((ethCompCfg & MV_ETHCOMP_GE_MAC1_2_RGMII1) == 0)
-		return;
+	mvEthComplexSwResetSet(MV_FALSE);
+	mvOsDelay(200);
 
-	/*----------------------------------------------------------------------
-	 * Connect GE MAC 1 to RGMII 1
-	 */
+	src = mvEthComplexSwPortSrcCalc(swPort, ETHC_SW_PORT_SRC_GBE_MAC);
+	mvEthComplexSwPortSrcSet(swPort, src);
+	mvEthComplexGbePortSrcSet(port, 0x1);
 
-	/*
-	 * Set 'GeMAC1Source' field in Ethernet Complex Control 0 reg to 0x0, ==>
-	 * GbE MAC 1 is connected to an MPP (RGMII).
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
-	reg &= ~ETHCC_GBE_MAC1_SRC_MASK;
-	reg |= (0x0 << ETHCC_GBE_MAC1_SRC_OFFSET);
-	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+	if (port == 0 && swPort == 6)
+		mvEthComplexGbeToSwitchSpeedSet(speed);
+	else
+		mvEthComplexPortDpClkSrcSet(port, 0x1);
 
-	/*
-	 * Set MPP[35:24] to option 0x2.
-	 */
-
-	/* Read MPP[31:24] and config MPP[31:24] to option 0x2 */
-	reg = MV_REG_READ(MPP_CONTROL_REG(3));
-	reg &= ~0xffffffff; /* each MPP stands for 4 bits */
-	reg |= 0x22222222;
-	MV_REG_WRITE(MPP_CONTROL_REG(3), reg);
-
-	/* Read MPP[32:39] and config MPP[35:32] to option 0x2 */
-	reg = MV_REG_READ(MPP_CONTROL_REG(4));
-	reg &= ~0xffff; /* each MPP stands for 4 bits */
-	reg |= 0x2222;
-	MV_REG_WRITE(MPP_CONTROL_REG(4), reg);
-
-	/*----------------------------------------------------------------------
-	 * Set 'Port[0/1]DpClkSource' field in Ports Group Control and Status to 0x1
-	 */
-	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_FALSE);
+	mvEthComplexComPhySelectorSet(2, 0x1);
+}
 
-	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
-	reg |= (0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port));
+static void mvEthComplexSwPortToRgmii(MV_U32 swPort, MV_U32 port)
+{
+	mvOsPrintf("%s: Not implemented.\n", __func__);
+}
 
-	reg &= ~ETHCGCS_GOP_ENABLE_DEV_MASK;
-	reg |= (0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET);
+static void mvEthComplexXponMacToPonSerdes(void)
+{
+	mvOsPrintf("%s: Not implemented.\n", __func__);
+}
 
-	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+static void mvEthComplexMacToGbePhy(MV_U32 port, MV_U32 phy, MV_U32 phyAddr)
+{
+	mvEthComplexGbePhySrcSet(phy, 0x0);
+	mvEthComplexGbePortSrcSet(port, 0x2);
+
+	if (port == 0)
+		mvEthComplexSwPortSrcSet(6, 0x0);
+
+	mvEthComplexPortDpClkSrcSet(port, 0x1);
+	mvEthComplexGbePhyPdConfigEdetASet(phy, 0x0);
+	mvEthComplexGbePhyPsEnaXcSSet(phy, 0x0);
+	mvEthComplexGbePhyResetSet(MV_FALSE);
+	mvEthComplexComPhySelectorSet(2, 0x1);
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_TRUE);
+}
 
-	/*----------------------------------------------------------------------
-	 * GOP init
-	 */
-
-	/* GOP works NOT in SGMII, ==> set 'PcsEn' field in
-	 * Port MAC Control Register2 to 'Not_working'.
-	 */
-	reg = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
-	reg &= ETH_GMAC_PCS_ENABLE_MASK;
-	reg |= (0 << ETH_GMAC_PCS_ENABLE_BIT);
-	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), reg);
-
-	/*
-	 * Working in Auto Negotiation (AN) mode
-	 */
-	mvEthCompMacSetAutoNegMode(port);
-
-	/*
-	 * Set 'PortMACReset' in Port MAC Control Register 2 to 'Port_MAC_Not_reset'.
-	 */
-	mvEthCompMacSetReset(port, MV_FALSE);
+static void mvEthComplexMacToComPhy(MV_U32 port, MV_U32 comPhy)
+{
+	mvOsPrintf("%s: Not implemented.\n", __func__);
 }
 
-/******************************************************************************
-* mvEthCompInit
-*
-* DESCRIPTION:
-*	Initialize the ethernet complex according to the boardEnv setup.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-MV_STATUS mvEthCompInit(void)
+static void mvEthComplexMac1ToPonSerdes(MV_U32 port)
+{
+	mvOsPrintf("%s: Not implemented.\n", __func__);
+}
+
+static void mvEthComplexMacToRgmii(MV_U32 port, MV_U32 phy)
+{
+	mvEthComplexGbePortSrcSet(port, 0x0);
+	mvEthComplexPortDpClkSrcSet(port, 0x1);
+	mvEthComplexGopDevEnable();
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_TRUE);
+}
+
+static void mvEthComplexSwPortToGbePhy(MV_U32 swPort, MV_U32 phy)
 {
-	MV_U32 ethCompCfg = mvBoardEthComplexConfigGet();
+	mvEthComplexSwPortSrcSet(swPort, 0x1);
+	mvEthComplexGbePhySrcSet(phy, 0x1);
+	mvEthComplexGbePhyResetSet(MV_FALSE);
+	mvEthComplexGbePhyPowerCycle(phy);
+}
 
-	if (gEthComplexSkipInit == MV_TRUE)
-		return MV_OK;
+MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig)
+{
+	MV_U32 c = ethCompConfig;
 
-	mvEthCompPreInit(ethCompCfg, mvBoardPhyAddrGet(GBE_PORT(0)));
+	mvEthComplexGopDevEnable();
 
-	/* MAC1 to RGMII1 */
-	mvEthCompMacRgmii1Config(GBE_PORT(1), ethCompCfg);
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		mvEthComplexMacToSwPort(0, 6, MV_ETH_SPEED_1000);
 
-	/* MAC0 to GE PHY Port0 */
-	mvEthCompMacToGePhyConfig(GBE_PORT(0), GE_PHY(0), ethCompCfg);
+	if (c & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0)
+		mvEthComplexMacToGbePhy(0, 0, mvBoardPhyAddrGet(0));
 
-	/*  Reset the switch after all configurations are done. */
-	mvEthCompSwitchReset(ethCompCfg);
+	if (c & MV_ETHCOMP_GE_MAC0_2_RGMII0)
+		mvEthComplexMacToRgmii(0, 0);
 
-	mvEthCompPostInit(ethCompCfg);
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_1)
+		mvEthComplexMacToComPhy(0, 1);
 
-	return MV_OK;
-}
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_2)
+		mvEthComplexMacToComPhy(0, 2);
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_3)
+		mvEthComplexMacToComPhy(0, 3);
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
+		mvEthComplexMacToSwPort(1, 4, MV_ETH_SPEED_1000);
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
+		mvEthComplexMacToGbePhy(1, 3, mvBoardPhyAddrGet(1));
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_RGMII1)
+		mvEthComplexMacToRgmii(1, 1);
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES)
+		mvEthComplexMac1ToPonSerdes(1);
+
+	if (c & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
+		mvEthComplexSwPortToGbePhy(3, 3);
+
+	if (c & MV_ETHCOMP_SW_P4_2_RGMII0)
+		mvEthComplexSwPortToRgmii(4, 0);
+
+	if (c & MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES)
+		mvEthComplexXponMacToPonSerdes();
 
-/******************************************************************************
-* mvEthCompChangeMode
-*
-* DESCRIPTION:
-*	Change the ethernet complex configuration at runtime.
-*	Meanwhile the function supports only the following mode changes:
-*		- Moving the switch between MAC0 & MAC1.
-*		- Connect / Disconnect GE-PHY to MAC1.
-*		- Connect / Disconnect RGMII-B to MAC0.
-*
-* INPUT:
-*	oldCfg	- The old ethernet complex configuration.
-*	newCfg	- The new ethernet complex configuration to switch to.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*	MV_OK on success,
-*	MV_ERROR otherwise.
-*******************************************************************************/
-static MV_STATUS mvEthCompChangeMode(MV_U32 oldCfg, MV_U32 newCfg)
-{
 	return MV_OK;
 }
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
index 04be499..ce96e25 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.h
@@ -68,71 +68,99 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "mvSysEthConfig.h"
 
-/*
+/*******************************************************************************
  * Ports Group Control and Status
  */
 #define MV_ETHCOMP_GOP_CTRL_STAT_REG			MV_ETH_COMPLEX_BASE
-#define     ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port)	(port == GBE_PORT(0) ? 13 : 14)
+
+#define     ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port)	((port == 0) ? 13 : 14)
 #define     ETHCGCS_PORT_DP_CLK_SRC_MASK(port)		(0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port))
+
 #define     ETHCGCS_GOP_ENABLE_DEV_OFFSET		19
 #define     ETHCGCS_GOP_ENABLE_DEV_MASK			(0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET)
 
-/*
+/*******************************************************************************
  * Ethernet Complex Control 0
  */
 #define MV_ETHCOMP_CTRL_REG				(MV_ETH_COMPLEX_BASE + 0x10)
-#define     ETHCC_SW_PORT_0_SRC_OFFSET			4
-#define     ETHCC_SW_PORT_0_SRC_MASK			(0x1 << ETHCC_SW_PORT_0_SRC_OFFSET)
-#define     ETHCC_SW_PORT_3_SRC_OFFSET			5
-#define     ETHCC_SW_PORT_3_SRC_MASK			(0x1 << ETHCC_SW_PORT_3_SRC_OFFSET)
-#define     ETHCC_SW_PORT_4_SRC_OFFSET			6
-#define     ETHCC_SW_PORT_4_SRC_MASK			(0x1 << ETHCC_SW_PORT_4_SRC_OFFSET)
-#define     ETHCC_SW_PORT_6_SRC_OFFSET			7
-#define     ETHCC_SW_PORT_6_SRC_MASK			(0x1 << ETHCC_SW_PORT_6_SRC_OFFSET)
-#define     ETHCC_GBE_MAC0_SRC_OFFSET			10
-#define     ETHCC_GBE_MAC0_SRC_MASK			(0x3 << ETHCC_GBE_MAC0_SRC_OFFSET)
-#define     ETHCC_GBE_MAC1_SRC_OFFSET			12
-#define     ETHCC_GBE_MAC1_SRC_MASK			(0x3 << ETHCC_GBE_MAC1_SRC_OFFSET)
-#define     ETHCC_GBE_PHY_PORT_0_SRC_OFFSET		14
-#define     ETHCC_GBE_PHY_PORT_0_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
-#define     ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET		15
-#define     ETHCC_GBE_PHY_PORT_1_SMI_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_1_SMI_SRC_OFFSET)
-#define     ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET		16
-#define     ETHCC_GBE_PHY_PORT_2_SMI_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_2_SMI_SRC_OFFSET)
-#define     ETHCC_GBE_PHY_PORT_3_SRC_OFFSET		17
-#define     ETHCC_GBE_PHY_PORT_3_SRC_MASK		(0x1 << ETHCC_GBE_PHY_PORT_0_SRC_OFFSET)
+
+#define     ETHCC_SW_PORT_SRC_OFFSET(port)		(port == 0 ? 4 : (port == 3 ? 5 : \
+							(port == 4 ? 6 : (port == 6 ? 7 : 4))))
+#define     ETHCC_SW_PORT_SRC_MASK(port)		(0x1 << ETHCC_SW_PORT_SRC_OFFSET(port))
+
+enum mvSwPortSrc {
+	ETHC_SW_PORT_SRC_NC,
+	ETHC_SW_PORT_SRC_GBE_MAC,
+	ETHC_SW_PORT_SRC_MPP,
+	ETHC_SW_PORT_SRC_GBE_PHY,
+};
+
+#define     ETHCC_GBE_MAC_SRC_OFFSET(port)		(port == 0 ? 10 : (port == 1 ? 12 : 10))
+#define     ETHCC_GBE_MAC_SRC_MASK(port)		(0x3 << ETHCC_GBE_MAC_SRC_OFFSET(port))
+
+#define     ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy)	((phy >= 0 && phy <= 3) ? 14 + phy : 14)
+#define     ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy)	(0x1 << ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy))
+
 #define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET	18
 #define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_MASK		(0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET)
+
 #define     ETHCC_LOOPBACK_PORT_SPEED_OFFSET		19
 #define     ETHCC_LOOPBACK_PORT_SPEED_MASK		(0x1 << ETHCC_LOOPBACK_PORT_SPEED_OFFSET)
 
-/*
+/*******************************************************************************
+ * Switch Configuration and Reset Control
+ */
+#define MV_ETHCOMP_SW_CONFIG_RESET_CTRL			(MV_ETH_COMPLEX_BASE + 0x30)
+
+#define     ETHSCRC_SWITCH_RESET_OFFSET			0
+#define     ETHSCRC_SWITCH_RESET_MASK			(0x1 << ETHSCRC_SWITCH_RESET_OFFSET)
+
+#define     ETHSCRC_PORT_2G_SELECT_OFFSET		14
+#define     ETHSCRC_PORT_2G_SELECT_MASK			(0x1 << ETHSCRC_PORT_2G_SELECT_OFFSET)
+
+/*******************************************************************************
  * GbE PHY <<%n>> Control 0.
  * 0x000189A0 + n*4: where n (0-3) represents GPHY_Num.
  */
 #define MV_ETHCOMP_GBE_PHY_CTRL0_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xA0 + (phy * 0x4))
+
 #define     ETHCGPC0_PCS_PHY_ADDR_OFFSET		13
 #define     ETHCGPC0_PCS_PHY_ADDR_MASK			(0x1F << ETHCGPC0_PCS_PHY_ADDR_OFFSET)
 
-/*
+/*******************************************************************************
  * GbE PHY <<%n>> Control 1.
  * 0x000189B0 + n*4: where n (0-3) represents GPHY_Num.
  */
 #define MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xB0 + (phy * 0x4))
-#define     ETHCGPC1_PD_CFG_EDED_A_OFFSET		14
-#define     ETHCGPC1_PD_CFG_EDED_A_MASK		(0x7 << ETHCGPC1_PD_CFG_EDED_A_OFFSET)
+
+#define     ETHCGPC1_PHY_POWER_DOWN_OFFSET		10
+#define     ETHCGPC1_PHY_POWER_DOWN_MASK		(0x3 << ETHCGPC1_PHY_POWER_DOWN_OFFSET)
+
 #define     ETHCGPC1_PS_ENA_XCS_OFFSET			12
 #define     ETHCGPC1_PS_ENA_XCS_MASK			(0x3 << ETHCGPC1_PS_ENA_XCS_OFFSET)
 
-/*
+#define     ETHCGPC1_PD_CFG_EDED_A_OFFSET		14
+#define     ETHCGPC1_PD_CFG_EDED_A_MASK			(0x7 << ETHCGPC1_PD_CFG_EDED_A_OFFSET)
+
+/*******************************************************************************
  * Quad GbE PHY Common Control and Status
  */
 #define MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG		(MV_ETH_COMPLEX_BASE + 0xD0)
+
 #define     ETHQPCS_RESET_OFFSET			0
 #define     ETHQPCS_RESET_MASK				(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
+
 #define     ETHQPCS_DPLL_RESET_OFFSET			4
 #define     ETHQPCS_DPLL_RESET_MASK			(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
 
-MV_STATUS mvEthCompInit(MV_VOID);
+/*******************************************************************************
+ * Common PHYs Selectors
+ */
+#define MV_COMMON_PHY_SELECTORS_REG			MV_COMMON_PHY_REGS_OFFSET
+
+#define     ETHCPS_COMPHY_SELECTOR_OFFSET(phy)		(phy)
+#define     ETHCPS_COMPHY_SELECTOR_MASK(phy)		(0x1 << ETHCPS_COMPHY_SELECTOR_OFFSET(phy))
+
+MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig);
 
 #endif /* __INCmvCtrlEthCompLibh */
diff --git a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
index 2e9db88..e3cb34f 100644
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.c
@@ -172,14 +172,12 @@ MV_STATUS mvEthPhyInit(MV_U32 ethPortNum, MV_BOOL eeeEnable)
 		break;
 	case MV_PHY_88E154X:
 	case MV_PHY_88E1543:
-	case MV_PHY_88E1340M: /* BUG IN THE 1543 IS RETURNING THE 1340 ID FOR PORTS 3-4 */
-	/* case MV_PHY_KW2_INTERNAL_GE:
-		if (ethPortNum != ((MV_U32) -1))
-			mvEthInternalGEPhyBasicInit(ethPortNum);
-		else
-	*/
-			mvEth1540PhyBasicInit(ethPortNum, eeeEnable);
+	case MV_PHY_88E1340M:
+		mvEth1540PhyBasicInit(ethPortNum, eeeEnable);
 		break;
+	case MV_PHY_ALP_INTERNAL_QUAD_GE:
+		if (ethphyHalData.ctrlFamily == MV_88F66X0)
+			mvEthInternalQuadGEPhyBasicInit();
 	case MV_PHY_88E1340S:
 	case MV_PHY_88E1340:
 		mvEth1340PhyBasicInit();
@@ -823,7 +821,28 @@ MV_VOID		mvEthE1111PhyBasicInit(MV_U32 ethPortNum)
 }
 
 /*******************************************************************************
-* mvEthE1112PhyBasicInit -
+* mvEthInternalQuadGEPhyBasicInit -
+*
+* DESCRIPTION:
+*	Do a basic Init to the Phy , including reset
+*
+* INPUT:
+*       NONE.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None
+*
+*******************************************************************************/
+MV_VOID mvEthInternalQuadGEPhyBasicInit(MV_VOID)
+{
+	/* No init needed */
+}
+
+/*******************************************************************************
+* mvEthE1112PhyBasicInit
 *
 * DESCRIPTION:
 *	Do a basic Init to the Phy , including reset
diff --git a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
index 2706820..363f708 100644
--- a/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
+++ b/arch/arm/plat-armada/mv_hal/eth-phy/mvEthPhy.h
@@ -84,12 +84,12 @@ extern "C" {
 #define MV_PHY_88E1111  0xC      /* E1111, E1115 */
 #define MV_PHY_88E114X  0xD
 #define MV_PHY_88E1181  0xE
-#define MV_PHY_88E1340S 0x1C    /* 88E1340S */
+#define MV_PHY_88E1340S 0x1C     /* 88E1340S */
 #define MV_PHY_88E1512  0x1D
-#define MV_PHY_88E1340  0x1E    /* 88E1340/x0a */
+#define MV_PHY_88E1340  0x1E     /* 88E1340/x0a */
 #define MV_PHY_88E1543  0x2A     /* 88E15453 */
 #define MV_PHY_88E154X  0x2B     /* 88E1545M */
-#define MV_PHY_88E1340M 0x1F    /* 88E1340M/x0a */
+#define MV_PHY_88E1340M 0x1F     /* 88E1340M/x0a */
 #define MV_PHY_88E1116R 0x24
 #define MV_PHY_88E1116  0x21     /* E1116, E1116R */
 #define MV_PHY_88E3016_88E3019  0x22     /* E3015, E3016, E3018, 88E3019 */
@@ -97,8 +97,9 @@ extern "C" {
 #define MV_PHY_88E1149R 0x25
 #define MV_PHY_88E1119R 0x28    /* 88E1119R */
 #define MV_PHY_88E1310  0x29    /* 88E1310 */
-#define MV_PHY_KW2_INTERNAL_GE  0x2b
-#define MV_PHY_KW2_INTERNAL_3FE 0x26
+#define MV_PHY_KW2_INTERNAL_GE		0x2b
+#define MV_PHY_KW2_INTERNAL_3FE		0x26
+#define MV_PHY_ALP_INTERNAL_QUAD_GE	0x0
 
 #define MV_IS_MARVELL_OUI(_reg2, _reg3)		\
 	(((_reg2) == 0x0141) && (((_reg3)&0xFC00) == 0x0C00))
@@ -112,6 +113,8 @@ typedef struct {
 	MV_U32		ethPhySmiReg;		/* Ethernet unit PHY SMI register offset */
 	MV_BOOL		isSgmii[MV_ETH_MAX_PORTS];
 	MV_U32		QuadPhyPort0[MV_ETH_MAX_PORTS];		/* quad phy port 0 address */
+	MV_U16		ctrlModel;
+	MV_U32		ctrlFamily;
 } MV_ETHPHY_HAL_DATA;
 
 MV_STATUS 	mvEthPhyHalInit(MV_ETHPHY_HAL_DATA *halData);
@@ -129,6 +132,7 @@ MV_STATUS	mvEthPhyPrintStatus(MV_U32 phyAddr);
 MV_STATUS	mvEthPhyAdvertiseSet(MV_U32 phyAddr, MV_U16 advertise);
 MV_STATUS	mvEthPhyAdvertiseGet(MV_U32 phyAddr, MV_U16 *advertise);
 
+MV_VOID		mvEthInternalQuadGEPhyBasicInit(MV_VOID);
 MV_VOID		mvEthE1111PhyBasicInit(MV_U32 ethPortNum);
 MV_VOID		mvEthE1112PhyBasicInit(MV_U32 ethPortNum);
 MV_VOID		mvEthE1112PhyPowerDown(MV_U32 ethPortNum);
@@ -146,10 +150,6 @@ MV_VOID		mvEth1540PhyBasicInit(MV_U32 ethPortNum, MV_BOOL eeeEnable);
 MV_VOID		mvEth1340PhyBasicInit(void);
 MV_VOID		mvEthE1512PhyBasicInit(MV_U32 ethPortNum);
 
-/* MV_VOID		mvEthInternal3FEPhyBasicInit(MV_U32 port); */
-
-
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index 0ab0ec4..eb0398d 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -76,9 +76,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "pp2/common/mvPp2Common.h"
 #include "pp2/prs/mvPp2PrsHw.h"
 
-#define GBE_PORT(n)					(n)
-#define GE_PHY(n)					(n)
-
 #define PP2_CPU_CODE_IS_RX_SPECIAL(cpu_code)		((cpu_code) & RI_CPU_CODE_RX_SPEC_VAL)
 
 static inline int mvPp2IsRxSpecial(MV_U16 parser_info)
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
index ee9c2f8..149bde1 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
@@ -79,11 +79,11 @@ void mvEthPortDisable(int port)
 	MV_U32 regVal;
 
 	regVal = MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
-	regVal &= ~(ETH_GMAC_PORT_EN_MASK);
+	regVal &= ~ETH_GMAC_PORT_EN_MASK;
 	MV_REG_WRITE(ETH_GMAC_CTRL_0_REG(port), regVal);
 }
 
-static void mvEthPortRgmiiSet(int port, int enable)
+void mvEthPortRgmiiSet(int port, int enable)
 {
 	MV_U32  regVal;
 
@@ -96,7 +96,7 @@ static void mvEthPortRgmiiSet(int port, int enable)
 	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), regVal);
 }
 
-static void mvEthPortSgmiiSet(int port, int enable)
+void mvEthPortSgmiiSet(int port, int enable)
 {
 	MV_U32 regVal;
 
@@ -109,6 +109,20 @@ static void mvEthPortSgmiiSet(int port, int enable)
 	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), regVal);
 }
 
+void mvEthPortPeriodicXonSet(int port, int enable)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_1_REG(port));
+
+	if (enable)
+		regVal |= ETH_GMAC_PERIODIC_XON_EN_MASK;
+	else
+		regVal &= ~ETH_GMAC_PERIODIC_XON_EN_MASK;
+
+	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), regVal);
+}
+
 void mvEthPortLbSet(int port, int isGmii, int isPcsEn)
 {
 	MV_U32 regVal;
@@ -128,23 +142,32 @@ void mvEthPortLbSet(int port, int isGmii, int isPcsEn)
 	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), regVal);
 }
 
-void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
+void mvEthPortResetSet(int port, MV_BOOL setReset)
 {
 	MV_U32 regVal;
 
-	mvEthPortSgmiiSet(port, isSgmii);
-	mvEthPortRgmiiSet(port, isRgmii);
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	regVal &= ~ETH_GMAC_PORT_RESET_MASK;
 
-	regVal = MV_REG_READ(ETH_GMAC_CTRL_1_REG(port));
-	regVal &= ~ETH_GMAC_PERIODIC_XON_EN_MASK;
-	MV_REG_WRITE(ETH_GMAC_CTRL_1_REG(port), regVal);
+	if (setReset == MV_TRUE)
+		regVal |= ETH_GMAC_PORT_RESET_MASK;
+	else
+		regVal &= ~ETH_GMAC_PORT_RESET_MASK;
 
-	/* Cancel Port Reset */
-	regVal = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
-	regVal &= (~ETH_GMAC_PORT_RESET_MASK);
 	MV_REG_WRITE(ETH_GMAC_CTRL_2_REG(port), regVal);
-	while ((MV_REG_READ(ETH_GMAC_CTRL_2_REG(port)) & ETH_GMAC_PORT_RESET_MASK) != 0)
-		continue;
+
+	if (setReset == MV_FALSE)
+		while (MV_REG_READ(ETH_GMAC_CTRL_2_REG(port) &
+		       ETH_GMAC_PORT_RESET_MASK))
+				;
+}
+
+void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
+{
+	mvEthPortSgmiiSet(port, isSgmii);
+	mvEthPortRgmiiSet(port, isRgmii);
+	mvEthPortPeriodicXonSet(port, MV_FALSE);
+	mvEthPortResetSet(port, MV_FALSE);
 }
 
 void mvEthPortPowerDown(int port)
@@ -204,6 +227,7 @@ MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus)
 
 	return MV_OK;
 }
+
 /******************************************************************************/
 /*                          Port Configuration functions                      */
 /******************************************************************************/
@@ -254,10 +278,10 @@ void mvEthMaxRxSizeSet(int port, int maxRxSize)
 *******************************************************************************/
 MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down)
 {
-	MV_U32	regVal;
+	MV_U32 regVal;
 
 	/* Can't force link pass and link fail at the same time */
-	if ((force_link_up) && (force_link_down))
+	if (force_link_up && force_link_down)
 		return MV_BAD_PARAM;
 
 	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
@@ -274,7 +298,7 @@ MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force
 
 	MV_REG_WRITE(ETH_GMAC_AN_CTRL_REG(portNo), regVal);
 
-    return MV_OK;
+	return MV_OK;
 }
 
 /*******************************************************************************
@@ -296,7 +320,7 @@ MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_D
 	MV_U32 regVal;
 
 	/* Check validity */
-	if ((speed == MV_ETH_SPEED_1000) && (duplex == MV_ETH_DUPLEX_HALF))
+	if (speed == MV_ETH_SPEED_1000 && duplex == MV_ETH_DUPLEX_HALF)
 		return MV_BAD_PARAM;
 
 	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
@@ -309,7 +333,6 @@ MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_D
 	case MV_ETH_SPEED_1000:
 		regVal &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
 		regVal |= ETH_SET_GMII_SPEED_1000_MASK;
-		regVal &= ~ETH_SET_MII_SPEED_100_MASK;
 		/* the 100/10 bit doesn't matter in this case */
 		break;
 	case MV_ETH_SPEED_100:
@@ -495,6 +518,40 @@ MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl)
 	return MV_OK;
 }
 
+MV_STATUS mvEthPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
+				     int forceLinkUp)
+{
+	if (forceLinkUp) {
+		if (mvEthSpeedDuplexSet(port, speed, MV_ETH_DUPLEX_FULL)) {
+			mvOsPrintf("mvEthSpeedDuplexSet failed\n");
+			return MV_FAIL;
+		}
+		if (mvEthFlowCtrlSet(port, MV_ETH_FC_ENABLE)) {
+			mvOsPrintf("mvEthFlowCtrlSet failed\n");
+			return MV_FAIL;
+		}
+		if (mvEthForceLinkModeSet(port, 1, 0)) {
+			mvOsPrintf("mvEthForceLinkModeSet failed\n");
+			return MV_FAIL;
+		}
+	} else {
+		if (mvEthForceLinkModeSet(port, 0, 0)) {
+			mvOsPrintf("mvEthForceLinkModeSet failed\n");
+			return MV_FAIL;
+		}
+		if (mvEthSpeedDuplexSet(port, MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN)) {
+			mvOsPrintf("mvEthSpeedDuplexSet failed\n");
+			return MV_FAIL;
+		}
+		if (mvEthFlowCtrlSet(port, MV_ETH_FC_AN_SYM)) {
+			mvOsPrintf("mvEthFlowCtrlSet failed\n");
+			return MV_FAIL;
+		}
+	}
+
+	return MV_OK;
+}
+
 /******************************************************************************/
 /*                         PHY Control Functions                              */
 /******************************************************************************/
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
index 4518193..6e8778e 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
@@ -74,7 +74,8 @@ typedef enum {
 	MV_ETH_SPEED_AN,
 	MV_ETH_SPEED_10,
 	MV_ETH_SPEED_100,
-	MV_ETH_SPEED_1000
+	MV_ETH_SPEED_1000,
+	MV_ETH_SPEED_2000,
 } MV_ETH_PORT_SPEED;
 
 typedef enum {
@@ -112,7 +113,8 @@ static INLINE void mvEthIsrSummaryMask(MV_VOID)
 
 static INLINE void mvEthIsrSummaryUnmask(MV_VOID)
 {
-	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, ETH_ISR_SUM_PORT0_MASK | ETH_ISR_SUM_PORT1_MASK | 0x20/*magic bit*/);
+	MV_REG_WRITE(ETH_ISR_SUM_MASK_REG, ETH_ISR_SUM_PORT0_MASK |
+		     ETH_ISR_SUM_PORT1_MASK | 0x20 /* magic bit */);
 }
 
 static INLINE MV_U32 mvEthIsrSummaryCauseGet(MV_VOID)
@@ -137,9 +139,13 @@ static INLINE MV_VOID mvEthPortIsrUnmask(int port)
 
 void mvEthPortEnable(int port);
 void mvEthPortDisable(int port);
+void mvEthPortRgmiiSet(int port, int enable);
+void mvEthPortSgmiiSet(int port, int enable);
+void mvEthPortPeriodicXonSet(int port, int enable);
 MV_BOOL mvEthPortIsLinkUp(int port);
 MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus);
 void mvEthPortLbSet(int port, int isGmii, int isPcsEn);
+void mvEthPortResetSet(int port, MV_BOOL setReset);
 void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii);
 void mvEthPortPowerDown(int port);
 
@@ -152,6 +158,8 @@ MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_D
 MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex);
 MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl);
 MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl);
+MV_STATUS mvEthPortLinkSpeedFlowCtrl(int port, MV_ETH_PORT_SPEED speed,
+				     int forceLinkUp);
 
 /******************************************************************************/
 /*                         PHY Control Functions                              */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
index c528be2..51b528e3 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
@@ -133,6 +133,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define ETH_ENABLE_SPEED_AUTO_NEG_BIT          7
 #define ETH_ENABLE_SPEED_AUTO_NEG_MASK         (1 << ETH_ENABLE_SPEED_AUTO_NEG_BIT)
 
+#define ETH_ENABLE_FLOW_CTRL_AUTO_NEG_BIT      11
+#define ETH_ENABLE_FLOW_CTRL_AUTO_NEG_MASK     (1 << ETH_ENABLE_FLOW_CTRL_AUTO_NEG_BIT)
+
 /* TODO: I keep this bit even though it's not listed in Cider */
 #define ETH_SET_FLOW_CONTROL_BIT               8
 #define ETH_SET_FLOW_CONTROL_MASK              (1 << ETH_SET_FLOW_CONTROL_BIT)
-- 
1.7.5.4

