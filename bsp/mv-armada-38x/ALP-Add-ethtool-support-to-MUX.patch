From 098227bc28b44c6a92638f5c7c94750b94324676 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Thu, 25 Jul 2013 14:16:11 +0300
Subject: [PATCH 0899/1825] ALP: Add ethtool support to MUX

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6a00afcc142cb25bb6a4c9a0b49d56afe6cd1a36

	- Add ethtool support to mux driver
	- change sysfs commands
	- Add new sysfs command for port dump

Change-Id: I61677e34f3f9ff4652c3e78ac62f279ce9654134
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2868
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile |    2 +-
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |  145 +++++++++-----
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.h          |    2 +
 .../mv_drivers_lsp/mv_mux/mv_mux_sysfs.c           |   68 ++++---
 .../mv_drivers_lsp/mv_mux/mv_mux_tool.c            |  221 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_mux/mv_mux_tool.h            |   38 ++++
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |   17 ++
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |    1 +
 8 files changed, 412 insertions(+), 82 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
index ff57e5a..4423f1e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/Makefile
@@ -5,4 +5,4 @@ ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-obj-y	+= mv_mux_netdev.o mv_mux_sysfs.o
+obj-y	+= mv_mux_netdev.o mv_mux_sysfs.o mv_mux_tool.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index 8571a9a..cbd7563 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -30,10 +30,11 @@ disclaimer.
 #include "mv_mux_netdev.h"
 #include "mv_switch/mv_switch.h"
 #include <linux/platform_device.h>
+#include "mv_mux_tool.h"
 
 static const struct net_device_ops mv_mux_netdev_ops;
-static struct  mv_mux_eth_port mux_eth_shadow[MV_ETH_MAX_PORTS];
 static struct  mv_mux_switch_port  mux_switch_shadow;
+struct  mv_mux_eth_port mux_eth_shadow[MV_ETH_MAX_PORTS];
 
 /* ppv2/neta functions that called from mux */
 static struct  mv_mux_eth_ops	*mux_eth_ops;
@@ -46,6 +47,7 @@ static struct  mv_switch_mux_ops switch_mux_ops;
 static inline struct net_device *mv_mux_rx_netdev_get(int port, struct sk_buff *skb);
 static inline int mv_mux_rx_tag_remove(struct net_device *dev, struct sk_buff *skb);
 static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb);
+static int mv_mux_netdev_delete_all(int port);
 
 
 /*-----------------------------------------------------------------------------------------*/
@@ -109,15 +111,14 @@ static int mv_mux_mgr_probe(int gbe_port)
 	/* config switch according to preset mode */
 	mv_switch_preset_init(preset, tag_mode, vid);
 
-	/* config mux interfaces according to preset mode */
-	mv_mux_mgr_init(preset, vid, tag_mode, gbe_port);
-
 	/* update netdev port with tag type */
 	mv_mux_tag_type_set(gbe_port, tag_mode);
 
+	/* config mux interfaces according to preset mode */
+	mv_mux_mgr_init(preset, vid, tag_mode, gbe_port);
+
 	if (tag_mode != MV_TAG_TYPE_NONE)
-		if (mux_eth_ops && mux_eth_ops->set_tag_type)
-			/*must be true if (tag_type != none)*/
+		if (mux_eth_ops && mux_eth_ops->promisc_set)
 			mux_eth_ops->promisc_set(gbe_port);
 
 	mv_switch_interrupt_unmask();
@@ -140,6 +141,24 @@ static int mv_mux_mgr_probe(int gbe_port)
 
 /*-----------------------------------------------------------------------------------------*/
 
+void mv_mux_shadow_print(int gbe_port)
+{
+	struct mv_mux_eth_port shadow;
+	static const char * const tags[] = {"None", "mh", "dsa", "edas", "vlan"};
+
+	if (mux_eth_shadow[gbe_port].root == NULL)
+		printk(KERN_ERR "gbe port %d is not attached.\n", gbe_port);
+
+	shadow = mux_eth_shadow[gbe_port];
+		printk(KERN_ERR "\n");
+		printk(KERN_ERR "port #%d: tag type=%s, switch_dev=0x%p, root_dev = 0x%p, flags=0x%x\n",
+			gbe_port, tags[shadow.tag_type],
+			shadow.switch_dev, shadow.root, (unsigned int)shadow.flags);
+
+	mv_mux_netdev_print_all(gbe_port);
+}
+
+/*-----------------------------------------------------------------------------------------*/
 void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port)
 {
 
@@ -185,18 +204,12 @@ void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops
 
 void mv_mux_eth_detach(int port)
 {
-	struct net_device *mux_dev;
-
 	/* allready deattach */
 	if (mux_eth_shadow[port].root == NULL)
 		return;
 
 	/* delete all attached mux devices */
-	mux_dev = mux_eth_shadow[port].switch_dev;
-	while (mux_dev) {
-		mv_mux_netdev_delete(mux_dev);
-		mux_dev = mux_eth_shadow[port].switch_dev;
-	}
+	mv_mux_netdev_delete_all(port);
 
 	/* clear port data */
 	memset(&mux_eth_shadow[port], 0, sizeof(struct mv_mux_eth_port));
@@ -429,6 +442,7 @@ int mv_mux_open(struct net_device *dev)
 
 	netif_stacked_transfer_operstate(root, dev);
 	netif_tx_wake_all_queues(dev);
+
 #ifdef CONFIG_MV_INCLUDE_SWITCH
 	if (mux_switch_shadow.attach) {
 		if (dev->mtu != root->mtu) {
@@ -538,37 +552,37 @@ static inline void mv_mux_init_features(struct net_device *mux_dev)
 	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
 
 	mux_dev->features = root->features;
-	mux_dev->hw_features = root->hw_features;
+	mux_dev->hw_features = root->hw_features & ~NETIF_F_RXCSUM;
 	mux_dev->wanted_features = root->wanted_features;
 	mux_dev->vlan_features = root->vlan_features;
-
 }
-
 /*-----------------------------------------------------------------------------------------*/
-static int mv_mux_set_features(struct net_device *mux_dev, netdev_features_t features)
+/* mv_mux_transfer_features								   */
+/* update features when root features are changed					   */
+/*-----------------------------------------------------------------------------------------*/
+static void mv_mux_transfer_features(struct net_device *root, struct net_device *mux_dev)
 {
+	mux_dev->features &= ~NETIF_F_RXCSUM;
+	mux_dev->features |=  (root->features & NETIF_F_RXCSUM);
 
-	struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
-	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
-	netdev_features_t changed = mux_dev->features ^ features;
-	netdev_features_t old = mux_dev->features;
-
-	if (changed & NETIF_F_TSO)
-		if (!(old & NETIF_F_TSO))
-			/* mux interface want to set tso */
-			if (!(root->features & NETIF_F_TSO))
-				/* master tso is down */
-				return -EOPNOTSUPP;
-
-	if (changed & NETIF_F_IP_CSUM)
-		if (!(old & NETIF_F_IP_CSUM))
-			/* mux interface want to set tx csum */
-			if (!(root->features & NETIF_F_IP_CSUM))
-				/* master tx csum is down */
-				return -EOPNOTSUPP;
-	return MV_OK;
-}
+	mux_dev->features &= ~NETIF_F_IP_CSUM;
+	mux_dev->features |=  (root->features & NETIF_F_IP_CSUM);
 
+	mux_dev->hw_features &= ~NETIF_F_IP_CSUM;
+	mux_dev->hw_features |=  (root->features & NETIF_F_IP_CSUM);
+
+	mux_dev->features &= ~NETIF_F_TSO;
+	mux_dev->features |=  (root->features & NETIF_F_TSO);
+
+	mux_dev->hw_features &= ~NETIF_F_TSO;
+	mux_dev->hw_features |=  (root->features & NETIF_F_TSO);
+
+	mux_dev->features &= ~NETIF_F_SG;
+	mux_dev->features |=  (root->features & NETIF_F_SG);
+
+	mux_dev->hw_features &= ~NETIF_F_SG;
+	mux_dev->hw_features |=  (root->features & NETIF_F_SG);
+}
 /*----------------------------------------------------------------------------------------*/
 /* Function attache mux device to root device,						  */
 /* Set mux mac address and features according to root device				  */
@@ -579,10 +593,8 @@ static struct net_device *mv_mux_netdev_init(int port, struct net_device *mux_de
 	struct net_device *root = mux_eth_shadow[port].root;
 	int tag_type = mux_eth_shadow[port].tag_type;
 
-
 	if (root == NULL)
 		return NULL;
-
 /*
 	if (pp && !(pp->flags & MV_ETH_F_CONNECT_LINUX)) {
 		printk(KERN_ERR "%s: root device is not connect to linux.\n", __func__);
@@ -607,7 +619,7 @@ static struct net_device *mv_mux_netdev_init(int port, struct net_device *mux_de
 	/* TODO: handle features */
 	mv_mux_init_features(mux_dev);
 
-	/*SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);*/
+	SET_ETHTOOL_OPS(mux_dev, &mv_mux_tool_ops);
 
 #ifdef CONFIG_MV_INCLUDE_SWITCH
 	if (mux_switch_shadow.attach)
@@ -630,9 +642,7 @@ int mv_mux_tag_type_get(int port)
 /*-----------------------------------------------------------------------------------------*/
 
 struct net_device *mv_mux_netdev_add(int port, struct net_device *mux_dev)
-
 {
-
 	struct net_device *dev_temp;
 	struct net_device *switch_dev;
 
@@ -678,6 +688,10 @@ int mv_mux_tag_type_set(int port, int type)
 	if (root == NULL)
 		return MV_ERROR;
 
+	/* No change in tag type */
+	if (mux_eth_shadow[port].tag_type == type)
+		return MV_OK;
+
 	flgs = root->flags;
 
 	if (flgs & IFF_UP) {
@@ -685,6 +699,10 @@ int mv_mux_tag_type_set(int port, int type)
 		return MV_ERROR;
 	}
 
+	/* delete all attached virtual interfaces */
+	if (mv_mux_netdev_delete_all(port))
+		return MV_ERROR;
+
 	mux_eth_shadow[port].tag_type = type;
 
 	if (mux_eth_ops && mux_eth_ops->set_tag_type)
@@ -746,6 +764,7 @@ int mv_mux_netdev_delete(struct net_device *mux_dev)
 			/* delet current */
 			synchronize_net();
 			unregister_netdev(mux_dev);
+			printk(KERN_ERR "%s has been removed.\n", mux_dev->name);
 			free_netdev(mux_dev);
 			return MV_OK;
 
@@ -759,6 +778,27 @@ int mv_mux_netdev_delete(struct net_device *mux_dev)
 }
 
 /*-----------------------------------------------------------------------------------------*/
+static int mv_mux_netdev_delete_all(int port)
+{
+	/* delete all attached mux devices */
+	struct net_device *mux_dev;
+
+	if (mux_eth_shadow[port].root == NULL)
+		return MV_ERROR;
+
+	/* delete all attached mux devices */
+	mux_dev = mux_eth_shadow[port].switch_dev;
+	while (mux_dev) {
+		if (mv_mux_netdev_delete(mux_dev))
+			return MV_ERROR;
+
+		mux_dev = mux_eth_shadow[port].switch_dev;
+	}
+
+	return MV_OK;
+}
+
+/*-----------------------------------------------------------------------------------------*/
 static int mux_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
 {
 	struct net_device *mux_dev, *dev = ptr;
@@ -831,10 +871,6 @@ static int mux_device_event(struct notifier_block *unused, unsigned long event,
 
 		break;
 
-	case NETDEV_FEAT_CHANGE:
-		/* not supported */
-		break;
-
 	case NETDEV_DOWN:
 		/* Master down - Put all mux devices for this dev in the down state too.  */
 		mux_dev = mux_eth_shadow[port].switch_dev;
@@ -846,8 +882,8 @@ static int mux_device_event(struct notifier_block *unused, unsigned long event,
 				mux_dev = pdev_priv->next;
 				continue;
 			}
+			/* dev_change_flags call to mv_mux_close*/
 			dev_change_flags(mux_dev, flgs & ~IFF_UP);
-			netif_stacked_transfer_operstate(dev, mux_dev);
 			mux_dev = pdev_priv->next;
 		}
 		break;
@@ -864,11 +900,19 @@ static int mux_device_event(struct notifier_block *unused, unsigned long event,
 				continue;
 			}
 			dev_change_flags(mux_dev, flgs | IFF_UP);
-
-			netif_stacked_transfer_operstate(dev, mux_dev);
+			/* dev_change_flags call to mv_mux_open*/
 			mux_dev = pdev_priv->next;
 		}
+		break;
 
+	case NETDEV_FEAT_CHANGE:
+		/* Master features changed - Propagate device features to underlying device */
+		mux_dev = mux_eth_shadow[port].switch_dev;
+		while (mux_dev != NULL) {
+			pdev_priv = MV_MUX_PRIV(mux_dev);
+			mv_mux_transfer_features(mux_eth_shadow[port].root, mux_dev);
+			mux_dev = pdev_priv->next;
+		}
 		break;
 	} /*switch*/
 out:
@@ -1300,7 +1344,7 @@ void mv_mux_netdev_print(struct net_device *mux_dev)
 	switch (tag_type) {
 
 	case MV_TAG_TYPE_VLAN:
-		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
+		printk(KERN_ERR "%s: port=%d, pdev=%p, tx_vlan=0x%08x, rx_vlan=0x%08x, rx_mask=0x%08x\n",
 			mux_dev->name, pdev->port, pdev, pdev->tx_tag.vlan, pdev->rx_tag_ptrn.vlan, pdev->rx_tag_mask.vlan);
 		break;
 
@@ -1375,7 +1419,6 @@ static const struct net_device_ops mv_mux_netdev_ops = {
 	.ndo_do_ioctl		= mv_mux_ioctl,
 	.ndo_set_rx_mode	= mv_mux_set_rx_mode,
 	.ndo_change_rx_flags	= mv_mux_change_rx_flags,
-	.ndo_set_features	= mv_mux_set_features,
 };
 
 module_init(mux_proto_init);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
index 71ca312..f647b7a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
@@ -38,6 +38,7 @@ disclaimer.
 #include "mvOs.h"
 #include "mv802_3.h"
 
+extern const struct ethtool_ops mv_mux_tool_ops;
 
 struct mux_netdev {
 	int	idx;
@@ -91,6 +92,7 @@ void mv_mux_cfg_get(struct net_device *mux_dev, MV_MUX_TAG *mux_cfg);
 int mv_mux_rx(struct sk_buff *skb, int port, struct napi_struct *napi);
 void mv_mux_netdev_print(struct net_device *mux_dev);
 void mv_mux_netdev_print_all(int port);
+void mv_mux_shadow_print(int gbe_port);
 struct net_device *mv_mux_switch_ptr_get(int port);
 int mv_mux_ctrl_dbg_flag(int port, u32 flag, u32 val);
 void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops *ops);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
index a3f4845..716683d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_sysfs.c
@@ -31,29 +31,31 @@ disclaimer.
 #include "mv_mux_netdev.h"
 MV_MUX_TAG mux_cfg;
 
-static ssize_t mv_mux_help(char *buf)
+static ssize_t mv_mux_help(char *b)
 {
-	int off = 0;
-
-	off += sprintf(buf+off, "echo [if_name]                 > dump         - Dump mux device\n");
-	off += sprintf(buf+off, "echo [if_name] p               > add          - Attach to gbe [p] new virtual interface [if_name]\n");
-	off += sprintf(buf+off, "echo [if_name]                 > del          - Remove virtual interface [if_name]\n");
-
-	off += sprintf(buf+off, "\n");
-	off += sprintf(buf+off, "echo p {0|1|2|3|4}             > tag_type     - Set port [p] tag: 0-NONE, 1-MH, 2-DSA, 3-EDSA, 4-VID\n");
-	off += sprintf(buf+off, "echo [if_name] vid             > mux_vid      - Set virtual interface [if_name] vid value.\n");
-	off += sprintf(buf+off, "echo [if_name] mh mask         > mh_rx        - Set virtual port Marvell header RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] dsa mask        > dsa_rx       - Set virtual port DSA RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] tagL mask       > edsa_low_rx  - Set virtual port EDSA low RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] tagH mask       > edsa_high_rx - Set virtual port EDSA high RX tag and mask\n");
-	off += sprintf(buf+off, "echo [if_name] mh              > mh_tx        - Set virtual port Marvell header tX tag\n");
-	off += sprintf(buf+off, "echo [if_name] dsa             > dsa_tx       - Set virtual port DSA TX tag\n");
-	off += sprintf(buf+off, "echo [if_name] tagH tagL       > edsa_tx      - Set virtual port EDSA TX tag\n");
+	int o = 0;
+	o += sprintf(b+o, "echo p             > dump         - Show gbe port [p] info\n");
+	o += sprintf(b+o, "echo name          > mux_dump     - Show virt interface device info\n");
+	o += sprintf(b+o, "echo name p        > add          - Attach to gbe port [p] new virtual interface\n");
+	o += sprintf(b+o, "echo name          > del          - Remove virt interface\n");
+	o += sprintf(b+o, "\n");
+	o += sprintf(b+o, "echo p tag         > tag_type     - Set port p tag type 0-NONE,1-MH,2-DSA,3-EDSA,4-VID\n");
+	o += sprintf(b+o, "echo name vid      > mux_vid      - Set virt interface vid value.\n");
+	o += sprintf(b+o, "echo name mh       > mh_tx        - Set virt interface MH tX tag\n");
+	o += sprintf(b+o, "echo name mh mask  > mh_rx        - Set virt interface MH RX tag and mask\n");
+	o += sprintf(b+o, "echo name dsa      > dsa_tx       - Set virt interface DSA TX tag\n");
+	o += sprintf(b+o, "echo name dsa mask > dsa_rx       - Set virt interface DSA RX tag and mask\n");
+	o += sprintf(b+o, "echo name wL wH    > edsa_tx      - Set virt interface EDSA TX tag\n");
+	o += sprintf(b+o, "echo name wL wH    > edsa_rx      - Set virt interface EDSA RX tag\n");
+	o += sprintf(b+o, "echo name wL wH    > edsa_rx_mask - Set virt interface EDSA RX mask tag\n");
+
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-	off += sprintf(buf+off, "echo [p] [hex]                 > debug        - bit0:rx, bit1:tx\n");
+	o += sprintf(b+o, "echo p hex         > debug        - bit0:rx, bit1:tx\n");
 #endif
+	o += sprintf(b+o, "\n");
+	o += sprintf(b+o, "params: name-interface name,  mh-2 bytes value(hex), dsa,edsa,vid-4 bytes value(hex)\n");
 
-	return off;
+	return o;
 }
 
 
@@ -88,7 +90,7 @@ static ssize_t mv_mux_netdev_store(struct device *dev,
 	if (mux_dev)
 		dev_put(mux_dev);
 
-	if (!strcmp(name, "dump")) {
+	if (!strcmp(name, "mux_dump")) {
 		mv_mux_netdev_print(mux_dev);
 
 	} else if (!strcmp(name, "mux_vid")) {
@@ -107,15 +109,15 @@ static ssize_t mv_mux_netdev_store(struct device *dev,
 		mux_cfg.rx_tag_mask.dsa = b;
 		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
 
-	} else if (!strcmp(name, "edsa_low_rx")) {
+	} else if (!strcmp(name, "edsa_rx")) {
 		mv_mux_cfg_get(mux_dev, &mux_cfg);
 		mux_cfg.rx_tag_ptrn.edsa[0] = a;
-		mux_cfg.rx_tag_mask.edsa[0] = b;
+		mux_cfg.rx_tag_ptrn.edsa[1] = b;
 		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
 
-	} else if (!strcmp(name, "edsa_high_rx")) {
+	} else if (!strcmp(name, "edsa_rx_mask")) {
 		mv_mux_cfg_get(mux_dev, &mux_cfg);
-		mux_cfg.rx_tag_ptrn.edsa[1] = a;
+		mux_cfg.rx_tag_mask.edsa[0] = a;
 		mux_cfg.rx_tag_mask.edsa[1] = b;
 		err = mv_mux_netdev_alloc(dev_name, -1, &mux_cfg) ? 0 : 1;
 
@@ -166,6 +168,10 @@ static ssize_t mv_mux_store(struct device *dev,
 
 	if (!strcmp(name, "tag_type")) {
 		mv_mux_tag_type_set(a, b);
+
+	} else if (!strcmp(name, "dump")) {
+		mv_mux_shadow_print(a);
+
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	} else if (!strcmp(name, "debug")) {
 		err = mv_mux_ctrl_dbg_flag(a, MV_MUX_F_DBG_RX,   b & 0x1);
@@ -188,14 +194,15 @@ static DEVICE_ATTR(del,          S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(mux_vid,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(mh_rx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(dsa_rx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(edsa_low_rx,  S_IWUSR, mv_mux_show, mv_mux_netdev_store);
-static DEVICE_ATTR(edsa_high_rx, S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_rx,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(edsa_rx_mask, S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(mh_tx,        S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(dsa_tx,       S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(edsa_tx,      S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(tag_type,     S_IWUSR, mv_mux_show, mv_mux_store);
+static DEVICE_ATTR(dump,         S_IWUSR, mv_mux_show, mv_mux_store);
 static DEVICE_ATTR(debug,        S_IWUSR, mv_mux_show, mv_mux_store);
-static DEVICE_ATTR(dump,         S_IWUSR, mv_mux_show, mv_mux_netdev_store);
+static DEVICE_ATTR(mux_dump,     S_IWUSR, mv_mux_show, mv_mux_netdev_store);
 static DEVICE_ATTR(help,         S_IRUSR, mv_mux_show, NULL);
 
 
@@ -206,14 +213,15 @@ static struct attribute *mv_mux_attrs[] = {
 	&dev_attr_mux_vid.attr,
 	&dev_attr_mh_rx.attr,
 	&dev_attr_dsa_rx.attr,
-	&dev_attr_edsa_low_rx.attr,
-	&dev_attr_edsa_high_rx.attr,
+	&dev_attr_edsa_rx.attr,
+	&dev_attr_edsa_rx_mask.attr,
 	&dev_attr_mh_tx.attr,
 	&dev_attr_dsa_tx.attr,
 	&dev_attr_edsa_tx.attr,
 	&dev_attr_tag_type.attr,
-	&dev_attr_help.attr,
 	&dev_attr_dump.attr,
+	&dev_attr_help.attr,
+	&dev_attr_mux_dump.attr,
 	&dev_attr_debug.attr,
 	NULL
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
new file mode 100644
index 0000000..44816d6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
@@ -0,0 +1,221 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mv_mux_tool.h"
+
+/******************************************************************************
+*mv_mux_tool_get_settings
+*Description:
+*	ethtool	get standard port settings
+*INPUT:
+*	netdev	Network device structure pointer
+*OUTPUT
+*	cmd	command (settings)
+*RETURN:
+*	0 for success
+*
+*******************************************************************************/
+int mv_mux_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(netdev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	if (!root)
+		return -ENETUNREACH;
+
+	return __ethtool_get_settings(root, cmd);
+}
+/******************************************************************************
+*mv_mux_tool_get_drvinfo
+*Description:
+*	ethtool get driver information
+*INPUT:
+*	netdev	Network device structure pointer
+*	info	driver information
+*OUTPUT
+*	info	driver information
+*RETURN:
+*	None
+*
+*******************************************************************************/
+void mv_mux_tool_get_drvinfo(struct net_device *netdev, struct ethtool_drvinfo *info)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(netdev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	if (!root || !root->ethtool_ops || !root->ethtool_ops->get_drvinfo)
+		return;
+
+
+	root->ethtool_ops->get_drvinfo(root, info);
+}
+
+/******************************************************************************
+*mv_mux_tool_get_coalesce
+*Description:
+*	ethtool get RX/TX coalesce parameters
+*INPUT:
+*	netdev	Network device structure pointer
+*OUTPUT
+*	cmd	Coalesce parameters
+*RETURN:
+*	0 on success
+*
+*******************************************************************************/
+int mv_mux_tool_get_coalesce(struct net_device *netdev, struct ethtool_coalesce *cmd)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(netdev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	if (!root || !root->ethtool_ops || !root->ethtool_ops->get_coalesce)
+		return -ENETUNREACH;
+
+	return root->ethtool_ops->get_coalesce(root, cmd);
+
+}
+/******************************************************************************
+*mv_mux_tool_get_pauseparam
+*Description:
+*	ethtool get pause parameters
+*INPUT:
+*	netdev	Network device structure pointer
+*OUTPUT
+*	pause	Pause paranmeters
+*RETURN:
+*	None
+*
+*******************************************************************************/
+void mv_mux_tool_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *pause)
+{
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(netdev);
+	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
+
+	if (!root || !root->ethtool_ops || !root->ethtool_ops->get_pauseparam)
+		return;
+
+	root->ethtool_ops->get_pauseparam(root, pause);
+}
+
+
+/******************************************************************************
+* mv_mux_tool_nway_reset
+* Description:
+*	ethtool restart auto negotiation
+* INPUT:
+*	netdev	Network device structure pointer
+* OUTPUT
+*	None
+* RETURN:
+*	0 on success
+*
+*******************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+int mv_mux_tool_nway_reset(struct net_device *mux_dev)
+{
+	struct mux_netdev *pdev_priv;
+
+	pdev_priv = MV_MUX_PRIV(mux_dev);
+	/* restart group autoneg */
+	if (mv_switch_group_restart_autoneg(pdev_priv->idx))
+		return -EINVAL;
+
+	return 0;
+}
+#endif
+
+/******************************************************************************
+* mv_mux_tool_get_link
+* Description:
+*	ethtool get link status
+* INPUT:
+*	netdev	Network device structure pointer
+* OUTPUT
+*	None
+* RETURN:
+*	0 if link is down, 1 if link is up
+*
+*******************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+u32 mv_mux_tool_get_link(struct net_device *mux_dev)
+{
+	struct mux_netdev *pdev_priv;
+
+	pdev_priv = MV_MUX_PRIV(mux_dev);
+
+	return mv_switch_link_status_get(pdev_priv->idx);
+}
+#endif
+
+
+const struct ethtool_ops mv_mux_tool_ops = {
+	.get_settings	= mv_mux_tool_get_settings,
+	.get_pauseparam	= mv_mux_tool_get_pauseparam,
+	.get_coalesce	= mv_mux_tool_get_coalesce,
+	.get_link	= ethtool_op_get_link,
+	.get_drvinfo	= mv_mux_tool_get_drvinfo,
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	.nway_reset	= mv_mux_tool_nway_reset,
+	.get_link	= mv_mux_tool_get_link,
+#endif
+};
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.h
new file mode 100644
index 0000000..c278949
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef NET_DEV_MV_MUX_TOOL_H
+#define NET_DEV_MV_MUX_TOOL_H
+
+#include <linux/version.h>
+#include <linux/ethtool.h>
+#include "mv_mux_netdev.h"
+#include "mv_switch/mv_switch.h"
+#include <linux/netdevice.h>
+
+extern struct  mv_mux_eth_port mux_eth_shadow[];
+
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index 2f31f0c..8514d5c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -221,6 +221,23 @@ static int mv_switch_group_state_set(int db, int en)
 	return 0;
 }
 
+int mv_switch_group_restart_autoneg(int db)
+{
+	unsigned int p, port_mask = db_port_mask[db];
+
+	/* enable/disable all ports in group */
+	for (p = 0; p < qd_dev->numOfPorts; p++) {
+		if (!MV_BIT_CHECK(port_mask, p))
+			continue;
+
+		if (gprtPortRestartAutoNeg(qd_dev, p) != GT_OK) {
+			printk(KERN_ERR "gprtPortRestartAutoNeg failed\n");
+			return -1;
+		}
+	}
+	return 0;
+}
+
 int mv_switch_group_enable(int db)
 {
 	return mv_switch_group_state_set(db, 1);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index 359f8ed..fb64339 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -75,6 +75,7 @@ int     mv_switch_port_del(int switch_port);
 int		mv_switch_default_config_get(MV_TAG_TYPE *tag_mode, MV_SWITCH_PRESET_TYPE *preset, int *vid, int *gbe_port);
 int		mv_switch_tag_get(MV_MUX_TAG *tag, MV_SWITCH_PRESET_TYPE preset, int vid, MV_TAG_TYPE tag_mode, int db);
 unsigned int	mv_switch_group_map_get(void);
+int		mv_switch_group_restart_autoneg(int db);
 int		mv_switch_group_enable(int db);
 int		mv_switch_group_disable(int db);
 int		mv_switch_link_status_get(int db);
-- 
1.7.5.4

