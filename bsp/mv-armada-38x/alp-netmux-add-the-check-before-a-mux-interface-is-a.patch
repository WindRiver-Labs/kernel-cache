From 1bed6458056d1c5d4332a5d3490e7761cda31874 Mon Sep 17 00:00:00 2001
From: Ken Ma <make@marvell.com>
Date: Tue, 22 Apr 2014 17:36:13 +0800
Subject: [PATCH 1581/1825] alp: netmux: add the check before a mux interface
 is added to or removed from a port

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 7225904d354c507e64e49bb31e1d7e3c4695726f

	In current release, if we input "echo mux0 0 > /sys/devices/platform/mv_mux/add"
	twice, then system may collapse; if we delete a unattached mux interface, there
	is an error. So I add the check before adding/removing mux interface - if the
	adding mux interface is attached to the target port already, then it will not be
	attached again; if the removing mux interface is not attached to any port, then it
	can be removed without any error.

Signed-off-by: Ken Ma <make@marvell.com>

Change-Id: Iea15eadb9cf275c89adbf898daaf96985d816cec
Signed-off-by: Ken Ma <make@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7156
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |   19 +++++++++++++++----
 1 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index c2ef6a9..eed6130 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -567,6 +567,11 @@ struct net_device *mv_mux_netdev_alloc(char *name, int idx, MV_MUX_TAG *tag_cfg)
 			return NULL;
 		}
 
+		/*initialization for new net device*/
+		pmux_priv = MV_MUX_PRIV(mux_dev);
+		memset(pmux_priv, 0, sizeof(struct mux_netdev));
+		pmux_priv->port = -1;
+		pmux_priv->next = NULL;
 	} else
 		dev_put(mux_dev);
 
@@ -701,11 +706,16 @@ struct net_device *mv_mux_netdev_add(int port, struct net_device *mux_dev)
 		mux_eth_shadow[port].switch_dev = mux_dev;
 	} else {
 		pdev = MV_MUX_PRIV(switch_dev);
-		while (pdev->next != NULL) {
+		dev_temp = switch_dev;
+		while ((mux_dev != dev_temp) && (pdev->next != NULL)) {
 			dev_temp = pdev->next;
 			pdev = MV_MUX_PRIV(dev_temp);
 		}
-		pdev->next = mux_dev;
+		/*check whether mux_dev is already in the physical port*/
+		if (mux_dev == dev_temp)
+			netdev_info(mux_dev, "this mux interface is already in port %d\n", port);
+		else
+			pdev->next = mux_dev;
 	}
 
 	if (!mux_init_cnt)
@@ -766,7 +776,7 @@ int mv_mux_netdev_delete(struct net_device *mux_dev)
 {
 	struct net_device *pdev_curr, *pdev_prev = NULL;
 	struct mux_netdev *pdev_tmp_curr, *pdev_tmp_prev, *pdev;
-	struct net_device *root;
+	struct net_device *root = NULL;
 	int flgs, port;
 
 	if (mux_dev == NULL) {
@@ -776,7 +786,8 @@ int mv_mux_netdev_delete(struct net_device *mux_dev)
 	pdev = MV_MUX_PRIV(mux_dev);
 	port = pdev->port;
 
-	root = mux_eth_shadow[pdev->port].root;
+	if (port != -1)
+		root = mux_eth_shadow[pdev->port].root;
 
 	/*not attached to gbe port*/
 	if (root == NULL) {
-- 
1.7.5.4

