From d5ff3ac1dbc36b9d3502d75ac265b47b40794709 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 23 Oct 2013 14:34:54 +0200
Subject: [PATCH 1222/1825] smp: alp: remove obsolete SMP boot sync mechanism
 (pen release)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 64e9990ded377ae39f6e6dcc807d7764c107b55e

	Also fixed compilation warning in platsmp.c file:
	In file included from arch/arm/mach-avantalp/platsmp.c:25:0:
	arch/arm/mach-avantalp/core.h:8:32: warning: 'struct mbus_dram_target_info' declared inside parameter list [enabled by default]
	arch/arm/mach-avantalp/core.h:8:32: warning: its scope is only this definition or declaration, which is probably not what you want [enabled by default]

Change-Id: Ifd51f3d1e52f9dd79c06408d4ffba7638d8ecc50
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3831
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.h    |    2 +
 arch/arm/mach-avantalp/headsmp.S |   22 -----------
 arch/arm/mach-avantalp/platsmp.c |   73 +-------------------------------------
 3 files changed, 3 insertions(+), 94 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.h b/arch/arm/mach-avantalp/core.h
index 73a8d91..717ba85 100644
--- a/arch/arm/mach-avantalp/core.h
+++ b/arch/arm/mach-avantalp/core.h
@@ -4,6 +4,8 @@
  * published by the Free Software Foundation.
  */
 
+#include <linux/mbus.h>
+
 void alp_irq_init(void);
 void __init mv_usb_init(struct mbus_dram_target_info *dram);
 void set_core_count(unsigned int cpu_count);
diff --git a/arch/arm/mach-avantalp/headsmp.S b/arch/arm/mach-avantalp/headsmp.S
index 36797e0..3776362 100644
--- a/arch/arm/mach-avantalp/headsmp.S
+++ b/arch/arm/mach-avantalp/headsmp.S
@@ -63,28 +63,6 @@ ENTRY(v7_invalidate_l1)
 	mov	pc, lr
 ENDPROC(v7_invalidate_l1)
 
-/*
- * This provides a "holding pen" into which all secondary cores are held
- * until we're ready for them to initialise.
- */
 ENTRY(alp_secondary_startup)
 	bl	v7_invalidate_l1
-	mrc	p15, 0, r0, c0, c0, 5
-	and	r0, r0, #15
-	adr	r4, 1f
-	ldmia	r4, {r5, r6}
-	sub	r4, r4, r5
-	add	r6, r6, r4
-pen:	ldr	r7, [r6]
-	cmp	r7, r0
-	bne	pen
-
-	/*
-	 * we've been released from the holding pen: secondary_stack
-	 * should now contain the SVC stack for this core
-	 */
 	b	secondary_startup
-
-	.align
-1:	.long	.
-	.long	pen_release
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index 7d88674..28c61d8 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -80,88 +80,17 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG(1));
 }
 
-/*
- * control for which core is the next to come out of the secondary
- * boot "holding pen"
- */
-volatile int __cpuinitdata pen_release = -1;
-
-/*
- * Write pen_release in a way that is guaranteed to be visible to all
- * observers, irrespective of whether they're taking part in coherency
- * or not.  This is necessary for the hotplug code to work reliably.
- */
-static void __cpuinit write_pen_release(int val)
-{
-	pen_release = val;
-	smp_wmb();
-	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
-	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
-}
-
-static DEFINE_SPINLOCK(boot_lock);
-
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
-	/*
-	 * if any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
 	gic_secondary_init(0);
-
-	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
-	write_pen_release(-1);
-
-	/*
-	 * Synchronise with the boot thread.
-	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
 }
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	unsigned long timeout;
-
-	/*
-	 * Set synchronisation state between this boot processor
-	 * and the secondary one
-	 */
-
-	spin_lock(&boot_lock);
-
-	/*
-	 * This is really belt and braces; we hold unintended secondary
-	 * CPUs in the holding pen until we're ready for them.  However,
-	 * since we haven't sent them a soft interrupt, they shouldn't
-	 * be there.
-	 */
-	write_pen_release(cpu_logical_map(cpu));
-
 	/*
 	 * Get CPU out of software reset state.
 	 */
 	writel(0, CPU_SOFT_RESET_REG(cpu_logical_map(cpu)) +
 			INTER_REGS_VIRT_BASE);
-
-	timeout = jiffies + (1 * HZ);
-	while (time_before(jiffies, timeout)) {
-		smp_rmb();
-		if (pen_release == -1)
-			break;
-
-		udelay(10);
-	}
-
-	/*
-	 * now the secondary core is starting up let it run its
-	 * calibrations, then wait for it to finish
-	 */
-	spin_unlock(&boot_lock);
-
-	return pen_release != -1 ? -ENOSYS : 0;
+	return 0;
 }
-- 
1.7.5.4

