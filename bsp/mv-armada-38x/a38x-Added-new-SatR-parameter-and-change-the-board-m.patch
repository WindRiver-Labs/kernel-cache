From 248b86bac8951e527de1ac90c4d3e59929eac924 Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Sun, 22 Dec 2013 16:51:32 +0200
Subject: [PATCH 1237/1825] a38x: Added new SatR parameter and change the
 board module structure

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit d23d6b5fc149ab02053decc5890d1dcb4445c830

	1. Added new software parameters to S@R command for RD-NAS-SGMII and for DB-USB3 mode
	2. Improve  S@R list by adding parameters name to S@R table
	3. Update boot source name for SPI0 and SPI1
	4. Earlier the board module detect for NOR init
	5. Move bootOtionConfig to board struct spec
	6. Add 2 function mvBoardModuleConfigGet and mvBoardModuleConfigSet to update
	   bootOptionConfig in board spec structure

Change-Id: Ib149957c1e239b961a42a846848ba1465f904d59
Signed-off-by: Eli Nidam <elini@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4823
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |   99 +++++++++++++++-----
 .../armada_38x_family/boardEnv/mvBoardEnvLib.h     |   47 +++++++---
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.c    |   12 ++-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |   15 ---
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |   16 ++--
 5 files changed, 127 insertions(+), 62 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index 7af3ebc..273c301 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -98,9 +98,7 @@ MV_SATR_BOOT_TABLE satrBootSrcTable[] = MV_SATR_BOOT_SRC_TABLE_VAL;
 /* Locals */
 static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 static MV_BOARD_INFO *board;
-MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
-
-
+static MV_VOID mvBoardModuleAutoDetect(MV_VOID);
 /*******************************************************************************
 * mvBoardEnvInit
 *
@@ -125,12 +123,12 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 	MV_U32 syncCtrl	= 0;
 	MV_BOARD_BOOT_SRC bootSrc;
 
-	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION);
-
 	board = boardInfoTbl[DB_68XX_ID];	/* init for first time get the correct twsi address */
 	mvBoardIdSet(mvBoardIdGet());
+	if (mvBoardConfigAutoDetectEnabled())
+		mvBoardModuleAutoDetect();
 	bootSrc = mvBoardBootDeviceGroupSet();
-	if (MSAR_0_BOOT_NAND_NEW == bootSrc) {
+	if (MSAR_0_BOOT_NAND_NEW == bootSrc) {	/* init NAND only if boot from NAND */
 		nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
 		if (nandDev != 0xFFFFFFFF) {
 			/* Set NAND interface access parameters */
@@ -140,7 +138,7 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 			/* Set Ready Polarity to Active High */
 			syncCtrl |= SYNC_CTRL_READY_POL(nandDev);
 		}
-	} else if (MSAR_0_BOOT_NOR_FLASH == bootSrc) {
+	} else if (mvBoardModuleConfigGet() & MV_CONFIG_NOR) { /* init NOR only if Module NOR is detected */
 		norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
 		if (norDev != 0xFFFFFFFF) {
 			/* Set NOR interface access parameters */
@@ -329,6 +327,44 @@ MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum)
 		return MV_TRUE;
 	return MV_FALSE;
 }
+/*******************************************************************************
+* mvBoardModuleConfigGet - Get the module configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit module configuration.
+*
+*******************************************************************************/
+MV_32 mvBoardModuleConfigGet(MV_VOID)
+{
+	return board->boardOptionsConfig;
+}
+/*******************************************************************************
+* mvBoardModuleConfigSet - Set the module configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit module configuration.
+*
+*******************************************************************************/
+MV_VOID mvBoardModuleConfigSet(MV_U32 newCfg)
+{
+	board->boardOptionsConfig |= newCfg;
+}
+
+
 
 /*******************************************************************************
 * mvBoardPhyAddrGet - Get the phy address
@@ -796,9 +832,8 @@ MV_VOID mvBoardMppSet(MV_U32 mppGroupNum, MV_U32 mppValue)
 	board->pBoardMppConfigValue->mppGroup[mppGroupNum] = mppValue;
 }
 
-
 /*******************************************************************************
-* mvBoardInfoUpdate - Update Board information structures according to auto-detection.
+* mvBoardModuleAutoDetect - Update Board information structures according to auto-detection.
 *
 * DESCRIPTION:
 *	Update board information according to detection using TWSI bus.
@@ -813,33 +848,53 @@ MV_VOID mvBoardMppSet(MV_U32 mppGroupNum, MV_U32 mppValue)
 *	None.
 *
 *******************************************************************************/
-MV_VOID mvBoardInfoUpdate(MV_VOID)
+static MV_VOID mvBoardModuleAutoDetect(MV_VOID)
 {
 	MV_U8 readValue;
 	MV_BOARD_CONFIG_TYPE_INFO configInfo;
 	int i;
 	MV_BOARD_BOOT_SRC bootSrc;
-	MV_U32	reg;
-
-
 	/*Read all TWSI board module if exsist : */
-	/* Save values Locally in configVal[] */
+	/* Save values board spec struct  */
 	for (i = 0; i < MV_CONFIG_TYPE_MAX_MODULE; i++) {
-		if (mvBoardConfigTypeGet(i, &configInfo) == MV_TRUE) {
+		if (mvBoardConfigTypeGet((1 << i), &configInfo) == MV_TRUE) {
 			if (mvBoardTwsiGet(BOARD_TWSI_MODULE_DETECT, configInfo.twsiAddr,
 					   configInfo.offset, &readValue) != MV_OK) {
 				DB(mvOsPrintf("%s: Error: Read from TWSI failed addr=0x%x\n",
 					   __func__, configInfo.twsiAddr));
 				continue;
 			}
+			readValue &= 0x0f;	/* only 4 bit relevant  */
 			/* twsi ID represente  module configuration ID*/
 			if (configInfo.twsiId == readValue)
-				boardOptionsConfig[configInfo.configId] = 1;
+				mvBoardModuleConfigSet(configInfo.configId);
 		}
 	}
 	bootSrc = mvBoardBootDeviceGroupSet();
 	if (MSAR_0_BOOT_NAND_NEW == bootSrc)
-		boardOptionsConfig[MV_CONFIG_NAND_ON_BOARD] = 1;
+		mvBoardModuleConfigSet(MV_CONFIG_NAND_ON_BOARD);
+
+}
+
+/*******************************************************************************
+* mvBoardInfoUpdate - Update Board information structures according to auto-detection.
+*
+* DESCRIPTION:
+*	Update board information according to detection using TWSI bus.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardInfoUpdate(MV_VOID)
+{
+	MV_U32	reg;
 
 	/* Update MPP group types and values according to board configuration */
 	mvBoardMppIdUpdate();
@@ -871,9 +926,7 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 *******************************************************************************/
 MV_BOOL mvBoardIsModuleConnected(MV_U32 ModuleID)
 {
-	if (ModuleID >= MV_CONFIG_TYPE_MAX_OPTION)
-		return MV_FALSE;
-	if (boardOptionsConfig[ModuleID] == 1)
+	if (mvBoardModuleConfigGet() & ModuleID)
 		return MV_TRUE;
 	return MV_FALSE;
 }
@@ -1042,7 +1095,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 	case MSAR_0_BOOT_NOR_FLASH:
 		break;
 	case MSAR_0_BOOT_NAND_NEW:
-		boardOptionsConfig[MV_CONFIG_NAND_ON_BOARD] = 1;
+		mvBoardModuleConfigSet(MV_CONFIG_NAND_ON_BOARD);
 		break;
 	case MSAR_0_BOOT_SPI_FLASH:
 		break;
@@ -1255,7 +1308,7 @@ MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
 	mvOsOutput("Board configuration detected:\n");
 
 	for (i = 0; i < MV_CONFIG_TYPE_MAX_MODULE; i++) {
-		if (mvBoardIsModuleConnected(i))
+		if (mvBoardIsModuleConnected(1 << i))
 			mvOsOutput("       %s module.\n", moduleStr[i]);
 
 	}
@@ -1657,7 +1710,7 @@ MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *s
 	 * and check if field is relevant to current running board */
 	for (i = 0; i < MV_SATR_MAX_OPTION ; i++)
 		if (boardSatrInfo[i].satrId == satrClass) {
-			*satrInfo = boardSatrInfo[i];
+			memcpy(satrInfo, &boardSatrInfo[i], sizeof(MV_BOARD_SATR_INFO));
 			if (boardSatrInfo[i].isActiveForBoard[boardId])
 				return MV_OK;
 			else
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
index 0ab9aeb..e61728f 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
@@ -169,9 +169,25 @@ typedef enum _mvSatRTypeID {
 	MV_SATR_BOOT2_DEVICE,
 	MV_SATR_BOARD_ID,
 	MV_SATR_BOARD_ECO_VERSION,
+	MV_SATR_DB_USB3_PORT0,
+	MV_SATR_DB_USB3_PORT1,
+	MV_SATR_RD_NAS_SERDES4_CFG,
 	MV_SATR_MAX_OPTION,
 } MV_SATR_TYPE_ID;
 
+typedef enum _mvConfigTypeID {
+	MV_CONFIG_NO_MODULE		= 0x000,	/* MII board SLM 1362	*/
+	MV_CONFIG_MII			= BIT0,	/* MII board SLM 1362	*/
+	MV_CONFIG_SLIC_TDM_DEVICE	= BIT1,	/* TDM board SLM 1360	*/
+	MV_CONFIG_I2S_DEVICE		= BIT2,	/* I2S board SLM 1360	*/
+	MV_CONFIG_SPDIF_DEVICE		= BIT3,	/* SPDIF board SLM 1360	*/
+	MV_CONFIG_NOR			= BIT4,	/* NOR board SLM 1361	*/
+	MV_CONFIG_NAND			= BIT5,	/* NAND board SLM 1361	*/
+	MV_CONFIG_SDIO			= BIT6,	/* SDIO board SLM 1361	*/
+	MV_CONFIG_NAND_ON_BOARD		= BIT7,	/* ON board nand detect */
+	MV_CONFIG_TYPE_MAX_MODULE	= 7,
+	MV_CONFIG_TYPE_MAX_OPTION	= 8
+} MV_CONFIG_TYPE_ID;
 
 typedef struct _devCsInfo {
 	MV_U8 deviceCS;
@@ -206,6 +222,7 @@ typedef struct _boardTwsiInfo {
 } MV_BOARD_TWSI_INFO;
 
 typedef struct _boardSatrInfo {
+	char name[20];
 	MV_SATR_TYPE_ID satrId;
 	MV_U32 mask;
 	MV_U32 bitOffset;
@@ -363,6 +380,7 @@ typedef struct _boardInfo {
 	MV_BOOL configAutoDetect;
 	MV_U32	numIoExp;
 	struct MV_BOARD_IO_EXPANDER *pIoExp;
+	MV_U32  boardOptionsConfig;
 } MV_BOARD_INFO;
 
 /* {{MV_CONFIG_TYPE_ID ConfigID, twsi-ID,  Offset, ID,  isActiveForBoard[]}} */
@@ -428,6 +446,8 @@ MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum);
+MV_VOID mvBoardModuleConfigSet(MV_U32 newCfg);
+MV_32 mvBoardModuleConfigGet(MV_VOID);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
 MV_VOID mvBoardPhyAddrSet(MV_U32 ethPortNum, MV_U32 smiAddr);
 MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo);
@@ -517,18 +537,21 @@ MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val);
 /*    SATR-ID                   Mask    bit    TWSI   Reg  board	*/
 /*    SATR-ID                   Mask  offset  devID  num  active	*/
 #define MV_SAR_INFO { \
-{ MV_SATR_CPU_DDR_L2_FREQ,	0x1F,	0,	1,	0,	{1, 1, 1, 0}, BOARD_SATR_SWAP_BIT},\
-{ MV_SATR_CORE_CLK_SELECT,	0x04,	2,	3,	0,	{0, 1, 0, 0}, 0},\
-{ MV_SATR_CPU1_ENABLE,		0x01,	0,	2,	0,	{0, 1, 0, 0}, 0},\
-{ MV_SATR_SSCG_DISABLE,		0x08,	3,	3,	0,	{0, 1, 0, 0}, 0},\
-{ MV_SATR_DDR4_SELECT,		0x20,	5,	4,	1,	{0, 1, 0, 0}, BOARD_SATR_READ_ONLY},\
-{ MV_SATR_DDR_BUS_WIDTH,	0x02,	1,	4,	0,	{0, 1, 0, 0}, BOARD_SATR_READ_ONLY},\
-{ MV_SATR_DDR_ECC_ENABLE,	0x04,	2,	4,	0,	{0, 1, 0, 0}, 0},\
-{ MV_SATR_BOOT_DEVICE,		0x3,	0,	3,	0,	{0, 1, 0, 0}, BOARD_SATR_SWAP_BIT},\
-{ MV_SATR_BOOT2_DEVICE,		0x1E,	1,	2,	0,	{0, 1, 0, 0}, BOARD_SATR_SWAP_BIT},\
-{ MV_SATR_BOARD_ID,		0x7,	0,	0,	0,	{1, 1, 1, 0}, 0},\
-{ MV_SATR_BOARD_ECO_VERSION,	0xff,	0,	0,	1,	{1, 1, 1, 0}, BOARD_SATR_READ_ONLY},\
-{ MV_SATR_MAX_OPTION,		0x0,	0,	0,	0,	{0, 0, 0, 0}, 0},\
+{ "coreclock",	MV_SATR_CORE_CLK_SELECT,	0x1F,	0,	1,	0,	{1, 1, 1, 0}, BOARD_SATR_SWAP_BIT},\
+{ "freq",	MV_SATR_CPU_DDR_L2_FREQ,	0x04,	2,	3,	0,	{0, 1, 0, 0}, 0},\
+{ "cpusnum",	MV_SATR_CPU1_ENABLE,		0x01,	0,	2,	0,	{0, 1, 0, 0}, 0},\
+{ "sscg",	MV_SATR_SSCG_DISABLE,		0x08,	3,	3,	0,	{0, 1, 0, 0}, 0},\
+{ "ddr4select",	MV_SATR_DDR4_SELECT,		0x20,	5,	4,	1,	{0, 1, 0, 0}, BOARD_SATR_READ_ONLY},\
+{ "ddrbuswidth",  MV_SATR_DDR_BUS_WIDTH,	0x02,	1,	4,	0,	{0, 1, 0, 0}, BOARD_SATR_READ_ONLY},\
+{ "ddreccenable", MV_SATR_DDR_ECC_ENABLE,	0x04,	2,	4,	0,	{0, 1, 0, 0}, 0},\
+{ "bootsrc",	MV_SATR_BOOT_DEVICE,		0x3,	0,	3,	0,	{0, 1, 0, 0}, BOARD_SATR_SWAP_BIT},\
+{ "boarsrc2",	MV_SATR_BOOT2_DEVICE,		0x1E,	1,	2,	0,	{0, 1, 0, 0}, BOARD_SATR_SWAP_BIT},\
+{ "boardid",	MV_SATR_BOARD_ID,		0x7,	0,	0,	0,	{1, 1, 1, 0}, 0},\
+{ "ecoversion",	MV_SATR_BOARD_ECO_VERSION,	0xff,	0,	0,	1,	{1, 1, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ "usb3port0",	MV_SATR_DB_USB3_PORT0,		0x1,	0,	1,	1,	{0, 1, 0, 0}, 0},\
+{ "usb3port1",	MV_SATR_DB_USB3_PORT1,		0x2,	1,	1,	1,	{0, 1, 0, 0}, 0},\
+{ "rdserdes4",	MV_SATR_RD_NAS_SERDES4_CFG,	0x4,	2,	1,	1,	{1, 0, 0, 0}, 0},\
+{ "max_option",	MV_SATR_MAX_OPTION,		0x0,	0,	0,	0,	{0, 0, 0, 0}, 0},\
 };
 
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
index aa989dc..a43ce7d 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
@@ -187,7 +187,8 @@ MV_BOARD_INFO db88f68xx_board_info = {
 	/* Enable modules auto-detection. */
 	.configAutoDetect		= MV_TRUE,
 	.numIoExp			= 0,
-	.pIoExp				= NULL
+	.pIoExp				= NULL,
+	.boardOptionsConfig		= MV_CONFIG_NO_MODULE
 };
 
 /*******************************************************************************
@@ -286,7 +287,8 @@ MV_BOARD_INFO rdNas88f68XX_board_info = {
 	/* Enable modules auto-detection. */
 	.configAutoDetect		= MV_FALSE,
 	.numIoExp			= ARRSZ(ioExpNas),
-	.pIoExp				= ioExpNas
+	.pIoExp				= ioExpNas,
+	.boardOptionsConfig		= MV_CONFIG_NO_MODULE
 };
 /*******************************************************************************
  * A380 RD-WAP-88F68XX board */
@@ -363,7 +365,8 @@ MV_BOARD_INFO rdWAP88f68XX_board_info = {
 	/* Enable modules auto-detection. */
 	.configAutoDetect		= MV_FALSE,
 	.numIoExp			= ARRSZ(ioExpWap),
-	.pIoExp				= ioExpWap
+	.pIoExp				= ioExpWap,
+	.boardOptionsConfig		= MV_CONFIG_NO_MODULE
 };
 
 
@@ -459,7 +462,8 @@ MV_BOARD_INFO A380_customer_board_info = {
 	.norFlashReadParams		= A380_CUSTOMER_BOARD_NOR_READ_PARAMS,
 	.norFlashWriteParams		= A380_CUSTOMER_BOARD_NOR_WRITE_PARAMS,
 	.numIoExp			= 0,
-	.pIoExp				= NULL
+	.pIoExp				= NULL,
+	.boardOptionsConfig		= MV_CONFIG_NO_MODULE
 };
 
 /*
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
index ef8954a..5f0acc2 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -74,20 +74,6 @@
 #include "ctrlEnv/mvCtrlEnvAddrDec.h"
 
 
-typedef enum _mvConfigTypeID {
-	MV_CONFIG_MII,			/* MII board SLM 1362	*/
-	MV_CONFIG_SLIC_TDM_DEVICE,	/* TDM board SLM 1360	*/
-	MV_CONFIG_I2S_DEVICE,		/* I2S board SLM 1360	*/
-	MV_CONFIG_SPDIF_DEVICE,		/* SPDIF board SLM 1360	*/
-	MV_CONFIG_NOR,			/* NOR board SLM 1361	*/
-	MV_CONFIG_NAND,			/* NAND board SLM 1361	*/
-	MV_CONFIG_SDIO,			/* SDIO board SLM 1361	*/
-	MV_CONFIG_TYPE_MAX_MODULE,
-	MV_CONFIG_NAND_ON_BOARD = MV_CONFIG_TYPE_MAX_MODULE,	/* ON board nand detect */
-	MV_CONFIG_TYPE_MAX_OPTION,
-} MV_CONFIG_TYPE_ID;
-
-
 /* This enumerator describes the possible SMI control options */
 typedef enum _mvSMIctrl {
 	CPU_SMI_CTRL,
@@ -205,7 +191,6 @@ typedef enum {
 /* mcspLib.h API list */
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
 MV_U32 mvCtrlbootSrcGet(void);
-MV_U32 mvCtrlSysConfigGet(MV_CONFIG_TYPE_ID configField);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
index aee261d..ccb8a0d 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -309,21 +309,21 @@ typedef struct _mvSATRBootTable {
 /*31*/ { MSAR_0_BOOT_SDIO,		0,		40,		37		, \
 		"SDIO   Port0"}, /* port, mpp, mpp */ \
 /*32*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
-		"SPI 24 bit address"}, \
+		"SPI0 24 bit address"}, \
 /*33*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
-		"SPI 32 bit address"}, \
+		"SPI0 32 bit address"}, \
 /*34*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 59, \
-		"SPI 24 bit address"}, \
+		"SPI1 24 bit address"}, \
 /*35*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 59, \
-		"SPI 32 bit address"}, \
+		"SPI1 32 bit address"}, \
 /*36*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
-		"SPI 24 bit address"}, \
+		"SPI0 24 bit address"}, \
 /*37*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
-		"SPI 32 bit address"}, \
+		"SPI0 32 bit address"}, \
 /*38*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
-		"SPI 24 bit address"}, \
+		"SPI1 24 bit address"}, \
 /*39*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
-		"SPI 32 bit address"} \
+		"SPI1 32 bit address"} \
 }
 
 typedef struct {
-- 
1.7.5.4

