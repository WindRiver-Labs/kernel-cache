From 106bbb4a0895ce3d8e4ca5384f55e30d643b6e8b Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Thu, 29 Aug 2013 11:11:37 +0300
Subject: [PATCH 0978/1825] fix: alp: added required routines for active_units
 command

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 055c4d5c75c81719670ee423387149c32852fe2d

	Added 'active_units' command (fully supported and tested on ALP and A375).
	This detects current configuration on board, and prints which interfaces are active.
	Supported interfaces : cpu, pex, egiga, usb, mmc, sata, spi, nand, i2c, tdm

	- removed NAND & SPI defines from mvSysHwConfig, so build sequence will define them if needed
		(according to requested interfaces in build command)
	- Added routine mvBoardIsEthConnected to detect if egiga ports are activated and usable
	- Added help routine mvBoardMacCpuSwitchPortGet to determine which of the egiga's is the CPU port
	- Added USB3_UNIT_ID to SocUnitNums table, and a routine mvCtrlUsb3MaxGet
	- Added routine mvCtrlPexActiveUnitNumGet to detect number of active PCIe slots
	- updated mvCtrlSataMaxPortGet & mvCtrlSdioSupport to consider HW limitations for specifc board

Change-Id: I606a949b970ac0fa619a6f1b7db8e8d01fa2969a
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3126
Reviewed-by: Kosta Zertsekel <konszert@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   83 +++++++++++++++++++-
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    2 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |   65 ++++++++++++++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    4 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    1 +
 5 files changed, 149 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 51c6868..76e8895 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -2843,7 +2843,7 @@ MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
 {
-	MV_U32 c = board->pBoardModTypeValue->ethSataComplexOpt;
+	MV_U32 c = mvBoardEthComplexConfigGet();
 	MV_U32 cpuPort = -1;
 
 	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
@@ -2857,6 +2857,87 @@ MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
 }
 
 /*******************************************************************************
+* mvBoardIsEthConnected - detect if a certain Ethernet port is active
+*
+* DESCRIPTION:
+*	This routine returns true if a certain Ethernet port is active and usable
+*
+* INPUT:
+*	ethNum - index of the ethernet port requested
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if the requested ethernet port is connected and usable.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum)
+{
+	MV_U32 c = mvBoardEthComplexConfigGet();
+	MV_BOOL isConnected = MV_FALSE;
+
+	if (ethNum >= board->numBoardMacInfo) {
+		mvOsPrintf("%s: Error: Illegal port number(%u)\n", __func__, ethNum);
+		return MV_FALSE;
+	}
+
+	/*
+	 * Determine if port is both active and usable:
+	 * 1. active : if MAC is set as active in Ethernet complex board configuration
+	 * 2. usable : - MAC always usable when connected to RGMII, COMPHY, or GE-PHY
+	 *             - if connected to switch ,a MAC is usable only as the CPU Port
+	 *               (if a 2nd MAC is connected to switch, it used for Loopback)
+	 */
+
+	if ((ethNum == 0) && ((c & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0) ||
+			(c & MV_ETHCOMP_GE_MAC0_2_RGMII0) ||
+			(c & MV_ETHCOMP_GE_MAC0_2_COMPHY_2) ||
+			((c & MV_ETHCOMP_GE_MAC0_2_SW_P6) && mvBoardMacCpuPortGet() == 0)))
+			isConnected = MV_TRUE;
+
+	if ((ethNum == 1) && ((c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3) ||
+			(c & MV_ETHCOMP_GE_MAC1_2_RGMII1) ||
+			((c & MV_ETHCOMP_GE_MAC1_2_SW_P4) && mvBoardMacCpuPortGet() == 1)))
+			isConnected = MV_TRUE;
+
+	return isConnected;
+}
+
+/*******************************************************************************
+* mvBoardMacCpuPortGet - returns the MAC CPU port connected to switch
+*
+* DESCRIPTION:
+*	This routine returns true returns the MAC CPU port connected to switch
+*
+* INPUT:
+*	None
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*	the MAC CPU port number connected to switch
+*
+*******************************************************************************/
+MV_U32 mvBoardMacCpuPortGet(MV_VOID)
+{
+	MV_U32 c = mvBoardEthComplexConfigGet();
+	MV_U32 macCpuPort = -1;
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)		/* MAC0 is the default CPU port */
+		macCpuPort = 0;
+	/* only If MAC0 isn't connected to switch, then MAC1 is the CPU port
+	 * If both MAC0 and MAC1 connected to switch, MAC1 is used for Loopback */
+	else if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
+		macCpuPort = 1;
+	else
+		DB(mvOsPrintf("%s: Error: No MAC CPU port.\n", __func__));
+
+	return macCpuPort;
+}
+
+/*******************************************************************************
 * mvBoardIsQsgmiiModuleConnected
 *
 * DESCRIPTION:
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index d2032fe..1d8de8c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -550,6 +550,8 @@ MV_32 mvBoardRgmiiASwitchPortGet(void);
 MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
 MV_VOID mvBoardMacSpeedSet(MV_U32 ethPortNum, MV_BOARD_MAC_SPEED macSpeed);
 MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
+MV_U32 mvBoardMacCpuPortGet(MV_VOID);
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum);
 MV_32 mvBoardSwitchIrqGet(MV_VOID);
 MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort);
 MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 95b0cc9..54b361e 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -222,6 +222,7 @@ MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_66xx_INDEX_MAX] = {
 /* PEX_UNIT_ID          */ { 2,                 1,              0, },
 /* ETH_GIG_UNIT_ID      */ { 2,                 2,              2, },
 /* USB_UNIT_ID          */ { 1,                 1,              0, },
+/* USB3_UNIT_ID         */ { 1,                 0,              0, },
 /* IDMA_UNIT_ID         */ { 0,                 0,              0, },
 /* XOR_UNIT_ID          */ { 2,                 0,              0, },
 /* SATA_UNIT_ID         */ { 2,                 0,              0, },
@@ -844,6 +845,34 @@ MV_U32 mvCtrlPexMaxUnitGet(MV_VOID)
 	return mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
 }
 
+/*******************************************************************************
+* mvCtrlPexActiveUnitNumGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexActiveUnitNumGet(MV_VOID)
+{
+	/* check board configuration for DB-6660:
+	 * if PEX1 is disabled , only PEX0 is active (return constant 1)
+	 * (only if MV_CONFIG_LANE1=0 --> then LANE1=PEX) */
+	if (mvBoardIdGet() == DB_6660_ID && mvCtrlSysConfigGet(MV_CONFIG_LANE1) != 0x0)
+		return 1;
+
+	/* else, all PEX interfaces are active */
+	return mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
+}
+
 #if defined(MV_INCLUDE_PCI)
 /*******************************************************************************
 * mvCtrlPciMaxIfGet
@@ -916,7 +945,11 @@ MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
 {
-	return mvCtrlSocUnitInfoNumGet(SATA_UNIT_ID);
+	/* Typical HW setup for DB-6660 is is with 1 SATA only*/
+	if (mvBoardIdGet() == DB_6660_ID)
+		return 1;
+	else
+		return mvCtrlSocUnitInfoNumGet(SATA_UNIT_ID);
 }
 
 #endif
@@ -968,7 +1001,7 @@ MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
 
 #if defined(MV_INCLUDE_USB)
 /*******************************************************************************
-* mvCtrlUsbMaxGet - Get number of Marvell Usb  controllers
+* mvCtrlUsbMaxGet - Get number of Marvell USB controllers
 *
 * DESCRIPTION:
 *
@@ -979,7 +1012,7 @@ MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
 *       None.
 *
 * RETURN:
-*       returns number of Marvell USB  controllers.
+*       returns number of Marvell USB controllers.
 *
 *******************************************************************************/
 MV_U32 mvCtrlUsbMaxGet(void)
@@ -987,6 +1020,26 @@ MV_U32 mvCtrlUsbMaxGet(void)
 	return mvCtrlSocUnitInfoNumGet(USB_UNIT_ID);
 }
 
+/*******************************************************************************
+* mvCtrlUsb3MaxGet - Get number of Marvell USB 3.0 controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB 3.0 controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsb3MaxGet(void)
+{
+	return mvCtrlSocUnitInfoNumGet(USB3_UNIT_ID);
+}
+
 #endif
 
 #if defined(MV_INCLUDE_SDIO)
@@ -1007,7 +1060,11 @@ MV_U32 mvCtrlUsbMaxGet(void)
 *******************************************************************************/
 MV_U32 mvCtrlSdioSupport(MV_VOID)
 {
-	return mvCtrlSocUnitInfoNumGet(SDIO_UNIT_ID) ? MV_TRUE : MV_FALSE;
+	/* default HW setup is with SDIO only for RD-6660*/
+	if (mvBoardIdGet() == RD_6660_ID)
+		return mvCtrlSocUnitInfoNumGet(SDIO_UNIT_ID) ? MV_TRUE : MV_FALSE;
+	else
+		return 0;
 }
 
 #endif
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 1fbdd0a..d630586 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -268,7 +268,7 @@ MV_U32 mvCtrlPexMaxUnitGet(MV_VOID);
 #else
 #define mvCtrlPciMaxIfGet()             1
 #endif
-
+MV_U32 mvCtrlPexActiveUnitNumGet(MV_VOID);
 #if defined(MV_INCLUDE_PCI)
 #define mvCtrlPciIfMaxIfGet()           1
 #else
@@ -276,12 +276,14 @@ MV_U32 mvCtrlPexMaxUnitGet(MV_VOID);
 #endif
 
 MV_U32 mvCtrlEthMaxPortGet(MV_VOID);
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID);
 #if defined(MV_INCLUDE_XOR)
 MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
 MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
 #endif
 #if defined(MV_INCLUDE_USB)
 MV_U32 mvCtrlUsbMaxGet(MV_VOID);
+MV_U32 mvCtrlUsb3MaxGet(MV_VOID);
 #endif
 #if defined(MV_INCLUDE_SDIO)
 MV_U32 mvCtrlSdioSupport(MV_VOID);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index 5c86ada..af1570b 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -413,6 +413,7 @@ typedef enum _mvUnitId {
 	PEX_UNIT_ID,
 	ETH_GIG_UNIT_ID,
 	USB_UNIT_ID,
+	USB3_UNIT_ID,
 	IDMA_UNIT_ID,
 	XOR_UNIT_ID,
 	SATA_UNIT_ID,
-- 
1.7.5.4

