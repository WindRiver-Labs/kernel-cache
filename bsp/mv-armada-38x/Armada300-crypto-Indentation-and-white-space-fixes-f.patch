From cfcc238395d848f2d9222de5e175b4d5a79af1c8 Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Thu, 13 Dec 2012 19:43:40 +0200
Subject: [PATCH 1796/1825] Armada300,crypto: Indentation and white space
 fixes for crypto code.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 7b0d7b12d2b6bb66d99f83305e7f68344570eb59

Change-Id: I2491bf96486776b1baaa8da79be0da7a842f8587
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 cesa/openswan/README                         |    2 +-
 crypto/ocf/crypto.c                          |   46 ++--
 crypto/ocf/cryptodev.c                       |   54 ++--
 crypto/ocf/cryptodev.h                       |    4 +-
 crypto/ocf/cryptosoft.c                      |  476 +++++++++++++-------------
 crypto/ocf/ep80579/Makefile                  |   84 +++---
 crypto/ocf/ep80579/environment.mk            |   80 +++---
 crypto/ocf/ep80579/icp_asym.c                |  184 +++++-----
 crypto/ocf/ep80579/icp_common.c              |  128 ++++----
 crypto/ocf/ep80579/icp_ocf.h                 |   84 +++---
 crypto/ocf/ep80579/icp_sym.c                 |  110 +++---
 crypto/ocf/ep80579/linux_2.6_kernel_space.mk |   80 +++---
 crypto/ocf/hifn/hifn7751.c                   |   14 +-
 crypto/ocf/hifn/hifn7751reg.h                |    4 +-
 crypto/ocf/hifn/hifn7751var.h                |    8 +-
 crypto/ocf/hifn/hifnHIPP.c                   |   10 +-
 crypto/ocf/hifn/hifnHIPPvar.h                |    2 +-
 crypto/ocf/ixp4xx/ixp4xx.c                   |   22 +-
 crypto/ocf/random.c                          |    2 +-
 crypto/ocf/safe/md5.c                        |   28 +-
 crypto/ocf/safe/safe.c                       |   24 +-
 crypto/ocf/safe/safereg.h                    |    2 +-
 crypto/ocf/talitos/talitos.c                 |  178 +++++-----
 crypto/ocf/talitos/talitos_dev.h             |   18 +-
 24 files changed, 822 insertions(+), 822 deletions(-)

diff --git a/cesa/openswan/README b/cesa/openswan/README
index ccbd457..288ed2c 100644
--- a/cesa/openswan/README
+++ b/cesa/openswan/README
@@ -3,7 +3,7 @@ OpenSWAN
 In order to explore the CESA through the OpenSWAN, please follow the next steps:
 
 1. Download openswan-2.6.38 (http://www.openswan.org/), then untar+unzip it.
- 
+
 2. Apply the patch:
 	- 0001-marvell-patch-for-openswan-2.6.38.patch:
 		> Disable default DEBUG support.
diff --git a/crypto/ocf/crypto.c b/crypto/ocf/crypto.c
index 123140be..01b83f5 100644
--- a/crypto/ocf/crypto.c
+++ b/crypto/ocf/crypto.c
@@ -787,7 +787,7 @@ crypto_unblock(u_int32_t driverid, int what)
 			cap->cc_unkqblocked = 0;
 			crypto_all_kqblocked = 0;
 		}
-			wake_up_interruptible(&cryptoproc_wait);
+		wake_up_interruptible(&cryptoproc_wait);
 		err = 0;
 	} else
 		err = EINVAL;
@@ -821,7 +821,7 @@ crypto_dispatch(struct cryptop *crp)
 	crp->crp_flags &= ~CRYPTO_F_DONE;
 	crp->crp_etype = 0;
 
-#ifdef CONFIG_MV_CESA_OCF
+#if defined(CONFIG_MV_CESA_OCF) || defined(CONFIG_MV_CESA_OCF_KW2)
 
 	CRYPTO_Q_UNLOCK();
 
@@ -835,20 +835,20 @@ crypto_dispatch(struct cryptop *crp)
 
 		result = crypto_invoke(cap, crp, 0);
 		if (result != 0)
-            	    cryptostats.cs_drops++;
+			cryptostats.cs_drops++;
 	} else {
 		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
 		result = 0;
 		wake_up_interruptible(&cryptoproc_wait);
 		CRYPTO_Q_UNLOCK();
-		} 
+	}
 #else
 
-		/*
+	/*
 	 * Caller marked the request to be processed immediately; dispatch
 	 * it directly to the driver unless the driver is currently blocked.
-		 */
+	 */
 	if ((crp->crp_flags & CRYPTO_F_BATCH) == 0) {
 		int hid = CRYPTO_SESID2HID(crp->crp_sid);
 		cap = crypto_checkdriver(hid);
@@ -859,7 +859,7 @@ crypto_dispatch(struct cryptop *crp)
 			crypto_drivers[hid].cc_unqblocked = 1;
 			CRYPTO_Q_UNLOCK();
 			result = crypto_invoke(cap, crp, 0);
-      		CRYPTO_Q_LOCK();
+			CRYPTO_Q_LOCK();
 			if (result == ERESTART)
 				if (crypto_drivers[hid].cc_unqblocked)
 					crypto_drivers[hid].cc_qblocked = 1;
@@ -883,10 +883,10 @@ crypto_dispatch(struct cryptop *crp)
 		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
 		result = 0;
 	}
-			wake_up_interruptible(&cryptoproc_wait);
-		CRYPTO_Q_UNLOCK();
+	wake_up_interruptible(&cryptoproc_wait);
+	CRYPTO_Q_UNLOCK();
 #endif
-	
+
 	return result;
 }
 
@@ -906,7 +906,7 @@ crypto_kdispatch(struct cryptkop *krp)
 	if (error == ERESTART) {
 		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_kq, krp, krp_next);
-			wake_up_interruptible(&cryptoproc_wait);
+		wake_up_interruptible(&cryptoproc_wait);
 		CRYPTO_Q_UNLOCK();
 		error = 0;
 	}
@@ -1204,7 +1204,7 @@ crypto_done(struct cryptop *crp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
+		wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_q, crp, crp_next);
 		CRYPTO_RETQ_UNLOCK();
 	}
@@ -1254,7 +1254,7 @@ crypto_kdone(struct cryptkop *krp)
 		 * Normal case; queue the callback for the thread.
 		 */
 		CRYPTO_RETQ_LOCK();
-			wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
+		wake_up_interruptible(&cryptoretproc_wait);/* shared wait channel */
 		TAILQ_INSERT_TAIL(&crp_ret_kq, krp, krp_next);
 		CRYPTO_RETQ_UNLOCK();
 	}
@@ -1377,7 +1377,7 @@ crypto_proc(void *arg)
 				list_add(&submit->crp_next, &crp_q);
 				cryptostats.cs_blocks++;
 				if (crypto_drivers[hid].cc_unqblocked)
-				crypto_drivers[hid].cc_qblocked=0;
+					crypto_drivers[hid].cc_qblocked=0;
 				crypto_drivers[hid].cc_unqblocked=0;
 			}
 			crypto_drivers[hid].cc_unqblocked = 0;
@@ -1708,10 +1708,10 @@ crypto_init(void)
 									"ocf_%d", (int) cpu);
 		if (IS_ERR(cryptoproc[cpu])) {
 			error = PTR_ERR(cryptoproc[cpu]);
-		printk("crypto: crypto_init cannot start crypto thread; error %d",
-			error);
-		goto bad;
-	}
+			printk("crypto: crypto_init cannot start crypto thread; error %d",
+				error);
+			goto bad;
+		}
 		kthread_bind(cryptoproc[cpu], cpu);
 		wake_up_process(cryptoproc[cpu]);
 
@@ -1719,10 +1719,10 @@ crypto_init(void)
 									"ocf_ret_%d", (int) cpu);
 		if (IS_ERR(cryptoretproc[cpu])) {
 			error = PTR_ERR(cryptoretproc[cpu]);
-		printk("crypto: crypto_init cannot start cryptoret thread; error %d",
-				error);
-		goto bad;
-	}
+			printk("crypto: crypto_init cannot start cryptoret thread; error %d",
+					error);
+			goto bad;
+		}
 		kthread_bind(cryptoretproc[cpu], cpu);
 		wake_up_process(cryptoretproc[cpu]);
 	}
@@ -1749,7 +1749,7 @@ crypto_exit(void)
 		kthread_stop(cryptoretproc[cpu]);
 	}
 
-	/* 
+	/*
 	 * Reclaim dynamically allocated resources.
 	 */
 	if (crypto_drivers != NULL)
diff --git a/crypto/ocf/cryptodev.c b/crypto/ocf/cryptodev.c
index 10faffb..a21b967 100644
--- a/crypto/ocf/cryptodev.c
+++ b/crypto/ocf/cryptodev.c
@@ -135,7 +135,7 @@ checkcrid(int crid)
 	int hid = crid & ~(CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_HARDWARE);
 	int typ = crid & (CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_HARDWARE);
 	int caps = 0;
-	
+
 	/* if the user hasn't selected a driver, then just call newsession */
 	if (hid == 0 && typ != 0)
 		return 0;
@@ -147,7 +147,7 @@ checkcrid(int crid)
 		dprintk("%s: hid=%x typ=%x not matched\n", __FUNCTION__, hid, typ);
 		return EINVAL;
 	}
-	
+
 	/* the user didn't specify SW or HW, so the driver is ok */
 	if (typ == 0)
 		return 0;
@@ -214,7 +214,7 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 			crde = crp->crp_desc;
 			crda = crde->crd_next;
 		} else {
-		crda = crp->crp_desc;
+			crda = crp->crp_desc;
 			crde = crda->crd_next;
 		}
 	} else if (cse->info.authsize) {
@@ -222,10 +222,10 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 	} else if (cse->info.blocksize) {
 		crde = crp->crp_desc;
 	} else {
-			dprintk("%s: bad request\n", __FUNCTION__);
-			error = EINVAL;
-			goto bail;
-		}
+		dprintk("%s: bad request\n", __FUNCTION__);
+		error = EINVAL;
+		goto bail;
+	}
 
 	if ((error = copy_from_user(cse->uio.uio_iov[0].iov_base, cop->src,
 					cop->len))) {
@@ -310,26 +310,26 @@ cryptodev_op(struct csession *cse, struct crypt_op *cop)
 		goto bail;
 	}
 
-		dprintk("%s about to WAIT\n", __FUNCTION__);
+	dprintk("%s about to WAIT\n", __FUNCTION__);
+	/*
+	 * we really need to wait for driver to complete to maintain
+	 * state,  luckily interrupts will be remembered
+	 */
+	do {
+		error = wait_event_interruptible(crp->crp_waitq,
+				((crp->crp_flags & CRYPTO_F_DONE) != 0));
 		/*
-		 * we really need to wait for driver to complete to maintain
-		 * state,  luckily interrupts will be remembered
+		 * we can't break out of this loop or we will leave behind
+		 * a huge mess,  however,  staying here means if your driver
+		 * is broken user applications can hang and not be killed.
+		 * The solution,  fix your driver :-)
 		 */
-		do {
-			error = wait_event_interruptible(crp->crp_waitq,
-					((crp->crp_flags & CRYPTO_F_DONE) != 0));
-			/*
-			 * we can't break out of this loop or we will leave behind
-			 * a huge mess,  however,  staying here means if your driver
-			 * is broken user applications can hang and not be killed.
-			 * The solution,  fix your driver :-)
-			 */
-			if (error) {
-				schedule();
-				error = 0;
-			}
-		} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
-		dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
+		if (error) {
+			schedule();
+			error = 0;
+		}
+	} while ((crp->crp_flags & CRYPTO_F_DONE) == 0);
+	dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
 
 	if (crp->crp_etype != 0) {
 		error = crp->crp_etype;
@@ -491,7 +491,7 @@ cryptodev_key(struct crypt_kop *kop)
 	} while ((krp->krp_flags & CRYPTO_KF_DONE) == 0);
 
 	dprintk("%s finished WAITING error=%d\n", __FUNCTION__, error);
-	
+
 	kop->crk_crid = krp->krp_crid;		/* device that did the work */
 	if (krp->krp_status != 0) {
 		error = krp->krp_status;
@@ -565,7 +565,7 @@ csedelete(struct fcrypt *fcr, struct csession *cse_del)
 	}
 	return (0);
 }
-	
+
 static struct csession *
 cseadd(struct fcrypt *fcr, struct csession *cse)
 {
diff --git a/crypto/ocf/cryptodev.h b/crypto/ocf/cryptodev.h
index cca0ec8..30f6add 100644
--- a/crypto/ocf/cryptodev.h
+++ b/crypto/ocf/cryptodev.h
@@ -185,7 +185,7 @@ struct session_op {
 	int		mackeylen;	/* mac key */
 	caddr_t		mackey;
 
-  	u_int32_t	ses;		/* returns: session # */ 
+  	u_int32_t	ses;		/* returns: session # */
 };
 
 struct session2_op {
@@ -197,7 +197,7 @@ struct session2_op {
 	int		mackeylen;	/* mac key */
 	caddr_t		mackey;
 
-  	u_int32_t	ses;		/* returns: session # */ 
+  	u_int32_t	ses;		/* returns: session # */
 	int		crid;		/* driver id + flags (rw) */
 	int		pad[4];		/* for future expansion */
 };
diff --git a/crypto/ocf/cryptosoft.c b/crypto/ocf/cryptosoft.c
index 79bf76b..d6b5f73 100644
--- a/crypto/ocf/cryptosoft.c
+++ b/crypto/ocf/cryptosoft.c
@@ -439,14 +439,14 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				dprintk("%s %s cipher is async\n", __FUNCTION__, algo);
 				(*swd)->sw_type |= SW_TYPE_ASYNC;
 			} else {
-			(*swd)->sw_tfm = crypto_blkcipher_tfm(
+				(*swd)->sw_tfm = crypto_blkcipher_tfm(
 						crypto_alloc_blkcipher(algo, 0, CRYPTO_ALG_ASYNC));
 				if ((*swd)->sw_tfm && !IS_ERR((*swd)->sw_tfm))
 					dprintk("%s %s cipher is sync\n", __FUNCTION__, algo);
 			}
 			if (!(*swd)->sw_tfm || IS_ERR((*swd)->sw_tfm)) {
 				int err;
-				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s,0x%x)\n",
+				dprintk("cryptosoft: crypto_alloc_blkcipher failed(%s, 0x%x)\n",
 						algo,mode);
 				err = IS_ERR((*swd)->sw_tfm) ? -(PTR_ERR((*swd)->sw_tfm)) : EINVAL;
 				(*swd)->sw_tfm = NULL; /* ensure NULL */
@@ -456,7 +456,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 
 			if (debug) {
 				dprintk("%s key:cri->cri_klen=%d,(cri->cri_klen + 7)/8=%d",
-						__FUNCTION__,cri->cri_klen,(cri->cri_klen + 7)/8);
+						__FUNCTION__, cri->cri_klen, (cri->cri_klen + 7) / 8);
 				for (i = 0; i < (cri->cri_klen + 7) / 8; i++)
 					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
 							cri->cri_key[i] & 0xff);
@@ -475,7 +475,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				crypto_blkcipher_set_flags(
 						crypto_blkcipher_cast((*swd)->sw_tfm),
 							CRYPTO_TFM_REQ_WEAK_KEY);
-			error = crypto_blkcipher_setkey(
+				error = crypto_blkcipher_setkey(
 							crypto_blkcipher_cast((*swd)->sw_tfm),
 								cri->cri_key, (cri->cri_klen + 7) / 8);
 			}
@@ -497,8 +497,8 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 				(*swd)->sw_type |= SW_TYPE_ASYNC;
 			} else {
 				dprintk("%s %s hash is sync\n", __FUNCTION__, algo);
-			(*swd)->sw_tfm = crypto_hash_tfm(
-								crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
+				(*swd)->sw_tfm = crypto_hash_tfm(
+						crypto_alloc_hash(algo, 0, CRYPTO_ALG_ASYNC));
 			}
 
 			if (!(*swd)->sw_tfm) {
@@ -510,7 +510,7 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 
 			(*swd)->u.hmac.sw_klen = (cri->cri_klen + 7) / 8;
 			(*swd)->u.hmac.sw_key = (char *)kmalloc((*swd)->u.hmac.sw_klen,
-				SLAB_ATOMIC);
+					SLAB_ATOMIC);
 			if ((*swd)->u.hmac.sw_key == NULL) {
 				swcr_freesession(NULL, i);
 				dprintk("%s,%d: ENOBUFS\n", __FILE__, __LINE__);
@@ -522,9 +522,9 @@ swcr_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			} else if ((*swd)->sw_type & SW_TYPE_ASYNC) {
 				(*swd)->u.hmac.sw_mlen = crypto_ahash_digestsize(
 						__crypto_ahash_cast((*swd)->sw_tfm));
-			} else {
+			} else  {
 				(*swd)->u.hmac.sw_mlen = crypto_hash_digestsize(
-								crypto_hash_cast((*swd)->sw_tfm));
+						crypto_hash_cast((*swd)->sw_tfm));
 			}
 		} else if ((*swd)->sw_type & SW_TYPE_COMP) {
 			(*swd)->sw_tfm = crypto_comp_tfm(
@@ -602,7 +602,7 @@ swcr_freesession(device_t dev, u_int64_t tid)
 					crypto_free_comp(crypto_comp_cast(swd->sw_tfm));
 				break;
 			default:
-			crypto_free_tfm(swd->sw_tfm);
+				crypto_free_tfm(swd->sw_tfm);
 				break;
 			}
 			swd->sw_tfm = NULL;
@@ -668,7 +668,7 @@ done:
 	dprintk("%s crypto_done %p\n", __FUNCTION__, req);
 	crypto_done(req->crp);
 	kmem_cache_free(swcr_req_cache, req);
-		}
+}
 
 #if defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH)
 static void swcr_process_callback(struct crypto_async_request *creq, int err)
@@ -681,10 +681,10 @@ static void swcr_process_callback(struct crypto_async_request *creq, int err)
 			return;
 		dprintk("%s() fail %d\n", __FUNCTION__, -err);
 		req->crp->crp_etype = -err;
-		}
+	}
 
 	swcr_process_req_complete(req);
-	}
+}
 #endif /* defined(HAVE_ABLKCIPHER) || defined(HAVE_AHASH) */
 
 
@@ -699,25 +699,25 @@ static void swcr_process_req(struct swcr_req *req)
 
 	dprintk("%s()\n", __FUNCTION__);
 
-		/*
-		 * Find the crypto context.
-		 *
-		 * XXX Note that the logic here prevents us from having
-		 * XXX the same algorithm multiple times in a session
-		 * XXX (or rather, we can but it won't give us the right
-		 * XXX results). To do that, we'd need some way of differentiating
-		 * XXX between the various instances of an algorithm (so we can
-		 * XXX locate the correct crypto context).
-		 */
+	/*
+	 * Find the crypto context.
+	 *
+	 * XXX Note that the logic here prevents us from having
+	 * XXX the same algorithm multiple times in a session
+	 * XXX (or rather, we can but it won't give us the right
+	 * XXX results). To do that, we'd need some way of differentiating
+	 * XXX between the various instances of an algorithm (so we can
+	 * XXX locate the correct crypto context).
+	 */
 	for (sw = req->sw_head; sw && sw->sw_alg != crd->crd_alg; sw = sw->sw_next)
-			;
+		;
 
-		/* No such context ? */
-		if (sw == NULL) {
-			crp->crp_etype = EINVAL;
-			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-			goto done;
-		}
+	/* No such context ? */
+	if (sw == NULL) {
+		crp->crp_etype = EINVAL;
+		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		goto done;
+	}
 
 	/*
 	 * for some types we need to ensure only one user as info is stored in
@@ -743,77 +743,77 @@ static void swcr_process_req(struct swcr_req *req)
 	}
 
 	req->sw = sw;
-		skip = crd->crd_skip;
+	skip = crd->crd_skip;
 
-		/*
-		 * setup the SG list skip from the start of the buffer
-		 */
+	/*
+	 * setup the SG list skip from the start of the buffer
+	 */
 	memset(req->sg, 0, sizeof(req->sg));
 	sg_init_table(req->sg, SCATTERLIST_MAX);
-		if (crp->crp_flags & CRYPTO_F_SKBUF) {
-			int i, len;
+	if (crp->crp_flags & CRYPTO_F_SKBUF) {
+		int i, len;
+
+		sg_num = 0;
+		sg_len = 0;
 
-			sg_num = 0;
-			sg_len = 0;
+		if (skip < skb_headlen(skb)) {
+			len = skb_headlen(skb) - skip;
+			if (len + sg_len > crd->crd_len)
+				len = crd->crd_len - sg_len;
+			sg_set_page(&req->sg[sg_num],
+				virt_to_page(skb->data + skip), len,
+				offset_in_page(skb->data + skip));
+			sg_len += len;
+			sg_num++;
+			skip = 0;
+		} else
+			skip -= skb_headlen(skb);
 
-			if (skip < skb_headlen(skb)) {
-				len = skb_headlen(skb) - skip;
+		for (i = 0; sg_len < crd->crd_len &&
+					i < skb_shinfo(skb)->nr_frags &&
+					sg_num < SCATTERLIST_MAX; i++) {
+			if (skip < skb_shinfo(skb)->frags[i].size) {
+				len = skb_shinfo(skb)->frags[i].size - skip;
 				if (len + sg_len > crd->crd_len)
 					len = crd->crd_len - sg_len;
-			sg_set_page(&req->sg[sg_num],
-					virt_to_page(skb->data + skip), len,
-					offset_in_page(skb->data + skip));
+				sg_set_page(&req->sg[sg_num],
+					skb_frag_page(&skb_shinfo(skb)->frags[i]),
+					len,
+					skb_shinfo(skb)->frags[i].page_offset + skip);
 				sg_len += len;
 				sg_num++;
 				skip = 0;
 			} else
-				skip -= skb_headlen(skb);
-
-			for (i = 0; sg_len < crd->crd_len &&
-						i < skb_shinfo(skb)->nr_frags &&
-						sg_num < SCATTERLIST_MAX; i++) {
-				if (skip < skb_shinfo(skb)->frags[i].size) {
-					len = skb_shinfo(skb)->frags[i].size - skip;
-					if (len + sg_len > crd->crd_len)
-						len = crd->crd_len - sg_len;
-				sg_set_page(&req->sg[sg_num],
-					skb_frag_page(&skb_shinfo(skb)->frags[i]),
-						len,
-						skb_shinfo(skb)->frags[i].page_offset + skip);
-					sg_len += len;
-					sg_num++;
-					skip = 0;
-				} else
-					skip -= skb_shinfo(skb)->frags[i].size;
-			}
-		} else if (crp->crp_flags & CRYPTO_F_IOV) {
-			int len;
+				skip -= skb_shinfo(skb)->frags[i].size;
+		}
+	} else if (crp->crp_flags & CRYPTO_F_IOV) {
+		int len;
 
-			sg_len = 0;
+		sg_len = 0;
 		for (sg_num = 0; sg_len < crd->crd_len &&
-					sg_num < uiop->uio_iovcnt &&
-					sg_num < SCATTERLIST_MAX; sg_num++) {
-				if (skip <= uiop->uio_iov[sg_num].iov_len) {
-					len = uiop->uio_iov[sg_num].iov_len - skip;
-					if (len + sg_len > crd->crd_len)
-						len = crd->crd_len - sg_len;
+				sg_num < uiop->uio_iovcnt &&
+				sg_num < SCATTERLIST_MAX; sg_num++) {
+			if (skip <= uiop->uio_iov[sg_num].iov_len) {
+				len = uiop->uio_iov[sg_num].iov_len - skip;
+				if (len + sg_len > crd->crd_len)
+					len = crd->crd_len - sg_len;
 				sg_set_page(&req->sg[sg_num],
-						virt_to_page(uiop->uio_iov[sg_num].iov_base+skip),
-						len,
-						offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
-					sg_len += len;
-					skip = 0;
-				} else 
-					skip -= uiop->uio_iov[sg_num].iov_len;
-			}
-		} else {
-			sg_len = (crp->crp_ilen - skip);
-			if (sg_len > crd->crd_len)
-				sg_len = crd->crd_len;
-		sg_set_page(&req->sg[0], virt_to_page(crp->crp_buf + skip),
-				sg_len, offset_in_page(crp->crp_buf + skip));
-			sg_num = 1;
+					virt_to_page(uiop->uio_iov[sg_num].iov_base+skip),
+					len,
+					offset_in_page(uiop->uio_iov[sg_num].iov_base+skip));
+				sg_len += len;
+				skip = 0;
+			} else
+				skip -= uiop->uio_iov[sg_num].iov_len;
 		}
+	} else {
+		sg_len = (crp->crp_ilen - skip);
+		if (sg_len > crd->crd_len)
+			sg_len = crd->crd_len;
+		sg_set_page(&req->sg[0], virt_to_page(crp->crp_buf + skip),
+			sg_len, offset_in_page(crp->crp_buf + skip));
+		sg_num = 1;
+	}
 	if (sg_num > 0)
 		sg_mark_end(&req->sg[sg_num-1]);
 
@@ -964,190 +964,190 @@ static void swcr_process_req(struct swcr_req *req)
 		} break;
 #endif /* HAVE_ABLKCIPHER */
 
-		case SW_TYPE_BLKCIPHER: {
-			unsigned char iv[EALG_MAX_BLOCK_LEN];
-			unsigned char *ivp = iv;
-			struct blkcipher_desc desc;
+	case SW_TYPE_BLKCIPHER: {
+		unsigned char iv[EALG_MAX_BLOCK_LEN];
+		unsigned char *ivp = iv;
+		struct blkcipher_desc desc;
 		int ivsize = crypto_blkcipher_ivsize(crypto_blkcipher_cast(sw->sw_tfm));
 
-			if (sg_len < crypto_blkcipher_blocksize(
-					crypto_blkcipher_cast(sw->sw_tfm))) {
-				crp->crp_etype = EINVAL;
-				dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
-						sg_len, crypto_blkcipher_blocksize(
-							crypto_blkcipher_cast(sw->sw_tfm)));
-				goto done;
-			}
+		if (sg_len < crypto_blkcipher_blocksize(
+				crypto_blkcipher_cast(sw->sw_tfm))) {
+			crp->crp_etype = EINVAL;
+			dprintk("%s,%d: EINVAL len %d < %d\n", __FILE__, __LINE__,
+					sg_len, crypto_blkcipher_blocksize(
+						crypto_blkcipher_cast(sw->sw_tfm)));
+			goto done;
+		}
 
-			if (ivsize > sizeof(iv)) {
-				crp->crp_etype = EINVAL;
-				dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-				goto done;
-			}
+		if (ivsize > sizeof(iv)) {
+			crp->crp_etype = EINVAL;
+			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+			goto done;
+		}
 
-			if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
-				int i, error;
+		if (crd->crd_flags & CRD_F_KEY_EXPLICIT) {
+			int i, error;
 
-				if (debug) {
-					dprintk("%s key:", __FUNCTION__);
-					for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
-						dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
+			if (debug) {
+				dprintk("%s key:", __FUNCTION__);
+				for (i = 0; i < (crd->crd_klen + 7) / 8; i++)
+					dprintk("%s0x%x", (i % 8) ? " " : "\n    ",
 							crd->crd_key[i] & 0xff);
-					dprintk("\n");
-				}
+				dprintk("\n");
+			}
 			/* OCF doesn't enforce keys */
 			crypto_blkcipher_set_flags(crypto_blkcipher_cast(sw->sw_tfm),
 					CRYPTO_TFM_REQ_WEAK_KEY);
-				error = crypto_blkcipher_setkey(
-							crypto_blkcipher_cast(sw->sw_tfm), crd->crd_key,
-							(crd->crd_klen + 7) / 8);
-				if (error) {
-					dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
-							error, sw->sw_tfm->crt_flags);
-					crp->crp_etype = -error;
-				}
+			error = crypto_blkcipher_setkey(
+						crypto_blkcipher_cast(sw->sw_tfm), crd->crd_key,
+						(crd->crd_klen + 7) / 8);
+			if (error) {
+				dprintk("cryptosoft: setkey failed %d (crt_flags=0x%x)\n",
+						error, sw->sw_tfm->crt_flags);
+				crp->crp_etype = -error;
 			}
+		}
+
+		memset(&desc, 0, sizeof(desc));
+		desc.tfm = crypto_blkcipher_cast(sw->sw_tfm);
 
-			memset(&desc, 0, sizeof(desc));
-			desc.tfm = crypto_blkcipher_cast(sw->sw_tfm);
-
-			if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
-
-				if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
-					ivp = crd->crd_iv;
-				} else {
-					get_random_bytes(ivp, ivsize);
-				}
-				/*
-				 * do we have to copy the IV back to the buffer ?
-				 */
-				if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
-					crypto_copyback(crp->crp_flags, crp->crp_buf,
-							crd->crd_inject, ivsize, (caddr_t)ivp);
-				}
-				desc.info = ivp;
+		if (crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
+
+			if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
+				ivp = crd->crd_iv;
+			} else {
+				get_random_bytes(ivp, ivsize);
+			}
+			/*
+			 * do we have to copy the IV back to the buffer ?
+			 */
+			if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+				crypto_copyback(crp->crp_flags, crp->crp_buf,
+						crd->crd_inject, ivsize, (caddr_t)ivp);
+			}
+			desc.info = ivp;
 			crypto_blkcipher_encrypt_iv(&desc, req->sg, req->sg, sg_len);
 
-			} else { /*decrypt */
+		} else { /*decrypt */
 
-				if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
-					ivp = crd->crd_iv;
-				} else {
-					crypto_copydata(crp->crp_flags, crp->crp_buf,
-							crd->crd_inject, ivsize, (caddr_t)ivp);
-				}
-				desc.info = ivp;
-			crypto_blkcipher_decrypt_iv(&desc, req->sg, req->sg, sg_len);
+			if (crd->crd_flags & CRD_F_IV_EXPLICIT) {
+				ivp = crd->crd_iv;
+			} else {
+				crypto_copydata(crp->crp_flags, crp->crp_buf,
+						crd->crd_inject, ivsize, (caddr_t)ivp);
 			}
-			} break;
+			desc.info = ivp;
+			crypto_blkcipher_decrypt_iv(&desc, req->sg, req->sg, sg_len);
+		}
+		} break;
 
-		case SW_TYPE_HMAC:
-		case SW_TYPE_HASH:
-			{
-			char result[HASH_MAX_LEN];
-			struct hash_desc desc;
+	case SW_TYPE_HMAC:
+	case SW_TYPE_HASH:
+		{
+		char result[HASH_MAX_LEN];
+		struct hash_desc desc;
 
-			/* check we have room for the result */
-			if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
+		/* check we have room for the result */
+		if (crp->crp_ilen - crd->crd_inject < sw->u.hmac.sw_mlen) {
 			dprintk("cryptosoft: EINVAL crp_ilen=%d, len=%d, inject=%d "
 					"digestsize=%d\n", crp->crp_ilen, crd->crd_skip + sg_len,
 					crd->crd_inject, sw->u.hmac.sw_mlen);
-				crp->crp_etype = EINVAL;
-				goto done;
-			}
+			crp->crp_etype = EINVAL;
+			goto done;
+		}
 
-			memset(&desc, 0, sizeof(desc));
-			desc.tfm = crypto_hash_cast(sw->sw_tfm);
+		memset(&desc, 0, sizeof(desc));
+		desc.tfm = crypto_hash_cast(sw->sw_tfm);
 
-			memset(result, 0, sizeof(result));
+		memset(result, 0, sizeof(result));
 
 		if (sw->sw_type & SW_TYPE_HMAC) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-				crypto_hmac(sw->sw_tfm, sw->u.hmac.sw_key, &sw->u.hmac.sw_klen,
+			crypto_hmac(sw->sw_tfm, sw->u.hmac.sw_key, &sw->u.hmac.sw_klen,
 					req->sg, sg_num, result);
 #else
-				crypto_hash_setkey(desc.tfm, sw->u.hmac.sw_key,
-						sw->u.hmac.sw_klen);
+			crypto_hash_setkey(desc.tfm, sw->u.hmac.sw_key,
+					sw->u.hmac.sw_klen);
 			crypto_hash_digest(&desc, req->sg, sg_len, result);
 #endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
-				
-			} else { /* SW_TYPE_HASH */
+
+		} else { /* SW_TYPE_HASH */
 			crypto_hash_digest(&desc, req->sg, sg_len, result);
-			}
+		}
 
-			crypto_copyback(crp->crp_flags, crp->crp_buf,
-					crd->crd_inject, sw->u.hmac.sw_mlen, result);
-			}
-			break;
+		crypto_copyback(crp->crp_flags, crp->crp_buf,
+				crd->crd_inject, sw->u.hmac.sw_mlen, result);
+		}
+		break;
 
-		case SW_TYPE_COMP: {
-			void *ibuf = NULL;
-			void *obuf = sw->u.sw_comp_buf;
-			int ilen = sg_len, olen = CRYPTO_MAX_DATA_LEN;
-			int ret = 0;
+	case SW_TYPE_COMP: {
+		void *ibuf = NULL;
+		void *obuf = sw->u.sw_comp_buf;
+		int ilen = sg_len, olen = CRYPTO_MAX_DATA_LEN;
+		int ret = 0;
 
-			/*
-			 * we need to use an additional copy if there is more than one
-			 * input chunk since the kernel comp routines do not handle
-			 * SG yet.  Otherwise we just use the input buffer as is.
-			 * Rather than allocate another buffer we just split the tmp
-			 * buffer we already have.
-			 * Perhaps we should just use zlib directly ?
-			 */
-			if (sg_num > 1) {
-				int blk;
+		/*
+		 * we need to use an additional copy if there is more than one
+		 * input chunk since the kernel comp routines do not handle
+		 * SG yet.  Otherwise we just use the input buffer as is.
+		 * Rather than allocate another buffer we just split the tmp
+		 * buffer we already have.
+		 * Perhaps we should just use zlib directly ?
+		 */
+		if (sg_num > 1) {
+			int blk;
 
-				ibuf = obuf;
-				for (blk = 0; blk < sg_num; blk++) {
+			ibuf = obuf;
+			for (blk = 0; blk < sg_num; blk++) {
 				memcpy(obuf, sg_virt(&req->sg[blk]),
 						req->sg[blk].length);
 				obuf += req->sg[blk].length;
-				}
-				olen -= sg_len;
-			} else
+			}
+			olen -= sg_len;
+		} else
 			ibuf = sg_virt(&req->sg[0]);
 
-			if (crd->crd_flags & CRD_F_ENCRYPT) { /* compress */
-				ret = crypto_comp_compress(crypto_comp_cast(sw->sw_tfm),
-						ibuf, ilen, obuf, &olen);
-				if (!ret && olen > crd->crd_len) {
-					dprintk("cryptosoft: ERANGE compress %d into %d\n",
-							crd->crd_len, olen);
-					if (swcr_fail_if_compression_grows)
-						ret = ERANGE;
-				}
-			} else { /* decompress */
-				ret = crypto_comp_decompress(crypto_comp_cast(sw->sw_tfm),
-						ibuf, ilen, obuf, &olen);
-				if (!ret && (olen + crd->crd_inject) > crp->crp_olen) {
-					dprintk("cryptosoft: ETOOSMALL decompress %d into %d, "
-							"space for %d,at offset %d\n",
-							crd->crd_len, olen, crp->crp_olen, crd->crd_inject);
-					ret = ETOOSMALL;
-				}
+		if (crd->crd_flags & CRD_F_ENCRYPT) { /* compress */
+			ret = crypto_comp_compress(crypto_comp_cast(sw->sw_tfm),
+					ibuf, ilen, obuf, &olen);
+			if (!ret && olen > crd->crd_len) {
+				dprintk("cryptosoft: ERANGE compress %d into %d\n",
+						crd->crd_len, olen);
+				if (swcr_fail_if_compression_grows)
+					ret = ERANGE;
 			}
-			if (ret)
-				dprintk("%s,%d: ret = %d\n", __FILE__, __LINE__, ret);
-
-			/*
-			 * on success copy result back,
-			 * linux crpyto API returns -errno,  we need to fix that
-			 */
-			crp->crp_etype = ret < 0 ? -ret : ret;
-			if (ret == 0) {
-				/* copy back the result and return it's size */
-				crypto_copyback(crp->crp_flags, crp->crp_buf,
-						crd->crd_inject, olen, obuf);
-				crp->crp_olen = olen;
+		} else { /* decompress */
+			ret = crypto_comp_decompress(crypto_comp_cast(sw->sw_tfm),
+					ibuf, ilen, obuf, &olen);
+			if (!ret && (olen + crd->crd_inject) > crp->crp_olen) {
+				dprintk("cryptosoft: ETOOSMALL decompress %d into %d, "
+						"space for %d,at offset %d\n",
+						crd->crd_len, olen, crp->crp_olen, crd->crd_inject);
+				ret = ETOOSMALL;
 			}
-			} break;
+		}
+		if (ret)
+			dprintk("%s,%d: ret = %d\n", __FILE__, __LINE__, ret);
 
-		default:
-			/* Unknown/unsupported algorithm */
-			dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
-			crp->crp_etype = EINVAL;
-			goto done;
+		/*
+		 * on success copy result back,
+		 * linux crpyto API returns -errno,  we need to fix that
+		 */
+		crp->crp_etype = ret < 0 ? -ret : ret;
+		if (ret == 0) {
+			/* copy back the result and return it's size */
+			crypto_copyback(crp->crp_flags, crp->crp_buf,
+					crd->crd_inject, olen, obuf);
+			crp->crp_olen = olen;
 		}
+		} break;
+
+	default:
+		/* Unknown/unsupported algorithm */
+		dprintk("%s,%d: EINVAL\n", __FILE__, __LINE__);
+		crp->crp_etype = EINVAL;
+		goto done;
+	}
 
 done:
 	swcr_process_req_complete(req);
@@ -1265,7 +1265,7 @@ cryptosoft_init(void)
 
 	for (i = 0; i < sizeof(crypto_details)/sizeof(crypto_details[0]); i++) {
 		int found;
-		
+
 		algo = crypto_details[i].alg_name;
 		if (!algo || !*algo) {
 			dprintk("%s:Algorithm %d not supported\n", __FUNCTION__, i);
@@ -1277,26 +1277,26 @@ cryptosoft_init(void)
 
 		found = 0;
 		switch (sw_type & SW_TYPE_ALG_MASK) {
-			case SW_TYPE_CIPHER:
+		case SW_TYPE_CIPHER:
 			found = crypto_has_cipher(algo, 0, CRYPTO_ALG_ASYNC);
-				break;
-			case SW_TYPE_HMAC:
+			break;
+		case SW_TYPE_HMAC:
 			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
-				break;
-			case SW_TYPE_HASH:
+			break;
+		case SW_TYPE_HASH:
 			found = crypto_has_hash(algo, 0, swcr_no_ahash?CRYPTO_ALG_ASYNC:0);
-				break;
-			case SW_TYPE_COMP:
+			break;
+		case SW_TYPE_COMP:
 			found = crypto_has_comp(algo, 0, CRYPTO_ALG_ASYNC);
-				break;
-			case SW_TYPE_BLKCIPHER:
+			break;
+		case SW_TYPE_BLKCIPHER:
 			found = crypto_has_blkcipher(algo, 0, CRYPTO_ALG_ASYNC);
 			if (!found && !swcr_no_ablk)
 				found = crypto_has_ablkcipher(algo, 0, 0);
 			break;
 		}
 		if (found) {
-					REGISTER(i);
+			REGISTER(i);
 		} else {
 			dprintk("%s:Algorithm Type %d not supported (algorithm %d:'%s')\n",
 					__FUNCTION__, sw_type, i, algo);
diff --git a/crypto/ocf/ep80579/Makefile b/crypto/ocf/ep80579/Makefile
index 9aab295..e488374 100644
--- a/crypto/ocf/ep80579/Makefile
+++ b/crypto/ocf/ep80579/Makefile
@@ -6,65 +6,65 @@
 #  depend  - build dependencies
 #  clean   - clears derived objects except the .depend files
 #  distclean- clears all derived objects and the .depend file
-#  
+#
 # @par
-# This file is provided under a dual BSD/GPLv2 license.  When using or 
+# This file is provided under a dual BSD/GPLv2 license.  When using or
 #   redistributing this file, you may do so under either license.
-# 
+#
 #   GPL LICENSE SUMMARY
-# 
+#
 #   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
-# 
-#   This program is free software; you can redistribute it and/or modify 
+#
+#   This program is free software; you can redistribute it and/or modify
 #   it under the terms of version 2 of the GNU General Public License as
 #   published by the Free Software Foundation.
-# 
-#   This program is distributed in the hope that it will be useful, but 
-#   WITHOUT ANY WARRANTY; without even the implied warranty of 
-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #   General Public License for more details.
-# 
-#   You should have received a copy of the GNU General Public License 
-#   along with this program; if not, write to the Free Software 
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
 #   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-#   The full GNU General Public License is included in this distribution 
+#   The full GNU General Public License is included in this distribution
 #   in the file called LICENSE.GPL.
-# 
+#
 #   Contact Information:
 #   Intel Corporation
-# 
-#   BSD LICENSE 
-# 
+#
+#   BSD LICENSE
+#
 #   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
 #   All rights reserved.
-# 
-#   Redistribution and use in source and binary forms, with or without 
-#   modification, are permitted provided that the following conditions 
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
 #   are met:
-# 
-#     * Redistributions of source code must retain the above copyright 
+#
+#     * Redistributions of source code must retain the above copyright
 #       notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above copyright 
-#       notice, this list of conditions and the following disclaimer in 
-#       the documentation and/or other materials provided with the 
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
 #       distribution.
-#     * Neither the name of Intel Corporation nor the names of its 
-#       contributors may be used to endorse or promote products derived 
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
 #       from this software without specific prior written permission.
-# 
-#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
-#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
-#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
-#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
-#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-# 
-# 
+#
+#
 #  version: Security.L.1.0.2-229
 ############################################################################
 
@@ -98,7 +98,7 @@ include ${ICP_BUILDSYSTEM_PATH}/build_files/common.mk
 #Add the name for the executable, Library or Module output definitions
 OUTPUT_NAME= icp_ocf
 
-# List of Source Files to be compiled 
+# List of Source Files to be compiled
 SOURCES= icp_common.c icp_sym.c icp_asym.c icp_ocf_linux.c
 
 #common includes between all supported OSes
diff --git a/crypto/ocf/ep80579/environment.mk b/crypto/ocf/ep80579/environment.mk
index 1a663e5..e04147e 100644
--- a/crypto/ocf/ep80579/environment.mk
+++ b/crypto/ocf/ep80579/environment.mk
@@ -1,62 +1,62 @@
  ###########################################################################
  #
-# This file is provided under a dual BSD/GPLv2 license.  When using or 
+# This file is provided under a dual BSD/GPLv2 license.  When using or
 #   redistributing this file, you may do so under either license.
-# 
+#
 #   GPL LICENSE SUMMARY
-# 
+#
 #   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
-# 
-#   This program is free software; you can redistribute it and/or modify 
+#
+#   This program is free software; you can redistribute it and/or modify
 #   it under the terms of version 2 of the GNU General Public License as
 #   published by the Free Software Foundation.
-# 
-#   This program is distributed in the hope that it will be useful, but 
-#   WITHOUT ANY WARRANTY; without even the implied warranty of 
-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #   General Public License for more details.
-# 
-#   You should have received a copy of the GNU General Public License 
-#   along with this program; if not, write to the Free Software 
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
 #   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-#   The full GNU General Public License is included in this distribution 
+#   The full GNU General Public License is included in this distribution
 #   in the file called LICENSE.GPL.
-# 
+#
 #   Contact Information:
 #   Intel Corporation
-# 
-#   BSD LICENSE 
-# 
+#
+#   BSD LICENSE
+#
 #   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
 #   All rights reserved.
-# 
-#   Redistribution and use in source and binary forms, with or without 
-#   modification, are permitted provided that the following conditions 
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
 #   are met:
-# 
-#     * Redistributions of source code must retain the above copyright 
+#
+#     * Redistributions of source code must retain the above copyright
 #       notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above copyright 
-#       notice, this list of conditions and the following disclaimer in 
-#       the documentation and/or other materials provided with the 
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
 #       distribution.
-#     * Neither the name of Intel Corporation nor the names of its 
-#       contributors may be used to endorse or promote products derived 
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
 #       from this software without specific prior written permission.
-# 
-#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
-#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
-#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
-#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
-#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-# 
-# 
+#
+#
 #  version: Security.L.1.0.130
  #
  ###########################################################################
diff --git a/crypto/ocf/ep80579/icp_asym.c b/crypto/ocf/ep80579/icp_asym.c
index 7093dd8..ebdddc1 100644
--- a/crypto/ocf/ep80579/icp_asym.c
+++ b/crypto/ocf/ep80579/icp_asym.c
@@ -1,62 +1,62 @@
 /***************************************************************************
  *
- * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
  *   redistributing this file, you may do so under either license.
- * 
+ *
  *   GPL LICENSE SUMMARY
- * 
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
- * 
- *   This program is free software; you can redistribute it and/or modify 
+ *
+ *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of version 2 of the GNU General Public License as
  *   published by the Free Software Foundation.
- * 
- *   This program is distributed in the hope that it will be useful, but 
- *   WITHOUT ANY WARRANTY; without even the implied warranty of 
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *   General Public License for more details.
- * 
- *   You should have received a copy of the GNU General Public License 
- *   along with this program; if not, write to the Free Software 
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *   The full GNU General Public License is included in this distribution 
+ *   The full GNU General Public License is included in this distribution
  *   in the file called LICENSE.GPL.
- * 
+ *
  *   Contact Information:
  *   Intel Corporation
- * 
- *   BSD LICENSE 
- * 
+ *
+ *   BSD LICENSE
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
- * 
- *   Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions 
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
  *   are met:
- * 
- *     * Redistributions of source code must retain the above copyright 
+ *
+ *     * Redistributions of source code must retain the above copyright
  *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright 
- *       notice, this list of conditions and the following disclaimer in 
- *       the documentation and/or other materials provided with the 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
  *       distribution.
- *     * Neither the name of Intel Corporation nor the names of its 
- *       contributors may be used to endorse or promote products derived 
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
  *       from this software without specific prior written permission.
- * 
- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
- *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * 
+ *
+ *
  *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
@@ -70,54 +70,54 @@ calling program uses different input buffer positions, these defines will have
 to be changed.*/
 
 /*DIFFIE HELLMAN buffer index values*/
-#define ICP_DH_KRP_PARAM_PRIME_INDEX				(0)
-#define ICP_DH_KRP_PARAM_BASE_INDEX				(1)
-#define ICP_DH_KRP_PARAM_PRIVATE_VALUE_INDEX			(2)
-#define ICP_DH_KRP_PARAM_RESULT_INDEX				(3)
+#define ICP_DH_KRP_PARAM_PRIME_INDEX                            (0)
+#define ICP_DH_KRP_PARAM_BASE_INDEX                             (1)
+#define ICP_DH_KRP_PARAM_PRIVATE_VALUE_INDEX                    (2)
+#define ICP_DH_KRP_PARAM_RESULT_INDEX                           (3)
 
 /*MOD EXP buffer index values*/
-#define ICP_MOD_EXP_KRP_PARAM_BASE_INDEX			(0)
-#define ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX			(1)
-#define ICP_MOD_EXP_KRP_PARAM_MODULUS_INDEX			(2)
-#define ICP_MOD_EXP_KRP_PARAM_RESULT_INDEX			(3)
+#define ICP_MOD_EXP_KRP_PARAM_BASE_INDEX                        (0)
+#define ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX                    (1)
+#define ICP_MOD_EXP_KRP_PARAM_MODULUS_INDEX                     (2)
+#define ICP_MOD_EXP_KRP_PARAM_RESULT_INDEX                      (3)
 
 /*MOD EXP CRT buffer index values*/
-#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_P_INDEX			(0)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_Q_INDEX			(1)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_I_INDEX			(2)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DP_INDEX		(3)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DQ_INDEX		(4)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_COEFF_QINV_INDEX		(5)
-#define ICP_MOD_EXP_CRT_KRP_PARAM_RESULT_INDEX			(6)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_P_INDEX                 (0)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_PRIME_Q_INDEX                 (1)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_I_INDEX                       (2)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DP_INDEX             (3)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_EXPONENT_DQ_INDEX             (4)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_COEFF_QINV_INDEX              (5)
+#define ICP_MOD_EXP_CRT_KRP_PARAM_RESULT_INDEX                  (6)
 
 /*DSA sign buffer index values*/
-#define ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX			(0)
-#define ICP_DSA_SIGN_KRP_PARAM_PRIME_P_INDEX			(1)
-#define ICP_DSA_SIGN_KRP_PARAM_PRIME_Q_INDEX			(2)
-#define ICP_DSA_SIGN_KRP_PARAM_G_INDEX				(3)
-#define ICP_DSA_SIGN_KRP_PARAM_X_INDEX				(4)
-#define ICP_DSA_SIGN_KRP_PARAM_R_RESULT_INDEX			(5)
-#define ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX			(6)
+#define ICP_DSA_SIGN_KRP_PARAM_DGST_INDEX                       (0)
+#define ICP_DSA_SIGN_KRP_PARAM_PRIME_P_INDEX                    (1)
+#define ICP_DSA_SIGN_KRP_PARAM_PRIME_Q_INDEX                    (2)
+#define ICP_DSA_SIGN_KRP_PARAM_G_INDEX                          (3)
+#define ICP_DSA_SIGN_KRP_PARAM_X_INDEX                          (4)
+#define ICP_DSA_SIGN_KRP_PARAM_R_RESULT_INDEX                   (5)
+#define ICP_DSA_SIGN_KRP_PARAM_S_RESULT_INDEX                   (6)
 
 /*DSA verify buffer index values*/
-#define ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX			(0)
-#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_P_INDEX			(1)
-#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_Q_INDEX			(2)
-#define ICP_DSA_VERIFY_KRP_PARAM_G_INDEX			(3)
-#define ICP_DSA_VERIFY_KRP_PARAM_PUBKEY_INDEX			(4)
-#define ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX			(5)
-#define ICP_DSA_VERIFY_KRP_PARAM_SIG_S_INDEX			(6)
+#define ICP_DSA_VERIFY_KRP_PARAM_DGST_INDEX                     (0)
+#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_P_INDEX                  (1)
+#define ICP_DSA_VERIFY_KRP_PARAM_PRIME_Q_INDEX                  (2)
+#define ICP_DSA_VERIFY_KRP_PARAM_G_INDEX                        (3)
+#define ICP_DSA_VERIFY_KRP_PARAM_PUBKEY_INDEX                   (4)
+#define ICP_DSA_VERIFY_KRP_PARAM_SIG_R_INDEX                    (5)
+#define ICP_DSA_VERIFY_KRP_PARAM_SIG_S_INDEX                    (6)
 
 /*DSA sign prime Q vs random number K size check values*/
-#define DONT_RUN_LESS_THAN_CHECK				(0)
-#define FAIL_A_IS_GREATER_THAN_B				(1)
-#define FAIL_A_IS_EQUAL_TO_B					(1)
-#define SUCCESS_A_IS_LESS_THAN_B				(0)
-#define DSA_SIGN_RAND_GEN_VAL_CHECK_MAX_ITERATIONS		(500)
+#define DONT_RUN_LESS_THAN_CHECK                                (0)
+#define FAIL_A_IS_GREATER_THAN_B                                (1)
+#define FAIL_A_IS_EQUAL_TO_B                                    (1)
+#define SUCCESS_A_IS_LESS_THAN_B                                (0)
+#define DSA_SIGN_RAND_GEN_VAL_CHECK_MAX_ITERATIONS              (500)
 
 /* We need to set a cryptokp success value just in case it is set or allocated
    and not set to zero outside of this module */
-#define CRYPTO_OP_SUCCESS					(0)
+#define CRYPTO_OP_SUCCESS                                       (0)
 
 /*Function to compute Diffie Hellman (DH) phase 1 or phase 2 key values*/
 static int icp_ocfDrvDHComputeKey(struct cryptkop *krp);
@@ -458,14 +458,14 @@ static int icp_ocfDrvModExp(struct cryptkop *krp)
 			    pModExpOpData->modulus.dataLenInBytes);
 
 	DPRINTK("%s : base (%d)\n", __FUNCTION__, krp->
-			krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
-		pModExpOpData->base.pData =
-		    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_p;
-		BITS_TO_BYTES(pModExpOpData->base.dataLenInBytes,
-			      krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
-			      crp_nbits);
-		icp_ocfDrvSwapBytes(pModExpOpData->base.pData,
-				    pModExpOpData->base.dataLenInBytes);
+		krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_nbits);
+	pModExpOpData->base.pData =
+	    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].crp_p;
+	BITS_TO_BYTES(pModExpOpData->base.dataLenInBytes,
+		      krp->krp_param[ICP_MOD_EXP_KRP_PARAM_BASE_INDEX].
+		      crp_nbits);
+	icp_ocfDrvSwapBytes(pModExpOpData->base.pData,
+			    pModExpOpData->base.dataLenInBytes);
 
 	pModExpOpData->exponent.pData =
 	    krp->krp_param[ICP_MOD_EXP_KRP_PARAM_EXPONENT_INDEX].crp_p;
@@ -547,7 +547,7 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 		APRINTK("%s():Failed to get memory"
 			" for MOD EXP CRT output data\n", __FUNCTION__);
 		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-				rsaDecryptOpData->pRecipientPrivateKey);
+			       rsaDecryptOpData->pRecipientPrivateKey);
 		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
@@ -651,7 +651,7 @@ static int icp_ocfDrvModExpCRT(struct cryptkop *krp)
 		krp->krp_status = ECANCELED;
 		icp_ocfDrvFreeFlatBuffer(pOutputData);
 		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-				rsaDecryptOpData->pRecipientPrivateKey);
+			       rsaDecryptOpData->pRecipientPrivateKey);
 		ICP_CACHE_FREE(drvRSADecrypt_zone, rsaDecryptOpData);
 	}
 
@@ -764,7 +764,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		APRINTK("%s():Failed to get memory"
 			" for DSA signature R\n", __FUNCTION__);
 		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-				dsaRsSignOpData->K.pData);
+			       dsaRsSignOpData->K.pData);
 		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
@@ -776,7 +776,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 			" for DSA signature S\n", __FUNCTION__);
 		icp_ocfDrvFreeFlatBuffer(pR);
 		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-				dsaRsSignOpData->K.pData);
+			       dsaRsSignOpData->K.pData);
 		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 		krp->krp_status = ENOMEM;
 		return ENOMEM;
@@ -824,7 +824,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
 			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-					dsaRsSignOpData->K.pData);
+				       dsaRsSignOpData->K.pData);
 			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
@@ -837,7 +837,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 			icp_ocfDrvFreeFlatBuffer(pS);
 			icp_ocfDrvFreeFlatBuffer(pR);
 			ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-					dsaRsSignOpData->K.pData);
+				       dsaRsSignOpData->K.pData);
 			ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 			krp->krp_status = EAGAIN;
 			return EAGAIN;
@@ -893,7 +893,7 @@ static int icp_ocfDrvDsaSign(struct cryptkop *krp)
 		icp_ocfDrvFreeFlatBuffer(pS);
 		icp_ocfDrvFreeFlatBuffer(pR);
 		ICP_CACHE_FREE(drvDSARSSignKValue_zone,
-				dsaRsSignOpData->K.pData);
+			       dsaRsSignOpData->K.pData);
 		ICP_CACHE_FREE(drvDSARSSign_zone, dsaRsSignOpData);
 	}
 
@@ -1156,7 +1156,7 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 		memset(pDecryptData->pRecipientPrivateKey, 0,
 		       sizeof(CpaCyRsaPrivateKey));
 		ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-				pDecryptData->pRecipientPrivateKey);
+			       pDecryptData->pRecipientPrivateKey);
 		memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
 		ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
 		krp->krp_status = ECANCELED;
@@ -1178,7 +1178,7 @@ icp_ocfDrvModExpCRTCallBack(void *callbackTag,
 	memset(pDecryptData->pRecipientPrivateKey, 0,
 	       sizeof(CpaCyRsaPrivateKey));
 	ICP_CACHE_FREE(drvRSAPrivateKey_zone,
-			pDecryptData->pRecipientPrivateKey);
+		       pDecryptData->pRecipientPrivateKey);
 	memset(pDecryptData, 0, sizeof(CpaCyRsaDecryptOpData));
 	ICP_CACHE_FREE(drvRSADecrypt_zone, pDecryptData);
 
diff --git a/crypto/ocf/ep80579/icp_common.c b/crypto/ocf/ep80579/icp_common.c
index 9431a72d..50a402b 100644
--- a/crypto/ocf/ep80579/icp_common.c
+++ b/crypto/ocf/ep80579/icp_common.c
@@ -1,68 +1,68 @@
 /*************************************************************************
  *
- * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
  *   redistributing this file, you may do so under either license.
- * 
+ *
  *   GPL LICENSE SUMMARY
- * 
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
- * 
- *   This program is free software; you can redistribute it and/or modify 
+ *
+ *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of version 2 of the GNU General Public License as
  *   published by the Free Software Foundation.
- * 
- *   This program is distributed in the hope that it will be useful, but 
- *   WITHOUT ANY WARRANTY; without even the implied warranty of 
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *   General Public License for more details.
- * 
- *   You should have received a copy of the GNU General Public License 
- *   along with this program; if not, write to the Free Software 
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *   The full GNU General Public License is included in this distribution 
+ *   The full GNU General Public License is included in this distribution
  *   in the file called LICENSE.GPL.
- * 
+ *
  *   Contact Information:
  *   Intel Corporation
- * 
- *   BSD LICENSE 
- * 
+ *
+ *   BSD LICENSE
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
- * 
- *   Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions 
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
  *   are met:
- * 
- *     * Redistributions of source code must retain the above copyright 
+ *
+ *     * Redistributions of source code must retain the above copyright
  *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright 
- *       notice, this list of conditions and the following disclaimer in 
- *       the documentation and/or other materials provided with the 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
  *       distribution.
- *     * Neither the name of Intel Corporation nor the names of its 
- *       contributors may be used to endorse or promote products derived 
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
  *       from this software without specific prior written permission.
- * 
- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
- *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * 
+ *
+ *
  *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
 
 /*
- * An OCF module that uses Intel QuickAssist Integrated Accelerator to do the 
+ * An OCF module that uses Intel QuickAssist Integrated Accelerator to do the
  * crypto.
  *
  * This driver requires the ICP Access Library that is available from Intel in
@@ -71,19 +71,19 @@
 
 #include "icp_ocf.h"
 
-#define ICP_OCF_COMP_NAME 			"ICP_OCF"
-#define ICP_OCF_VER_MAIN			(2)
+#define ICP_OCF_COMP_NAME                       "ICP_OCF"
+#define ICP_OCF_VER_MAIN                        (2)
 #define ICP_OCF_VER_MJR                         (1)
-#define ICP_OCF_VER_MNR 			(0)
+#define ICP_OCF_VER_MNR                         (0)
 
-#define MAX_DEREG_RETRIES 			(100)
+#define MAX_DEREG_RETRIES                       (100)
 #define DEFAULT_DEREG_RETRIES 			(10)
 #define DEFAULT_DEREG_DELAY_IN_JIFFIES		(10)
 
 /* This defines the maximum number of sessions possible between OCF
    and the OCF EP80579 Driver. If set to zero, there is no limit. */
-#define DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT	(0)
-#define NUM_SUPPORTED_CAPABILITIES		(21)
+#define DEFAULT_OCF_TO_DRV_MAX_SESSION_COUNT    (0)
+#define NUM_SUPPORTED_CAPABILITIES              (21)
 
 /*Slab zone names*/
 #define ICP_SESSION_DATA_NAME   "icp_ocf.SesDat"
@@ -129,7 +129,7 @@ int32_t icp_ocfDrvDriverId = INVALID_DRIVER_ID;
    re-tried */
 int num_dereg_retries = DEFAULT_DEREG_RETRIES;
 
-/* Module parameter - gives the delay time in jiffies before a LAC session 
+/* Module parameter - gives the delay time in jiffies before a LAC session
    shall be attempted to be deregistered again */
 int dereg_retry_delay_in_jiffies = DEFAULT_DEREG_DELAY_IN_JIFFIES;
 
@@ -214,7 +214,7 @@ ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
 	drvSessionData_zone =
 	    ICP_CACHE_CREATE(ICP_SESSION_DATA_NAME, struct icp_drvSessionData);
 
-	/* 
+	/*
 	 * Allocation of the OpData includes the allocation space for meta data.
 	 * The memory after the opData structure is reserved for this meta data.
 	 */
@@ -300,7 +300,7 @@ ICP_MODULE_INIT_FUNC(icp_ocfDrvInit)
 	DPRINTK("%s: Registered %d of %d device capabilities\n",
 		__FUNCTION__, ocfStatus, NUM_SUPPORTED_CAPABILITIES);
 
-/*Session data linked list used during module exit*/
+	/*Session data linked list used during module exit */
 	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead);
 	ICP_INIT_LIST_HEAD(&icp_ocfDrvGlobalSymListHead_FreeMemList);
 
@@ -354,7 +354,7 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 			" function already called. Exiting.\n", __FUNCTION__);
 		return ICP_MODULE_EXIT_FUNC_RETURN_VAL;
 	}
-	/*If any sessions are waiting to be deregistered, do that. This also 
+	/*If any sessions are waiting to be deregistered, do that. This also
 	   flushes the work queue */
 	ICP_WORKQUEUE_DESTROY(icp_ocfDrvFreeLacSessionWorkQ);
 
@@ -362,7 +362,7 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 	icp_spin_lockbh_lock(&icp_ocfDrvSymSessInfoListSpinlock);
 
 	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
-				 &icp_ocfDrvGlobalSymListHead, listNode) {
+				     &icp_ocfDrvGlobalSymListHead, listNode) {
 		for (i = 0; i < num_dereg_retries; i++) {
 			/*No harm if bad input - LAC will handle error cases */
 			if (ICP_SESSION_RUNNING == tempSessionData->inUse) {
@@ -379,7 +379,7 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 					break;
 				}
 
-				/*schedule_timout returns the time left for completion if 
+				/*schedule_timout returns the time left for completion if
 				 * this task is set to TASK_INTERRUPTIBLE */
 				remaining_delay_time_in_jiffies =
 				    dereg_retry_delay_in_jiffies;
@@ -415,8 +415,8 @@ ICP_MODULE_EXIT_FUNC(icp_ocfDrvExit)
 	/*free memory */
 
 	ICP_LIST_FOR_EACH_ENTRY_SAFE(tempSessionData, sessionData,
-				 &icp_ocfDrvGlobalSymListHead_FreeMemList,
-				 listNode) {
+				     &icp_ocfDrvGlobalSymListHead_FreeMemList,
+				     listNode) {
 
 		ICP_LIST_DEL(tempSessionData, listNode);
 		/* Free allocated CpaCySymSessionCtx */
@@ -585,9 +585,9 @@ void icp_ocfDrvDeferedFreeLacSessionProcess(void *arg)
 		icp_atomic_read(&lac_session_failed_dereg_count));
 }
 
-/* Name        : icp_ocfDrvPtrAndLenToFlatBuffer 
+/* Name        : icp_ocfDrvPtrAndLenToFlatBuffer
  *
- * Description : This function converts a "pointer and length" buffer 
+ * Description : This function converts a "pointer and length" buffer
  * structure to Fredericksburg Flat Buffer (CpaFlatBuffer) format.
  *
  * This function assumes that the data passed in are valid.
@@ -633,8 +633,8 @@ icp_ocfDrvBufferListToPtrAndLen(CpaBufferList * pBufferList,
 
 /* Name        : icp_ocfDrvBufferListMemInfo
  *
- * Description : This function will set the number of flat buffers in 
- * bufferlist, the size of memory to allocate for the pPrivateMetaData 
+ * Description : This function will set the number of flat buffers in
+ * bufferlist, the size of memory to allocate for the pPrivateMetaData
  * member of the CpaBufferList.
  */
 int
@@ -678,15 +678,15 @@ icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 {
 	Cpa32U metaSize = 0;
 
-	if (pBufferList->numBuffers <= ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS){
+	if (pBufferList->numBuffers <= ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) {
 		uint8_t *pOpDataStartAddr = (uint8_t *) pOpData;
 
-	    if (0 == defBuffListInfo.metaSize) {
+		if (0 == defBuffListInfo.metaSize) {
 			pBufferList->pPrivateMetaData = NULL;
 			return ICP_OCF_DRV_STATUS_SUCCESS;
 		}
 		/*
-		 * The meta data allocation has been included as part of the 
+		 * The meta data allocation has been included as part of the
 		 * op data.  It has been pre-allocated in memory just after the
 		 * icp_drvOpData structure.
 		 */
@@ -731,12 +731,12 @@ inline void icp_ocfDrvFreeMetaData(CpaBufferList * pBufferList)
 	}
 
 	/*
-	 * Only free the meta data if the BufferList has more than 
+	 * Only free the meta data if the BufferList has more than
 	 * ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS number of buffers.
 	 * Otherwise, the meta data shall be freed when the icp_drvOpData is
 	 * freed.
 	 */
-	if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < pBufferList->numBuffers){
+	if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS < pBufferList->numBuffers) {
 		icp_kfree(pBufferList->pPrivateMetaData);
 	}
 }
diff --git a/crypto/ocf/ep80579/icp_ocf.h b/crypto/ocf/ep80579/icp_ocf.h
index c62b3ca..68b479c 100644
--- a/crypto/ocf/ep80579/icp_ocf.h
+++ b/crypto/ocf/ep80579/icp_ocf.h
@@ -1,62 +1,62 @@
 /***************************************************************************
  *
- * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
  *   redistributing this file, you may do so under either license.
- * 
+ *
  *   GPL LICENSE SUMMARY
- * 
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
- * 
- *   This program is free software; you can redistribute it and/or modify 
+ *
+ *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of version 2 of the GNU General Public License as
  *   published by the Free Software Foundation.
- * 
- *   This program is distributed in the hope that it will be useful, but 
- *   WITHOUT ANY WARRANTY; without even the implied warranty of 
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *   General Public License for more details.
- * 
- *   You should have received a copy of the GNU General Public License 
- *   along with this program; if not, write to the Free Software 
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *   The full GNU General Public License is included in this distribution 
+ *   The full GNU General Public License is included in this distribution
  *   in the file called LICENSE.GPL.
- * 
+ *
  *   Contact Information:
  *   Intel Corporation
- * 
- *   BSD LICENSE 
- * 
+ *
+ *   BSD LICENSE
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
- * 
- *   Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions 
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
  *   are met:
- * 
- *     * Redistributions of source code must retain the above copyright 
+ *
+ *     * Redistributions of source code must retain the above copyright
  *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright 
- *       notice, this list of conditions and the following disclaimer in 
- *       the documentation and/or other materials provided with the 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
  *       distribution.
- *     * Neither the name of Intel Corporation nor the names of its 
- *       contributors may be used to endorse or promote products derived 
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
  *       from this software without specific prior written permission.
- * 
- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
- *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * 
+ *
+ *
  *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
@@ -304,7 +304,7 @@ int icp_ocfDrvDeregRetry(CpaCySymSessionCtx sessionToDeregister);
 
 /* Convert an OS scatter gather list to a CPA buffer list*/
 int icp_ocfDrvPacketBuffToBufferList(icp_packet_buffer_t * pPacketBuffer,
-				 CpaBufferList * bufferList);
+				     CpaBufferList * bufferList);
 
 /* Convert a CPA buffer list to an OS scatter gather list*/
 int icp_ocfDrvBufferListToPacketBuff(CpaBufferList * bufferList,
@@ -350,7 +350,7 @@ void icp_ocfDrvFreeFlatBuffer(CpaFlatBuffer * pFlatBuffer);
 
 /* This function will allocate memory for the pPrivateMetaData
    member of CpaBufferList. */
-int icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList, 
+int icp_ocfDrvAllocMetaData(CpaBufferList * pBufferList,
 			    struct icp_drvOpData *pOpData);
 
 /* Free data allocated for the pPrivateMetaData
diff --git a/crypto/ocf/ep80579/icp_sym.c b/crypto/ocf/ep80579/icp_sym.c
index b5d2c73..a3edc43 100644
--- a/crypto/ocf/ep80579/icp_sym.c
+++ b/crypto/ocf/ep80579/icp_sym.c
@@ -1,62 +1,62 @@
 /***************************************************************************
  *
- * This file is provided under a dual BSD/GPLv2 license.  When using or 
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
  *   redistributing this file, you may do so under either license.
- * 
+ *
  *   GPL LICENSE SUMMARY
- * 
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
- * 
- *   This program is free software; you can redistribute it and/or modify 
+ *
+ *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of version 2 of the GNU General Public License as
  *   published by the Free Software Foundation.
- * 
- *   This program is distributed in the hope that it will be useful, but 
- *   WITHOUT ANY WARRANTY; without even the implied warranty of 
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+ *
+ *   This program is distributed in the hope that it will be useful, but
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  *   General Public License for more details.
- * 
- *   You should have received a copy of the GNU General Public License 
- *   along with this program; if not, write to the Free Software 
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
  *   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *   The full GNU General Public License is included in this distribution 
+ *   The full GNU General Public License is included in this distribution
  *   in the file called LICENSE.GPL.
- * 
+ *
  *   Contact Information:
  *   Intel Corporation
- * 
- *   BSD LICENSE 
- * 
+ *
+ *   BSD LICENSE
+ *
  *   Copyright(c) 2007,2008,2009 Intel Corporation. All rights reserved.
  *   All rights reserved.
- * 
- *   Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions 
+ *
+ *   Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions
  *   are met:
- * 
- *     * Redistributions of source code must retain the above copyright 
+ *
+ *     * Redistributions of source code must retain the above copyright
  *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright 
- *       notice, this list of conditions and the following disclaimer in 
- *       the documentation and/or other materials provided with the 
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in
+ *       the documentation and/or other materials provided with the
  *       distribution.
- *     * Neither the name of Intel Corporation nor the names of its 
- *       contributors may be used to endorse or promote products derived 
+ *     * Neither the name of Intel Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
  *       from this software without specific prior written permission.
- * 
- *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
- *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
- *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+ *
+ *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * 
- * 
+ *
+ *
  *  version: Security.L.1.0.2-229
  *
  ***************************************************************************/
@@ -71,7 +71,7 @@
 #include "icp_ocf.h"
 
 /*This is the call back function for all symmetric cryptographic processes.
-  Its main functionality is to free driver crypto operation structure and to 
+  Its main functionality is to free driver crypto operation structure and to
   call back to OCF*/
 static void
 icp_ocfDrvSymCallBack(void *callbackTag,
@@ -105,7 +105,7 @@ static void icp_ocfDrvFreeOCFSession(struct icp_drvSessionData *sessionData);
 /* Name        : icp_ocfDrvSymCallBack
  *
  * Description : When this function returns it signifies that the LAC
- * component has completed the relevant symmetric operation. 
+ * component has completed the relevant symmetric operation.
  *
  * Notes : The callbackTag is a pointer to an icp_drvOpData. This memory
  * object was passed to LAC for the cryptographic processing and contains all
@@ -161,7 +161,7 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 			    icp_ocfDrvBufferListToPacketBuff(pDstBuffer,
 							     (icp_packet_buffer_t
 							      **)
-							 &(crp->crp_buf))) {
+							     & (crp->crp_buf))) {
 				EPRINTK("%s(): BufferList to SkBuff "
 					"conversion error.\n", __FUNCTION__);
 				crp->crp_etype = EPERM;
@@ -193,7 +193,7 @@ icp_ocfDrvSymCallBack(void *callbackTag,
 	return;
 }
 
-/* Name        : icp_ocfDrvNewSession 
+/* Name        : icp_ocfDrvNewSession
  *
  * Description : This function will create a new Driver<->OCF session
  *
@@ -587,7 +587,7 @@ int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
 		if (CPA_STATUS_RETRY == lacStatus) {
 			if (ICP_OCF_DRV_STATUS_SUCCESS !=
 			    icp_ocfDrvDeregRetry(&sessionToDeregister)) {
-				/* the retry function increments the 
+				/* the retry function increments the
 				   dereg failed count */
 				DPRINTK("%s(): LAC failed to deregister the "
 					"session. (localSessionId= %p)\n",
@@ -612,7 +612,7 @@ int icp_ocfDrvFreeLACSession(icp_device_t dev, uint64_t sid)
 
 }
 
-/* Name        : icp_ocfDrvAlgCheck 
+/* Name        : icp_ocfDrvAlgCheck
  *
  * Description : This function checks whether the cryptodesc argument pertains
  * to a sym or hash function
@@ -631,11 +631,11 @@ static int icp_ocfDrvAlgCheck(struct cryptodesc *crp_desc)
 	return ICP_OCF_DRV_ALG_HASH;
 }
 
-/* Name        : icp_ocfDrvSymProcess 
+/* Name        : icp_ocfDrvSymProcess
  *
  * Description : This function will map symmetric functionality calls from OCF
  * to the LAC API. It will also allocate memory to store the session context.
- * 
+ *
  * Notes: If it is the first perform call for a given session, then a LAC
  * session is registered. After the session is registered, no checks as
  * to whether session paramaters have changed (e.g. alg chain order) are
@@ -692,7 +692,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 
 /*If none of the session states are set, then the session structure was either
   not initialised properly or we are reading from a freed memory area (possible
-  due to OCF batch mode not removing queued requests against deregistered 
+  due to OCF batch mode not removing queued requests against deregistered
   sessions*/
 	if (ICP_SESSION_INITIALISED != sessionData->inUse &&
 	    ICP_SESSION_RUNNING != sessionData->inUse) {
@@ -825,7 +825,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 
 	}
 
-	/* 
+	/*
 	 * Allocate buffer list array memory if the data fragment is more than
 	 * the default number (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS) and not
 	 * calculated already
@@ -834,7 +834,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		if (NULL == drvOpData->lacOpData.pDigestResult) {
 			drvOpData->numBufferListArray =
 			    icp_ocfDrvGetPacketBuffFrags((icp_packet_buffer_t *)
-							      crp->crp_buf);
+							 crp->crp_buf);
 		}
 
 		if (ICP_OCF_DRV_DEFAULT_BUFFLIST_ARRAYS <
@@ -863,7 +863,7 @@ int icp_ocfDrvSymProcess(icp_device_t dev, struct cryptop *crp, int hint)
 		if (ICP_OCF_DRV_STATUS_SUCCESS !=
 		    icp_ocfDrvPacketBuffToBufferList((icp_packet_buffer_t *)
 						     crp->crp_buf,
-						 &(drvOpData->srcBuffer))) {
+						     &(drvOpData->srcBuffer))) {
 			EPRINTK("%s():Failed to translate from packet buffer "
 				"to bufferlist\n", __FUNCTION__);
 			crp->crp_etype = EINVAL;
@@ -1111,7 +1111,7 @@ static int icp_ocfDrvProcessDataSetup(struct icp_drvOpData *drvOpData,
  * address. Whether there is enough space for the digest must also be checked.
  */
 uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData * drvOpData,
-					    struct cryptodesc *crp_desc)
+				     struct cryptodesc * crp_desc)
 {
 
 	int offsetInBytes = crp_desc->crd_inject;
@@ -1122,8 +1122,8 @@ uint8_t *icp_ocfDrvDigestPointerFind(struct icp_drvOpData * drvOpData,
 	if (drvOpData->crp->crp_flags & ICP_CRYPTO_F_PACKET_BUF) {
 
 		return icp_ocfDrvPacketBufferDigestPointerFind(drvOpData,
-							 offsetInBytes,
-							 digestSizeInBytes);
+							       offsetInBytes,
+							       digestSizeInBytes);
 
 	} else {
 		/* IOV or flat buffer */
diff --git a/crypto/ocf/ep80579/linux_2.6_kernel_space.mk b/crypto/ocf/ep80579/linux_2.6_kernel_space.mk
index 96afa9a..4c92922 100644
--- a/crypto/ocf/ep80579/linux_2.6_kernel_space.mk
+++ b/crypto/ocf/ep80579/linux_2.6_kernel_space.mk
@@ -1,62 +1,62 @@
 ###################
 # @par
-# This file is provided under a dual BSD/GPLv2 license.  When using or 
+# This file is provided under a dual BSD/GPLv2 license.  When using or
 #   redistributing this file, you may do so under either license.
-# 
+#
 #   GPL LICENSE SUMMARY
-# 
+#
 #   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
-# 
-#   This program is free software; you can redistribute it and/or modify 
+#
+#   This program is free software; you can redistribute it and/or modify
 #   it under the terms of version 2 of the GNU General Public License as
 #   published by the Free Software Foundation.
-# 
-#   This program is distributed in the hope that it will be useful, but 
-#   WITHOUT ANY WARRANTY; without even the implied warranty of 
-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 #   General Public License for more details.
-# 
-#   You should have received a copy of the GNU General Public License 
-#   along with this program; if not, write to the Free Software 
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
 #   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-#   The full GNU General Public License is included in this distribution 
+#   The full GNU General Public License is included in this distribution
 #   in the file called LICENSE.GPL.
-# 
+#
 #   Contact Information:
 #   Intel Corporation
-# 
-#   BSD LICENSE 
-# 
+#
+#   BSD LICENSE
+#
 #   Copyright(c) 2007,2008 Intel Corporation. All rights reserved.
 #   All rights reserved.
-# 
-#   Redistribution and use in source and binary forms, with or without 
-#   modification, are permitted provided that the following conditions 
+#
+#   Redistribution and use in source and binary forms, with or without
+#   modification, are permitted provided that the following conditions
 #   are met:
-# 
-#     * Redistributions of source code must retain the above copyright 
+#
+#     * Redistributions of source code must retain the above copyright
 #       notice, this list of conditions and the following disclaimer.
-#     * Redistributions in binary form must reproduce the above copyright 
-#       notice, this list of conditions and the following disclaimer in 
-#       the documentation and/or other materials provided with the 
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in
+#       the documentation and/or other materials provided with the
 #       distribution.
-#     * Neither the name of Intel Corporation nor the names of its 
-#       contributors may be used to endorse or promote products derived 
+#     * Neither the name of Intel Corporation nor the names of its
+#       contributors may be used to endorse or promote products derived
 #       from this software without specific prior written permission.
-# 
-#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
-#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
-#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
-#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
-#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+#
+#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 #   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-# 
-# 
+#
+#
 #  version: Security.L.1.0.130
 ###################
 
diff --git a/crypto/ocf/hifn/hifn7751.c b/crypto/ocf/hifn/hifn7751.c
index d554f16..9dac0db 100644
--- a/crypto/ocf/hifn/hifn7751.c
+++ b/crypto/ocf/hifn/hifn7751.c
@@ -763,7 +763,7 @@ hifn_init_pubrng(struct hifn_softc *sc)
 		sc->sc_dmaier |= HIFN_DMAIER_PUBDONE;
 		WRITE_REG_1(sc, HIFN_1_DMA_IER, sc->sc_dmaier);
 #ifdef HIFN_VULCANDEV
-		sc->sc_pkdev = make_dev(&vulcanpk_cdevsw, 0, 
+		sc->sc_pkdev = make_dev(&vulcanpk_cdevsw, 0,
 					UID_ROOT, GID_WHEEL, 0666,
 					"vulcanpk");
 		sc->sc_pkdev->si_drv1 = sc;
@@ -964,7 +964,7 @@ hifn_next_signature(u_int32_t a, u_int cnt)
  * "hifn_enable_crypto" is called to enable it.  The check is important,
  * as enabling crypto twice will lock the board.
  */
-static int 
+static int
 hifn_enable_crypto(struct hifn_softc *sc)
 {
 	u_int32_t dmacfg, ramcfg, encl, addr, i;
@@ -1056,7 +1056,7 @@ report:
  * Give initial values to the registers listed in the "Register Space"
  * section of the HIFN Software Development reference manual.
  */
-static void 
+static void
 hifn_init_pci_registers(struct hifn_softc *sc)
 {
 	DPRINTF("%s()\n", __FUNCTION__);
@@ -1441,7 +1441,7 @@ hifn_readramaddr(struct hifn_softc *sc, int addr, u_int8_t *data)
 /*
  * Initialize the descriptor rings.
  */
-static void 
+static void
 hifn_init_dma(struct hifn_softc *sc)
 {
 	struct hifn_dma *dma = sc->sc_dma;
@@ -1729,10 +1729,10 @@ hifn_dmamap_load_src(struct hifn_softc *sc, struct hifn_command *cmd)
 	dma->srci = idx;
 	dma->srcu += src->nsegs;
 	return (idx);
-} 
+}
 
 
-static int 
+static int
 hifn_crypto(
 	struct hifn_softc *sc,
 	struct hifn_command *cmd,
@@ -2595,7 +2595,7 @@ hifn_process(device_t dev, struct cryptop *crp, int hint)
 		cmd->cklen = enccrd->crd_klen >> 3;
 		cmd->cry_masks |= HIFN_CRYPT_CMD_NEW_KEY;
 
-		/* 
+		/*
 		 * Need to specify the size for the AES key in the masks.
 		 */
 		if ((cmd->cry_masks & HIFN_CRYPT_CMD_ALG_MASK) ==
diff --git a/crypto/ocf/hifn/hifn7751reg.h b/crypto/ocf/hifn/hifn7751reg.h
index ccf54f9..5a3d5aa 100644
--- a/crypto/ocf/hifn/hifn7751reg.h
+++ b/crypto/ocf/hifn/hifn7751reg.h
@@ -78,7 +78,7 @@
  * MAX_COMMAND = base command + mac command + encrypt command +
  *			mac-key + rc4-key
  * MAX_RESULT  = base result + mac result + mac + encrypt result
- *			
+ *
  *
  */
 #define	HIFN_MAX_COMMAND	(8 + 8 + 8 + 64 + 260)
@@ -436,7 +436,7 @@ typedef struct hifn_desc {
 
 
 /*********************************************************************
- * Structs for board commands 
+ * Structs for board commands
  *
  *********************************************************************/
 
diff --git a/crypto/ocf/hifn/hifn7751var.h b/crypto/ocf/hifn/hifn7751var.h
index c5d30f9..7b69078 100644
--- a/crypto/ocf/hifn/hifn7751var.h
+++ b/crypto/ocf/hifn/hifn7751var.h
@@ -103,7 +103,7 @@ struct hifn_dma {
 
 	/*
 	 *  Our current positions for insertion and removal from the desriptor
-	 *  rings. 
+	 *  rings.
 	 */
 	int			cmdi, srci, dsti, resi;
 	volatile int		cmdu, srcu, dstu, resu;
@@ -224,7 +224,7 @@ struct hifn_softc {
  *
  *  session_num
  *  -----------
- *  A number between 0 and 2048 (for DRAM models) or a number between 
+ *  A number between 0 and 2048 (for DRAM models) or a number between
  *  0 and 768 (for SRAM models).  Those who don't want to use session
  *  numbers should leave value at zero and send a new crypt key and/or
  *  new MAC key on every command.  If you use session numbers and
@@ -238,7 +238,7 @@ struct hifn_softc {
  *  ----
  *  Either fill in the mbuf pointer and npa=0 or
  *	 fill packp[] and packl[] and set npa to > 0
- * 
+ *
  *  mac_header_skip
  *  ---------------
  *  The number of bytes of the source_buf that are skipped over before
@@ -326,7 +326,7 @@ struct hifn_command {
  *  0 for success, negative values on error
  *
  *  Defines for negative error codes are:
- *  
+ *
  *    HIFN_CRYPTO_BAD_INPUT  :  The passed in command had invalid settings.
  *    HIFN_CRYPTO_RINGS_FULL :  All DMA rings were full and non-blocking
  *                              behaviour was requested.
diff --git a/crypto/ocf/hifn/hifnHIPP.c b/crypto/ocf/hifn/hifnHIPP.c
index 4d6950a..f066929 100644
--- a/crypto/ocf/hifn/hifnHIPP.c
+++ b/crypto/ocf/hifn/hifnHIPP.c
@@ -179,9 +179,9 @@ struct hipp_fs_entry {
 static ssize_t
 cryptoid_show(struct device *dev,
 	      struct device_attribute *attr,
-	      char *buf)						
-{								
-	struct hipp_softc *sc;					
+	      char *buf)
+{
+	struct hipp_softc *sc;
 
 	sc = pci_get_drvdata(to_pci_dev (dev));
 	return sprintf (buf, "%d\n", sc->sc_cid);
@@ -313,13 +313,13 @@ fail:
 		crypto_unregister_all(sc->sc_cid);
 	if (sc->sc_irq != -1)
 		free_irq(sc->sc_irq, sc);
-	
+
 #if 0
 	if (sc->sc_dma) {
 		/* Turn off DMA polling */
 		WRITE_REG_1(sc, HIFN_1_DMA_CNFG, HIFN_DMACNFG_MSTRESET |
 			    HIFN_DMACNFG_DMARESET | HIFN_DMACNFG_MODE);
-		
+
 		pci_free_consistent(sc->sc_pcidev,
 				    sizeof(*sc->sc_dma),
 				    sc->sc_dma, sc->sc_dma_physaddr);
diff --git a/crypto/ocf/hifn/hifnHIPPvar.h b/crypto/ocf/hifn/hifnHIPPvar.h
index 61d292f..dde47f7 100644
--- a/crypto/ocf/hifn/hifnHIPPvar.h
+++ b/crypto/ocf/hifn/hifnHIPPvar.h
@@ -1,6 +1,6 @@
 /*
  * Hifn HIPP-I/HIPP-II (7855/8155) driver.
- * Copyright (c) 2006 Michael Richardson <mcr@xelerance.com> * 
+ * Copyright (c) 2006 Michael Richardson <mcr@xelerance.com> *
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/crypto/ocf/ixp4xx/ixp4xx.c b/crypto/ocf/ixp4xx/ixp4xx.c
index 948894a..f27b227 100644
--- a/crypto/ocf/ixp4xx/ixp4xx.c
+++ b/crypto/ocf/ixp4xx/ixp4xx.c
@@ -447,10 +447,10 @@ ixp_q_process(struct ixp_q *q)
 
 	if (q->ixp_q_ccrd) {
 		if (q->ixp_q_ccrd->crd_flags & CRD_F_ENCRYPT) {
-		if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT) {
-			q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
-		} else {
-			q->ixp_q_iv = q->ixp_q_iv_data;
+			if (q->ixp_q_ccrd->crd_flags & CRD_F_IV_EXPLICIT) {
+				q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
+			} else {
+				q->ixp_q_iv = q->ixp_q_iv_data;
 				read_random(q->ixp_q_iv, ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen);
 			}
 			if ((q->ixp_q_ccrd->crd_flags & CRD_F_IV_PRESENT) == 0)
@@ -463,11 +463,11 @@ ixp_q_process(struct ixp_q *q)
 				q->ixp_q_iv = q->ixp_q_ccrd->crd_iv;
 			else {
 				q->ixp_q_iv = q->ixp_q_iv_data;
-			crypto_copydata(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
-					q->ixp_q_ccrd->crd_inject,
-					ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
-					(caddr_t) q->ixp_q_iv);
-		}
+				crypto_copydata(q->ixp_q_crp->crp_flags, q->ixp_q_crp->crp_buf,
+						q->ixp_q_ccrd->crd_inject,
+						ixp->ixp_ctx.cipherCtx.cipherInitialVectorLen,
+						(caddr_t) q->ixp_q_iv);
+			}
 		}
 
 		if (q->ixp_q_acrd) {
@@ -533,7 +533,7 @@ ixp_q_process(struct ixp_q *q)
 		IX_MBUF_MLEN(&q->ixp_q_mbuf) = IX_MBUF_PKT_LEN(&q->ixp_q_mbuf) =
 			((IX_MBUF_MLEN(&q->ixp_q_mbuf) * 8) + 72 + 511) / 8;
 		tbuf = kmalloc(IX_MBUF_MLEN(&q->ixp_q_mbuf), SLAB_ATOMIC);
-		
+
 		if (IX_MBUF_MDATA(&q->ixp_q_mbuf) == NULL) {
 			printk("ixp: kmalloc(%u, SLAB_ATOMIC) failed\n",
 					IX_MBUF_MLEN(&q->ixp_q_mbuf));
@@ -1099,7 +1099,7 @@ ixp_kperform_cb(
 				&q->pkq_op,
 				ixp_kperform_cb,
 				&q->pkq_result);
-	
+
 		if (status == IX_CRYPTO_ACC_STATUS_SUCCESS) {
 			dprintk("%s() - ixCryptoAccPkeEauPerform SUCCESS\n", __FUNCTION__);
 			return; /* callback will return here for callback */
diff --git a/crypto/ocf/random.c b/crypto/ocf/random.c
index 4bb773f..440b7a5 100644
--- a/crypto/ocf/random.c
+++ b/crypto/ocf/random.c
@@ -303,7 +303,7 @@ random_proc(void *arg)
 #endif
 		}
 	}
-	
+
 	kfree(buf);
 
 bad_alloc:
diff --git a/crypto/ocf/safe/md5.c b/crypto/ocf/safe/md5.c
index 077c42e..8c6ded40 100644
--- a/crypto/ocf/safe/md5.c
+++ b/crypto/ocf/safe/md5.c
@@ -127,7 +127,7 @@ static const u_int8_t md5_paddat[MD5_BUFLEN] = {
 	0,	0,	0,	0,	0,	0,	0,	0,
 	0,	0,	0,	0,	0,	0,	0,	0,
 	0,	0,	0,	0,	0,	0,	0,	0,
-	0,	0,	0,	0,	0,	0,	0,	0,	
+	0,	0,	0,	0,	0,	0,	0,	0,
 };
 
 static void md5_calc(u_int8_t *, md5_ctxt *);
@@ -162,7 +162,7 @@ void md5_loop(ctxt, input, len)
 		for (i = gap; i + MD5_BUFLEN <= len; i += MD5_BUFLEN) {
 			md5_calc((u_int8_t *)(input + i), ctxt);
 		}
-		
+
 		ctxt->md5_i = len - i;
 		bcopy((void *)(input + i), (void *)ctxt->md5_buf, ctxt->md5_i);
 	} else {
@@ -177,7 +177,7 @@ void md5_pad(ctxt)
 {
 	u_int gap;
 
-	/* Don't count up padding. Keep md5_n. */	
+	/* Don't count up padding. Keep md5_n. */
 	gap = MD5_BUFLEN - ctxt->md5_i;
 	if (gap > 8) {
 		bcopy(md5_paddat,
@@ -193,7 +193,7 @@ void md5_pad(ctxt)
 		      MD5_BUFLEN - sizeof(ctxt->md5_n));
 	}
 
-	/* 8 byte word */	
+	/* 8 byte word */
 #if BYTE_ORDER == LITTLE_ENDIAN
 	bcopy(&ctxt->md5_n8[0], &ctxt->md5_buf[56], 8);
 #endif
@@ -241,7 +241,7 @@ static void md5_calc(b64, ctxt)
 	u_int32_t D = ctxt->md5_std;
 #if BYTE_ORDER == LITTLE_ENDIAN
 	u_int32_t *X = (u_int32_t *)b64;
-#endif	
+#endif
 #if BYTE_ORDER == BIG_ENDIAN
 	/* 4 byte words */
 	/* what a brute force but fast! */
@@ -273,7 +273,7 @@ static void md5_calc(b64, ctxt)
 	ROUND1(C, D, A, B, 10, Sc, 11); ROUND1(B, C, D, A, 11, Sd, 12);
 	ROUND1(A, B, C, D, 12, Sa, 13); ROUND1(D, A, B, C, 13, Sb, 14);
 	ROUND1(C, D, A, B, 14, Sc, 15); ROUND1(B, C, D, A, 15, Sd, 16);
-	
+
 	ROUND2(A, B, C, D,  1, Se, 17); ROUND2(D, A, B, C,  6, Sf, 18);
 	ROUND2(C, D, A, B, 11, Sg, 19); ROUND2(B, C, D, A,  0, Sh, 20);
 	ROUND2(A, B, C, D,  5, Se, 21); ROUND2(D, A, B, C, 10, Sf, 22);
@@ -291,14 +291,14 @@ static void md5_calc(b64, ctxt)
 	ROUND3(C, D, A, B,  3, Sk, 43); ROUND3(B, C, D, A,  6, Sl, 44);
 	ROUND3(A, B, C, D,  9, Si, 45); ROUND3(D, A, B, C, 12, Sj, 46);
 	ROUND3(C, D, A, B, 15, Sk, 47); ROUND3(B, C, D, A,  2, Sl, 48);
-	
-	ROUND4(A, B, C, D,  0, Sm, 49); ROUND4(D, A, B, C,  7, Sn, 50);	
-	ROUND4(C, D, A, B, 14, So, 51); ROUND4(B, C, D, A,  5, Sp, 52);	
-	ROUND4(A, B, C, D, 12, Sm, 53); ROUND4(D, A, B, C,  3, Sn, 54);	
-	ROUND4(C, D, A, B, 10, So, 55); ROUND4(B, C, D, A,  1, Sp, 56);	
-	ROUND4(A, B, C, D,  8, Sm, 57); ROUND4(D, A, B, C, 15, Sn, 58);	
-	ROUND4(C, D, A, B,  6, So, 59); ROUND4(B, C, D, A, 13, Sp, 60);	
-	ROUND4(A, B, C, D,  4, Sm, 61); ROUND4(D, A, B, C, 11, Sn, 62);	
+
+	ROUND4(A, B, C, D,  0, Sm, 49); ROUND4(D, A, B, C,  7, Sn, 50);
+	ROUND4(C, D, A, B, 14, So, 51); ROUND4(B, C, D, A,  5, Sp, 52);
+	ROUND4(A, B, C, D, 12, Sm, 53); ROUND4(D, A, B, C,  3, Sn, 54);
+	ROUND4(C, D, A, B, 10, So, 55); ROUND4(B, C, D, A,  1, Sp, 56);
+	ROUND4(A, B, C, D,  8, Sm, 57); ROUND4(D, A, B, C, 15, Sn, 58);
+	ROUND4(C, D, A, B,  6, So, 59); ROUND4(B, C, D, A, 13, Sp, 60);
+	ROUND4(A, B, C, D,  4, Sm, 61); ROUND4(D, A, B, C, 11, Sn, 62);
 	ROUND4(C, D, A, B,  2, So, 63); ROUND4(B, C, D, A,  9, Sp, 64);
 
 	ctxt->md5_sta += A;
diff --git a/crypto/ocf/safe/safe.c b/crypto/ocf/safe/safe.c
index 141640e..a392b45 100644
--- a/crypto/ocf/safe/safe.c
+++ b/crypto/ocf/safe/safe.c
@@ -338,7 +338,7 @@ safe_intr(int irq, void *arg, struct pt_regs *regs)
 		sc->sc_needwakeup &= ~wakeup;
 		crypto_unblock(sc->sc_cid, wakeup);
 	}
-	
+
 	return IRQ_HANDLED;
 }
 
@@ -870,7 +870,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 		/*
 		 * Tell the hardware to copy the header to the output.
 		 * The header is defined as the data from the end of
-		 * the bypass to the start of data to be encrypted. 
+		 * the bypass to the start of data to be encrypted.
 		 * Typically this is the inline IV.  Note that you need
 		 * to do this even if src+dst are the same; it appears
 		 * that w/o this bit the crypted data is written
@@ -969,7 +969,7 @@ safe_process(device_t dev, struct cryptop *crp, int hint)
 					 * destination wil result in a
 					 * destination particle list that does
 					 * the necessary scatter DMA.
-					 */ 
+					 */
 					safestats.st_iovnotuniform++;
 					err = EINVAL;
 					goto errout;
@@ -1082,7 +1082,7 @@ safe_callback(struct safe_softc *sc, struct safe_ringentry *re)
 		pci_unmap_operand(sc, &re->re_dst);
 	pci_unmap_operand(sc, &re->re_src);
 
-	/* 
+	/*
 	 * If result was written to a differet mbuf chain, swap
 	 * it in as the return value and reclaim the original.
 	 */
@@ -1107,14 +1107,14 @@ safe_callback(struct safe_softc *sc, struct safe_ringentry *re)
 				 */
 				re->re_sastate.sa_saved_indigest[0] =
 					cpu_to_be32(re->re_sastate.sa_saved_indigest[0]);
-				re->re_sastate.sa_saved_indigest[1] = 
+				re->re_sastate.sa_saved_indigest[1] =
 					cpu_to_be32(re->re_sastate.sa_saved_indigest[1]);
 				re->re_sastate.sa_saved_indigest[2] =
 					cpu_to_be32(re->re_sastate.sa_saved_indigest[2]);
 			} else {
 				re->re_sastate.sa_saved_indigest[0] =
 					cpu_to_le32(re->re_sastate.sa_saved_indigest[0]);
-				re->re_sastate.sa_saved_indigest[1] = 
+				re->re_sastate.sa_saved_indigest[1] =
 					cpu_to_le32(re->re_sastate.sa_saved_indigest[1]);
 				re->re_sastate.sa_saved_indigest[2] =
 					cpu_to_le32(re->re_sastate.sa_saved_indigest[2]);
@@ -1156,7 +1156,7 @@ safe_rng_init(struct safe_softc *sc)
 	 * status reg in the read in case it is initialized.  Then read
 	 * the data register until it changes from the first read.
 	 * Once it changes read the data register until it changes
-	 * again.  At this time the RNG is considered initialized. 
+	 * again.  At this time the RNG is considered initialized.
 	 * This could take between 750ms - 1000ms in time.
 	 */
 	i = 0;
@@ -1194,7 +1194,7 @@ safe_rng_enable_short_cycle(struct safe_softc *sc)
 {
 	DPRINTF(("%s()\n", __FUNCTION__));
 
-	WRITE_REG(sc, SAFE_RNG_CTRL, 
+	WRITE_REG(sc, SAFE_RNG_CTRL,
 		READ_REG(sc, SAFE_RNG_CTRL) | SAFE_RNG_CTRL_SHORTEN);
 }
 
@@ -1216,7 +1216,7 @@ safe_read_random(void *arg, u_int32_t *buf, int maxwords)
 	int i, rc;
 
 	DPRINTF(("%s()\n", __FUNCTION__));
-	
+
 	safestats.st_rng++;
 	/*
 	 * Fetch the next block of data.
@@ -1436,9 +1436,9 @@ safe_free_entry(struct safe_softc *sc, struct safe_ringentry *re)
 #endif
 
 	crp = (struct cryptop *)re->re_crp;
-	
+
 	re->re_desc.d_csr = 0;
-	
+
 	crp->crp_etype = EFAULT;
 	crypto_done(crp);
 	return(0);
@@ -1600,7 +1600,7 @@ safe_kstart(struct safe_softc *sc)
 		    ((base_bits + 7) / 8) - 1;
 		modp = krp->krp_param[SAFE_CRK_PARAM_MOD].crp_p +
 		    ((mod_bits + 7) / 8) - 1;
-		
+
 		for (i = 0; i < (mod_bits + 7) / 8; i++, basep--, modp--) {
 			if (*modp < *basep)
 				goto too_small;
diff --git a/crypto/ocf/safe/safereg.h b/crypto/ocf/safe/safereg.h
index dbaf98f..d3461f9 100644
--- a/crypto/ocf/safe/safereg.h
+++ b/crypto/ocf/safe/safereg.h
@@ -410,7 +410,7 @@ struct safe_sarec {
 #define	SAFE_SA_CMD1_AES192	0x03000000	/* 192-bit AES key */
 #define	SAFE_SA_CMD1_AES256	0x04000000	/* 256-bit AES key */
 
-/* 
+/*
  * Security Associate State Record (Rev 1).
  */
 struct safe_sastate {
diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index c4bc8c0..60854a1 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -40,12 +40,12 @@
  * The Freescale SEC (also known as 'talitos') resides on the
  * internal bus, and runs asynchronous to the processor core.  It has
  * a wide gamut of cryptographic acceleration features, including single-
- * pass IPsec (also known as algorithm chaining).  To properly utilize 
- * all of the SEC's performance enhancing features, further reworking 
+ * pass IPsec (also known as algorithm chaining).  To properly utilize
+ * all of the SEC's performance enhancing features, further reworking
  * of higher level code (framework, applications) will be necessary.
  *
  * The following table shows which SEC version is present in which devices:
- * 
+ *
  * Devices       SEC version
  *
  * 8272, 8248    SEC 1.0
@@ -89,13 +89,13 @@
  *
  * Channel ch0 may drive an aes operation to the aes unit (AESU),
  * and, at the same time, ch1 may drive a message digest operation
- * to the mdeu. Each channel has an input descriptor FIFO, and the 
+ * to the mdeu. Each channel has an input descriptor FIFO, and the
  * FIFO can contain, e.g. on the 8541E, up to 24 entries, before a
  * a buffer overrun error is triggered. The controller is responsible
- * for fetching the data from descriptor pointers, and passing the 
- * data to the appropriate EUs. The controller also writes the 
- * cryptographic operation's result to memory. The SEC notifies 
- * completion by triggering an interrupt and/or setting the 1st byte 
+ * for fetching the data from descriptor pointers, and passing the
+ * data to the appropriate EUs. The controller also writes the
+ * cryptographic operation's result to memory. The SEC notifies
+ * completion by triggering an interrupt and/or setting the 1st byte
  * of the hdr field to 0xff.
  *
  * TODO:
@@ -132,7 +132,7 @@
 #include <cryptodev.h>
 #include <uio.h>
 
-#define DRV_NAME "talitos" 
+#define DRV_NAME "talitos"
 
 #include "talitos_dev.h"
 #include "talitos_soft.h"
@@ -147,7 +147,7 @@ static int talitos_newsession(device_t dev, u_int32_t *sidp,
 static int talitos_freesession(device_t dev, u_int64_t tid);
 static int talitos_process(device_t dev, struct cryptop *crp, int hint);
 static void dump_talitos_status(struct talitos_softc *sc);
-static int talitos_submit(struct talitos_softc *sc, struct talitos_desc *td, 
+static int talitos_submit(struct talitos_softc *sc, struct talitos_desc *td,
 								int chsel);
 static void talitos_doneprocessing(struct talitos_softc *sc);
 static void talitos_init_device(struct talitos_softc *sc);
@@ -205,26 +205,26 @@ static void dump_talitos_status(struct talitos_softc *sc)
 	v_hi = talitos_read(sc->sc_base_addr + TALITOS_ISR_HI);
 	printk(KERN_INFO "%s: ISR          0x%08x_%08x\n",
 			device_get_nameunit(sc->sc_cdev), v, v_hi);
-	for (i = 0; i < sc->sc_num_channels; i++) { 
-		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
 			TALITOS_CH_CDPR);
-		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
 			TALITOS_CH_CDPR_HI);
-		printk(KERN_INFO "%s: CDPR     ch%d 0x%08x_%08x\n", 
+		printk(KERN_INFO "%s: CDPR     ch%d 0x%08x_%08x\n",
 				device_get_nameunit(sc->sc_cdev), i, v, v_hi);
 	}
-	for (i = 0; i < sc->sc_num_channels; i++) { 
-		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+	for (i = 0; i < sc->sc_num_channels; i++) {
+		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
 			TALITOS_CH_CCPSR);
-		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET + 
+		v_hi = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
 			TALITOS_CH_CCPSR_HI);
-		printk(KERN_INFO "%s: CCPSR    ch%d 0x%08x_%08x\n", 
+		printk(KERN_INFO "%s: CCPSR    ch%d 0x%08x_%08x\n",
 				device_get_nameunit(sc->sc_cdev), i, v, v_hi);
 	}
 	ptr = sc->sc_base_addr + TALITOS_CH_DESCBUF;
-	for (i = 0; i < 16; i++) { 
+	for (i = 0; i < 16; i++) {
 		v = talitos_read(ptr++); v_hi = talitos_read(ptr++);
-		printk(KERN_INFO "%s: DESCBUF  ch0 0x%08x_%08x (tdp%02d)\n", 
+		printk(KERN_INFO "%s: DESCBUF  ch0 0x%08x_%08x (tdp%02d)\n",
 				device_get_nameunit(sc->sc_cdev), v, v_hi, i);
 	}
 	return;
@@ -232,7 +232,7 @@ static void dump_talitos_status(struct talitos_softc *sc)
 
 
 #ifdef CONFIG_OCF_RANDOMHARVEST
-/* 
+/*
  * pull random numbers off the RNG FIFO, not exceeding amount available
  */
 static int
@@ -252,7 +252,7 @@ talitos_read_random(void *arg, u_int32_t *buf, int maxwords)
 		return 0;
 	}
 	/*
-	 * OFL is number of available 64-bit words, 
+	 * OFL is number of available 64-bit words,
 	 * shift and convert to a 32-bit word count
 	 */
 	v = talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI);
@@ -260,16 +260,16 @@ talitos_read_random(void *arg, u_int32_t *buf, int maxwords)
 	if (maxwords > v)
 		maxwords = v;
 	for (rc = 0; rc < maxwords; rc++) {
-		buf[rc] = talitos_read(sc->sc_base_addr + 
+		buf[rc] = talitos_read(sc->sc_base_addr +
 			TALITOS_RNG_FIFO + rc*sizeof(u_int32_t));
 	}
 	if (maxwords & 1) {
-		/* 
+		/*
 		 * RNG will complain with an AE in the RNGISR
 		 * if we don't complete the pairs of 32-bit reads
 		 * to its 64-bit register based FIFO
 		 */
-		v = talitos_read(sc->sc_base_addr + 
+		v = talitos_read(sc->sc_base_addr +
 			TALITOS_RNG_FIFO + rc*sizeof(u_int32_t));
 	}
 
@@ -286,18 +286,18 @@ talitos_rng_init(struct talitos_softc *sc)
 	v = talitos_read(sc->sc_base_addr + TALITOS_RNGRCR_HI);
 	v |= TALITOS_RNGRCR_HI_SR;
 	talitos_write(sc->sc_base_addr + TALITOS_RNGRCR_HI, v);
-	while ((talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI) 
+	while ((talitos_read(sc->sc_base_addr + TALITOS_RNGSR_HI)
 		& TALITOS_RNGSR_HI_RD) == 0)
 			cpu_relax();
 	/*
 	 * we tell the RNG to start filling the RNG FIFO
-	 * by writing the RNGDSR 
+	 * by writing the RNGDSR
 	 */
 	v = talitos_read(sc->sc_base_addr + TALITOS_RNGDSR_HI);
 	talitos_write(sc->sc_base_addr + TALITOS_RNGDSR_HI, v);
 	/*
-	 * 64 bits of data will be pushed onto the FIFO every 
-	 * 256 SEC cycles until the FIFO is full.  The RNG then 
+	 * 64 bits of data will be pushed onto the FIFO every
+	 * 256 SEC cycles until the FIFO is full.  The RNG then
 	 * attempts to keep the FIFO full.
 	 */
 	v = talitos_read(sc->sc_base_addr + TALITOS_RNGISR_HI);
@@ -307,7 +307,7 @@ talitos_rng_init(struct talitos_softc *sc)
 		return;
 	}
 	/*
-	 * n.b. we need to add a FIPS test here - if the RNG is going 
+	 * n.b. we need to add a FIPS test here - if the RNG is going
 	 * to fail, it's going to fail at reset time
 	 */
 	return;
@@ -353,7 +353,7 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 	}
 	if (encini == NULL && macini == NULL)
 		return EINVAL;
-	if (encini) {	
+	if (encini) {
 		/* validate key length */
 		switch (encini->cri_alg) {
 		case CRYPTO_DES_CBC:
@@ -372,7 +372,7 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 				return EINVAL;
 			break;
 		default:
-			DPRINTF("UNKNOWN encini->cri_alg %d\n", 
+			DPRINTF("UNKNOWN encini->cri_alg %d\n",
 				encini->cri_alg);
 			return EINVAL;
 		}
@@ -398,13 +398,13 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 			/* allocating session */
 			sesn = sc->sc_nsessions;
 			ses = (struct talitos_session *) kmalloc(
-				(sesn + 1) * sizeof(struct talitos_session), 
+				(sesn + 1) * sizeof(struct talitos_session),
 				SLAB_ATOMIC);
 			if (ses == NULL)
 				return ENOMEM;
 			memset(ses, 0,
 				(sesn + 1) * sizeof(struct talitos_session));
-			memcpy(ses, sc->sc_sessions, 
+			memcpy(ses, sc->sc_sessions,
 				sesn * sizeof(struct talitos_session));
 			memset(sc->sc_sessions, 0,
 				sesn * sizeof(struct talitos_session));
@@ -443,7 +443,7 @@ talitos_newsession(device_t dev, u_int32_t *sidp, struct cryptoini *cri)
 		}
 	}
 
-	/* really should make up a template td here, 
+	/* really should make up a template td here,
 	 * and only fill things like i/o and direction in process() */
 
 	/* assign session ID */
@@ -474,10 +474,10 @@ talitos_freesession(device_t dev, u_int64_t tid)
 }
 
 /*
- * launch device processing - it will come back with done notification 
- * in the form of an interrupt and/or HDR_DONE_BITS in header 
+ * launch device processing - it will come back with done notification
+ * in the form of an interrupt and/or HDR_DONE_BITS in header
  */
-static int 
+static int
 talitos_submit(
 	struct talitos_softc *sc,
 	struct talitos_desc *td,
@@ -486,9 +486,9 @@ talitos_submit(
 	u_int32_t v;
 
 	v = dma_map_single(NULL, td, sizeof(*td), DMA_TO_DEVICE);
-	talitos_write(sc->sc_base_addr + 
+	talitos_write(sc->sc_base_addr +
 		chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF, 0);
-	talitos_write(sc->sc_base_addr + 
+	talitos_write(sc->sc_base_addr +
 		chsel*TALITOS_CH_OFFSET + TALITOS_CH_FF_HI, v);
 	return 0;
 }
@@ -504,7 +504,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 	struct talitos_desc *td;
 	unsigned long flags;
 	/* descriptor mappings */
-	int hmac_key, hmac_data, cipher_iv, cipher_key, 
+	int hmac_key, hmac_data, cipher_iv, cipher_key,
 		in_fifo, out_fifo, cipher_iv_out;
 	static int chsel = -1;
 	u_int32_t rand_iv[4];
@@ -521,7 +521,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 
 	ses = &sc->sc_sessions[TALITOS_SESSION(crp->crp_sid)];
 
-        /* enter the channel scheduler */ 
+        /* enter the channel scheduler */
 	spin_lock_irqsave(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
 
 	/* reuse channel that already had/has requests for the required EU */
@@ -533,19 +533,19 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 		/*
 		 * haven't seen this algo the last sc_num_channels or more
 		 * use round robin in this case
-	 	 * nb: sc->sc_num_channels must be power of 2 
+	 	 * nb: sc->sc_num_channels must be power of 2
 		 */
 		chsel = (chsel + 1) & (sc->sc_num_channels - 1);
 	} else {
 		/*
-		 * matches channel with same target execution unit; 
+		 * matches channel with same target execution unit;
 		 * use same channel in this case
 		 */
 		chsel = i;
 	}
 	sc->sc_chnlastalg[chsel] = crp->crp_desc->crd_alg;
 
-        /* release the channel scheduler lock */ 
+        /* release the channel scheduler lock */
 	spin_unlock_irqrestore(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
 
 	/* acquire the selected channel fifo lock */
@@ -554,7 +554,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 	/* find and reserve next available descriptor-cryptop pair */
 	for (i = 0; i < sc->sc_chfifo_len; i++) {
 		if (sc->sc_chnfifo[chsel][i].cf_desc.hdr == 0) {
-			/* 
+			/*
 			 * ensure correct descriptor formation by
 			 * avoiding inadvertently setting "optional" entries
 			 * e.g. not using "optional" dptr2 for MD/HMAC descs
@@ -562,7 +562,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			memset(&sc->sc_chnfifo[chsel][i].cf_desc,
 				0, sizeof(*td));
 			/* reserve it with done notification request bit */
-			sc->sc_chnfifo[chsel][i].cf_desc.hdr |= 
+			sc->sc_chnfifo[chsel][i].cf_desc.hdr |=
 				TALITOS_DONE_NOTIFY;
 			break;
 		}
@@ -574,7 +574,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 		err = ERESTART;
 		goto errout;
 	}
-	
+
 	td = &sc->sc_chnfifo[chsel][i].cf_desc;
 	sc->sc_chnfifo[chsel][i].cf_crp = crp;
 
@@ -669,10 +669,10 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			err = EINVAL;
 			goto errout;
 		}
-		td->ptr[in_fifo].ptr = dma_map_single(NULL, skb->data, 
+		td->ptr[in_fifo].ptr = dma_map_single(NULL, skb->data,
 			skb->len, DMA_TO_DEVICE);
 		td->ptr[in_fifo].len = skb->len;
-		td->ptr[out_fifo].ptr = dma_map_single(NULL, skb->data, 
+		td->ptr[out_fifo].ptr = dma_map_single(NULL, skb->data,
 			skb->len, DMA_TO_DEVICE);
 		td->ptr[out_fifo].len = skb->len;
 		td->ptr[hmac_data].ptr = dma_map_single(NULL, skb->data,
@@ -745,7 +745,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 		 * copy both the header+IV.
 		 */
 		if (enccrd->crd_flags & CRD_F_ENCRYPT) {
-			td->hdr |= TALITOS_DIR_OUTBOUND; 
+			td->hdr |= TALITOS_DIR_OUTBOUND;
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT)
 				iv = enccrd->crd_iv;
 			else
@@ -755,7 +755,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 				    enccrd->crd_inject, ivsize, iv);
 			}
 		} else {
-			td->hdr |= TALITOS_DIR_INBOUND; 
+			td->hdr |= TALITOS_DIR_INBOUND;
 			if (enccrd->crd_flags & CRD_F_IV_EXPLICIT) {
 				iv = enccrd->crd_iv;
 			} else {
@@ -764,7 +764,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 				    enccrd->crd_inject, ivsize, iv);
 			}
 		}
-		td->ptr[cipher_iv].ptr = dma_map_single(NULL, iv, ivsize, 
+		td->ptr[cipher_iv].ptr = dma_map_single(NULL, iv, ivsize,
 			DMA_TO_DEVICE);
 		td->ptr[cipher_iv].len = ivsize;
 		/*
@@ -782,16 +782,16 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			|  TALITOS_MODE1_MDEU_INIT
 			|  TALITOS_MODE1_MDEU_PAD;
 		switch (maccrd->crd_alg) {
-			case	CRYPTO_MD5:	
+			case	CRYPTO_MD5:
 				td->hdr |= TALITOS_MODE1_MDEU_MD5;
 				break;
-			case	CRYPTO_MD5_HMAC:	
+			case	CRYPTO_MD5_HMAC:
 				td->hdr |= TALITOS_MODE1_MDEU_MD5_HMAC;
 				break;
-			case	CRYPTO_SHA1:	
+			case	CRYPTO_SHA1:
 				td->hdr |= TALITOS_MODE1_MDEU_SHA1;
 				break;
-			case	CRYPTO_SHA1_HMAC:	
+			case	CRYPTO_SHA1_HMAC:
 				td->hdr |= TALITOS_MODE1_MDEU_SHA1_HMAC;
 				break;
 			default:
@@ -808,7 +808,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			 * crypt data is the difference in the skips.
 			 */
 			/* ipsec only for now */
-			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
+			td->ptr[hmac_key].ptr = dma_map_single(NULL,
 				ses->ses_hmac, ses->ses_hmac_len, DMA_TO_DEVICE);
 			td->ptr[hmac_key].len = ses->ses_hmac_len;
 			td->ptr[in_fifo].ptr  += enccrd->crd_skip;
@@ -817,7 +817,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 			td->ptr[out_fifo].len =  enccrd->crd_len;
 			/* bytes of HMAC to postpend to ciphertext */
 			td->ptr[out_fifo].extent =  ses->ses_mlen;
-			td->ptr[hmac_data].ptr += maccrd->crd_skip; 
+			td->ptr[hmac_data].ptr += maccrd->crd_skip;
 			td->ptr[hmac_data].len = enccrd->crd_skip - maccrd->crd_skip;
 		}
 		if (enccrd->crd_flags & CRD_F_KEY_EXPLICIT) {
@@ -831,22 +831,22 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 				|  TALITOS_MODE0_MDEU_INIT
 				|  TALITOS_MODE0_MDEU_PAD;
 		switch (maccrd->crd_alg) {
-			case	CRYPTO_MD5:	
+			case	CRYPTO_MD5:
 				td->hdr |= TALITOS_MODE0_MDEU_MD5;
 				DPRINTF("MD5  ses %d ch %d len %d\n",
-					(u32)TALITOS_SESSION(crp->crp_sid), 
+					(u32)TALITOS_SESSION(crp->crp_sid),
 					chsel, td->ptr[in_fifo].len);
 				break;
-			case	CRYPTO_MD5_HMAC:	
+			case	CRYPTO_MD5_HMAC:
 				td->hdr |= TALITOS_MODE0_MDEU_MD5_HMAC;
 				break;
-			case	CRYPTO_SHA1:	
+			case	CRYPTO_SHA1:
 				td->hdr |= TALITOS_MODE0_MDEU_SHA1;
 				DPRINTF("SHA1 ses %d ch %d len %d\n",
-					(u32)TALITOS_SESSION(crp->crp_sid), 
+					(u32)TALITOS_SESSION(crp->crp_sid),
 					chsel, td->ptr[in_fifo].len);
 				break;
-			case	CRYPTO_SHA1_HMAC:	
+			case	CRYPTO_SHA1_HMAC:
 				td->hdr |= TALITOS_MODE0_MDEU_SHA1_HMAC;
 				break;
 			default:
@@ -861,16 +861,16 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 
 		if ((maccrd->crd_alg == CRYPTO_MD5_HMAC) ||
 		   (maccrd->crd_alg == CRYPTO_SHA1_HMAC)) {
-			td->ptr[hmac_key].ptr = dma_map_single(NULL, 
-				ses->ses_hmac, ses->ses_hmac_len, 
+			td->ptr[hmac_key].ptr = dma_map_single(NULL,
+				ses->ses_hmac, ses->ses_hmac_len,
 				DMA_TO_DEVICE);
 			td->ptr[hmac_key].len = ses->ses_hmac_len;
 		}
-	} 
+	}
 	else {
 		/* using process key (session data has duplicate) */
-		td->ptr[cipher_key].ptr = dma_map_single(NULL, 
-			enccrd->crd_key, (enccrd->crd_klen + 7) / 8, 
+		td->ptr[cipher_key].ptr = dma_map_single(NULL,
+			enccrd->crd_key, (enccrd->crd_klen + 7) / 8,
 			DMA_TO_DEVICE);
 		td->ptr[cipher_key].len = (enccrd->crd_klen + 7) / 8;
 	}
@@ -885,8 +885,8 @@ errout:
 	return err;
 }
 
-/* go through all channels descriptors, notifying OCF what has 
- * _and_hasn't_ successfully completed and reset the device 
+/* go through all channels descriptors, notifying OCF what has
+ * _and_hasn't_ successfully completed and reset the device
  * (otherwise it's up to decoding desc hdrs!)
  */
 static void talitos_errorprocessing(struct talitos_softc *sc)
@@ -898,19 +898,19 @@ static void talitos_errorprocessing(struct talitos_softc *sc)
 	spin_lock_irqsave(&sc->sc_chnfifolock[sc->sc_num_channels], flags);
 
 	if (debug) dump_talitos_status(sc);
-	/* go through descriptors, try and salvage those successfully done, 
+	/* go through descriptors, try and salvage those successfully done,
 	 * and EIO those that weren't
 	 */
 	for (i = 0; i < sc->sc_num_channels; i++) {
 		spin_lock_irqsave(&sc->sc_chnfifolock[i], flags);
 		for (j = 0; j < sc->sc_chfifo_len; j++) {
 			if (sc->sc_chnfifo[i][j].cf_desc.hdr) {
-				if ((sc->sc_chnfifo[i][j].cf_desc.hdr 
-					& TALITOS_HDR_DONE_BITS) 
+				if ((sc->sc_chnfifo[i][j].cf_desc.hdr
+					& TALITOS_HDR_DONE_BITS)
 					!= TALITOS_HDR_DONE_BITS) {
 					/* this one didn't finish */
 					/* signify in crp->etype */
-					sc->sc_chnfifo[i][j].cf_crp->crp_etype 
+					sc->sc_chnfifo[i][j].cf_crp->crp_etype
 						= EIO;
 				}
 			} else
@@ -953,8 +953,8 @@ static void talitos_doneprocessing(struct talitos_softc *sc)
 		spin_lock_irqsave(&sc->sc_chnfifolock[i], flags);
 		for (j = 0; j < sc->sc_chfifo_len; j++) {
 			/* descriptor has done bits set? */
-			if ((sc->sc_chnfifo[i][j].cf_desc.hdr 
-				& TALITOS_HDR_DONE_BITS) 
+			if ((sc->sc_chnfifo[i][j].cf_desc.hdr
+				& TALITOS_HDR_DONE_BITS)
 				== TALITOS_HDR_DONE_BITS) {
 				/* notify ocf */
 				crypto_done(sc->sc_chnfifo[i][j].cf_crp);
@@ -982,7 +982,7 @@ talitos_intr(int irq, void *arg, struct pt_regs *regs)
 {
 	struct talitos_softc *sc = arg;
 	u_int32_t v, v_hi;
-	
+
 	/* ack */
 	v = talitos_read(sc->sc_base_addr + TALITOS_ISR);
 	v_hi = talitos_read(sc->sc_base_addr + TALITOS_ISR_HI);
@@ -1014,11 +1014,11 @@ talitos_init_device(struct talitos_softc *sc)
 
 	/* init all channels */
 	for (i = 0; i < sc->sc_num_channels; i++) {
-		v = talitos_read(sc->sc_base_addr + 
+		v = talitos_read(sc->sc_base_addr +
 			i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR_HI);
 		v |= TALITOS_CH_CCCR_HI_CDWE
 		  |  TALITOS_CH_CCCR_HI_CDIE;  /* invoke interrupt if done */
-		talitos_write(sc->sc_base_addr + 
+		talitos_write(sc->sc_base_addr +
 			i*TALITOS_CH_OFFSET + TALITOS_CH_CCCR_HI, v);
 	}
 	/* enable all interrupts */
@@ -1063,13 +1063,13 @@ talitos_reset_device(struct talitos_softc *sc)
 
 	/*
 	 * Master reset
-	 * errata documentation: warning: certain SEC interrupts 
-	 * are not fully cleared by writing the MCR:SWR bit, 
-	 * set bit twice to completely reset 
+	 * errata documentation: warning: certain SEC interrupts
+	 * are not fully cleared by writing the MCR:SWR bit,
+	 * set bit twice to completely reset
 	 */
 	talitos_reset_device_master(sc);	/* once */
 	talitos_reset_device_master(sc);	/* and once again */
-	
+
 	/* reset all channels */
 	for (i = 0; i < sc->sc_num_channels; i++) {
 		v = talitos_read(sc->sc_base_addr + i*TALITOS_CH_OFFSET +
@@ -1139,7 +1139,7 @@ static int talitos_probe(struct platform_device *pdev)
 	rc = request_irq(sc->sc_irq, talitos_intr, 0,
 			device_get_nameunit(sc->sc_cdev), sc);
 	if (rc) {
-		printk(KERN_ERR "%s: failed to hook irq %d\n", 
+		printk(KERN_ERR "%s: failed to hook irq %d\n",
 				device_get_nameunit(sc->sc_cdev), sc->sc_irq);
 		sc->sc_irq = -1;
 		goto out;
@@ -1201,17 +1201,17 @@ static int talitos_probe(struct platform_device *pdev)
 	memset(sc->sc_chnlastalg, 0, sc->sc_num_channels * sizeof(int));
 
 	sc->sc_chnfifo = (struct desc_cryptop_pair **) kmalloc(
-		sc->sc_num_channels * sizeof(struct desc_cryptop_pair *), 
+		sc->sc_num_channels * sizeof(struct desc_cryptop_pair *),
 		GFP_KERNEL);
 	if (!sc->sc_chnfifo)
 		goto out;
 	for (i = 0; i < sc->sc_num_channels; i++) {
 		sc->sc_chnfifo[i] = (struct desc_cryptop_pair *) kmalloc(
-			sc->sc_chfifo_len * sizeof(struct desc_cryptop_pair), 
+			sc->sc_chfifo_len * sizeof(struct desc_cryptop_pair),
 			GFP_KERNEL);
 		if (!sc->sc_chnfifo[i])
 			goto out;
-		memset(sc->sc_chnfifo[i], 0, 
+		memset(sc->sc_chnfifo[i], 0,
 			sc->sc_chfifo_len * sizeof(struct desc_cryptop_pair));
 	}
 
diff --git a/crypto/ocf/talitos/talitos_dev.h b/crypto/ocf/talitos/talitos_dev.h
index a8b0479..86bb57c 100644
--- a/crypto/ocf/talitos/talitos_dev.h
+++ b/crypto/ocf/talitos/talitos_dev.h
@@ -33,7 +33,7 @@
 #define TALITOS_ID_SEC_2_1	0x40 /* cross ref with IP block revision reg */
 
 /*
- * following num_channels, channel-fifo-depth, exec-unit-mask, and 
+ * following num_channels, channel-fifo-depth, exec-unit-mask, and
  * descriptor-types-mask are for forward-compatibility with openfirmware
  * flat device trees
  */
@@ -61,11 +61,11 @@
 #define TALITOS_CHFIFOLEN_SEC_2_1	24
 #define TALITOS_CHFIFOLEN_SEC_2_4	24
 
-/* 
+/*
  *  exec-unit-mask : The bitmask representing what Execution Units (EUs)
- *  are available. EU information should be encoded following the SEC's 
+ *  are available. EU information should be encoded following the SEC's
  *  EU_SEL0 bitfield documentation, i.e. as follows:
- * 
+ *
  *    bit 31 = set if SEC permits no-EU selection (should be always set)
  *    bit 30 = set if SEC has the ARC4 EU (AFEU)
  *    bit 29 = set if SEC has the des/3des EU (DEU)
@@ -74,7 +74,7 @@
  *    bit 26 = set if SEC has the public key EU (PKEU)
  *    bit 25 = set if SEC has the aes EU (AESU)
  *    bit 24 = set if SEC has the Kasumi EU (KEU)
- * 
+ *
  */
 #define TALITOS_HAS_EU_NONE		(1<<0)
 #define TALITOS_HAS_EU_AFEU		(1<<1)
@@ -95,8 +95,8 @@
 
 /*
  *  descriptor-types-mask : The bitmask representing what descriptors
- *  are available. Descriptor type information should be encoded 
- *  following the SEC's Descriptor Header Dword DESC_TYPE field 
+ *  are available. Descriptor type information should be encoded
+ *  following the SEC's Descriptor Header Dword DESC_TYPE field
  *  documentation, i.e. as follows:
  *
  *    bit 0  = set if SEC supports the aesu_ctr_nonsnoop desc. type
@@ -122,7 +122,7 @@
 #define TALITOS_HAS_DESCTYPES_SEC_2_0	0x01010ebf
 #define TALITOS_HAS_DESCTYPES_SEC_2_1	0x012b0ebf
 
-/* 
+/*
  * a TALITOS_xxx_HI address points to the low data bits (32-63) of the register
  */
 
@@ -161,7 +161,7 @@
 #define TALITOS_CH_FF_HI	0x114c	/* Fetch FIFO's FETCH_ADRS */
 #define TALITOS_CH_CDPR		0x1140	/* Crypto-Channel Pointer Status Reg */
 #define TALITOS_CH_CDPR_HI	0x1144	/* Crypto-Channel Pointer Status Reg */
-#define TALITOS_CH_DESCBUF	0x1180	/* (thru 11bf) Crypto-Channel 
+#define TALITOS_CH_DESCBUF	0x1180	/* (thru 11bf) Crypto-Channel
 					 * Descriptor Buffer (debug) */
 
 /* execution unit register offset addresses and bits */
-- 
1.7.5.4

