From f45aea8fc4be75b5a5c84c3242e482797514226a Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Sun, 29 Dec 2013 18:50:01 +0200
Subject: [PATCH 1243/1825] fix: xor: avanta: Add support for XOR engine

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e2e21f36ec7f446937a9eb9d8e3582ac421938c9

	XOR engine driver is the mainline driver at
	drivers/dma/mv_xor.c file.

Change-Id: Iaed7e9bfa468d8843df1e03f2735df91dd7683a6
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4929
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/avanta_gw_defconfig               |    2 +
 arch/arm/mach-feroceon-kw2/core.c                  |  190 +++++++++++++++++++-
 .../mach-feroceon-kw2/include/mach/bridge-regs.h   |    5 +
 arch/arm/plat-feroceon/include/plat/mv_xor.h       |   30 +++
 drivers/dma/Kconfig                                |    2 +-
 5 files changed, 227 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/plat-feroceon/include/plat/mv_xor.h

diff --git a/arch/arm/configs/avanta_gw_defconfig b/arch/arm/configs/avanta_gw_defconfig
index 3fe9750..a909e32 100644
--- a/arch/arm/configs/avanta_gw_defconfig
+++ b/arch/arm/configs/avanta_gw_defconfig
@@ -183,6 +183,8 @@ CONFIG_USB_SERIAL_CP210X=y
 CONFIG_MMC=y
 CONFIG_MMC_SDHCI=y
 CONFIG_MMC_MVSDIO=y
+CONFIG_DMADEVICES=y
+CONFIG_MV_XOR=y
 CONFIG_STAGING=y
 CONFIG_PHONE=y
 CONFIG_EXT2_FS=y
diff --git a/arch/arm/mach-feroceon-kw2/core.c b/arch/arm/mach-feroceon-kw2/core.c
index 247fc59..e3665c3 100644
--- a/arch/arm/mach-feroceon-kw2/core.c
+++ b/arch/arm/mach-feroceon-kw2/core.c
@@ -67,6 +67,11 @@
 #include "sdmmc/mvSdmmc.h"
 #include <plat/mvsdio.h>
 #endif
+
+#ifdef CONFIG_MV_INCLUDE_XOR
+#include <plat/mv_xor.h>
+#endif
+
 #if defined(CONFIG_MV_INCLUDE_CESA)
 #include "cesa/mvCesa.h"
 #endif
@@ -219,12 +224,69 @@ void print_board_info(void)
 /*******************************************************************************
  * DRAM
  ******************************************************************************/
+struct mbus_dram_target_info kw2_mbus_dram_info;
+
 const struct mbus_dram_target_info *mv_mbus_dram_info(void)
 {
-	return NULL; /* dummy */
+	return &kw2_mbus_dram_info;
 }
 EXPORT_SYMBOL_GPL(mv_mbus_dram_info);
 
+/*
+ * Setup MBUS dram target info.
+ */
+#define  DDR_WINDOW_CPU_BASE	(INTER_REGS_BASE | 0x1500)
+
+/*
+ * DDR target is the same on all Orion platforms.
+ */
+#define TARGET_DDR		0
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0000 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)	(0x0004 + ((n) << 3))
+
+/*
+ * CPU Address Decode Windows registers
+ */
+#define WIN_CTRL_OFF		0x0000
+#define WIN_BASE_OFF		0x0004
+#define WIN_REMAP_LO_OFF	0x0008
+#define WIN_REMAP_HI_OFF	0x000c
+
+static void __init kw2_setup_cpu_mbus_target(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+
+	kw2_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+
+	addr = (void __iomem *)DDR_WINDOW_CPU_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+
+			w = &kw2_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->base = base & 0xffff0000;
+			w->size = (size | 0x0000ffff) + 1;
+		}
+	}
+
+	kw2_mbus_dram_info.num_cs = cs;
+}
+
 /***********************************************
  * I2C(TWSI)
  ****************************************************************************/
@@ -335,6 +397,123 @@ static struct platform_device kw2_nfc = {
 };
 #endif
 
+/*******************************************************************************
+ * XOR
+ */
+#ifdef CONFIG_MV_INCLUDE_XOR
+static struct mv_xor_platform_shared_data kw2_xor_shared_data = {
+	.dram		= &kw2_mbus_dram_info,
+};
+
+static u64 kw2_xor_dmamask = DMA_BIT_MASK(32);
+
+/*
+ * XOR0
+ */
+static struct resource kw2_xor0_shared_resources[] = {
+	{
+		.name	= "xor 0 low",
+		.start	= XOR0_PHYS_BASE,
+		.end	= XOR0_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 0 high",
+		.start	= XOR0_HIGH_PHYS_BASE,
+		.end	= XOR0_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device kw2_xor0_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data = &kw2_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(kw2_xor0_shared_resources),
+	.resource	= kw2_xor0_shared_resources,
+};
+
+static struct resource kw2_xor00_resources[] = {
+	[0] = {
+		.start	= XOR0_IRQ_NUM,
+		.end	= XOR0_IRQ_NUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data kw2_xor00_data = {
+	.shared		= &kw2_xor0_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device kw2_xor00_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(kw2_xor00_resources),
+	.resource	= kw2_xor00_resources,
+	.dev		= {
+		.dma_mask		= &kw2_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &kw2_xor00_data,
+	},
+};
+
+static struct resource kw2_xor01_resources[] = {
+	[0] = {
+		.start	= XOR1_IRQ_NUM,
+		.end	= XOR1_IRQ_NUM,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data kw2_xor01_data = {
+	.shared		= &kw2_xor0_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device kw2_xor01_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(kw2_xor01_resources),
+	.resource	= kw2_xor01_resources,
+	.dev		= {
+		.dma_mask		= &kw2_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &kw2_xor01_data,
+	},
+};
+
+static void __init kw2_xor0_init(void)
+{
+	platform_device_register(&kw2_xor0_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_MEMCPY, kw2_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, kw2_xor00_data.cap_mask);
+	platform_device_register(&kw2_xor00_channel);
+
+	dma_cap_set(DMA_MEMCPY, kw2_xor01_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, kw2_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, kw2_xor01_data.cap_mask);
+	platform_device_register(&kw2_xor01_channel);
+}
+
+
+#endif
+
+static void __init kw2_xor_init(void)
+{
+#ifdef CONFIG_MV_INCLUDE_XOR
+	kw2_xor0_init();
+#endif
+}
+
 /*****************************************************************************
  * UART
  ****************************************************************************/
@@ -647,6 +826,11 @@ static void __init mv_init(void)
 		return;
 	}
 
+	/*
+	 * Init DRAM MBUS windows structure (needed by mainline drivers)
+	 */
+	kw2_setup_cpu_mbus_target();
+
 	/* Init Tclk & SysClk */
 	mvTclk = mvBoardTclkGet();
 	mvSysclk = mvBoardSysClkGet();
@@ -726,6 +910,10 @@ static void __init mv_init(void)
 	/* Watchdog */
 	mv_wdt_init();
 
+
+	/* XOR engines */
+	kw2_xor_init();
+
 	/* CPU idle driver */
 	boardId = mvBoardIdGet();
 	if (boardId == DB_88F6535_BP_ID || boardId == RD_88F6560_GW_ID)
diff --git a/arch/arm/mach-feroceon-kw2/include/mach/bridge-regs.h b/arch/arm/mach-feroceon-kw2/include/mach/bridge-regs.h
index 2dd0815..bbeacca 100644
--- a/arch/arm/mach-feroceon-kw2/include/mach/bridge-regs.h
+++ b/arch/arm/mach-feroceon-kw2/include/mach/bridge-regs.h
@@ -48,6 +48,11 @@
 #define RSTOUTn_MASK                   (FEROCEON_REGS_VIRT_BASE | CPU_RSTOUTN_MASK_REG)
 #define BRIDGE_CAUSE                   (FEROCEON_REGS_VIRT_BASE | CPU_AHB_MBUS_CAUSE_INT_REG)
 
+#define XOR0_PHYS_BASE			(INTER_REGS_BASE | 0x60800)
+#define XOR0_VIRT_BASE			(INTER_REGS_BASE | 0x60800)
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_BASE | 0x60A00)
+#define XOR0_HIGH_VIRT_BASE		(INTER_REGS_BASE | 0x60A00)
+
 #define WDT_RESET_OUT_EN               0x00000002
 #define WDT_INT_REQ                    0x0008
 
diff --git a/arch/arm/plat-feroceon/include/plat/mv_xor.h b/arch/arm/plat-feroceon/include/plat/mv_xor.h
new file mode 100644
index 0000000..bd5f3bd
--- /dev/null
+++ b/arch/arm/plat-feroceon/include/plat/mv_xor.h
@@ -0,0 +1,30 @@
+/*
+ * arch/arm/plat-orion/include/plat/mv_xor.h
+ *
+ * Marvell XOR platform device data definition file.
+ */
+
+#ifndef __PLAT_MV_XOR_H
+#define __PLAT_MV_XOR_H
+
+#include <linux/dmaengine.h>
+#include <linux/mbus.h>
+
+#define MV_XOR_SHARED_NAME	"mv_xor_shared"
+#define MV_XOR_NAME		"mv_xor"
+
+struct mbus_dram_target_info;
+
+struct mv_xor_platform_shared_data {
+	struct mbus_dram_target_info	*dram;
+};
+
+struct mv_xor_platform_data {
+	struct platform_device		*shared;
+	int				hw_id;
+	dma_cap_mask_t			cap_mask;
+	size_t				pool_size;
+};
+
+
+#endif
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 8100c22..ac61b61 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -115,7 +115,7 @@ config MPC512X_DMA
 
 config MV_XOR
 	bool "Marvell XOR engine support"
-	depends on PLAT_ORION || PLAT_ARMADA
+	depends on PLAT_ORION || PLAT_ARMADA || ARCH_FEROCEON
 	select DMA_ENGINE
 	select ASYNC_TX_ENABLE_CHANNEL_SWITCH
 	---help---
-- 
1.7.5.4

