From 4527309a47f1e227ed811e23d3095f7713910bdb Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Thu, 7 Nov 2013 17:33:44 +0200
Subject: [PATCH 1128/1825] fix: a38x: rampup patch2

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4a3be1d73e5c9f13dfd29367cc53e5f6eaf6fbc5

	1. Fixed TWSI read module detect.
	2. Update Modul MPP's
	3. Fixed board S@R read/write function
	4. Fixed S@R info table
	5. Fixed mvCtrlSocUnitInfoNumGet/Set functions
	6. update temperatire calculation formula and register offset
	7. Fixed DEV_BUS_SYNC_CTRL register offset according to spec
        8. Fixed S@R commands:
		1. Fixed bootsrc list table
		2. Fixed S@R default table and maximum table entry
		3. Change command from corefreq to coreclock
		4. Change command from cpufreq to cpuddrfreq
		5. Change command from boot_device to bootsrc
		6. Add Write default command
		7. Fixed coreclock =0 to 250MHz (was 166MHz)
		8. Fixed bootsrc maximum entries.
		9. Fixed read bootsrc output string
		10 Add dump command
		11. Update SatR Help command.

Change-Id: I8e4140eef0837b1fa2d11f1d29200ce83b72b3eb
Signed-off-by: Eli Nidam <elini@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4256
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |   84 +++++----
 .../armada_38x_family/boardEnv/mvBoardEnvLib.h     |    7 +-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.c       |  200 +++++++++++++-------
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |   10 +-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |  157 ++++++++++------
 .../armada_38x_family/device/mvDeviceRegs.h        |    2 +-
 6 files changed, 282 insertions(+), 178 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index fec605b..9a709c8 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -91,9 +91,9 @@
 #endif
 
 extern MV_BOARD_INFO *boardInfoTbl[];
-extern MV_BOARD_SATR_INFO boardSatrInfo[];
 MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[] = MV_BOARD_CONFIG_INFO;
 MV_BOARD_SATR_INFO boardSatrInfo[] = MV_SAR_INFO;
+MV_SATR_BOOT_TABLE satrBootSrcTable[] = MV_SATR_BOOT_SRC_TABLE_VAL;
 
 /* Locals */
 static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
@@ -811,25 +811,25 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 {
 	MV_U8 readValue;
 	MV_BOARD_CONFIG_TYPE_INFO configInfo;
-	MV_U32 boardId = mvBoardIdGet();
 	int i;
 
 	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION);
-
 	/*Read all TWSI board module if exsist : */
 	/* Save values Locally in configVal[] */
 	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
 		if (mvBoardConfigTypeGet(i, &configInfo) == MV_TRUE) {
-			if (mvBoardTwsiGet(configInfo.twsiAddr, configInfo.offset, 0, &readValue) != MV_OK) {
-				mvOsPrintf("%s: Error: Read from TWSI failed addr=0x%x\n",
-					   __func__, configInfo.twsiAddr);
-				return;
+			if (mvBoardTwsiGet(BOARD_TWSI_MODULE_DETECT, configInfo.twsiAddr,
+					   configInfo.offset, &readValue) != MV_OK) {
+				DB(mvOsPrintf("%s: Error: Read from TWSI failed addr=0x%x\n",
+					   __func__, configInfo.twsiAddr));
+				continue;
 			}
-			if ((configInfo.twsiId == readValue) &&
-				(configInfo.isActiveForBoard[boardId]))
+			/* twsi ID represente  module configuration ID*/
+			if (configInfo.twsiId == readValue)
 				boardOptionsConfig[configInfo.configId] = 1;
 		}
 	}
+
 	/* Update MPP group types and values according to board configuration */
 	mvBoardMppIdUpdate();
 	mvBoardEthComplexInfoUpdate();
@@ -912,27 +912,26 @@ MV_VOID mvBoardMppIdUpdate(MV_VOID)
 	struct _mvBoardMppModule i2sModule = MPP_I2S_MODULE;
 	struct _mvBoardMppModule spdifModule = MPP_SPDIF_MODULE;
 
-	if (mvBoardIsModuleConnected(MV_CONFIG_MII)) {
+	if (mvBoardIsModuleConnected(MV_CONFIG_MII))
 		mvModuleMppUpdate(3, miiModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_NOR)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_NOR))
 		mvModuleMppUpdate(6, norModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_NAND)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_NAND))
 		mvModuleMppUpdate(6, nandModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_SDIO)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_SDIO))
 		mvModuleMppUpdate(4, sdioModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_SLIC_TDM_DEVICE)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_SLIC_TDM_DEVICE))
 		mvModuleMppUpdate(2, tdmModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_I2S_DEVICE)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_I2S_DEVICE))
 		mvModuleMppUpdate(1, &i2sModule);
-	}
-	if (mvBoardIsModuleConnected(MV_CONFIG_SPDIF_DEVICE)) {
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_SPDIF_DEVICE))
 		mvModuleMppUpdate(1, &spdifModule);
-	}
 }
 
 /*******************************************************************************
@@ -1011,7 +1010,6 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 {
 	MV_U32 satrBootDeviceValue;
-	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
 	MV_SATR_BOOT_TABLE satrBootEntry;
 
 	satrBootDeviceValue = mvBoardSatRRead(MV_SATR_BOOT_DEVICE);
@@ -1021,7 +1019,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 		return MSAR_0_BOOT_SPI_FLASH; /* SPI is the Default Boot source */
 	}
 
-	satrBootEntry = satrTable[satrBootDeviceValue];
+	satrBootEntry = satrBootSrcTable[satrBootDeviceValue];
 
 	if (satrBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
 		return satrBootEntry.bootSrc;
@@ -1049,8 +1047,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 *******************************************************************************/
 MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum)
 {
-	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
-	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
+	MV_SATR_BOOT_TABLE satrBootEntry = satrBootSrcTable[satrBootDeviceValue];
 
 	switch (attrNum) {
 	case 1:
@@ -1792,10 +1789,10 @@ MV_STATUS mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regN
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
-	DB(mvOsPrintf("Board: TWSI Read device\n"));
 	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(twsiClass, devNum);
 	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(twsiClass, devNum);
 	twsiSlave.moreThen256 = mvBoardTwsiIsMore256Get(twsiClass, devNum);
+	DB(mvOsPrintf("Board: TWSI Read device addr=0x%x\n", twsiSlave.slaveAddr.address));
 
 	twsiSlave.validOffset = MV_TRUE;
 	/* Use offset as command */
@@ -2151,12 +2148,13 @@ MV_STATUS mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
 	MV_TWSI_ADDR slave;
 
 	/* Read MPP module ID */
-	DB(mvOsPrintf("Board: Read S@R device read\n"));
 	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
 	if (0xFF == twsiSlave.slaveAddr.address)
 		return MV_ERROR;
 	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
 	twsiSlave.moreThen256 = mvBoardTwsiIsMore256Get(BOARD_DEV_TWSI_SATR, devNum);
+	DB(mvOsPrintf("Board: Read S@R device read ADDR=0x%X, regnum=%d\n",	\
+		      twsiSlave.slaveAddr.address, regNum));
 
 	/* Use offset as command */
 	twsiSlave.offset = regNum;
@@ -2172,7 +2170,7 @@ MV_STATUS mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
 		DB(mvOsPrintf("Board: Read S@R fail\n"));
 		return MV_ERROR;
 	}
-	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+	DB(mvOsPrintf("Board: Read S@R succeded 0x%X\n", *pData));
 
 	return MV_OK;
 }
@@ -2206,8 +2204,8 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 		return MV_ERROR;
 	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
 	twsiSlave.validOffset = MV_TRUE;
-	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
-		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	DB(mvOsPrintf("Board: Write S@R device addr %x, regNum %x, data 0x%X\n",
+		      twsiSlave.slaveAddr.address, regNum, regVal));
 	/* Use offset as command */
 	twsiSlave.offset = regNum;
 	twsiSlave.moreThen256 = mvBoardTwsiIsMore256Get(BOARD_DEV_TWSI_SATR, devNum);
@@ -2220,7 +2218,7 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 		DB(mvOsPrintf("Board: Write S@R fail\n"));
 		return MV_ERROR;
 	}
-	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+	DB(mvOsPrintf("Board: Write S@R succeded addr=0x%X data=0x%X\n", twsiSlave.slaveAddr.address, regVal));
 
 	return MV_OK;
 }
@@ -2242,7 +2240,8 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 MV_U32 mvBoardSatRRead(MV_SATR_TYPE_ID satrField)
 {
 	MV_BOARD_SATR_INFO satrInfo;
-	MV_U8 data;
+	MV_U8 data, data1;
+	MV_U32 c;
 
 	if (satrField >= MV_SATR_MAX_OPTION) {
 		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ , satrField);
@@ -2261,9 +2260,12 @@ MV_U32 mvBoardSatRRead(MV_SATR_TYPE_ID satrField)
 	}
 	data &= satrInfo.mask;
 	data = (data >> satrInfo.bitOffset);
+
 	if (satrInfo.status & BOARD_SATR_SWAP_BIT) {
-		MV_U32 c = mvCountMaskBits(satrInfo.mask);
-		data = mvReverseBits(data) >> (8-c) ;
+		c = mvCountMaskBits(satrInfo.mask);
+		data1 = mvReverseBits(data);
+		data =  (data1 >> (8-c));
+		DB(mvOsPrintf("%s: value after mvReverseBits = 0x%X\n", __func__, data));
 	}
 
 	if (satrField == MV_SATR_BOOT_DEVICE) {
@@ -2297,7 +2299,8 @@ MV_U32 mvBoardSatRRead(MV_SATR_TYPE_ID satrField)
 MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val)
 {
 	MV_BOARD_SATR_INFO satrInfo;
-	MV_U8 data, val1;
+	MV_U8 data, val1, data1;
+	MV_U32 c;
 
 	if (satrWriteField >= MV_SATR_MAX_OPTION) {
 		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ , satrWriteField);
@@ -2328,11 +2331,12 @@ MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val)
 	}
 
 	if (satrInfo.status & BOARD_SATR_SWAP_BIT) {
-		MV_U32 c = mvCountMaskBits(satrInfo.mask);
-		val = mvReverseBits(val) >> (8 - c) ;
+		c = mvCountMaskBits(satrInfo.mask);
+		data1 = mvReverseBits(val);
+		val =  (data1 >> (8-c));
+		DB(mvOsPrintf("%s: value after mvReverseBits = 0x%X\n", __func__, val));
 	}
 
-
 	/* modify */
 	data &= ~(satrInfo.mask);             /* clean old value */
 	data |= (val <<  satrInfo.bitOffset);    /* save new value */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
index e37a9f9..97d6dc0 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
@@ -485,6 +485,7 @@ MV_U8 mvBoardCpuFreqGet(MV_VOID);
 MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
 MV_STATUS mvBoardIsInternalSwitchConnected(void);
 MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx);
+MV_U32 mvBoardFreqModesNumGet(void);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
 MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
 MV_VOID mvBoardMacSpeedSet(MV_U32 ethPortNum, MV_BOARD_MAC_SPEED macSpeed);
@@ -516,9 +517,9 @@ MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val);
 /*    SATR-ID                   Mask  offset  devID  num  active	*/
 #define MV_SAR_INFO { \
 { MV_SATR_CPU_DDR_L2_FREQ,	0x1F,	0,	1,	0,	{1, 1, 0}, BOARD_SATR_SWAP_BIT},\
-{ MV_SATR_CORE_CLK_SELECT,	0x08,	3,	3,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_CORE_CLK_SELECT,	0x04,	2,	3,	0,	{0, 1, 0}, 0},\
 { MV_SATR_CPU1_ENABLE,		0x01,	0,	2,	0,	{0, 1, 0}, 0},\
-{ MV_SATR_SSCG_DISABLE,		0x10,	4,	2,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_SSCG_DISABLE,		0x08,	3,	3,	0,	{0, 1, 0}, 0},\
 { MV_SATR_DDR4_SELECT,		0x20,	5,	4,	1,	{0, 1, 0}, BOARD_SATR_READ_ONLY},\
 { MV_SATR_DDR_BUS_WIDTH,	0x02,	1,	4,	0,	{0, 1, 0}, BOARD_SATR_READ_ONLY},\
 { MV_SATR_DDR_ECC_ENABLE,	0x04,	2,	4,	0,	{0, 1, 0}, 0},\
@@ -528,7 +529,7 @@ MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val);
 { MV_SATR_RD_LANE0_CFG,		0x4,	2,	1,	1,	{1, 0, 0}, 0},\
 { MV_SATR_RD_APPS_CFG,		0x8,	3,	1,	1,	{1, 0, 0}, 0},\
 { MV_SATR_BOOT_DEVICE,		0x3,	0,	3,	0,	{0, 1, 0}, BOARD_SATR_SWAP_BIT},\
-{ MV_SATR_BOOT2_DEVICE,		0x1E,	1,	4,	0,	{0, 1, 0}, BOARD_SATR_SWAP_BIT},\
+{ MV_SATR_BOOT2_DEVICE,		0x1E,	1,	2,	0,	{0, 1, 0}, BOARD_SATR_SWAP_BIT},\
 { MV_SATR_BOARD_ID,		0x7,	0,	0,	0,	{1, 1, 0}, BOARD_SATR_READ_ONLY},\
 { MV_SATR_BOARD_ECO_VERSION,	0xff,	0,	0,	1,	{1, 1, 0}, BOARD_SATR_READ_ONLY},\
 { MV_SATR_MAX_OPTION,		0x0,	0,	0,	0,	{0, 0, 0}, 0},\
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
index 394e930..f650cc9 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
@@ -116,6 +116,32 @@ static const MV_U8 serdesCfg[MV_SERDES_MAX_LANES][8] = SERDES_CFG;
  */
 #define MV_INVALID_CTRL_REV     0xff
 
+#define MV_6820_INDEX		0
+#define MV_6810_INDEX		1
+#define MV_68xx_INDEX_MAX	2
+
+MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_68xx_INDEX_MAX] = {
+/*                          6820 */
+/* DRAM_UNIT_ID         */ { 1, 1},
+/* PEX_UNIT_ID          */ { MV_PEX_MAX_UNIT,		MV_PEX_MAX_UNIT_6810},
+/* ETH_GIG_UNIT_ID      */ { MV_ETH_MAX_PORTS,	MV_ETH_MAX_PORTS_6810},
+/* USB_UNIT_ID          */ { MV_USB_MAX_PORTS,		MV_USB3_MAX_PORTS_6810},
+/* USB3_UNIT_ID         */ { MV_USB3_MAX_PORTS,		MV_USB3_MAX_PORTS_6810},
+/* IDMA_UNIT_ID         */ { MV_IDMA_MAX_CHAN,		MV_IDMA_MAX_CHAN},
+/* XOR_UNIT_ID          */ { MV_XOR_MAX_UNIT,		MV_XOR_MAX_UNIT},
+/* SATA_UNIT_ID         */ { MV_SATA_MAX_CHAN,		MV_SATA_MAX_CHAN},
+/* TDM_32CH_UNIT_ID     */ { 1,				1},
+/* UART_UNIT_ID         */ { MV_UART_MAX_CHAN,		MV_UART_MAX_CHAN},
+/* CESA_UNIT_ID         */ { 1,				1},
+/* SPI_UNIT_ID          */ { 1,				1},
+/* AUDIO_UNIT_ID        */ { 1,				1},
+/* SDIO_UNIT_ID         */ { 1,				1},
+/* TS_UNIT_ID           */ { 0,				0},
+/* XPON_UNIT_ID         */ { 0,				0},
+/* BM_UNIT_ID           */ { 0,				0},
+/* PNC_UNIT_ID          */ { 0,				0},
+/* I2C_UNIT_ID          */ { 2,				2},
+};
 /*******************************************************************************
 * mvCtrlGetCpuNum
 *
@@ -147,20 +173,92 @@ MV_STATUS mvCtrlUpdatePexId(MV_VOID)
 
 #endif
 
-#define MV_6820_INDEX		0
-#define MV_6810_INDEX		1
-#define MV_68xx_INDEX_MAX	2
+/*******************************************************************************
+* mvCtrlDevIdIndexGet
+*
+* DESCRIPTION: return SOC device index
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*        return SOC device index
+*
+*******************************************************************************/
+MV_U32 mvCtrlDevIdIndexGet(void)
+{
+	if (MV_6810_DEV_ID ==  mvCtrlModelGet())
+		return MV_6810_INDEX;
+	return MV_6820_INDEX;
+}
 
-static MV_U32 mvCtrlDevIdIndexGet(void)
+/*******************************************************************************
+* mvCtrlSocUnitInfoNumGet
+*
+* DESCRIPTION: return the max interface detected for special unit
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
 {
-	switch (mvCtrlModelGet()) {
-	case MV_6820_DEV_ID: return MV_6820_INDEX;
-	case MV_6810_DEV_ID: return MV_6810_INDEX;
+	MV_U32 devIdIndex;
+
+	if (unit >= MAX_UNITS_ID) {
+		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
+		return 0;
 	}
-	return MV_6820_INDEX;
+
+	devIdIndex = mvCtrlDevIdIndexGet();
+	return mvCtrlSocUnitNums[unit][devIdIndex];
 }
+/*******************************************************************************
+* mvCtrlSocUnitInfoNumSet
+*
+* DESCRIPTION: Set the max interface detected for special unit
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U32 mvCtrlSocUnitInfoNumSet(MV_UNIT_ID unit, MV_U32 maxValue)
+{
+	MV_U32 devIdIndex;
+
+	if (unit >= MAX_UNITS_ID) {
+		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
+		return 0;
+	}
 
-static MV_VOID mvCtrlSerdesConfig(MV_VOID)
+	devIdIndex = mvCtrlDevIdIndexGet();
+	return mvCtrlSocUnitNums[unit][devIdIndex] = maxValue;
+}
+
+/*******************************************************************************
+* mvCtrlSerdesConfig
+*
+* DESCRIPTION: auto detect serdes configuration and Set the max interface detected for
+*		SERDES units
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 {
 	MV_U32 pexIf, commPhyConfigReg, comPhyCfg, serdesNum, serdesCongigField, maxSerdesLane;
 	MV_U32 ethIfCount = 0;
@@ -170,22 +268,18 @@ static MV_VOID mvCtrlSerdesConfig(MV_VOID)
 
 	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
 
-	switch (mvCtrlModelGet()) {
-	case MV_6810_DEV_ID:
+	maxSerdesLane = MV_SERDES_MAX_LANES;
+	if (MV_6810_DEV_ID == mvCtrlModelGet())
 		maxSerdesLane = MV_SERDES_MAX_LANES_6810;
-		break;
-	default:
-	case MV_6820_DEV_ID:
-		maxSerdesLane = MV_SERDES_MAX_LANES;
-	}
 
 	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
 	commPhyConfigReg = MV_REG_READ(COMM_PHY_SELECTOR_REG);
+	DB(printf("mvCtrlSerdesConfig: commPhyConfigReg=0x%x\n", commPhyConfigReg));
 	for (serdesNum = 0; serdesNum < maxSerdesLane; serdesNum++) {
 		serdesCongigField = (commPhyConfigReg & COMPHY_SELECT_MASK(serdesNum)) >> COMPHY_SELECT_OFFS(serdesNum);
 		comPhyCfg = serdesCfg[serdesNum][serdesCongigField];
-		DB(printf("%s:   serdesCongigField = 0x%x, comPhyCfg = 0x%x\n",
-			  serdesCongigField, comPhyCfg));
+		DB(printf("serdesCongigField=0x%x, comPhyCfg=0x%2x SERDES %d detect as ",	\
+			  serdesCongigField, comPhyCfg, serdesNum));
 		switch (comPhyCfg & 0xF0) {
 		case SERDES_UNIT_PEX:
 			pexIf = comPhyCfg & 0x0f;
@@ -195,19 +289,26 @@ static MV_VOID mvCtrlSerdesConfig(MV_VOID)
 				boardPexInfo->pexUnitCfg[pexIf] = PEX_BUS_MODE_X1;
 			boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = pexIf;
 			boardPexInfo->boardPexIfNum++;
+			DB(printf("PEX, if=%d\n", pexIf));
 			break;
 		case SERDES_UNIT_SATA:
+			DB(printf("SATA, if=%d\n", (comPhyCfg & 0x0f)));
 			sataIfCount++;
 			break;
 		case SERDES_UNIT_GBE:
+			DB(printf("SGMII, if=%d\n", (comPhyCfg & 0x0f)));
 			ethIfCount++;
 			break;
 		case SERDES_UNIT_USB_H:
+		DB(printf("USB_H, if=%d\n", (comPhyCfg & 0x0f)));
 			usbHIfCount++;
 			break;
 		case SERDES_UNIT_USB:
+			DB(printf("USB, if=%d\n", (comPhyCfg & 0x0f)));
 			usbIfCount++;
 			break;
+		case SERDES_UNIT_NA:
+			DB(printf("Not connected! ***\n"));
 		}
 	}
 	mvCtrlSocUnitInfoNumSet(PEX_UNIT_ID, boardPexInfo->boardPexIfNum);
@@ -218,55 +319,11 @@ static MV_VOID mvCtrlSerdesConfig(MV_VOID)
 		mvCtrlSocUnitInfoNumSet(ETH_GIG_UNIT_ID, ethIfCount);
 	else
 		mvCtrlSocUnitInfoNumSet(ETH_GIG_UNIT_ID, MV_ETH_MAX_ON_BOARD_PORTS);
-}
-
-
-MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_68xx_INDEX_MAX] = {
-/*                          6820 */
-/* DRAM_UNIT_ID         */ { 1, 1},
-/* PEX_UNIT_ID          */ { MV_PEX_MAX_UNIT,		MV_PEX_MAX_UNIT_6810},
-/* ETH_GIG_UNIT_ID      */ { MV_ETH_MAX_PORTS,	MV_ETH_MAX_PORTS_6810},
-/* USB_UNIT_ID          */ { MV_USB_MAX_PORTS,		MV_USB3_MAX_PORTS_6810},
-/* USB3_UNIT_ID         */ { MV_USB3_MAX_PORTS,		MV_USB3_MAX_PORTS_6810},
-/* IDMA_UNIT_ID         */ { MV_IDMA_MAX_CHAN,		MV_IDMA_MAX_CHAN},
-/* XOR_UNIT_ID          */ { MV_XOR_MAX_UNIT,		MV_XOR_MAX_UNIT},
-/* SATA_UNIT_ID         */ { MV_SATA_MAX_CHAN,		MV_SATA_MAX_CHAN},
-/* TDM_32CH_UNIT_ID     */ { 1,				1},
-/* UART_UNIT_ID         */ { MV_UART_MAX_CHAN,		MV_UART_MAX_CHAN},
-/* CESA_UNIT_ID         */ { 1,				1},
-/* SPI_UNIT_ID          */ { 1,				1},
-/* AUDIO_UNIT_ID        */ { 1,				1},
-/* SDIO_UNIT_ID         */ { 1,				1},
-/* TS_UNIT_ID           */ { 0,				0},
-/* XPON_UNIT_ID         */ { 0,				0},
-/* BM_UNIT_ID           */ { 0,				0},
-/* PNC_UNIT_ID          */ { 0,				0},
-/* I2C_UNIT_ID          */ { 2,				2},
-};
-
-MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
-{
-	MV_U32 devIdIndex;
-
-	if (unit >= MAX_UNITS_ID) {
-		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
-		return 0;
-	}
-
-	devIdIndex = mvCtrlDevIdIndexGet();
-	return mvCtrlSocUnitNums[unit][devIdIndex];
-}
-MV_U32 mvCtrlSocUnitInfoNumSet(MV_UNIT_ID unit, MV_U32 maxValue)
-{
-	MV_U32 devIdIndex;
-
-	if (unit >= MAX_UNITS_ID) {
-		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
-		return 0;
-	}
-
-	devIdIndex = mvCtrlDevIdIndexGet();
-	return mvCtrlSocUnitNums[unit][devIdIndex] = maxValue;
+	DB(printf("mvCtrlSocUnitGet[PEX] = %d,\n", mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)));
+	DB(printf("mvCtrlSocUnitGet[ETH] = %d,\n", mvCtrlSocUnitInfoNumGet(ETH_GIG_UNIT_ID)));
+	DB(printf("mvCtrlSocUnitGet[SATA]= %d,\n", mvCtrlSocUnitInfoNumGet(SATA_UNIT_ID)));
+	DB(printf("mvCtrlSocUnitGet[USBH]= %d,\n", mvCtrlSocUnitInfoNumGet(USB_UNIT_ID)));
+	DB(printf("mvCtrlSocUnitGet[USB3]= %d,\n", mvCtrlSocUnitInfoNumGet(USB3_UNIT_ID)));
 }
 
 /*******************************************************************************
@@ -300,7 +357,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 		mvBoardInfoUpdate();
 	}
 
-	mvCtrlSerdesConfig();
+	mvCtrlSerdesConfigDetect();
 
 	/* write MPP's config and Board general config */
 	mvBoardConfigWrite();
@@ -356,7 +413,7 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 * OUTPUT: None,
 *
 * RETURN:
-*       MV_STATUS to indicate a successful read.
+*	MV_STATUS to indicate a successful read.
 *
 *******************************************************************************/
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
@@ -1539,7 +1596,7 @@ MV_BOOL mvCtrlDDRECC(MV_VOID)
 MV_U32 mvCtrlGetJuncTemp(MV_VOID)
 {
 	/*Used Hard Coded values, TODO sync with Spec*/
-	MV_32 reg = 0;
+	MV_32 reg = 0, temp;
 
 	/* init the TSEN sensor once */
 	if ((MV_REG_READ(TSEN_STATE_REG) & TSEN_STATE_MASK) == 0) {
@@ -1556,8 +1613,9 @@ MV_U32 mvCtrlGetJuncTemp(MV_VOID)
 
 	reg = MV_REG_READ(TSEN_STATUS_REG);
 	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+	temp = (((((10000 * reg) / 21445) * 1000) - 272674) / 1000);
 
-	return (3171900 - (10000 * reg)) / 13553;
+	return temp;
 }
 /*******************************************************************************
 * mvCtrlNandClkSet
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
index f804eae..0a82065 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -189,14 +189,14 @@ typedef enum {
 
 
 /* Termal Sensor Registers */
-#define TSEN_STATE_REG							0xE8070
-#define TSEN_STATE_OFFSET						31
-#define TSEN_STATE_MASK							(0x1 << TSEN_STATE_OFFSET)
+#define TSEN_STATE_REG						0xE4070
+#define TSEN_STATE_OFFSET					31
+#define TSEN_STATE_MASK						(0x1 << TSEN_STATE_OFFSET)
 
-#define TSEN_CONF_REG							0xE8074
+#define TSEN_CONF_REG						0xE4074
 #define TSEN_CONF_OTF_CALIB_MASK				(0x1 << 8)
 
-#define TSEN_STATUS_REG							0xE8078
+#define TSEN_STATUS_REG						0xE4078
 #define TSEN_STATUS_TEMP_OUT_OFFSET				0
 #define TSEN_STATUS_TEMP_OUT_MASK				(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
index d2c94fd..1111f77 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -218,67 +218,107 @@ typedef struct _mvSATRBootTable {
 	MV_U32 attr1;                           /* Device width/Port */
 	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
 	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
+	char name[80];
 } MV_SATR_BOOT_TABLE;
 
-#define MV_SATR_TABLE_VAL { \
-/*00*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*01*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 1 }, \
-/*02*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*03*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 1 }, \
-/*04*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*05*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1 }, \
-/*06*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*07*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1 }, \
-/*08*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 3 }, \
-/*09*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 4 }, \
-/*0A*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT }, \
-/*0B*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT }, \
-/*0C*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT}, \
-/*0D*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT}, \
-/*0E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT }, \
-/*0F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT }, \
-/*10*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT}, \
-/*11*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT}, \
-/*12*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT }, \
-/*13*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT }, \
-/*14*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT}, \
-/*15*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT}, \
+#define BOOT_SRC_TABLE_SIZE 0x3A
+#define MV_SATR_BOOT_SRC_TABLE_VAL { \
+/*00*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,  0, 0, "00  |    NOR 8 bit "}, \
+/*01*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,  0, 1, "01  |    NOR 8 bit "}, \
+/*02*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,  0, 0, "02  |    NOR 8 bit "}, \
+/*03*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,  0, 1, "03  |    NOR 8 bit "}, \
+/*04*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0, "04  |    NOR 16 bit"}, \
+/*05*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1, "05  |    NOR 16 bit"}, \
+/*06*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0, "06  |    NOR 16 bit"}, \
+/*07*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1, "07  |    NOR 16 bit"}, \
+/*08*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 3, \
+		"08  |    NAND 8 bit |Page size 512B "}, \
+/*09*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 4, \
+		"09  |    NAND 8 bit |Page size 512B "}, \
+/*0A*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT , \
+		"0A  |    NAND 8 bit |Page size 2KB, ECC 4BIT "}, \
+/*0B*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT , \
+		"0B  |    NAND 8 bit |Page size 2KB  ECC 8BIT "}, \
+/*0C*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT, \
+		"0C  |    NAND 8 bit |Page size 2KB  ECC 4BIT "}, \
+/*0D*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT, \
+		"0D  |    NAND 8 bit |Page size 2KB  ECC 8BIT "}, \
+/*0E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT , \
+		"0E  |    NAND 8 bit |Page size 4KB  ECC 4BIT "}, \
+/*0F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT , \
+		"0F  |    NAND 8 bit |Page size 4KB  ECC 8BIT "}, \
+/*10*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT, \
+		"10  |    NAND 8 bit |Page size 4KB  ECC 12BIT"}, \
+/*11*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT, \
+		"11  |    NAND 8 bit |Page size 4KB  ECC 16BIT"}, \
+/*12*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT , \
+		"12  |    NAND 8 bit |Page size 8KB  ECC 4BIT "}, \
+/*13*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT , \
+		"13  |    NAND 8 bit |Page size 8KB  ECC 8BIT "}, \
+/*14*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT, \
+		"14  |    NAND 8 bit |Page size 8KB  ECC 12BIT"}, \
+/*15*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT, \
+		"15  |    NAND 8 bit |Page size 8KB  ECC 16BIT"}, \
 /*16*/ { -1, -1, -1, -1},	\
 /*17*/ { -1, -1, -1, -1}, \
-/*18*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 3}, \
-/*19*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 4}, \
-/*1A*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT }, \
-/*1B*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT }, \
-/*1C*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT}, \
-/*1D*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT}, \
-/*1E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT }, \
-/*1F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT }, \
-/*20*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT},\
-/*21*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT},\
-/*22*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },\
-/*23*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },\
-/*24*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT},\
-/*25*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT},\
+/*18*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 3		       , \
+		"18  |    NAND 16    |Page size 512B          "}, \
+/*19*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 4		       , \
+		"19  |    NAND 16    |Page size 512B          "}, \
+/*1A*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT , \
+		"1A  |    NAND 16    |Page size 2KB  ECC 4BIT "}, \
+/*1B*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT , \
+		"1B  |    NAND 16    |Page size 2KB  ECC 8BIT "}, \
+/*1C*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT, \
+		"1C  |    NAND 16    |Page size 2KB  ECC 12BIT"}, \
+/*1D*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT, \
+		"1D  |    NAND 16    |Page size 2KB  ECC 16BIT"}, \
+/*1E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT , \
+		"1E  |    NAND 16    |Page size 4KB  ECC 4BIT "}, \
+/*1F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT , \
+		"1F  |    NAND 16    |Page size 4KB  ECC 8BIT "}, \
+/*20*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT, \
+		"20  |    NAND 16    |Page size 4KB  ECC 12BIT"},\
+/*21*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT, \
+		"21  |    NAND 16    |Page size 4KB  ECC 16BIT"},\
+/*22*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT , \
+		"22  |    NAND 16    |Page size 8KB  ECC 4BIT "},\
+/*23*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT , \
+		"23  |    NAND 16    |Page size 8KB  ECC 8BIT "},\
+/*24*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT, \
+		"24  |    NAND 16    |Page size 8KB  ECC 12BIT"},\
+/*25*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT, \
+		"25  |    NAND 16    |Page size 8KB  ECC 16BIT"},\
 /*26*/ { -1, -1, -1, -1}, \
 /*27*/ { -1, -1, -1, -1}, \
-/*28*/ { MSAR_0_BOOT_UART,		0,		 0,		1 }, /* port, mpp, mpp */ \
-/*29*/ { MSAR_0_BOOT_UART,		1,		56,		55}, /* port, mpp, mpp */  \
-/*2A*/ { MSAR_0_BOOT_SATA,		0,		 0,		-1}, /* port, lane */  \
-/*2B*/ { MSAR_0_BOOT_SATA,		0,		 1,		-1}, /* port, lane */ \
-/*2C*/ { MSAR_0_BOOT_PEX,		0,		 0,		-1}, /* port, lane */ \
-/*2D*/ { MSAR_0_BOOT_PEX,		0,		 1,		-1}, /* port, lane */ \
-/*2E*/ { MSAR_0_BOOT_I2C,		0,		 3,		 2}, /* port, mpp, mpp */ \
+/*28*/ { MSAR_0_BOOT_UART, 0,  0,  1, "28  |    UART   Port0"}, /* port, mpp, mpp */ \
+/*29*/ { MSAR_0_BOOT_UART, 1, 56, 55, "29  |    UART   Port1"}, /* port, mpp, mpp */  \
+/*2A*/ { MSAR_0_BOOT_SATA, 0,  0, -1, "2A  |    SATA   Lan0 "}, /* port, lane */  \
+/*2B*/ { MSAR_0_BOOT_SATA, 0,  1, -1, "2B  |    SATA   Lan1 "}, /* port, lane */ \
+/*2C*/ { MSAR_0_BOOT_PEX,  0,  0, -1, "2C  |    PEX0   Lan0 "}, /* port, lane */ \
+/*2D*/ { MSAR_0_BOOT_PEX,  0,  1, -1, "2D  |    PEX0   Lan1 "}, /* port, lane */ \
+/*2E*/ { MSAR_0_BOOT_I2C,  0,  3,  2, "2E  |    I2C         "}, /* port, mpp, mpp */ \
 /*2F*/ { -1, -1, -1, -1}, \
-/*30*/ { MSAR_0_BOOT_SDIO,		0,		59,		54}, /* port, mpp, mpp */ \
-/*31*/ { MSAR_0_BOOT_SDIO,		0,		40,		37}, /* port, mpp, mpp */ \
-/*32*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
-/*33*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25}, \
-/*34*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 59}, \
-/*35*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 59}, \
-/*36*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
-/*37*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25}, \
-/*38*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
-/*39*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25} \
+/*30*/ { MSAR_0_BOOT_SDIO,		0,		59,		54		, \
+		"30  |    SDIO   Port0"}, /* port, mpp, mpp */ \
+/*31*/ { MSAR_0_BOOT_SDIO,		0,		40,		37		, \
+		"31  |    SDIO   Port0"}, /* port, mpp, mpp */ \
+/*32*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
+		"32  |    SPI 24 bit address"}, \
+/*33*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
+		"33  |    SPI 32 bit address"}, \
+/*34*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 59, \
+		"34  |    SPI 24 bit address"}, \
+/*35*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 59, \
+		"35  |    SPI 32 bit address"}, \
+/*36*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
+		"36  |    SPI 24 bit address"}, \
+/*37*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
+		"37  |    SPI 32 bit address"}, \
+/*38*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25, \
+		"38  |    SPI 24 bit address"}, \
+/*39*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25, \
+		"39  |    SPI 32 bit address"} \
 }
 
 typedef struct {
@@ -286,16 +326,17 @@ typedef struct {
 	MV_U32 cpuFreq;
 	MV_U32 ddrFreq;
 	MV_U32 l2Freq;
+	MV_BOOL	isDisplay;
 } MV_FREQ_MODE;
 
 /* End of Table indicator - Should be in the last line of the SAR Table */
 #define MV_SAR_FREQ_MODES_EOT		0xFF
 
 #define MV_SAR_FREQ_MODES { \
-		{ 0x4,   1066, 533, 266 }, \
-		{ 0x8,   1332, 666, 333 }, \
-		{ 0xC,   1600, 800, 400 }, \
-		{ MV_SAR_FREQ_MODES_EOT,  0,    0,   0   } \
+		{ 0x4,   1066, 533, 266, MV_TRUE  }, \
+		{ 0x8,   1332, 666, 333, MV_TRUE  }, \
+		{ 0xC,   1600, 800, 400, MV_TRUE  }, \
+		{ MV_SAR_FREQ_MODES_EOT,  0,    0,   0, MV_FALSE } \
 };
 
 /* These macros help units to identify a target Mport Arbiter group */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h b/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h
index fb01c9b..e9fa520 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h
@@ -96,7 +96,7 @@ static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
 }
 
 #define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
-#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x070)
 #define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
 /* Select Ready Polarity bit for CS in DEV_BUS_SYNC_CTRL */
 #define SYNC_CTRL_READY_POL(cs)		(cs == DEV_BOOCS ? 0x20 : \
-- 
1.7.5.4

