From 17601562facf6bab53c8532c9fd0afe8b45a31f6 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 7 Apr 2013 17:33:50 +0300
Subject: [PATCH 0551/1825] ALP: Initial clean of core.c

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e28b3f8dc4cddf322e45b6d0d42f5f4d75aa1ef0

The changes: uncrustified the file, removed unneeded features (AXP L2, 7SEG)
and moved mv_cpu_count to platsmp.c file.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I3efe148bb713c7c22fa0a3ec0d7a0fdc5677db40
Reviewed-on: http://vgitil04.il.marvell.com:8080/1498
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armadaxp/platsmp.c |   18 ++-
 arch/arm/mach-avantalp/core.c    |  395 ++++++++++++++++----------------------
 2 files changed, 180 insertions(+), 233 deletions(-)
 mode change 100755 => 100644 arch/arm/mach-avantalp/core.c

diff --git a/arch/arm/mach-armadaxp/platsmp.c b/arch/arm/mach-armadaxp/platsmp.c
index 41a40a4..5f62495 100644
--- a/arch/arm/mach-armadaxp/platsmp.c
+++ b/arch/arm/mach-armadaxp/platsmp.c
@@ -26,12 +26,28 @@ extern void axp_secondary_startup(void);
 extern void axp_ipi_init(void);
 extern void second_cpu_msi_init(void);
 extern MV_CPU_DEC_WIN *mv_sys_map(void);
-extern unsigned long mv_cpu_count;
 extern void armadaxp_fabric_restore_deepIdle(void);
 
 unsigned int master_cpu_id  = 0;
 unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
 
+unsigned long mv_cpu_count = NR_CPUS;
+static int __init mv_cpu_count_setup(char *s)
+{
+	int fail;
+	unsigned int cpu_count;
+
+	while (isspace(*s))
+		s++;
+
+	fail = strict_strtoul(s, 10, &cpu_count);
+	if (fail == 0)
+		set_core_count(cpu_count);
+
+	return 1;
+}
+__setup("mv_cpu_count=", mv_cpu_count_setup);
+
 /*
  * We use IRQ1 as the IPI
  */
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
old mode 100755
new mode 100644
index 422791b..fda9114
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -13,6 +13,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/ctype.h>
@@ -46,7 +47,6 @@
 #include <linux/ata_platform.h>
 #include <linux/ethtool.h>
 #include <asm/serial.h>
-#include <plat/cache-aurora-l2.h>
 
 #include <mach/serial.h>
 
@@ -91,8 +91,8 @@
 #include <asm/hardware/gic.h>
 #include "ca9x2.h"
 
-#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
-#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+#define MV_COHERENCY_FABRIC_CTRL_REG            (MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG             (MV_COHERENCY_FABRIC_OFFSET + 0x4)
 
 extern unsigned int irq_int_type[];
 extern void __init alp_map_io(void);
@@ -120,39 +120,28 @@ MV_U32 mvSysclk = 200000000;
 
 #ifdef CONFIG_MV_INCLUDE_GIG_ETH
 MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
-MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = {0};
+MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = { 0 };
 #endif
 
 /*
  * Helpers to get DDR bank info
  */
-#define DDR_BASE_CS_OFF(n)	(0x0180 + ((n) << 3))
-#define DDR_SIZE_CS_OFF(n)	(0x0184 + ((n) << 3))
-#define TARGET_DDR		0
-#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC	0x1
+#define DDR_BASE_CS_OFF(n)      (0x0180 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)      (0x0184 + ((n) << 3))
+#define TARGET_DDR              0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC     0x1
 
 struct mbus_dram_target_info avantalp_mbus_dram_info;
 
-/* XOR0 is disabled in Z1 Silicone */
-#ifdef CONFIG_ARMADA_XP_REV_Z1
- /* XOR0 is disabled in Z1 Silicone */
-#undef XOR0_ENABLE
-#else
- /* XOR0 is disabled in A0 Silicone */
-#define XOR0_ENABLE
-#endif
-
-/*********************************************************************************/
-/**************                 Early Printk Support                **************/
-/*********************************************************************************/
+/*******************************************************************************
+ * Early Printk Support
+ */
 #ifdef MV_INCLUDE_EARLY_PRINTK
-#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
-#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
-#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x14))
-#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x0 ))
-#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
-//#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x40000))
-//#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x2011c))
+#define MV_UART0_LSR    (*(volatile unsigned char*)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR    (*(volatile unsigned char*)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char*)(INTER_REGS_VIRT_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char*)(INTER_REGS_VIRT_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE  ((unsigned char*)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
 /*
  * This does not append a newline
  */
@@ -160,31 +149,34 @@ static void putstr(const char *s)
 {
 	unsigned int model;
 
-        while (*s) {
-		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+	while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0) ;
 		MV_UART0_THR = *s;
 
-                if (*s == '\n') {
-                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
-                        MV_UART0_THR = '\r';
-                }
-                s++;
-        }
+		if (*s == '\n') {
+			while ((MV_UART0_LSR & UART_LSR_THRE) == 0) ;
+			MV_UART0_THR = '\r';
+		}
+		s++;
+	}
 }
+
 extern void putstr(const char *ptr);
-void mv_early_printk(char *fmt,...)
+void mv_early_printk(char *fmt, ...)
 {
 	va_list args;
+
 	va_start(args, fmt);
-	vsprintf(arr,fmt,args);
+	vsprintf(arr, fmt, args);
 	va_end(args);
 	putstr(arr);
 }
+
 #endif
 
-/*********************************************************************************/
-/**************               UBoot Tagging Parameters              **************/
-/*********************************************************************************/
+/*******************************************************************************
+ * UBoot Tagging Parameters
+ */
 #ifdef CONFIG_BE8_ON_LE
 #define read_tag(a)    le32_to_cpu(a)
 #define read_mtu(a)    le16_to_cpu(a)
@@ -222,75 +214,44 @@ static int __init parse_tag_mv_uboot(const struct tag *tag)
 	if ((mvUbootVer >> 8) >= 0x3040c)
 		mv_nand_ecc = read_tag(tag->u.mv_uboot.nand_ecc);
 	else
-		mv_nand_ecc = 1; /* fallback to 1-bit ECC */
+		mv_nand_ecc = 1;  /* fallback to 1-bit ECC */
 #endif
 	return 0;
 }
 
 __tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
 
-/*********************************************************************************/
-/**************                Command Line Parameters              **************/
-/*********************************************************************************/
-
-#ifdef CONFIG_CACHE_AURORA_L2
-static int noL2 = 0;
-static int __init noL2_setup(char *__unused)
-{
-     noL2 = 1;
-     return 1;
-}
-
-__setup("noL2", noL2_setup);
-#endif
-
+/*******************************************************************************
+ * Command Line Parameters
+ */
 #ifdef CONFIG_SMP
-#if 0
-unsigned long mv_cpu_count = NR_CPUS;
-static int __init mv_cpu_count_setup(char *s)
-{
-	int fail;
-	unsigned int cpu_count;
-
-	/* Translate string to integer. If fails return to default*/
-	while (isspace(*s))
-		s++;
-
-	fail = strict_strtoul(s, 10, &cpu_count);
-	if(fail == 0)
-	{
-		set_core_count(cpu_count);
-	}
-
-	return 1;
-}
-__setup("mv_cpu_count=", mv_cpu_count_setup);
-#endif
 static int __init mv_rsrc_setup(char *s)
 {
 	char* rsrc = strchr(s, ' ');
 
-	/*Verify NULL termination */
+	/* Verify NULL termination */
 	if (rsrc) (*rsrc) = '\0';
+
 	/* Parse string to table */
-	if (MV_FALSE == mvUnitMapSetup(s, strstr))
+	if (mvUnitMapSetup(s, strstr) == MV_FALSE)
 		printk(KERN_ERR "Invalid resource string %s\n", s);
 
-	// Change to rsrc limited mode
+	/* Change to rsrc limited mode */
 	mvUnitMapSetRsrcLimited(MV_TRUE);
 
 	return 1;
 }
-__setup("mv_rsrc=", mv_rsrc_setup);
-#endif /* CONFIG_SMP */
 
+__setup("mv_rsrc=", mv_rsrc_setup);
+#endif
 
 void __init avantalp_setup_cpu_mbus(void)
 {
 	void __iomem *addr;
 	int i;
 	int cs;
-	u8	coherency_status = 0;
+	u8 coherency_status = 0;
+
 #if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
 	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
 #endif
@@ -299,7 +260,7 @@ void __init avantalp_setup_cpu_mbus(void)
 	 * Setup MBUS dram target info.
 	 */
 	avantalp_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
-	addr = (void __iomem *)BRIDGE_VIRT_BASE;
+	addr = (void __iomem*)BRIDGE_VIRT_BASE;
 
 	for (i = 0, cs = 0; i < 4; i++) {
 		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
@@ -324,102 +285,100 @@ void __init avantalp_setup_cpu_mbus(void)
 	avantalp_mbus_dram_info.num_cs = cs;
 }
 
-/*********************************************************************************/
-/**************               I/O Devices Platform Info             **************/
-/*********************************************************************************/
+/*******************************************************************************
+ * I/O Devices Platform Info
+ */
+
 /**********
- * UART-0 *
- **********/
-static struct plat_serial8250_port aurora_uart0_data[] = {
+* UART-0 *
+**********/
+static struct plat_serial8250_port uart0_data[] = {
 	{
-		.iotype		= UPIO_MEM32,
-		.regshift	= 2,
-		.uartclk	= 0,
+		.iotype         = UPIO_MEM32,
+		.regshift       = 2,
+		.uartclk        = 0,
 	},
 };
 
-static struct resource aurora_uart0_resources[] = {
+static struct resource uart0_resources[] = {
 	{
-		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
-		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= IRQ_UART0,
-		.end		= IRQ_UART0,
-		.flags		= IORESOURCE_IRQ,
+		.start          = (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end            = (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags          = IORESOURCE_MEM,
+	},{
+		.start          = IRQ_UART0,
+		.end            = IRQ_UART0,
+		.flags          = IORESOURCE_IRQ,
 	},
 };
 
-static struct platform_device aurora_uart0 = {
+static struct platform_device uart0 = {
 	.name			= "dw-apb-uart",
 	.id			= 0,
 	.dev			= {
-		.platform_data	= aurora_uart0_data,
+		.platform_data	= uart0_data,
 	},
-	.resource		= aurora_uart0_resources,
-	.num_resources		= ARRAY_SIZE(aurora_uart0_resources),
+	.resource		= uart0_resources,
+	.num_resources		= ARRAY_SIZE(uart0_resources),
 };
 
 /**********
- * UART-1 *
- **********/
- static struct plat_serial8250_port aurora_uart1_data[] = {
+* UART-1 *
+**********/
+static struct plat_serial8250_port uart1_data[] = {
 	{
-		.iotype		= UPIO_MEM32,
-		.regshift	= 2,
-		.uartclk	= 0,
+		.iotype         = UPIO_MEM32,
+		.regshift       = 2,
+		.uartclk        = 0,
 	},
 };
 
-static struct resource aurora_uart1_resources[] = {
+static struct resource uart1_resources[] = {
 	{
-		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
-		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= IRQ_UART1,
-		.end		= IRQ_UART1,
-		.flags		= IORESOURCE_IRQ,
+		.start          = (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.end            = (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
+		.flags          = IORESOURCE_MEM,
+	},{
+		.start          = IRQ_UART1,
+		.end            = IRQ_UART1,
+		.flags          = IORESOURCE_IRQ,
 	},
 };
 
-static struct platform_device aurora_uart1 = {
+static struct platform_device uart1 = {
 	.name			= "dw-apb-uart",
 	.id			= 0,
 	.dev			= {
-		.platform_data	= aurora_uart1_data,
+		.platform_data	= uart1_data,
 	},
-	.resource		= aurora_uart1_resources,
-	.num_resources		= ARRAY_SIZE(aurora_uart1_resources),
+	.resource		= uart1_resources,
+	.num_resources		= ARRAY_SIZE(uart1_resources),
 };
 
 void __init serial_initialize(int port)
 {
-	if(port == 0)
-	{
-		if (mvUnitMapIsMine(UART0) == MV_FALSE){
+	if (port == 0) {
+		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
 			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART0);
 		}
 
-		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
-		platform_device_register(&aurora_uart0);
-	}
-	else
-	{
-		if(mvUnitMapIsMine(UART1) == MV_FALSE){
+		uart0_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&uart0);
+	}else {
+		if (mvUnitMapIsMine(UART1) == MV_FALSE) {
 			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART1);
 		}
 
-		aurora_uart1_data[0].uartclk = mvBoardTclkGet();
-		platform_device_register(&aurora_uart1);
+		uart1_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&uart1);
 	}
 }
 
 /*******
- * GBE *
- *******/
+* GBE *
+*******/
 #ifdef CONFIG_MV_ETHERNET
 #if defined(CONFIG_MV_ETH_LEGACY)
 static struct platform_device mv88fx_eth = {
@@ -436,7 +395,7 @@ static struct platform_device mv88fx_neta = {
 #elif defined(CONFIG_MV_ETH_PP2)
 static void mv_pp2_giga_pdev_register(struct platform_device *pdev)
 {
-	struct mv_pp2_pdata *plat_data = (struct mv_pp2_pdata *)pdev->dev.platform_data;
+	struct mv_pp2_pdata *plat_data = (struct mv_pp2_pdata*)pdev->dev.platform_data;
 	int speed, port = pdev->id;
 
 	plat_data->cpu_mask  = group_cpu_mask;
@@ -483,17 +442,17 @@ static struct resource mv_pp2_ge0_resources[] = {
 };
 
 static struct mv_pp2_pdata mv_pp2_ge0_pdata = {
-	.mtu = 1500,
-	.phy_addr = 0,
+	.mtu		= 1500,
+	.phy_addr	= 0,
 };
 
 static struct platform_device mv_pp2_ge0_plat = {
-	.name           = MV_PP2_PORT_NAME,
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(mv_pp2_ge0_resources),
-	.resource       = mv_pp2_ge0_resources,
-	.dev            = {
-		.platform_data = &mv_pp2_ge0_pdata,
+	.name			= MV_PP2_PORT_NAME,
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(mv_pp2_ge0_resources),
+	.resource		= mv_pp2_ge0_resources,
+	.dev			= {
+		.platform_data	= &mv_pp2_ge0_pdata,
 	},
 };
 
@@ -506,23 +465,23 @@ static struct resource mv_pp2_ge2_resources[] = {
 };
 
 static struct mv_pp2_pdata mv_pp2_ge2_pdata = {
-	.mtu = 1500,
-	.phy_addr = -1,
+	.mtu		= 1500,
+	.phy_addr	= -1,
 };
 
 static struct platform_device mv_pp2_ge2_plat = {
-	.name           = MV_PP2_PORT_NAME,
-	.id             = 2,
-	.num_resources  = ARRAY_SIZE(mv_pp2_ge2_resources),
-	.resource       = mv_pp2_ge2_resources,
-	.dev            = {
-		.platform_data = &mv_pp2_ge2_pdata,
+	.name			= MV_PP2_PORT_NAME,
+	.id			= 2,
+	.num_resources		= ARRAY_SIZE(mv_pp2_ge2_resources),
+	.resource		= mv_pp2_ge2_resources,
+	.dev			= {
+		.platform_data	= &mv_pp2_ge2_pdata,
 	},
 };
 
 static struct mv_pp2_pdata mv_pp2_ge3_pdata = {
-	.mtu = 1500,
-	.phy_addr = -1,
+	.mtu		= 1500,
+	.phy_addr	= -1,
 };
 
 static struct resource mv_pp2_ge3_resources[] = {
@@ -534,12 +493,12 @@ static struct resource mv_pp2_ge3_resources[] = {
 };
 
 static struct platform_device mv_pp2_ge3_plat = {
-	.name           = MV_PP2_PORT_NAME,
-	.id             = 3,
-	.num_resources  = ARRAY_SIZE(mv_pp2_ge3_resources),
-	.resource       = mv_pp2_ge3_resources,
-	.dev            = {
-		.platform_data = &mv_pp2_ge3_pdata,
+	.name			= MV_PP2_PORT_NAME,
+	.id			= 3,
+	.num_resources		= ARRAY_SIZE(mv_pp2_ge3_resources),
+	.resource		= mv_pp2_ge3_resources,
+	.dev			= {
+		.platform_data	= &mv_pp2_ge3_pdata,
 	},
 };
 #else
@@ -570,10 +529,9 @@ static void __init eth_init(void)
 		netaSmpGroupStruct->portMask = portMask;
 	}
 
-	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
+	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
 		if (MV_BIT_CHECK(netaSmpGroupStruct->cpuMask, cpu))
 			found = 1;
-	}
 
 	if (!found) {
 		printk(KERN_ERR "%s: cpuMask does not contain any of the CPUs \n", __func__);
@@ -595,7 +553,7 @@ static void __init eth_init(void)
  * GPIO
  ***********/
 static struct platform_device mv_gpio = {
-	.name	= "mv_gpio",
+	.name		= "mv_gpio",
 	.id		= 0,
 	.num_resources	= 0,
 };
@@ -606,65 +564,37 @@ static void __init mv_gpio_init()
 }
 
 /*******
- * RTC *
- *******/
-static struct resource alp_rtc_resource[] = {
+* RTC *
+*******/
+static struct resource rtc_resource[] = {
 	{
-		.start	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
-		.end	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= IRQ_RTC,
-		.flags	= IORESOURCE_IRQ,
+		.start  = INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
+		.end    = INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
+		.flags  = IORESOURCE_MEM,
+	},{
+		.start  = IRQ_RTC,
+		.flags  = IORESOURCE_IRQ,
 	}
 };
 
 static void __init rtc_init(void)
 {
-	platform_device_register_simple("rtc-mv", -1, alp_rtc_resource, 2);
-}
-
-/*************
- * 7-Segment *
- *************/
-static struct timer_list alp_db_timer;
-static void alp_db_7seg_event(unsigned long data)
-{
-	static int count = 0;
-
-	/* Update the 7 segment */
-	mvBoardDebugLed(count);
-
-	/* Incremnt count and arm the timer*/
-	count = (count + 1) & 7;
-	mod_timer(&alp_db_timer, jiffies + 1 * HZ);
-}
-
-static int __init alp_db_7seg_init(void)
-{
-	/* Create the 7segment timer */
-	setup_timer(&alp_db_timer, alp_db_7seg_event, 0);
-
-	/* Arm it expire in 1 second */
-	mod_timer(&alp_db_timer, jiffies + 1 * HZ);
-
-	return 0;
+	platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
 }
-/* __initcall(alp_db_7seg_init); */
 
-
-/*********************************************************************************/
-/**************                      Helper Routines                **************/
-/*********************************************************************************/
+/*******************************************************************************
+ * Helper Routines
+ */
 
 void print_board_info(void)
 {
 	char name_buff[50];
+
 	printk("\n");
 	printk("  Marvell Avanta-LP");
 
 	mvBoardNameGet(name_buff, 50);
-	printk(" %s Board - ",name_buff);
+	printk(" %s Board - ", name_buff);
 
 	mvCtrlModelRevNameGet(name_buff);
 	printk(" Soc: %s",  name_buff);
@@ -673,7 +603,7 @@ void print_board_info(void)
 #else
 	printk(" BE\n");
 #endif
-	printk("  Detected Tclk %d, SysClk %d, FabricClk %d, PClk %d\n",mvTclk, mvSysclk, mvCpuL2ClkGet(), mvCpuPclkGet());
+	printk("  Detected Tclk %d, SysClk %d, FabricClk %d, PClk %d\n", mvTclk, mvSysclk, mvCpuL2ClkGet(), mvCpuPclkGet());
 	printk("  LSP version: %s\n", LSP_VERSION);
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvUnitMapPrint();
@@ -681,7 +611,7 @@ void print_board_info(void)
 	printk("\n");
 }
 
-#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 static void io_coherency_init(void)
 {
 	MV_U32 reg;
@@ -695,16 +625,17 @@ static void io_coherency_init(void)
 #ifndef CONFIG_SMP
 	/* enable CPUs in SMP group on Fabric coherency */
 	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CTRL_REG);
-	reg &= ~(0x3<<24);
-	reg |= 1<<24;
+	reg &= ~(0x3 << 24);
+	reg |= 1 << 24;
 	MV_REG_WRITE(MV_COHERENCY_FABRIC_CTRL_REG, reg);
 
 	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CFG_REG);
-	reg &= ~(0x3<<24);
-	reg |= 1<<24;
+	reg &= ~(0x3 << 24);
+	reg |= 1 << 24;
 	MV_REG_WRITE(MV_COHERENCY_FABRIC_CFG_REG, reg);
 #endif
 }
+
 #endif
 
 #ifdef CONFIG_DEBUG_LL
@@ -749,7 +680,7 @@ static void cpu_fabric_common_init(void)
 
 	platform_device_register(&pmu_device);
 
-#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+#ifdef  CONFIG_AURORA_IO_CACHE_COHERENCY
 	printk("Support IO coherency.\n");
 	io_coherency_init();
 #endif
@@ -762,7 +693,7 @@ static void cpu_fabric_common_init(void)
 extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
 static void __init alp_fpga_init(void)
 {
-#if 1 /* kostaz: disabling l2+iocc init for SMP boot test */
+#if 1   /* kostaz: disabling l2+iocc init for SMP boot test */
 	cpu_fabric_common_init();
 #endif
 
@@ -779,8 +710,8 @@ static void __init alp_fpga_init(void)
 	mvBoardEnvInit();
 
 	/* init the controller environment */
-	if( mvCtrlEnvInit() ) {
-		printk( "Controller env initialization failed.\n" );
+	if ( mvCtrlEnvInit() ) {
+		printk("Controller env initialization failed.\n");
 		return;
 	}
 
@@ -789,15 +720,15 @@ static void __init alp_fpga_init(void)
 
 	/* Init the CPU windows setting and the access protection windows. */
 	/*if( mvCpuIfInit(mv_sys_map())) {
-		printk( "Cpu Interface initialization failed.\n" );
-		return;
-	}*/
+	        printk( "Cpu Interface initialization failed.\n" );
+	        return;
+	   }*/
 
 	avantalp_setup_cpu_mbus();
 
 	/* Init the CPU windows setting and the access protection windows. */
-	if( mvCpuIfInit(mv_sys_map())) {
-		printk( "Cpu Interface initialization failed.\n" );
+	if ( mvCpuIfInit(mv_sys_map())) {
+		printk("Cpu Interface initialization failed.\n");
 		return;
 	}
 
@@ -831,10 +762,10 @@ static void __init alp_fpga_init(void)
 
 	serial_initialize(0);
 
-	if( mvCpuIfInit(mv_sys_map())) {
+	if ( mvCpuIfInit(mv_sys_map())) {
 		printk("Cpu Interface initialization failed.\n");
 		return;
-}
+	}
 }
 
 static void alp_restart(char mode, const char *cmd)
@@ -843,17 +774,17 @@ static void alp_restart(char mode, const char *cmd)
 	mvBoardReset();
 
 	/* This should never be reached */
-	while (1);
+	while (1) ;
 }
 
 extern void __init alp_init_irq(void);
 
 MACHINE_START(AVANTA_LP_FPGA, "Marvell Avanta LP FPGA Board")
-	.atag_offset	= BOOT_PARAMS_OFFSET,
-	.map_io		= alp_map_io,
-	.init_irq	= alp_init_irq,
-	.timer		= &alp_timer,
-	.handle_irq	= gic_handle_irq,
-	.init_machine	= alp_fpga_init,
-	.restart	= alp_restart,
+.atag_offset    = BOOT_PARAMS_OFFSET,
+.map_io         = alp_map_io,
+.init_irq       = alp_init_irq,
+.timer          = &alp_timer,
+.handle_irq     = gic_handle_irq,
+.init_machine   = alp_fpga_init,
+.restart        = alp_restart,
 MACHINE_END
-- 
1.7.5.4

