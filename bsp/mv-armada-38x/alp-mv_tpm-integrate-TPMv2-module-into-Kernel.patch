From a28a9eee0ff3f85d6c288d9866149160c6f5279a Mon Sep 17 00:00:00 2001
From: Jing Hua <jinghua@marvell.com>
Date: Wed, 19 Mar 2014 12:22:40 +0800
Subject: [PATCH 1502/1825] alp: mv_tpm: integrate TPMv2 module into Kernel

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit c543a82406367fd49927017e71bd9b3a5ba9fb11

merged TPM from LSP FPGA branch, until commit 0ac1def62f523be51a0d3e855a7035ff23c1cd71

Signed-off-by: Jing Hua <jinghua@marvell.com>

Change-Id: I63b9a23e4d77a652d8f054c0880517ab1378ee1d
Reviewed-on: http://vgitil04.il.marvell.com:8080/6523
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/avanta_lp_a0_defconfig            |    1 +
 arch/arm/mach-avantalp/Makefile                    |    5 +-
 arch/arm/mach-avantalp/config/mvRules.mk           |   18 +-
 arch/arm/plat-armada/Kconfig                       |   12 +
 .../plat-armada/mv_drivers_lsp/mv_switch/Makefile  |    8 +
 .../plat-armada/mv_drivers_lsp/mv_switch/mv_phy.c  |  532 ++
 .../plat-armada/mv_drivers_lsp/mv_switch/mv_phy.h  |   46 +
 .../mv_drivers_lsp/mv_switch/mv_switch.c           | 3320 ++++++++-
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |  172 +-
 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig |   39 +
 .../arm/plat-armada/mv_drivers_lsp/mv_tpm/Makefile |   49 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_api.h            |  852 ++
 .../plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2.h |  195 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_c2_qos.h         |  126 +
 .../plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c3.h |  190 +
 .../plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c4.h |  164 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_cls.h            |  169 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_common.h         |   70 +
 .../plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_db.h |  706 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_device.h         |  644 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_header.h         |  123 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_in6.h            |   71 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_init.h           |  612 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_internal_types.h |  697 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_log.h            |  249 +
 .../plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mc.h |  149 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_mempool.h        |  126 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_mng.h            |  426 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_parser.h         |  249 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_pme.h            |  631 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_policer.h        |  152 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_switch.h         |  273 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_switch_api.h     | 1709 ++++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_sysfs.h          |  115 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_sysfs_utils.h    |  233 +
 .../mv_drivers_lsp/mv_tpm/inc/tpm_types.h          |  561 ++
 .../mv_drivers_lsp/mv_tpm/inc/tpm_utils.h          |   79 +
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_api.c       | 1293 +++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c        | 5916 ++++++++++++++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_device.c    | 1366 ++++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_init.c      | 1588 ++++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_log.c       |   85 +
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c       | 8220 ++++++++++++++++++++
 .../mv_tpm/src/conf/tpm_switch_api.c               | 1924 +++++
 .../mv_drivers_lsp/mv_tpm/src/conf/tpm_utils.c     |  263 +
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c        | 2612 +++++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c2_qos.c    |  405 +
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c3.c        | 1664 ++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c        |  683 ++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c       | 2107 +++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_common.c    |  472 ++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c        | 1337 ++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_mempool.c   |  311 +
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_parser.c    | 1847 +++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c       | 3282 ++++++++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_policer.c   |  963 +++
 .../mv_drivers_lsp/mv_tpm/src/core/tpm_switch.c    | 4122 ++++++++++
 .../mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs.c    |  422 +
 .../mv_tpm/src/sysfs/tpm_sysfs_api.c               | 7280 +++++++++++++++++
 .../mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c2.c |  937 +++
 .../mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c3.c | 1042 +++
 .../mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c4.c |  493 ++
 .../mv_tpm/src/sysfs/tpm_sysfs_cls.c               | 1020 +++
 .../mv_tpm/src/sysfs/tpm_sysfs_init.c              | 1838 +++++
 .../mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mc.c |  605 ++
 .../mv_tpm/src/sysfs/tpm_sysfs_mng.c               | 1291 +++
 .../mv_tpm/src/sysfs/tpm_sysfs_plcr.c              |  910 +++
 .../mv_tpm/src/sysfs/tpm_sysfs_pme.c               | 1043 +++
 .../mv_tpm/src/sysfs/tpm_sysfs_prs.c               |  751 ++
 .../mv_tpm/src/sysfs/tpm_sysfs_switch.c            | 5506 +++++++++++++
 .../mv_tpm/src/sysfs/tpm_sysfs_utils.c             | 1023 +++
 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/test.h  |    1 -
 72 files changed, 78385 insertions(+), 10 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Makefile
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_api.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2_qos.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c3.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c4.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_cls.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_common.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_db.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_device.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_header.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_in6.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_init.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_internal_types.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mc.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mempool.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mng.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_parser.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_pme.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_policer.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch_api.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs_utils.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_types.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_utils.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_api.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_device.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_init.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_log.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_switch_api.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_utils.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2_qos.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c3.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_common.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mempool.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_parser.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_policer.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_switch.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_api.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c2.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c3.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c4.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_cls.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_init.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mc.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mng.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_plcr.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_pme.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_prs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_switch.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_utils.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/test.h

diff --git a/arch/arm/configs/avanta_lp_a0_defconfig b/arch/arm/configs/avanta_lp_a0_defconfig
index 7449092..e775634 100644
--- a/arch/arm/configs/avanta_lp_a0_defconfig
+++ b/arch/arm/configs/avanta_lp_a0_defconfig
@@ -197,3 +197,4 @@ CONFIG_CRYPTO_PCBC=m
 # CONFIG_CRYPTO_ANSI_CPRNG is not set
 CONFIG_CRC_CCITT=y
 CONFIG_LIBCRC32C=y
+# CONFIG_MV_INCLUDE_TPM is not set
\ No newline at end of file
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 296afd04..d7d0c60 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -49,7 +49,8 @@ QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrv
                   $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o\
                   $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o		\
 		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
-		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o \
+		  $(HAL_QD_DIR)/src/msapi/gtWeight.o
 
 LSP_OBJS        = core.o irq.o sysmap.o export.o time.o
 
@@ -114,6 +115,8 @@ obj-y					+= $(LSP_MUX_DIR)/
 obj-$(CONFIG_SENSORS_ALP)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
 
+#TPM
+obj-$(CONFIG_MV_TPM) += $(PLAT_DRIVERS)/mv_tpm/
 
 # LSP part
 avantalp-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
diff --git a/arch/arm/mach-avantalp/config/mvRules.mk b/arch/arm/mach-avantalp/config/mvRules.mk
index 5e7d20f..e32debb 100644
--- a/arch/arm/mach-avantalp/config/mvRules.mk
+++ b/arch/arm/mach-avantalp/config/mvRules.mk
@@ -44,6 +44,11 @@ HAL_UART_DIR      = $(HAL_DIR)/uart
 
 HAL_PP2_DIR       = $(HAL_DIR)/pp2
 HAL_PP2_PRS_DIR   = $(HAL_PP2_DIR)/prs
+HAL_PP2_CLS_DIR   = $(HAL_PP2_DIR)/cls
+HAL_PP2_WOL_DIR   = $(HAL_PP2_DIR)/wol
+HAL_PP2_DPI_DIR   = $(HAL_PP2_DIR)/dpi
+HAL_PP2_PME_DIR   = $(HAL_PP2_DIR)/pme
+HAL_PP2_PLCR_DIR  = $(HAL_PP2_DIR)/plcr
 LSP_PP2_DIR       = $(PLAT_DRIVERS)/mv_pp2
 LSP_PP2_DEV_DIR   = $(LSP_PP2_DIR)/net_dev
 
@@ -87,6 +92,9 @@ endif
 ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
 HAL_NFC_DIR       = $(HAL_DIR)/nfc
 endif
+ifeq ($(CONFIG_MV_INCLUDE_TPM),y)
+LSP_TPM_INC_DIR  = $(PLAT_DRIVERS)/mv_tpm/inc
+endif
 
 LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
@@ -127,7 +135,12 @@ DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_PP2_D
                    -I$(PLAT_PATH_I)/$(LSP_EPON_CORE_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_CORE_DIR) \
                    -I$(PLAT_PATH_I)/$(LSP_EPON_PERF_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PERF_DIR) \
                    -I$(PLAT_PATH_I)/$(LSP_EPON_PLAT_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PLAT_DIR) \
-                   -I$(PLAT_PATH_I)/$(LSP_PON_PLAT_DIR)  -I$(PLAT_PATH_I)/$(LSP_PON_PERF_DIR)
+                   -I$(PLAT_PATH_I)/$(LSP_PON_PLAT_DIR)  -I$(PLAT_PATH_I)/$(LSP_PON_PERF_DIR) \
+                   -I$(PLAT_PATH_I)/$(LSP_TPM_INC_DIR)   -I$(PLAT_PATH_I)/$(HAL_PP2_DIR) \
+                   -I$(PLAT_PATH_I)/$(HAL_PP2_PRS_DIR)   -I$(PLAT_PATH_I)/$(HAL_PP2_CLS_DIR) \
+                   -I$(PLAT_PATH_I)/$(HAL_PP2_WOL_DIR)   -I$(PLAT_PATH_I)/$(HAL_PP2_DPI_DIR) \
+                   -I$(PLAT_PATH_I)/$(HAL_PP2_PME_DIR)   -I$(PLAT_PATH_I)/$(HAL_PP2_PLCR_DIR) \
+                   -I$(PLAT_PATH_I)/$(LSP_MUX_DIR)
 
 EXTRA_INCLUDE    = $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH) $(ALP_FAM_PATH) \
                    $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
@@ -137,6 +150,9 @@ EXTRA_INCLUDE    = $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH) $(ALP_FAM_PATH) \
 ###################################################################################################
 MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
 
+ifeq ($(CONFIG_MV_INCLUDE_TPM),y)
+EXTRA_INCLUDE   += -I$(PLAT_PATH_I)/$(LSP_TPM_DIR)/inc
+endif
 
 ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
 EXTRA_INCLUDE   += $(QD_PATH)
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 1207b10..a06136d 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -200,6 +200,16 @@ config MV_INCLUDE_SWITCH
 	help
 	  TBD
 
+config MV_INCLUDE_TPM
+	bool "TPM Support"
+	depends on MV88F6500 || MV_ETH_PP2
+	default n
+	help
+	Add TPM (Traffic Processor Manager) support,
+	which provides a set of high level APIs over PPv2, based
+	on IP packet fields value to create/delete hardware
+	forwarding rules for routing and bridging traffic.
+
 config MV_INCLUDE_PRESTERA
 	bool "Prestera Switch Support"
 	depends on ARCH_MSYS
@@ -616,6 +626,8 @@ source arch/arm/plat-armada/mv_drivers_lsp/mv_tsu/Kconfig
 
 source arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
 
+source arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig
+
 config  SCSI_MVSATA
 	tristate "Support for Marvell Sata Adapters"
 	depends on ( MV_INCLUDE_INTEG_SATA && SCSI ) || ( PCI && SCSI )
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
index b37a198..16cd6fa 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/Makefile
@@ -17,4 +17,12 @@ ccflags-y       += -I$(PLAT_PATH_I)/$(LSP_MUX_DIR)
 
 endif # CONFIG_ARCH_MVEBU
 
+ifeq ($(CONFIG_ARCH_AVANTA_LP),y)
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o mv_switch_sysfs.o mv_phy.o
+
+else
+
 obj-$(CONFIG_MV_INCLUDE_SWITCH)	+= mv_switch.o mv_switch_sysfs.o
+
+endif # CONFIG_ARCH_AVANTA_LP
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.c
new file mode 100644
index 0000000..4ee44b6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.c
@@ -0,0 +1,532 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/mv_switch.h>
+#include <linux/module.h>
+
+#include "mvOs.h"
+#include "mvSysHwConfig.h"
+#include "eth-phy/mvEthPhy.h"
+#ifdef MV_INCLUDE_ETH_COMPLEX
+#include "ctrlEnv/mvCtrlEthCompLib.h"
+#endif /* MV_INCLUDE_ETH_COMPLEX */
+
+#include "msApi.h"
+#include "mv_switch.h"
+#include "mv_phy.h"
+#include "mv_mux/mv_mux_netdev.h"
+
+/*******************************************************************************
+* mv_phy_port_power_state_set
+*
+* DESCRIPTION:
+*	The API configures the PHY port state of given switch logical port.
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	state  - PHY port power state to set.
+*			GT_TRUE: power on
+*			GT_FALSE: power down
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_power_state_set(unsigned int lport, GT_BOOL state)
+{
+	GT_BOOL power_state;
+	GT_BOOL pre_power_state;
+	GT_STATUS rc = GT_OK;
+
+	if (state == GT_TRUE)
+		power_state = GT_FALSE;
+	else
+		power_state = GT_TRUE;
+
+	/* get the current link status */
+	rc = gprtGetPortPowerDown(mv_switch_qd_dev_get(), lport, &pre_power_state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortPowerDown()\n");
+
+	rc = gprtPortPowerDown(mv_switch_qd_dev_get(), lport, power_state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtPortPowerDown()\n");
+
+	/* since link change event from HW (via interrupt) does not happen
+	   for UP->DOWN link change, only for DOWN->UP after link negotiation,
+	   print a port Down state change for this use case */
+	if (pre_power_state == GT_FALSE && power_state == GT_TRUE)
+		pr_err("Port %d: Link-down\n", lport);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_power_state_get
+*
+* DESCRIPTION:
+*	The API gets the PHY port state of given switch logical port.
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state  - PHY port power state to set.
+*			GT_TRUE: power on
+*			GT_FALSE: power down
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_power_state_get(unsigned int lport, GT_BOOL *state)
+{
+	GT_BOOL power_state;
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortPowerDown(mv_switch_qd_dev_get(), lport, &power_state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortPowerDown()\n");
+
+	if (power_state == GT_TRUE)
+		*state = GT_FALSE;
+	else
+		*state = GT_TRUE;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_autoneg_mode_set
+*
+* DESCRIPTION:
+*	The API configures the auto negotiation state of given switch logical port.
+* INPUTS:
+*	lport          - logical switch PHY port ID.
+*	autoneg_state  - autonegotiation state, enabled or disabled.
+*	autoneg_mode   - enum:
+*			SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
+*			SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
+*			SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
+*			SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
+*			SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
+*			SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
+*			SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
+*			SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
+*			SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
+*			SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
+*			SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
+*			SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_autoneg_mode_set(unsigned int lport, GT_BOOL autoneg_state, GT_PHY_AUTO_MODE autoneg_mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	if (GT_FALSE == autoneg_state) {
+		rc = gprtPortAutoNegEnable(mv_switch_qd_dev_get(), lport, GT_FALSE);
+		SW_IF_ERROR_STR(rc, "failed to call gprtPortAutoNegEnable()\n");
+
+		return MV_OK;
+	} else	{
+		rc = gprtSetPortAutoMode(mv_switch_qd_dev_get(), lport, autoneg_mode);
+		SW_IF_ERROR_STR(rc, "failed to call gprtSetPortAutoMode()\n");
+
+		rc = gprtPortAutoNegEnable(mv_switch_qd_dev_get(), lport, GT_TRUE);
+		SW_IF_ERROR_STR(rc, "failed to call gprtPortAutoNegEnable()\n");
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_autoneg_mode_get
+*
+* DESCRIPTION:
+*	The API gets the auto negotiation state of given switch logical port.
+* INPUTS:
+*	lport          - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	autoneg_state  - autonegotiation state, enabled or disabled.
+*	autoneg_mode   - enum:
+*			SPEED_AUTO_DUPLEX_AUTO: Auto for both speed and duplex
+*			SPEED_1000_DUPLEX_AUTO: 1000Mbps and auto duplex
+*			SPEED_100_DUPLEX_AUTO:  100Mbps and auto duplex
+*			SPEED_10_DUPLEX_AUTO:   10Mbps and auto duplex
+*			SPEED_AUTO_DUPLEX_FULL: Auto for speed only and Full duplex
+*			SPEED_AUTO_DUPLEX_HALF: Auto for speed only and Half duplex. (1000Mbps is not supported)
+*			SPEED_1000_DUPLEX_FULL: 1000Mbps Full duplex.
+*			SPEED_1000_DUPLEX_HALF: 1000Mbps half duplex.
+*			SPEED_100_DUPLEX_FULL:  100Mbps Full duplex.
+*			SPEED_100_DUPLEX_HALF:  100Mbps half duplex.
+*			SPEED_10_DUPLEX_FULL:   10Mbps Full duplex.
+*			SPEED_10_DUPLEX_HALF:   10Mbps half duplex.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_autoneg_mode_get(unsigned int lport, GT_BOOL *autoneg_state, GT_PHY_AUTO_MODE *autoneg_mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortAutoNegState(mv_switch_qd_dev_get(), lport, autoneg_state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortAutoNegState()\n");
+
+	rc = gprtGetPortAutoMode(mv_switch_qd_dev_get(), lport, autoneg_mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortAutoMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_autoneg_restart
+*
+* DESCRIPTION:
+*	The API restarts the auto negotiation of given switch logical port.
+* INPUTS:
+*	lport - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_autoneg_restart(unsigned int lport)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtPortRestartAutoNeg(mv_switch_qd_dev_get(), lport);
+	SW_IF_ERROR_STR(rc, "failed to call gprtPortRestartAutoNeg()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_pause_mode_set
+*
+* DESCRIPTION:
+*	This routine will set the pause bit in Autonegotiation Advertisement
+*	Register. And restart the autonegotiation.
+*
+* INPUTS:
+*	lport - logical switch PHY port ID.	The physical address, if SERDES device is accessed
+*	state - GT_PHY_PAUSE_MODE enum value.
+*		GT_PHY_NO_PAUSE		- disable pause
+*		GT_PHY_PAUSE		- support pause
+*		GT_PHY_ASYMMETRIC_PAUSE	- support asymmetric pause
+*		GT_PHY_BOTH_PAUSE	- support both pause and asymmetric pause
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+* COMMENTS:
+*	Data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+int mv_phy_port_pause_mode_set(unsigned int lport, GT_PHY_PAUSE_MODE state)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPause(mv_switch_qd_dev_get(), lport, state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPause()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_pause_mode_get
+*
+* DESCRIPTION:
+*	This routine will get the pause bit in Autonegotiation Advertisement
+*	Register.
+*
+* INPUTS:
+*	lport - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state - GT_PHY_PAUSE_MODE enum value.
+*		GT_PHY_NO_PAUSE		- disable pause
+*		GT_PHY_PAUSE		- support pause
+*		GT_PHY_ASYMMETRIC_PAUSE	- support asymmetric pause
+*		GT_PHY_BOTH_PAUSE	- support both pause and asymmetric pause
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+* COMMENTS:
+*	Data sheet register 4.10 Autonegotiation Advertisement Register
+*******************************************************************************/
+int mv_phy_port_pause_mode_get(unsigned int lport, GT_PHY_PAUSE_MODE *state)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPause(mv_switch_qd_dev_get(), lport, state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPause()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_pause_state_get
+*
+* DESCRIPTION:
+*	This routine will get the current pause state.
+*	Register.
+*
+* INPUTS:
+*	lport - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state - pause state
+*		GT_FALSE: MAC pause is not implemented
+*		GT_TRUE: MAC pause is implemented
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_phy_port_pause_state_get(unsigned int lport, GT_BOOL *state)
+{
+	GT_BOOL force;
+	GT_BOOL pause;
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsGetForcedFC(mv_switch_qd_dev_get(), lport, &force);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedFC()\n");
+
+	if (force) {
+		rc = gpcsGetFCValue(mv_switch_qd_dev_get(), lport, &pause);
+		SW_IF_ERROR_STR(rc, "failed to call gpcsGetFCValue()\n");
+	} else {
+		rc = gprtGetPauseEn(mv_switch_qd_dev_get(), lport, &pause);
+		SW_IF_ERROR_STR(rc, "failed to call gprtGetPauseEn()\n");
+	}
+
+	*state = pause;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_egr_loopback_set
+*
+* DESCRIPTION:
+*	Enable/Disable egress loopback of switch PHY port,
+*       and enable/disable force link port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable egree loopback.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Data sheet register 0.14 - Loop_back
+*******************************************************************************/
+int mv_phy_port_egr_loopback_set(unsigned int lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+	GT_BOOL link_forced;
+
+	rc = gprtSetPortLoopback(mv_switch_qd_dev_get(), lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortLoopback()\n");
+
+	/* Get port force link statue */
+	rc = gpcsGetForcedLink(mv_switch_qd_dev_get(), lport, &link_forced);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedLink()\n");
+	if (((enable == GT_TRUE) && (link_forced == GT_FALSE)) ||
+	    ((enable == GT_FALSE) && (link_forced == GT_TRUE))) {
+		/* Set force link */
+		rc = gpcsSetForcedLink(mv_switch_qd_dev_get(), lport, enable);
+		SW_IF_ERROR_STR(rc, "failed to call gpcsSetForcedLink()\n");
+		/* Set force link value */
+		rc = gpcsSetLinkValue(mv_switch_qd_dev_get(), lport, enable);
+		SW_IF_ERROR_STR(rc, "failed to call gpcsSetLinkValue()\n");
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_egr_loopback_get
+*
+* DESCRIPTION:
+*	This API get enabled/disabled state of egress loopback of switch PHY port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable egress loopback.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Data sheet register 0.14 - Loop_back
+*******************************************************************************/
+int mv_phy_port_egr_loopback_get(unsigned int lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortLoopback(mv_switch_qd_dev_get(), lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortLoopback()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_ingr_loopback_set
+*
+* DESCRIPTION:
+*	This API sets enabled/disabled state of ingress loopback of switch PHY port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable ingress loopback.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Data sheet register FE:28.4, GE:21_2.14  - Loop_back
+********************************************************************************/
+int mv_phy_port_ingr_loopback_set(unsigned int lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPortLineLoopback(mv_switch_qd_dev_get(), lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortLineLoopback()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_ingr_loopback_get
+*
+* DESCRIPTION:
+*	This API gets enabled/disabled state of ingress loopback of switch PHY port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable ingress loopback.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Data sheet register FE:28.4, GE:21_2.14  - Loop_back
+********************************************************************************/
+int mv_phy_port_ingr_loopback_get(unsigned int lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortLineLoopback(mv_switch_qd_dev_get(), lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortLineLoopback()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_speed_set
+*
+* DESCRIPTION:
+*	This API sets the speed of switch PHY port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable ingress loopback.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+********************************************************************************/
+int mv_phy_port_speed_set(unsigned int lport, GT_PHY_SPEED speed)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPortSpeed(mv_switch_qd_dev_get(), lport, speed);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortSpeed()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_phy_port_duplex_set
+*
+* DESCRIPTION:
+*	This API sets the duplex mode of switch PHY port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	mode   - enable or disable duplex mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+********************************************************************************/
+int mv_phy_port_duplex_set(unsigned int lport, GT_BOOL mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPortDuplexMode(mv_switch_qd_dev_get(), lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortDuplexMode()\n");
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.h
new file mode 100644
index 0000000..d24316d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_phy.h
@@ -0,0 +1,46 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#ifndef __mv_phy_h__
+#define __mv_phy_h__
+
+
+int mv_phy_port_power_state_set(unsigned int lport, GT_BOOL state);
+int mv_phy_port_power_state_get(unsigned int lport, GT_BOOL *state);
+int mv_phy_port_autoneg_mode_set(unsigned int lport, GT_BOOL autoneg_state, GT_PHY_AUTO_MODE autoneg_mode);
+int mv_phy_port_autoneg_mode_get(unsigned int lport, GT_BOOL *autoneg_state, GT_PHY_AUTO_MODE *autoneg_mode);
+int mv_phy_port_autoneg_restart(unsigned int lport);
+int mv_phy_port_pause_mode_set(unsigned int lport, GT_PHY_PAUSE_MODE state);
+int mv_phy_port_pause_mode_get(unsigned int lport, GT_PHY_PAUSE_MODE *state);
+int mv_phy_port_pause_state_get(unsigned int lport, GT_BOOL *state);
+int mv_phy_port_egr_loopback_set(unsigned int lport, GT_BOOL enable);
+int mv_phy_port_egr_loopback_get(unsigned int lport, GT_BOOL *enable);
+int mv_phy_port_ingr_loopback_set(unsigned int lport, GT_BOOL enable);
+int mv_phy_port_ingr_loopback_get(unsigned int lport, GT_BOOL *enable);
+int mv_phy_port_speed_set(unsigned int lport, GT_PHY_SPEED speed);
+int mv_phy_port_duplex_set(unsigned int lport, GT_BOOL mode);
+#endif /* __mv_phy_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index 7031a21..042786c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -40,7 +40,13 @@ disclaimer.
 
 #include "msApi.h"
 #include "h/platform/gtMiiSmiIf.h"
+#include "h/driver/gtHwCntl.h"
 #include "mv_switch.h"
+#include "mv_phy.h"
+#include "mv_mux_netdev.h"
+
+/*void mv_eth_switch_interrupt_clear(void);
+void mv_eth_switch_interrupt_unmask(void);*/
 
 #define MV_SWITCH_DEF_INDEX     0
 #define MV_ETH_PORT_0           0
@@ -50,6 +56,9 @@ static u16	db_port_mask[MV_SWITCH_DB_NUM];
 static u16	db_link_mask[MV_SWITCH_DB_NUM];
 static void	*db_cookies[MV_SWITCH_DB_NUM];
 
+static struct sw_port_info_t	sw_port_tbl[MV_SWITCH_MAX_PORT_NUM];
+static struct sw_vlan_info_t	sw_vlan_tbl[MV_SWITCH_MAX_VLAN_NUM];
+
 /* uncomment for debug prints */
 /* #define SWITCH_DEBUG */
 
@@ -310,7 +319,20 @@ int mv_switch_group_cookie_set(int db, void *cookie)
 	return 0;
 }
 
+int mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac)
+{
+	int err;
+
+	/* remove old mac */
+	err = mv_switch_mac_addr_set(db, old_mac, 0);
+	if (err)
+		return err;
 
+	/* add new mac */
+	err = mv_switch_mac_addr_set(db, new_mac, 1);
+
+	return err;
+}
 int mv_switch_mac_addr_set(int db, unsigned char *mac_addr, unsigned char op)
 {
 	GT_ATU_ENTRY mac_entry;
@@ -437,7 +459,7 @@ int mv_switch_promisc_set(int db, u8 promisc_on)
 		if (MV_BIT_CHECK(ports_mask, i) && (i != qd_cpu_port)) {
 			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, i),
 						      MV_SWITCH_VLAN_TO_GROUP(vlan_grp_id),
-						      ports_mask) != 0) {
+							ports_mask) != 0) {
 				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 				return -1;
 			}
@@ -1597,8 +1619,8 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 		return -1;
 	}
 
-	/* Add port to the VLAN */
-	if (mv_switch_port_based_vlan_set(port_map, 0) != 0)
+	/* Add port to the VLAN (CPU port is not part of VLAN) */
+	if (mv_switch_port_based_vlan_set((port_map & ~(1 << qd_cpu_port)), 0) != 0)
 		printk(KERN_ERR "mv_switch_port_based_vlan_set failed\n");
 
 	/* Add port to vtu (used in tx) */
@@ -1609,7 +1631,7 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		if (MV_BIT_CHECK(port_map, p) && (p != qd_cpu_port)) {
 			if (mv_switch_vlan_in_vtu_set(MV_SWITCH_PORT_VLAN_ID(vlan_grp_id, p),
-						      grp_id, port_map) != 0) {
+						      grp_id, port_map & ~(1 << qd_cpu_port)) != 0) {
 				printk(KERN_ERR "mv_switch_vlan_in_vtu_set failed\n");
 			}
 		}
@@ -1667,8 +1689,8 @@ int mv_switch_port_del(int switch_port)
 	if (gstpSetPortState(qd_dev, switch_port, GT_PORT_DISABLE) != GT_OK)
 		printk(KERN_ERR "gstpSetPortState failed on port #%d\n", switch_port);
 
-	/* Remove port from the VLAN */
-	if (mv_switch_port_based_vlan_set(port_map, 0) != 0)
+	/* Remove port from the VLAN (CPU port is not part of VLAN) */
+	if (mv_switch_port_based_vlan_set((port_map & ~(1 << qd_cpu_port)), 0) != 0)
 		printk(KERN_ERR "mv_gtw_set_port_based_vlan failed\n");
 
 	/* Remove port from vtu (used in tx) */
@@ -1693,6 +1715,3292 @@ int mv_switch_port_del(int switch_port)
 	return 0;
 }
 
+/*******************************************************************************
+* mv_switch_port_discard_tag_set
+*
+* DESCRIPTION:
+*	The API allows or drops all tagged packets based on logical port.
+*
+* INPUTS:
+*	lport - logical port.
+*	mode  - discard tag mode.
+*		GT_TRUE = discard tagged packets per lport
+*		GT_FALSE = allow tagged packets per lport.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_discard_tag_set(unsigned int lport, GT_BOOL mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetDiscardTagged(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetDiscardTagged()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_discard_tag_get
+*
+* DESCRIPTION:
+*	This routine gets discard tagged bit for given lport.
+*
+* INPUTS:
+*	lport - logical port.
+*
+* OUTPUTS:
+*	mode  - discard tag mode.
+*		GT_TRUE = discard tagged packets per lport
+*		GT_FALSE = allow tagged packets per lport.
+*
+* RETURNS:
+*       On success -  TPM_RC_OK.
+*       On error different types are returned according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_switch_port_discard_tag_get(unsigned int lport, GT_BOOL *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetDiscardTagged(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetDiscardTagged()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_discard_untag_set
+*
+* DESCRIPTION:
+*	The API allows or drops all untagged packets based on logical port.
+*
+* INPUTS:
+*	lport - logical port.
+*	mode  - discard untag mode.
+*		GT_TRUE = discard untagged packets per lport
+*		GT_FALSE = allow untagged packets per lport.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_discard_untag_set(unsigned int lport, GT_BOOL mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetDiscardUntagged(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetDiscardUntagged()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_discard_untag_get
+*
+* DESCRIPTION:
+*	This routine gets discard untagged bit for given lport.
+*
+* INPUTS:
+*	lport - logical port.
+*
+* OUTPUTS:
+*	mode  - discard untag mode.
+*		GT_TRUE = undiscard tagged packets per lport
+*		GT_FALSE = unallow tagged packets per lport.
+*
+* RETURNS:
+*       On success -  TPM_RC_OK.
+*       On error different types are returned according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_switch_port_discard_untag_get(unsigned int lport, GT_BOOL *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetDiscardUntagged(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetDiscardUntagged()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_def_vid_set
+*
+* DESCRIPTION:
+*	The API sets port default vlan ID.
+*
+* INPUTS:
+*	lport - logical port.
+*	vid   - port default VLAN ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_def_vid_set(unsigned int lport, unsigned short vid)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnSetPortVid(qd_dev, lport, vid);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnSetPortVid()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_def_vid_get
+*
+* DESCRIPTION:
+*	The API gets port default vlan ID.
+*
+* INPUTS:
+*	lport - logical port.
+*
+* OUTPUTS:
+*	vid   - port default VLAN ID.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_def_vid_get(unsigned int lport, unsigned short *vid)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnGetPortVid(qd_dev, lport, vid);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnGetPortVid()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_def_pri_set
+*
+* DESCRIPTION:
+*	The API sets port default priority.
+*
+* INPUTS:
+*	lport - logical port.
+*	pri   - the port priority.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_def_pri_set(unsigned int lport, unsigned char pri)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gcosSetPortDefaultTc(qd_dev, lport, pri);
+	SW_IF_ERROR_STR(rc, "failed to call gcosSetPortDefaultTc()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_def_pri_get
+*
+* DESCRIPTION:
+*	The API gets port default priority.
+*
+* INPUTS:
+*	lport - logical port.
+*
+* OUTPUTS:
+*	pri   - the port priority.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_def_pri_get(unsigned int lport, unsigned char *pri)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gcosGetPortDefaultTc(qd_dev, lport, pri);
+	SW_IF_ERROR_STR(rc, "failed to call gcosGetPortDefaultTc()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_vtu_entry_find
+*
+* DESCRIPTION:
+*	The API find expected VTU entry in sw_vlan_tbl.
+*
+* INPUTS:
+*	vtu_entry - VTU entry, supply VID.
+*
+* OUTPUTS:
+*	found     - find expected entry or not.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_vtu_entry_find(GT_VTU_ENTRY *vtu_entry, GT_BOOL *found)
+{
+	SW_IF_NULL(vtu_entry);
+	SW_IF_NULL(found);
+
+	if (sw_vlan_tbl[vtu_entry->vid].port_bm) {/* if port members is not 0, this vid entry exist in HW andd SW */
+		memcpy(vtu_entry, &sw_vlan_tbl[vtu_entry->vid].vtu_entry, sizeof(GT_VTU_ENTRY));
+		*found = MV_TRUE;
+	} else {
+		*found = MV_FALSE;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_vtu_entry_save
+*
+* DESCRIPTION:
+*	The API store expected VTU entry in sw_vlan_tbl.
+*
+* INPUTS:
+*	vtu_entry - VTU entry.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_vtu_entry_save(GT_VTU_ENTRY *vtu_entry)
+{
+	SW_IF_NULL(vtu_entry);
+
+	memcpy(&sw_vlan_tbl[vtu_entry->vid].vtu_entry, vtu_entry, sizeof(GT_VTU_ENTRY));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_vid_add
+*
+* DESCRIPTION:
+*	The API adds a VID.
+*
+* INPUTS:
+*	lport     - logical switch port ID.
+*	vid       - VLAN ID.
+*	egr_mode  - egress mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_vid_add(unsigned int lport, unsigned short vid, unsigned char egr_mode)
+{
+	GT_VTU_ENTRY vtu_entry;
+	unsigned int found = GT_FALSE;
+	unsigned int port;
+	GT_STATUS rc = GT_OK;
+
+	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+
+	/* Find existed VTU entry in SW cache */
+	vtu_entry.vid = vid;
+	rc = mv_switch_vtu_entry_find(&vtu_entry, &found);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_find()\n");
+
+	/* Add new VTU entry in case VTU entry does not exist */
+	if (found == GT_FALSE) {
+		vtu_entry.DBNum				= 0;
+		vtu_entry.vid				= vid;
+		vtu_entry.vidPriOverride		= GT_FALSE;
+		vtu_entry.vidPriority			= 0;
+		vtu_entry.vidExInfo.useVIDFPri		= GT_FALSE;
+		vtu_entry.vidExInfo.vidFPri		= 0;
+		vtu_entry.vidExInfo.useVIDQPri		= GT_FALSE;
+		vtu_entry.vidExInfo.vidQPri		= 0;
+		vtu_entry.vidExInfo.vidNRateLimit	= GT_FALSE;
+
+	}
+
+	/* Update VTU entry */
+	for (port = 0; port < qd_dev->numOfPorts; port++) {
+		if (sw_vlan_tbl[vid].port_bm & (1 << port)) {
+			if (port == lport)
+				vtu_entry.vtuData.memberTagP[port] = egr_mode;/* update egress mode only */
+			else
+				vtu_entry.vtuData.memberTagP[port] = sw_vlan_tbl[vid].egr_mode[port];
+		} else if (port == lport) {
+			vtu_entry.vtuData.memberTagP[port] = egr_mode;
+		} else if ((sw_port_tbl[port].port_mode == GT_FALLBACK) || (qd_dev->cpuPortNum == port)) {
+			/* add cpu_port to VLAN if cpu_port is valid */
+			vtu_entry.vtuData.memberTagP[port] = MEMBER_EGRESS_UNMODIFIED;
+		} else {
+			vtu_entry.vtuData.memberTagP[port] = NOT_A_MEMBER;
+		}
+	}
+
+	/* Add/Update HW VTU entry */
+	rc = gvtuAddEntry(qd_dev, &vtu_entry);
+	SW_IF_ERROR_STR(rc, "failed to call gvtuAddEntry()\n");
+
+	/* Record HW VTU entry info to sw_vlan_tbl */
+	rc = mv_switch_vtu_entry_save(&vtu_entry);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_save()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vid_add
+*
+* DESCRIPTION:
+*	The API adds a VID per lport.
+*
+* INPUTS:
+*	lport     - logical switch port ID.
+*	vid       - VLAN ID.
+*	egr_mode  - egress mode.
+*	belong    - whether this port blong to the VLAN actually
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vid_add(unsigned int lport, unsigned short vid, unsigned char egr_mode, bool belong)
+{
+	GT_STATUS rc = GT_OK;
+	unsigned int  port_bm;
+	unsigned int port_idx;
+
+	/* Verify whether the port is already a member of this VID */
+	port_bm = (unsigned int)(1 << lport);
+	if (!(sw_vlan_tbl[vid].port_bm & port_bm) || (sw_vlan_tbl[vid].egr_mode[lport] != egr_mode)) {
+		rc = mv_switch_vid_add(lport, vid, egr_mode);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_vid_add()\n");
+
+		/* add port to vid's member bit map and set port egress mode */
+		sw_vlan_tbl[vid].port_bm |= port_bm;
+		sw_vlan_tbl[vid].egr_mode[lport] = egr_mode;
+	}
+
+	/* add fallback port or CPU port to this VLAN in DB */
+	for (port_idx = 0; port_idx < qd_dev->numOfPorts; port_idx++) {
+		/* If a VLAN has been defined (there is a member in the VLAN) and
+		   the specified port is not a member */
+		if (!(sw_vlan_tbl[vid].port_bm & (1 << port_idx)) &&
+		     ((sw_port_tbl[port_idx].port_mode == GT_FALLBACK) ||
+		      (port_idx == qd_dev->cpuPortNum))) {
+			sw_vlan_tbl[vid].port_bm |= (1 << port_idx);
+			sw_vlan_tbl[vid].egr_mode[port_idx] = MEMBER_EGRESS_UNMODIFIED;
+		}
+	}
+
+	/* Add the specified port to the SW Port table */
+	if ((true == belong) && (sw_port_tbl[lport].vlan_blong[vid] == MV_SWITCH_PORT_NOT_BELONG))
+		sw_port_tbl[lport].vlan_blong[vid] = MV_SWITCH_PORT_BELONG;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vid_del
+*
+* DESCRIPTION:
+*	The API delete existed VID per lport.
+*
+* INPUTS:
+*	lport     - logical switch port ID.
+*	vid       - VLAN ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vid_del(unsigned int lport, unsigned short vid)
+{
+	unsigned int port_bm;
+	GT_VTU_ENTRY vtu_entry;
+	unsigned int found = GT_TRUE;
+	unsigned int port_idx;
+	unsigned int is_vlan_member = 0;
+	GT_STATUS rc = GT_OK;
+
+	/* Do nothing if the port does not in this VLAN */
+	port_bm = (unsigned int)(1 << lport);
+	if (!(sw_vlan_tbl[vid].port_bm & port_bm)) {
+		pr_err("%s(%d) port(%d) is not in VLAN(%d)\n", __func__, __LINE__, lport, vid);
+		return MV_OK;
+	}
+
+	/* Find VTU entry in SW cache */
+	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+	vtu_entry.vid = vid;
+	rc = mv_switch_vtu_entry_find(&vtu_entry, &found);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_find()\n");
+
+	/* Step 1. Mark the lport as NOT_A_MEMBER. */
+	vtu_entry.vtuData.memberTagP[lport] = NOT_A_MEMBER;
+
+	/* 2. Search whether a secure port is a member of the VLAN */
+	for (port_idx = 0; port_idx < qd_dev->numOfPorts; port_idx++) {
+		if ((vtu_entry.vtuData.memberTagP[port_idx] != NOT_A_MEMBER) &&
+			((sw_port_tbl[port_idx].port_mode == GT_SECURE) ||
+			(sw_port_tbl[port_idx].vlan_blong[vid] == MV_SWITCH_PORT_BELONG))) {
+			is_vlan_member = 1;
+			break;
+	    }
+	}
+
+	/* Update the VTU entry */
+	if (is_vlan_member) {
+		/* Add HW VTU entry */
+		rc = gvtuAddEntry(qd_dev, &vtu_entry);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_find()\n");
+
+		/* Record HW VTU entry info to sw_vlan_tbl */
+		rc = mv_switch_vtu_entry_save(&vtu_entry);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_save()\n");
+
+		/* Delete port from VID DB */
+		sw_vlan_tbl[vid].port_bm &= ~port_bm;
+	} else {
+		/* Delete the VTU entry */
+		rc = gvtuDelEntry(qd_dev, &vtu_entry);
+		SW_IF_ERROR_STR(rc, "failed to call gvtuDelEntry()\n");
+
+		sw_vlan_tbl[vid].port_bm = 0;
+	}
+
+	if (sw_port_tbl[lport].vlan_blong[vid] == MV_SWITCH_PORT_BELONG) {
+		sw_port_tbl[lport].vlan_blong[vid] = MV_SWITCH_PORT_NOT_BELONG;
+		sw_vlan_tbl[vid].egr_mode[lport] = NOT_A_MEMBER;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_vid_get
+*
+* DESCRIPTION:
+*	The API get VID information.
+*
+* INPUTS:
+*	vid       - VLAN ID.
+*
+* OUTPUTS:
+*	vtu_entry - VTU entry.
+*	found     - MV_TRUE, if the appropriate entry exists.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_vid_get(unsigned int vid, GT_VTU_ENTRY *vtu_entry, unsigned int *found)
+{
+	GT_STATUS rc = GT_OK;
+
+	memset(vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+	vtu_entry->vid = vid;
+	rc = gvtuFindVidEntry(qd_dev, vtu_entry, found);
+	SW_IF_ERROR_STR(rc, "failed to call gvtuFindVidEntry()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vid_egress_mode_set
+*
+* DESCRIPTION:
+*	The API sets the egress mode for a member port of a vlan.
+*
+* INPUTS:
+*	lport    - logical switch port ID.
+*       vid      - vlan id.
+*       egr_mode - egress mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*       MEMBER_EGRESS_UNMODIFIED - 0
+*       NOT_A_MEMBER             - 1
+*       MEMBER_EGRESS_UNTAGGED   - 2
+*       MEMBER_EGRESS_TAGGED     - 3
+*
+*******************************************************************************/
+int mv_switch_port_vid_egress_mode_set(unsigned int lport, unsigned short vid, unsigned char egr_mode)
+{
+	GT_STATUS    rc = GT_OK;
+	GT_VTU_ENTRY vtu_entry;
+	GT_BOOL      found = GT_FALSE;
+
+	/* If the port is the member of vlan, set */
+	if (sw_vlan_tbl[vid].port_bm & (1 << lport)) {
+		sw_vlan_tbl[vid].egr_mode[lport] = egr_mode;
+
+		memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+		vtu_entry.vid = vid;
+
+		rc = mv_switch_vtu_entry_find(&vtu_entry, &found);
+		if (rc != GT_OK && rc != GT_NO_SUCH) {
+			pr_err("%s(%d) rc(%d) failed to call mv_switch_vtu_entry_find()\n",
+			       __func__, __LINE__, rc);
+
+			return MV_FAIL;
+		}
+
+		vtu_entry.vtuData.memberTagP[lport] = egr_mode;
+
+		rc = gvtuAddEntry(qd_dev, &vtu_entry);
+		SW_IF_ERROR_STR(rc, "failed to call gvtuAddEntry()\n");
+
+		/* Record HW VT entry info to sw_vlan_tbl */
+		rc = mv_switch_vtu_entry_save(&vtu_entry);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_vtu_entry_save()\n");
+	} else {
+		pr_err("%s(%d) port(%d) is not the member of vlan(%d)\n",
+		       __func__, __LINE__, lport, vid);
+		return MV_FAIL;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_unknown_unicast_flood_set
+*
+* DESCRIPTION:
+*	This routine enable/disable unknown unicast frame egress on a specific port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*	enable  - Enable unknown unicast flooding.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_unknown_unicast_flood_set(unsigned char lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetForwardUnknown(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetForwardUnknown()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_unknown_unicast_flood_get
+*
+* DESCRIPTION:
+*       This routine gets unknown unicast frame egress mode of a specific port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*
+* OUTPUTS:
+*	enable  - Enable unknown unicast flooding.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_unknown_unicast_flood_get(unsigned char lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetForwardUnknown(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetForwardUnknown()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_unknown_multicast_flood_set
+*
+* DESCRIPTION:
+*	This routine enable/disable unknown multicast frame egress on a specific port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*	enable  - Enable unknown multicast flooding.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_unknown_multicast_flood_set(unsigned char lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetDefaultForward(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetDefaultForward()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_unknown_multicast_flood_get
+*
+* DESCRIPTION:
+*	This routine gets unknown multicast frame egress mode of a specific port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*
+* OUTPUTS:
+*	enable  - Enable unknown multicast flooding.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_unknown_multicast_flood_get(unsigned char lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetDefaultForward(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetDefaultForward()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_broadcast_flood_set
+*
+* DESCRIPTION:
+*	This routine decides whether the switch always floods the broadcast
+*	frames to all portsr or uses the multicast egress mode (per port).
+*
+* INPUTS:
+*	enable - enable broadcast flooding regardless the multicast egress mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_broadcast_flood_set(GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gsysSetFloodBC(qd_dev, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gsysSetFloodBC()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_broadcast_flood_get
+*
+* DESCRIPTION:
+*	This routine gets the global mode of broadcast flood.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	enable - always floods the broadcast regardless the multicast egress mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_broadcast_flood_get(GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gsysGetFloodBC(qd_dev, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gsysGetFloodBC()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_count3_get
+*
+* DESCRIPTION:
+*	This function gets all counter 3 of the given port
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*	count - all port counter 3.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Clear on read.
+*******************************************************************************/
+int mv_switch_port_count3_get(unsigned int lport, GT_STATS_COUNTER_SET3 *count)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gstatsGetPortAllCounters3(qd_dev, lport, count);
+	SW_IF_ERROR_STR(rc, "failed to call gstatsGetPortAllCounters3()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_drop_count_get
+*
+* DESCRIPTION:
+*	This function gets the port InDiscards, InFiltered, and OutFiltered counters.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*	count - all port dropped counter.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	Clear on read.
+*******************************************************************************/
+int mv_switch_port_drop_count_get(unsigned int lport, GT_PORT_STAT2 *count)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortCtr2(qd_dev, lport, count);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortCtr2()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_count_clear
+*
+* DESCRIPTION:
+*	This function clean all counters of the given port
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_count_clear(unsigned int lport)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gstatsFlushPort(qd_dev, lport);
+	SW_IF_ERROR_STR(rc, "failed to call gstatsFlushPort()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_count_clear
+*
+* DESCRIPTION:
+*	This function gets all counters of the given port
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_count_clear(void)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gstatsFlushAll(qd_dev);
+	SW_IF_ERROR_STR(rc, "failed to call gstatsFlushAll()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_limit_mode_set
+*
+* DESCRIPTION:
+*	This routine sets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*	mode  - rate control ingress limit mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	GT_LIMT_ALL = 0,        limit and count all frames
+*	GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
+*	GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
+*	GT_LIMIT_BRDCST         limit and count Broadcast frames
+*
+*******************************************************************************/
+int mv_switch_ingr_limit_mode_set(unsigned int lport, GT_RATE_LIMIT_MODE mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = grcSetLimitMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call grcSetLimitMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_limit_mode_get
+*
+* DESCRIPTION:
+*	This routine gets the port's rate control ingress limit mode.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*	mode  - rate control ingress limit mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	GT_LIMT_ALL = 0,        limit and count all frames
+*	GT_LIMIT_FLOOD,         limit and count Broadcast, Multicast and flooded unicast frames
+*	GT_LIMIT_BRDCST_MLTCST, limit and count Broadcast and Multicast frames
+*	GT_LIMIT_BRDCST         limit and count Broadcast frames
+*
+*******************************************************************************/
+int mv_switch_ingr_limit_mode_get(unsigned int lport, GT_RATE_LIMIT_MODE *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = grcGetLimitMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call grcSetLimitMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_police_rate_get
+*
+* DESCRIPTION:
+*	The API gets the ingress policing rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*
+* OUTPUTS:
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_police_rate_get(unsigned int		lport,
+				   GT_PIRL2_COUNT_MODE	*count_mode,
+				   unsigned int		*cir)
+{
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_U32		irl_unit;
+	GT_STATUS	rc = GT_OK;
+
+	/* IRL Unit 0 - bucket to be used (0 ~ 4) */
+	irl_unit =  0;
+	memset(&pirl_2_Data, 0, sizeof(GT_PIRL2_DATA));
+
+	rc = gpirl2ReadResource(qd_dev, lport, irl_unit, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2ReadResource()\n");
+
+	*count_mode	= pirl_2_Data.byteTobeCounted;
+	*cir		= pirl_2_Data.ingressRate;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_egr_rate_limit_set
+*
+* DESCRIPTION:
+*	The API Configures the egress frame rate limit of logical port.
+* INPUTS:
+*	lport - logical switch port ID.
+*	mode  - egress rate limit mode.
+*       rate  - egress rate limit value.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	GT_ERATE_TYPE used kbRate - frame rate valid values are:
+*	7600,..., 9600,
+*	10000, 20000, 30000, 40000, ..., 100000,
+*	110000, 120000, 130000, ..., 1000000.
+*******************************************************************************/
+int mv_switch_egr_rate_limit_set(unsigned int lport, GT_PIRL_ELIMIT_MODE mode, unsigned int rate)
+{
+	GT_ERATE_TYPE	fRate;
+	GT_STATUS	rc = GT_OK;
+
+	fRate.fRate  = rate;
+	fRate.kbRate = rate;
+
+	rc = grcSetELimitMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call grcSetELimitMode()\n");
+
+
+	rc = grcSetEgressRate(qd_dev, lport, &fRate);
+	SW_IF_ERROR_STR(rc, "failed to call grcSetEgressRate()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_egr_rate_limit_get
+*
+* DESCRIPTION:
+*	The API return the egress frame rate limit of logical port
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*	mode  - egress rate limit mode.
+*       rate  - egress rate limit value.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	GT_ERATE_TYPE used kbRate - frame rate valid values are:
+*	7600,..., 9600,
+*	10000, 20000, 30000, 40000, ..., 100000,
+*	110000, 120000, 130000, ..., 1000000.
+*******************************************************************************/
+int mv_switch_egr_rate_limit_get(unsigned int lport, GT_PIRL_ELIMIT_MODE *mode, unsigned int *rate)
+{
+	GT_ERATE_TYPE	fRate;
+	GT_STATUS		rc = GT_OK;
+
+	rc = grcGetELimitMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call grcGetELimitMode()\n");
+
+	rc = grcGetEgressRate(qd_dev, lport, &fRate);
+	SW_IF_ERROR_STR(rc, "failed to call grcGetEgressRate()\n");
+
+	if (mode == GT_PIRL_ELIMIT_FRAME) {
+		/* frame based limit */
+		*rate = fRate.fRate;
+	} else {
+		/* rate based limit */
+		*rate = fRate.kbRate;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_broadcast_rate_get
+*
+* DESCRIPTION:
+*	The API gets the ingress broacast rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*
+* OUTPUTS:
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_broadcast_rate_get(unsigned int		lport,
+				   GT_PIRL2_COUNT_MODE	*count_mode,
+				   unsigned int		*cir)
+{
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_U32		irl_unit;
+	GT_STATUS	rc = GT_OK;
+
+	/* IRL Unit 0 - bucket to be used (0 ~ 4) */
+	irl_unit =  MV_SWITCH_PIRL_RESOURCE_BROADCAST;
+	memset(&pirl_2_Data, 0, sizeof(GT_PIRL2_DATA));
+
+	rc = gpirl2ReadResource(qd_dev, lport, irl_unit, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2ReadResource()\n");
+
+	*count_mode	= pirl_2_Data.byteTobeCounted;
+	*cir		= pirl_2_Data.ingressRate;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_multicast_rate_get
+*
+* DESCRIPTION:
+*	The API gets the ingress broacast rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*
+* OUTPUTS:
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_multicast_rate_get(unsigned int		lport,
+				   GT_PIRL2_COUNT_MODE	*count_mode,
+				   unsigned int		*cir)
+{
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_U32		irl_unit;
+	GT_STATUS	rc = GT_OK;
+
+	/* IRL Unit 0 - bucket to be used (0 ~ 4) */
+	irl_unit =  MV_SWITCH_PIRL_RESOURCE_MULTICAST;
+	memset(&pirl_2_Data, 0, sizeof(GT_PIRL2_DATA));
+
+	rc = gpirl2ReadResource(qd_dev, lport, irl_unit, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2ReadResource()\n");
+
+	*count_mode	= pirl_2_Data.byteTobeCounted;
+	*cir		= pirl_2_Data.ingressRate;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_mirror_set
+*
+* DESCRIPTION:
+*	Set port mirror.
+*
+* INPUTS:
+*	sport  - Source port.
+*	mode   - mirror mode.
+*	enable - enable/disable mirror.
+*	dport  - Destination port.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_mirror_set(unsigned int sport, enum sw_mirror_mode_t mode, GT_BOOL enable, unsigned int dport)
+{
+	GT_STATUS rc = GT_OK;
+
+	if (mode == MV_SWITCH_MIRROR_INGRESS) {
+		if (enable == GT_TRUE) {
+			/* set ingress monitor source */
+			rc = gprtSetIngressMonitorSource(qd_dev, sport, GT_TRUE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetIngressMonitorSource()\n");
+
+			/* set ingress monitor destination */
+			rc = gsysSetIngressMonitorDest(qd_dev, dport);
+			SW_IF_ERROR_STR(rc, "failed to call gsysSetIngressMonitorDest()\n");
+		} else {
+			/*disable ingress monitor source */
+			rc = gprtSetIngressMonitorSource(qd_dev, sport, GT_FALSE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetIngressMonitorSource()\n");
+		}
+	} else if (mode == MV_SWITCH_MIRROR_EGRESS) {
+		if (enable == GT_TRUE) {
+			/* enable egress monitor source */
+			rc = gprtSetEgressMonitorSource(qd_dev, sport, GT_TRUE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetEgressMonitorSource()\n");
+
+			/* set egress monitor destination */
+			rc = gsysSetEgressMonitorDest(qd_dev, dport);
+			SW_IF_ERROR_STR(rc, "failed to call gsysSetEgressMonitorDest()\n");
+		} else {
+			/* disable egress monitor source */
+			rc = gprtSetEgressMonitorSource(qd_dev, sport, GT_FALSE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetEgressMonitorSource()\n");
+		}
+	} else if (mode ==  MV_SWITCH_MIRROR_BOTH) {
+		if (enable == GT_TRUE) {
+			/* enable egress monitor source */
+			rc = gprtSetIngressMonitorSource(qd_dev, sport, GT_TRUE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetIngressMonitorSource()\n");
+
+			/* set ingress monitor destination */
+			rc = gsysSetIngressMonitorDest(qd_dev, dport);
+			SW_IF_ERROR_STR(rc, "failed to call gsysSetIngressMonitorDest()\n");
+
+			/* enable egress monitor source */
+			rc = gprtSetEgressMonitorSource(qd_dev, sport, GT_TRUE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetEgressMonitorSource()\n");
+
+			/* set egress monitor destination */
+			rc = gsysSetEgressMonitorDest(qd_dev, dport);
+			SW_IF_ERROR_STR(rc, "failed to call gsysSetEgressMonitorDest()\n");
+		} else {
+			/*disable ingress monitor source */
+			rc = gprtSetIngressMonitorSource(qd_dev, sport, GT_FALSE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetIngressMonitorSource()\n");
+
+			/* disable egress monitor source */
+			rc = gprtSetEgressMonitorSource(qd_dev, sport, GT_FALSE);
+			SW_IF_ERROR_STR(rc, "failed to call gprtSetEgressMonitorSource()\n");
+		}
+	} else {
+		pr_err("illegal port mirror dir(%d)\n", mode);
+		return MV_FAIL;
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_mirror_get
+*
+* DESCRIPTION:
+*	Get port mirror status.
+*
+* INPUTS:
+*	sport  - Source port.
+*	mode   - mirror mode.
+*
+* OUTPUTS:
+*	enable - enable/disable mirror.
+*	dport  - Destination port.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_mirror_get(unsigned int sport, enum sw_mirror_mode_t mode, GT_BOOL *enable, unsigned int *dport)
+{
+	GT_LPORT port;
+	GT_STATUS rc = GT_OK;
+
+	if (mode == MV_SWITCH_MIRROR_INGRESS) {
+		/* Get ingress monitor source status */
+		rc = gprtGetIngressMonitorSource(qd_dev, (GT_LPORT)sport, enable);
+		SW_IF_ERROR_STR(rc, "failed to call gprtGetIngressMonitorSource()\n");
+
+		/* Get ingress destination port */
+		rc = gsysGetIngressMonitorDest(qd_dev, &port);
+		SW_IF_ERROR_STR(rc, "failed to call gsysGetIngressMonitorDest()\n");
+		*dport = port;
+
+	} else if (mode == MV_SWITCH_MIRROR_EGRESS) {
+		/* Get egress monitor source status */
+		rc = gprtGetEgressMonitorSource(qd_dev, (GT_LPORT)sport, enable);
+		SW_IF_ERROR_STR(rc, "failed to call gprtGetEgressMonitorSource()\n");
+
+		/* Get egress destination port */
+		rc = gsysGetEgressMonitorDest(qd_dev, &port);
+		SW_IF_ERROR_STR(rc, "failed to call gsysGetEgressMonitorDest()\n");
+		*dport = port;
+
+	} else {
+		pr_err("illegal port mirror dir(%d)\n", mode);
+		return MV_FAIL;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_age_time_set
+*
+* DESCRIPTION:
+*	This function sets the MAC address aging time.
+*
+* INPUTS:
+*	time - aging time value.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_age_time_set(unsigned int time)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gfdbSetAgingTimeout(qd_dev, time);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbSetAgingTimeout()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_age_time_get
+*
+* DESCRIPTION:
+*	This function gets the MAC address aging time.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	time - MAC aging time.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_age_time_get(unsigned int *time)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gfdbGetAgingTimeout(qd_dev, (GT_U32 *)time);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbGetAgingTimeout()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mac_learn_disable_set
+*
+* DESCRIPTION:
+*	Enable/disable automatic learning of new source MAC addresses on port
+*	ingress direction.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*	enable - enable/disable MAC learning.
+*		GT_TRUE: disable MAC learning
+*		GT_FALSE: enable MAC learning
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mac_learn_disable_set(unsigned int lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetLearnDisable(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetLearnDisable()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mac_learn_disable_get
+*
+* DESCRIPTION:
+*	Get automatic learning status of new source MAC addresses on port ingress.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable MAC learning.
+*		GT_TRUE: disable MAC learning
+*		GT_FALSE: enable MAC learning
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mac_learn_disable_get(unsigned int lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetLearnDisable(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetLearnDisable()\n");
+
+	return MV_OK;
+}
+#ifdef CONFIG_ARCH_AVANTA_LP
+
+/*******************************************************************************
+* mv_switch_ingr_police_rate_set
+*
+* DESCRIPTION:
+*	The API configures the ingress policing rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_police_rate_set(unsigned int	lport,
+				   GT_PIRL2_COUNT_MODE	count_mode,
+				   unsigned int		cir)
+{
+	GT_U32		irlRes;
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_BOOL		pause_state;
+	GT_STATUS	rc = GT_OK;
+
+	memset(&pirl_2_Data, 0, sizeof(pirl_2_Data));
+
+	irlRes = 0;
+
+	/* configure cir, count_mode */
+	pirl_2_Data.ingressRate		= cir;
+	pirl_2_Data.customSetup.isValid	= GT_FALSE;
+	pirl_2_Data.accountQConf	= GT_FALSE;
+	pirl_2_Data.accountFiltered	= GT_TRUE;
+	pirl_2_Data.mgmtNrlEn		= GT_TRUE;
+	pirl_2_Data.saNrlEn		= GT_FALSE;
+	pirl_2_Data.daNrlEn		= GT_FALSE;
+	pirl_2_Data.samplingMode	= GT_FALSE;
+	pirl_2_Data.actionMode		= PIRL_ACTION_USE_LIMIT_ACTION;
+
+	/* decide which mode to adopt when deal with overload traffic.
+	*  If pause state is ON, select FC mode, otherwize select drop mode.
+	*/
+	rc = mv_phy_port_pause_state_get(lport, &pause_state);
+	SW_IF_ERROR_STR(rc, "failed to call mv_phy_port_pause_state_get()\n");
+	if (pause_state == GT_TRUE)
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_FC;
+	else
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_DROP;
+
+	pirl_2_Data.fcDeassertMode	= GT_PIRL_FC_DEASSERT_EMPTY;
+	pirl_2_Data.bktRateType		= BUCKET_TYPE_TRAFFIC_BASED;
+	pirl_2_Data.priORpt		= GT_TRUE;
+	pirl_2_Data.priMask		= 0;
+	pirl_2_Data.bktTypeMask		= 0x7fff;
+	pirl_2_Data.byteTobeCounted	= count_mode;
+
+	rc = gpirl2WriteResource(qd_dev, lport, irlRes, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2WriteResource()\n");
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mv_switch_ingr_broadcast_rate_set
+*
+* DESCRIPTION:
+*	The API configures the ingress broadcast rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_broadcast_rate_set(unsigned int		lport,
+					GT_PIRL2_COUNT_MODE	count_mode,
+					unsigned int	cir)
+{
+	GT_U32		irlRes;
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_BOOL		pause_state;
+	GT_STATUS	rc = GT_OK;
+
+	memset(&pirl_2_Data, 0, sizeof(pirl_2_Data));
+
+	irlRes = MV_SWITCH_PIRL_RESOURCE_BROADCAST;
+
+	/* configure cir, count_mode */
+	pirl_2_Data.ingressRate		= cir;
+	pirl_2_Data.customSetup.isValid	= GT_FALSE;
+	pirl_2_Data.accountQConf	= GT_FALSE;
+	pirl_2_Data.accountFiltered	= GT_TRUE;
+	pirl_2_Data.mgmtNrlEn		= GT_TRUE;
+	pirl_2_Data.saNrlEn		= GT_FALSE;
+	pirl_2_Data.daNrlEn		= GT_FALSE;
+	pirl_2_Data.samplingMode	= GT_FALSE;
+	pirl_2_Data.actionMode		= PIRL_ACTION_USE_LIMIT_ACTION;
+
+	/* decide which mode to adopt when deal with overload traffic.
+	*  If pause state is ON, select FC mode, otherwize select drop mode.
+	*/
+	rc = mv_phy_port_pause_state_get(lport, &pause_state);
+	SW_IF_ERROR_STR(rc, "failed to call mv_phy_port_pause_state_get()\n");
+	if (pause_state == GT_TRUE)
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_FC;
+	else
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_DROP;
+
+	pirl_2_Data.fcDeassertMode	= GT_PIRL_FC_DEASSERT_EMPTY;
+	pirl_2_Data.bktRateType		= BUCKET_TYPE_TRAFFIC_BASED;
+	pirl_2_Data.priORpt		= GT_TRUE;
+	pirl_2_Data.priMask		= 0;
+	pirl_2_Data.bktTypeMask		= (1 << MV_SWITCH_PIRL_BKTTYPR_BROADCAST_BIT);
+	pirl_2_Data.byteTobeCounted	= count_mode;
+
+	rc = gpirl2WriteResource(qd_dev, lport, irlRes, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2WriteResource()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_ingr_multicast_rate_set
+*
+* DESCRIPTION:
+*	The API configures the ingress broadcast rate for given switch port.
+*
+* INPUTS:
+*	lport      - logical switch port ID.
+*	count_mode - policing rate count mode:
+*			GT_PIRL2_COUNT_FRAME = 0
+*			GT_PIRL2_COUNT_ALL_LAYER1
+*			GT_PIRL2_COUNT_ALL_LAYER2
+*			GT_PIRL2_COUNT_ALL_LAYER3
+*	cir        - committed infomation rate.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_ingr_multicast_rate_set(unsigned int		lport,
+				   GT_PIRL2_COUNT_MODE	count_mode,
+				   unsigned int cir)
+{
+	GT_U32		irlRes;
+	GT_PIRL2_DATA	pirl_2_Data;
+	GT_BOOL		pause_state;
+	GT_STATUS	rc = GT_OK;
+
+	memset(&pirl_2_Data, 0, sizeof(pirl_2_Data));
+
+	irlRes = MV_SWITCH_PIRL_RESOURCE_MULTICAST;
+
+	/* configure cir, count_mode */
+	pirl_2_Data.ingressRate		= cir;
+	pirl_2_Data.customSetup.isValid	= GT_FALSE;
+	pirl_2_Data.accountQConf	= GT_FALSE;
+	pirl_2_Data.accountFiltered	= GT_TRUE;
+	pirl_2_Data.mgmtNrlEn		= GT_TRUE;
+	pirl_2_Data.saNrlEn		= GT_FALSE;
+	pirl_2_Data.daNrlEn		= GT_FALSE;
+	pirl_2_Data.samplingMode	= GT_FALSE;
+	pirl_2_Data.actionMode		= PIRL_ACTION_USE_LIMIT_ACTION;
+
+	/* decide which mode to adopt when deal with overload traffic.
+	*  If pause state is ON, select FC mode, otherwize select drop mode.
+	*/
+	rc = mv_phy_port_pause_state_get(lport, &pause_state);
+	SW_IF_ERROR_STR(rc, "failed to call mv_phy_port_pause_state_get()\n");
+	if (pause_state == GT_TRUE)
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_FC;
+	else
+		pirl_2_Data.ebsLimitAction = ESB_LIMIT_ACTION_DROP;
+
+	pirl_2_Data.fcDeassertMode	= GT_PIRL_FC_DEASSERT_EMPTY;
+	pirl_2_Data.bktRateType		= BUCKET_TYPE_TRAFFIC_BASED;
+	pirl_2_Data.priORpt		= GT_TRUE;
+	pirl_2_Data.priMask		= 0;
+	pirl_2_Data.bktTypeMask		= ((1 << MV_SWITCH_PIRL_BKTTYPR_MULTICAST_BIT)
+		| (1 << MV_SWITCH_PIRL_BKTTYPR_UNKNOWN_MULTICAST_BIT));
+	pirl_2_Data.byteTobeCounted	= count_mode;
+
+	rc = gpirl2WriteResource(qd_dev, lport, irlRes, &pirl_2_Data);
+	SW_IF_ERROR_STR(rc, "failed to call gpirl2WriteResource()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_queue_weight_set
+*
+* DESCRIPTION:
+*	The API configures the weight of a queues for all
+*	Ethernet UNI ports in the integrated switch.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*	queue  - switch queue, ranging from 0 to 3.
+*	weight - weight value per queue (1-8).
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_queue_weight_set(unsigned int lport, unsigned char queue, unsigned char weight)
+{
+	unsigned int len = 0;
+	unsigned int offset = 0;
+	unsigned int idx;
+	GT_QoS_WEIGHT l_weight;
+	GT_STATUS rc = GT_OK;
+
+	/* get weight information at first */
+	rc = gsysGetQoSWeight(qd_dev, &l_weight);
+	SW_IF_ERROR_STR(rc, "failed to call gsysGetQoSWeight()\n");
+
+	offset = MV_SWITCH_MAX_QUEUE_NUM*lport + queue;
+	if (offset >= MAX_QOS_WEIGHTS) {
+		pr_err("%s offset(%d) is out of range\n", __func__, offset);
+		return MV_FAIL;
+	}
+
+	/* Update queue weight */
+	if ((offset+1) <= l_weight.len) {
+		l_weight.queue[offset] = weight;
+		len = l_weight.len;
+	} else {
+		for (idx = l_weight.len; idx < (offset/MV_SWITCH_MAX_QUEUE_NUM+1)*MV_SWITCH_MAX_QUEUE_NUM; idx++) {
+			if (idx == offset)
+				l_weight.queue[idx] = weight;
+			else
+				l_weight.queue[idx] = MV_SWITCH_DEFAULT_WEIGHT;
+		}
+
+		len = (offset/MV_SWITCH_MAX_QUEUE_NUM+1)*MV_SWITCH_MAX_QUEUE_NUM;
+	}
+
+	l_weight.len = len;
+
+	rc = gsysSetQoSWeight(qd_dev, &l_weight);
+	SW_IF_ERROR_STR(rc, "failed to call gsysSetQoSWeight()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_queue_weight_get
+*
+* DESCRIPTION:
+*	The API configures the weight of a queues for all
+*	Ethernet UNI ports in the integrated switch.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*	queue  - switch queue, ranging from 0 to 3.
+*
+* OUTPUTS:
+*	weight - weight value per queue (1-8).
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_queue_weight_get(unsigned int lport, unsigned char queue, unsigned char *weight)
+{
+	GT_QoS_WEIGHT l_weight;
+	unsigned int offset;
+	GT_STATUS rc = GT_OK;
+
+	/* Get QoS queue information */
+	rc = gsysGetQoSWeight(qd_dev, &l_weight);
+	SW_IF_ERROR_STR(rc, "failed to call gsysSetQoSWeight()\n");
+
+	offset = MV_SWITCH_MAX_QUEUE_NUM*lport + queue;
+	if ((offset + 1) > l_weight.len)
+		*weight = 0;
+	else
+		*weight = l_weight.queue[offset];
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_learn2all_enable_set
+*
+* DESCRIPTION:
+*	Enable/disable learn to all devices
+*
+* INPUTS:
+*	enable - enable/disable learn to all devices.
+*		GT_TRUE: disable MAC learning
+*		GT_FALSE: enable MAC learning
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_learn2all_enable_set(GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gsysSetLearn2All(qd_dev, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gsysSetLearn2All(%d)\n", enable);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_learn2all_enable_get
+*
+* DESCRIPTION:
+*	returns if the learn2all bit status
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	enabled - learn2all enabled/disabled
+*		GT_TRUE: learn2all enabled
+*		GT_FALSE: learn2all disabled
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_learn2all_enable_get(GT_BOOL *enabled)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gsysGetLearn2All(qd_dev, enabled);
+	SW_IF_ERROR_STR(rc, "failed to call gsysSetLearn2All()\n");
+
+	return MV_OK;
+}
+#endif
+/*******************************************************************************
+* mv_switch_mac_limit_set
+*
+* DESCRIPTION:
+*	This function limits the number of MAC addresses per lport.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*	mac_num - maximum number of MAC addresses per port (0-255).
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*
+* COMMENTS:
+*	The following care is needed when enabling this feature:
+*		1) disable learning on the ports
+*		2) flush all non-static addresses in the ATU
+*		3) define the desired limit for the ports
+*		4) re-enable learing on the ports
+*******************************************************************************/
+int mv_switch_mac_limit_set(unsigned int lport, unsigned int mac_num)
+{
+	GT_STATUS rc = GT_OK;
+
+	/* define the desired limit for the ports */
+	rc = gfdbSetPortAtuLearnLimit(qd_dev, lport, mac_num);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbSetPortAtuLearnLimit()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mac_limit_get
+*
+* DESCRIPTION
+*	Port's auto learning limit. When the limit is non-zero value, the number
+*	of MAC addresses that can be learned on this lport are limited to the value
+*	specified in this API. When the learn limit has been reached any frame
+*	that ingresses this lport with a source MAC address not already in the
+*	address database that is associated with this lport will be discarded.
+*	Normal auto-learning will resume on the lport as soon as the number of
+*	active unicast MAC addresses associated to this lport is less than the
+*	learn limit.
+*	CPU directed ATU Load, Purge, or Move will not have any effect on the
+*	learn limit.
+*	This feature is disabled when the limit is zero.
+*	The following care is needed when enabling this feature:
+*		1) dsable learning on the ports
+*		2) flush all non-static addresses in the ATU
+*		3) define the desired limit for the ports
+*		4) re-enable learing on the ports
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*
+* OUTPUTS:
+*	mac_num - maximum number of MAC addresses per port (0-255).
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mac_limit_get(unsigned int lport, unsigned int *mac_num)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gfdbGetPortAtuLearnLimit(qd_dev, lport, (GT_U32 *)mac_num);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbGetPortAtuLearnLimit()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mac_addr_add
+*
+* DESCRIPTION:
+*	This function creates a MAC entry in the MAC address table for a
+*	specific lport in the integrated switch
+*
+* INPUTS:
+*	port_bm  - logical switch port bitmap, bit0: switch port 0, bit1: port 1.
+*	mac_addr - 6byte network order MAC source address.
+*	mode     - Static or dynamic mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mac_addr_add(unsigned int port_bm, unsigned char mac_addr[6], unsigned int mode)
+{
+	GT_ATU_ENTRY mac_entry;
+	unsigned int l_port_bm = 0;
+	GT_STATUS    rc = GT_OK;
+	enum sw_mac_addr_type_t type = MV_SWITCH_UNICAST_MAC_ADDR;
+
+	memset(&mac_entry, 0, sizeof(GT_ATU_ENTRY));
+
+	mac_entry.trunkMember			= GT_FALSE;
+	mac_entry.prio				= 0;
+	mac_entry.exPrio.useMacFPri		= 0;
+	mac_entry.exPrio.macFPri		= 0;
+	mac_entry.exPrio.macQPri		= 0;
+	mac_entry.DBNum				= 0;
+	l_port_bm				= port_bm;
+	memcpy(mac_entry.macAddr.arEther, mac_addr, GT_ETHERNET_HEADER_SIZE);
+
+	/* treat broadcast MAC address as multicast one */
+	if (((mac_addr[0] & 0x01) == 0x01) ||
+		((mac_addr[0] == 0x33) && (mac_addr[1] == 0x33))) {
+		type = MV_SWITCH_MULTICAST_MAC_ADDR;
+		l_port_bm |= (1 << qd_dev->cpuPortNum);
+	}
+	mac_entry.portVec = l_port_bm;
+
+	if (type == MV_SWITCH_UNICAST_MAC_ADDR) {
+		if (mode == MV_SWITCH_DYNAMIC_MAC_ADDR)
+			mac_entry.entryState.ucEntryState = GT_UC_DYNAMIC;
+		else
+			mac_entry.entryState.ucEntryState = GT_UC_STATIC;
+	} else {
+		mac_entry.entryState.mcEntryState = GT_MC_STATIC;
+	}
+
+	/* add ATU entry */
+	rc = gfdbAddMacEntry(qd_dev, &mac_entry);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbAddMacEntry()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mac_addr_del
+*
+* DESCRIPTION:
+*	This function removes an existed MAC entry from the MAC address
+*	table in the integrated switch.
+*
+* INPUTS:
+*	lport    - logical switch port ID.
+*       mac_addr - MAC address.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mac_addr_del(unsigned int lport, unsigned char mac_addr[6])
+{
+	GT_ATU_ENTRY mac_entry;
+	GT_BOOL      found;
+	GT_BOOL      mc_addr = GT_FALSE;
+	GT_STATUS    rc = GT_OK;
+
+	/* try to find VTU entry */
+	memset(&mac_entry, 0, sizeof(GT_ATU_ENTRY));
+	memcpy(mac_entry.macAddr.arEther, mac_addr, GT_ETHERNET_HEADER_SIZE);
+	rc = gfdbFindAtuMacEntry(qd_dev, &mac_entry, &found);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbFindAtuMacEntry()\n");
+
+	/* return ok in case no ATU entry is found */
+	if (GT_FALSE == found)
+		return MV_OK;
+
+	/* delete ATU entry */
+	rc = gfdbDelMacEntry(qd_dev, &mac_entry.macAddr);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbDelMacEntry()\n");
+
+	/* treat broadcast MAC address as multicast one */
+	if (((mac_addr[0] & 0x01) == 0x01) ||
+	    ((mac_addr[0] == 0x33) && (mac_addr[1] == 0x33))) {
+		mc_addr = GT_TRUE;
+	}
+
+	/* add ATU again in case there still have other ports */
+	if (((mac_entry.portVec & ~(1 << lport)) && (mc_addr == GT_FALSE)) ||
+	    ((mac_entry.portVec & ~((1 << lport) | (1 << qd_dev->cpuPortNum))) && (mc_addr == GT_TRUE))) {
+		mac_entry.portVec &= ~(1 << lport);
+		rc = gfdbAddMacEntry(qd_dev, &mac_entry);
+		SW_IF_ERROR_STR(rc, "failed to call gfdbAddMacEntry()\n");
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_qos_mode_set()
+*
+* DESCRIPTION:
+*	Configures the scheduling mode per logical port.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*	mode  - scheduler mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_qos_mode_set(unsigned int lport, GT_PORT_SCHED_MODE mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPortSched(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortSched()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_qos_mode_get()
+*
+* DESCRIPTION:
+*	This API gets the scheduling mode per logical port.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*	mode  - scheduler mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_qos_mode_get(unsigned int lport, GT_PORT_SCHED_MODE *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortSched(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortSched()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mtu_set
+*
+* DESCRIPTION:
+*	Set switch MTU size.
+*
+* INPUTS:
+*	mtu - MTU size.
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mtu_set(unsigned int mtu)
+{
+	unsigned int idx;
+	GT_JUMBO_MODE jumbo_mode;
+	GT_STATUS rc = GT_OK;
+
+	/* Set jumbo frames mode */
+	if (mtu < 1522) {
+		pr_err("MTU(%d) will be adjusted to jumbo mode(1522)\n", mtu);
+		jumbo_mode = GT_JUMBO_MODE_1522;
+	} else if (mtu == 1522) {
+		jumbo_mode = GT_JUMBO_MODE_1522;
+	} else if (mtu < 2048) {
+		pr_err("MTU(%d) will be adjusted to jumbo mode(2048)\n", mtu);
+		jumbo_mode = GT_JUMBO_MODE_2048;
+	} else if (mtu == 2048) {
+		jumbo_mode = GT_JUMBO_MODE_2048;
+	} else if (mtu != 10240) {
+		pr_err("MTU(%d) will be adjusted to jumbo mode(10240)\n", mtu);
+		jumbo_mode = GT_JUMBO_MODE_10240;
+	} else {
+		jumbo_mode = GT_JUMBO_MODE_10240;
+	}
+
+	for (idx = 0; idx < qd_dev->numOfPorts; idx++) {
+		/* Set switch MTU */
+		rc = gsysSetJumboMode(qd_dev, idx, jumbo_mode);
+		SW_IF_ERROR_STR(rc, "failed to call gsysSetJumboMode()\n");
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mtu_get
+*
+* DESCRIPTION:
+*	Get switch MTU size.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	mtu - MTU size.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mtu_get(unsigned int *mtu)
+{
+	GT_JUMBO_MODE jumbo_mode;
+	GT_STATUS rc = GT_OK;
+
+	/* Get switch MTU */
+	rc = gsysGetJumboMode(qd_dev, MV_SWITCH_CPU_PORT_NUM, &jumbo_mode);
+	SW_IF_ERROR_STR(rc, "failed to call gsysGetJumboMode()\n");
+
+	/* Convert jumbo frames mode to MTU size */
+	if (jumbo_mode == GT_JUMBO_MODE_1522)
+		*mtu = 1522;
+	else if (jumbo_mode == GT_JUMBO_MODE_2048)
+		*mtu = 2048;
+	else
+		*mtu = 10240;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_link_state_get
+*
+* DESCRIPTION:
+*	The API return realtime port link state of switch logical port.
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state  - realtime port link state.
+*			GT_TRUE: link up
+*			GT_FALSE: link down down
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_link_state_get(unsigned int lport, GT_BOOL *state)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetLinkState(qd_dev, lport, state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetLinkState()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_duplex_state_get
+*
+* DESCRIPTION:
+*	The API return realtime port duplex status of given switch logical port.
+* INPUTS:
+*	lport - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state - duplex state.
+*		GT_FALSE:half deplex mode
+*		GT_TRUE:full deplex mode					.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_duplex_state_get(unsigned int lport, GT_BOOL *state)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetDuplex(qd_dev, lport, state);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetDuplex()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_speed_state_get
+*
+* DESCRIPTION:
+*	The API return realtime port speed mode of given switch logical port.
+* INPUTS:
+*	lport - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	state - speed mode state
+*		0:10M
+*		1:100M
+*		2:1000M
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_speed_state_get(unsigned int lport, GT_PORT_SPEED_MODE *speed)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetSpeedMode(qd_dev, lport, speed);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetSpeedMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_secure_mode_set
+*
+* DESCRIPTION:
+*	Change a port mode in the SW data base and remove it from all VLANs
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_secure_mode_set(unsigned int lport)
+{
+	unsigned int port_bm;
+	unsigned short vlan_idx;
+	GT_STATUS rc = GT_OK;
+
+	sw_port_tbl[lport].port_mode = GT_SECURE;
+
+	port_bm = 1 << lport;
+
+	for (vlan_idx = 0; vlan_idx < MV_SWITCH_MAX_VLAN_NUM; vlan_idx++) {
+		if ((sw_vlan_tbl[vlan_idx].port_bm & port_bm) &&
+		    (sw_port_tbl[lport].vlan_blong[vlan_idx] == MV_SWITCH_PORT_NOT_BELONG)) {
+			rc = mv_switch_port_vid_del(lport, vlan_idx);
+			SW_IF_ERROR_STR(rc, "failed to call mv_switch_port_vid_del()\n");
+
+			sw_vlan_tbl[vlan_idx].egr_mode[lport] = NOT_A_MEMBER;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_fallback_mode_set
+*
+* DESCRIPTION:
+*	Change a port mode in the SW data base and add it to all VLANs
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_fallback_mode_set(unsigned int lport)
+{
+	unsigned int port_bm;
+	unsigned short vlan_idx;
+	GT_STATUS rc = GT_OK;
+
+	sw_port_tbl[lport].port_mode = GT_FALLBACK;
+
+	port_bm = 1 << lport;
+
+	for (vlan_idx = 0; vlan_idx < MV_SWITCH_MAX_VLAN_NUM; vlan_idx++) {
+		/* If a VLAN has been defined (there is a member in the VLAN) and
+		   the specified port is not a member */
+		if (sw_vlan_tbl[vlan_idx].port_bm &&
+		     !(sw_vlan_tbl[vlan_idx].port_bm & port_bm)) {
+			/* Update VTU table */
+			rc = mv_switch_port_vid_add(lport, vlan_idx, MEMBER_EGRESS_UNMODIFIED, false);
+			SW_IF_ERROR_STR(rc, "failed to call mv_switch_port_vid_add()\n");
+
+			sw_vlan_tbl[vlan_idx].port_bm |= port_bm;
+			sw_vlan_tbl[vlan_idx].egr_mode[lport] = MEMBER_EGRESS_UNMODIFIED;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_filter_set
+*
+* DESCRIPTION:
+*	The API sets the filtering mode of a certain lport.
+*	If the lport is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_add_vid API will be allowed to ingress and egress the lport.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*       filter - set to 1 means the lport will drop all packets which are NOT in
+*		 the allowed VID list (built using API tpm_sw_port_add_vid).
+*		 set to 0 - means that the list of VIDs allowed
+*		 per lport has no significance (the list is not deleted).
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_filter_set(unsigned int lport, unsigned char filter)
+{
+	GT_DOT1Q_MODE mode;
+	GT_STATUS rc = GT_OK;
+
+	/* Move port to secure mode and removed from all VLANs */
+	if (filter) {
+		/* The port is already in the secure mode - do noting */
+		if (sw_port_tbl[lport].port_mode == GT_SECURE)
+			return MV_OK;
+
+		rc = mv_switch_port_secure_mode_set(lport);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_port_secure_mode_set()\n");
+		mode = GT_SECURE;
+	} else {
+		/* Port should be moved to the fallback mode and added to all VLANs */
+		if (sw_port_tbl[lport].port_mode == GT_FALLBACK)
+			return MV_OK;
+
+		rc = mv_switch_port_fallback_mode_set(lport);
+		SW_IF_ERROR_STR(rc, "failed to call mv_switch_port_fallback_mode_set()\n");
+		mode = GT_FALLBACK;
+	}
+
+	rc = gvlnSetPortVlanDot1qMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnSetPortVlanDot1qMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_filter_get
+*
+* DESCRIPTION:
+*	The API gets the filtering mode of a certain lport.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*
+* OUTPUTS:
+*       filter - set to 1 means the lport will drop all packets which are NOT in
+*		 the allowed VID list (built using API tpm_sw_port_add_vid).
+*		 set to 0 - means that the list of VIDs allowed
+*		 per lport has no significance (the list is not deleted).
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_filter_get(unsigned int lport, unsigned char *filter)
+{
+	GT_DOT1Q_MODE mode;
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnGetPortVlanDot1qMode(qd_dev, lport, &mode);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnGetPortVlanDot1qMode()\n");
+
+	if (GT_SECURE == mode)
+		*filter = 1;
+	else
+		*filter = 0;
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_mode_set
+*
+* DESCRIPTION:
+*	The API sets the VLAN 802.1q mode of a certain lport.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*       mode   - VLAN 802.1q mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_mode_set(unsigned int lport, GT_DOT1Q_MODE mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnSetPortVlanDot1qMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnSetPortVlanDot1qMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_mode_get
+*
+* DESCRIPTION:
+*	The API gets the VLAN 802.1q mode of a certain lport.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*
+* OUTPUTS:
+*       mode   - VLAN 802.1q mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_mode_get(unsigned int lport, GT_DOT1Q_MODE *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnGetPortVlanDot1qMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnGetPortVlanDot1qMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_mac_filter_mode_set
+*
+* DESCRIPTION: The routine sets MAC filter mode
+*
+* INPUTS:
+*	lport   - switch port
+*	mode   - MAC filter mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns MV_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_switch_port_mac_filter_mode_set(unsigned int	lport,
+				    GT_SA_FILTERING	mode)
+
+{
+	int rc = MV_OK;
+
+	/* set filter mode */
+	rc = gprtSetSAFiltering(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "fail to set filter port(%d) mode(%d)\n", lport, mode);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_switch_port_mac_filter_mode_get
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	lport   - switch lport
+*
+* OUTPUTS:
+*	mode   - MAC filter mode
+*
+* RETURNS:
+*	On success, the function returns MV_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_switch_port_mac_filter_mode_get(unsigned int	lport,
+				    GT_SA_FILTERING	*mode)
+{
+	int rc = MV_OK;
+
+	/* set filter mode */
+	rc = gprtGetSAFiltering(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "fail to get filtering mode of port(%d)\n", lport);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_switch_port_mac_filter_entry_add
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	lport    - switch lport
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns MV_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_switch_port_mac_filter_entry_add(unsigned int	lport,
+				     unsigned char		*mac,
+				     unsigned short		vlan,
+				     GT_SA_FILTERING		mode)
+{
+	int rc = MV_OK;
+	unsigned int port_bm;
+
+	if (GT_SA_DROP_ON_LOCK == mode)
+		port_bm = (1 << lport);
+	else if (GT_SA_DROP_ON_UNLOCK == mode || GT_SA_DROP_TO_CPU == mode)
+		port_bm = 0;
+	else
+		return MV_OK;
+
+	rc = mv_switch_mac_addr_add(port_bm, mac, MV_SWITCH_STATIC_MAC_ADDR);
+	SW_IF_ERROR_STR(rc, "fail to add filtering addr of port(%d)\n", lport);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_switch_port_mac_filter_entry_del
+*
+* DESCRIPTION: The routine deletes MAC address filter entry
+*
+* INPUTS:
+*	lport    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns MV_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_switch_port_mac_filter_entry_del(unsigned int	lport,
+				     unsigned char		*mac,
+				     unsigned short		vlan,
+				     GT_SA_FILTERING		mode)
+{
+	int rc = MV_OK;
+
+	rc = mv_switch_mac_addr_del(lport, mac);
+	SW_IF_ERROR_STR(rc, "fail to del filtering addr of port(%d)\n", lport);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_set
+*
+* DESCRIPTION:
+*	This routine sets the port VLAN group port membership list.
+*
+* INPUTS:
+*	lport    - logical switch port ID.
+*	mem_port - array of logical ports in the same vlan.
+*	mem_num  - number of members in memPorts array
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_set(unsigned int lport, GT_LPORT mem_port[], unsigned int mem_num)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnSetPortVlanPorts(qd_dev, (GT_LPORT)lport, mem_port, (unsigned char)mem_num);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnSetPortVlanPorts()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_vlan_get
+*
+* DESCRIPTION:
+*	This routine gets the port VLAN group port membership list.
+*
+* INPUTS:
+*	lport    - logical switch port ID.
+*
+* OUTPUTS:
+*	mem_port - array of logical ports in the same vlan.
+*	mem_num  - number of members in memPorts array
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_vlan_get(unsigned int lport, GT_LPORT mem_port[], unsigned int *mem_num)
+{
+	GT_U8 num;
+	GT_STATUS rc = GT_OK;
+
+	rc = gvlnGetPortVlanPorts(qd_dev, lport, mem_port, &num);
+	SW_IF_ERROR_STR(rc, "failed to call gvlnGetPortVlanPorts()\n");
+	*mem_num = num;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mh_mode_set
+*
+* DESCRIPTION:
+*	This routine enables/disables ingress and egress header mode of switch port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*	enable  - enable/disable marvell header.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mh_mode_set(unsigned char lport, GT_BOOL enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetHeaderMode(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetHeaderMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_mh_mode_get
+*
+* DESCRIPTION:
+*	This routine gets ingress and egress header mode of switch port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*
+* OUTPUTS:
+*	enable  - enable/disable marvell header.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_mh_mode_get(unsigned char lport, GT_BOOL *enable)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetHeaderMode(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetHeaderMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_frame_mode_set
+*
+* DESCRIPTION:
+*	This routine sets the frame mode.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*	mode  - frame mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_frame_mode_set(unsigned char lport, GT_FRAME_MODE mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetFrameMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetFrameMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_frame_mode_get
+*
+* DESCRIPTION:
+*	This routine gets the frame mode.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*
+* OUTPUTS:
+*	mode   - frame mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_frame_mode_get(unsigned char lport, GT_FRAME_MODE *mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetFrameMode(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetFrameMode()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_etype_set
+*
+* DESCRIPTION:
+*	This routine sets ethernet type.
+*
+* INPUTS:
+*	lport - logical switch port ID.
+*	etype - Ethernet type.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_etype_set(unsigned char lport, unsigned short etype)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtSetPortEType(qd_dev, lport, etype);
+	SW_IF_ERROR_STR(rc, "failed to call gprtSetPortEType()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_etype_get
+*
+* DESCRIPTION:
+*	This routine gets the frame mode.
+*
+* INPUTS:
+*	lport  - logical switch port ID.
+*
+* OUTPUTS:
+*	etype - Ethernet type.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_etype_get(unsigned char lport, unsigned short *etype)
+{
+	GT_ETYPE l_etype;
+	GT_STATUS rc = GT_OK;
+
+	rc = gprtGetPortEType(qd_dev, lport, &l_etype);
+	SW_IF_ERROR_STR(rc, "failed to call gprtGetPortEType()\n");
+	*etype = (unsigned short)l_etype;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_preamble_set
+*
+* DESCRIPTION:
+*	This routine sets preamble of a switch port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*	preamble - preamble length.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_preamble_set(unsigned char lport, unsigned short preamble)
+{
+	unsigned short data;
+	GT_STATUS rc = GT_OK;
+
+	rc = mv_switch_mii_write(qd_dev, 3, 26, preamble);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_set_port_reg()\n");
+
+	mvOsDelay(10);
+
+	data = 0xb002 | (lport << 8);
+	rc = mv_switch_mii_write(qd_dev, 2, 26, data);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_set_port_reg()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_preamble_get
+*
+* DESCRIPTION:
+*	This routine gets preamble of a switch port.
+*
+* INPUTS:
+*	lport   - logical switch port ID.
+*
+* OUTPUTS:
+*	preamble - preamble length.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_preamble_get(unsigned char lport, unsigned short *preamble)
+{
+	unsigned int data;
+	GT_STATUS rc = GT_OK;
+
+	data = 0xc002 | (lport << 8);
+	rc = mv_switch_mii_write(qd_dev, 2, 26, data);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_mii_read()\n");
+
+	mvOsDelay(10);
+
+	rc = mv_switch_mii_read(qd_dev, 3, 26, &data);
+	SW_IF_ERROR_STR(rc, "failed to call mv_switch_mii_read()\n");
+
+	*preamble = data;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_atu_next_entry_get
+*
+* DESCRIPTION:
+*	This function get next FDB entry.
+*
+* INPUTS:
+*	atu_entry - ATU entry
+*
+* OUTPUTS:
+*	atu_entry - ATU entry
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_atu_next_entry_get(GT_ATU_ENTRY *atu_entry)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gfdbGetAtuEntryNext(qd_dev, atu_entry);
+
+	if (rc == GT_OK)
+		return MV_OK;
+	else
+		return MV_FAIL;
+}
+
+/*******************************************************************************
+* mv_switch_vtu_flush
+*
+* DESCRIPTION:
+*	Flush VTU on the Switch
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_vtu_flush(void)
+{
+	unsigned int lport;
+	GT_STATUS rc = GT_OK;
+
+	rc = gvtuFlush(qd_dev);
+	SW_IF_ERROR_STR(rc, "failed to call gvtuFlush()\n");
+
+	memset(sw_vlan_tbl, 0, sizeof(sw_vlan_tbl));
+
+	for (lport = 0; lport < qd_dev->numOfPorts; lport++)
+		memset(&(sw_port_tbl[lport].vlan_blong), 0, sizeof(sw_port_tbl[lport].vlan_blong));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_atu_flush
+*
+* DESCRIPTION:
+*	Flush ATU on the Switch
+*
+* INPUTS:
+*	flush_cmd - flush command
+*	db_num    - ATU DB Num, only 0 should be used, since there is only one ATU DB right now.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_atu_flush(GT_FLUSH_CMD flush_cmd, unsigned short db_num)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gfdbFlushInDB(qd_dev, flush_cmd, db_num);
+	SW_IF_ERROR_STR(rc, "failed to call gfdbFlushInDB()\n");
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_link_set
+*
+* DESCRIPTION:
+*       This routine will force given switch port to be linked.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable port force link.
+*	value  - force link up or down
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_link_set(unsigned int lport, GT_BOOL enable, GT_BOOL value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsSetForcedLink(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetForcedLink()\n");
+
+	rc = gpcsSetLinkValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetLinkValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_link_get
+*
+* DESCRIPTION:
+*       This routine gets the force link state of given switch port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable port force link.
+*	value  - force link up or down
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_link_get(unsigned int lport, GT_BOOL *enable, GT_BOOL *value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsGetForcedLink(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedLink()\n");
+
+	rc = gpcsGetLinkValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetLinkValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_fc_set
+*
+* DESCRIPTION:
+*	This routine will set forced flow control state and value.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable forced flow control.
+*	value  - force flow control value, enable flow control or disable it.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_fc_set(unsigned int lport, GT_BOOL enable, GT_BOOL value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsSetForcedFC(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetForcedFC()\n");
+
+	rc = gpcsSetFCValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetFCValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_fc_get
+*
+* DESCRIPTION:
+*	This routine will get forced flow control state and value.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable forced flow control.
+*	value  - force flow control value, enable flow control or disable it.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_fc_get(unsigned int lport, GT_BOOL *enable, GT_BOOL *value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsGetForcedFC(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedFC()\n");
+
+	rc = gpcsGetFCValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetFCValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_speed_set
+*
+* DESCRIPTION:
+*       This routine will force given switch port to work at specific speed.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable port force speed.
+*	mode   - speed mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_speed_set(unsigned int lport, GT_BOOL enable, unsigned int mode)
+{
+	GT_PORT_FORCED_SPEED_MODE l_mode;
+	GT_STATUS rc = GT_OK;
+
+	if (GT_FALSE == enable)
+		l_mode = PORT_DO_NOT_FORCE_SPEED;
+	else
+		l_mode = (GT_PORT_FORCED_SPEED_MODE)mode;
+
+	rc = gpcsSetForceSpeed(qd_dev, lport, l_mode);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetForceSpeed()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_speed_get
+*
+* DESCRIPTION:
+*       This routine gets the force speed state of given switch port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable port force speed.
+*	mode   - speed mode.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_speed_get(unsigned int lport, GT_BOOL *enable, unsigned int *mode)
+{
+	GT_PORT_FORCED_SPEED_MODE l_mode;
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsGetForceSpeed(qd_dev, lport, &l_mode);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForceSpeed()\n");
+
+	if (PORT_DO_NOT_FORCE_SPEED == l_mode) {
+		*enable = GT_FALSE;
+		*mode   = PORT_FORCE_SPEED_1000_MBPS; /* do not have mean in case the force is disabled */
+	} else {
+		*enable = GT_TRUE;
+		*mode   = (unsigned int)l_mode;
+	}
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_duplex_set
+*
+* DESCRIPTION:
+*       This routine will force given switch port w/ duplex mode.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*	enable - enable/disable port force duplex.
+*	value  - half or full duplex mode
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_duplex_set(unsigned int lport, GT_BOOL enable, GT_BOOL value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsSetForcedDpx(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetForcedDpx()\n");
+
+	rc = gpcsSetDpxValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsSetDpxValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_force_duplex_get
+*
+* DESCRIPTION:
+*       This routine gets the force duplex state of given switch port.
+*
+* INPUTS:
+*	lport  - logical switch PHY port ID.
+*
+* OUTPUTS:
+*	enable - enable/disable port force duplex.
+*	value  - half or full duplex mode
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+int mv_switch_port_force_duplex_get(unsigned int lport, GT_BOOL *enable, GT_BOOL *value)
+{
+	GT_STATUS rc = GT_OK;
+
+	rc = gpcsGetForcedDpx(qd_dev, lport, enable);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedDpx()\n");
+
+	rc = gpcsGetDpxValue(qd_dev, lport, value);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetDpxValue()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_port_num_get
+*
+* DESCRIPTION:
+*	This routine will get total switch port number.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success return MV_OK.
+*	On error different types are returned according to the case.
+*******************************************************************************/
+unsigned int mv_switch_port_num_get(void)
+{
+	return qd_dev->numOfPorts;
+}
+
+/*******************************************************************************
+* mv_switch_qd_dev_get
+*
+* DESCRIPTION:
+*	This routine gets QA dev.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	QA dev.
+*******************************************************************************/
+GT_QD_DEV *mv_switch_qd_dev_get(void)
+{
+	return qd_dev;
+}
+
+/*******************************************************************************
+* mv_switch_vtu_shadow_dump
+*
+* DESCRIPTION:
+*	This routine dumps the VTU shadow.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*
+*******************************************************************************/
+int mv_switch_vtu_shadow_dump(void)
+{
+	unsigned int vid;
+	unsigned int num = 0;
+	unsigned int port_idx;
+	GT_VTU_ENTRY *vtu_entry;
+	pr_err("switch VTU shadow\n\n");
+
+	for (vid = 0; vid < MV_SWITCH_MAX_VLAN_NUM; vid++) {
+		if (sw_vlan_tbl[vid].port_bm) {
+			vtu_entry = &sw_vlan_tbl[vid].vtu_entry;
+			pr_err("DBNum:%i, VID:%i port_bm:0x%02x,\n",
+				vtu_entry->DBNum, vtu_entry->vid, sw_vlan_tbl[vid].port_bm);
+			pr_err("Tag Mode: ");
+			for (port_idx = 0; port_idx < MV_SWITCH_MAX_PORT_NUM; port_idx++)
+				pr_err("port(%d):%d; ", port_idx, sw_vlan_tbl[vid].egr_mode[port_idx]);
+			pr_err("\n");
+
+			pr_err("vidPriOverride(%d), vidPriority(%d), sid(%d), vidPolicy(%d), useVIDFPri(%d), vidFPri(%d), useVIDQPri(%d), vidQPri(%d), vidNRateLimit(%d)\n",
+				vtu_entry->vidPriOverride,
+				vtu_entry->vidPriority,
+				vtu_entry->sid,
+				vtu_entry->vidPolicy,
+				vtu_entry->vidExInfo.useVIDFPri,
+				vtu_entry->vidExInfo.vidFPri,
+				vtu_entry->vidExInfo.useVIDQPri,
+				vtu_entry->vidExInfo.vidQPri,
+				vtu_entry->vidExInfo.vidNRateLimit);
+			num++;
+		}
+	}
+	pr_err("\nTag mode 0: egress unmodified, 1:port not in VLAN, 2:egress untagged, 3:egress tagged\n");
+	pr_err("Total switch VLAN number:%d\n", num);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_vlan_tunnel_set
+*
+* DESCRIPTION:
+*	This routine set VLAN tunnel mode of switch port.
+*
+* INPUTS:
+*	lport  - switch port
+*       mode   - vlan tunnel mode, enable or disable
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*
+*******************************************************************************/
+int mv_switch_vlan_tunnel_set(unsigned int lport, GT_BOOL mode)
+{
+	GT_STATUS rc = GT_OK;
+
+	/* check qd_dev init or not */
+	if (qd_dev == NULL) {
+		rc = MV_ERROR;
+		SW_IF_ERROR_STR(rc, "qd_dev not initialized, call mv_switch_load() first\n");
+	}
+
+	rc = gprtSetVlanTunnel(qd_dev, lport, mode);
+	SW_IF_ERROR_STR(rc, "failed to call gpcsGetForcedDpx()\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mv_switch_cpu_port_get
+*
+* DESCRIPTION:
+*	This routine get cpu port of swicth.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	cpu_port - swicth CPU port configured.
+*
+* RETURNS:
+*
+*******************************************************************************/
+int mv_switch_cpu_port_get(unsigned int *cpu_port)
+{
+	GT_STATUS rc = GT_OK;
+
+	if (cpu_port == NULL)
+		return MV_BAD_VALUE;
+
+	/* check qd_dev init or not */
+	if (qd_dev == NULL) {
+		rc = MV_ERROR;
+		SW_IF_ERROR_STR(rc, "qd_dev not initialized, call mv_switch_load() first\n");
+	}
+
+	*cpu_port = qd_dev->cpuPortNum;
+
+	return MV_OK;
+}
+
 static int mv_switch_probe(struct platform_device *pdev)
 {
 	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index 130a2ff..806ba88 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -29,10 +29,24 @@ disclaimer.
 #define __mv_switch_h__
 
 #include "mv802_3.h"
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+#include "msApiTypes.h"
+#include "msApiDefs.h"
+#endif
 #include "mv_mux_netdev.h"
 
 #define MV_SWITCH_DB_NUM			16
 
+/*TPM start*/
+#define MV_SWITCH_PORT_NOT_BELONG		(0)	/* VLAN does not belong to port		*/
+#define MV_SWITCH_PORT_BELONG			(1)	/* VLAN belong to port			*/
+#define MV_SWITCH_MAX_VLAN_NUM			(4096)	/* Maximum switch VLAN number		*/
+#define MV_SWITCH_MAX_PORT_NUM			(7)	/* Maximum switch port number		*/
+#define MV_SWITCH_MAX_QUEUE_NUM			(4)	/* Maximum switch queue number per port	*/
+#define MV_SWITCH_CPU_PORT_NUM			(6)	/* Switch port connected to CPU		*/
+#define MV_SWITCH_DEFAULT_WEIGHT		(2)	/* Switch default queue weight		*/
+/*TPM end*/
+
 #define MV_SWITCH_PHY_ACCESS			1
 #define MV_SWITCH_PORT_ACCESS			2
 #define MV_SWITCH_GLOBAL_ACCESS			3
@@ -43,6 +57,66 @@ disclaimer.
 #define MV_SWITCH_GROUP_VLAN_ID(grp)       (((grp) + 1) << 8)
 #define MV_SWITCH_VLAN_TO_GROUP(vid)       ((((vid) & 0xf00) >> 8) - 1)
 
+#define MV_SWITCH_PIRL_BKTTYPR_UNKNOWN_MULTICAST_BIT    1
+#define MV_SWITCH_PIRL_BKTTYPR_BROADCAST_BIT		2
+#define MV_SWITCH_PIRL_BKTTYPR_MULTICAST_BIT		3
+
+#define MV_SWITCH_PIRL_RESOURCE_BROADCAST    1
+#define MV_SWITCH_PIRL_RESOURCE_MULTICAST    2
+
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+/*TPM start*/
+#define SW_IF_NULL(ptr) { \
+	if (ptr == NULL) {\
+		pr_err("(error) %s(%d) recvd NULL pointer\n", __func__, __LINE__);\
+		return MV_FAIL;\
+	} \
+}
+#define SW_IF_ERROR_STR(rc, format, ...) { \
+	if (rc) {\
+		pr_err("(error) %s(%d) (rc=%d): "format, __func__, __LINE__, rc, ##__VA_ARGS__);\
+		return MV_FAIL;\
+	} \
+}
+
+/* port mirror direction */
+enum sw_mirror_mode_t {
+	MV_SWITCH_MIRROR_INGRESS,
+	MV_SWITCH_MIRROR_EGRESS,
+	MV_SWITCH_MIRROR_BOTH
+};
+
+
+/* operations requested by switch device from mux device */
+struct mux_device_ops {
+	int	(*update_link)(void *cookie, int link_up);
+};
+
+/* port mirror direction */
+enum sw_mac_addr_type_t {
+	MV_SWITCH_ALL_MAC_ADDR,
+	MV_SWITCH_UNICAST_MAC_ADDR,
+	MV_SWITCH_MULTICAST_MAC_ADDR,
+	MV_SWITCH_DYNAMIC_MAC_ADDR,
+	MV_SWITCH_STATIC_MAC_ADDR
+};
+
+/* logical port VLAN information */
+struct sw_port_info_t {
+	GT_DOT1Q_MODE	port_mode;
+	unsigned int	vlan_blong[MV_SWITCH_MAX_VLAN_NUM];
+};
+
+/* VLAN information */
+struct sw_vlan_info_t {
+	unsigned int	port_bm;				/* bitmap of the ports in this VLAN */
+	unsigned char	egr_mode[MV_SWITCH_MAX_PORT_NUM];	/* egress mode of each port         */
+	GT_VTU_ENTRY	vtu_entry;				/* Add this member to record HW VT info to SW table */
+};
+/*TPM end*/
+#endif
+/*unsigned int	mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);*/
 void mv_switch_interrupt_mask(void);
 void mv_switch_interrupt_unmask(void);
 void mv_switch_interrupt_clear(void);
@@ -56,6 +130,7 @@ int     mv_switch_port_based_vlan_set(unsigned int ports_mask, int set_cpu_port)
 int     mv_switch_vlan_in_vtu_set(unsigned short vlan_id, unsigned short db_num, unsigned int ports_mask);
 int     mv_switch_atu_db_flush(int db_num);
 int     mv_switch_vlan_set(u16 vlan_grp_id, u16 port_map);
+int mv_switch_promisc_set(int db, u8 promisc_on);
 
 int     mv_switch_reg_read(int port, int reg, int type, MV_U16 *value);
 int     mv_switch_reg_write(int port, int reg, int type, MV_U16 value);
@@ -78,7 +153,102 @@ int		mv_switch_group_enable(int db);
 int		mv_switch_group_disable(int db);
 int		mv_switch_link_status_get(int db);
 int		mv_switch_group_cookie_set(int db, void *cookie);
+int		mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac);
 int		mv_switch_mac_addr_set(int db, unsigned char *mac_addr, unsigned char op);
 int		mv_switch_mux_ops_set(const struct mv_switch_mux_ops *mux_ops_ptr);
-int		mv_switch_promisc_set(int db, u8 promisc_on);
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+/*TPM start*/
+int mv_switch_mac_update(int db, unsigned char *old_mac, unsigned char *new_mac);
+int mv_switch_port_discard_tag_set(unsigned int lport, GT_BOOL mode);
+int mv_switch_port_discard_tag_get(unsigned int lport, GT_BOOL *mode);
+int mv_switch_port_discard_untag_set(unsigned int lport, GT_BOOL mode);
+int mv_switch_port_discard_untag_get(unsigned int lport, GT_BOOL *mode);
+int mv_switch_port_def_vid_set(unsigned int lport, unsigned short vid);
+int mv_switch_port_def_vid_get(unsigned int lport, unsigned short *vid);
+int mv_switch_port_def_pri_set(unsigned int lport, unsigned char pri);
+int mv_switch_port_def_pri_get(unsigned int lport, unsigned char *pri);
+int mv_switch_port_vid_add(unsigned int lport, unsigned short vid, unsigned char egr_mode, bool belong);
+int mv_switch_port_vid_del(unsigned int lport, unsigned short vid);
+int mv_switch_vid_get(unsigned int vid, GT_VTU_ENTRY *vtu_entry, unsigned int *found);
+int mv_switch_port_vid_egress_mode_set(unsigned int lport, unsigned short vid, unsigned char egr_mode);
+int mv_switch_unknown_unicast_flood_set(unsigned char lport, GT_BOOL enable);
+int mv_switch_unknown_unicast_flood_get(unsigned char lport, GT_BOOL *enable);
+int mv_switch_unknown_multicast_flood_set(unsigned char lport, GT_BOOL enable);
+int mv_switch_unknown_multicast_flood_get(unsigned char lport, GT_BOOL *enable);
+int mv_switch_broadcast_flood_set(GT_BOOL enable);
+int mv_switch_broadcast_flood_get(GT_BOOL *enable);
+int mv_switch_port_count3_get(unsigned int lport, GT_STATS_COUNTER_SET3 *count);
+int mv_switch_port_drop_count_get(unsigned int lport, GT_PORT_STAT2 *count);
+int mv_switch_port_count_clear(unsigned int lport);
+int mv_switch_count_clear(void);
+int mv_switch_ingr_limit_mode_set(unsigned int lport, GT_RATE_LIMIT_MODE mode);
+int mv_switch_ingr_limit_mode_get(unsigned int lport, GT_RATE_LIMIT_MODE *mode);
+int mv_switch_ingr_police_rate_set(unsigned int	lport,
+					GT_PIRL2_COUNT_MODE	count_mode,
+					unsigned int		cir);
+int mv_switch_ingr_police_rate_get(unsigned int		lport,
+				   GT_PIRL2_COUNT_MODE	*count_mode,
+				   unsigned int		*cir);
+int mv_switch_egr_rate_limit_set(unsigned int lport, GT_PIRL_ELIMIT_MODE mode, unsigned int rate);
+int mv_switch_egr_rate_limit_get(unsigned int lport, GT_PIRL_ELIMIT_MODE *mode, unsigned int *rate);
+int mv_switch_ingr_broadcast_rate_set(unsigned int lport, GT_PIRL2_COUNT_MODE count_mode, unsigned int cir);
+int mv_switch_ingr_broadcast_rate_get(unsigned int lport, GT_PIRL2_COUNT_MODE *count_mode, unsigned int *cir);
+int mv_switch_ingr_multicast_rate_set(unsigned int lport, GT_PIRL2_COUNT_MODE count_mode, unsigned int cir);
+int mv_switch_ingr_multicast_rate_get(unsigned int lport, GT_PIRL2_COUNT_MODE *count_mode, unsigned int *cir);
+int mv_switch_port_mirror_set(unsigned int sport, enum sw_mirror_mode_t mode, GT_BOOL enable, unsigned int dport);
+int mv_switch_port_mirror_get(unsigned int sport, enum sw_mirror_mode_t mode, GT_BOOL *enable, unsigned int *dport);
+int mv_switch_age_time_set(unsigned int time);
+int mv_switch_age_time_get(unsigned int *time);
+int mv_switch_mac_learn_disable_set(unsigned int lport, GT_BOOL enable);
+int mv_switch_mac_learn_disable_get(unsigned int lport, GT_BOOL *enable);
+int mv_switch_learn2all_enable_set(GT_BOOL enable);
+int mv_switch_learn2all_enable_get(GT_BOOL *enable);
+int mv_switch_mac_limit_set(unsigned int lport, unsigned int mac_num);
+int mv_switch_mac_limit_get(unsigned int lport, unsigned int *mac_num);
+int mv_switch_mac_addr_add(unsigned int port_bm, unsigned char mac_addr[6], unsigned int mode);
+int mv_switch_mac_addr_del(unsigned int lport, unsigned char mac_addr[6]);
+int mv_switch_port_qos_mode_set(unsigned int lport, GT_PORT_SCHED_MODE mode);
+int mv_switch_port_qos_mode_get(unsigned int lport, GT_PORT_SCHED_MODE *mode);
+int mv_switch_queue_weight_set(unsigned int lport, unsigned char queue, unsigned char weight);
+int mv_switch_queue_weight_get(unsigned int lport, unsigned char queue, unsigned char *weight);
+int mv_switch_mtu_set(unsigned int mtu);
+int mv_switch_mtu_get(unsigned int *mtu);
+int mv_switch_link_state_get(unsigned int lport, GT_BOOL *state);
+int mv_switch_duplex_state_get(unsigned int lport, GT_BOOL *state);
+int mv_switch_speed_state_get(unsigned int lport, GT_PORT_SPEED_MODE *speed);
+int mv_switch_port_vlan_filter_set(unsigned int lport, unsigned char filter);
+int mv_switch_port_vlan_filter_get(unsigned int lport, unsigned char *filter);
+int mv_switch_port_vlan_mode_set(unsigned int lport, GT_DOT1Q_MODE mode);
+int mv_switch_port_vlan_mode_get(unsigned int lport, GT_DOT1Q_MODE *mode);
+int mv_switch_port_mac_filter_mode_set(unsigned int lport, GT_SA_FILTERING mode);
+int mv_switch_port_mac_filter_mode_get(unsigned int lport, GT_SA_FILTERING *mode);
+int mv_switch_port_mac_filter_entry_add(unsigned int lport, unsigned char *mac,
+	unsigned short vlan, GT_SA_FILTERING mode);
+int mv_switch_port_mac_filter_entry_del(unsigned int lport, unsigned char *mac,
+	unsigned short	vlan, GT_SA_FILTERING mode);
+int mv_switch_port_vlan_set(unsigned int lport, GT_LPORT mem_port[], unsigned int mem_num);
+int mv_switch_port_vlan_get(unsigned int lport, GT_LPORT mem_port[], unsigned int *mem_num);
+int mv_switch_mh_mode_set(unsigned char lport, GT_BOOL enable);
+int mv_switch_mh_mode_get(unsigned char lport, GT_BOOL *enable);
+int mv_switch_frame_mode_set(unsigned char lport, GT_FRAME_MODE mode);
+int mv_switch_frame_mode_get(unsigned char lport, GT_FRAME_MODE *mode);
+int mv_switch_etype_set(unsigned char lport, unsigned short etype);
+int mv_switch_etype_get(unsigned char lport, unsigned short *etype);
+int mv_switch_port_preamble_set(unsigned char lport, unsigned short preamble);
+int mv_switch_port_preamble_get(unsigned char lport, unsigned short *preamble);
+int mv_switch_port_force_speed_set(unsigned int lport, GT_BOOL enable, unsigned int mode);
+int mv_switch_port_force_speed_get(unsigned int lport, GT_BOOL *enable, unsigned int *mode);
+int mv_switch_port_force_duplex_set(unsigned int lport, GT_BOOL enable, GT_BOOL value);
+int mv_switch_port_force_duplex_get(unsigned int lport, GT_BOOL *enable, GT_BOOL *value);
+int mv_switch_atu_next_entry_get(GT_ATU_ENTRY *atu_entry);
+int mv_switch_vtu_flush(void);
+int mv_switch_atu_flush(GT_FLUSH_CMD flush_cmd, unsigned short db_num);
+unsigned int mv_switch_port_num_get(void);
+GT_QD_DEV *mv_switch_qd_dev_get(void);
+int mv_switch_vtu_shadow_dump(void);
+int mv_switch_vlan_tunnel_set(unsigned int lport, GT_BOOL mode);
+int mv_switch_cpu_port_get(unsigned int *cpu_port);
+/*TPM end*/
+#endif
 #endif /* __mv_switch_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig
new file mode 100644
index 0000000..320237c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Kconfig
@@ -0,0 +1,39 @@
+menu "SoC TPMv2 support"
+depends on MV_INCLUDE_TPM
+
+config  MV_TPM
+        tristate "Support for Marvell TPM Driver"
+        default y
+        ---help---
+        Add TPM (Traffic Processor Manager) support,
+        which provides a set of high level APIs over PPv2, based
+        on IP packet fields value to create/delete hardware
+        forwarding rules for routing and bridging traffic.
+
+comment "TPM Driver Options"
+depends on MV_TPM
+
+config  MV_TPM_SFS_2_IOCTL
+        bool "Support for debugging ioctl API via sysfs interface"
+        depends on MV_TPM
+        default N
+        ---help---
+        TPM module has many sysfs commands for each user API, which
+        are used for QA to test, or customer to try it. Also, TPM has
+        IOCTL for user in user space, when MV_TPM_SFS_2_IOCTL is
+        configured, TPM API sysfs command is passed to user space,
+        and go back to Kernel space with IOCTL, this way user space
+        IOCTL could be tested by QA.
+
+config  MV_TPM_C3_SEARCH_DEPTH
+        int "C3 maximum cuckoo search depth"
+        depends on MV_TPM
+        default 3
+        ---help---
+        Defines how deep the cuckoo search will go, when adding a C3
+        entry. Since C3 engine use hash to get the hardware index,
+        there might be the possibility that two entries result in
+        the same index, so it could be rearraged by cuckoo to put
+        these confict entries in different sections of C3 engine.
+
+endmenu
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Makefile
new file mode 100644
index 0000000..691604a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/Makefile
@@ -0,0 +1,49 @@
+#
+# Makefile for the Marvell TPMv2 driver
+#
+
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+TPM_OBJS += 	src/core/tpm_common.o \
+		src/core/tpm_parser.o \
+		src/conf/tpm_init.o \
+		src/conf/tpm_device.o \
+		src/core/tpm_mempool.o \
+		src/conf/tpm_api.o \
+		src/conf/tpm_db.o \
+		src/conf/tpm_utils.o \
+		src/conf/tpm_mng.o \
+		src/conf/tpm_log.o \
+		src/core/tpm_cls.o \
+		src/core/tpm_c2_qos.o \
+		src/core/tpm_cls.o \
+		src/core/tpm_mc.o \
+		src/core/tpm_c2.o \
+		src/core/tpm_c3.o \
+		src/core/tpm_c4.o \
+		src/core/tpm_pme.o \
+		src/core/tpm_policer.o \
+		src/sysfs/tpm_sysfs.o \
+		src/sysfs/tpm_sysfs_init.o \
+		src/sysfs/tpm_sysfs_prs.o \
+		src/sysfs/tpm_sysfs_cls.o \
+		src/sysfs/tpm_sysfs_c2.o \
+		src/sysfs/tpm_sysfs_c3.o \
+		src/sysfs/tpm_sysfs_c4.o \
+		src/sysfs/tpm_sysfs_pme.o \
+		src/sysfs/tpm_sysfs_api.o \
+		src/sysfs/tpm_sysfs_mng.o \
+		src/sysfs/tpm_sysfs_utils.o \
+		src/sysfs/tpm_sysfs_plcr.o \
+		src/sysfs/tpm_sysfs_mc.o
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+TPM_OBJS += 	src/core/tpm_switch.o \
+		src/conf/tpm_switch_api.o \
+		src/sysfs/tpm_sysfs_switch.o
+endif
+
+mv_tpm-objs := $(TPM_OBJS)
+obj-$(CONFIG_MV_TPM) := mv_tpm.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_api.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_api.h
new file mode 100644
index 0000000..12f727b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_api.h
@@ -0,0 +1,852 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/*******************************************************************************
+* tpm_api.h
+*
+* DESCRIPTION:
+*		Header File contains APIs protype supplied to customers.
+*
+* DEPENDENCIES:
+*		None
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_API_H_
+#define _TPM_API_H_
+
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_add()
+*
+* DESCRIPTION: API performs exact match classification to all packets it should process, as
+*              defined in the Init configuration. (Typically all the Routed Unicast packets).
+*              At a minimum packets are matched with their Ethertype (and ppp_proto), and 5-tuple.
+*              There is no partial field classification.
+*              Additional classification fields will be added in AVANTA-LP-Ao.
+*              Packets forwarded to CPU cannot be modified.
+*
+* INPUTS:
+*	exact_match - Contains Match parameters to perform exact match.
+*			5_tuple + IP_version are mandatory, others are optional.
+*	action      - Contains parameters to classify the packet:
+*			Packet destination, modification and packet color for policer and tx_queue thresholds.
+*	policer_id  - Reference to previously created policer (0-15), 0xffff-> no policer
+*
+* OUTPUTS:
+*	rule_id     - Unique handle to this rule. Should be used for deleting the rule.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_add(struct tpm_exact_match_t	*exact_match,
+				unsigned short			num_pp_trgt,
+				struct tpm_pkt_action_t		action[],
+				unsigned char			policer_id,
+				unsigned int			*rule_id);
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del()
+*
+* DESCRIPTION: API deletes an exact_match_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del(struct tpm_5t_t *ipvx_five_t, unsigned int rule_id);
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del_all()
+*
+* DESCRIPTION: API deletes all exact_match rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del_all(void);
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_cntr_get()
+*
+* DESCRIPTION: API ges an exact_match_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_cntr_get(
+	struct tpm_5t_t *ipvx_five_t,
+	unsigned int rule_id,
+	unsigned int *cntr);
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_add()
+*
+* DESCRIPTION: API handles packets that were compared to the exact_match_rules, and created an exception in that
+*		ruleset. I.e. they passed the exact_match rule_set without hitting any rule. Rules in this API are
+*		limited to forwarding packets to CPU or dropping. Consequently, packets cannot be modified.
+*
+* INPUTS:
+*	match_key    - Contains Match parameters to perform packet match according to predefined
+*			capabilities. Initial supported capabilities are l4_ports, l4_proto, and dscp. Keys
+*			matching any of the IPv4/v6/TCP/UDP fields, must match the (TPM_MATCH_IPV4_PKT)attribute.
+*
+*	action       - Contains parameters to classify the packet: Set packet destination (only to CPU or drop),
+*			and set packet color. No packet modification.
+*	policer_id   - See previous definition.
+*	qos          - Parameter can be used in [ext_qos_tbl] mode (configured in Init). This mode implies
+*			that callers of this API can perform direct table lookup on the Packet processor
+*			qos_tables, (See also tpm_qos_table_set API) and use the qos_table_lookup as part of
+*			the main key matching process. NULL pointer implies no qos_table is used.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_add(struct tpm_pkt_key_t	*match_key,
+				       struct tpm_pkt_action_t	*action,
+				       unsigned char		policer_id,
+				       struct tpm_qos_t		*qos,
+				       unsigned int		*rule_id);
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del()
+*
+* DESCRIPTION: API deletes an exact_match_except_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del(struct tpm_pkt_key_t *match_key, unsigned int rule_id);
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del_all()
+*
+* DESCRIPTION: API deletes all  exact_match_except rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del_all(void);
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_cntr_get()
+*
+* DESCRIPTION: API ges an exact_match_except_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_cntr_get(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int rule_id,
+	unsigned int *cntr);
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_add()
+*
+* DESCRIPTION: API processes all packets that are not handled by other API's. (I.e. Typically bridged packets).The API
+*		allows to use combined field-matching keys and masks (as pre-configured during Init) .
+*
+* INPUTS:
+*	match_key    - See previous definition.
+*	action       - See previous definition. Can set all action fields.
+*	policer_id   - See previous definition.
+*	qos          - See previous definition.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_add(struct tpm_pkt_key_t	*match_key,
+			    unsigned short		num_pp_trgt,
+			    struct tpm_pkt_action_t	action[],
+			    unsigned char		policer_id,
+			    struct tpm_qos_t		*qos,
+			    unsigned int		*rule_id);
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del()
+*
+* DESCRIPTION: API deletes an gen_cls_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del(struct tpm_pkt_key_t *match_key, unsigned int	rule_id);
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del_all()
+*
+* DESCRIPTION: API deletes all  generic classification rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del_all(void);
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_cntr_get()
+*
+* DESCRIPTION: API ges an gen_cls_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_cntr_get(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr);
+
+/*******************************************************************************
+* mv_tpm_mc_flow_add()
+*
+* DESCRIPTION: API handles Multicast packets (Snooping or Proxy Routing) according to HGU/SFU requirements.
+*              The allowed field-matches are statically preconfigured for the most.
+*              Multicast streams that do not have a mc_flow rule, and are not IGMP/MLD, will be be dropped or sent to
+*              CPU (Init configured).
+*
+* INPUTS:
+*	match_key  - See previous definition.
+*			Fields that are allowed in the field-match bitmap:
+*			port, out_vid, ether_type, pppoe_proto
+*			ip_src (must have full host_mask).
+*			ip_dst OR eth_dst (In either case, must have full host_mask)
+*
+*	num_dest   - Number of Destination Action, meaning number of packet replications.
+*	action     - See previous definition. Can set all action fields.
+*
+* OUTPUTS:
+*	rule_id    - See previous definition
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_add(struct tpm_pkt_key_t	*match_key,
+		       unsigned short		num_dest,
+		       struct tpm_pkt_action_t	action[],
+		       int			*rule_id);
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del()
+*
+* DESCRIPTION: API deletes an multicast rule
+*
+* INPUTS:
+*	rule_id     - Rule to delete
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del(unsigned int	rule_id);
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del_all()
+*
+* DESCRIPTION: API deletes all multicast rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del_all(void);
+
+
+/*******************************************************************************
+* mv_tpm_cm_rule_add()
+*
+* DESCRIPTION: API adds a CnM rule that sets target queue and optionally p-bit for bridged packets.
+*                         The API allows using combined field-matching keys that do not need to be pre-config when Init.
+*                         Each CnM rule could have up to 6 fields:
+*                         Three of them :no bigger than 2 bytes, operator could be equal, not equal, GE or LE.
+*                         one of them    : no bigger than 16 bytes, operator could be equal, not equal.
+*                         one of them    : no bigger than 6 bytes, operator could be equal, not equal.
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*			rule_num: 0 to 7.
+*			field_num: each CnM rule has up to 6 fields.
+*			field_op   : each field operator could be equal, not equal, less or equal, greater or equal.
+*			match_key: contains the field key value, and source port. Only UNI port is allowed as src port.
+*	action           - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                        in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_add(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action);
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del()
+*
+* DESCRIPTION: API deletes a CnM rule.
+*
+* INPUTS:
+*	rule_num: valid from 0 to 7
+*	port	: src port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num);
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del_all()
+*
+* DESCRIPTION: API deletes all CnM rules of certain ports.
+*
+* INPUTS:
+*	port_bm: bit map of port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del_all(unsigned int port_bm);
+
+/*******************************************************************************
+* mv_tpm_qos_table_entry_set()
+*
+* DESCRIPTION: API directly configures the packet processor Qos Tables (part of C2 Engine).
+*              The packet processor has 64 p-bit tables and 16 dscp tables, that can be used for mapping pbit/dscp
+*              values to Qos related parameters (GMAC/T-CONT, gemport, rx/tx_queue, packet_color for policer)
+*              Values returned by the mapping table can be used as part of a generic packet classification, as
+*              written in APIs using the qos_tbl.
+*
+* INPUTS:
+*	tpm_qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	rule_id        - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_entry_set(enum tpm_qos_sel_t	tpm_qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg);
+
+/*******************************************************************************
+* mv_tpm_qos_table_set()
+*
+* DESCRIPTION: API configures all entries of a qos_table with value in param.
+*
+* INPUTS:
+*	tpm_qos_select  - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl         - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	qos_cfg         - Qos parameter configuration.
+*
+* OUTPUTS:
+*	rule_id         - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_set(enum tpm_qos_sel_t		tpm_qos_select,
+			 unsigned char			qos_tbl,
+			 struct tpm_qos_tbl_act_t	*qos_cfg);
+
+
+/* TBD:
+*  1. mv_tpm_bridge_learning_mac_rule_add();	// Add mac for learning
+*  2. mv_tpm_bridge_learning_vid_add();		// Add vid for bridge learning
+*  3. mv_tpm_dynamic_field_rule_add();		// CnM
+*  4. mv_tpm_filter_rule_add();			// Perform White List filtering
+*  5. mv_tpm_policer_add();			// Add policer
+*  6. mv_tpm_init.				// Init parameters
+*/
+
+/*******************************************************************************
+* mv_tpm_plcr_add()
+*
+* DESCRIPTION: This API adds a policer entry.
+*
+* INPUTS:
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	policer_id    - policer ID.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_add(struct tpm_policer_entry_t	*policer_entry,
+		    unsigned char		*policer_id);
+
+/*******************************************************************************
+* mv_tpm_plcr_del()
+*
+* DESCRIPTION: This API deletes a policer entry.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_del(unsigned char policer_id);
+
+/*******************************************************************************
+* mv_tpm_plcr_clear()
+*
+* DESCRIPTION: This API deletes all policer entries.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_clear(void);
+
+/*******************************************************************************
+* mv_tpm_sched_egr_mtu_set()
+*
+* DESCRIPTION: This API set the egress MTU on the port.
+*
+* INPUTS:
+*          gmac_idx    - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont       - valid for GPON PMAC, other set to 0
+*          tx_size_max - MTU, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_mtu_set(enum tpm_gmac_idx_t gmac_idx,
+			     unsigned char tcont_id,
+			     unsigned int tx_size_max);
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_mode_set()
+*
+* DESCRIPTION: This API Set the egress scheduling mode, strict or wrr.
+*
+* INPUTS:
+*          gmac_idx  - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont     - valid for GPON PMAC, other set to 0
+*          queue_id  - queue index, 0-7
+*          mode      - scheduling mode, strict priority or WRR
+*          wrr_weight- 0-255, if mode is WRR
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_mode_set(enum tpm_gmac_idx_t gmac_idx,
+				    unsigned char tcont_id,
+				    unsigned char queue_id,
+				    enum tpm_egr_sched_mode_t mode,
+				    unsigned short wrr_weight);
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_rate_lim_set()
+*
+* DESCRIPTION: This API set the egress rate limit on the queue.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+					unsigned char tcont_id,
+					unsigned char queue_id,
+					unsigned int rate_lim_val,
+					unsigned int bucket_size);
+
+/*******************************************************************************
+* mv_tpm_sched_egr_port_rate_lim_set()
+*
+* DESCRIPTION: This API set the egress rate limit on the port.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_port_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				       unsigned char tcont_id,
+				       unsigned int rate_lim_val,
+				       unsigned int bucket_size);
+
+/*******************************************************************************
+* mv_tpm_filter_rule_add()
+*
+* DESCRIPTION: This API adds a filter rule
+*
+* INPUTS:
+*          match_key      - See previous definition.
+*          frwd	     - defines packet forward, to drop or allow.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_add(
+	struct tpm_pkt_key_t		*match_key,
+	enum tpm_filter_frwd_mode_t	frwd,
+	unsigned int			*rule_id);
+
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del()
+*
+* DESCRIPTION: This API deletes a filter rule
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int		rule_id);
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del_all()
+*
+* DESCRIPTION: This API deletes all filter rule
+*
+* INPUTS:
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del_all(void);
+
+/*******************************************************************************
+* mv_tpm_filter_rule_cntr_get()
+*
+* DESCRIPTION: API ges an filter  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_cntr_get(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr);
+
+/*******************************************************************************
+* mv_tpm_filter_def_rule_cntr_get()
+*
+* DESCRIPTION: API ges an filter default rule hit counter.
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_def_rule_cntr_get(
+	unsigned char			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*cntr);
+
+/*******************************************************************************
+* mv_tpm_mtm_add()
+*
+* DESCRIPTION: API adds a MAC to port, to make it Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be added
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_add(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac);
+
+/*******************************************************************************
+* mv_tpm_mtm_del()
+*
+* DESCRIPTION: API removes a MAC from port, to make it not Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be removed
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_del(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac);
+
+/*******************************************************************************
+* tpm_init_spec_ipv6nh_add
+*
+* DESCRIPTION: The API will add wanted special IPV6 NH to tpm_start_db
+*
+* INPUTS:
+*	ipv6_special_nh - IPV6 NH need special treat
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Done before tpm_start call, and can not be called in running phase.
+*******************************************************************************/
+int tpm_init_spec_ipv6nh_add(unsigned char	ipv6_special_nh);
+
+/*******************************************************************************
+* tpm_init_spec_ipv6nh_del()
+*
+* DESCRIPTION: The API will delete IPV6 NH from special treat list
+*
+* INPUTS:
+*	ipv6_special_nh - IPV6 NH need special treat
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_init_spec_ipv6nh_del(unsigned char	ipv6_special_nh);
+
+/*******************************************************************************
+* tpm_mib_reset()
+*
+* DESCRIPTION: Performs MIB reset
+*
+* INPUTS:
+*	reset_level - The reset level determines the which elements will not be reset in the API call
+*			0: high level, reset all TPM configuration and reset TPM to none started state
+*			1: medium level, reset all TPM configuration including parser config
+*			2: low level, reset TPM configuration except parser config
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_mib_reset(enum tpm_reset_level_enum_t	reset_level);
+
+#endif /* _TPM_API_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2.h
new file mode 100644
index 0000000..5a31c7a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2.h
@@ -0,0 +1,195 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_c2.h
+*
+* DESCRIPTION:
+*               Internal definetion for C2 engine sub-module
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_C2_H_
+#define _TPM_C2_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_C2_FIRST_ENTRY		0
+#define TPM_C2_LAST_ENTRY		255
+#define TPM_C2_ENTRY_MAX		(TPM_C2_LAST_ENTRY + 1)
+#define TPM_C2_ENTRY_INVALID_IDX	TPM_C2_ENTRY_MAX
+#define TPM_C2_LKP_TYPE_MAX		64
+#define TPM_C2_LKP_TYPE_INVALID_PRI	0xFF
+#define TPM_C2_TCAM_KEY_LEN_MAX		8
+#define TPM_C2_LOGIC_IDX_BASE		1000
+
+#define TPM_C2_HEK_LKP_TYPE_OFFS	0
+#define TPM_C2_HEK_LKP_TYPE_BITS	6
+#define TPM_C2_HEK_LKP_TYPE_MASK	(0x3F << TPM_C2_HEK_LKP_TYPE_OFFS)
+
+#define TPM_C2_HEK_PORT_TYPE_OFFS	6
+#define TPM_C2_HEK_PORT_TYPE_BITS	2
+#define TPM_C2_HEK_PORT_TYPE_MASK	(0x3 << TPM_C2_HEK_PORT_TYPE_OFFS)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_c2_entry_free_t {
+	TPM_C2_ENTRY_FREE_TRUE = 0,
+	TPM_C2_ENTRY_FREE_FALSE,
+};
+
+enum tpm_c2_db_entry_valid_t {
+	TPM_C2_ENTRY_INVALID = 0,
+	TPM_C2_ENTRY_VALID
+};
+
+enum tpm_c2_hek_offs_t {
+	TPM_C2_HEK_OFF_BYTE0 = 0,
+	TPM_C2_HEK_OFF_BYTE1,
+	TPM_C2_HEK_OFF_BYTE2,
+	TPM_C2_HEK_OFF_BYTE3,
+	TPM_C2_HEK_OFF_BYTE4,
+	TPM_C2_HEK_OFF_BYTE5,
+	TPM_C2_HEK_OFF_BYTE6,
+	TPM_C2_HEK_OFF_BYTE7,
+	TPM_C2_HEK_OFF_LKP_PORT_TYPE,
+	TPM_C2_HEK_OFF_PORT_ID,
+	TPM_C2_HEK_OFF_MAX
+};
+
+enum tpm_port_dump_idx_t {
+	TPM_PORT_DUMP_TYPE = 0,
+	TPM_PORT_DUMP_VALUE,
+	TPM_PORT_DUMP_MASK
+};
+
+enum tpm_act_dump_idx_t {
+	TPM_ACT_DUMP_DSCP = 0,
+	TPM_ACT_DUMP_PBIT,
+	TPM_ACT_DUMP_GEMPORT,
+	TPM_ACT_DUMP_QUEUE_LOW,
+	TPM_ACT_DUMP_QUEUE_HIGH,
+	TPM_ACT_DUMP_COLOR,
+	TPM_ACT_DUMP_POLICER,
+	TPM_ACT_DUMP_FRWD,
+	TPM_ACT_DUMP_FLOWID
+};
+
+enum tpm_mod_dump_idx_t {
+	TPM_MOD_DUMP_IPTR = 0,
+	TPM_MOD_DUMP_DPTR,
+	TPM_MOD_DUMP_L4_CHECKSUM
+};
+
+enum tpm_flow_dump_idx_t {
+	TPM_FLOW_DUMP_ID = 0,
+	TPM_FLOW_DUMP_CNT
+};
+
+enum tpm_index_dump_idx_t {
+	TPM_INDEX_DUMP_TCAM = 0,
+	TPM_INDEX_DUMP_LOGICAL,
+	TPM_INDEX_DUMP_DB
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_c2_add_entry_t {
+	struct tpm_src_port_t		port;
+	unsigned char			lkp_type;
+	unsigned char			lkp_type_mask;
+	unsigned int			priority;	/* priority in this look_type */
+	unsigned int			field_bm;	/* bitmap of relevant fields*/
+	unsigned int			field_bm_mask;	/* bitmap of fields that need to be parsed */
+	struct tpm_mng_pkt_key_t	*mng_pkt_key;	/* pkt key value */
+	struct tpm_engine_qos_info_t	qos_info;	/* all the qos input */
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info */
+	struct tpm_qos_value_t		qos_value;	/* pri/dscp/gemport/qLow/qHigh */
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd_idx and data_idx */
+	struct tpm_duplicate_t		flow_info;	/* pkt duplication flow info */
+};
+
+struct tpm_c2_data_t {
+	unsigned int			valid;		/* Indicate the data is a real TCAM entry or not */
+	unsigned int			priority;	/* priority in this look_type */
+	struct tpm_src_port_t		port;
+	unsigned char			lkp_type;
+	unsigned char			lkp_type_mask;
+	unsigned int			field_bm;	/* bitmap of relevant fields*/
+	struct tpm_mng_pkt_key_db_t	mng_pkt_key;	/* pkt key value */
+	struct tpm_engine_qos_info_t	qos_info;	/* all the qos input */
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info */
+	struct tpm_qos_value_t		qos_value;	/* pri/dscp/gemport/qLow/qHigh */
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd_idx and data_idx */
+	struct tpm_duplicate_t		flow_info;	/* pkt duplication flow info */
+};
+
+struct tpm_c2_index_t {
+	unsigned int		valid;		/* Indicate the node is in list(valid), free or lookup up type list */
+	unsigned int		c2_logic_idx;	/* logical index, unique inentifier, used for delete C2 entry */
+	unsigned int		c2_hw_idx;	/* HW entry index in C2 engine */
+	unsigned int		c2_data_db_idx;	/* data index in db */
+	struct list_head	list_node;	/* list node */
+};
+
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_c2_get_hw_idx_from_logic_idx(unsigned int	logic_idx,
+				unsigned int		*c2_hw_idx,
+				unsigned int		*c2_db_idx);
+int tpm_c2_free_entry_number_get(unsigned int *free_entry_number);
+int tpm_c2_rule_add(struct tpm_c2_add_entry_t *c2_entry,
+		    unsigned int *c2_logic_index);
+int tpm_c2_rule_del(unsigned int c2_logic_index);
+int tpm_c2_rule_sram_get(unsigned int logic_index, struct tpm_engine_sram_t *sram);
+int tpm_c2_rule_sram_update(unsigned int logic_index, struct tpm_engine_sram_t *sram);
+int tpm_c2_reset(void);
+int tpm_c2_start(void);
+int tpm_c2_hit_cntr_clear_all(void);
+int tpm_c2_hit_cntr_all_get(int			hit_low_thresh,
+			struct tpm_hit_cnt_t	cntr_info[],
+			unsigned int		*num_of_cntrs);
+int tpm_c2_hit_cntr_get(int	c2_id,
+			unsigned int	*cntr);
+int tpm_c2_tcam_hek_get(unsigned int field_bm,
+		       struct tpm_c2_add_entry_t *c2_entry,
+		       unsigned char hek[],
+		       unsigned char hek_mask[]);
+
+#endif /* _TPM_C2_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2_qos.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2_qos.h
new file mode 100644
index 0000000..70654af
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c2_qos.h
@@ -0,0 +1,126 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/*******************************************************************************
+* tpm_c2_qos.h
+*
+* DESCRIPTION:
+*		Internal definetion for QOS in C2 engine sub-module
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_C2_QOS_H_
+#define _TPM_C2_QOS_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_qos_tbl_type_t {
+	TPM_QOS_TBL_TYPE_PRI = 0,
+	TPM_QOS_TBL_TYPE_DSCP,
+};
+
+enum tpm_qos_src_t {
+	TPM_QOS_SRC_ACTION_TBL = 0,
+	TPM_QOS_SRC_DSCP_PBIT_TBL,
+};
+
+enum tpm_qos_dump_index_t {
+	TPM_QOS_DUMP_DSCP = 0,
+	TPM_QOS_DUMP_PBIT,
+	TPM_QOS_DUMP_GEMPORT,
+	TPM_QOS_DUMP_QUEUE_LOW,
+	TPM_QOS_DUMP_QUEUE_HIGH,
+	TPM_QOS_DUMP_COLOR,
+	TPM_QOS_DUMP_TABLE,
+	TPM_QOS_DUMP_POLICER
+};
+enum tpm_qos_tbl_ref_cnt_action_t {
+	TPM_QOS_TBL_REF_CNT_INC = 0,	/* increase reference counter by 1		*/
+	TPM_QOS_TBL_REF_CNT_DEC,	/* decrease reference counter by 1		*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_engine_qos_info_t {
+	enum tpm_qos_tbl_type_t	qos_tbl_type;	/* dscp pri table or none */
+	unsigned int		qos_tbl_index;	/* dscp or pri table index */
+	unsigned short		policer_id;	/* policer id, 0xffff do not assign policer */
+	enum tpm_qos_src_t	pri_dscp_src;	/* pri/dscp comes from qos or act tbl */
+	enum tpm_qos_src_t	gemport_src;	/* gemport comes from qos or act tbl */
+	enum tpm_qos_src_t	q_low_src;
+	enum tpm_qos_src_t	q_high_src;
+	enum tpm_qos_src_t	color_src;
+};
+
+struct tpm_qos_value_t {
+	unsigned short		pri;
+	unsigned short		dscp;
+	unsigned short		gemp;
+	unsigned short		q_low;
+	unsigned short		q_high;
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_qos_tbl_entry_set(enum tpm_qos_sel_t	tpm_qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg);
+int tpm_qos_tbl_set(enum tpm_qos_sel_t	qos_select,
+			unsigned char		qos_tbl,
+			struct tpm_qos_tbl_act_t	*qos_cfg);
+
+int tpm_qos_tbl_state_check(enum tpm_qos_sel_t	qos_select,
+				unsigned char		qos_tbl);
+
+int tpm_qos_tbl_ref_cnt_update(enum tpm_qos_sel_t	qos_select,
+				unsigned char		qos_tbl,
+				enum tpm_qos_tbl_ref_cnt_action_t	cnt_action);
+
+int tpm_qos_tbl_reset(void);
+int tpm_qos_tbl_start(void);
+
+
+/*************************************************************/
+/*               STRUCTURES                                  */
+/*************************************************************/
+
+
+#endif /* _TPM_C2_QOS_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c3.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c3.h
new file mode 100644
index 0000000..1e43318
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c3.h
@@ -0,0 +1,190 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_C3_H_
+#define _TPM_C3_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_C3_INVALID_ENTRY_NUM	(0x1FFF)	/* invalid C3 entry number	*/
+#define TPM_C3_MAX_SEARCH_DEPTH		(16)		/* max cuckoo search depth	*/
+#define TPM_C3_DEFAULT_SEARCH_DEPTH	(3)		/* default cuckoo search depth	*/
+#define TPM_C3_MAX_HASH_KEY_SIZE	(MV_PP2_CLS_C3_EXT_HEK_WORDS * WORD_BYTES)	/* max key size */
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_scan_mode_t {
+	TPM_SCAN_BELOW_THRESHOLD = 0,	/* scan the entries whose hit counter are below theshold	*/
+	TPM_SCAN_ABOVE_THRESHOLD	/* scan the entries whose hit counter are above theshold	*/
+};
+
+enum tpm_c3_db_entry_valid_t {
+	TPM_C3_ENTRY_INVALID = 0,	/* invalid C3 entry	*/
+	TPM_C3_ENTRY_VALID		/* valid C3 entry	*/
+};
+
+/* below enums are used by C3 sysfs */
+enum tpm_c3_port_dump_idx_t {
+	TPM_C3_PORT_DUMP_TYPE = 0,
+	TPM_C3_PORT_DUMP_VALUE
+};
+
+enum tpm_c3_hek_dump_idx_t {
+	TPM_C3_HEK_DUMP_LEN = 0,
+	TPM_C3_HEK_DUMP_KEY1,
+	TPM_C3_HEK_DUMP_KEY2,
+	TPM_C3_HEK_DUMP_KEY3
+};
+
+enum tpm_c3_act_dump_idx_t {
+	TPM_C3_ACT_DUMP_COLOR = 0,
+	TPM_C3_ACT_DUMP_QUEUE_LOW,
+	TPM_C3_ACT_DUMP_QUEUE_HIGH,
+	TPM_C3_ACT_DUMP_FRWD,
+	TPM_C3_ACT_DUMP_POLICER,
+	TPM_C3_ACT_DUMP_FLOWID
+};
+
+enum tpm_c3_qos_dump_idx_t {
+	TPM_C3_QOS_DUMP_QUEUE_LOW = 0,
+	TPM_C3_QOS_DUMP_QUEUE_HIGH
+};
+
+enum tpm_c3_mod_dump_idx_t {
+	TPM_C3_MOD_DUMP_DPTR = 0,
+	TPM_C3_MOD_DUMP_IPTR,
+	TPM_C3_MOD_DUMP_L4_CHECKSUM
+};
+
+enum tpm_c3_flow_dump_idx_t {
+	TPM_C3_FLOW_DUMP_ID = 0,
+	TPM_C3_FLOW_DUMP_CNT
+};
+
+enum tpm_c3_index_dump_idx_t {
+	TPM_C3_INDEX_DUMP_HASH = 0,
+	TPM_C3_INDEX_DUMP_LOGICAL
+};
+
+enum tpm_c3_table_dump_mode_t {
+	TPM_C3_TABLE_DUMP_VALID = 0,	/* only dump valid entries	*/
+	TPM_C3_TABLE_DUMP_ALL		/* dump all entries		*/
+};
+
+enum tpm_c3_entry_dump_mode_t {
+	TPM_C3_ENTRY_DUMP_LOGIC_IDX = 0,
+	TPM_C3_ENTRY_DUMP_HASH_IDX,
+	TPM_C3_ENTRY_DUMP_LU_TYPE,
+	TPM_C3_ENTRY_DUMP_ALL
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_c3_add_entry_t {
+	struct tpm_src_port_t		port;		/* port information		*/
+	unsigned char			lkp_type;	/* lookup type			*/
+	struct tpm_mng_pkt_key_t	*mng_pkt_key;	/* pkt key value		*/
+	struct tpm_engine_qos_info_t	qos_info;	/* all the qos input		*/
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info		*/
+	struct tpm_qos_value_t		qos_value;	/* pri/dscp/gemport/qLow/qHigh	*/
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd_idx and data_idx	*/
+	struct tpm_duplicate_t		flow_info;	/* pkt duplication flow info	*/
+};
+
+struct tpm_c3_hash_index_entry_t {
+	unsigned short	valid;		/* indicate whether this logical index is valid	*/
+	unsigned short	hash_idx;	/* multihash index				*/
+};
+
+struct tpm_c3_logic_index_entry_t {
+	unsigned short	valid;		/* indicate whether this hash index is valid	*/
+	unsigned short	logic_idx;	/* logical index				*/
+};
+
+struct tpm_c3_scan_config_t {
+	unsigned char	clear_before_scan;	/* clear counter before scan	*/
+	unsigned char	lkp_type_scan;		/* scan by lookup type		*/
+	unsigned char	lkp_type;		/* lookup type			*/
+	unsigned char	scan_mode;		/* scan mode			*/
+	unsigned int	start_entry;		/* scan startted entry		*/
+	unsigned int	scan_delay;		/* scan delay time		*/
+	unsigned int	scan_threshold;		/* scan threshold		*/
+};
+
+/* below data structure are used by C3 sysfs */
+struct tpm_c3_data_t {
+	struct tpm_src_port_t		port;		/* port information		*/
+	unsigned char			lkp_type;	/* lookup type			*/
+	enum tpm_l4_type_t		l4_type;	/* L4 type, 0:tcp, 1:udp	*/
+	unsigned char			hek_len;	/* the length of HEK		*/
+	unsigned char			hek[TPM_C3_MAX_HASH_KEY_SIZE];/* HEK value	*/
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info		*/
+	struct tpm_qos_value_t		qos_value;	/* qLow/qHigh			*/
+	unsigned short			policer_id;	/* policer id, 0xffff		*/
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd idx and data idx	*/
+	struct tpm_duplicate_t		dup_info;	/* pkt duplication flow info	*/
+};
+
+struct tpm_c3_scan_entry_t {
+	unsigned int	hash_idx;	/* multihash index	*/
+	unsigned int	logic_idx;	/* logical index	*/
+	unsigned int	hit_cnt;	/* hit counter		*/
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_c3_rule_add(struct tpm_c3_add_entry_t	*c3_entry,
+		    unsigned int		*logic_idx);
+int tpm_c3_default_rule_add(struct tpm_c3_add_entry_t	*c3_entry,
+			    unsigned int		*logic_idx);
+int tpm_c3_rule_del(unsigned int logic_idx);
+int tpm_c3_rule_get(struct tpm_c3_add_entry_t	*c3_entry,
+		    unsigned int		*entry_num,
+		    unsigned int		*logic_idx_arr[]);
+int tpm_c3_hit_count_get(int logic_idx, unsigned int *hit_count);
+int tpm_c3_hit_cntr_all_get(int			hit_low_thresh,
+			struct tpm_hit_cnt_t	cntr_info[],
+			unsigned int		*num_of_cntrs);
+int tpm_c3_scan_param_set(struct tpm_c3_scan_config_t *scan_config);
+int tpm_c3_scan_result_get(unsigned int			max_entry_num,
+			   unsigned int			*entry_num,
+			   struct tpm_c3_scan_entry_t	result_entry[]);
+int tpm_c3_entry_get(unsigned int logic_idx, struct tpm_c3_data_t *c3_entry);
+int tpm_c3_rule_sram_update(unsigned int logic_idx, struct tpm_engine_sram_t *sram);
+
+int tpm_c3_reset(void);
+int tpm_c3_start(void);
+int tpm_c3_test(void);
+#endif /*_TPM_C3_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c4.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c4.h
new file mode 100644
index 0000000..289be01
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_c4.h
@@ -0,0 +1,164 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_c4.h
+*
+* DESCRIPTION:
+*               Internal definetion for C4 engine sub-module
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_C4_H_
+#define _TPM_C4_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_C4_OP_ALWAYS_TRUE		(0x1)
+#define TPM_C4_2B_FIELD_MAX		(4)
+
+#define TPM_C4_FIELD0_3_SIZE		(2)
+#define TPM_C4_FIELD4_SIZE		(16)
+#define TPM_C4_FIELD5_SIZE		(6)
+
+#define TPM_C4_PBIT_OFFSET		(5)
+#define TPM_C4_IP_VER_OFFSET		(4)
+#define TPM_C4_DSCP_OFFSET		(2)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_c4_field_id {
+	TPM_C4_FIELD_ID_0,
+	TPM_C4_FIELD_ID_1,
+	TPM_C4_FIELD_ID_2,
+	TPM_C4_FIELD_ID_3,
+	TPM_C4_FIELD_ID_4,
+	TPM_C4_FIELD_ID_5,
+};
+enum tpm_c4_vlan_num_t {
+	TPM_C4_VLAN_NUM_FALSE,           /* always False                         */
+	TPM_C4_VLAN_NUM_TRUE,            /* always True                          */
+	TPM_C4_VLAN_NUM_NOVLANTAGS,      /* the packet has no VLAN tags          */
+	TPM_C4_VLAN_NUM_VLANTAGS,        /* the packet has at least one VLAN tag */
+	TPM_C4_VLAN_NUM_ONEVLANTAG,      /* the packet has one VLAN tag          */
+	TPM_C4_VLAN_NUM_TWOVLANTAGS,     /* the packet has two VLAN tags         */
+	TPM_C4_VLAN_NUM_THREEVLANTAGS,   /* the packet has 3 VLAN tags           */
+};
+enum tpm_c4_pppoe_t {
+	TPM_C4_PPPOE_FALSE,	      /* always False		*/
+	TPM_C4_PPPOE_TRUE,	      /* always True		*/
+	TPM_C4_PPPOE_NOPPPOE,         /* the packet has no PPPOE	*/
+	TPM_C4_PPPOE_WITH_PPPOE,      /* the packet has PPPOE	*/
+};
+enum tpm_c4_mac_to_me_t {
+	TPM_C4_MAC_TO_ME_FALSE,	      /* always False		*/
+	TPM_C4_MAC_TO_ME_TRUE,	      /* always True		*/
+	TPM_C4_MAC_TO_ME_NOMAC_TO_ME,         /* the packet is no MAC_TO_ME */
+	TPM_C4_MAC_TO_ME_WITH_MAC_TO_ME,      /* the packet is MAC_TO_ME	  */
+};
+enum tpm_c4_l4_info_t {
+	TPM_C4_L4_INFO_FALSE,		/* always False		*/
+	TPM_C4_L4_INFO_TRUE,		/* always True		*/
+	TPM_C4_L4_INFO_0,	/* L4_INFO 0 */
+	TPM_C4_L4_INFO_1,		/* L4_INFO 1 */
+	TPM_C4_L4_INFO_2,		/* L4_INFO 2 */
+	TPM_C4_L4_INFO_3,		/* L4_INFO 3 */
+	TPM_C4_L4_INFO_4,		/* L4_INFO 4 */
+	TPM_C4_L4_INFO_5,		/* L4_INFO 5 */
+	TPM_C4_L4_INFO_6,		/* L4_INFO 6 */
+	TPM_C4_L4_INFO_7,		/* L4_INFO 7 */
+};
+enum tpm_c4_l3_info_t {
+	TPM_C4_L3_INFO_FALSE,		/* always False		*/
+	TPM_C4_L3_INFO_TRUE,		/* always True		*/
+	TPM_C4_L3_INFO_IPV4,		/* L3_INFO IPV4 */
+	TPM_C4_L3_INFO_IPV6,		/* L3_INFO IPV6 */
+	TPM_C4_L3_INFO_0,	/* L3_INFO 0 */
+	TPM_C4_L3_INFO_1,		/* L3_INFO 1 */
+	TPM_C4_L3_INFO_2,		/* L3_INFO 2 */
+	TPM_C4_L3_INFO_3,		/* L3_INFO 3 */
+	TPM_C4_L3_INFO_4,		/* L3_INFO 4 */
+	TPM_C4_L3_INFO_5,		/* L3_INFO 5 */
+	TPM_C4_L3_INFO_6,		/* L3_INFO 6 */
+	TPM_C4_L3_INFO_7,		/* L3_INFO 7 */
+};
+
+enum tpm_c4_misc_dump_idx_t {
+	TPM_C4_MISC_DUMP_VLAN = 0,
+	TPM_C4_MISC_DUMP_PPPOE,
+	TPM_C4_MISC_DUMP_MTM,
+	TPM_C4_MISC_DUMP_L4_INFO,
+	TPM_C4_MISC_DUMP_L3_INFO,
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+struct tpm_c4_field_t {
+	/* in each field, TPM_C4_OP_INVALID means this field is not valid */
+	enum tpm_cnm_op_t	op;
+	struct tpm_field_match_info	field_info;
+};
+
+struct tpm_c4_add_entry_t {
+	unsigned int			ruleSet;
+	unsigned int			rule_num;
+	enum tpm_c4_vlan_num_t	vlan_num;
+	enum tpm_c4_pppoe_t		pppoe;
+	enum tpm_c4_mac_to_me_t	mac_to_me;
+	enum tpm_c4_l4_info_t		l4_info;
+	enum tpm_c4_l3_info_t		l3_info;
+	unsigned int			field_num;	/* item number in field_op struct */
+	struct tpm_cnm_field_op_t	field_op[TPM_CNM_FIELD_MAX];
+	struct tpm_pkt_key_t		pkt_key;	/* pkt key value */
+	unsigned int			policer_id;
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info */
+	struct tpm_qos_value_t		qos_value;	/* pri/dscp/gemport/qLow/qHigh */
+};
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry);
+int tpm_c4_entry_del(unsigned int ruleSet, unsigned int rule_num);
+int tpm_c4_port_to_ruleset_set(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		rule_set,
+	unsigned int		rule_number);
+int tpm_c4_start(void);
+
+#endif /* _TPM_C4_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_cls.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_cls.h
new file mode 100644
index 0000000..285ddfa
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_cls.h
@@ -0,0 +1,169 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_CLS_H_
+#define _TPM_CLS_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_CLS_LOG_FLOW_LUID_MAX	(20)				/* max lookup ID per flow	*/
+#define TPM_CLS_FLOW_RULE_MAX		(64)				/* max flow rules		*/
+#define TPM_CLS_FREE_LOG2OFF		(0)				/* 1st entry is the free index	*/
+#define TPM_CLS_LOG2OFF_START		(1)				/* 1st entry is the free index	*/
+#define TPM_CLS_LOG2OFF_TBL_SIZE	(MV_PP2_CLS_FLOWS_TBL_SIZE+TPM_CLS_FREE_LOG2OFF)
+									/* logical to offset table size	*/
+#define TPM_CLS_FL_RND_SIZE		(10)				/* max rule hits per CLS round	*/
+#define TPM_CLS_C2_RND_MAX		(8)				/* max C2 per CLS round		*/
+#define TPM_CLS_C3_RND_MAX		(4)				/* max C3 per CLS round		*/
+#define TPM_CLS_C4_RND_MAX		(1)				/* max C4 per CLS round		*/
+#define TPM_CLS_FLOW_RND_MAX		(2)				/* max CLS rounds		*/
+#define TPM_CLS_UNDF_FL_LOG_ID		(0)				/* CLS undefined logical rule ID*/
+#define TPM_CLS_FREE_FL_LOG		(0xFFFF)			/* free flow rule value		*/
+#define TPM_CLS_FL_OFF_INV		(0xFFFF)			/* rule invalid offset		*/
+#define TPM_PORT_TYPE_INV		(0xFFFF)			/* invalid port type flag	*/
+#define TPM_PORT_BM_INV			(0xFFFF)			/* invalid port BM flag		*/
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_cls_rl_mrg_state_t {
+	TPM_MRG_NOT_NEW			= 0x0000,			/* merged rule no new		*/
+	TPM_MRG_NEW			= 0x0001,			/* merged rule new		*/
+	TPM_MRG_NEW_EXISTS		= 0x0002			/* merged rule exists		*/
+};
+
+enum tpm_cls_rl_cnt_op_t {
+	TPM_CNT_INC			= 0x0000,			/* increment engine counter	*/
+	TPM_CNT_DEC			= 0x0001			/* decrement engine counter	*/
+};
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/* define the value of RX queue high from:
+*0: The value of QueueHigh is as defined by the Classifier
+*1: The value of QueueHigh is as defined by corresponding register */
+enum tpm_cls_rx_qh_from_t {
+	TPM_RX_QH_FROM_CLS = 0,
+	TPM_RX_QH_FROM_REG,
+};
+
+/* Define the RX queue high for port, only valid in PP21 */
+enum tpm_cls_rx_qh_t {
+	TPM_GMAC0_RX_QH = 0,
+	TPM_GMAC1_RX_QH,
+	TPM_PMAC_RX_QH,
+};
+#endif
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_cls_luid_conf_t {
+	unsigned char			luid;				/* Lookup ID			*/
+	unsigned char			first_pri;			/* LUID first priority		*/
+};
+
+struct tpm_cls_fl_eng_cnt_t {
+	unsigned char			c2;				/* C2 engine count		*/
+	unsigned char			c3;				/* C3 engine count		*/
+	unsigned char			c4;				/* C4 engine count		*/
+};
+
+struct tpm_cls_lkp_dcod_entry_t {
+	unsigned char			cpu_q;				/* CPU queue			*/
+	unsigned char			way;				/* entry way			*/
+	unsigned char			flow_len;			/* flow length			*/
+	unsigned short			flow_log_id;			/* flow logical ID		*/
+	unsigned short			luid_num;			/* Lookup ID number		*/
+	struct tpm_cls_luid_conf_t	luid_list[TPM_CLS_LOG_FLOW_LUID_MAX];/* Lookup ID list		*/
+};
+
+struct tpm_cls_fl_rule_entry_t {
+	unsigned short			fl_log_id;	/* flow logical id              */
+	unsigned short			rl_log_id;			/* rule logical id              */
+	unsigned short			port_type;			/* port type			*/
+	unsigned short			port_bm;			/* port bitmap			*/
+	unsigned short			lu_type;	/* lookup type                  */
+	unsigned char			enabled;	/* enable flag		*/
+	unsigned char			prio;	/* HW priority                  */
+	unsigned char			engine;	/* engine to use                */
+	unsigned char			field_id_cnt;			/* field ID count		*/
+	unsigned char			field_id[TPM_FLOW_FIELD_COUNT_MAX];/* field IDs			*/
+};
+
+struct tpm_cls_fl_rule_list_t {
+	struct tpm_cls_fl_rule_entry_t	fl[TPM_CLS_FLOW_RULE_MAX];	/* flow rules			*/
+	unsigned short			fl_len;				/* flow length			*/
+};
+
+struct tpm_cls_rl_entry_t {
+	unsigned short			rl_log_id;	/* rule logical id		*/
+	unsigned short			rl_off;				/* rule offset			*/
+#ifndef CONFIG_MV_ETH_PP2_1
+	unsigned short			ref_cnt;			/* rule reference count         */
+#else
+	unsigned short			ref_cnt[TPM_MAX_NUM_GMACS];	/* rule reference count         */
+#endif
+	unsigned short			port_type;			/* port type			*/
+	unsigned short			port_bm;			/* port bitmap			*/
+	unsigned short			lu_type;	/* lookup type                  */
+	unsigned char			prio;	/* HW priority                  */
+	unsigned char			engine;	/* engine to use                */
+	unsigned char			enabled;	/* enable flag			*/
+	unsigned char			skip;				/* skip flag			*/
+	unsigned char			field_id_cnt;			/* field ID count		*/
+	unsigned char			field_id[TPM_FLOW_FIELD_COUNT_MAX];/* field IDs			*/
+	enum tpm_cls_rl_mrg_state_t	state;				/* rule state			*/
+};
+
+struct tpm_cls_fl_t {
+	unsigned short			fl_log_id;			/* flow logical id              */
+	unsigned short			fl_len;				/* flow length			*/
+	struct tpm_cls_rl_entry_t	fl[TPM_CLS_FLOW_RULE_MAX];	/* flow rules			*/
+	struct tpm_cls_fl_eng_cnt_t	eng_cnt;			/* flow rules engine count	*/
+};
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+/* decode table */
+int tpm_cls_lkp_dcod_enable(unsigned short flow_log_id);
+int tpm_cls_lkp_dcod_set(struct tpm_cls_lkp_dcod_entry_t *lkp_dcod_conf);
+
+/* CLS flow table */
+int tpm_cls_fl_rule_add(struct tpm_cls_fl_rule_list_t *fl_rls);
+int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls);
+int tpm_cls_fl_rule_disable(unsigned short		*rl_log_id,
+				unsigned short		rl_log_id_len,
+				struct tpm_class_port_t	*src_port);
+int tpm_cls_init(void);
+
+#endif /* _TPM_CLS_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_common.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_common.h
new file mode 100644
index 0000000..f6427ff
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_common.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/*******************************************************************************
+* tpm_common.h
+*
+* DESCRIPTION:
+*		Internal definetion for tpm_common.c
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_COMMON_H_
+#define _TPM_COMMON_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_MEMSET_ZERO(STRUCT)	memset(&(STRUCT), 0, sizeof((STRUCT)))
+#define TPM_MEMSET_FF(STRUCT)	memset(&(STRUCT), 0xff, sizeof((STRUCT)))
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_field_bm_to_field_info(unsigned int			field_bm,
+			       struct tpm_mng_pkt_key_t		*tpm_pkt_key,
+			       unsigned int			field_max,
+			       bool				l4_info,
+			       struct tpm_field_match_info	field_info[]);
+unsigned int tpm_field_size_get(unsigned int	field_id);
+
+#endif /* _TPM_COMMON_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_db.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_db.h
new file mode 100644
index 0000000..0116f5d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_db.h
@@ -0,0 +1,706 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_db.h
+*
+* DESCRIPTION:
+*               TPM db definetions
+*
+* DEPENDENCIES:
+*               None
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_DB_H_
+#define _TPM_DB_H_
+
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+/* TPM init module definition */
+#define TPM_DB_INIT_INVALID_VALUE	(0)	/* Default TPM DB invalid value	*/
+
+/* TPM mng module definition */
+#define TPM_DB_MNG_FLOW_LUID_MAX		(20)		/* max number of luid in a single flow_id	*/
+#define TPM_DB_MNG_FLOW_CAP_MAX			(400)		/* max number of {cap, flow_id} couple		*/
+#define TPM_DB_MNG_CAP_MAX			(TPM_NUM_MAX_CAPABILITIES * 2)	/* max number of public caps	*/
+#define TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX	(5)		/* max number of engine entry of a single api	*/
+#define TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX	(15)		/* max number of flow entry of a single api	*/
+#define TPM_DB_MNG_API_RULE_MAX			(5000)		/* max number of api entry			*/
+#define TPM_DB_MNG_RULE_ID_INVALID		(0xffffffff)	/* invalid value of a rule_id			*/
+#define TPM_DB_MNG_VIRT_PID_MAX			(64)		/* max number of virt port id			*/
+#define TPM_DB_MNG_API_RULE_IDX_START		(1000)		/* API logical ID start index			*/
+#define TPM_DB_MNG_MC_API_RULE_MAX		(256)		/* max number of MC api entry			*/
+
+#define TPM_DB_C4_RULESET_INVALID		(0xff)		/* invalid value of a ruleSet			*/
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+/* Generic DB parameter */
+enum tpm_db_param_type_t {
+	TPM_DB_PARAM_SWITCH_INIT,		/* whether init switch		*/
+	TPM_DB_PARAM_MC_DATA_HANDLE,		/* multicast data handler, MC or UC	*/
+	TPM_DB_PARAM_MC_SW_HANDLE,		/* multicast switch handler, MC or UC  */
+	TPM_DB_PARAM_MC_FLOW_DEFAULT,		/* multicast flow default action	*/
+	TPM_DB_PARAM_MAX_UNI_NUM,		/* Maximum UNI port number	*/
+	TPM_DB_PARAM_IPV6_SUPPORT,		/* whether support IPv6		*/
+	TPM_DB_PARAM_CPU_RX_QUEUE,		/* default CPU RX queue		*/
+	TPM_DB_PARAM_TTL_ILLEGAL_ACTION,	/* TTL illegal action		*/
+	TPM_DB_PARAM_TCP_FLAG_CHECK,		/* whether check TCP flag		*/
+	TPM_DB_PARAM_TRACE_DEBUG_FLAG,		/* TPM trace and debug flag		*/
+	TPM_DB_PARAM_QOS_TABLE_EXT,		/* QoS table extension		*/
+	TPM_DB_PARAM_BAD_CHKSUM_ACTION,		/* l3/4 checksum error action	*/
+	TPM_DB_PARAM_CNM_SUPPORT,		/* whether support CTC CnM		*/
+	TPM_DB_PARAM_MAX			/* TTL illegal action		*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+/* Generic data parameter structure */
+struct tpm_db_param_t {
+	enum tpm_db_param_type_t	type;	/* parameter type	*/
+	unsigned int			*value; /* parameter value	*/
+};
+
+/* Parser db structure */
+struct tpm_db_prs_t {
+	struct tpm_prs_ipv6_spec_nh_t	ipv6_special_nh[TPM_PRS_IPV6_NH_COUNT];	/*IPV6 NH:Hop by Hop(00),
+										DH(60), RH(43), FH(44),
+										ESP(52), AH(51);
+										Invalid 0xFF*/
+	struct tpm_prs_lu_id_t		prs_lu_id[TPM_TRAFFIC_TYPE_MAX];
+};
+
+/* C2 module db structure */
+struct tpm_db_c2_t {
+	struct tpm_c2_data_t	c2_data_db[TPM_C2_ENTRY_MAX];		/* info of each entry in C2 engine */
+	struct tpm_c2_index_t	c2_index_db[TPM_C2_ENTRY_MAX];		/* logic index and hw index of C2 entry */
+	struct list_head	c2_lu_type_head_db[TPM_C2_LKP_TYPE_MAX];/* header of list of the valid lookup_types */
+	struct list_head	c2_free_head_db;			/* header of free C2 entry list */
+};
+
+/* C3 module db structure */
+struct tpm_db_c3_t {
+	struct tpm_c3_scan_config_t		scan_config;					/* scan config       */
+	unsigned int				max_search_depth;				/* max search depth  */
+	struct tpm_c3_hash_index_entry_t	hash_idx_tbl[MV_PP2_CLS_C3_HASH_TBL_SIZE];	/* tbl for hash idx  */
+	struct tpm_c3_logic_index_entry_t	logic_idx_tbl[MV_PP2_CLS_C3_HASH_TBL_SIZE];	/* tbl for logic idx */
+};
+
+/* C4 module db structure */
+struct tpm_db_c4_ruleset_t {
+	unsigned int		rule_number;
+	struct tpm_class_port_t src_port;
+};
+
+struct tpm_db_c4_rule_t {
+	unsigned int			valid;
+	struct tpm_c4_add_entry_t	rule_entry;
+};
+
+struct tpm_db_c4_t {
+	/* ruleSet port configuration */
+	struct tpm_db_c4_ruleset_t	ruleset_config[MV_PP2_CLS_C4_GRPS_NUM];
+	/* all C4 rules */
+	struct tpm_db_c4_rule_t		rule_entries[MV_PP2_CLS_C4_GRPS_NUM][MV_PP2_CLS_C4_GRP_SIZE];
+};
+
+/* CLS module db structure */
+struct tpm_db_cls_fl_ctrl_t {
+	unsigned short			fl_max_len;			/* the max flow length		*/
+	unsigned short			lkp_dcod_en;			/* swap section index		*/
+	unsigned short			f_start;			/* free start index		*/
+	unsigned short			f_end;				/* free end index		*/
+};
+
+struct tpm_db_cls_lkp_dcod_t {
+	bool				enabled;			/* enabled flag			*/
+	unsigned char			cpu_q;				/* CPU queue			*/
+	unsigned char			way;				/* entry way			*/
+	unsigned char			flow_alloc_len;			/* flow allocation length	*/
+	unsigned char			flow_len;			/* flow current length		*/
+	unsigned short			flow_off;			/* flow offset			*/
+	unsigned short			luid_num;			/* Lookup ID number		*/
+	struct tpm_cls_luid_conf_t	luid_list[TPM_CLS_LOG_FLOW_LUID_MAX];/* Lookup ID list		*/
+};
+
+struct tpm_db_cls_fl_rule_t {
+	unsigned short			port_type;			/* port type			*/
+	unsigned short			port_bm;			/* port bitmap			*/
+	unsigned short			lu_type;	/* lookup type			*/
+	bool				enabled;		/* enable flag			*/
+	unsigned char			prio;	/* HW priority			*/
+	unsigned char			engine;	/* rule engine			*/
+	unsigned char			field_id_cnt;			/* field ID count		*/
+	unsigned char			field_id[TPM_FLOW_FIELD_COUNT_MAX];/* field IDs			*/
+#ifndef CONFIG_MV_ETH_PP2_1
+	unsigned short			ref_cnt;			/* reference count		*/
+#else
+	unsigned short			ref_cnt[TPM_MAX_NUM_GMACS];	/* reference count		*/
+#endif
+	unsigned short			rl_log_id;			/* rule logical id              */
+};
+
+struct tpm_db_cls_fl_rule_list_t {
+	struct tpm_db_cls_fl_rule_t	flow[TPM_CLS_FLOW_RULE_MAX];	/* flow rules			*/
+	unsigned short			flow_len;			/* flow length			*/
+};
+
+struct tpm_db_cls_t {
+	struct tpm_db_cls_fl_ctrl_t	fl_ctrl;			/* flow control DB		*/
+	struct tpm_db_cls_fl_rule_t	fl_rule[MV_PP2_CLS_FLOWS_TBL_SIZE];/*CLS rule DB		*/
+	unsigned short			log2off[TPM_CLS_LOG2OFF_TBL_SIZE];/* logical rule ID to offset	*/
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod[TPM_MNG_FLOW_ID_MAX];	/* lookpu decode DB		*/
+};
+
+/* MNG module db structure */
+struct tpm_db_mng_flow_cap_conf_t {
+	enum tpm_field_match_t		cap_field_bm;
+	enum tpm_mng_api_type_t		cap_api_type;
+	enum tpm_mng_flow_log_id_t	flow_log_id;
+	unsigned char			cls_pri;
+	enum tpm_engine_no_t		eng_no;
+	unsigned char			lu_type;
+	unsigned char			c2_pri;
+	enum tpm_field_match_t		c2_key_bm;	/* bm pass to C2, ~(cap_field_bm ^ c2_key_bm) masked by 0 */
+	enum tpm_vlan_num_enum_t	vlan_num;
+	unsigned int			rule_type;	/* only valid in TPM_API_PUBLIC_CLS api_type */
+	int				valid;
+};
+
+struct tpm_db_mng_flow_luid_conf_t {
+	unsigned char		luid;
+	unsigned char		c2_pri;
+};
+
+struct tpm_db_mng_flow_conf_t {
+	enum tpm_mng_flow_log_id_t		flow_log_id;
+	unsigned char				way;
+	unsigned char				flow_length;
+	struct tpm_db_mng_flow_luid_conf_t	luid_conf[TPM_DB_MNG_FLOW_LUID_MAX];
+};
+
+struct tpm_db_mng_api_data_t {
+	int				valid;
+	unsigned int			api_rule_id;
+	enum tpm_mng_api_type_t		cap_api_type;
+	unsigned int			c2_rule_id[TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX];
+	unsigned int			c3_rule_id[TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX];
+	unsigned int			flow_rule_id[TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX];
+	struct tpm_pkt_key_t		match_key;
+	unsigned int			num_dest; /* added for MC, indicates the multicast dest or action number */
+	struct tpm_pkt_action_t		action[TPM_ACT_NUM_MAX];
+	unsigned char			policer_id;
+	struct tpm_qos_t		qos;
+	struct tpm_engine_pkt_mod_t	pkt_mod[TPM_ACT_NUM_MAX];
+	struct tpm_duplicate_t		dup_info;
+};
+struct tpm_db_mng_virt_pid_t {
+	unsigned int		valid;
+	unsigned int		gemport;
+};
+struct tpm_db_mng_cap_conf_t {
+	unsigned int			rule_type;
+	enum tpm_field_match_t		cap_field_bm;
+	enum tpm_mng_api_type_t		cap_api_type;
+	unsigned short			prec;             /* precedence of this cap */
+	int				hit_number;       /* the max hit number in issue engine */
+	enum tpm_vlan_num_enum_t	vlan_num;
+	int				valid;
+};
+/* filter default rule DB */
+struct tpm_db_mng_filter_def_rule_t {
+	unsigned int			valid;
+	struct tpm_db_mng_cap_conf_t	filter_type;
+	unsigned int			def_rule_id;
+};
+
+/* Multicast switch ATU and VTU info record in DB */
+struct tpm_db_mng_mc_atu {
+	unsigned char			gdmac[MAC_ADDR_SIZE];
+	unsigned int			mac_ref_cnt;
+};
+
+struct tpm_db_mng_mc_vtu {
+	unsigned int			vid[TPM_MAX_VLAN_ID_VALUE + 1];/* Invalid VID 0xFFFF */
+	enum tpm_sw_vlan_egress_mode_t	egress_mode[TPM_MAX_VLAN_ID_VALUE + 1];
+};
+
+struct tpm_db_mng_mc_switch_t {
+	struct tpm_db_mng_mc_atu	switch_atu[TPM_DB_MNG_MC_API_RULE_MAX];
+	struct tpm_db_mng_mc_vtu	switch_vtu;
+};
+struct tpm_db_mng_ctc_cnm_rule_t {
+	unsigned int			valid;
+	struct tpm_cnm_key_t	cnm_key;
+	struct tpm_pkt_action_t	action;
+};
+
+struct tpm_db_mng_ctc_cnm_t {
+	struct tpm_class_port_t			src_port[MV_PP2_CLS_C4_GRPS_NUM];
+	struct tpm_db_mng_ctc_cnm_rule_t	cnm_rule[MV_PP2_CLS_C4_GRPS_NUM][MV_PP2_CLS_C4_GRP_SIZE];
+};
+
+struct tpm_db_mng_t {
+	struct tpm_db_mng_flow_cap_conf_t	flow_cap_cfg[TPM_DB_MNG_FLOW_CAP_MAX];
+	struct tpm_db_mng_api_data_t		api_data[TPM_DB_MNG_API_RULE_MAX];
+	struct tpm_db_mng_virt_pid_t		virt_pid_cfg[TPM_DB_MNG_VIRT_PID_MAX];
+	struct tpm_db_mng_cap_conf_t		cap_cfg[TPM_DB_MNG_CAP_MAX];
+	struct tpm_db_mng_mc_switch_t		mc_switch[TPM_NUM_MAX_UNI_PORTS];
+	struct tpm_db_mng_ctc_cnm_t		cnm_data;
+	struct tpm_db_mng_filter_def_rule_t	filter_def_rule[TPM_NUM_MAX_FILTER_TYPE];
+	unsigned int				c2_lu_type_cntr[TPM_C2_LKP_TYPE_MAX];
+	struct tpm_common_mempool_t		*api_data_pool;
+};
+
+/* PME module DB structure */
+struct tpm_db_pme_t {
+	struct tpm_pme_templ_data_t		templ_db[TPM_PME_INSTR_TEMPL_MAX];
+	struct tpm_pme_vlan_skip_permu_t	vlan_permu_stat[VLANOP_MAX_CNT];
+	struct tpm_pme_vlan_subr_t		vlan_db[TPM_VLAN_TEMPL_MAX];
+	struct tpm_pme_addr_rep_subr_t		addr_rep_db[TPM_ADDR_REP_TEMPL_MAX];
+	struct tpm_pme_data_entry_set_t		pri_data_db[TPM_PME_PRIVATE_SET_MAX];
+	struct tpm_pme_data_entry_set_t		sha_data_db[TPM_PME_SHARE_SET_MAX];
+	struct tpm_pme_misc_t			pme_misc_data;
+};
+
+struct tpm_db_plcr_entry_t {
+	int				valid;		/* whether this policer entry is valid	*/
+	struct tpm_policer_entry_t	plcr_entry;	/* policer entry			*/
+	unsigned int			ref_cnt;	/* reference counter by flow APIs	*/
+};
+
+/* policer module DB structure */
+struct tpm_db_plcr_t {
+	struct tpm_policer_gen_cfg_t	gen_cfg;			/* general configuration	*/
+	struct tpm_db_plcr_entry_t	plcr_arr[MV_PP2_PLCR_NUM];	/* policer entry array		*/
+	struct tpm_policer_early_drop_t	early_drop;			/* early drop configuration	*/
+};
+enum tpm_db_qos_status_t {
+	TPM_QOS_TBL_STATUS_UNINITED,	/* not been inited yet */
+	TPM_QOS_TBL_STATUS_INITED,	/* already been inited */
+};
+
+struct tpm_db_qos_tbl_entry_t {
+	enum tpm_db_qos_status_t		entry_stat;	/* Entry's status */
+	struct tpm_qos_tbl_act_t		qos_entry;	/* qos entry */
+};
+
+struct tpm_db_qos_prio_tbl_t {
+	enum tpm_db_qos_status_t		tbl_stat;	/* Table's status */
+	unsigned int				ref_count;	/* reference count of prio table */
+	struct tpm_db_qos_tbl_entry_t		pri_entry[MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE];/* Pri tbl entry array */
+};
+
+struct tpm_db_qos_dscp_tbl_t {
+	enum tpm_db_qos_status_t		tbl_stat;	/* Table's status */
+	unsigned int				ref_count;	/* reference count of prio table */
+	struct tpm_db_qos_tbl_entry_t		dscp_entry[MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE];/* DSCP table entry array */
+};
+
+/* QOS module DB structure */
+struct tpm_db_qos_t {
+	struct tpm_db_qos_prio_tbl_t	pri_tbl[MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM];	/* Prio table array */
+	struct tpm_db_qos_dscp_tbl_t	dscp_tbl[MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM];	/* DSCP table array */
+};
+
+/* MCT module DB structure */
+struct tpm_db_mc_t {
+	struct tpm_mc_data_t	mct_data_db[MV_PP2_MC_TBL_SIZE];	/* info of each entry in MCT */
+	struct tpm_mc_index_t	mct_index_db[MV_PP2_MC_TBL_SIZE];	/* DB index and hw index of MCT entry */
+	struct list_head	mct_dup_head_db[MV_PP2_MC_TBL_SIZE];	/* header of list of the valid dup list */
+	struct list_head	mct_free_head_db;			/* header of free MCT entry list */
+};
+
+/* switch module DB structure */
+struct tpm_db_sw_t {
+	unsigned int sw_port_ingr_rate[TPM_SW_PORT_MAX + 1];		/*switch port ingress rate limit*/
+	unsigned int sw_port_ingr_mc_rate[TPM_SW_PORT_MAX + 1];		/*switch port ingress multicast rate limit*/
+	unsigned int sw_port_ingr_bc_rate[TPM_SW_PORT_MAX + 1];		/*switch port ingress broadcast rate limit*/
+};
+
+struct tpm_db_t {
+	enum tpm_module_state_t	tpm_module_init_state;	/* TPM module init state	*/
+	struct tpm_init_t	init_db;		/* TPM module init db		*/
+	struct tpm_db_prs_t	prs_db;			/* TPM module parser db		*/
+	struct tpm_db_c2_t	c2_db;			/* TPM module C2 db		*/
+	struct tpm_db_c3_t	c3_db;			/* TPM module C3 db		*/
+	struct tpm_db_c4_t	c4_db;			/* TPM module C4 db		*/
+	struct tpm_db_cls_t	cls_db;			/* TPM module CLS db		*/
+	struct tpm_db_mng_t	mng_db;			/* TPM module mng db		*/
+	struct tpm_db_pme_t	pme_db;			/* TPM module PME db		*/
+	struct tpm_db_plcr_t	plcr_db;		/* TPM module PLCR db		*/
+	struct tpm_db_qos_t	qos_db;			/* TPM module QOS db		*/
+	struct tpm_db_mc_t	mc_db;			/* TPM module MC db		*/
+	struct tpm_db_sw_t	sw_db;			/* TPM module switch db		*/
+};
+
+#define TPM_DB_MNG_API_DATA_POOL_SIZE 5
+struct tpm_db_mng_api_data_node_t {
+	bool valid;
+	struct tpm_db_mng_api_data_t api_data;
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+/* TPM parser section */
+int tpm_db_prs_pre_all_set(struct tpm_db_prs_t *parser_pre_cfg);
+int tpm_db_prs_lu_id_set(unsigned int traffic_type, struct tpm_prs_lu_id_t *lu_id_data);
+int tpm_db_prs_lu_id_get(unsigned int traffic_type, struct tpm_prs_lu_id_t *lu_id_data);
+int tpm_db_spec_ipv6nh_set(unsigned char ipv6_nh, unsigned int tid, enum tpm_prs_ipv6_spec_nh_op_t op);
+int tpm_db_spec_ipv6nh_get(struct tpm_prs_ipv6_spec_nh_t ipv6_nh[]);
+
+/* TPM init section */
+int tpm_db_module_state_set(enum tpm_module_state_t state);
+unsigned int tpm_db_module_state_get(void);
+struct tpm_init_t *tpm_db_init_db_get(enum tpm_init_param_mode_t init_mode);
+int tpm_db_init_switch_mode_set(enum tpm_gmacs_enum_t gmac, enum tpm_sw_head_mode_t mode);
+enum tpm_sw_head_mode_t tpm_db_init_switch_mode_get(enum tpm_gmacs_enum_t gmac);
+int tpm_db_init_gmac_def_mh_set(enum tpm_gmacs_enum_t gmac, unsigned short mh);
+unsigned short tpm_db_init_gmac_def_mh_get(enum tpm_gmacs_enum_t gmac);
+int tpm_db_init_filter_type_set(
+	unsigned char			rule_type,
+	unsigned char			priority,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num);
+int tpm_db_init_filter_type_get(unsigned int index, struct tpm_init_filter_t *filter);
+int tpm_db_init_capability_set(enum tpm_cap_type_t type, struct tpm_init_cap_conf_t *cap);
+int tpm_db_init_capability_get(enum tpm_cap_type_t type, unsigned int index, struct tpm_init_cap_conf_t *cap);
+int tpm_db_init_capability_del(enum tpm_cap_type_t type, struct tpm_init_cap_conf_t *cap);
+int tpm_db_init_mc_proto_handler_set(struct tpm_port_mc_proto_handler_t *handler);
+int tpm_db_init_mc_proto_handler_get(unsigned int index, struct tpm_port_mc_proto_handler_t *handler);
+int tpm_db_init_mc_flow_def_set(enum tpm_mc_traffic_layer_t mc_flow_layer, enum tpm_mc_flow_def_action_t mc_flow_def);
+int tpm_db_init_mc_flow_def_get(enum tpm_mc_traffic_layer_t mc_flow_layer, enum tpm_mc_flow_def_action_t *mc_flow_def);
+int tpm_db_init_mod_tpid_set(unsigned short tpid);
+int tpm_db_init_mod_tpid_get(unsigned int index, unsigned short *tpid);
+int tpm_db_init_tpid_combo_set(struct tpm_tpid_combo_t *tpid_combo);
+int tpm_db_init_tpid_combo_get(unsigned int index, struct tpm_tpid_combo_t *tpid_combo);
+int tpm_db_init_tpid_combo_del(struct tpm_tpid_combo_t *tpid_combo);
+int tpm_db_generic_param_set(enum tpm_db_param_type_t type, unsigned int value);
+int tpm_db_generic_param_get(enum tpm_db_param_type_t type, unsigned int *value);
+
+/* C2 section */
+struct list_head *tpm_db_c2_lkp_type_list_head_get(unsigned char lkp_type);
+struct list_head *tpm_db_c2_free_list_head_get(void);
+struct tpm_c2_index_t *tpm_db_c2_index_node_get(unsigned int c2_node_idx);
+int tpm_db_c2_index_node_set(unsigned int		c2_node_idx,
+			     struct tpm_c2_index_t	*c2_index_node);
+int tpm_db_c2_data_get(unsigned int		c2_db_idx,
+		       struct tpm_c2_data_t	*c2_data);
+int tpm_db_c2_data_set(unsigned int		c2_db_idx,
+		       struct tpm_c2_data_t	*c2_data);
+int tpm_db_c2_init(void);
+
+/* C3 section */
+int tpm_db_c3_free_logic_idx_get(unsigned int *logic_idx);
+int tpm_db_c3_entry_add(unsigned int	logic_idx,
+			unsigned int	hash_idx);
+int tpm_db_c3_entry_del(int logic_idx);
+int tpm_db_c3_hash_idx_get(unsigned int	logic_idx,
+			   unsigned int	*hash_idx);
+int tpm_db_c3_logic_idx_get(unsigned int	hash_idx,
+			    unsigned int	*logic_idx);
+int tpm_db_c3_hash_idx_update(MV_PP2_CLS3_HASH_PAIR *hash_pair_arr);
+int tpm_db_c3_scan_param_set(struct tpm_c3_scan_config_t *scan_config);
+int tpm_db_c3_scan_param_get(struct tpm_c3_scan_config_t *scan_config);
+int tpm_db_c3_search_depth_set(unsigned int search_depth);
+int tpm_db_c3_search_depth_get(unsigned int *search_depth);
+int tpm_db_c3_init(void);
+/* C4 section */
+unsigned int tpm_db_c4_port_to_ruleset_set(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		rule_set,
+	unsigned int		rule_number);
+unsigned int tpm_db_c4_port_to_ruleset_get(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		*rule_set,
+	unsigned int		*rule_number);
+unsigned int tpm_db_c4_rule_add(
+	struct tpm_c4_add_entry_t *c4_entry);
+unsigned int tpm_db_c4_rule_del(
+	unsigned int		rule_set,
+	unsigned int		rule_number);
+unsigned int tpm_db_c4_rule_get(
+	unsigned int		rule_set,
+	unsigned int		rule_number,
+	struct tpm_db_c4_rule_t *db_c4_rule);
+int tpm_db_c4_init(void);
+
+/* CLS section */
+void tpm_db_cls_init(void);
+int  tpm_db_cls_fl_ctrl_set(struct tpm_db_cls_fl_ctrl_t *fl_ctrl);
+int  tpm_db_cls_fl_ctrl_get(struct tpm_db_cls_fl_ctrl_t *fl_ctrl);
+int  tpm_db_cls_fl_rule_set(unsigned int idx, struct tpm_db_cls_fl_rule_t *fl_rule);
+int  tpm_db_cls_fl_rule_get(unsigned int idx, struct tpm_db_cls_fl_rule_t *fl_rule);
+int  tpm_db_cls_fl_rule_list_get(unsigned int idx, unsigned int len, struct tpm_db_cls_fl_rule_t *fl_rl_list);
+int  tpm_db_cls_lkp_dcod_set(unsigned int idx, struct tpm_db_cls_lkp_dcod_t *lkp_dcod);
+int  tpm_db_cls_lkp_dcod_get(unsigned int idx, struct tpm_db_cls_lkp_dcod_t *lkp_dcod);
+int  tpm_db_cls_rl_off_lkp_dcod_get(unsigned short rl_off, struct tpm_db_cls_lkp_dcod_t	*lkp_dcod);
+void tpm_db_cls_rl_off_init(void);
+int  tpm_db_cls_rl_off_free_nr(unsigned int *free_nr);
+int  tpm_db_cls_rl_off_free_set(unsigned short off, unsigned short *log);
+int  tpm_db_cls_rl_off_get(unsigned short *off, unsigned short log);
+int  tpm_db_cls_rl_off_set(unsigned short off, unsigned short log);
+
+/* MNG section */
+void tpm_db_mng_clear(void);
+int tpm_db_mng_flow_cap_add(struct tpm_db_mng_flow_cap_conf_t *flow_cap_arr);
+int tpm_db_mng_flow_cap_update(
+	struct tpm_db_mng_flow_cap_conf_t *flow_cap,
+	struct tpm_db_mng_flow_cap_conf_t *flow_cap_updated);
+int tpm_db_mng_flow_in_cap_get(
+	enum tpm_mng_api_type_t   api_type,
+	unsigned int              rule_type,
+	unsigned int              field_match_bm,
+	enum tpm_vlan_num_enum_t  vlan_num,
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr[],
+	int *flow_num);
+int tpm_db_mng_pub_cap_get(struct tpm_db_mng_cap_conf_t	cap_arr[],
+			   int				*arr_len);
+int tpm_db_mng_pub_cap_set(enum tpm_mng_api_type_t cap_api_type, struct tpm_init_cap_conf_t *cap);
+int tpm_db_mng_cap_in_flow_get(enum tpm_mng_flow_log_id_t	flow_id,
+			       struct tpm_db_mng_flow_cap_conf_t	cap_arr[],
+					int *cap_num);
+int tpm_db_mng_next_cls_pri_get(enum tpm_mng_flow_log_id_t	flow_id,
+				int				*next_pri);
+int tpm_db_mng_cap_hit_num_get(
+				enum tpm_mng_api_type_t   api_type,
+				unsigned int		  rule_type,
+				enum tpm_field_match_t    cap_field_bm,
+				enum tpm_vlan_num_enum_t  vlan_num,
+				int                       *hit_number);
+int tpm_db_mng_api_entry_add(struct tpm_db_mng_api_data_t *api_data);
+int tpm_db_mng_api_entry_get(int rule_id, struct tpm_db_mng_api_data_t *api_data);
+int tpm_db_mng_api_entry_set(int rule_id, struct tpm_db_mng_api_data_t *api_data);
+int tpm_db_mng_api_entry_del(int rule_id);
+int tpm_db_mng_api_rule_id_get(void);
+
+int tpm_db_mng_api_entry_type_first_get(enum tpm_mng_api_type_t		cap_api_type,
+					struct tpm_db_mng_api_data_t	*api_data);
+int tpm_db_mng_api_entry_type_next_get(struct tpm_db_mng_api_data_t *api_data);
+int tpm_db_mng_virt_pid_get(int	gemport,
+			    int	*virt_port_id);
+int tpm_db_mng_virt_pid_add(int	gemport,
+			    int	*virt_port_id);
+int tpm_db_mng_flt_def_rule_set(
+	unsigned int			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			rule_id);
+int tpm_db_mng_flt_def_rule_get(
+	unsigned int			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*rule_id);
+
+/* MNG MC section */
+int tpm_db_mng_mc_atu_add(unsigned int switch_port,
+			  unsigned char *mac);
+int tpm_db_mng_mc_atu_del(unsigned int switch_port,
+			  unsigned char *mac,
+			  unsigned int *ref_cnt);
+int tpm_db_mng_mc_atu_get(unsigned int switch_port,
+			  unsigned char *mac,
+			  struct tpm_db_mng_mc_atu *atu);
+int tpm_db_mng_mc_vtu_set(unsigned int switch_port,
+			  unsigned int vid,
+			  enum tpm_sw_vlan_egress_mode_t egress_mode);
+int tpm_db_mng_mc_vtu_del(unsigned int switch_port,
+			  unsigned int vid);
+int tpm_db_mng_cm_rule_del(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num);
+int tpm_db_mng_cm_rule_add(
+	struct tpm_cnm_key_t	*cnm_key,
+	struct tpm_pkt_action_t *action);
+int tpm_db_mng_cm_rule_get(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num,
+	struct tpm_db_mng_ctc_cnm_rule_t *cnm_rule);
+int tpm_db_mng_cm_ruleset_set(
+	struct tpm_class_port_t	*port,
+	unsigned int ruleSet);
+int tpm_db_mng_cm_ruleset_get(
+	struct tpm_class_port_t	*port,
+	unsigned int *ruleSet);
+int tpm_db_mng_c2_lu_type_cntr_op(unsigned int lu_type,
+	unsigned char increase);
+int tpm_db_mng_free_c2_lu_type_get(unsigned char *lu_type);
+int tpm_db_mng_api_data_allocate(
+	struct tpm_db_mng_api_data_t **api_data);
+void tpm_db_mng_api_data_release(
+	struct tpm_db_mng_api_data_t *api_data);
+
+/* PME Section */
+int tpm_db_pme_cmd_first_free_set(enum tpm_pme_cmd_area_type_t area_type,
+				  unsigned int first_free);
+int tpm_db_pme_cmd_first_free_get(enum tpm_pme_cmd_area_type_t area_type,
+				  unsigned int *first_free);
+
+int tpm_db_pme_data_rng_unit_size_get(unsigned int tbl_idx,
+				      unsigned int rng_idx,
+				      unsigned int *unit_size);
+
+int tpm_db_pme_data_rng_info_get(unsigned int tbl_idx,
+				 unsigned int rng_idx,
+				 struct tpm_pme_tbl_rng_t *rng_mng_info);
+
+int tpm_db_pme_data_rng_unit_state_get(unsigned int tbl_idx,
+				       unsigned int rng_idx,
+				       unsigned int *state);
+
+int tpm_db_pme_data_rng_unit_state_set(unsigned int tbl_idx,
+				       unsigned int rng_idx,
+				       unsigned int *state);
+
+
+int tpm_db_pme_data_free_db_idx_get(unsigned int tbl_idx,
+				    unsigned int *db_idx);
+
+int tpm_db_pme_data_set(unsigned int tbl_idx,
+			unsigned int db_idx,
+			struct tpm_pme_data_entry_set_t *mod_data_set);
+
+int tpm_db_pme_data_get(unsigned int tbl_idx,
+			unsigned int db_idx,
+			struct tpm_pme_data_entry_set_t *mod_data_set);
+
+int tpm_db_pme_instr_templ_set(unsigned int db_idx,
+			       struct tpm_pme_templ_data_t *instr_templ);
+int tpm_db_pme_instr_templ_get(unsigned int db_idx,
+			       struct tpm_pme_templ_data_t *instr_templ);
+int tpm_db_pme_instr_templ_free_idx_get(unsigned int *db_idx);
+
+int tpm_db_pme_vlan_permu_stat_set(unsigned int vlan_op,
+				   struct tpm_pme_vlan_skip_permu_t *permu);
+int tpm_db_pme_vlan_permu_stat_get(unsigned int vlan_op,
+				   struct tpm_pme_vlan_skip_permu_t *permu);
+
+int tpm_db_pme_vlan_subr_set(unsigned int db_idx,
+			     struct tpm_pme_vlan_subr_t *vlan_subr);
+int tpm_db_pme_vlan_subr_get(unsigned int db_idx,
+			     struct tpm_pme_vlan_subr_t *vlan_subr);
+int tpm_db_pme_vlan_free_idx_get(unsigned int *db_idx);
+
+int tpm_db_pme_addr_rep_subr_set(unsigned int db_idx,
+				 struct tpm_pme_addr_rep_subr_t *addr_rep_subr);
+
+int tpm_db_pme_addr_rep_subr_get(unsigned int db_idx,
+				 struct tpm_pme_addr_rep_subr_t *addr_rep_subr);
+
+
+int tpm_db_pme_addr_rep_free_idx_get(unsigned int *db_idx);
+
+void tpm_db_pme_data_rng_lock(unsigned int tbl_idx, unsigned int rng_idx);
+void tpm_db_pme_data_rng_unlock(unsigned int tbl_idx, unsigned int rng_idx);
+void tpm_db_pme_hw_lock(void);
+void tpm_db_pme_hw_unlock(void);
+void tpm_db_pme_templ_lock(void);
+void tpm_db_pme_templ_unlock(void);
+
+int tpm_db_pme_init(void);
+
+int tpm_db_gmac_conn_get(enum tpm_gmacs_enum_t gmac,
+			 enum tpm_gmac_conn_t *gmac_con);
+
+/* policer section */
+int tpm_db_plcr_free_id_get(unsigned char *policer_id);
+int tpm_db_plcr_entry_set(unsigned char			policer_id,
+			  struct tpm_db_plcr_entry_t	*plcr_entry);
+int tpm_db_plcr_entry_get(unsigned char			policer_id,
+			  struct tpm_db_plcr_entry_t	*plcr_entry);
+int tpm_db_plcr_ref_cnt_update(unsigned char			policer_id,
+			       enum tpm_plcr_ref_cnt_action_t	cnt_action);
+int tpm_db_plcr_gen_cfg_set(struct tpm_policer_gen_cfg_t *gen_cfg);
+int tpm_db_plcr_gen_cfg_get(struct tpm_policer_gen_cfg_t *gen_cfg);
+int tpm_db_plcr_early_drop_set(struct tpm_policer_early_drop_t *early_drop);
+int tpm_db_plcr_early_drop_get(struct tpm_policer_early_drop_t *early_drop);
+int tpm_db_plcr_init(void);
+
+
+/* qos table section */
+int tpm_db_qos_tbl_entry_set(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg);
+
+int tpm_db_qos_tbl_status_get(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       enum tpm_db_qos_status_t	*status,
+			       int			*ref_cnt);
+
+int tpm_db_qos_tbl_ref_cnt_updt(enum tpm_qos_sel_t	qos_select,
+			       unsigned char			qos_tbl,
+			       enum tpm_qos_tbl_ref_cnt_action_t	cnt_action);
+
+int tpm_db_qos_tbl_entry_get(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_db_qos_tbl_entry_t	*qos_entry);
+
+/* MCT (replication) section */
+struct list_head *tpm_db_mc_dup_list_head_get(unsigned char dup_flowid);
+
+struct list_head *tpm_db_mc_free_list_head_get(void);
+
+struct tpm_mc_index_t *tpm_db_mc_index_node_get(unsigned int mct_node_idx);
+
+int tpm_db_mc_index_node_set(unsigned int mct_node_idx,
+			     struct tpm_mc_index_t *mct_index_node);
+
+int tpm_db_mc_data_get(unsigned int mct_db_idx,
+		       struct tpm_mc_data_t *mct_data);
+
+int tpm_db_mc_data_set(unsigned int mct_db_idx,
+		       struct tpm_mc_data_t *mct_data);
+
+int tpm_db_mc_init(void);
+
+int tpm_db_sw_port_ingr_rate_get(enum tpm_sw_port_t port, unsigned int *rate);
+
+int tpm_db_sw_port_ingr_rate_set(enum tpm_sw_port_t port, unsigned int rate);
+
+int tpm_db_sw_port_ingr_mc_rate_get(enum tpm_sw_port_t port, unsigned int *rate);
+
+int tpm_db_sw_port_ingr_mc_rate_set(enum tpm_sw_port_t port, unsigned int rate);
+
+int tpm_db_sw_port_ingr_bc_rate_get(enum tpm_sw_port_t port, unsigned int *rate);
+
+int tpm_db_sw_port_ingr_bc_rate_set(enum tpm_sw_port_t port, unsigned int rate);
+
+/* DB general section */
+int tpm_db_init(void);
+
+#endif /* _TPM_DB_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_device.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_device.h
new file mode 100644
index 0000000..5ff83b7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_device.h
@@ -0,0 +1,644 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_device.h                                                      **
+**                                                                           **
+**  DESCRIPTION : Header file of tpm_device_if.c                             **
+**  DEPENDCY :                                                               **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_DEVICE_H_
+#define _TPM_DEVICE_H_
+
+/*************************************************************/
+/*		 MACROS				     */
+/*************************************************************/
+#define TPM_DEVICES_COUNT	1
+#define TPM_DEV_NAME		("tpm")
+#define MV_TPM_IOCTL_MAGIC	('T')
+
+#define MPOOL_S_MAX_BUFF_SIZE   300
+#define MPOOL_M_MAX_BUFF_SIZE  1024
+#define MPOOL_L_MAX_BUFF_SIZE  2048
+#define MPOOL_H_MAX_BUFF_SIZE  4096
+
+
+/* TPM IOCTL CMD */
+#define MV_TPM_IOCTL_INIT_SECTION	_IOWR(MV_TPM_IOCTL_MAGIC, 1, unsigned int)
+#define MV_TPM_IOCTL_SWITCH_SECTION	_IOWR(MV_TPM_IOCTL_MAGIC, 2, unsigned int)
+#define MV_TPM_IOCTL_ACL_RULE_SECTION	_IOWR(MV_TPM_IOCTL_MAGIC, 3, unsigned int)
+#define MV_TPM_IOCTL_PP_SECTION		_IOWR(MV_TPM_IOCTL_MAGIC, 4, unsigned int)
+
+/*************************************************************/
+/*               ENUMERATIONS                                */
+/*************************************************************/
+enum tpm_ioctl_mempool_type_t {
+	TPM_MPOOL_TYPE_SMALL,
+	TPM_MPOOL_TYPE_MEDIAM,
+	TPM_MPOOL_TYPE_LARGE,
+	TPM_MPOOL_TYPE_HUGE,
+	TPM_MPOOL_TYPE_MAX
+};
+
+enum tpm_ioctl_init_cmd_type_t {
+	TPM_IOCTL_INIT_GMAC_MODE_SET = 1,
+	TPM_IOCTL_INIT_GMAC_DEF_MH_SET,
+	TPM_IOCTL_INIT_SWITCH_SET,
+	TPM_IOCTL_INIT_EXACT_CAP_ADD,
+	TPM_IOCTL_INIT_GEN_CAP_ADD,
+	TPM_IOCTL_INIT_EXACT_CAP_DEL,
+	TPM_IOCTL_INIT_GEN_CAP_DEL,
+	TPM_IOCTL_INIT_MC_DEF_ACT_SET,
+	TPM_IOCTL_INIT_MC_PROTO_HANDLE_SET,
+	TPM_IOCTL_INIT_MC_DATA_HANDLE_SET,
+	TPM_IOCTL_INIT_MC_SW_HANDLE_SET,
+	TPM_IOCTL_INIT_UNI_NUM_SET,
+	TPM_IOCTL_INIT_IPV6_SUPPORT_SET,
+	TPM_IOCTL_INIT_TRAP_QUEUE_SET,
+	TPM_IOCTL_INIT_ILLEGAL_TTL_ACT_SET,
+	TPM_IOCTL_INIT_TCP_FLAG_CHECK_SET,
+	TPM_IOCTL_INIT_MOD_VLAN_TPID_SET,
+	TPM_IOCTL_INIT_TPID_COMB_ADD,
+	TPM_IOCTL_INIT_TPID_COMB_DEL,
+	TPM_IOCTL_INIT_TRACE_FLAG_SET,
+	TPM_IOCTL_INIT_QOS_TBL_OWNER_SET,
+	TPM_IOCTL_INIT_MODULE_START,
+	TPM_IOCTL_INIT_MIB_RESET,
+};
+
+enum tpm_ioctl_switch_cmd_type_t {
+	TPM_IOCTL_SWITCH_VLAN_INGRESS_SET = 1,
+	TPM_IOCTL_SWITCH_VLAN_INGRESS_GET,
+	TPM_IOCTL_SWITCH_PBIT_VID_SET,
+	TPM_IOCTL_SWITCH_PBIT_VID_GET,
+	TPM_IOCTL_SWITCH_VLAN_SET,
+	TPM_IOCTL_SWITCH_VLAN_DEL,
+	TPM_IOCTL_SWITCH_VLAN_GET,
+	TPM_IOCTL_SWITCH_VLAN_FILTER_SET,
+	TPM_IOCTL_SWITCH_VLAN_FILTER_GET,
+	TPM_IOCTL_SWITCH_PORT_STATE_SET,
+	TPM_IOCTL_SWITCH_PORT_STATE_GET,
+	TPM_IOCTL_SWITCH_FLOW_CTL_SET,
+	TPM_IOCTL_SWITCH_FLOW_CTL_GET,
+	TPM_IOCTL_SWITCH_PORT_ISOLATE_SET,
+	TPM_IOCTL_SWITCH_PORT_ISOLATE_GET,
+	TPM_IOCTL_SWITCH_FLOOD_CTL_SET,
+	TPM_IOCTL_SWITCH_FLOOD_CTL_GET,
+	TPM_IOCTL_SWITCH_ONU_CNT_CLEAR,
+	TPM_IOCTL_SWITCH_PORT_CNT_CLEAR,
+	TPM_IOCTL_SWITCH_LINK_MODE_SET,
+	TPM_IOCTL_SWITCH_LINK_MODE_GET,
+	TPM_IOCTL_SWITCH_LINK_STATE_GET,
+	TPM_IOCTL_SWITCH_RATE_LIMIT_SET,
+	TPM_IOCTL_SWITCH_RATE_LIMIT_GET,
+	TPM_IOCTL_SWITCH_MC_PROTO_RATE_SET,
+	TPM_IOCTL_SWITCH_MC_PROTO_RATE_GET,
+	TPM_IOCTL_SWITCH_MC_DATA_RATE_SET,
+	TPM_IOCTL_SWITCH_MC_DATA_RATE_GET,
+	TPM_IOCTL_SWITCH_BC_RATE_SET,
+	TPM_IOCTL_SWITCH_BC_RATE_GET,
+	TPM_IOCTL_SWITCH_MIRROR_SET,
+	TPM_IOCTL_SWITCH_MIRROR_GET,
+	TPM_IOCTL_SWITCH_LPK_SET,
+	TPM_IOCTL_SWITCH_LPK_GET,
+	TPM_IOCTL_SWITCH_AGING_SET,
+	TPM_IOCTL_SWITCH_AGING_GET,
+	TPM_IOCTL_SWITCH_MAC_LIMIT_SET,/* MAC learn limit */
+	TPM_IOCTL_SWITCH_MAC_LIMIT_GET,
+	TPM_IOCTL_SWITCH_MAC_ADDR_ADD,
+	TPM_IOCTL_SWITCH_MAC_ADDR_DEL,
+	TPM_IOCTL_SWITCH_FILTER_MODE_SET,
+	TPM_IOCTL_SWITCH_FILTER_MODE_GET,
+	TPM_IOCTL_SWITCH_FILTER_ENTRY_ADD,
+	TPM_IOCTL_SWITCH_FILTER_ENTRY_DEL,
+	TPM_IOCTL_SWITCH_ONU_MAC_CLEAR,
+	TPM_IOCTL_SWITCH_PORT_MAC_TBL_CLEAR,
+	TPM_IOCTL_SWITCH_QOS_SET,
+	TPM_IOCTL_SWITCH_QOS_GET,
+	TPM_IOCTL_SWITCH_MTU_SET,
+	TPM_IOCTL_SWITCH_MTU_GET,
+	TPM_IOCTL_SWITCH_PORT_STAT1_GET,
+	TPM_IOCTL_SWITCH_PORT_STAT2_GET,
+	TPM_IOCTL_SWITCH_PORT_STAT3_GET,
+	TPM_IOCTL_SWITCH_PORT_STAT_ALL_GET,
+};
+
+enum tpm_ioctl_acl_rule_cmd_type_t {
+	TPM_IOCTL_ACL_EXACT_ADD = 1,
+	TPM_IOCTL_ACL_EXACT_DEL,
+	TPM_IOCTL_ACL_EXACT_DEL_ALL,
+	TPM_IOCTL_ACL_EXACT_CNTR_GET,
+	TPM_IOCTL_ACL_EXACT_EXCEPT_ADD,
+	TPM_IOCTL_ACL_EXACT_EXCEPT_DEL,
+	TPM_IOCTL_ACL_EXACT_EXCEPT_DEL_ALL,
+	TPM_IOCTL_ACL_EXACT_EXCEPT_CNTR_GET,
+	TPM_IOCTL_ACL_GEN_CLS_ADD,
+	TPM_IOCTL_ACL_GEN_CLS_DEL,
+	TPM_IOCTL_ACL_GEN_CLS_DEL_ALL,
+	TPM_IOCTL_ACL_GEN_CLS_CNTR_GET,
+	TPM_IOCTL_ACL_MC_FLOW_ADD,
+	TPM_IOCTL_ACL_MC_FLOW_DEL,
+	TPM_IOCTL_ACL_MC_FLOW_DEL_ALL,
+	TPM_IOCTL_ACL_CM_ADD,
+	TPM_IOCTL_ACL_CM_DEL,
+	TPM_IOCTL_ACL_CM_DEL_ALL,
+	TPM_IOCTL_ACL_FILTER_ADD,
+	TPM_IOCTL_ACL_FILTER_DEL,
+	TPM_IOCTL_ACL_FILTER_DEL_ALL,
+	TPM_IOCTL_ACL_FILTER_CNTR_GET,
+	TPM_IOCTL_ACL_FILTER_DEF_CNTR_GET,
+	TPM_IOCTL_ACL_MTM_ADD,
+	TPM_IOCTL_ACL_MTM_DEL,
+};
+
+enum tpm_ioctl_pp_cmd_type_t {
+	TPM_IOCTL_PP_SCHED_EGR_MTU_SET = 1,
+	TPM_IOCTL_PP_SCHED_EGR_Q_MODE_SET,
+	TPM_IOCTL_PP_SCHED_EGR_Q_RATE_LIM_SET,
+	TPM_IOCTL_PP_SCHED_EGR_PORT_RATE_LIM_SET,
+	TPM_IOCTL_PP_QOS_TBL_ENTRY_SET,
+	TPM_IOCTL_PP_QOS_TBL_SET,
+	TPM_IOCTL_PP_PLCR_ADD,
+	TPM_IOCTL_PP_PLCR_DEL,
+	TPM_IOCTL_PP_PLCR_DEL_ALL,
+};
+
+/*************************************************************/
+/*               STRUCTURES                                  */
+/*************************************************************/
+/* IOCTL mempool definetion, 3 size: Small, Medium Large and Huge */
+struct tpm_ioctl_mpools_t {
+	struct tpm_common_mempool_t *mpool_s;
+	struct tpm_common_mempool_t *mpool_m;
+	struct tpm_common_mempool_t *mpool_l;
+	struct tpm_common_mempool_t *mpool_h;
+};
+
+/* TPM Init Section
+** ================
+** Function list:
+** 1. mv_tpm_init_switch_mode_set
+** 2. mv_tpm_init_gmac_def_mh_set
+** 3. mv_tpm_init_switch_init_set
+** 4. mv_tpm_init_capability_set
+** 5. mv_tpm_init_mc_flow_default_set
+** 6. mv_tpm_init_mc_data_handler_set
+** 7. mv_tpm_init_mc_sw_handler_set
+** 8. mv_tpm_init_mc_proto_handler_set
+** 9. mv_tpm_init_uni_port_num_set
+** 10. mv_tpm_init_ipv6_support_set
+** 11. mv_tpm_init_cpu_trap_queue_set
+** 12. mv_tpm_init_ttl_illegal_action_set
+** 13. mv_tpm_init_tcp_flag_check_set
+** 14. mv_tpm_init_mod_vlan_tpid_set
+** 15. mv_tpm_init_tpid_combo_set
+** 16. mv_tpm_init_tpid_combo_del
+** 17. mv_tpm_init_trace_debug_flag_set
+** 18. mv_tpm_init_qos_tbl_ext_set
+*/
+struct tpm_ioctl_init_gmac_mode_t {
+	unsigned int gmac_idx;
+	enum tpm_sw_head_mode_t	mode;
+};
+
+struct tpm_ioctl_init_gmac_def_mh_t {
+	unsigned int gmac_idx;
+	unsigned short mh;
+};
+
+struct tpm_ioctl_init_mc_proto_handle_t {
+	unsigned int gmac_idx;
+	struct tpm_port_mc_proto_handler_t handler;
+};
+
+struct tpm_ioctl_init_mod_tpid_t {
+	unsigned int tpid_reg_idx;
+	unsigned short tpid;
+};
+
+/* tpm_ioctl_init_t, tpm init parameter, size:12B */
+struct tpm_ioctl_init_t {
+	unsigned int cmd;
+	/* same to struct tpm_init_t */
+	union {
+		struct tpm_ioctl_init_gmac_mode_t	gmac_mode;			/* GMAC switch mode	*/
+		struct tpm_ioctl_init_gmac_def_mh_t	gmac_def_tx_mh;			/* GMAC default TX MH	*/
+		enum tpm_sw_init_mode_t			switch_init;			/* whether ini switch	*/
+		struct tpm_capability_t			tpm_capability;			/* exact match type cap	*/
+		enum tpm_mc_flow_def_action_t		mc_def_act[TPM_MC_LAYER_MAX];	/* mc default action	*/
+		struct tpm_port_mc_proto_handler_t	mc_proto_handler;		/* mc protocol handler	*/
+		enum tpm_traffic_handler_t		mc_data_handle;			/* mc data handler	*/
+		enum tpm_mc_switch_handler_t		mc_sw_handle;			/* mc sw cfg handler	*/
+		unsigned int				uni_count;			/* max num of UNI port	*/
+		unsigned int				ipv6_support;			/* whether support IPv6	*/
+		unsigned int				cpu_trap_rx_queue;		/* def CPU trap RX queue*/
+		enum tpm_ttl_illegal_action_t		illegal_ttl_action;		/* act to illegal TTL	*/
+		enum tpm_tcp_flag_check_t		tcp_flag_check;			/* whether check TCP	*/
+		unsigned short				mod_vlan_tpid;			/* TPID for VLAN mod	*/
+		struct tpm_tpid_combo_t			tpid_combo;			/* TPID combo of VLANs	*/
+		unsigned int				trace_debug_flag;		/* TPM debug flag	*/
+		enum tpm_qos_tbl_owner_t		qos_tbl_owner;			/* QoS table usage	*/
+		enum tpm_reset_level_enum_t		reset_level;			/* MIB reset level	*/
+	};
+};
+
+/* Switch Section
+** ==============
+** Function list:
+** 1. mv_tpm_sw_vlan_ingress_mode_set
+** 2. mv_tpm_sw_vlan_ingress_mode_get
+** 3. mv_tpm_sw_pvid_set
+** 4. mv_tpm_sw_pvid_get
+** 5. mv_tpm_sw_vlan_set
+** 6. mv_tpm_sw_vlan_del
+** 7. mv_tpm_sw_vlan_get
+** 8. mv_tpm_sw_vlan_filter_set
+** 9. mv_tpm_sw_vlan_filter_get
+** 1. mv_tpm_sw_enable_state_set
+** 9. mv_tpm_sw_enable_state_get
+** 10.mv_tpm_sw_flow_control_set
+** 11.mv_tpm_sw_flow_control_get
+** 12.mv_tpm_sw_isolate_mask_set
+** 13.mv_tpm_sw_isolate_mask_get
+** 14.mv_tpm_sw_flood_control_mask_set
+** 15.mv_tpm_sw_flood_control_mask_get
+** 16.mv_tpm_sw_all_count_clear
+** 17.mv_tpm_sw_port_count_clear
+** 18.mv_tpm_sw_link_mode_set
+** 19.mv_tpm_sw_link_mode_get
+** 20.mv_tpm_sw_link_state_get
+** 21.mv_tpm_sw_rate_limit_set
+** 22.mv_tpm_sw_rate_limit_get
+** 23.mv_tpm_sw_mc_proto_rate_set
+** 24.mv_tpm_sw_mc_proto_rate_get
+** 25.mv_tpm_sw_mc_data_rate_set
+** 26.mv_tpm_sw_mc_data_rate_get
+** 27.mv_tpm_sw_broadcast_rate_set
+** 28.mv_tpm_sw_broadcast_rate_get
+** 29.mv_tpm_sw_mirror_set
+** 30.mv_tpm_sw_mirror_get
+** 31.mv_tpm_sw_loopback_set
+** 32.mv_tpm_sw_loopback_get
+** 33.mv_tpm_sw_mac_aging_time_set
+** 34.mv_tpm_sw_mac_aging_time_get
+** 35.mv_tpm_sw_mac_learn_limit_set
+** 36.mv_tpm_sw_mac_learn_limit_get
+** 37.mv_tpm_sw_mac_address_add
+** 38.mv_tpm_sw_mac_address_del
+** 39.mv_tpm_sw_mac_filter_mode_set
+** 40.mv_tpm_sw_mac_filter_mode_get
+** 41.mv_tpm_sw_mac_filter_entry_add
+** 42.mv_tpm_sw_mac_filter_entry_del
+** 43.mv_tpm_sw_mac_address_clear
+** 44.mv_tpm_sw_mac_table_clear
+** 45.mv_tpm_sw_qos_set
+** 46.mv_tpm_sw_qos_get
+** 47.mv_tpm_sw_mtu_set
+** 48.mv_tpm_sw_mtu_get
+** 49.mv_tpm_sw_stat1_get
+** 50.mv_tpm_sw_stat2_get
+** 51.mv_tpm_sw_stat3_get
+** 52.mv_tpm_sw_stat_all_get
+*/
+
+struct tpm_ioctl_switch_pvid_t {
+	unsigned short vid;
+	unsigned char pri;
+};
+
+struct tpm_ioctl_switch_vlan_grp_t {
+	unsigned short min_vlan;
+	unsigned short max_vlan;
+	enum tpm_sw_vlan_egress_mode_t mode;
+	unsigned short vlan;
+	unsigned int fwd_bm;
+	unsigned int tag_bm;
+};
+
+struct tpm_ioctl_switch_flow_ctl_t {
+	enum tpm_sw_config_state_t enable;
+	unsigned int pause_interval;
+};
+
+struct tpm_ioctl_switch_flood_ctl_t {
+	enum tpm_sw_flood_packet_type_t pkt_type;
+	unsigned int port_mask;
+};
+
+struct tpm_ioctl_switch_link_mode_t {
+	enum tpm_sw_config_state_t auto_en;
+	enum tpm_sw_speed_mode_t speed;
+	enum tpm_sw_duplex_mode_t duplex;
+};
+
+struct tpm_ioctl_switch_link_state_t {
+	enum tpm_sw_port_state_t link;
+	enum tpm_sw_speed_mode_t speed;
+	enum tpm_sw_duplex_mode_t duplex;
+};
+
+struct tpm_ioctl_switch_rate_t {
+	enum tpm_sw_port_dir_t dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_rate_limit_mode_t mode;
+	unsigned int rate;
+};
+
+struct tpm_ioctl_switch_mirror_t {
+	enum tpm_sw_port_dir_t dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_port_t dport;
+};
+
+struct tpm_ioctl_switch_lpk_t {
+	enum tpm_sw_port_dir_t dir;
+	enum tpm_sw_config_state_t enable;
+};
+
+struct tpm_ioctl_switch_mac_limit_t {
+	enum tpm_sw_config_state_t enable;
+	unsigned int limit;
+};
+
+struct tpm_ioctl_switch_mac_addr_t {
+	unsigned int port_bm;
+	unsigned char mac[6];
+	unsigned short vlan;
+	enum tpm_sw_mac_addr_mode_t mode;
+};
+
+struct tpm_ioctl_switch_qos_t {
+	enum tpm_sw_queue_t queue;
+	enum tpm_sw_qos_mode_t mode;
+	unsigned char weight;
+};
+
+/* tpm_ioctl_switch_oper_t, tpm switch operate parameter, size:120B */
+struct tpm_ioctl_switch_oper_t {
+	unsigned int cmd;
+	enum tpm_sw_port_t switch_port;
+	unsigned char count_reset;
+	union {
+		enum tpm_sw_ingress_mode_t ingress_mode;
+		enum tpm_sw_vlan_egress_mode_t egress_mode;
+		enum tpm_sw_config_state_t vlan_filter_mode;
+		enum tpm_sw_config_state_t port_enable;
+		struct tpm_ioctl_switch_pvid_t pvid;
+		struct tpm_ioctl_switch_vlan_grp_t vlan_grp;
+		struct tpm_ioctl_switch_flow_ctl_t flow_ctl;
+		unsigned int port_isolate_mask; /* bitmap mask of dedicated switch port */
+		struct tpm_ioctl_switch_flood_ctl_t flood_ctl;
+		struct tpm_ioctl_switch_link_mode_t link_mode;
+		struct tpm_ioctl_switch_link_state_t link_state;
+		struct tpm_ioctl_switch_rate_t rate_cfg;
+		struct tpm_ioctl_switch_mirror_t mirror;
+		struct tpm_ioctl_switch_lpk_t loopback;
+		unsigned int age_time;
+		struct tpm_ioctl_switch_mac_limit_t mac_learn_limit;
+		struct tpm_ioctl_switch_mac_addr_t mac_addr_op;
+		enum tpm_sw_mac_filter_mode_t filter_mode;
+		enum tpm_sw_mac_addr_mode_t mac_clear_mode;
+		struct tpm_ioctl_switch_qos_t qos;
+		unsigned int mtu;
+		struct tpm_sw_port_stat1_t switch_stat1;
+		struct tpm_sw_port_stat2_t switch_stat2;
+		struct tpm_sw_port_stat3_t switch_stat3;
+		struct tpm_sw_port_stat_all_t switch_stat_all;
+	};
+};
+
+/* ACL Rule Section
+** ====================
+** Function list:
+** 1. mv_tpm_exact_match_rule_add
+** 2. mv_tpm_exact_match_rule_del
+** 3. mv_tpm_exact_match_rule_del_all
+** 4. mv_tpm_exact_match_rule_cntr_get
+** 5. mv_tpm_exact_match_except_rule_add
+** 6. mv_tpm_exact_match_except_rule_del
+** 7. mv_tpm_exact_match_except_rule_del_all
+** 8. mv_tpm_exact_match_except_rule_cntr_get
+** 9. mv_tpm_gen_cls_rule_add
+** 10.mv_tpm_gen_cls_rule_del
+** 11.mv_tpm_gen_cls_rule_del_all
+** 12.mv_tpm_gen_cls_rule_cntr_get
+** 13.mv_tpm_mc_flow_add
+** 14.mv_tpm_mc_flow_del
+** 15.mv_tpm_mc_flow_del_all
+** 16.mv_tpm_cm_rule_add
+** 17.mv_tpm_cm_rule_del
+** 18.mv_tpm_cm_rule_del_all
+** 19.mv_tpm_filter_rule_add
+** 20.mv_tpm_filter_rule_del
+** 21.mv_tpm_filter_rule_del_all
+** 22.mv_tpm_filter_rule_cntr_get
+** 23.mv_tpm_filter_def_rule_cntr_get
+** 24.mv_tpm_mtm_add
+** 25.mv_tpm_mtm_del
+*/
+
+struct tpm_ioctl_acl_exact_add_t {
+	struct tpm_exact_match_t	exact_match;
+	unsigned short			num_pp_trgt;
+	struct tpm_pkt_action_t		action[TPM_TRG_PORT_MAX];
+	unsigned char			policer_id;
+};
+
+struct tpm_ioctl_acl_rule_add_t {
+	struct tpm_pkt_key_t	match_key;
+	unsigned short		num_pp_trgt;
+	struct tpm_pkt_action_t	action[TPM_TRG_PORT_MAX];
+	unsigned char		policer_id;
+	struct tpm_qos_t	qos;
+};
+
+struct tpm_ioctl_cm_rule_add_t {
+	struct tpm_cnm_key_t	cnm_key;
+	struct tpm_pkt_action_t	action;
+};
+
+struct tpm_ioctl_filter_rule_add_t {
+	struct tpm_pkt_key_t		match_key;
+	enum tpm_filter_frwd_mode_t	frwd;
+};
+
+struct tpm_ioctl_filter_def_rule_cntr_get_t {
+	unsigned char			rule_type;
+	enum tpm_field_match_t		field_bm;
+	enum tpm_vlan_num_enum_t	vlan_num;
+};
+
+struct tpm_ioctl_mtm_add_t {
+	enum tpm_gmacs_enum_t	port;
+	unsigned char		mac[6];
+};
+
+/* tpm_ioctl_acl_rule_t, acl rule parameter, size:248B */
+struct tpm_ioctl_acl_rule_t {
+	unsigned int cmd;
+	unsigned int rule_id;
+	unsigned int cntr;
+	union {
+		struct tpm_ioctl_acl_exact_add_t		exact_add_para;
+		struct tpm_ioctl_acl_rule_add_t		rule_add_para;
+		struct tpm_ioctl_cm_rule_add_t		cm_add_para;
+		struct tpm_ioctl_filter_rule_add_t		filter_add_para;
+		struct tpm_ioctl_filter_def_rule_cntr_get_t	filter_def_rule_cntr_get_para;
+		struct tpm_ioctl_mtm_add_t			mtm_add_para;
+	};
+};
+
+/* TPM Char Device Structure */
+struct tpm_module_cdev_t {
+	struct tpm_ioctl_init_t	tpm_ioctl_init;
+	struct tpm_ioctl_switch_oper_t switch_oper;
+	struct tpm_ioctl_acl_rule_t acl_rule_oper;
+	struct cdev cdev;
+};
+
+
+/* PP operations Section
+** =====================
+** Function list:
+** 1.mv_tpm_sched_egr_mtu_set
+** 2.mv_tpm_sched_egr_queue_mode_set
+** 3.mv_tpm_sched_egr_queue_rate_lim_set
+** 4.mv_tpm_sched_egr_port_rate_lim_set
+*/
+
+struct tpm_pp_sched_egr_mtu_t {
+	enum tpm_gmac_idx_t		gmac_idx;
+	unsigned char			tcont_id;
+	unsigned int			tx_size_max;
+};
+
+struct tpm_pp_sched_egr_q_mode_t {
+	enum tpm_gmac_idx_t		gmac_idx;
+	unsigned char			tcont_id;
+	unsigned char			queue_id;
+	enum tpm_egr_sched_mode_t	mode;
+	unsigned short			wrr_weight;
+};
+
+struct tpm_pp_sched_egr_q_rate_lim_t {
+	enum tpm_gmac_idx_t		gmac_idx;
+	unsigned char			tcont_id;
+	unsigned char			queue_id;
+	unsigned int			rate_lim_val;
+	unsigned int			bucket_size;
+};
+
+struct tpm_pp_sched_egr_port_rate_lim_t {
+	enum tpm_gmac_idx_t		gmac_idx;
+	unsigned char			tcont_id;
+	unsigned int			rate_lim_val;
+	unsigned int			bucket_size;
+};
+
+struct tpm_pp_qos_tbl_set_t {
+	enum tpm_qos_sel_t		qos_select;
+	unsigned char			qos_tbl;
+	unsigned char			entry;
+	struct tpm_qos_tbl_act_t	qos_cfg;
+};
+
+struct tpm_pp_plcr_t {
+	struct tpm_policer_entry_t	policer_entry;
+	unsigned char			policer_id;
+};
+
+/* tpm_ioctl_pp_oper_t, acl rule parameter */
+struct tpm_ioctl_pp_oper_t {
+	unsigned int cmd;
+	unsigned int rule_id;
+	union {
+		struct tpm_pp_sched_egr_mtu_t		pp_sched_egr_mtu;
+		struct tpm_pp_sched_egr_q_mode_t	pp_sched_egr_q_mode;
+		struct tpm_pp_sched_egr_q_rate_lim_t	pp_sched_egr_q_rate_lim;
+		struct tpm_pp_sched_egr_port_rate_lim_t pp_sched_egr_port_rate_lim;
+		struct tpm_pp_qos_tbl_set_t		pp_qos_tbl_set;
+		struct tpm_pp_plcr_t			pp_plcr;
+	};
+};
+
+/* this structure is used for passing sysfs request from kernel to userspace
+   to be ioctl (SFS_TO_IOCTL mode)  */
+struct tpm_ioctl_mng_t {
+	unsigned int		cmd;			/* the ioctl command            */
+	union {
+		struct tpm_ioctl_init_t	tpm_ioctl_init;
+		struct tpm_ioctl_switch_oper_t	tpm_ioctl_switch;
+		struct tpm_ioctl_acl_rule_t	tpm_ioctl_acl_rule;
+		struct tpm_ioctl_pp_oper_t	tpm_ioctl_pp_oper;
+	};								/* the ioctl additional data    */
+};
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+extern struct semaphore		tpm_sfs_2_ioctl_sem;
+extern struct tpm_ioctl_mng_t		tpm_sfs_2_ioctl_command;
+#endif
+
+/*************************************************************/
+/*               API PROTYPES                                */
+/*************************************************************/
+/*******************************************************************************
+* tpm_device_if_create
+*
+* DESCRIPTION: The function will create user interface for TPM device
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+int tpm_device_if_create(void);
+
+/*******************************************************************************
+* tpm_device_if_release
+*
+* DESCRIPTION: The function will release user interface of TPM device
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+int tpm_device_if_release(void);
+
+#endif /* _TPM_DEVICE_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_header.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_header.h
new file mode 100644
index 0000000..9d1a537
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_header.h
@@ -0,0 +1,123 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_api.h
+*
+* DESCRIPTION:
+*		This file tpm module header files.
+*
+* DEPENDENCIES:
+*		None
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_HEADER_H_
+#define _TPM_HEADER_H_
+
+/* Linux OS header files */
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/byteorder/generic.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/in.h>
+#include <linux/capability.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/sort.h>
+
+/* LSP Header Files */
+#include "mv_netdev.h"
+#include "mvPp2PrsHw.h"
+#include "mvPp2Prs.h"
+#include "mvPp2Cls2Hw.h"
+#include "mvPp2Cls3Hw.h"
+#include "mvPp2Cls4Hw.h"
+#include "mvPp2ClsHw.h"
+#include "mvPp2PmeHw.h"
+#include "mvPp2PlcrHw.h"
+#include "mv_netdev.h"
+#include "mvPp2ClsMcHw.h"
+
+/* LSP Switch Files */
+#include "msApi.h"
+#include "mv_switch.h"
+#include "mv_phy.h"
+
+/* TPM Header Files */
+#include "tpm_types.h"
+#include "tpm_api.h"
+#include "tpm_c2_qos.h"
+#include "tpm_internal_types.h"
+#include "tpm_common.h"
+#include "tpm_parser.h"
+#include "tpm_c2_qos.h"
+#include "tpm_mc.h"
+#include "tpm_c2.h"
+#include "tpm_c3.h"
+#include "tpm_c4.h"
+#include "tpm_switch_api.h"
+#include "tpm_switch.h"
+#include "tpm_mng.h"
+#include "tpm_cls.h"
+#include "tpm_init.h"
+#include "tpm_policer.h"
+#include "tpm_pme.h"
+#include "tpm_db.h"
+#include "tpm_utils.h"
+#include "tpm_sysfs.h"
+#include "tpm_log.h"
+#include "tpm_in6.h"
+#include "tpm_sysfs_utils.h"
+#include "tpm_mempool.h"
+#include "tpm_device.h"
+
+
+
+#endif /* _TPM_HEADER_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_in6.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_in6.h
new file mode 100644
index 0000000..04a0f99
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_in6.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_in6.h
+*
+* DESCRIPTION:
+*		This file contains definition of IPV6.
+*
+* DEPENDENCIES:
+*		None
+*******************************************************************************/
+/***********************/
+/* h file declarations */
+/***********************/
+
+#ifndef _TPM_IN6_H_
+#define _TPM_IN6_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+/* IPV6 NEXT HEADER */
+#define TPM_IPV6_NH_HH               (0)
+#define TPM_IPV6_NH_DH               (60)
+#define TPM_IPV6_NH_RH               (43)
+#define TPM_IPV6_NH_FH               (44)
+#define TPM_IPV6_NH_EH               (52)
+#define TPM_IPV6_NH_AH               (51)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+
+
+#endif /* _TPM_IN6_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_init.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_init.h
new file mode 100644
index 0000000..2e0ec35
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_init.h
@@ -0,0 +1,612 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_init.h						     **
+**									     **
+**  DESCRIPTION : This file contains macros and API protypes of tpm_init     **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_INIT_H_
+#define _TPM_INIT_H_
+
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_init_enum_str_t {
+	TPM_INIT_ENUM_SWITCH_MODE,		/* GMAC switch head mode	*/
+	TPM_INIT_ENUM_SWITCH_INIT,		/* whether initialize switch	*/
+	TPM_INIT_ENUM_MC_DEF_ACTION,		/* MC flow default action	*/
+	TPM_INIT_ENUM_MC_HANDLER,		/* MC protocol handler		*/
+	TPM_INIT_ENUM_SW_HANDLER,		/* MC swicth handler		*/
+	TPM_INIT_ENUM_IPV6_SUPPORT,		/* IPv6 support			*/
+	TPM_INIT_ENUM_TTL_ILLEGAL_ACTION,	/* Illegal TTL action		*/
+	TPM_INIT_ENUM_TCP_FLAG_CHECK,		/* whether check TCP flag	*/
+	TPM_INIT_ENUM_QOS_TABLE_OWNER,		/* QoS table owner		*/
+	TPM_INIT_ENUM_CAPABILITY_FIELD,		/* Capability filed		*/
+	TPM_INIT_ENUM_MODULE_STATE		/* TPM module state		*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_init_filter_t {
+	unsigned int			rule_type;	/* valid from 0 to 15, each rule_type has one or more cap */
+							/* capabilities within smaller rule_type get higher priority */
+							/* for example: */
+							/* rule_type 0 for all trap_to_cpu rules */
+							/* rule_type 1 for all L2 HWF rules */
+	unsigned int			field_match_bm;	/* capability field bitmap	*/
+	enum tpm_vlan_num_enum_t	tag_num;	/* allowed number of vlan_tags */
+	unsigned char			precedence;	/* priority of this capabilty within rule_type */
+	int				valid;		/* validation indication */
+};
+struct tpm_init_cap_conf_t {
+	unsigned int			rule_type;	/* valid from 0 to 15, each rule_type has one or more cap */
+							/* capabilities within smaller rule_type get higher priority */
+							/* for example: */
+							/* rule_type 0 for all trap_to_cpu rules */
+							/* rule_type 1 for all L2 HWF rules */
+	unsigned int			field_match_bm;	/* capability field bitmap	*/
+	enum tpm_vlan_num_enum_t	tag_num;	/* allowed number of vlan_tags */
+	unsigned char			precedence;	/* priority of this capabilty within rule_type */
+	unsigned char			max_port_hits;	/* max port hit number */
+	int				valid;		/* validation indication */
+};
+
+struct tpm_init_t {
+	enum tpm_sw_head_mode_t			gmac_switch_mode[TPM_NUM_ETH_GMACS];		/* GMAC switch mode   */
+	unsigned short				gmac_def_tx_mh[TPM_NUM_ETH_GMACS];		/* GMAC default TX MH */
+	enum tpm_sw_init_mode_t			switch_init;					/* whether init switch*/
+	struct tpm_init_cap_conf_t		exact_match_except_cap[TPM_NUM_MAX_CAPABILITIES];/* exact type cap    */
+	struct tpm_init_cap_conf_t		generic_class_cap[TPM_NUM_MAX_CAPABILITIES];	/* Cls type cap	      */
+	struct tpm_init_filter_t		filter_cap[TPM_NUM_MAX_FILTER_TYPE];		/* filter types	      */
+	enum tpm_traffic_handler_t		mc_data_handle;					/* mc data handler    */
+	enum tpm_mc_switch_handler_t		mc_sw_handle;					/* mc switch handler  */
+	enum tpm_mc_flow_def_action_t		mc_flow_def[TPM_MC_LAYER_MAX];			/* mc default action  */
+	struct tpm_port_mc_proto_handler_t	mc_proto_handler[TPM_NUM_MAX_GMAC_PORTS];	/* mc protocol handler*/
+	unsigned int				max_num_uni_ports;				/* max num of UNI port*/
+	unsigned int				ipv6_support;					/* whether support IP6*/
+	unsigned int				cpu_trap_rx_queue;				/* def CPU trap RXq   */
+	enum tpm_ttl_illegal_action_t		ttl_illegal_action;				/* act to illegal TTL */
+	enum tpm_bad_chksum_action_t		bad_chksum_action;				/* act to bad L3/4    */
+	enum tpm_tcp_flag_check_t		tcp_flag_check;					/* whether check TCP  */
+	unsigned short				mod_vlan_tpid[TPM_NUM_VLAN_ETYPE_REGS];		/* TPID for VLAN mod  */
+	struct tpm_tpid_combo_t			tpid_combo[TPM_NUM_MAX_TPID_COMBO];		/* TPID combo VLANs   */
+	unsigned int				trace_debug_flag;				/* TPM debug flag     */
+	enum tpm_qos_tbl_owner_t		qos_tbl_ext;					/* QoS table usage    */
+	unsigned int				cnm_support;					/* whether support CNM*/
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+/******************************************************************************
+* tpm_init_lookup_enum_str()
+*
+* DESCRIPTION:
+*	This routine lookups enum string according to enum value
+*
+* INPUTS:
+*	enum_array   - pointer to enum array
+*	enum_value   - the enum value to be matched
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Enum string
+*******************************************************************************/
+char *tpm_init_lookup_enum_str(enum tpm_init_enum_str_t enum_type, int enum_val);
+
+/*******************************************************************************
+* tpm_init_switch_mode_set()
+*
+* DESCRIPTION: set switch mode, MH or DSA
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mode      - switch header mode
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_switch_mode_set(enum tpm_gmacs_enum_t gmac, enum tpm_sw_head_mode_t mode);
+
+/*******************************************************************************
+* tpm_init_gmac_def_mh_set()
+*
+* DESCRIPTION: set GMAC default TX MH
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mh        - Marvell head
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_gmac_def_mh_set(enum tpm_gmacs_enum_t gmac, unsigned short mh);
+
+/*******************************************************************************
+* tpm_init_switch_init_set()
+*
+* DESCRIPTION: set the flag whether need to init switch
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mh        - Marvell head
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_switch_init_set(enum tpm_sw_init_mode_t sw_init_mode);
+
+/*******************************************************************************
+* tpm_init_capability_set()
+*
+* DESCRIPTION: set capability
+*
+* INPUTS:
+*	type      - Capability type
+*	cap       - Capabillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_capability_set(enum tpm_cap_type_t type, struct tpm_capability_t *cap);
+
+/*******************************************************************************
+* tpm_init_capability_del()
+*
+* DESCRIPTION: delete capability
+*
+* INPUTS:
+*	type      - Capability type
+*	cap       - Capabillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_capability_del(enum tpm_cap_type_t type, struct tpm_capability_t *cap);
+
+/*******************************************************************************
+* tpm_init_mc_data_handler_set()
+*
+* DESCRIPTION: set the handler mode for multicast data packet.
+*
+* INPUTS:
+*	data_handle  - multicast data handler
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_data_handler_set(enum tpm_traffic_handler_t data_handle);
+
+/*******************************************************************************
+* tpm_init_mc_flow_default_set()
+*
+* DESCRIPTION: set the default action for multicast data flow
+*
+* INPUTS:
+*       mc_layer     - MC flow layer
+*	mc_flow_def  - multicast data flow default action
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_flow_default_set(unsigned int mc_layer, enum tpm_mc_flow_def_action_t mc_flow_def);
+
+/*******************************************************************************
+* tpm_init_mc_proto_handler_set()
+*
+* DESCRIPTION: set the handler for multicast protocol packets
+*
+* INPUTS:
+*	mc_proto_handler  - multicast protocol handler
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_proto_handler_set(struct tpm_port_mc_proto_handler_t *handler);
+
+/*******************************************************************************
+* tpm_init_mc_sw_handler_set()
+*
+* DESCRIPTION: set the handler of swicth ATU and VTU set, done by MC API or not.
+*
+* INPUTS:
+*	sw_handle  - MC swicth ATU&VTU handler
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_sw_handler_set(enum tpm_mc_switch_handler_t sw_handle);
+
+/*******************************************************************************
+* tpm_init_uni_port_num_set()
+*
+* DESCRIPTION: set the the number of UNI ports
+*
+* INPUTS:
+*	uni_port_num  - Maximum UNI port number
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_uni_port_num_set(unsigned int uni_port_num);
+
+/*******************************************************************************
+* tpm_init_ipv6_support_set()
+*
+* DESCRIPTION: set the flag that whether support IPv6
+*
+* INPUTS:
+*	ipv6_support -  IPv6 support flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_ipv6_support_set(enum tpm_ipv6_support_t ipv6_support);
+
+/*******************************************************************************
+* tpm_init_cpu_trap_queue_set()
+*
+* DESCRIPTION: set the CPU trap RX queue
+*
+* INPUTS:
+*	cpu_trap_queue - CPU trap RX queue
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_cpu_trap_queue_set(unsigned int cpu_trap_queue);
+
+/*******************************************************************************
+* tpm_init_ttl_illegal_action_set()
+*
+* DESCRIPTION: set the action for illegal TTL
+*
+* INPUTS:
+*	ttl_illegal_action  - action for illegal TTL
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_ttl_illegal_action_set(enum tpm_ttl_illegal_action_t ttl_illegal_action);
+
+/*******************************************************************************
+* tpm_init_bad_chksum_action_set()
+*
+* DESCRIPTION: set the action of bad L3/4 checksum packet.
+*
+* INPUTS:
+*	bad_chksum_action  -
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_bad_chksum_action_set(enum tpm_bad_chksum_action_t action);
+
+/*******************************************************************************
+* tpm_init_mod_vlan_tpid_set()
+*
+* DESCRIPTION: set the Ethernet type(TPID) used by TPM VLAN modification
+*
+* INPUTS:
+*	mod_vlan_tpid  - Ethernet type(TPID) used by TPM VLAN modification
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mod_vlan_tpid_set(unsigned short mod_vlan_tpid);
+
+/*******************************************************************************
+* tpm_init_tpid_combo_set()
+*
+* DESCRIPTION: set TPID combo up to dual VLAN tag
+*
+* INPUTS:
+*	tpid_combo  - TPID combo up to dual VLAN tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tpid_combo_set(struct tpm_tpid_combo_t *tpid_combo);
+
+/*******************************************************************************
+* tpm_init_tpid_combo_del()
+*
+* DESCRIPTION: delete TPID combo up to dual VLAN tag
+*
+* INPUTS:
+*	tpid_combo  - TPID combo up to dual VLAN tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tpid_combo_del(struct tpm_tpid_combo_t *tpid_combo);
+
+/*******************************************************************************
+* tpm_init_tcp_flag_check_set()
+*
+* DESCRIPTION: set the flag that whether check TCP flag
+*
+* INPUTS:
+*	tcp_flag_check  - whether check TCP flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tcp_flag_check_set(enum tpm_tcp_flag_check_t tcp_flag_check);
+
+/*******************************************************************************
+* tpm_init_trace_debug_flag_set()
+*
+* DESCRIPTION: set the trace and debug flag
+*
+* INPUTS:
+*	trace_debug_flag  - Flag to control TPM trace and debug level
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_trace_debug_flag_set(unsigned int trace_debug_flag);
+
+/*******************************************************************************
+* tpm_init_qos_tbl_ext_set()
+*
+* DESCRIPTION: set the QoS table extention mode
+*
+* INPUTS:
+*	qos_tbl_ext  - QoS table extention mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_qos_tbl_ext_set(enum tpm_qos_tbl_owner_t qos_tbl_ext);
+
+/*******************************************************************************
+* tpm_init_cnm_support_set()
+*
+* DESCRIPTION: set the flag that whether support CTC CnM
+*
+* INPUTS:
+*	cnm_support -  CTC CnM support flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_cnm_support_set(enum tpm_init_cnm_mode_t cnm_support);
+
+/*******************************************************************************
+* tpm_init_filter_type_set()
+*
+* DESCRIPTION: set a filter type
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	priority		-  priority value of this filter within its rule type
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_filter_type_set(
+	unsigned char			rule_type,
+	unsigned char			priority,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num);
+
+/*******************************************************************************
+* tpm_init_db_init()
+*
+* DESCRIPTION: Perform DB Initialization for init module.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+int tpm_init_db_init(void);
+
+/*******************************************************************************
+* tpm_module_init()
+*
+* DESCRIPTION: Initialize the TPM module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* Comments:
+*	This function will be called once TPM kernel module is loaded
+*
+*******************************************************************************/
+int tpm_module_init(void);
+
+/*******************************************************************************
+* tpm_module_start()
+*
+* DESCRIPTION: Starts the TPM module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* Comments:
+*	This function will be triggered by other applications
+*
+*******************************************************************************/
+int tpm_module_start(void);
+
+/*******************************************************************************
+* tpm_module_mib_reset()
+*
+* DESCRIPTION: handle TPM module MIB reset on fly
+*
+* INPUTS:
+*	reset_level  - reset level, determine which parts are reset in TPM
+*			0: high level, reset all TPM configuration and reset TPM to none started state
+*			1: medium level, reset all TPM configuration including parser config
+*			2: low level, reset TPM configuration except parser config
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_module_mib_reset(enum tpm_reset_level_enum_t reset_level);
+
+
+#endif /* _TPM_INIT_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_internal_types.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_internal_types.h
new file mode 100644
index 0000000..dca93fa
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_internal_types.h
@@ -0,0 +1,697 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_internal_types.h
+*
+* DESCRIPTION:
+*               Internal definietion shared by sub-modules
+*
+* DEPENDENCIES:
+*              None
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_INTERNAL_TYPES_H_
+#define _TPM_INTERNAL_TYPES_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_FALSE	(0)	/* TPM false state	*/
+#define TPM_TRUE	(1)	/* TPM true state	*/
+
+/* additional match filed bm, internal use */
+#define TPM_MATCH_TTL			0x1000000
+#define TPM_MATCH_TCP_FLAG_RF		0x2000000
+#define TPM_MATCH_TCP_FLAG_S		0x4000000
+#define TPM_MATCH_MH			0x8000000
+
+#define MAC_ADDR_SIZE			(6)
+#define IPV4_ADDR_SIZE			(4)
+#define IPV6_ADDR_SIZE			(16)
+#define WORD_BYTES			(4)
+#define SHORT_BITS			(16)
+#define BYTE_BITS			(8)
+#define BYTE_MASK			(0xFF)
+#define IPV4_VER			(4)
+#define IPV6_VER			(6)
+#define VLAN_PBIT_OFF			(13)/* The offset of pbit on VLAN */
+/* IPvx Multist related */
+#define IP4_MC_MAC_2BYTE		(0x0100)
+#define IP4_MC_MAC_2BYTE_MASK		(0xFF00)
+#define IP6_MC_MAC_2BYTE		(0x3333)
+#define IP6_MC_MAC_2BYTE_MASK		(0xFFFF)
+
+#define TPM_FLOW_FIELD_COUNT_MAX	(4)
+#define TPM_VIRT_PORT_ID_MAX		(63)
+
+#define TPM_HWF_MOD_IPTR_MAX		(255)
+#define TPM_HW_MOD_DPTR_MAX		(23552)/* Private data 41KB, 41K/2 */
+#define TPM_POLICER_ID_MAX		ACT_DUP_POLICER_MAX
+#define TPM_DSCP_VALUE_MAX		ACT_QOS_ATTR_DSCP_MAX
+#define TPM_PRI_VALUE_MAX		ACT_QOS_ATTR_PRI_MAX
+#define TPM_CPU_SWITCH_PORT		(6)
+#define TPM_GMAC0_CONNECT_SW_PORT	TPM_CPU_SWITCH_PORT
+#define TPM_GMAC1_CONNECT_SW_PORT	(4)
+
+
+/* Port definition
+------------------------------------------------------------------------------*/
+#define TPM_NUM_ETH_GMACS		(2)	/* The number of GMAC connected to Ethernet port	*/
+#define TPM_NUM_MAX_GMAC_PORTS		(3)	/* Maximum number of GMAC ports				*/
+#define TPM_NUM_MAX_UNI_PORTS		(5)	/* Maximum number of UNI  ports				*/
+#define TPM_NUM_MAX_UNI_PORTS_BM	(1 << (TPM_NUM_MAX_UNI_PORTS - 1))/* Maximum bit map of UNI  ports	*/
+#define TPM_UNI_PORTS_BM		(0x3f)	/* The UNI port bitmap used by MH			*/
+#define TPM_NUM_DEFAULT_UNI_PORTS	(4)	/* Default number of UNI  ports				*/
+#define TPM_SWITCH_UPLINK_PORT		(6)	/* Switch uplink port					*/
+#define TPM_NUM_TX_PORTS		(18)	/* TX ports number, 0-15 for TCONT, 16 -17 for G0/1, 18 for lpbk*/
+#define TPM_TX_PORT_LPBK_IDX		(18)	/* loopback port TX ports index */
+
+/* Port Bit Map */
+#define TPM_SRC_PORT_GMAC0_BM		(1 << TPM_ENUM_GMAC_0)
+#define TPM_SRC_PORT_PON_BM		(1 << TPM_ENUM_PMAC)
+
+/* WAY definition
+------------------------------------------------------------------------------*/
+#define TPM_WAY_PON			(1)	/* WAY of PON		*/
+#define TPM_WAY_NON_PON			(0)	/* WAY of NONE PON port	*/
+
+/* Queue definition
+------------------------------------------------------------------------------*/
+#define TPM_NUM_MAX_QUEUE		(8)	/* Maximum number of queue for GMAC or TCONT	*/
+#define TPM_NUM_DEFAULT_CPU_QUEUE	(7)	/* Default number of queue for GMAC or TCONT	*/
+#define TPM_QUEUE_HIGH_SHIFT		(3)	/* shift of queue high				*/
+#define TPM_QUEUE_HIGH_MASK		(0x1f)	/* mask of queue high				*/
+#define TPM_QUEUE_LOW_MASK		(0x07)	/* mask of queue low				*/
+#define TPM_TCONT_NUM_MAX		(16)	/* Maximum number of TCONT */
+
+/* Capbility definition
+------------------------------------------------------------------------------*/
+#define TPM_NUM_MAX_CAPABILITIES	(64)	/* Maximum number of capabilities		*/
+#define TPM_NUM_MAX_PRECEDENCE		(64)	/* Maximum number of precedence			*/
+#define TPM_NUM_MIN_PORT_HITS		(1)	/* Minimum number of port hits			*/
+#define TPM_NUM_MAX_PORT_HITS		(2)	/* Maximum number of port hits			*/
+#define TPM_NUM_MAX_FILED_NUM		(4)	/* Maximum number of fileds per capability	*/
+#define TPM_NUM_MAX_RULE_TYPE_NUM	(15)	/* Maximum number of rule_type	*/
+
+/* VLAN tag definition
+------------------------------------------------------------------------------*/
+#define TPM_NUM_MAX_TPID_COMBO		(16)	/* Maximum number of TPID combo up to dual tag		*/
+#define TPM_NUM_VLAN_ETYPE_REGS		(3)	/* Maximum number of Ethernet type registers		*/
+#define TPM_NUM_MAX_FILTER_TYPE		(8)	/* Maximum number of filter type			*/
+#define TPM_INVALID_TPID		(0xFFFF)/* Invalid TPID for VLAN modification, TPID combo	*/
+#define TPM_MAX_VLAN_ID_VALUE		(4095)	/* Maximum legal VLAN ID value				*/
+#define TPM_MIN_VLAN_ID_VALUE		(0)	/* Minum legal VLAN ID value				*/
+#define TPM_MAX_PBITS_VALUE		(7)	/* Maximum legal P-bits value				*/
+#define TPM_INVALID_VLAN_ID		(0xFFFF)/* Invalid VLAN ID value				*/
+#define TPM_VID_MASK			(0xFFF)	/* VID mask						*/
+
+
+/* MTU definition
+------------------------------------------------------------------------------*/
+/*default layer 2 MTU size, default L3 MTU + MH + DMAC + SMAC + VLAN tag + VLAN tags	*/
+#define TPM_DEFAULT_L2_MTU_SIZE		(1500+2+12+4+4)
+
+/* Whether it is default LSP LU ID
+------------------------------------------------------------------------------*/
+#define LUID_IS_LSP_RESERVED(luid)	((luid == FLOWID_DEF(TPM_ENUM_GMAC_0)) ||\
+					 (luid == FLOWID_DEF(TPM_ENUM_GMAC_1)) ||\
+					 (luid == FLOWID_DEF(TPM_ENUM_GMAC_LPK)) ||\
+					 (luid == FLOWID_DEF(TPM_ENUM_PMAC)))
+
+/* IPV4 Multicast IP */
+#define TPM_IPV4_MC_IP			(0xE0)
+#define TPM_IPV4_MC_IP_MASK		(0xE0)
+#define TPM_IGMP_MAC_ADDR_MASK		(0x7F)/* Mask the 25th bit of MAC address */
+
+/* IPV6 Multicast IP */
+#define TPM_IPV6_MC_IP			(0xFF)
+#define TPM_IPV6_MC_IP_MASK		(0xFF)
+
+/* Multicast MAC */
+#define TPM_MC_MAC			(0x01)
+#define TPM_MC_MAC_MASK			(0xFF)
+
+/* Rxq high of MAC */
+#define TPM_RXQ_QH_GMAC0		(0x0 >> TPM_QUEUE_HIGH_SHIFT)
+#define TPM_RXQ_QH_GMAC1		(0x8 >> TPM_QUEUE_HIGH_SHIFT)
+#define TPM_RXQ_QH_LPBK			(0x10 >> TPM_QUEUE_HIGH_SHIFT)
+#define TPM_RXQ_QH_PON			(0x18 >> TPM_QUEUE_HIGH_SHIFT)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+/* Traffic type */
+enum tpm_traffic_type_t {
+	LSP_GMAC0_DEFAULT = 0,
+	LSP_LPK_GMAC_DEFAULT,
+	LSP_PON_DEFAULT,
+	IPV4_UC_RTR_NF_NPPOE_UNTAG,
+	IPV4_UC_RTR_NF_NPPOE_STAG,
+	IPV4_UC_RTR_NF_NPPOE_DTAG,
+	IPV4_UC_RTR_NF_NPPOE_TTAG,/* Triple Tag */
+	IPV4_UC_RTR_NF_PPOE_UNTAG,
+	IPV4_UC_RTR_NF_PPOE_STAG,
+	IPV4_UC_RTR_NF_PPOE_DTAG,
+	IPV4_UC_RTR_NF_PPOE_TTAG,
+	IPV4_UC_RTR_FRAG_NPPOE_UNTAG,
+	IPV4_UC_RTR_FRAG_NPPOE_STAG,
+	IPV4_UC_RTR_FRAG_NPPOE_DTAG,
+	IPV4_UC_RTR_FRAG_NPPOE_TTAG,
+	IPV4_UC_RTR_FRAG_PPOE_UNTAG,
+	IPV4_UC_RTR_FRAG_PPOE_STAG,
+	IPV4_UC_RTR_FRAG_PPOE_DTAG,
+	IPV4_UC_RTR_FRAG_PPOE_TTAG,
+	NON_IP_MTM_UNTAG,
+	NON_IP_MTM_STAG,
+	NON_IP_MTM_DTAG,
+	NON_IP_MTM_TTAG,
+	IPV4_MC_RTR_UNTAG,
+	IPV4_MC_L2_UNTAG,
+	NON_IP_MC_UNTAG,
+	IPV4_MC_RTR_TAG,
+	IPV4_MC_RTR_DTAG,
+	IPV4_MC_L2_TAG,
+	NON_IP_MC_TAG,
+	IPV4_MC_L2_DTAG,
+	NON_IP_MC_DTAG,
+	IPV6_MC_RTR_UNTAG,
+	IPV6_MC_L2_UNTAG,
+	IPV6_MC_RTR_TAG,
+	IPV6_MC_RTR_DTAG,
+	IPV6_MC_L2_TAG,
+	IPV6_MC_L2_DTAG,
+	IPV4_L2_MC_BRG_NF_UNTAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV4_L2_MC_BRG_NF_STAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV4_L2_MC_BRG_NF_DTAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV6_L2_MC_BRG_NF_UNTAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV6_L2_MC_BRG_NF_STAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV6_L2_MC_BRG_NF_DTAG,/* L2 MC packet, which is taken as BRG packet */
+	IPV4_UC_BRG_NF_UNTAG,
+	IPV4_BC_L2_NF_UNTAG,
+	IPV4_BC_L3_NF_UNTAG,
+	IPV4_UC_BRG_NF_STAG,
+	IPV4_BC_L2_NF_STAG,
+	IPV4_BC_L3_NF_STAG,
+	IPV4_UC_BRG_NF_DTAG,
+	IPV4_BC_L2_NF_DTAG,
+	IPV4_BC_L3_NF_DTAG,
+	IPV4_UC_BRG_NF_TTAG,
+	IPV6_UC_BRG_NF_UNTAG,
+	IPV6_BC_L2_NF_UNTAG,
+	IPV6_BC_L3_NF_UNTAG,
+	IPV6_UC_BRG_NF_STAG,
+	IPV6_BC_L2_NF_STAG,
+	IPV6_BC_L3_NF_STAG,
+	IPV6_UC_BRG_NF_DTAG,
+	IPV6_BC_L2_NF_DTAG,
+	IPV6_BC_L3_NF_DTAG,
+	IPV6_UC_BRG_NF_TTAG,
+	PPOE_BRG_UNTAG,
+	NON_IP_BC_UNTAG,
+	NON_IP_BRG_UNTAG,
+	PPOE_BRG_STAG,
+	NON_IP_BC_STAG,
+	NON_IP_BRG_STAG,
+	PPOE_BRG_DTAG,
+	PPOE_BRG_TTAG,
+	NON_IP_BC_DTAG,
+	NON_IP_BRG_DTAG,
+	NON_IP_BRG_TTAG,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_STAG,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_TTAG,
+	IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG,
+	IPV6_UC_RTR_SPEC_EX_PPOE_STAG,
+	IPV6_UC_RTR_SPEC_EX_PPOE_DTAG,
+	IPV6_UC_RTR_SPEC_EX_PPOE_TTAG,
+	IPV6_UC_RTR_NOEX_NPPOE_UNTAG,
+	IPV6_UC_RTR_NOEX_NPPOE_STAG,
+	IPV6_UC_RTR_NOEX_NPPOE_DTAG,
+	IPV6_UC_RTR_NOEX_NPPOE_TTAG,
+	IPV6_UC_RTR_NOEX_PPOE_UNTAG,
+	IPV6_UC_RTR_NOEX_PPOE_STAG,
+	IPV6_UC_RTR_NOEX_PPOE_DTAG,
+	IPV6_UC_RTR_NOEX_PPOE_TTAG,
+	IPV6_UC_RTR_GEN_EX_NPPOE_UNTAG,
+	IPV6_UC_RTR_GEN_EX_NPPOE_STAG,
+	IPV6_UC_RTR_GEN_EX_NPPOE_DTAG,
+	IPV6_UC_RTR_GEN_EX_NPPOE_TTAG,
+	IPV6_UC_RTR_GEN_EX_PPOE_UNTAG,
+	IPV6_UC_RTR_GEN_EX_PPOE_STAG,
+	IPV6_UC_RTR_GEN_EX_PPOE_DTAG,
+	IPV6_UC_RTR_GEN_EX_PPOE_TTAG,
+	NON_IP_ARP,
+	LOOPBACK_PORT_PKT,
+	UNEXPECTED_PKT,
+	TPM_TRAFFIC_TYPE_MAX
+};
+
+/* Classifier lookup ID enum */
+enum tpm_lu_id_enum_t {
+	LSP_GMAC0_DEFAULT_ID			= 0,
+	SPECIAL_PKT_TO_CPU_ID			= 1,
+	LSP_LPK_GMAC_DEFAULT_ID			= 2,
+	LSP_PON_DEFAULT_ID			= 7,
+	IPV4_UC_RTR_NF_NPPOE_UNTAG_ID		= 8,
+	IPV4_UC_RTR_NF_NPPOE_STAG_ID		= 9,
+	IPV4_UC_RTR_NF_NPPOE_DTAG_ID		= 10,
+	IPV4_UC_RTR_NF_NPPOE_TTAG_ID		= 10, /* IPV4_UC_RTR_NF_NPPOE_DTAG_ID */
+	IPV4_UC_RTR_NF_PPOE_UNTAG_ID		= 11,
+	IPV4_UC_RTR_NF_PPOE_STAG_ID		= 12,
+	IPV4_UC_RTR_NF_PPOE_DTAG_ID		= 13,
+	IPV4_UC_RTR_NF_PPOE_TTAG_ID		= 13, /* IPV4_UC_RTR_NF_PPOE_DTAG_ID */
+	IPV4_UC_RTR_FRAG_NPPOE_UNTAG_ID		= 14,
+	IPV4_UC_RTR_FRAG_NPPOE_STAG_ID		= 15,
+	IPV4_UC_RTR_FRAG_NPPOE_DTAG_ID		= 16,
+	IPV4_UC_RTR_FRAG_NPPOE_TTAG_ID		= 16, /* IPV4_UC_RTR_FRAG_NPPOE_DTAG_ID */
+	IPV4_UC_RTR_FRAG_PPOE_UNTAG_ID		= 17,
+	IPV4_UC_RTR_FRAG_PPOE_STAG_ID		= 18,
+	IPV4_UC_RTR_FRAG_PPOE_DTAG_ID		= 19,
+	IPV4_UC_RTR_FRAG_PPOE_TTAG_ID		= 19, /* IPV4_UC_RTR_FRAG_PPOE_DTAG_ID */
+	NON_IP_MTM_UNTAG_ID			= 20,
+	NON_IP_MTM_STAG_ID			= 21,
+	NON_IP_MTM_DTAG_ID			= 22,
+	NON_IP_MTM_TTAG_ID			= 22, /* NON_IP_MTM_DTAG_ID */
+	IPV4_MC_RTR_UNTAG_ID			= 23,
+	IPV4_MC_L2_UNTAG_ID			= 23, /* IPV4_MC_RTR_UNTAG_ID */
+	NON_IP_MC_UNTAG_ID			= 23,
+	IPV4_MC_RTR_TAG_ID			= 24,
+	IPV4_MC_RTR_DTAG_ID			= 24, /* IPV4_MC_RTR_TAG_ID */
+	IPV4_MC_L2_TAG_ID			= 24, /* IPV4_MC_RTR_TAG_ID */
+	IPV4_MC_L2_DTAG_ID			= 24, /* IPV4_MC_L2_TAG_ID */
+	NON_IP_MC_STAG_ID			= 24,
+	NON_IP_MC_DTAG_ID			= 24,
+	IPV6_MC_RTR_UNTAG_ID			= 25,
+	IPV6_MC_L2_UNTAG_ID			= 25, /* IPV6_MC_RTR_UNTAG_ID */
+	IPV6_MC_RTR_TAG_ID			= 26,
+	IPV6_MC_RTR_DTAG_ID			= 26, /* IPV6_MC_RTR_TAG_ID */
+	IPV6_MC_L2_TAG_ID			= 26, /* IPV6_MC_RTR_TAG_ID */
+	IPV6_MC_L2_DTAG_ID			= 26, /* IPV6_MC_L2_TAG_ID */
+	IPV4_UC_BRG_NF_UNTAG_ID			= 27,
+	IPV4_BC_L2_NF_UNTAG_ID			= 27, /* IPV4_UC_BRG_NF_UNTAG_ID */
+	IPV4_BC_L3_NF_UNTAG_ID			= 27, /* IPV4_UC_BRG_NF_UNTAG_ID */
+	IPV4_UC_BRG_NF_STAG_ID			= 28,
+	IPV4_BC_L2_NF_STAG_ID			= 28, /* IPV4_UC_BRG_NF_STAG_ID */
+	IPV4_BC_L3_NF_STAG_ID			= 28, /* IPV4_UC_BRG_NF_STAG_ID */
+	IPV4_UC_BRG_NF_DTAG_ID			= 29,
+	IPV4_BC_L2_NF_DTAG_ID			= 29, /* IPV4_UC_BRG_NF_DTAG_ID */
+	IPV4_BC_L3_NF_DTAG_ID			= 29, /* IPV4_UC_BRG_NF_DTAG_ID */
+	IPV4_UC_BRG_NF_TTAG_ID			= 29, /* IPV4_UC_BRG_NF_DTAG_ID */
+	IPV6_UC_BRG_NF_UNTAG_ID			= 30,
+	IPV6_BC_L2_NF_UNTAG_ID			= 30, /* IPV6_UC_BRG_NF_UNTAG_ID */
+	IPV6_BC_L3_NF_UNTAG_ID			= 30, /* IPV6_UC_BRG_NF_UNTAG_ID */
+	IPV6_UC_BRG_NF_STAG_ID			= 31,
+	IPV6_BC_L2_NF_STAG_ID			= 31, /* IPV6_UC_BRG_NF_STAG_ID */
+	IPV6_BC_L3_NF_STAG_ID			= 31, /* IPV6_UC_BRG_NF_STAG_ID */
+	IPV6_UC_BRG_NF_DTAG_ID			= 32,
+	IPV6_BC_L2_NF_DTAG_ID			= 32, /* IPV6_UC_BRG_NF_DTAG_ID */
+	IPV6_BC_L3_NF_DTAG_ID			= 32, /* IPV6_UC_BRG_NF_DTAG_ID */
+	IPV6_UC_BRG_NF_TTAG_ID			= 32, /* IPV6_UC_BRG_NF_DTAG_ID */
+	PPOE_BRG_UNTAG_ID			= 33,
+	NON_IP_BRG_UNTAG_ID			= 33, /* PPOE_BRG_UNTAG_ID */
+	NON_IP_BC_UNTAG_ID			= 33, /* NON_IP_BRG_UNTAG_ID */
+	PPOE_BRG_STAG_ID			= 34,
+	NON_IP_BRG_STAG_ID			= 34, /* PPOE_BRG_STAG_ID */
+	NON_IP_BC_STAG_ID			= 34, /* NON_IP_BRG_STAG_ID */
+	PPOE_BRG_DTAG_ID			= 35,
+	PPOE_BRG_TTAG_ID			= 35, /* PPOE_BRG_DTAG_ID */
+	NON_IP_BRG_DTAG_ID			= 35, /* PPOE_BRG_DTAG_ID */
+	NON_IP_BC_DTAG_ID			= 35, /* NON_IP_BRG_DTAG_ID */
+	NON_IP_BRG_TTAG_ID			= 35, /* NON_IP_BRG_DTAG_ID */
+	IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG_ID	= 36,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_STAG_ID	= 37,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG_ID	= 38,
+	IPV6_UC_RTR_SPEC_EX_NPPOE_TTAG_ID	= 38, /* IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG_ID */
+	IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG_ID	= 39,
+	IPV6_UC_RTR_SPEC_EX_PPOE_STAG_ID	= 40,
+	IPV6_UC_RTR_SPEC_EX_PPOE_DTAG_ID	= 41,
+	IPV6_UC_RTR_SPEC_EX_PPOE_TTAG_ID	= 41, /* IPV6_UC_RTR_SPEC_EX_PPOE_DTAG_ID */
+	IPV6_UC_RTR_NOEX_NPPOE_UNTAG_ID		= 42,
+	IPV6_UC_RTR_GEN_EX_NPPOE_UNTAG_ID	= 42, /* IPV6_UC_RTR_NOEX_NPPOE_UNTAG_ID */
+	IPV6_UC_RTR_NOEX_NPPOE_STAG_ID		= 43,
+	IPV6_UC_RTR_GEN_EX_NPPOE_STAG_ID	= 43, /* IPV6_UC_RTR_NOEX_NPPOE_STAG_ID */
+	IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID		= 44,
+	IPV6_UC_RTR_NOEX_NPPOE_TTAG_ID		= 44, /* IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID */
+	IPV6_UC_RTR_GEN_EX_NPPOE_DTAG_ID	= 44, /* IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID */
+	IPV6_UC_RTR_GEN_EX_NPPOE_TTAG_ID	= 44, /* IPV6_UC_RTR_GEN_EX_NPPOE_DTAG_ID */
+	IPV6_UC_RTR_NOEX_PPOE_UNTAG_ID		= 45,
+	IPV6_UC_RTR_GEN_EX_PPOE_UNTAG_ID	= 45, /* IPV6_UC_RTR_NOEX_PPOE_UNTAG_ID */
+	IPV6_UC_RTR_NOEX_PPOE_STAG_ID		= 46,
+	IPV6_UC_RTR_GEN_EX_PPOE_STAG_ID		= 46, /* IPV6_UC_RTR_NOEX_PPOE_STAG_ID */
+	IPV6_UC_RTR_NOEX_PPOE_DTAG_ID		= 47,
+	IPV6_UC_RTR_NOEX_PPOE_TTAG_ID		= 47, /* IPV6_UC_RTR_NOEX_PPOE_DTAG_ID */
+	IPV6_UC_RTR_GEN_EX_PPOE_DTAG_ID		= 47, /* IPV6_UC_RTR_NOEX_PPOE_DTAG_ID */
+	IPV6_UC_RTR_GEN_EX_PPOE_TTAG_ID		= 47, /* IPV6_UC_RTR_GEN_EX_PPOE_DTAG_ID */
+
+	IPV4_UC_BRG_FRAG_UNTAG_ID		= 48,
+	IPV4_UC_BRG_FRAG_STAG_ID		= 49,
+	IPV4_UC_BRG_FRAG_DTAG_ID		= 50,
+	IPV6_UC_BRG_FRAG_UNTAG_ID		= 51,
+	IPV6_UC_BRG_FRAG_STAG_ID		= 52,
+	IPV6_UC_BRG_FRAG_DTAG_ID		= 53,
+	NON_IP_ARP_ID				= 54,
+	LOOPBACK_PKT_ID				= 55,
+	UNEXPECTED_PKT_ID			= 56
+};
+
+/* TPM module state
+------------------------------------------------------------------------------*/
+enum tpm_module_state_t {
+	TPM_MODULE_NOT_START,	/* TPM module does not start	*/
+	TPM_MODULE_STARTED	/* TPM module already starts	*/
+};
+
+enum tpm_color_action_type_t {
+	TPM_COLOR_ACTION_TYPE_NO_UPDT,		/* Do not update color */
+	TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK,	/* Do not update color and lock */
+	TPM_COLOR_ACTION_TYPE_GREEN,		/* Update to green */
+	TPM_COLOR_ACTION_TYPE_YELLOW = 4,	/* Update to yellow */
+	TPM_COLOR_ACTION_TYPE_RED = 6,		/* Update to red */
+	TPM_COLOR_ACTION_TYPE_RED_LOCK = 7,	/* Update to red and lock */
+};
+
+enum tpm_action_type_t {
+	TPM_ACTION_TYPE_NO_UPDT,		/* The field will be not updated */
+	TPM_ACTION_TYPE_NO_UPDT_LOCK,		/* The field will be not updated and lock */
+	TPM_ACTION_TYPE_UPDT,			/* The field will be updated */
+	TPM_ACTION_TYPE_UPDT_LOCK,		/* The field will be updated and lock */
+};
+
+enum tpm_action_flowid_type_t {
+	TPM_ACTION_FLOWID_DISABLE = 0,		/* FlowID is disable */
+	TPM_ACTION_FLOWID_ENABLE,		/* FlowID is enable */
+};
+
+enum tpm_frwd_action_type_t {
+	TPM_FRWD_ACTION_TYPE_NO_UPDT,			/* The decision will be not updated */
+	TPM_FRWD_ACTION_TYPE_NO_UPDT_LOCK,		/* The decision is not updated, and following no change to it */
+	TPM_FRWD_ACTION_TYPE_SWF,			/* The packet to CPU (Software Forwarding) */
+	TPM_FRWD_ACTION_TYPE_SWF_LOCK,			/* The packet to CPU, and following no change to it */
+	TPM_FRWD_ACTION_TYPE_HWF,			/* The packet to one transmit port (Hardware Forwarding) */
+	TPM_FRWD_ACTION_TYPE_HWF_LOCK,			/* The packet to one tx port, and following no change to it */
+	TPM_FRWD_ACTION_TYPE_HWF_LOW_LATENCY,		/* The pkt to one tx port, and maybe internal packets is used */
+	TPM_FRWD_ACTION_TYPE_HWF_LOW_LATENCY_LOCK,	/* Same to above, but following no change to it*/
+};
+
+enum tpm_src_port_bm_t {
+	TPM_SRC_PORT_G0 = 0x1,
+	TPM_SRC_PORT_G1 = 0x2,
+	TPM_SRC_PORT_LPBK = 0x4,
+	TPM_SRC_PORT_PON = 0x80,
+};
+
+enum tpm_src_port_type_t {
+	TPM_SRC_PORT_TYPE_PHY,
+	TPM_SRC_PORT_TYPE_UNI,
+	TPM_SRC_PORT_TYPE_VIR
+};
+
+enum tpm_cls_field_id_t {
+	MH_FIELD_ID			= 0,
+	GEM_PORT_ID_FIELD_ID		= 1,
+	MH_UNTAGGED_PRI_FIELD_ID	= 2,
+	MAC_DA_FIELD_ID			= 3,
+	MAC_SA_FIELD_ID			= 4,
+	OUT_VLAN_PRI_FIELD_ID		= 5,
+	OUT_VLAN_ID_FIELD_ID		= 6,
+	IN_VLAN_ID_FIELD_ID		= 7,
+	ETH_TYPE_FIELD_ID		= 8,
+	PPPOE_FIELD_ID			= 9,
+	IP_VER_FIELD_ID			= 10,
+	IPV4_DSCP_FIELD_ID		= 11,
+	IPV4_ECN_FIELD_ID		= 12,
+	IPV4_LEN_FIELD_ID		= 13,
+	IPV4_TTL_FIELD_ID		= 14,
+	IPV6_HL_FIELD_ID		= 14,
+	IPV4_PROTO_FIELD_ID		= 15,
+	IPV6_PROTO_FIELD_ID		= 15,
+	IPV4_SA_FIELD_ID		= 16,
+	IPV4_DA_FIELD_ID		= 17,
+	IPV6_DSCP_FIELD_ID		= 18,
+	IPV6_ECN_FIELD_ID		= 19,
+	IPV6_FLOW_LBL_FIELD_ID		= 20,
+	IPV6_PAYLOAD_LEN_FIELD_ID	= 21,
+	IPV6_NH_FIELD_ID		= 22,
+	IPV6_SA_FIELD_ID		= 23,
+	IPV6_SA_PREF_FIELD_ID		= 24,
+	IPV6_SA_SUFF_FIELD_ID		= 25,
+	IPV6_DA_FIELD_ID		= 26,
+	IPV6_DA_PREF_FIELD_ID		= 27,
+	IPV6_DA_SUFF_FIELD_ID		= 28,
+	L4_SRC_FIELD_ID			= 29,
+	L4_DST_FIELD_ID			= 30,
+	TCP_FLAGS_FIELD_ID		= 31,
+	ARP_IPV4_DA_FIELD_ID		= 48,
+	CLS_FIELD_MAX			= 33
+
+};
+
+enum tpm_cls_field_size_t {/* unit: bits */
+	MH_FIELD_SIZE			= 16,
+	GEM_PORT_ID_FIELD_SIZE		= 12,
+	MH_UNTAGGED_PRI_FIELD_SIZE	= 3 ,
+	MAC_DA_FIELD_SIZE		= 48,
+	MAC_SA_FIELD_SIZE		= 48,
+	OUT_VLAN_PRI_FIELD_SIZE	= 3,
+	OUT_VLAN_ID_FIELD_SIZE		= 12,
+	IN_VLAN_ID_FIELD_SIZE		= 12,
+	ETH_TYPE_FIELD_SIZE		= 16,
+	PPPOE_FIELD_SIZE		= 16,
+	IP_VER_FIELD_SIZE		= 4,
+	IPV4_DSCP_FIELD_SIZE		= 6,
+	IPV4_ECN_FIELD_SIZE		= 2,
+	IPV4_LEN_FIELD_SIZE		= 16,
+	IPV4_TTL_FIELD_SIZE		= 8,
+	IPV4_PROTO_FIELD_SIZE		= 8,
+	IPV4_SA_FIELD_SIZE		= 32,
+	IPV4_DA_FIELD_SIZE		= 32,
+	IPV6_PROTO_FIELD_SIZE		= 8,
+	IPV6_DSCP_FIELD_SIZE		= 6,
+	IPV6_ECN_FIELD_SIZE		= 2,
+	IPV6_FLOW_LBL_FIELD_SIZE	= 20,
+	IPV6_PAYLOAD_LEN_FIELD_SIZE	= 16,
+	IPV6_NH_FIELD_SIZE		= 8,
+	IPV6_HL_FIELD_SIZE		= 8,
+	IPV6_SA_FIELD_SIZE		= 128,
+	IPV6_SA_PREF_FIELD_SIZE		= 64,
+	IPV6_SA_SUFF_FIELD_SIZE		= 64,
+	IPV6_DA_FIELD_SIZE		= 128,
+	IPV6_DA_PREF_FIELD_SIZE		= 64,
+	IPV6_DA_SUFF_FIELD_SIZE	= 64,
+	L4_SRC_FIELD_SIZE		= 16,
+	L4_DST_FIELD_SIZE		= 16,
+	TCP_FLAGS_FIELD_SIZE		= 8,
+	ARP_IPV4_DA_FIELD_SIZE		= 32
+};
+
+enum tpm_cls_field_valid_t {
+	TPM_FIELD_INVALID = 0,
+	TPM_FIELD_VALID
+};
+
+enum tpm_engine_no_t {
+	TPM_ENGINE_C2 = 1,
+	TPM_ENGINE_C3_A,
+	TPM_ENGINE_C3_B,
+	TPM_ENGINE_C4,
+	TPM_ENGINE_C5,
+};
+
+enum tpm_l4_type_t {
+	TPM_L4_TYPE_NO_EXIST = 0,		/* L4 Info no exist */
+	TPM_L4_TYPE_TCP,			/* TCP type */
+	TPM_L4_TYPE_UDP,			/* UDP type */
+	TPM_L4_TYPE_MAX = TPM_L4_TYPE_UDP,
+};
+
+enum tpm_l4_checksum_gen_t {
+	TPM_L4_CKSUM_NO_GEN = 0,		/* Not Generate L4 checksum */
+	TPM_L4_CKSUM_GEN,			/* Generate L4 checksum */
+};
+
+/* Possible Physical internal connections for a Packet Processor Ethernet GMAC (GMAC0/GMAC1)
+*  Need update in future according to possible connection
+*/
+enum tpm_gmac_conn_t {
+	TPM_GMAC_CON_DISC = 0,	/* Disconnected */
+	TPM_GMAC_CON_SWITCH_4,	/* Amber Switch Port #4 */
+	TPM_GMAC_CON_SWITCH_6,	/* Amber Switch Port #6 */
+	TPM_GMAC_CON_GE_PHY	/* Internal Gig PHY */
+};
+
+enum tpm_queue_type_t {
+	TPM_CPU_RX_QUEUE = 0,	/* CPU RX queue		*/
+	TPM_HWF_TX_QUEUE	/* HWF/CPU TX queue	*/
+};
+
+enum tpm_action_num_t {
+	TPM_ACT_NUM_IS_1 = 1,
+	TPM_ACT_NUM_IS_2,
+	TPM_ACT_NUM_IS_3,
+	TPM_ACT_NUM_IS_4,
+	TPM_ACT_NUM_IS_5,
+	TPM_ACT_NUM_IS_6,
+	TPM_ACT_NUM_IS_7,
+	TPM_ACT_NUM_IS_8,
+	TPM_ACT_NUM_MAX = TPM_ACT_NUM_IS_8
+};
+
+enum tpm_action_index_t {
+	TPM_ACT_IDX0,
+	TPM_ACT_IDX1,
+	TPM_ACT_IDX2,
+	TPM_ACT_IDX3,
+	TPM_ACT_IDX4,
+	TPM_ACT_IDX5,
+	TPM_ACT_IDX6,
+	TPM_ACT_IDX7,
+	TPM_ACT_IDX_MAX = TPM_ACT_IDX7
+};
+
+enum tpm_mng_vlan_tunnel_mode_t {
+	TPM_VLAN_TUNNEL_FALSE = 0,
+	TPM_VLAN_TUNNEL_TRUE
+};
+
+/* Policer bank, only for pp2.1 */
+enum tpm_plcr_bank_t {
+	TPM_PLCR_BANK0 = 0,
+	TPM_PLCR_BANK1,
+};
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/* This bit selects the value of the Port ID forwareded to the C2, C3 engines */
+enum tpm_cls_port_id_sel_t {
+	TPM_CLS_PORT_ID_FROM_TBL = 0,
+	TPM_CLS_PORT_ID_FROM_PKT,
+};
+#endif
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_mng_pkt_key_t {
+	struct tpm_pkt_key_t *pkt_key;
+	unsigned char      ttl;
+	unsigned char      tcp_flag;
+	unsigned char      tcp_flag_mask;
+	unsigned short     mh;
+	unsigned short     mh_mask;
+};
+
+struct tpm_mng_pkt_key_db_t {
+	struct tpm_pkt_key_t	pkt_key;
+	unsigned char		ttl;
+	unsigned char		tcp_flag;
+	unsigned char		tcp_flag_mask;
+	unsigned char		dummy;
+};
+
+struct tpm_engine_pkt_action_t {
+	enum tpm_color_action_type_t	color_act;
+	enum tpm_action_type_t		pri_act;
+	enum tpm_action_type_t		dscp_act;
+	enum tpm_action_type_t		gemp_act;
+	enum tpm_action_type_t		q_low_act;
+	enum tpm_action_type_t		q_high_act;
+	enum tpm_action_type_t		policer_act;
+	enum tpm_action_flowid_type_t	flowid_act;
+	enum tpm_frwd_action_type_t	frwd_act;
+};
+
+struct tpm_engine_pkt_mod_t {
+	unsigned int	mod_cmd_idx;
+	unsigned int	mod_data_idx;
+	unsigned int	l4_chksum_update_flag;
+};
+
+struct tpm_duplicate_t {
+	unsigned int	flow_id;		/* pkt duplication flow id */
+	unsigned int	flow_cnt;		/* pkt duplication count */
+};
+
+struct tpm_field_int_value_t {
+	unsigned int	parsed_int_val;
+	unsigned int	parsed_int_val_mask;
+};
+
+struct tpm_field_mac_addr_t {
+	unsigned char	parsed_mac_addr[MAC_ADDR_SIZE];
+	unsigned char	parsed_mac_addr_mask[MAC_ADDR_SIZE];
+};
+
+
+struct tpm_field_ipv4_addr_t {
+	unsigned char	parsed_ipv4_addr[IPV4_ADDR_SIZE];
+	unsigned char	parsed_ipv4_addr_mask[IPV4_ADDR_SIZE];
+};
+
+struct tpm_field_ipv6_addr_t {
+	unsigned char	parsed_ipv6_addr[IPV6_ADDR_SIZE];
+	unsigned char	parsed_ipv6_addr_mask[IPV6_ADDR_SIZE];
+};
+
+union tpm_field_value_union_t {
+	struct tpm_field_int_value_t	int_data;
+	struct tpm_field_mac_addr_t	mac_addr;
+	struct tpm_field_ipv4_addr_t	ipv4_addr;
+	struct tpm_field_ipv6_addr_t	ipv6_addr;
+};
+
+struct tpm_field_match_info {
+	int				valid;
+	unsigned int			field_id;
+	union tpm_field_value_union_t	filed_value;
+};
+
+struct tpm_src_port_t {
+	enum tpm_src_port_type_t	port_type;
+	unsigned int			port_value;
+	unsigned int			port_mask;
+};
+
+struct tpm_hit_cnt_t {
+	unsigned int			log_idx;
+	unsigned int			phys_idx;
+	unsigned int			cntr_val;
+};
+
+struct tpm_engine_sram_t {
+	struct tpm_engine_qos_info_t	qos_info;	/* C2 QoS table info            */
+	struct tpm_engine_pkt_action_t	action;		/* update&lock info		*/
+	struct tpm_qos_value_t		qos_value;	/* qLow/qHigh			*/
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd idx and data idx	*/
+	struct tpm_duplicate_t		dup_info;	/* pkt duplication flow info    */
+};
+
+#endif /* _TPM_INTERNAL_TYPES_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
new file mode 100644
index 0000000..18d1fd8
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_log.h
@@ -0,0 +1,249 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_log.h						     **
+**									     **
+**  DESCRIPTION : This file contains macros trace log of tpm	             **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_LOG_H_
+#define _TPM_LOG_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+extern unsigned int g_tpm_trace_flag;
+#define GLOB_TRACE      g_tpm_trace_flag
+
+#define TPM_FATAL_MASK  0x80000000	/*Currently, not used */
+#define TPM_ERROR_MASK  0x40000000
+#define TPM_WARN_MASK   0x20000000
+#define TPM_INFO_MASK   0x10000000
+#define TPM_DEBUG_MASK  0x08000000
+
+#define TPM_FATAL_TRACE_LEVEL   0x80000000	/*Currently, not used */
+#define TPM_ERROR_TRACE_LEVEL   0xC0000000
+#define TPM_WARN_TRACE_LEVEL    0xE0000000
+#define TPM_INFO_TRACE_LEVEL    0xF0000000
+#define TPM_DEBUG_TRACE_LEVEL   0xF8000000
+
+#define TPM_ALL_TRACE_LEVEL     0xFFFF0000
+
+
+#define tpm_printf      printk
+
+#define TPM_PRS_MOD         (0x00000001)
+#define TPM_CLS_MOD         (0x00000002)
+#define TPM_C2_MOD          (0x00000004)
+#define TPM_C3_MOD          (0x00000008)
+#define TPM_C4_MOD          (0x00000010)
+#define TPM_PME_MOD         (0x00000020)
+#define TPM_QOS_MOD         (0x00000040)
+#define TPM_SWITCH_MOD      (0x00000080)
+#define TPM_API_MOD         (0x00000100)
+#define TPM_INIT_MOD        (0x00000200)
+#define TPM_MNG_MOD         (0x00000400)
+#define TPM_DB_MOD          (0x00000800)
+#define TPM_SYSFS_MOD       (0x00001000)
+#define TPM_COMMON_MOD      (0x00002000)
+#define TPM_IOCTL_MOD       (0x00004000)
+#define TPM_PLCR_MOD        (0x00008000)
+#define TPM_MC_MOD          (0x00010000)
+
+#define TPM_ALL_MOD         (0x0001FFFF)
+
+
+#define TPM_OS_DEBUG(module , format , ...)  \
+		{ \
+			if ((module & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE))  \
+				tpm_printf("(debug)%s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
+		}
+#define TPM_OS_INFO(module , format , ...)  \
+		{ \
+			if ((module & GLOB_TRACE) && (TPM_INFO_MASK & GLOB_TRACE))  \
+				tpm_printf("(info)%s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
+		}
+#define TPM_OS_WARN(module , format , ...)  \
+		{ \
+			if ((module & GLOB_TRACE) && (TPM_WARN_MASK & GLOB_TRACE))  \
+				tpm_printf("(warn)  %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
+		}
+#define TPM_OS_ERROR(module , format , ...) \
+		{ \
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
+				tpm_printf("(error) %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__); \
+		}
+#define TPM_OS_FATAL(module , format , ...) \
+		tpm_printf("(fatal) %s(%d):  "format , __func__ , __LINE__ , ##__VA_ARGS__);
+
+#define IF_ERROR(module, ret)	\
+		{ \
+			if (ret) {\
+				TPM_OS_ERROR(module, " recvd ret_code(%d)\n", ret);\
+				return ret;\
+			} \
+		}
+
+#define IF_ERROR_STR(module, ret, format, ...)									\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			return ret;										\
+		} \
+	}
+
+#define IF_ERROR_STR_REL_API_DATA(module, ret, api_data, format, ...)						\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			tpm_db_mng_api_data_release(api_data);							\
+			return ret;										\
+		} \
+	}
+
+#define IF_ERROR_STR_REL_TWO_API_DATA(module, ret, api_data1, api_data2, format, ...)				\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			tpm_db_mng_api_data_release(api_data1);							\
+			tpm_db_mng_api_data_release(api_data2);							\
+			return ret;										\
+		} \
+	}
+
+#define IF_ERROR_STR_RET_VOID(module, ret, format, ...)								\
+	{ \
+		if (ret) {											\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("(error) %s(%d)(rc=%d): "format , __func__ , __LINE__, ret, ##__VA_ARGS__); \
+			return;											\
+		} \
+	}
+
+#define IF_EQUAL_STR(module, var, expect, format, ...)								\
+	{ \
+		if (var == expect) {										\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("%s(%d) (var=%d): "format , __func__ , __LINE__, var, ##__VA_ARGS__); \
+			return TPM_BAD_VALUE;									\
+		} \
+	}
+
+#define IF_NOT_EQUAL_STR(module, var, expect, format, ...)							\
+	{ \
+		if (var != expect) {										\
+			if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE))				\
+				tpm_printf("%s(%d) (var!=%d): "format , __func__ , __LINE__, var, ##__VA_ARGS__); \
+			return TPM_BAD_VALUE;									\
+		} \
+	}
+
+#define IF_NULL(module, ptr)											\
+	{ \
+		if (ptr == NULL) {										\
+			TPM_OS_ERROR(module, " recvd NULL pointer\n");						\
+			return TPM_BAD_PARAM;									\
+		} \
+	}
+
+#define IF_NULL_NO_RET(module, ptr)										\
+	{ \
+		if (ptr == NULL) {										\
+			TPM_OS_ERROR(module, " recvd NULL pointer\n");						\
+			return;											\
+		} \
+	}
+
+#define TPM_DECIMAL_RANGE_VALIDATE(module, value, min, max) { \
+	if (((value) > (max)) || ((value) < (min))) { \
+		if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
+			tpm_printf("(error) %s(%d) value (%d/0x%x) is out of range[%d, %d]\n", \
+			__func__ , __LINE__, (value), (value), (min), (max)); \
+		return TPM_BAD_PARAM; \
+	} \
+}
+
+#define TPM_HEX_RANGE_VALIDATE(module, value, min, max) { \
+	if (((value) > (max)) || ((value) < (min))) { \
+		if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
+			tpm_printf("(error) %s(%d) value(%d/0x%x) is out of range[0x%X, 0x%X]\n", \
+			__func__ , __LINE__, (value), (value), (min), (max)); \
+		return TPM_BAD_PARAM; \
+	} \
+}
+
+#define TPM_DECIMAL_RANGE_VALIDATE_STR(module, value, min, max, str) { \
+	if (((value) > (max)) || ((value) < (min))) { \
+		if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
+			tpm_printf("(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n", \
+			__func__ , __LINE__, (str), (value), (value), (min), (max)); \
+		return TPM_BAD_PARAM; \
+	} \
+}
+
+#define TPM_HEX_RANGE_VALIDATE_STR(module, value, min, max, str) { \
+	if (((value) > (max)) || ((value) < (min))) { \
+		if ((module & GLOB_TRACE) && (TPM_ERROR_MASK & GLOB_TRACE)) \
+			tpm_printf("(error) %s(%d) %s(%d/0x%x), out of range[0x%X, 0x%X]\n", \
+			__func__ , __LINE__, (str), (value), (value), (min), (max)); \
+		return TPM_BAD_PARAM; \
+	} \
+}
+
+#define TPM_BIT_RANGE_VALIDATE(module, value)			TPM_DECIMAL_RANGE_VALIDATE(module, value , 0, 1)
+#define TPM_BIT_RANGE_VALIDATE_STR(module, value, str)	TPM_DECIMAL_RANGE_VALIDATE_STR(module, value , 0, 1, str)
+#define TPM_POS_RANGE_VALIDATE(module, value, max)		TPM_DECIMAL_RANGE_VALIDATE(module, value , 0, max)
+#define TPM_POS_RANGE_VALIDATE_STR(module, value, max, str) TPM_DECIMAL_RANGE_VALIDATE_STR(module, value , 0, max, str)
+#define TPM_POS_HEX_RANGE_VALIDATE(module, value, max)		TPM_HEX_RANGE_VALIDATE(module, value , 0, max)
+#define TPM_POS_HEX_RANGE_VALIDATE_STR(module, value, max, str)	TPM_HEX_RANGE_VALIDATE_STR(module, value , 0, max, str)
+
+#define TPM_SWITCH_INIT_CHECK(module, type, port)	IF_ERROR(module, tpm_sw_init_check(type, port))
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_log_trace_level_set(unsigned int trace_level);
+unsigned int tpm_log_trace_level_get(void);
+#endif /*_TPM_LOG_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mc.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mc.h
new file mode 100644
index 0000000..963f112
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mc.h
@@ -0,0 +1,149 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+
+#ifndef _TPM_MC_H_
+#define _TPM_MC_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_MC_DUP_MAX		(14)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_mc_frwd_t {
+	TPM_MC_FRWD_TO_CPU,
+	TPM_MC_FRWD_TO_TX,
+};
+
+enum tpm_mc_mod_en_t {
+	TPM_MC_MOD_DIS = 0,
+	TPM_MC_MOD_ENABLE,
+};
+
+enum tpm_mc_db_entry_valid_t {
+	TPM_MC_ENTRY_INVALID = 0,
+	TPM_MC_ENTRY_VALID
+};
+
+enum tpm_mc_entry_update_t {
+	TPM_MC_ENTRY_KEEP = 0,
+	TPM_MC_ENTRY_DEL,
+	TPM_MC_ENTRY_UPDATE,
+	TPM_MC_ENTRY_ADD,
+};
+
+enum tpm_mc_update_valid_t {
+	TPM_MC_UPDATE_INVALID = 0,
+	TPM_MC_UPDATE_VALID,
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+struct tpm_mc_index_t {
+	unsigned int		valid;			/* Indicate the node is in list(valid) */
+	unsigned int		mct_hw_idx;		/* HW entry index in MC table */
+	unsigned int		mct_data_db_idx;	/* data index in db */
+	struct list_head	list_node;		/* list node */
+};
+
+struct tpm_mc_mod_t {
+	struct tpm_engine_pkt_mod_t	pkt_mod;	/* PMT cmd_idx and data_idx */
+	enum tpm_mc_mod_en_t		gem_mod_en;	/* Gemport ID mod enable */
+	enum tpm_mc_mod_en_t		pri_mod_en;	/* Priority mod enable */
+	enum tpm_mc_mod_en_t		dscp_mod_en;	/* DSCP mod enable */
+	unsigned short			gem;		/* New VID */
+	unsigned char			pri;		/* New Priority */
+	unsigned char			dscp;		/* New DSCP */
+};
+
+struct tpm_mc_action_t {
+	unsigned char			queue;		/* Queue high and queue low */
+	enum tpm_mc_frwd_t		frwd;		/* Forward, to CPu ot TX port */
+	unsigned char			next_mcti;	/* Next MC table entry index */
+	unsigned int			port_id_bm;	/* The destination UNI bitmap, just record the dest info */
+};
+
+struct tpm_mc_data_t {
+	unsigned int			valid;		/* Indicate the entry is used or not */
+	struct tpm_mc_mod_t		mct_mod;	/* MC table modification */
+	struct tpm_mc_action_t		action;		/* MCT action info */
+};
+
+struct tpm_mc_tbl_entry_t {
+	struct tpm_mc_mod_t		mct_mod;
+	struct tpm_mc_action_t		action;
+};
+
+struct tpm_mc_update_info_t {
+	enum tpm_mc_update_valid_t	valid;
+	unsigned int			old_hw_idx;	/* Not valid when state is ADD */
+	unsigned int			new_entry_idx;
+	enum tpm_mc_entry_update_t	state;
+	struct tpm_mc_tbl_entry_t	new_entry;
+};
+
+struct tpm_mc_update_t {
+	struct tpm_mc_update_info_t	info[TPM_MC_DUP_MAX];
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_mc_dup_list_create(unsigned int dup_cnt,
+			   struct tpm_mc_tbl_entry_t mct_entry[],
+			   unsigned int *flow_id);
+
+int tpm_mc_dup_list_update(unsigned int rule_index,
+			   unsigned int flow_id,
+			   unsigned int new_dup_cnt,
+			   struct tpm_mc_tbl_entry_t new_mct_entry[],
+			   int (*dup_info_set)(unsigned int rule_idx,
+					       unsigned int dup_cnt,
+					       unsigned int flowid),
+			   int (*dest_bm_set)(unsigned int entry_idx,
+					      unsigned int dst_bm));
+
+int tpm_mc_dup_list_release(unsigned int flow_id);
+
+unsigned int tpm_mc_free_entry_cnt_get(void);
+
+unsigned int tpm_mc_dup_list_entry_cnt_get(unsigned int flow_id);
+
+int tpm_mc_start(void);
+
+int tpm_mc_reset(void);
+
+#endif /*_TPM_MC_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mempool.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mempool.h
new file mode 100644
index 0000000..9278a77
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mempool.h
@@ -0,0 +1,126 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : tpm_mempool.h                                              **
+**                                                                           **
+**  DESCRIPTION : This file tpm memory pool manager                          **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_MEMPOOL_H
+#define _TPM_MEMPOOL_H
+
+/*************************************************************/
+/*               MACROS                                      */
+/*************************************************************/
+#define TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED	(0x00000001)					/* pool header flag */
+#define TPM_COMMON_MPOOL_HDR_MAGIC		(0xa5a5a508)					/* Header magic */
+#define TPM_COMMON_MPOOL_FTR_MAGIC		(0xa5a5a509)					/* Ftr magic */
+#define TPM_COMMON_MPOOL_ALIGN4(size)		(((size)+4) & 0xFFFFFFFC);			/* 4 bytes aligned */
+#define TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)	((((unsigned int)(ptr)) & 0x00000003) == 0)	/* 4 bytes aligned */
+
+
+/*************************************************************/
+/*               STRUCTURES                                  */
+/*************************************************************/
+struct tpm_common_mpool_hdr_t {
+	struct tpm_common_mpool_hdr_t	*next;
+	struct tpm_common_mempool_t	*pool;
+	unsigned int			flags;
+	unsigned int			magic;
+};
+
+struct tpm_common_mempool_t {
+	struct tpm_common_mpool_hdr_t	*head;
+	struct tpm_common_mpool_hdr_t	*tail;
+	unsigned int			number_of_free_entries;
+	spinlock_t			lock;
+	unsigned int			data_size;		/* size of data section in pool entry */
+	unsigned int			pool_entry_size;	/* size of pool entry */
+	/* parameters passed on init */
+	unsigned int			number_of_entries;
+	unsigned int			entry_size;
+	unsigned char			*mem;
+};
+
+struct tpm_common_mpool_ftr_t {
+	unsigned int			magic;
+	struct tpm_common_mempool_t	*pool;
+};
+
+/*************************************************************/
+/*               API PROTYPES                                */
+/*************************************************************/
+void *tpm_common_mempool_alloc(struct tpm_common_mempool_t *pool);
+void tpm_common_mempool_free(struct tpm_common_mempool_t *pool, void *mem);
+struct tpm_common_mempool_t *tpm_common_mempool_get(void *mem);
+struct tpm_common_mempool_t *tpm_common_mempool_create(unsigned int number_of_entries,
+						       unsigned int entry_size,
+						       int priority);
+void tpm_common_mempool_destroy(struct tpm_common_mempool_t *pool);
+
+#endif /* _TPM_MEMPOOL_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mng.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mng.h
new file mode 100644
index 0000000..17abbed
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_mng.h
@@ -0,0 +1,426 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_mng.h						     **
+**									     **
+**  DESCRIPTION : This file contains api protypes and macro of tpm_mng.c   **
+**  DEPENDCY :			                                             **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_MNG_H_
+#define _TPM_MNG_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_MNG_IGMP_PROT_VALUE       2
+#define TPM_MNG_MLD_NH_VALUE          58
+/* for dst port, 0-15 is TCONT, 16 is G0, this is the start of GMAC */
+#define TPM_MNG_DST_PORT_G0_START     0xf
+#define TPM_MNG_ILLEGAL_LUID          0xff
+/* max number of field_id in API */
+#define TPM_MNG_MAX_FIELD_NUM         4
+
+/* This two values will be updated after TPM_START */
+#define TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START   0
+#define TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START   0
+
+/* max cap number per flow */
+#define TPM_MNG_CAP_PER_FLOW_MAX      30
+/* max flow number per cap */
+#define TPM_MNG_FLOW_PER_CAP_MAX      70
+#define TPM_MNG_FLOW_TBL_SIZE_MAX     100
+#define TPM_MNG_CLS_PRI_MAX           63
+/* PRI number reserved for each cap */
+#define TPM_MNG_PRI_CAP_RESERVE       2
+#define TPM_MNG_ALL_PORT_MASK        0xffff
+#define TPM_MNG_ALL_LUTYPE_MASK      0xff
+
+#define TPM_MATCH_IPV4_5T     (TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_L4_DST \
+			      | TPM_MATCH_L4_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT)
+
+#define TPM_MATCH_IPV6_5T     (TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_L4_DST \
+			      | TPM_MATCH_L4_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT)
+
+/* so far for each API rule, only one C2/C3 rule is added, so keep rule_id in the first array item */
+#define TPM_MNG_ENG_RULEID_ARR_SUBSCRIPT_START	0
+
+/* mod MH for pkt egress from G0 */
+#define TPM_MNG_DFLT_PME_G0  1
+
+/* remove MH for pkt egress from G1 */
+#define TPM_MNG_DFLT_PME_G1  2
+
+/* CPU queue high of PON */
+#define TPM_MNG_PON_QHIGH  3
+
+/* all vlan field_bm */
+#define TPM_MNG_ALL_VLAN_FIELD_BM  (TPM_MATCH_VID_INNER | TPM_MATCH_VID_OUTER \
+				   | TPM_MATCH_PBITS_OUTER | TPM_MATCH_PBITS_INNER)
+
+/* rule_type value for API type other than CLS */
+#define TPM_MNG_RULE_TYPE_INVALID	0
+
+#define TPM_MNG_FLOW_CAP_PRINT(CAP) \
+	printk(KERN_INFO "%-7d %-6s %-7d %-17s %-6d 0x%08x     0x%08x	%-7d  %-7d\n", \
+		(CAP)->cls_pri,\
+		tpm_utils_eng_no_str_get((CAP)->eng_no),\
+		(CAP)->lu_type,\
+		tpm_utils_cap_type_str_get((CAP)->cap_api_type),\
+		(CAP)->c2_pri,\
+		(CAP)->cap_field_bm,\
+		(CAP)->c2_key_bm,\
+		(CAP)->vlan_num,\
+		(CAP)->rule_type)
+
+/* CnM cap */
+#define TPM_MNG_CNM_FIELD_BM	(0)
+#define TPM_MNG_CNM_LU_TYPE	(0)
+
+/* TPM mod and dup optimize */
+#define TPM_MNG_MERGE_INVALID	(0xFF)
+
+/* Loopback port rule for MH check */
+#define TPM_MNG_LPBK_MH_MASK	(0xF000)
+
+/* Last CnM P-bit table reserved if CnM is supported */
+#define TPM_MNG_CNM_PBIT_TBL	(MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM - 1)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_mng_mtm_op_t {
+	TPM_MNG_MTM_DEL,
+	TPM_MNG_MTM_ADD,
+};
+
+enum tpm_mng_spid_ex_mode_t {
+	TPM_SPID_MODE_MH,
+	TPM_SPID_MODE_EXTERNAL_SW,
+	TPM_SPID_MODE_CASCADED_SW,
+	TPM_SPID_MODE_PORT_TRUNK,
+};
+
+enum tpm_cap_port_type_t {
+	TPM_CAP_PORT_PHY        = 0x1,
+	TPM_CAP_PORT_UNI_VIR    = 0x2,
+};
+
+enum tpm_mng_port_way_t {
+	/* all ports except PON get way value 0 */
+	TPM_MNG_PORT_WAY_GMAC   = 0x0,
+	TPM_MNG_PORT_WAY_PMAC   = 0x1,
+};
+
+enum tpm_mng_api_type_t {
+	TPM_API_PUBLIC_CLS,
+	TPM_API_PUBLIC_EXCT_EXCPT,
+	TPM_API_PUBLIC_FLTR,
+	TPM_API_PRIVATE_CLS,
+	TPM_API_PRIVATE_START     = TPM_API_PRIVATE_CLS,
+	TPM_API_PRIVATE_EXCT,
+	TPM_API_PRIVATE_EXCT_DEFAULT,
+	TPM_API_PRIVATE_MC_US,
+	TPM_API_PRIVATE_MC_DS,
+	TPM_API_PRIVATE_CPU_Q,
+	TPM_API_PRIVATE_CNM_PBIT,
+	TPM_API_PRIVATE_CNM,
+	TPM_API_PRIVATE_LPBK_MH,
+	TPM_API_TYPE_MAX = TPM_API_PRIVATE_LPBK_MH,
+};
+
+enum tpm_mng_src_port_type_t {
+	TPM_CAP_PORT_G0         = TPM_PP_GMAC0,
+	TPM_CAP_PORT_G1         = TPM_PP_GMAC1,
+	TPM_CAP_PORT_PON        = TPM_PP_PMAC,
+	TPM_CAP_PORT_LPBK	= TPM_PP_LPBK,
+	TPM_CAP_PORT_UNI        = 0x080,
+	TPM_CAP_PORT_VIR        = 0x100,
+};
+
+enum tpm_mng_pri_lu_type_c2_t {
+	TPM_MNG_PRI_LU_TYPE_C2_CPU_Q = 0,
+	TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT,
+	TPM_MNG_PRI_LU_TYPE_C2_TTL,
+	TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_RF,
+	TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_S,
+	TPM_MNG_PRI_LU_TYPE_C2_IGMP_SNP,
+	TPM_MNG_PRI_LU_TYPE_C2_MLD_SNP,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_VID_PPOE_DIP = TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_VID_DIP = TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_UNTAG,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_PPOE_DIP = TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_UNTAG,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_DIP,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_PPOE_DIP,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_DIP,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_PPOE_ETH_DEF,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_DIP_DEF,
+	TPM_MNG_PRI_LU_TYPE_C2_MC_NONIP_DEF,
+	TPM_MNG_PRI_LU_TYPE_C2_LOOPBACK_MH,
+	TPM_MNG_PRI_LU_TYPE_C2_LAST = TPM_MNG_PRI_LU_TYPE_C2_LOOPBACK_MH,
+};
+enum tpm_mng_pri_lu_type_c3_t {
+	TPM_MNG_PRI_LU_TYPE_C3_IPV4_5T = 0,
+	TPM_MNG_PRI_LU_TYPE_C3_IPV6_5T,
+	TPM_MNG_PRI_LU_TYPE_C3_MC_DMAC_SMAC_VID,
+	TPM_MNG_PRI_LU_TYPE_C3_MC_VID_PPOE_SIP_DIP = TPM_MNG_PRI_LU_TYPE_C3_MC_DMAC_SMAC_VID,
+	TPM_MNG_PRI_LU_TYPE_C3_MC_VID_SIP_DIP,
+	TPM_MNG_PRI_LU_TYPE_C3_LAST,
+};
+enum tpm_mng_exact_cls_pri_t {
+	TPM_MNG_CLS_PRI_CPU_Q = 0,
+	TPM_MNG_CLS_PRI_TTL,
+	TPM_MNG_CLS_PRI_TCP_FLAG_RF,
+	TPM_MNG_CLS_PRI_IPVX,
+	TPM_MNG_CLS_PRI_TCP_FLAG_S,
+	TPM_MNG_EXCECT_CLS_PRI_START,
+};
+enum tpm_mng_mc_cls_pri_t {
+	TPM_MNG_MC_CLS_PRI_CPU_Q = 0,
+	TPM_MNG_MC_CLS_PRI_IGMP_SNP,
+	TPM_MNG_MC_CLS_PRI_START,
+};
+enum tpm_mng_gen_cls_pri_t {
+	TPM_MNG_GEN_CLS_PRI_CPU_Q = 0,
+	TPM_MNG_GEN_CLS_PRI_CNM,
+	TPM_MNG_CLS_PRI_CNM_PBIT,
+};
+
+/* do not change the order of this enum, */
+enum tpm_mng_flow_log_id_t {
+	TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_NPON,
+	TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON,
+	TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON,
+/*	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_STAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_DTAG_PON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_STAG_NPON,
+	TPM_MNG_FLOW_ID_IPV4_UC_BRG_FRAG_DTAG_NPON,*/
+/*	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_STAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_DTAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_STAG_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_FRAG_DTAG_NPON,*/
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON,
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_PON,
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_PON,
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON,
+	TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON,
+	TPM_MNG_FLOW_ID_NOT_IP_ARP_PON,
+	TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON,
+	TPM_MNG_FLOW_ID_UNEXPECTED_PKT_PON,
+	TPM_MNG_FLOW_ID_UNEXPECTED_PKT_NPON,
+	TPM_MNG_FLOW_ID_LOOPBACK_PORT,
+
+	/* put all IPv6 flow_id at the end, so if user configue not to
+	     support IPv6, easy to implement.
+	     keep the first IPv6 flow_id equal to TPM_MNG_FLOW_ID_IPV6_START */
+	TPM_MNG_FLOW_ID_IPV6_START,
+	TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON = TPM_MNG_FLOW_ID_IPV6_START,
+	TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_NPON,
+	TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_PON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON,
+	TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON,
+	TPM_MNG_FLOW_ID_MAX,
+};
+
+enum tpm_mng_api_op_t {
+	TPM_MNG_API_DEL = 0,
+	TPM_MNG_API_ADD,
+	TPM_MNG_API_UPDATE
+};
+
+/* Indicate tpm_mng_flow_cfg_init updated status */
+enum tpm_mng_flow_update_t {
+	TPM_MNG_FLOW_NO_UPDATE,
+	TPM_MNG_FLOW_UPDATED
+};
+
+enum tpm_mc_unknown_handle_t {
+	TPM_MC_UNKNOWN_BLOCK,
+	TPM_MC_UNKNOWN_UNBLOCK,
+};
+
+enum tpm_mc_cap_pri_t {
+	/* IP based rule cap */
+	TPM_MC_VID_PPOE_SIP_DIP_PRI,
+	TPM_MC_VID_SIP_DIP_PRI,
+	TPM_MC_VID_PPOE_DIP_PRI,
+	TPM_MC_VID_DIP_PRI,
+	TPM_MC_TAG_PPOE_DIP_PRI,
+	TPM_MC_TAG_DIP_PRI,
+	TPM_MC_UNTAG_PPOE_DIP_PRI,
+	TPM_MC_UNTAG_DIP_PRI,
+	/* MAC based rule cap*/
+	TPM_MC_DMAC_SMAC_VID_PRI,
+	TPM_MC_DMAC_VID_PRI,
+	TPM_MC_DMAC_TAG_PRI,
+	TPM_MC_DMAC_UNTAG_PRI,
+	/* Default rule cap */
+	TPM_MC_PPOE_ETH_DEF_PRI,
+	TPM_MC_IP_BASE_DIP_DEF_PRI,
+	TPM_MC_NONIP_MAC_DEF_PRI,
+};
+
+enum tpm_mc_rule_type_t {
+	TPM_MC_DATA_TRAFFIC_TYPE,
+	TPM_MC_DEF_DIP_TYPE,
+};
+
+enum tpm_mng_gem_port_src_select_t {
+	TPM_GEM_PORT_FROM_GPON_HEADER,
+	TPM_GEM_PORT_FROM_DSA_TAG,
+	TPM_GEM_PORT_FROM_CLASSIFIER,
+	TPM_GEM_PORT_FROM_DSA_FIELDS,
+	TPM_GEM_PORT_ZERO,
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+/* Structure contain parameter to add engine rule needed for MNG module */
+struct tpm_mng_eng_add_entry_t {
+	struct tpm_db_mng_flow_cap_conf_t	*cap;
+	enum tpm_vlan_num_enum_t		vlan_num;
+	struct tpm_mng_pkt_key_t		*match_key;
+	unsigned int				act_num;
+	struct tpm_pkt_action_t			*action;
+	unsigned short				policer_id;
+	struct tpm_qos_t			*qos;
+	struct tpm_engine_pkt_mod_t		*pkt_mod;
+	struct tpm_duplicate_t			*dup_info;
+};
+
+struct tpm_mng_reassigned_lu_type_t {
+	unsigned int c2_key_bm;
+	unsigned char new_lu_type;
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_mng_start(void);
+int tpm_mng_reset(void);
+void tpm_mng_lock(void);
+void tpm_mng_unlock(void);
+int tpm_mng_rule_id_get(
+	enum tpm_mng_api_type_t	cap_api_type,
+	struct tpm_pkt_key_t	*pkt_key,
+	unsigned int		*rule_id);
+int tpm_mng_cap_entry_add(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_mng_pkt_key_t      *match_key,
+	unsigned int              act_num,
+	struct tpm_pkt_action_t   *action,
+	unsigned short           policer_id,
+	struct tpm_qos_t          *qos,
+	unsigned int            *rule_id);
+int tpm_mng_cap_entry_del(
+	enum tpm_mng_api_type_t	cap_api_type,
+	unsigned int rule_id);
+int tpm_mng_cap_entry_del_type(enum tpm_mng_api_type_t       cap_api_type);
+int tpm_mng_5t_key_build(
+	struct tpm_pkt_key_t		*pkt_key,
+	struct tpm_qos_t		*qos,
+	struct tpm_exact_match_t	*exact_match);
+int tpm_mng_log_idx_map_pkt_mod(int logic_idx,
+				unsigned int *num_dest,
+				struct tpm_engine_pkt_mod_t pkt_mod[]);
+int tpm_mng_cap_entry_cntr_get(unsigned int rule_id, unsigned int *cntr);
+int tpm_mng_engine_action_update(unsigned int rule_idx,
+				 struct tpm_class_port_t *src_port,
+				 struct tpm_pkt_action_t *action,
+				 struct tpm_engine_pkt_mod_t *pkt_mod);
+int tpm_mng_entry_dup_update(unsigned int rule_idx, unsigned int dup_cnt, unsigned int flow_id);
+int tpm_mng_filter_def_rule_cntr_get(
+	unsigned char			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*cntr);
+
+int tpm_mng_dst_port_bm_update(unsigned int dptr, unsigned int port_bm);
+
+
+/* Multicast Section */
+int tpm_mng_mc_flow_add(struct tpm_pkt_key_t	*match_key,
+			unsigned short		num_dest,
+			struct tpm_pkt_action_t	action[],
+			int			*rule_id);
+int tpm_mng_mc_flow_del(unsigned int rule_id);
+int tpm_mng_mc_flow_del_all(void);
+int tpm_mng_cm_rule_add(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action);
+int tpm_mng_cm_rule_del(
+	struct tpm_class_port_t *port,
+	unsigned int rule_num);
+int tpm_mng_cm_rule_del_all(unsigned int port_bm);
+int tpm_mng_mtm_add(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac);
+int tpm_mng_mtm_del(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac);
+int tpm_mng_upstream_gem_port_src_select(enum tpm_mng_gem_port_src_select_t gem_src);
+/* #define TPM_AUTO_TEST */
+#define TPM_AUTO_TEST
+
+#ifdef TPM_AUTO_TEST
+void tpm_mng_cap_merge_auto_test(void);
+void tpm_mng_cnm_auto_test(void);
+
+#endif
+
+#endif /* _TPM_MNG_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_parser.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_parser.h
new file mode 100644
index 0000000..8b35062
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_parser.h
@@ -0,0 +1,249 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/*******************************************************************************
+* tpm_parser.h
+*
+* DESCRIPTION:
+*               Internal definetion for parser sub-module
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_PARSER_H_
+#define _TPM_PARSER_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_PRS_LU_ID_ENTRY_INV          (false)
+#define TPM_PRS_LU_ID_ENTRY_VALID        (true)
+#define TPM_PRS_LU_ID_MIN                0
+#define TPM_PRS_LU_ID_MAX                63
+
+#define TPM_PRS_INV_TCAM_IDX             0xFF
+#define TPM_PRS_IPV6_NH_COUNT            6
+#define TPM_PRS_INV_SPEC_IPV6_NH         0xFF
+#define TPM_PRS_TCAM_IDX_MAX             255
+
+#define TPM_PRS_SPECIAL_MH_ADD           1
+#define TPM_PRS_SPECIAL_MH_DEL           0
+#define TPM_PRS_OMCI_MH                  0x0000
+#define TPM_PRS_OMCI_MH_MASK             0x0F80
+
+
+/* Result Info */
+#define TPM_PRS_RI_FIELD_NUM 17
+#define TPM_PRS_TO_MASK(off, size) (((1<<size) - 1) << off)
+/* MAC2ME, bit 0 */
+#define TPM_PRS_MAC2ME_OFFS 0
+#define TPM_PRS_MAC2ME_BITS 1
+#define TPM_PRS_MAC2ME_MASK TPM_PRS_TO_MASK(TPM_PRS_MAC2ME_OFFS, TPM_PRS_MAC2ME_BITS)
+#define TPM_PRS_MAC2ME_TRUE (1 << TPM_PRS_MAC2ME_OFFS)
+#define TPM_PRS_MAC2ME_FALSE (0 << TPM_PRS_MAC2ME_OFFS)
+/* EtherType DSA, bit 1 */
+#define TPM_PRS_EDSA_OFFS 1
+#define TPM_PRS_EDSA_BITS 1
+#define TPM_PRS_EDSA_MASK TPM_PRS_TO_MASK(TPM_PRS_EDSA_OFFS, TPM_PRS_EDSA_BITS)
+#define TPM_PRS_EDSA_TRUE (1 << TPM_PRS_EDSA_OFFS)
+#define TPM_PRS_EDSA_FALSE (0 << TPM_PRS_EDSA_OFFS)
+/* VLAN Tag, bits 2 - 3 */
+#define TPM_PRS_VLAN_OFFS 2
+#define TPM_PRS_VLAN_BITS 2
+#define TPM_PRS_VLAN_MASK TPM_PRS_TO_MASK(TPM_PRS_VLAN_OFFS, TPM_PRS_VLAN_BITS)
+#define TPM_PRS_VLAN_NONE (0 << TPM_PRS_VLAN_OFFS)
+#define TPM_PRS_VLAN_SINGLE (1 << TPM_PRS_VLAN_OFFS)
+#define TPM_PRS_VLAN_DOUBLE (2 << TPM_PRS_VLAN_OFFS)
+#define TPM_PRS_VLAN_TRIPLE (3 << TPM_PRS_VLAN_OFFS)
+/* CPU Code, bits 4 - 6 */
+#define TPM_PRS_CPU_CODE_OFFS 4
+#define TPM_PRS_CPU_CODE_BITS 3
+#define TPM_PRS_CPU_CODE_MASK TPM_PRS_TO_MASK(TPM_PRS_CPU_CODE_OFFS, TPM_PRS_CPU_CODE_BITS)
+#define TPM_PRS_CPU_CODE_SPECIAL_PKT (1 << TPM_PRS_CPU_CODE_OFFS)
+/* L2 Version, bits 7 - 8 */
+#define TPM_PRS_L2_VER_OFFS 7
+#define TPM_PRS_L2_VER_BITS 2
+#define TPM_PRS_L2_VER_MASK TPM_PRS_TO_MASK(TPM_PRS_L2_VER_OFFS, TPM_PRS_L2_VER_BITS)
+#define TPM_PRS_L2_VER_LLC (0 << TPM_PRS_L2_VER_OFFS)
+#define TPM_PRS_L2_VER_LLC_SNAP (1 << TPM_PRS_L2_VER_OFFS)
+#define TPM_PRS_L2_VER_ETHV2 (2 << TPM_PRS_L2_VER_OFFS)
+#define TPM_PRS_L2_VER_OTHER (3 << TPM_PRS_L2_VER_OFFS)
+/* L2 Cast Info, bits 9 - 10 */
+#define TPM_PRS_L2_CAST_OFFS 9
+#define TPM_PRS_L2_CAST_BITS 2
+#define TPM_PRS_L2_CAST_MASK TPM_PRS_TO_MASK(TPM_PRS_L2_CAST_OFFS, TPM_PRS_L2_CAST_BITS)
+#define TPM_PRS_L2_UC (0 << TPM_PRS_L2_CAST_OFFS)
+#define TPM_PRS_L2_MC (1 << TPM_PRS_L2_CAST_OFFS)
+#define TPM_PRS_L2_BC (2 << TPM_PRS_L2_CAST_OFFS)
+/* PPPoE, bit 11 */
+#define TPM_PRS_PPPOE_OFFS 11
+#define TPM_PRS_PPPOE_BITS 1
+#define TPM_PRS_PPPOE_MASK TPM_PRS_TO_MASK(TPM_PRS_PPPOE_OFFS, TPM_PRS_PPPOE_BITS)
+#define TPM_PRS_PPPOE_TRUE (1 << TPM_PRS_PPPOE_OFFS)
+#define TPM_PRS_PPPOE_FALSE (0 << TPM_PRS_PPPOE_OFFS)
+/* L3 Info, bits 12 - 14 */
+#define TPM_PRS_L3_INFO_OFFS 12
+#define TPM_PRS_L3_INFO_BITS 3
+#define TPM_PRS_L3_INFO_MASK TPM_PRS_TO_MASK(TPM_PRS_L3_INFO_OFFS, TPM_PRS_L3_INFO_BITS)
+#define TPM_PRS_L3_NA (0 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_IPV4_IHL_E5 (1 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_IPV4_IHL_G5 (2 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_IPV4_OTHER (3 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_IPV6_NO_EXT (4 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_IPV6_EXT (5 << TPM_PRS_L3_INFO_OFFS)
+#define TPM_PRS_L3_ARP (6 << TPM_PRS_L3_INFO_OFFS)
+/* L3 Cast Info, bits 15 - 16 */
+#define TPM_PRS_L3_CAST_OFFS 15
+#define TPM_PRS_L3_CAST_BITS 2
+#define TPM_PRS_L3_CAST_MASK TPM_PRS_TO_MASK(TPM_PRS_L3_CAST_OFFS, TPM_PRS_L3_CAST_BITS)
+#define TPM_PRS_L3_UC (0 << TPM_PRS_L3_CAST_OFFS)
+#define TPM_PRS_L3_MC (1 << TPM_PRS_L3_CAST_OFFS)
+#define TPM_PRS_L3_AC (2 << TPM_PRS_L3_CAST_OFFS)
+#define TPM_PRS_L3_BC (3 << TPM_PRS_L3_CAST_OFFS)
+/* IP Frag, bit 17 */
+#define TPM_PRS_FRAG_OFFS 17
+#define TPM_PRS_FRAG_BITS 1
+#define TPM_PRS_FRAG_MASK TPM_PRS_TO_MASK(TPM_PRS_FRAG_OFFS, TPM_PRS_FRAG_BITS)
+#define TPM_PRS_FRAG_TRUE (1 << TPM_PRS_FRAG_OFFS)
+#define TPM_PRS_FRAG_FALSE (0 << TPM_PRS_FRAG_OFFS)
+/* UDF2 For IPV6, bits 18 - 19 */
+#define TPM_PRS_UDF2_IPV6_OFFS 18
+#define TPM_PRS_UDF2_IPV6_BITS 2
+#define TPM_PRS_UDF2_IPV6_MASK TPM_PRS_TO_MASK(TPM_PRS_UDF2_IPV6_OFFS, TPM_PRS_UDF2_IPV6_BITS)
+#define TPM_PRS_UDF2_IPV6_NONE (0 << TPM_PRS_UDF2_IPV6_OFFS)
+#define TPM_PRS_UDF2_IPV6_PRE2ME (1 << TPM_PRS_UDF2_IPV6_OFFS)
+#define TPM_PRS_UDF2_IPV4_IN_IPV6 (2 << TPM_PRS_UDF2_IPV6_OFFS)
+/* UDF3 , bits 20 - 21 */
+#define TPM_PRS_UDF3_OFFS 20
+#define TPM_PRS_UDF3_BITS 2
+#define TPM_PRS_UDF3_MASK TPM_PRS_TO_MASK(TPM_PRS_UDF3_OFFS, TPM_PRS_UDF3_BITS)
+#define TPM_PRS_UDF3_PON_CHANNEL_NONE (0 << TPM_PRS_UDF3_OFFS)
+#define TPM_PRS_UDF3_SPECIAL_IPV6_NH (1 << TPM_PRS_UDF3_OFFS)
+#define TPM_PRS_UDF3_PON_CHANNEL (2 << TPM_PRS_UDF3_OFFS)
+#define TPM_PRS_UDF3_PON_CHANNEL_MASK TPM_PRS_UDF3_PON_CHANNEL
+
+/* UDF4 , L4 Info, bits 22 - 24 */
+#define TPM_PRS_L4_INFO_OFFS 22
+#define TPM_PRS_L4_INFO_BITS 3
+#define TPM_PRS_L4_INFO_MASK TPM_PRS_TO_MASK(TPM_PRS_L4_INFO_OFFS, TPM_PRS_L4_INFO_BITS)
+#define TPM_PRS_L4_INFO_NONE (0 << TPM_PRS_L4_INFO_OFFS)
+#define TPM_PRS_L4_INFO_TCP (1 << TPM_PRS_L4_INFO_OFFS)
+#define TPM_PRS_L4_INFO_UDP (2 << TPM_PRS_L4_INFO_OFFS)
+/* UDF5 , bits 25 - 26 */
+#define TPM_PRS_UDF5_OFFS 25
+#define TPM_PRS_UDF5_BITS 2
+#define TPM_PRS_UDF5_MASK TPM_PRS_TO_MASK(TPM_PRS_UDF5_OFFS, TPM_PRS_UDF5_BITS)
+/* UDF6 , bits 27 - 28 */
+#define TPM_PRS_UDF6_OFFS 27
+#define TPM_PRS_UDF6_BITS 2
+#define TPM_PRS_UDF6_MASK TPM_PRS_TO_MASK(TPM_PRS_UDF6_OFFS, TPM_PRS_UDF6_BITS)
+/* UDF7 , bits 29 - 30 */
+#define TPM_PRS_UDF7_OFFS 29
+#define TPM_PRS_UDF7_BITS 2
+#define TPM_PRS_UDF7_MASK TPM_PRS_TO_MASK(TPM_PRS_UDF7_OFFS, TPM_PRS_UDF7_BITS)
+/* DROP, bit 31 */
+#define TPM_PRS_DROP_OFFS 31
+#define TPM_PRS_DROP_BITS 1
+#define TPM_PRS_DROP_MASK TPM_PRS_TO_MASK(TPM_PRS_DROP_OFFS, TPM_PRS_DROP_BITS)
+#define TPM_PRS_DROP_TRUE (1 << TPM_PRS_DROP_OFFS)
+#define TPM_PRS_DROP_FALSE (0 << TPM_PRS_DROP_OFFS)
+/* No result to care */
+#define TPM_PRS_RI_NONE 0
+#define TPM_PRS_RI_NONE_MASK 0
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_prs_ipv6_nh_idx_t {
+	TPM_IPV6_NH_HH_IDX,
+	TPM_IPV6_NH_DH_IDX,
+	TPM_IPV6_NH_RH_IDX,
+	TPM_IPV6_NH_FH_IDX,
+	TPM_IPV6_NH_EH_IDX,
+	TPM_IPV6_NH_AH_IDX,
+	TPM_IPV6_NH_MAX_IDX
+};
+
+enum tpm_prs_ipv6_spec_nh_op_t {
+	TPM_PRS_SPEC_IPV6NH_DEL = 0,
+	TPM_PRS_SPEC_IPV6NH_ADD
+};
+
+enum tpm_prs_tpid_comb_op_t {
+	TPM_PRS_TPID_COMB_DEL = 0,
+	TPM_PRS_TPID_COMB_ADD
+};
+
+enum tpm_prs_unexpected_enum_t {
+	TPM_PRS_UNEXPECTED_DIS = 0,
+	TPM_PRS_UNEXPECTED_EN
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_prs_result_t {
+	unsigned int	prs_ri;
+	unsigned int	prs_ri_mask;
+};
+
+struct tpm_prs_lu_id_t {
+	bool			valid;		/* Indicate the lu_id entry is valid */
+	unsigned int		traffic_type;	/* Coresponding Traffic Type */
+	struct tpm_prs_result_t	prs_result;	/* Parser Result to Generate Lookup ID */
+	unsigned int		prs_idx;	/* Parser TCAM Index */
+	unsigned int		lu_id;		/* Classifier Lookup ID */
+};
+
+struct tpm_prs_ipv6_spec_nh_t {
+	unsigned char	nh;
+	unsigned int	prs_idx;
+};
+
+struct tpm_prs_ri_str_map_t {
+	unsigned int	prs_ri_mask;
+	char		result_str[8][20];
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_prs_init(void);
+int tpm_prs_db_init(void);
+int tpm_prs_unexp_lu_id_op(int unexp_en);
+int tpm_prs_reset(void);
+
+#endif /*_TPM_PARSER_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_pme.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_pme.h
new file mode 100644
index 0000000..3112077
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_pme.h
@@ -0,0 +1,631 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_PME_INVALID_IDX		(0xffff)
+#define TPM_PME_INVALID_DATA		(0xffff)
+#define TPM_PME_SHARE_NEED		(0xffffffff)/* Indicates the share data entry is needed */
+#define TPM_PME_UNIT_ALL_OCCUPIED	(0xffffffff)
+
+/* DSCP MASK */
+#define TPM_PME_IP4_DSCP_UPDATE_MASK	(0x0300)
+#define TPM_PME_IP4_DSCP_KEEP_MASK	(0xFF00)
+#define TPM_PME_IP4_DSCP_BIT_OFF	(2)
+#define TPM_PME_IP6_DSCP_UPDATE_MASK	(0x0003)
+#define TPM_PME_IP6_DSCP_KEEP_MASK	(0xF00F)
+#define TPM_PME_IP6_DSCP_BIT_OFF	(6)
+
+/* PME instruction table allocation */
+#define TPM_PME_JMP_START		(1)	/* command 0 is reserved, for no-mod pkt */
+#define TPM_PME_JMP_AREA_SIZE		(252)
+
+#define TPM_PME_LPBK_START		(253)	/* Used to MH modification when send packet to CPU through LPBK port */
+#define TPM_PME_LPBK_SIZE		(3)
+#define TPM_PME_LPBK_GMAC0_IPTR		(253)
+#define TPM_PME_LPBK_GMAC1_IPTR		(254)
+#define TPM_PME_LPBK_PON_IPTR		(255)
+
+#define TPM_PME_TEMPLATE_START		(TPM_PME_JMP_START + TPM_PME_JMP_AREA_SIZE + TPM_PME_LPBK_SIZE)
+#define TPM_PME_TEMPLATE_AREA_SIZE	(700)
+
+#define TPM_PME_SUBR_START		(TPM_PME_TEMPLATE_START + TPM_PME_TEMPLATE_AREA_SIZE)
+#define TPM_PME_SUBR_AREA_SIZE		(1500)
+
+/* Private table allocation, unit: data entry, (2 bytes) */
+#define TPM_PME_PRI_NO_MOD_CASE_MAX	(288)
+#define TPM_PME_PRI_NO_MOD_START	(1)
+#define TPM_PME_PRI_NO_MOD_SIZE		(288)
+#define TPM_PME_PRI_NO_MOD_UNIT_BYTES	(2)
+
+#define TPM_PME_PRI_L2_SW_CASE_MAX	(160)
+#define TPM_PME_PRI_L2_SW_START		(TPM_PME_PRI_NO_MOD_START + TPM_PME_PRI_NO_MOD_SIZE)
+#define TPM_PME_PRI_L2_SW_SIZE		(800)
+#define TPM_PME_PRI_L2_SW_UNIT_BYTES	(10)
+
+#define TPM_PME_PRI_ROUTE_CASE_MAX	(256 + 32)/* Including MC and UNI */
+#define TPM_PME_PRI_ROUTE_START		(TPM_PME_PRI_L2_SW_START + TPM_PME_PRI_L2_SW_SIZE)
+#define TPM_PME_PRI_ROUTE_SIZE		(2304)
+#define TPM_PME_PRI_ROUTE_UNIT_BYTES	(16)
+
+#define TPM_PME_PRI_NAPT_US_CASE_MAX	(1500)
+#define TPM_PME_PRI_NAPT_US_START	(TPM_PME_PRI_ROUTE_START + TPM_PME_PRI_ROUTE_SIZE)
+#define TPM_PME_PRI_NAPT_US_SIZE	(12000)
+#define TPM_PME_PRI_NAPT_US_UNIT_BYTES	(16)
+
+#define TPM_PME_PRI_NAPT_DS_CASE_MAX	(1500)
+#define TPM_PME_PRI_NAPT_DS_START	(TPM_PME_PRI_NAPT_US_START + TPM_PME_PRI_NAPT_US_SIZE)
+#define TPM_PME_PRI_NAPT_DS_SIZE	(7500)
+#define TPM_PME_PRI_NAPT_DS_UNIT_BYTES	(10)
+
+#define TPM_PME_PRIVATE_SET_MAX		(TPM_PME_PRI_NO_MOD_CASE_MAX + TPM_PME_PRI_L2_SW_CASE_MAX + \
+					TPM_PME_PRI_ROUTE_CASE_MAX + TPM_PME_PRI_NAPT_US_CASE_MAX + \
+					TPM_PME_PRI_NAPT_DS_CASE_MAX)
+/* TPM_PME_STATE_INT_NUM: the int data number to flag the occupy state of each data unit */
+#define TPM_PME_STATE_INT_NUM		(1+(TPM_PME_PRI_NAPT_US_CASE_MAX/(sizeof(unsigned int)*BYTE_BITS)))
+
+/* Share table allocation, unit: data entry, (2 bytes) */
+#define TPM_PME_SHA_MAC_CASE_MAX	(32 + 1)/* DMAC and SMAC */
+#define TPM_PME_SHA_MAC_START		(0)
+#define TPM_PME_SHA_MAC_SIZE		(99)
+#define TPM_PME_SHA_MAC_UNIT_BYTES	(6)
+
+#define TPM_PME_SHA_SA_SIP_CASE_MAX	(8)
+#define TPM_PME_SHA_SA_SIP_START	(99)
+#define TPM_PME_SHA_SA_SIP_SIZE		(40)
+#define TPM_PME_SHA_SA_SIP_UNIT_BYTES	(10)
+
+#define TPM_PME_SHA_DA_SA_DIP_CASE_MAX	(128)
+#define TPM_PME_SHA_DA_SA_DIP_START	(139)
+#define TPM_PME_SHA_DA_SA_DIP_SIZE	(1024)
+#define TPM_PME_SHA_DA_SA_DIP_UNIT_BYTES (16)
+
+#define TPM_PME_SHARE_SET_MAX		(TPM_PME_SHA_MAC_CASE_MAX + \
+					TPM_PME_SHA_SA_SIP_CASE_MAX + TPM_PME_SHA_DA_SA_DIP_CASE_MAX)
+
+/* Use case modification bit map */
+#define TPM_PME_NO_MOD_BM		(0)
+
+#define TPM_PME_L2_SW_BM1		(TPM_VLAN_MOD)
+
+#define TPM_PME_L2_SW_BM2		(TPM_VLAN_MOD | TPM_IP_DSCP_SET)
+
+#define TPM_PME_ROUTE_BM1		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | \
+					TPM_TTL_HOPL_DEC)
+#define TPM_PME_ROUTE_BM2		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD | \
+					TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC)
+
+#define TPM_PME_ROUTE_BM3		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | \
+					TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC)
+
+#define TPM_PME_ROUTE_BM4		(TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC)/* MC */
+
+
+#define TPM_PME_NAPT_US_BM1		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | \
+					TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET)
+
+#define TPM_PME_NAPT_US_BM2		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD | \
+					TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET)
+
+#define TPM_PME_NAPT_DS_BM1		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | \
+					TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET)
+
+#define TPM_PME_NAPT_DS_BM2		(TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | \
+					TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET)
+
+/* Max number of modification entries per command */
+#define TPM_PME_MAX_VLAN_ENTRIES	(2)
+#define TPM_VLAN_TEMPL_ENTRY_MAX_NUM	(5)/* 2+2+1 */
+#define TPM_VLAN_TEMPL_MAX		(320)
+
+/* VLAN Config data */
+/* ETY_Sel, bit 0 */
+#define TPM_PME_ETY_OFFS		(0)
+#define TPM_PME_ETY_BITS		(3)
+/* VID_Sel, bit 4 */
+#define TPM_PME_VID_OFFS		(4)
+#define TPM_PME_VID_BITS		(2)
+/* CFI_Sel, bit 6 */
+#define TPM_PME_CFI_OFFS		(6)
+#define TPM_PME_CFI_BITS		(2)
+/* PBIT_Sel, bit 8 */
+#define TPM_PME_PBIT_OFFS		(8)
+#define TPM_PME_PBIT_BITS		(2)
+
+/* Address replacement template related */
+#define TPM_PME_ADDR_REP_ENTRY_MAX	(3)
+#define TPM_ADDR_REP_TEMPL_MAX		(4)
+
+/*
+*|----------DMAC/DIP------------|----------SMAC/SIP------------|
+*|---cmd_type---|---entry_off---|---cmd_type---|---entry_off---|
+*/
+#define TPM_ADDR_REP_INFO_SA_IDX_OFF	(0)
+#define TPM_ADDR_REP_INFO_SA_TYPE_OFF	(8)
+#define TPM_ADDR_REP_INFO_DA_IDX_OFF	(16)
+#define TPM_ADDR_REP_INFO_DA_TYPE_OFF	(24)
+#define TPM_ADDR_REP_INFO_SIP_IDX_OFF	(0)
+#define TPM_ADDR_REP_INFO_SIP_TYPE_OFF	(8)
+#define TPM_ADDR_REP_INFO_DIP_IDX_OFF	(16)
+#define TPM_ADDR_REP_INFO_DIP_TYPE_OFF	(24)
+#define TPM_ADDR_REP_INFO_MASK		(0xFF)
+
+/* Usecase instruction template related */
+#define TPM_PME_INSTR_TEMPL_ENTRY_MAX	(15)
+#ifndef CONFIG_MV_ETH_PP2_1
+#define TPM_PME_INSTR_TEMPL_MAX		(74)
+#else
+#define TPM_PME_INSTR_TEMPL_MAX		(48)
+#endif
+#define TPM_PPOE_SESS_ALLOWED_MAX	(5)
+
+/* Private and share data area related*/
+#define TPM_PME_DATA_ENTRY_MAX		(8)
+#define TPM_PME_DATA_ENTRY_SET_MAX	(100)
+
+/* PME Init Macros */
+#define TPM_PME_PPOE_LEN_CFG		(0x7002)/* Replace modification data when calculate length */
+
+/* PME MH of LPBK from MAC define, only high 4 bits valid */
+#define TPM_PME_LPBK_MH_G0		(0xA000)
+#define TPM_PME_LPBK_MH_G1		(0xB000)
+#define TPM_PME_LPBK_MH_PON		(0xC000)
+
+/* Replace MSB instruction mask, only low 12 bits valid */
+#define TPM_PME_LPBK_MH_MASK		(0x000F)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+/* PME COMMAND CODE ENUM */
+enum tpm_pme_cmd_code_t {
+	TPM_PME_CMD_NONE = 0,
+	TPM_PME_CMD_ADD_2B,
+	TPM_PME_CMD_CFG_VLAN,
+	TPM_PME_CMD_ADD_VLAN,
+	TPM_PME_CMD_CFG_DSA_1,
+	TPM_PME_CMD_CFG_DSA_2,
+	TPM_PME_CMD_ADD_DSA,
+	TPM_PME_CMD_DEL_BYTES,
+	TPM_PME_CMD_REPLACE_2B,
+	TPM_PME_CMD_REPLACE_LSB,
+	TPM_PME_CMD_REPLACE_MSB,
+	TPM_PME_CMD_REPLACE_VLAN,
+	TPM_PME_CMD_DEC_LSB,
+	TPM_PME_CMD_DEC_MSB,
+	TPM_PME_CMD_ADD_CALC_LEN,
+	TPM_PME_CMD_REPLACE_LEN,
+	TPM_PME_CMD_IPV4_CSUM,
+	TPM_PME_CMD_L4_CSUM,
+	TPM_PME_CMD_SKIP,
+	TPM_PME_CMD_JUMP,
+	TPM_PME_CMD_JUMP_SKIP,
+	TPM_PME_CMD_JUMP_SUB,
+	TPM_PME_CMD_PPPOE,
+	TPM_PME_CMD_STORE,
+	TPM_PME_CMD_ADD_IP4_CSUM,
+	TPM_PME_CMD_PPPOE_2,
+	TPM_PME_CMD_REPLACE_MID,
+	TPM_PME_CMD_ADD_MULT,
+	TPM_PME_CMD_REPLACE_MULT,
+	TPM_PME_CMD_REP_RMV_2B,		/* 0x1D, New command since A0 */
+	TPM_PME_CMD_ADD_IPV6_HDR,	/* 0x1E, New command since A0, add IPV6 header when DS-LITE */
+	TPM_PME_CMD_DROP_PKT,
+	TPM_TMP_CMD_MAX,
+	/* In order compatible between Z1 and A0 for Marvell header operation */
+#ifndef CONFIG_MV_ETH_PP2_1
+	TPM_PME_CMD_MH_OP = TPM_PME_CMD_REPLACE_2B,
+#else
+	TPM_PME_CMD_MH_OP = TPM_PME_CMD_REP_RMV_2B,
+#endif
+};
+
+/* PME COMMAND TYPE ENUM */
+enum tpm_pme_cmd_type_t {
+	TPM_PME_CMD_TYPE0 = 0,
+	TPM_PME_CMD_TYPE1,
+	TPM_PME_CMD_TYPE2,
+	TPM_PME_CMD_TYPE3,
+	TPM_PME_CMD_TYPE4,
+	TPM_PME_CMD_TYPE5,
+	TPM_PME_CMD_TYPE6,
+	TPM_PME_CMD_TYPE7,
+	TPM_PME_CMD_TYPE_MAX
+};
+
+/* PME MOD Internal Bitmap ENUM */
+enum tpm_pme_mod_internal_t {
+	TPM_MH_T1_MOD       = 0x0001,	/* Marvell header is replaced with type1 */
+	TPM_MH_T5_MOD       = 0x0002,	/* Marvell header is replaced with type5 */
+#ifndef CONFIG_MV_ETH_PP2_1
+	TPM_MH_DEL          = 0x0004,	/* Only for Z1 */
+#endif
+	TPM_IPV4_CHECK_MOD  = 0x0008,
+	TPM_L4_CHECK_MOD    = 0x0010,
+	TPM_QOS_FROM_DESC   = 0x0020,	/* If set, means QoS from Tx Desc */
+	TPM_MOD_PKT_IS_IP6  = 0x0040	/* Indicate the modified packet is IPV6 */
+};
+
+/* PME COMMAND LAST ENUM */
+enum tpm_pme_cmd_last_t {
+	TPM_PME_CMD_NO_LAST = 0,
+	TPM_PME_CMD_LAST
+};
+
+/* PME COMMAND TABLE Divide Type ENUM */
+enum tpm_pme_cmd_area_type_t {
+	TPM_PME_CMD_AREA_JMP = 0,
+	TPM_PME_CMD_AREA_TEMPL,
+	TPM_PME_CMD_AREA_SUBR
+};
+
+/* Instruction Template valid Enum*/
+enum tpm_pme_instr_templ_valid_t {
+	TPM_INSTR_TEMPL_INVALID = 0,
+	TPM_INSTR_TEMPL_VALID
+};
+
+/* Instruction Template valid Enum*/
+enum tpm_pme_data_valid_t {
+	TPM_DATA_INVALID = 0,
+	TPM_DATA_VALID
+};
+
+/* VLAN OPERATION ENUM */
+enum tpm_pme_vlan_oper_t {
+	VLANOP_NOOP,			/* no VLAN operation performed */
+	VLANOP_EXT_TAG_MOD,		/* modify external tag */
+	VLANOP_EXT_TAG_DEL,		/* delete external tag */
+	VLANOP_EXT_TAG_INS,		/* insert(prepend) external tag */
+	VLANOP_EXT_TAG_MOD_INS,		/* modify existing external tag and insert(prepend) new tag */
+	VLANOP_INS_2TAG,		/* insert(prepend) 2 new tags */
+	VLANOP_MOD_2TAG,		/* modify 2 tags */
+	VLANOP_SWAP_TAGS,		/* swap internal and external tags */
+	VLANOP_DEL_2TAG,		/* delete 2 existing tags */
+	VLANOP_INT_TAG_MOD,		/* modify existing internal tag */
+	VLANOP_EXT_TAG_DEL_INT_MOD,	/* delete existing external tag and modify internal tag */
+
+	VLANOP_MAX_CNT
+};
+
+/* VLAN Ether Type (TPID) selection in HW */
+enum tpm_pme_vlan_tpid_sel_t {
+	TPM_VLAN_ETY_REG0 = 0,
+	TPM_VLAN_ETY_REG1,
+	TPM_VLAN_ETY_REG2,
+	TPM_VLAN_ETY_REG3,
+	TPM_VLAN_ETY_VLAN1,
+	TPM_VLAN_ETY_VLAN2,
+	TPM_VLAN_ETY_SEL_CNT
+};
+
+/* VLAN Ether Type (TPID) selection supported in TPM */
+enum tpm_pme_vlan_tpid_logic_t {
+	TPM_VLAN_ETY_LOG_VLAN12 = 0,
+	TPM_VLAN_ETY_LOG_REG0,
+	TPM_VLAN_ETY_LOG_REG1,
+	TPM_VLAN_ETY_LOG_MAX
+};
+
+/* VLAN VID selection in HW */
+enum tpm_pme_vlan_vid_sel_t {
+	TPM_VLAN_VID_VLAN1 = 0,
+	TPM_VLAN_VID_VLAN2,
+	TPM_VLAN_VID_NEW,
+	TPM_VLAN_VID_SEL_CNT
+};
+
+/* VLAN VID selection supported in TPM */
+enum tpm_pme_vlan_vid_logic_t {
+	TPM_VLAN_VID_LOG_VLAN12 = 0,
+	TPM_VLAN_VID_LOG_NEW,
+	TPM_VLAN_VID_LOG_MAX
+};
+
+/* VLAN CFI selection in HW */
+enum tpm_pme_vlan_cfi_sel_t {
+	TPM_VLAN_CFI_VLAN1 = 0,
+	TPM_VLAN_CFI_VLAN2,
+	TPM_VLAN_CFI_NEW,
+	TPM_VLAN_CFI_SEL_CNT
+};
+
+/* VLAN PBIT selection in HW */
+enum tpm_pme_vlan_pbit_sel_t {
+	TPM_VLAN_PBIT_VLAN1 = 0,
+	TPM_VLAN_PBIT_VLAN2,
+	TPM_VLAN_PBIT_NEW,
+	TPM_VLAN_PBIT_COLOR,
+	TPM_VLAN_PBIT_SEL_CNT
+};
+
+/* VLAN PBIT selection supported in TPM */
+enum tpm_pme_vlan_pbit_logic_t {
+	TPM_VLAN_PBIT_LOG_VLAN12 = 0,
+	TPM_VLAN_PBIT_LOG_NEW,
+	TPM_VLAN_PBIT_LOG_MAX
+};
+
+/* TPM Modification QOS Source */
+enum tpm_pme_qos_src_t {
+	TPM_PME_QOS_PRV = 0,	/* QOS from private data */
+	TPM_PME_QOS_DESC,	/* QOS from TX descriptor */
+	TPM_PME_QOS_MAX
+};
+
+/* TPM modification pppoe permutation */
+enum tpm_pme_pppoe_permu_t {
+	TPM_PME_PPPOE_FALSE = 0,
+	TPM_PME_PPPOE_TRUE,
+	TPM_PME_PPPOE_PERMU_MAX
+};
+
+/* VLAN OP Parameter ENUM */
+enum tpm_pme_vlan_op_para_t {
+	TPM_VLAN_OP_PARA0 = 0,
+	TPM_VLAN_OP_PARA1 = 1,
+	TPM_VLAN_OP_PARA_CNT
+};
+
+/* VLAN Subr valid Enum*/
+enum tpm_pme_vlan_subr_valid_t {
+	TPM_VLAN_SUBR_INVALID = 0,
+	TPM_VLAN_SUBR_VALID
+};
+
+/* Addr rep Subr valid Enum*/
+enum tpm_pme_addr_rep_subr_valid_t {
+	TPM_ADDR_REP_SUBR_INVALID = 0,
+	TPM_ADDR_REP_SUBR_VALID
+};
+
+/* Address Repacement Op Enum*/
+enum tpm_pme_addr_repl_op_t {
+	REPLACE_ADDR_MAC_T1 = 0,
+	REPLACE_ADDR_MAC_T2,
+	REPLACE_ADDR_MAC_T3,
+	REPLACE_ADDR_IP_T3,
+
+	REPLACE_ADDR_OP_MAX
+};
+
+/* Mod data area type Enum */
+enum tpm_pme_data_tbl_type_t {
+	TPM_PME_PRIVATE_TBL,
+	TPM_PME_SHARE_TBL,
+	TPM_PME_TBL_MAX,
+};
+
+/* Private table range enum */
+enum tpm_pme_private_range_t {
+	TPM_PME_PRI_RNG_NO_MOD,		/* No mod, ext mod_bm: 0x0 */
+	TPM_PME_PRI_RNG_L2_SW,		/* L2 Switch , ext mod_bm: 0x04 and 0x104 */
+	TPM_PME_PRI_RNG_ROUTE,		/* IPV4/6 UNI and MC route ext mod_bm 0x307, 0x317, 0x327 */
+	TPM_PME_PRI_RNG_US_NAPT,	/* IPV4 NAPT US ext mod_bm: 0x1707 0x1717 */
+	TPM_PME_PRI_RNG_DS_NAPT,	/* IPV4 NAPT DS ext mod_bm 0x2B07, 0x2B27 */
+	TPM_PME_PRI_RNG_MAX
+};
+
+/* Share table range enum */
+enum tpm_pme_share_range_t {
+	TPM_PME_SHA_RNG_MAC,		/* Single MAC */
+	TPM_PME_SHA_RNG_SA_SIP,		/* SMAC + SIP, for IP4_US_NAPT  ext mod_bm: 0x1707 0x1717*/
+	TPM_PME_SHA_RNG_DA_SA_DIP,	/* DMAC + SMAC + SIP, for IP4_DS_NAPT ext mod_bm 0x2B07, 0x2B27 */
+	TPM_PME_SHA_RNG_MAX
+};
+
+/* The allocated unit index in one use case, at most 2 according to design */
+enum tpm_pme_data_range_unit_idx_t {
+	TPM_PME_DATA_UNIT0 = 0,
+	TPM_PME_DATA_UNIT1,
+	TPM_PME_DATA_UNIT_MAX
+};
+
+/* The max num of different range in one case */
+enum tpm_pme_data_range_idx_t {
+	TPM_PME_DIFF_RNG0 = 0,
+	TPM_PME_DIFF_RNG1,
+	TPM_PME_SHARE_DIFF_RNG_MAX
+};
+
+/* Data table unit status enum */
+enum tpm_pme_data_unitstate_op_t {
+	TPM_DATA_STATE_CLEAR = 0,
+	TPM_DATA_STATE_SET,
+	TPM_DATA_STATE_OP_MAX
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+/* PME Modification structure */
+struct tpm_pme_pkt_mod_t {
+	struct tpm_pkt_mod_t	mod_data;	/* Modification data from user, inclding mod bm */
+	unsigned int		inter_mod_bm;	/* Internal modification bit map, seperate from user bit map */
+	unsigned short		mh_value;	/* Mh valud if need to update it */
+};
+
+/* PME modification instruction structure */
+struct tpm_pme_entry_t {
+	unsigned short	opcode;		/* Modification command */
+	unsigned short	data;		/* Modification data in instruction area */
+	unsigned char	last;		/* Indicates the end of modification command sequence */
+	unsigned char	updt_ipv4;	/* Update IPV4 checksum if needed */
+	unsigned char	updt_l4;	/* Update L4 checksum if needed */
+	unsigned char	cmd_type;	/* Modification command type */
+};
+
+/*tpm_pme_templ_pattern_t
+*Template pattern, mac_rep_info and ip_rep_info are explained as following:
+*take SMAC for example, it takes the low 16bit of mac_rep_info,
+*The low 8 bit of SMAC info, indicates the PME entry offset in instruction set,
+*higher 8 bits, indicates the cmd_type of first replace_2b instruction.
+*It is used with ext mod_bm, it is invalid if corresponding bm is not set.
+*|----------DMAC/DIP------------|----------SMAC/SIP------------|
+*|---cmd_type---|---entry_off---|---cmd_type---|---entry_off---|
+*/
+struct tpm_pme_templ_pattern_t {
+	struct tpm_pme_entry_t	pme_entry[TPM_PME_INSTR_TEMPL_ENTRY_MAX];
+	unsigned int		ext_mod_bm;	/* Mod bm from user */
+	unsigned int		int_mod_bm;	/* Mod bm internally */
+	unsigned char		qos_permu;	/* permutation of Qos */
+	unsigned char		ppoe_num;	/* only for IPV4 NAPT US, means the supported pppoe session number */
+	unsigned int		mac_rep_info;	/* MAC address replacement JSR info */
+	unsigned int		ip_rep_info;	/* IPV4 address replacement JSR info */
+};
+
+/* VLAN OPeration pattern */
+struct tpm_pme_vlan_entry_t {
+	struct tpm_pme_entry_t	vlan1[TPM_PME_MAX_VLAN_ENTRIES];	/* First VLAN op parameter */
+	struct tpm_pme_entry_t	vlan2[TPM_PME_MAX_VLAN_ENTRIES];	/* Second VLAN op parameter */
+};
+
+/* VLAN OPeration with skip to packet ether type filed */
+struct tpm_pme_vlan_skip_entry_t {
+	struct tpm_pme_vlan_entry_t	entry_array[VLANOP_MAX_CNT];	/* Vlan OP entry */
+	struct tpm_pme_entry_t		skip;				/* Skip to ETY after VLAN OP */
+};
+
+/* VLAN Operation permutation factor */
+struct tpm_pme_vlan_skip_permu_t {
+	unsigned char	pppoe;		/* Indicates apply to PPPoE pkt */
+	unsigned char	qos_src;	/* Indicates Pbit from */
+	unsigned char	tpid_sel;	/* VLAN TPID source factor */
+	unsigned char	vid_sel;	/* VLAN VID source */
+	unsigned char	cfi_sel;	/* VLAN CFI source, NOT care temporarily */
+	unsigned char	pbit_sel;	/* VLAN Pbit source */
+	unsigned char	dummy1;
+	unsigned char	dummy2;
+};
+
+/* VLAN Subr record info */
+struct tpm_pme_vlan_subr_t {
+	int					valid;		/* Indicate the entry is valid or not */
+	enum tpm_pme_vlan_oper_t		vlan_op;
+	struct tpm_pme_vlan_skip_permu_t	vlan_permu;
+	struct tpm_pme_entry_t			pme_entry[TPM_VLAN_TEMPL_ENTRY_MAX_NUM];
+	unsigned int				start_idx;	/* Sub-routine start index in instruction table */
+};
+
+/* Address Replacement subr */
+struct tpm_pme_addr_rep_subr_t {
+	int				valid;		/* Indicate the entry is valid or not */
+	enum tpm_pme_addr_repl_op_t	addr_rep_op;
+	struct tpm_pme_entry_t		pme_entry[TPM_PME_ADDR_REP_ENTRY_MAX];
+	unsigned int			start_idx;	/* Sub-routine start index in instruction table */
+};
+
+/* Usecase unified instruction template */
+struct tpm_pme_templ_data_t {
+	int			valid;		/* Indicate the entry is valid or not */
+	unsigned int		ext_mod_bm;	/* Modification bitmap from user config */
+	unsigned int		int_mod_bm;	/* Modification bitmap internal used */
+	unsigned int		mac_rep_info;	/* MAC address replacement JSR info */
+	unsigned int		ip_rep_info;	/* IPV4 address replacement JSR info */
+	unsigned int		jmp_idx;	/* The jump instruction index, which will jump to start_idx*/
+	unsigned int		start_idx;	/* The first instruction index in PME table */
+	unsigned int		ppoe_idx;	/* the PME entry index excutes IPV4 NAPT PPPoE add, others ignore it */
+	struct tpm_pme_entry_t	pme_entry[TPM_PME_INSTR_TEMPL_ENTRY_MAX];	/* PME command sequence */
+	unsigned int		ref_count;	/* Reference count of this template */
+};
+
+/* PME private and share data area management in DB */
+struct tpm_pme_data_entry_set_t {
+	int		valid;		/* Indicate the entry is valid or not */
+	unsigned char	tbl;		/* Indicates private and share data table */
+	unsigned char	range;		/* Indicates the entry belong to which data range */
+	unsigned short	mod_data[TPM_PME_DATA_ENTRY_MAX];	/* data sequence */
+	unsigned int	real_entry_cnt;	/* Real data entry count */
+	unsigned int	first_idx;	/* The first entry index in data area */
+	unsigned int	share_idx_ptr[TPM_PME_DATA_UNIT_MAX];/* The private data entry index point to share data */
+	unsigned int	templ_jmp;	/* The template jump index which the data belong to, only for private data */
+	unsigned int	ref_count;	/* Reference count of this entry */
+};
+
+/* Accoring to design, for one case, only share data range may appear 2 different kinds */
+struct tpm_pme_data_build_t {
+	unsigned int	private_data[TPM_PME_DATA_ENTRY_MAX];
+	unsigned short	share_data[TPM_PME_SHARE_DIFF_RNG_MAX][TPM_PME_DATA_ENTRY_MAX];
+	unsigned int	pri_rng[TPM_PME_SHARE_DIFF_RNG_MAX];
+	unsigned int	sha_rng[TPM_PME_SHARE_DIFF_RNG_MAX];
+	unsigned int	rng_unit_size[TPM_PME_SHARE_DIFF_RNG_MAX];/* Allocate unit size(B) of one range in share data */
+	unsigned int	private_idx;/* Index of private entry */
+};
+
+/* PME data table managment */
+struct tpm_pme_tbl_rng_t {
+	unsigned int	start;
+	unsigned int	case_num_max;
+	unsigned int	unit_size;	/* Allocated unit size, bytes, only used for Private and share table */
+	unsigned int	unit_state[TPM_PME_STATE_INT_NUM];/* each bit indicate each data unit,0:no-occupy, 1:occupied */
+};
+
+/* Misc information for PME HW */
+struct tpm_pme_misc_t {
+	spinlock_t			hw_lock;				/* HW access lock */
+	spinlock_t			instr_templ_lock;			/* Instruction template lock */
+	spinlock_t			pri_tbl_lock[TPM_PME_PRI_RNG_MAX];	/* Privae data lock */
+	spinlock_t			sha_tbl_lock[TPM_PME_SHA_RNG_MAX];	/* Share data lock */
+	/* Instruction table partition */
+	unsigned int			jmp_start;
+	unsigned int			jmp_area_size;
+	unsigned int			jmp_first_free;
+	unsigned int			templ_start;
+	unsigned int			templ_area_size;
+	unsigned int			templ_first_free;
+	unsigned int			subr_start;
+	unsigned int			subr_area_size;
+	unsigned int			subr_first_free;
+	/* Private data table range management info */
+	struct tpm_pme_tbl_rng_t	pri_rng_mng[TPM_PME_PRI_RNG_MAX];
+	/* Share data table range management info */
+	struct tpm_pme_tbl_rng_t	sha_rng_mng[TPM_PME_SHA_RNG_MAX];
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_pme_mod_create(struct tpm_pme_pkt_mod_t *pme_mod_data,
+		       unsigned int *hwfm_iptr,
+		       unsigned int *hwfm_dptr,
+		       bool mh_remove);
+
+int tpm_pme_priv_first_data_update(unsigned int index,
+				   unsigned short data);
+
+int tpm_pme_mod_release(unsigned int hwfm_iptr,
+			unsigned int hwfm_dptr);
+
+int tpm_pme_start(void);
+
+int tpm_pme_reset(void);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_policer.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_policer.h
new file mode 100644
index 0000000..e928406
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_policer.h
@@ -0,0 +1,152 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_POLICER_H_
+#define _TPM_POLICER_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_PLCR_INVALID_Q_THESH_IDX	(0xff)	/* invalid queue theshold index	*/
+#define TPM_PLCR_MIN_ENTRY_ID		(0)	/* minimium policer ID		*/
+#define TPM_TOKEN_PERIOD_400_CORE_CLOCK	(400)	/* 400 core clock		*/
+#define TPM_TOKEN_PERIOD_480_CORE_CLOCK	(480)	/* 480 core clock		*/
+#define TPM_TOKEN_PERIOD_600_CORE_CLOCK	(600)	/* 600 core clock		*/
+#define TPM_TOKEN_PERIOD_800_CORE_CLOCK	(800)	/* 800 core clock		*/
+#define TPM_PLCR_MIN_PKT_LEN		(0)	/* default min packet length	*/
+#define TPM_PLCR_CIR_NO_LIMIT		(0)	/* do not limit CIR		*/
+#define TPM_PLCR_DEFAULT_BURST_SIZE	(0)	/* default burst size		*/
+#define TPM_PLCR_DEFAULT_CBS		(2048)	/* default CBS size		*/
+#define TPM_PLCR_DEFAULT_EBS		(2048)	/* default EBS size		*/
+
+#define TPM_WRR_WEIGHT_MAX		(255)	/* WRR max weight factor        */
+#define TPM_SCHED_BUCKET_SIZE_MIN	(512)	/* Bucket min value             */
+#define TPM_WRR_UNIT_BYTE		(256)	/* wrr unit bytes               */
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_plcr_entry_state_t {
+	TPM_PLCR_ENTRY_INVALID_STATE = 0,	/* invalid policer entry	*/
+	TPM_PLCR_ENTRY_VALID_STATE		/* valid policer entry		*/
+};
+
+enum tpm_plcr_rate_state_t {
+	TPM_PLCR_BASE_RATE_DISABLE = 0,	/* disable base rate generation	*/
+	TPM_PLCR_BASE_RATE_ENABLE	/* enable base rate generation	*/
+};
+
+enum tpm_plcr_early_drop_state_t {
+	TPM_PLCR_EARLY_DROP_DISABLE = 0,/* disable early drop	*/
+	TPM_PLCR_EARLY_DROP_ENABLE	/* enable early drop	*/
+};
+
+enum tpm_plcr_ref_cnt_action_t {
+	TPM_PLCR_REF_CNT_INC = 0,	/* increase reference counter by 1		*/
+	TPM_PLCR_REF_CNT_DEC,		/* decrease reference counter by 1		*/
+	TPM_PLCR_REF_CNT_CLEAR,		/* clear reference counter to be 0		*/
+	TPM_PLCR_REF_CNT_CLEAR_ALL	/* clear reference counters for all policers	*/
+};
+
+enum tpm_plcr_token_update_type_t {
+	TPM_TOKEN_RATE_TYPE_1KBPS_1B = 0,	/* rate/burst bucket resolution:1KBPS/1B	*/
+	TPM_TOKEN_RATE_TYPE_10KBPS_8B,		/* rate/burst bucket resolution:10KBPS/8B	*/
+	TPM_TOKEN_RATE_TYPE_100KBPS_64B,	/* rate/burst bucket resolution:100KBPS/64B	*/
+	TPM_TOKEN_RATE_TYPE_1MBPS_512B,		/* rate/burst bucket resolution:1MBPS/512B	*/
+	TPM_TOKEN_RATE_TYPE_10MBPS_4KB,		/* rate/burst bucket resolution:10MBPS/4KB	*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_policer_gen_cfg_t {
+	enum tpm_plcr_rate_state_t	rate_state;	/* enable or disable base rate generation	*/
+	unsigned short			base_period;	/* token update period in units of core clock	*/
+	unsigned char			min_pkt_len;	/* minium packet length allowed by policer	*/
+	unsigned char			dummy;		/* dummy to be reserved for future usage	*/
+};
+
+struct tpm_policer_early_drop_t {
+	enum tpm_plcr_early_drop_state_t state;					/* en/disable base rate generation    */
+	unsigned short	cpu_q_thesh[MV_PP2_V0_PLCR_EDROP_THRESH_NUM];		/* CPU queue threshold for early drop */
+	unsigned short	hwf_q_thesh[MV_PP2_V0_PLCR_EDROP_THRESH_NUM];		/* HWF queue threshold for early drop */
+	unsigned char	rxq_idx[TPM_NUM_MAX_QUEUE];				/* CPU RX queue	threshold index	      */
+	unsigned char	txq_idx[TPM_NUM_TX_PORTS][TPM_NUM_MAX_QUEUE];		/* HWF TX queue	threshold index	      */
+};
+
+struct tpm_policer_token_type_t {
+	enum tpm_plcr_token_update_type_t	token_type;	/* token type					      */
+	unsigned int				rate_resl;	/* rate resolution in units of pkt/s or kbps	      */
+	unsigned int				max_rate;	/* maximum rate supported by this token type	      */
+	unsigned int				burst_size_resl;/* burst size resolution in units of pkt or bytes     */
+	unsigned int				max_busrt_size;	/* maximum burst size supported by this token type    */
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_plcr_entry_add(struct tpm_policer_entry_t	*policer_entry,
+		       unsigned char			*policer_id);
+int tpm_plcr_entry_del(unsigned char policer_id);
+int tpm_plcr_entry_clear(void);
+int tpm_plcr_ref_cnt_update(unsigned char			policer_id,
+			    enum tpm_plcr_ref_cnt_action_t	cnt_action);
+int tpm_plcr_gen_cfg_set(struct tpm_policer_gen_cfg_t *gen_cfg);
+int tpm_plcr_early_drop_set(struct tpm_policer_early_drop_t *early_drop);
+int tpm_plcr_entry_state_get(unsigned char policer_id, enum tpm_plcr_entry_state_t *state);
+int tpm_plcr_reset(void);
+int tpm_plcr_start(void);
+
+/* Tx rate limit */
+int tpm_sched_egr_mtu_set(enum tpm_gmac_idx_t gmac_idx,
+			  unsigned char tcont_id,
+			  unsigned int tx_size_max);
+
+int tpm_sched_egr_queue_mode_set(enum tpm_gmac_idx_t gmac_idx,
+				 unsigned char tcont_id,
+				 unsigned char queue_id,
+				 enum tpm_egr_sched_mode_t mode,
+				 unsigned short wrr_weight);
+
+int tpm_sched_egr_queue_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				     unsigned char tcont_id,
+				     unsigned char queue_id,
+				     unsigned int rate_lim_val,
+				     unsigned int bucket_size);
+
+int tpm_sched_egr_port_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				    unsigned char tcont_id,
+				    unsigned int rate_lim_val,
+				    unsigned int bucket_size);
+
+
+
+#endif /* _TPM_POLICER_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch.h
new file mode 100644
index 0000000..b70d57e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch.h
@@ -0,0 +1,273 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_switch.h                                                      **
+**                                                                           **
+**  DESCRIPTION : This file contains switch routine and wrapper APIs         **
+**  DEPENDCY : None                                                          **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_SWITCH_H_
+#define _TPM_SWITCH_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_SWITCH_MAX_PHY_NUM			(4)		/* Maximum internal PHY port number		*/
+#define TPM_SWITCH_MAX_PORT_RATE		(1000000)	/* Maximum switch port rate in unit of kpbs	*/
+#define TPM_SWITCH_MAX_UPLINK_PORT_RATE		(2000000)	/* Max switch uplink port rate in unit of kpbs	*/
+#define TPM_SWITCH_MAX_MAC_AGING_TIME		(0xFF*15)	/* Maximum MAC aging time			*/
+#define TPM_SWITCH_MAX_MAC_LEARN_LIMIT		(0xFF)		/* Maximum MAC learning limit			*/
+#define TPM_SWITCH_MAX_QUEUE_ID			(3)		/* Maximum queue number per port		*/
+#define TPM_SWITCH_MAX_WRR_VAR			(3)		/* Maximum switch WRR value			*/
+#define TPM_SWITCH_PORT_NUM			(7)		/* Switch port number				*/
+#define TPM_SWITCH_AGE_FACTOR			(15)		/* Switch aging time factor			*/
+#define TPM_SWITCH_DB_NUM			(0)		/* Switch DB number				*/
+#define TPM_ETHERTYPE_DSA_TAG			(0xDABC)	/* Switch default Ethernet type			*/
+
+#define BIT_2_GT_BOOL(var)	((var) ? GT_TRUE : GT_FALSE)
+#define GT_BOOL_2_BIT(var)	((var == GT_TRUE) ? 1 : 0)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_sw_port_type_t {
+	TPM_SW_MAC_PORT,	/* switch MAC type port	*/
+	TPM_SW_PHY_PORT,	/* switch PHY type port	*/
+	TPM_SW_ALL_PORT		/* whole switch port	*/
+};
+
+enum tpm_sw_enum_str_t {
+	TPM_SW_ENUM_INGRESS_MODE,	/* VLAN ingress mode	*/
+	TPM_SW_ENUM_EGRESS_MODE,	/* VLAN egress mode	*/
+	TPM_SW_ENUM_CONFIG_STATE,	/* switch config state	*/
+	TPM_SW_ENUM_FLOOD_TYPE,		/* flood packet type	*/
+	TPM_SW_ENUM_SPEED_MODE,		/* port speed mode	*/
+	TPM_SW_ENUM_DUPLEX_MODE,	/* port duplex mode	*/
+	TPM_SW_ENUM_PORT_STATE,		/* port state		*/
+	TPM_SW_ENUM_PORT_DIR,		/* port direction	*/
+	TPM_SW_ENUM_RATE_LIMIT_MODE,	/* port rate limit mode	*/
+	TPM_SW_ENUM_MAC_ADDR_TYPE,	/* MAC address type	*/
+	TPM_SW_ENUM_MAC_FILTER_MODE,	/* MAC filter mode	*/
+	TPM_SW_ENUM_MAC_CLEAR_MODE,	/* MAC clear type	*/
+	TPM_SW_ENUM_QOS_MODE,		/* QoS usage mode	*/
+	TPM_SW_ENUM_HEAD_MODE		/* head mode		*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+
+typedef int (*TPM_SW_FLOOD_GET_FUN) (unsigned char, GT_BOOL *);
+typedef int (*TPM_SW_FLOOD_SET_FUN) (unsigned char, GT_BOOL);
+
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+char *tpm_sw_lookup_enum_str(enum tpm_sw_enum_str_t enum_type, int enum_val);
+
+int tpm_sw_port_vlan_ingress_mode_set(enum tpm_sw_port_t		port,
+				      enum tpm_sw_ingress_mode_t	mode);
+int tpm_sw_port_vlan_ingress_mode_get(enum tpm_sw_port_t		port,
+				      enum tpm_sw_ingress_mode_t	*mode);
+int tpm_sw_port_pvid_set(enum tpm_sw_port_t	port,
+			 unsigned short		vid,
+			 unsigned char		pri);
+int tpm_sw_port_pvid_get(enum tpm_sw_port_t	port,
+			 unsigned short		*vid,
+			 unsigned char		*pri);
+int tpm_sw_port_vlan_set(enum tpm_sw_port_t		port,
+			 unsigned short			min_vlan,
+			 unsigned short			max_vlan,
+			 enum tpm_sw_vlan_egress_mode_t	mode);
+int tpm_sw_port_vlan_del(enum tpm_sw_port_t	port,
+			 unsigned short		min_vlan,
+			 unsigned short		max_vlan);
+int tpm_sw_port_vlan_get(unsigned short		vlan,
+			 unsigned int		*fwd_bm,
+			 unsigned int		*tag_bm);
+int tpm_sw_port_vlan_filter_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable);
+int tpm_sw_port_vlan_filter_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable);
+int tpm_sw_port_enable_state_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	enable);
+int tpm_sw_port_enable_state_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	*enable);
+int tpm_sw_port_flow_control_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	enable,
+				 unsigned int			interval);
+int tpm_sw_port_flow_control_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	*enable,
+				 unsigned int			*interval);
+int tpm_sw_port_isolate_mask_set(enum tpm_sw_port_t	port,
+				 unsigned int		port_mask);
+int tpm_sw_port_isolate_mask_get(enum tpm_sw_port_t	port,
+				 unsigned int		*port_mask);
+int tpm_sw_port_flood_control_mask_set(enum tpm_sw_port_t		port,
+				       enum tpm_sw_flood_packet_type_t	pkt_type,
+				       unsigned int			port_mask);
+int tpm_sw_port_flood_control_mask_get(enum tpm_sw_port_t		port,
+				       enum tpm_sw_flood_packet_type_t	pkt_type,
+				       unsigned int			*port_mask);
+int tpm_sw_all_count_clear(void);
+int tpm_sw_port_count_clear(enum tpm_sw_port_t port);
+int tpm_sw_port_link_mode_set(enum tpm_sw_port_t		port,
+			      enum tpm_sw_config_state_t	auto_en,
+			      enum tpm_sw_speed_mode_t		speed,
+			      enum tpm_sw_duplex_mode_t		duplex);
+int tpm_sw_port_link_mode_get(enum tpm_sw_port_t		port,
+			      enum tpm_sw_config_state_t	*auto_en,
+			      enum tpm_sw_speed_mode_t		*speed,
+			      enum tpm_sw_duplex_mode_t		*duplex);
+int tpm_sw_port_link_state_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_state_t		*link,
+			       enum tpm_sw_speed_mode_t		*speed,
+			       enum tpm_sw_duplex_mode_t	*duplex);
+int tpm_sw_port_rate_limit_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	enable,
+			       enum tpm_sw_rate_limit_mode_t	mode,
+			       unsigned int			rate);
+int tpm_sw_port_rate_limit_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	*enable,
+			       enum tpm_sw_rate_limit_mode_t	*mode,
+			       unsigned int			*rate);
+int tpm_sw_port_mc_proto_rate_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_port_dir_t	dir,
+				  enum tpm_sw_config_state_t	enable,
+				  enum tpm_sw_rate_limit_mode_t	mode,
+				  unsigned int			rate);
+int tpm_sw_port_mc_proto_rate_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_port_dir_t	dir,
+				  enum tpm_sw_config_state_t	*enable,
+				  enum tpm_sw_rate_limit_mode_t	*mode,
+				  unsigned int			*rate);
+int tpm_sw_port_mc_data_rate_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	enable,
+				 enum tpm_sw_rate_limit_mode_t	mode,
+				 unsigned int			rate);
+int tpm_sw_port_mc_data_rate_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	*enable,
+				 enum tpm_sw_rate_limit_mode_t	*mode,
+				 unsigned int			*rate);
+int tpm_sw_port_broadcast_rate_set(enum tpm_sw_port_t			port,
+				   enum tpm_sw_port_dir_t		dir,
+				   enum tpm_sw_config_state_t		enable,
+				   enum tpm_sw_rate_limit_mode_t	mode,
+				   unsigned int				rate);
+int tpm_sw_port_broadcast_rate_get(enum tpm_sw_port_t			port,
+				   enum tpm_sw_port_dir_t		dir,
+				   enum tpm_sw_config_state_t		*enable,
+				   enum tpm_sw_rate_limit_mode_t	*mode,
+				   unsigned int				*rate);
+int tpm_sw_port_mirror_set(enum tpm_sw_port_t		sport,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	enable,
+			   enum tpm_sw_port_t		dport);
+int tpm_sw_port_mirror_get(enum tpm_sw_port_t		sport,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	*enable,
+			   enum tpm_sw_port_t		*dport);
+int tpm_sw_port_loopback_set(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_dir_t	dir,
+			     enum tpm_sw_config_state_t	enable);
+int tpm_sw_port_loopback_get(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_dir_t	dir,
+			     enum tpm_sw_config_state_t	*enable);
+int tpm_sw_mac_aging_time_set(unsigned int time);
+int tpm_sw_mac_aging_time_get(unsigned int *time);
+int tpm_sw_port_mac_learn_limit_set(enum tpm_sw_port_t		port,
+				    enum tpm_sw_config_state_t	enable,
+				    unsigned int		limit);
+int tpm_sw_port_mac_learn_limit_get(enum tpm_sw_port_t		port,
+				    enum tpm_sw_config_state_t	*enable,
+				    unsigned int		*limit);
+int tpm_sw_port_mac_address_add(unsigned char			port_bm,
+				unsigned char			*mac,
+				unsigned short			vlan,
+				enum tpm_sw_mac_addr_mode_t	mode);
+int tpm_sw_port_mac_address_del(enum tpm_sw_port_t	port,
+				unsigned char		*mac,
+				unsigned short		vlan);
+int tpm_sw_port_mac_filter_mode_set(enum tpm_sw_port_t			port,
+				    enum tpm_sw_mac_filter_mode_t	mode);
+int tpm_sw_port_mac_filter_mode_get(enum tpm_sw_port_t			port,
+				    enum tpm_sw_mac_filter_mode_t	*mode);
+int tpm_sw_port_mac_filter_entry_add(enum tpm_sw_port_t			port,
+				     unsigned char			*mac,
+				     unsigned short			vlan,
+				     enum tpm_sw_mac_filter_mode_t	mode);
+int tpm_sw_port_mac_filter_entry_del(enum tpm_sw_port_t			port,
+				     unsigned char			*mac,
+				     unsigned short			vlan,
+				     enum tpm_sw_mac_filter_mode_t	mode);
+int tpm_sw_mac_address_clear(void);
+int tpm_sw_port_mac_table_clear(enum tpm_sw_port_t		port,
+				enum tpm_sw_mac_addr_mode_t	mode);
+int tpm_sw_port_mac_table_clear_dynamic(enum tpm_sw_port_t port);
+
+int tpm_sw_port_qos_set(enum tpm_sw_port_t	port,
+			enum tpm_sw_queue_t	queue,
+			enum tpm_sw_qos_mode_t	mode,
+			unsigned char		weight);
+int tpm_sw_port_qos_get(enum tpm_sw_port_t	port,
+			enum tpm_sw_queue_t	queue,
+			enum tpm_sw_qos_mode_t	*mode,
+			unsigned char		*weight);
+int tpm_sw_mtu_set(unsigned int mtu);
+int tpm_sw_mtu_get(unsigned int *mtu);
+int tpm_sw_port_stat1_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat1_t	*stat);
+int tpm_sw_port_stat2_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat2_t	*stat);
+int tpm_sw_port_stat3_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat3_t	*stat);
+int tpm_sw_port_stat_all_get(enum tpm_sw_port_t			port,
+			     enum tpm_sw_count_reset_t		reset,
+			     struct tpm_sw_port_stat_all_t	*stat);
+int tpm_sw_atu_dump(enum tpm_sw_mac_addr_mode_t mode);
+int tpm_sw_vtu_dump(unsigned int vid);
+int tpm_sw_vtu_shadow_dump(void);
+int tpm_sw_mh_mode_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable);
+int tpm_sw_mh_mode_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable);
+int tpm_sw_port_preamble_set(enum tpm_sw_port_t port, unsigned short preamble);
+int tpm_sw_port_preamble_get(enum tpm_sw_port_t port, unsigned short *preamble);
+int tpm_sw_head_mode_set(enum tpm_sw_head_mode_t mode);
+int tpm_sw_head_mode_get(enum tpm_sw_head_mode_t *mode);
+int tpm_sw_start(void);
+
+#endif /* _TPM_SWITCH_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch_api.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch_api.h
new file mode 100644
index 0000000..75c2039
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_switch_api.h
@@ -0,0 +1,1709 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_switch_api.h                                                  **
+**                                                                           **
+**  DESCRIPTION : This file contains switch APIs                             **
+**  DEPENDCY : None                                                          **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_SWITCH_API_H_
+#define _TPM_SWITCH_API_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_sw_port_t {
+	TPM_SW_PORT_0,			/* switch port 0	*/
+	TPM_SW_PORT_1,			/* switch port 1	*/
+	TPM_SW_PORT_2,			/* switch port 2	*/
+	TPM_SW_PORT_3,			/* switch port 3	*/
+	TPM_SW_PORT_4,			/* switch port 4	*/
+	TPM_SW_PORT_5,			/* switch port 5	*/
+	TPM_SW_PORT_6,			/* switch port 6	*/
+	TPM_SW_PORT_MAX = TPM_SW_PORT_6,/* switch port MAX	*/
+};
+
+enum tpm_sw_queue_t {
+	TPM_SW_QUEUE_0,				/* switch queue 0	*/
+	TPM_SW_QUEUE_1,				/* switch queue 1	*/
+	TPM_SW_QUEUE_2,				/* switch queue 2	*/
+	TPM_SW_QUEUE_3,				/* switch queue 3	*/
+	TPM_SW_QUEUE_MAX = TPM_SW_QUEUE_3,	/* switch queue MAX	*/
+};
+
+enum tpm_sw_head_mode_t {
+	TPM_SW_HEAD_NONE,		/* GAMC packets to switch w/o head		*/
+	TPM_SW_HEAD_MH,			/* GAMC packets to switch w/ MH			*/
+	TPM_SW_HEAD_MH_ETYPE_DSA,	/* GAMC packets to switch w/ MH ETH type DSA	*/
+	TPM_SW_HEAD_DSA,		/* GAMC packets to switch w/ DSA		*/
+	TPM_SW_HEAD_EXT_DSA,		/* GAMC packets to switch w/ extended DSA	*/
+	TPM_SW_HEAD_UNKNOWN		/* Unknown head mode				*/
+};
+
+enum tpm_sw_init_mode_t {
+	TPM_SW_MODE_NOT_INIT = 0,	/* initialize switch		*/
+	TPM_SW_MODE_INIT		/* do not initialize switch	*/
+};
+
+enum tpm_sw_ingress_mode_t {
+	TPM_SW_INGRESS_ASIS,		/* pass all ingress packets asis	*/
+	TPM_SW_INGRESS_DISCARD_ALL,	/* discard all ingress packets		*/
+	TPM_SW_INGRESS_DISCARD_UNTAG,	/* discard ingress untagged packets	*/
+	TPM_SW_INGRESS_DISCARD_TAG	/* discard ingress tagged packets	*/
+};
+
+enum tpm_sw_vlan_egress_mode_t {
+	TPM_SW_VLAN_EGRESS_ASIS,	/* pass all egress packets asis			*/
+	TPM_SW_VLAN_EGRESS_NOT_IN_VLAN,	/* egress port is not in VLAN			*/
+	TPM_SW_VLAN_EGRESS_STRIP_VLAN,	/* strip VLAN tag of egress tagged packets	*/
+	TPM_SW_VLAN_EGRESS_KEEP_VLAN	/* keep VLAN tag of egress tagged packets	*/
+};
+
+enum tpm_sw_config_state_t {
+	TPM_SW_CONFIG_DISABLE,	/* disable switch feature	*/
+	TPM_SW_CONFIG_ENABLE	/* enable switch feature	*/
+};
+
+enum tpm_sw_flood_packet_type_t {
+	TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST,	/* traffic type: unknown unicast DMAC address			*/
+	TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST,	/* traffic type: unknown unicast SMAC address			*/
+	TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST,	/* traffic type: unknown IPv4 multicast MAC address		*/
+	TPM_SW_FLOOD_PKT_BROADCAST,		/* traffic type: broadcast MAC addres				*/
+	TPM_SW_FLOOD_PKT_OTHER_PORT_SA,		/* traffic type: unicast SMAC address learned by other port	*/
+	TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST	/* traffic type: unknown IPv6 multicast MAC address		*/
+};
+
+enum tpm_sw_speed_mode_t {
+	TPM_SW_SPEED_MODE_10M,		/* 10Mbps speed			*/
+	TPM_SW_SPEED_MODE_100M,		/* 100Mbps speed		*/
+	TPM_SW_SPEED_MODE_1000M,	/* 1000Mbps speed		*/
+	TPM_SW_SPEED_MODE_AUTO		/* automatically seleted speed	*/
+};
+
+enum tpm_sw_duplex_mode_t {
+	TPM_SW_DUPLEX_MODE_HALF,	/* half duplex mode			*/
+	TPM_SW_DUPLEX_MODE_FULL,	/* full duplex mode			*/
+	TPM_SW_DUPLEX_MODE_AUTO		/* automaticall selted duplex mode	*/
+};
+
+enum tpm_sw_port_state_t {
+	TPM_SW_PORT_STATE_DOWN,	/* port PHY state is down	*/
+	TPM_SW_PORT_STATE_UP	/* port PHY state is up		*/
+};
+
+enum tpm_sw_port_dir_t {
+	TPM_SW_PORT_DIR_INGRESS,	/* ingress direction	*/
+	TPM_SW_PORT_DIR_EGRESS,		/* egress direction	*/
+	TPM_SW_PORT_DIR_BOTH		/* both of direction	*/
+};
+
+enum tpm_sw_rate_limit_mode_t {
+	TPM_SW_RATE_LIMIT_FRAME,	/* count on frame				*/
+	TPM_SW_RATE_LIMIT_LAYER1,	/* count on layer 1(includes preamble and ifg)	*/
+	TPM_SW_RATE_LIMIT_LAYER2,	/* count on layer 2(Frame's DA to CRC)		*/
+	TPM_SW_RATE_LIMIT_LAYER3,	/* count on layer 3				*/
+};
+
+enum tpm_sw_mac_addr_mode_t {
+	TPM_SW_MAC_ADDR_DYNAMIC,	/* dynamic MAC address	*/
+	TPM_SW_MAC_ADDR_STATIC,		/* static MAC address	*/
+	TPM_SW_MAC_ADDR_UNICAST,	/* unicast MAC address	*/
+	TPM_SW_MAC_ADDR_MULTICAST,	/* multicast MAC address*/
+	TPM_SW_MAC_ADDR_ALL,		/* all MAC address	*/
+};
+
+enum tpm_sw_mac_filter_mode_t {
+	TPM_SW_MAC_NO_FILTER,		/* no MAC filter		*/
+	TPM_SW_MAC_BLACK_FILTER_DMAC,	/* filter by DMAC in black list	*/
+	TPM_SW_MAC_WHITE_FILTER_DMAC,	/* filter by DMAC in white list	*/
+	TPM_SW_MAC_BLACK_FILTER_SMAC,	/* filter by SMAC in black list	*/
+	TPM_SW_MAC_WHITE_FILTER_SMAC	/* filter by SMAC in white list	*/
+};
+
+enum tpm_sw_qos_mode_t {
+	TPM_SW_QOS_MODE_SP,	/* SP QoS mode			*/
+	TPM_SW_QOS_MODE_WRR,	/* WRR QoS mode			*/
+	TPM_SW_QOS_MODE_SP_WRR	/* SP and SRR mixed QoS mode	*/
+};
+
+enum tpm_sw_count_reset_t {
+	TPM_SW_COUNT_NOT_RESET = 0,	/* do not reset switch counter while reading	*/
+	TPM_SW_COUNT_RESET		/* reset switch counter while reading		*/
+};
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_sw_port_stat1_t {
+	unsigned long long inbytes;		/* ingress bytes		*/
+	unsigned long long inpkts;		/* ingress pkts, no error pkts	*/
+	unsigned long long inunicast;		/* ingress unicast pkts		*/
+	unsigned long long inmulticast;		/* ingress multicast pkts	*/
+	unsigned long long inbroadcast;		/* ingress broadcast pkts	*/
+	unsigned long long inerror;		/* ingress FCS error pkts	*/
+	unsigned long long indiscard;		/* ingress discard pkts		*/
+	unsigned long long outbytes;		/* egress bytes			*/
+	unsigned long long outpkts;		/* egress pkts			*/
+	unsigned long long outunicast;		/* egress unicast pkts		*/
+	unsigned long long outmulticast;	/* egress multicast pkts	*/
+	unsigned long long outbroadcast;	/* egress broadcast pkts	*/
+	unsigned long long outerror;		/* egress FCS error pkts	*/
+	unsigned long long outdiscard;		/* egress discard pkts		*/
+};
+
+struct tpm_sw_port_stat2_t {
+	unsigned long long inundersize;		/* ingress pkts shorter than 64B		*/
+	unsigned long long inoversize;		/* ingress oversized pkts			*/
+	unsigned long long infragments;		/* ingress pkts shorter than 64B with FCS error	*/
+	unsigned long long injabbers;		/* ingress oversized pkts with FCS error	*/
+	unsigned long long outundersize;	/* egress pkts shorter than 64B			*/
+	unsigned long long outoversize;		/* egress oversized pkts			*/
+	unsigned long long pppoefiltered;	/* pkts filtered by PPPoE			*/
+	unsigned long long statechange;		/* state changing times				*/
+	unsigned long long outpause;		/* egress pause pkts				*/
+	unsigned long long dropevents;		/* ingress drop					*/
+};
+
+struct tpm_sw_port_stat3_t {
+	unsigned long long in64;		/* ingress pkts equal to 64B		*/
+	unsigned long long in65to127;		/* ingress pkts from 65B to 127B	*/
+	unsigned long long in128to255;		/* ingress pkts from 128B to 255B	*/
+	unsigned long long in256to511;		/* ingress pkts from 256B to 511B	*/
+	unsigned long long in512to1023;		/* ingress pkts from 512B to 1023B	*/
+	unsigned long long in1024tomax;		/* ingress pkts bigger than 1024B	*/
+	unsigned long long out64;		/* egress pkts equal to 64B		*/
+	unsigned long long out65to127;		/* egress pkts from 65B to 127B		*/
+	unsigned long long out128to255;	/* egress pkts from 128B to 255B	*/
+	unsigned long long out256to511;		/* egress pkts from 256B to 511B	*/
+	unsigned long long out512to1024;	/* egress pkts from 512B to 1023B	*/
+	unsigned long long out1024tomax;	/* egress pkts bigger than 1024B	*/
+};
+
+struct tpm_sw_port_stat_all_t {
+	unsigned int	inGoodOctetsLo;	/* ingress good bytes, LSB 4 bytes	*/
+	unsigned int	inGoodOctetsHi;	/* ingress good bytes, MSB 4 bytes	*/
+	unsigned int	inBadOctets;	/* ingress bad bytes			*/
+	unsigned int	outFCSErr;	/* egress FCS error packets		*/
+	unsigned int	inUnicasts;	/* ingress unicast packets		*/
+	unsigned int	deferred;	/* egress deferred packets		*/
+	unsigned int	inBroadcasts;	/* ingress broadcast packets		*/
+	unsigned int	inMulticasts;	/* ingress multicast packets		*/
+	/*
+	Histogram Counters : Rx Only, Tx Only, or both Rx and Tx
+	(refer to Histogram Mode)
+	*/
+	unsigned int	octets64;	/* 64 bytes				*/
+	unsigned int	octets127;	/* 65 to 127 bytes			*/
+	unsigned int	octets255;	/* 128 to 255 bytes			*/
+	unsigned int	octets511;	/* 256 to 511 bytes			*/
+	unsigned int	octets1023;	/* 512 to 1023 bytes			*/
+	unsigned int	octetsMax;	/* 1024 to Max bytes			*/
+	unsigned int	outOctetsLo;	/* ingress good bytes, LSB 4 bytes	*/
+	unsigned int	outOctetsHi;	/* ingress good bytes, MSB 4 bytes	*/
+	unsigned int	outUnicasts;	/* egress unicast packets		*/
+	unsigned int	excessive;	/* egress excessive packets		*/
+	unsigned int	outMulticasts;	/* egress multicast packets		*/
+	unsigned int	outBroadcasts;	/* egress broadcast packets		*/
+	unsigned int	single;		/* egress single packets		*/
+
+	unsigned int	outPause;	/* egress pause packets			*/
+	unsigned int	inPause;	/* ingress pause packets		*/
+	unsigned int	multiple;	/* egress multiple packets		*/
+	unsigned int	undersize;	/* ingress undersize packets		*/
+	unsigned int	fragments;	/* ingress fragment packets		*/
+	unsigned int	oversize;	/* ingress oversize packets		*/
+	unsigned int	jabber;		/* ingress jabber packets		*/
+	unsigned int	inMACRcvErr;	/* ingress MAC received error packets	*/
+	unsigned int	inFCSErr;	/* ingress FCS error packets		*/
+	unsigned int	collisions;	/* egress collision packets		*/
+	unsigned int	late;		/* egress late packets			*/
+
+	unsigned int	inDiscard;	/* ingress discarded packets		*/
+	unsigned int	inFiltered;	/* ingress filtered packets		*/
+	unsigned int	outFiltered;	/* egress filtered packets		*/
+
+};
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_set
+*
+* DESCRIPTION: The routine sets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_set(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_get
+*
+* DESCRIPTION: The routine gets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_get(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	*mode);
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_set
+*
+* DESCRIPTION: The routine sets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_set(enum tpm_sw_port_t	port,
+		       unsigned short		vid,
+		       unsigned char		pri);
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_get
+*
+* DESCRIPTION: The routine gets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_get(enum tpm_sw_port_t	port,
+		       unsigned short		*vid,
+		       unsigned char		*pri);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_set
+*
+* DESCRIPTION: The routine adds a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*	mode      - VLAN egress mode
+*			TPM_SW_VLAN_EGRESS_ASIS:        AS-IS
+*			TPM_SW_VLAN_EGRESS_NOT_IN_VLAN: not in this vlan
+*			TPM_SW_VLAN_EGRESS_STRIP_VLAN:  egress and strip vlan tag
+*			TPM_SW_VLAN_EGRESS_KEEP_VLAN:   egress and do not strip vlan tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_set(enum tpm_sw_port_t		port,
+		       unsigned short			min_vlan,
+		       unsigned short			max_vlan,
+		       enum tpm_sw_vlan_egress_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_del
+*
+* DESCRIPTION: The routine deletes a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_del(enum tpm_sw_port_t	port,
+		       unsigned short		min_vlan,
+		       unsigned short		max_vlan);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_get
+*
+* DESCRIPTION: The routine get VLAN information for specific switch port
+*
+* INPUTS:
+*	vlan    - VLAN ID value
+*
+* OUTPUTS:
+*	fwd_bm  - Bitmap of egress forwarding mode
+*		  0:do not forward, 1:forward
+*		  bit0:port 0, bit1:port 1 ...
+*	tag_bm  - Bitmap of egress VLAN tag mode
+*		  0:egress untagged, 1:egress tagged
+*		  bit0:port 0, bit1:port 1 ...
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_get(unsigned short		vlan,
+		       unsigned int		*fwd_bm,
+		       unsigned int		*tag_bm);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_set
+*
+* DESCRIPTION:
+*	The API sets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*       enable - enable or disable filter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable);
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_get
+*
+* DESCRIPTION:
+*	The API gets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*
+* OUTPUTS:
+*       enable - enable or disable filter mode.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable);
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_set
+*
+* DESCRIPTION: The routine enable or disable switch port
+*
+* INPUTS:
+*	port   - switch port
+*	enable - enable or disable switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable);
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_get
+*
+* DESCRIPTION: The routine gets switch port PHY state
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	enable - enabled or disabled of switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable);
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_set
+*
+* DESCRIPTION: The routine configures switch port flow control
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable flow control
+*	interval  - interval time of pause frame
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable,
+			       unsigned int			interval);
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_get
+*
+* DESCRIPTION: The routine gets switch port flow control configuration
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enabled or disabled of flow control
+*	interval  - interval time of pause frame
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable,
+			       unsigned int			*interval);
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_set
+*
+* DESCRIPTION: The routine sets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port        - switch port
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_set(enum tpm_sw_port_t	port,
+			       unsigned int		port_mask);
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_get
+*
+* DESCRIPTION: The routine gets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	port_mask - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_get(enum tpm_sw_port_t	port,
+			       unsigned int		*port_mask);
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_set
+*
+* DESCRIPTION: The routine sets switch port flood control configuration
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: block
+*			1: do not block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_set(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			port_mask);
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_get
+*
+* DESCRIPTION: The routine gets flood control information
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*
+* OUTPUTS:
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_get(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			*port_mask);
+
+/*******************************************************************************
+* mv_tpm_sw_all_count_clear
+*
+* DESCRIPTION: The routine clears the counters of all switch ports
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_all_count_clear(void);
+
+/*******************************************************************************
+* mv_tpm_sw_port_count_clear
+*
+* DESCRIPTION: The routine clears the counters of dedicated switch ports
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_port_count_clear(enum tpm_sw_port_t port);
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_set
+*
+* DESCRIPTION: The routine sets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_set(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	auto_en,
+			    enum tpm_sw_speed_mode_t	speed,
+			    enum tpm_sw_duplex_mode_t	duplex);
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_get
+*
+* DESCRIPTION: The routine gets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*
+* OUTPUTS:
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_get(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	*auto_en,
+			    enum tpm_sw_speed_mode_t	*speed,
+			    enum tpm_sw_duplex_mode_t	*duplex);
+
+/*******************************************************************************
+* mv_tpm_sw_link_state_get
+*
+* DESCRIPTION: The routine gets switch port dynamic link state, including
+*	whether link up, speed and dumplex mode.
+*
+* INPUTS:
+*	port    - switch port
+*
+* OUTPUTS:
+*	link    - link up or down state
+*			TPM_SW_PORT_STATE_DOWN:  link down
+*			TPM_SW_PORT_STATE_UP:    link up
+*	speed   - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*	duplex  - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_state_get(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_state_t	*link,
+			     enum tpm_sw_speed_mode_t	*speed,
+			     enum tpm_sw_duplex_mode_t	*duplex);
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_set(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		enable,
+			     enum tpm_sw_rate_limit_mode_t	mode,
+			     unsigned int			rate);
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_get(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		*enable,
+			     enum tpm_sw_rate_limit_mode_t	*mode,
+			     unsigned int			*rate);
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_set(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	enable,
+				enum tpm_sw_rate_limit_mode_t	mode,
+				unsigned int			rate);
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate);
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	enable,
+			       enum tpm_sw_rate_limit_mode_t	mode,
+			       unsigned int			rate);
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate);
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	enable,
+				 enum tpm_sw_rate_limit_mode_t	mode,
+				 unsigned int			rate);
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate);
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_set
+*
+* DESCRIPTION: The routine sets port mirror
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_set(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	enable,
+			 enum tpm_sw_port_t		dport);
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_get
+*
+* DESCRIPTION: The routine gets port mirror configuration
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_get(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	*enable,
+			 enum tpm_sw_port_t		*dport);
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_set
+*
+* DESCRIPTION: The routine sets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port loopback
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_set(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	enable);
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_get
+*
+* DESCRIPTION: The routine gets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port loopback
+
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_get(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	*enable);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_set
+*
+* DESCRIPTION: The routine sets switch aging time
+*
+* INPUTS:
+*	time  - switch aging time in unit of second
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_set(unsigned int time);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_get
+*
+* DESCRIPTION: The routine gets switch aging time
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	time  - switch aging time in unit of second
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_get(unsigned int *time);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_set
+*
+* DESCRIPTION: The routine sets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	enable,
+				  unsigned int			limit);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_get
+*
+* DESCRIPTION: The routine gets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	*enable,
+				  unsigned int			*limit);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_add
+*
+* DESCRIPTION: The routine adds MAC address
+*
+* INPUTS:
+*	port_bm - switch port bitmap
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - enable or disable port mirror
+*		TPM_SW_MAC_ADDR_DYNAMIC: dynamic MAC address
+*		TPM_SW_MAC_ADDR_STATIC:  static MAC address
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_add(unsigned char			port_bm,
+			      unsigned char			*mac,
+			      unsigned short			vlan,
+			      enum tpm_sw_mac_addr_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_del
+*
+* DESCRIPTION: The routine deletes MAC address
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_del(unsigned char	port,
+			      unsigned char	*mac,
+			      unsigned short	vlan);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_set
+*
+* DESCRIPTION: The routine sets MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_get
+*
+* DESCRIPTION: The routine gets MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	*mode);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_add
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_add(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_del
+*
+* DESCRIPTION: The routine deletes MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_del(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_clear
+*
+* DESCRIPTION: The routine clear all MAC addresses
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_clear(void);
+
+/*******************************************************************************
+* mv_tpm_sw_mac_table_clear
+*
+* DESCRIPTION: The routine clear MAC address based on port and type
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC clear mode
+*		TPM_SW_MAC_ADDR_DYNAMIC:   clear dynami mac
+*		TPM_SW_MAC_ADDR_STATIC:    clear static mac
+*		TPM_SW_MAC_ADDR_UNICAST:   clear unicast mac
+*		TPM_SW_MAC_ADDR_MULTICAST: clear multicast mac
+*		TPM_SW_MAC_ADDR_ALL:       clear all
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_table_clear(enum tpm_sw_port_t		port,
+			      enum tpm_sw_mac_addr_mode_t	mode);
+
+/*******************************************************************************
+* mv_tpm_sw_qos_set
+*
+* DESCRIPTION: The routine sets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_set(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	mode,
+		      unsigned char		weight);
+
+/*******************************************************************************
+* mv_tpm_sw_qos_get
+*
+* DESCRIPTION: The routine gets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*
+* OUTPUTS:
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_get(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	*mode,
+		      unsigned char		*weight);
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	mtu  - MTU of switch
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_set(unsigned int mtu);
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	mtu  - MTU of switch
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_get(unsigned int *mtu);
+
+/*******************************************************************************
+* mv_tpm_sw_stat1_get
+*
+* DESCRIPTION: The routine gets performance counter 1
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 1
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat1_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat1_t	*stat);
+
+/*******************************************************************************
+* mv_tpm_sw_stat2_get
+*
+* DESCRIPTION: The routine gets performance counter 2
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 2
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat2_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat2_t	*stat);
+
+/*******************************************************************************
+* mv_tpm_sw_stat3_get
+*
+* DESCRIPTION: The routine gets performance counter 3
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat3_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat3_t	*stat);
+
+/*******************************************************************************
+* mv_tpm_sw_stat_all_get
+*
+* DESCRIPTION: The routine gets all switch performance counters
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - all performance counters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat_all_get(enum tpm_sw_port_t			port,
+			   enum tpm_sw_count_reset_t		reset,
+			   struct tpm_sw_port_stat_all_t	*stat);
+
+#endif /* _TPM_SWITCH_API_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs.h
new file mode 100644
index 0000000..88d0421
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs.h
@@ -0,0 +1,115 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_sysfs.h						     **
+**									     **
+**  DESCRIPTION : This file contains macro and api protypes of TPM sysfs     **
+**  DEPENDCY : TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_SYSFS_H_
+#define _TPM_SYSFS_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_SYSFS_NUM_MAX_ATTR_GROUP	(20)	/* TPM MAX attribute group	*/
+
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_sysfs_type_t {
+	TPM_SYSFS_TYPE_API,	/* TPM API type sysfs attribute group	*/
+	TPM_SYSFS_TYPE_DEBUG	/* TPM debug type sysfs attribute group	*/
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_attr_group_pair_t {
+	bool			valid;		/* Wether this pair is valid	*/
+	char			*obj_name;	/* Object name			*/
+	struct attribute_group	*attr_group;	/* Pointer to attribute group	*/
+	struct kobject          *kobj;		/* Kernel object		*/
+};
+
+struct store_sysfs_name_func_t {
+	char *sysfs_name;					/* Name of syfs function	*/
+	void (*sysfs_func)(const char *buf, size_t len);	/* Syfs function		*/
+};
+
+struct show_sysfs_name_func_t {
+	char *sysfs_name;		/* Name of syfs function	*/
+	int (*sysfs_func)(char *buf);	/* Syfs function		*/
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+int tpm_sysfs_init_cfg_init(void);
+int tpm_sysfs_prs_init(void);
+int tpm_sysfs_cls_init(void);
+void tpm_sfs_cls_rl_print(unsigned int			offset,
+			struct tpm_db_cls_fl_rule_t	*fl_rule,
+			bool				hw_dump);
+int tpm_sysfs_c2_init(void);
+void tpm_sfs_valid_c2_entry_header_dump(void);
+void tpm_sfs_valid_c2_entry_line_dump(unsigned int lkp_type,
+				      unsigned int dump_idx,
+				      struct tpm_c2_data_t *c2_entry,
+				      struct tpm_c2_index_t *c2_index_node);
+int tpm_sysfs_c3_init(void);
+void tpm_sfs_c3_entry_convert(MV_PP2_CLS_C3_ENTRY *lsp_entry, struct tpm_c3_data_t *mng_entry);
+void tpm_sfs_c3_entry_header_dump(void);
+void tpm_sfs_c3_entry_line_dump(unsigned int		dump_idx,
+				unsigned int		hash_idx,
+				unsigned int		logic_idx,
+				unsigned int		hit_count,
+				struct tpm_c3_data_t	*c3_entry);
+int tpm_sysfs_c4_init(void);
+int tpm_sysfs_mc_init(void);
+int tpm_sysfs_pme_init(void);
+void tpm_sfs_pme_cmd_trace_dump(unsigned int	cmd,
+				unsigned int	data);
+int tpm_sysfs_qos_init(void);
+int tpm_sysfs_api_init(void);
+int tpm_sysfs_mng_init(void);
+int tpm_sysfs_plcr_init(void);
+int tpm_sysfs_switch_init(void);
+int tpm_sysfs_mc_init(void);
+int tpm_sysfs_register(enum tpm_sysfs_type_t type, char *name, struct attribute_group *group);
+int tpm_sysfs_init(void);
+void tpm_sfs_c4_entry_dump(struct tpm_c4_add_entry_t	*rule_entry);
+
+int tpm_sfs_help_parse_rule_bm_print(char *buf, int cur_off);
+
+#endif /* _TPM_SYSFS_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs_utils.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs_utils.h
new file mode 100644
index 0000000..2464098
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_sysfs_utils.h
@@ -0,0 +1,233 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_SYSFS_UTILS_H_
+#define _TPM_SYSFS_UTILS_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define DB_TPMCFG_MAX_NAME         32
+#define DB_TPMCFG_MAX_ENTRIES      512
+
+/* Flags to indicate which fields are defined */
+#define MOD_ENTRY_FLAG_IPV4        0x1
+#define MOD_ENTRY_FLAG_IPV6        0x2
+#define MOD_ENTRY_FLAG_PPPOE       0x4
+#define MOD_ENTRY_FLAG_MAC         0x8
+#define MOD_ENTRY_FLAG_VLAN        0x10
+#define MOD_ENTRY_FLAG_MH          0x20
+#define MOD_ENTRY_FLAG_DSCP        0x40
+#define MOD_ENTRY_FLAG_L4_PORT     0x80
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+#define PR_RULE_IDX(rule_idx)		{}
+#define PR_HIT_COUNT(hit_count)		{}
+#define PR_POLICER_ID(plcr_id)		{}
+#define PR_RESULT_OK	{}
+#else
+#define PR_RULE_IDX(rule_idx)	{printk(KERN_INFO "OK. rule_idx = %d\n", rule_idx); }
+#define PR_HIT_COUNT(hit_count)		{printk(KERN_INFO "OK. hit_count = %d\n", hit_count); }
+#define PR_POLICER_ID(plcr_id)		{printk(KERN_INFO "OK. policer ID: %d\n", plcr_id); }
+#define PR_RESULT_OK	{printk(KERN_INFO "OK.\n"); }
+#endif
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct string_enum_pair_t {
+	int  value;          /* enum value */
+	char *str;           /* enum string */
+};
+
+struct string_enum_pair_db_t {
+	struct string_enum_pair_t *string_enum_pair;
+	int                num_entries;
+};
+
+
+/* Common DB structure for entries */
+struct tpm_generic_rule_db_t {
+	int  max_num_entries;
+	int  num_entries;
+	int  size_entry;
+	void *entryAra;
+};
+
+
+/* Frwd packet entry and DB API */
+struct tpmcfg_frwd_entry_t {
+	char                     name[DB_TPMCFG_MAX_NAME+1];
+	struct tpm_pkt_dest_t    frwd[TPM_ACT_NUM_MAX];
+};
+/* CnM field op entry and DB API */
+struct tpmcfg_cnm_field_op_entry_t {
+	char                     name[DB_TPMCFG_MAX_NAME+1];
+	struct tpm_cnm_field_op_t    field_op[TPM_CNM_FIELD_MAX];
+};
+
+
+/* QOS entry and DB API */
+struct tpmcfg_qos_entry_t {
+	char                name[DB_TPMCFG_MAX_NAME+1];
+	unsigned int        tbl_type;
+	unsigned int        tbl_id;
+};
+
+/* Modification sysfs structure */
+struct tpmcfg_mod_entry_t {
+	char                  name[DB_TPMCFG_MAX_NAME+1];
+	struct tpm_pkt_mod_t  mod[TPM_ACT_NUM_MAX];
+	unsigned int          flags[TPM_ACT_NUM_MAX];
+};
+
+/* L2 ACL entry and DB API */
+struct tpmcfg_pkt_key_entry_t {
+	char                   name[DB_TPMCFG_MAX_NAME+1];
+	struct tpm_pkt_key_t     key;
+	struct tpm_vlan_mod_t    vlan_mod_key;
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+struct tpmcfg_cnm_field_op_entry_t *find_tpm_cnm_field_op_entry_by_name(char *name);
+void init_tpm_cnm_field_op_db(void);
+struct tpmcfg_cnm_field_op_entry_t *find_free_tpm_cnm_field_op_entry(void);
+struct tpmcfg_mod_entry_t  *find_tpm_mod_entry_by_name(char *name);
+struct tpmcfg_mod_entry_t  *find_free_tpm_mod_entry(void);
+bool del_tpm_mod_entry_by_name(char *name);
+void show_tpm_mod_db(void);
+struct tpmcfg_frwd_entry_t *find_tpm_pkt_frwd_entry_by_name(char *name);
+struct tpmcfg_frwd_entry_t *find_free_tpm_pkt_frwd_entry(void);
+struct tpmcfg_qos_entry_t *find_tpm_pkt_qos_entry_by_name(char *name);
+struct tpmcfg_qos_entry_t *find_free_tpm_pkt_qos_entry(void);
+bool del_tpm_pkt_frwd_entry_by_name(char *name);
+void show_tpm_pkt_frwd_db(void);
+bool get_srcport_value(char *str, unsigned int *value);
+bool get_srcdir_value(char *str, unsigned int *value);
+bool get_phase_value(char *str, unsigned int *value);
+bool get_bool_value(char *str, unsigned int *value);
+bool get_igmp_mode_value(char *str, unsigned int *value);
+bool get_igmp_srcport_value(char *str, unsigned int *value);
+bool get_lx_ipvy_value(char *str, unsigned int *value);
+bool get_direction_value(char *str, unsigned int *value);
+bool get_scheduling_mode_value(char *str, unsigned int *value);
+bool get_sched_entity_value(char *str, unsigned int *value);
+bool get_vlan_op_value(char *str, unsigned int *value);
+char *get_tpm_err_str(int value);
+bool parse_ipv4_address(char *buf, uint32_t *ipv4addr_parts);
+bool parse_ipv6_address(char *buf, uint32_t *ipv6addr_parts);
+bool parse_mac_address(char *buf, uint32_t *macaddr_parts);
+int  count_parameters(const char *buf);
+void print_horizontal_line(unsigned int char_count, char *char_val);
+void tpm_sfs_print_ipv6_pref_suff(unsigned char	ipv6[8]);
+void print_help_buffer(char *helpbuf, int len);
+void parm_error_completion(int numparms, int reqdparms, const char *buf, int (*help_text_routine)(char *));
+void tpm_sysfs_rule_db_init(void);
+
+
+struct tpmcfg_pkt_key_entry_t *find_tpm_pkt_key_entry_by_name(char *name);
+struct tpmcfg_pkt_key_entry_t *find_free_tpm_pkt_key_entry(void);
+bool del_tpm_lpkt_key_entry_by_name(char *name);
+void show_tpm_pkt_key_db(void);
+void init_tpm_pkt_key_db(void);
+void init_tpm_pkt_frwd_db(void);
+
+char *tpm_utils_port_type_str_get(int value);
+char *tpm_utils_l4_type_str_get(int value);
+char *tpm_utils_qos_action_str_get(int value);
+char *tpm_utils_common_action_str_get(int value);
+char *tpm_utils_flow_id_action_str_get(int value);
+char *tpm_utils_frwd_action_str_get(int value);
+char *tpm_utils_scan_mode_str_get(int value);
+char *tpm_utils_flow_id_str_get(int value);
+char *tpm_utils_eng_no_str_get(int value);
+char *tpm_utils_cap_type_str_get(int value);
+char *tpm_utils_vlan_num_str_get(int value);
+char *tpm_utils_valid_str_get(int value);
+char *tpm_utils_port_class_str_get(int value);
+char *tpm_utils_field_op_str_get(int value);
+char *tpm_utils_qos_type_str_get(int value);
+char *tpm_utils_pp_port_str_get(int value);
+char *tpm_utils_gmac_idx_str_get(int value);
+char *tpm_utils_color_str_get(int value);
+char *tpm_utils_field_match_str_get(int value);
+char *tpm_utils_field_id_str_get(int value);
+char *tpm_utils_vlan_op_str_get(int value);
+char *tpm_utils_mc_frwd_str_get(int value);
+char *tpm_utils_gmac_enum_str_get(int value);
+
+int tpm_sfs_api_rule_date_dump(struct tpm_db_mng_api_data_t *api_data);
+int tpm_sfs_help_parse_rule_bm_print(char *buf, int cur_off);
+
+#endif  /* _TPM_SYSFS_UTILS_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_types.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_types.h
new file mode 100644
index 0000000..a1a3853
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_types.h
@@ -0,0 +1,561 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_TYPES_H_
+#define _TPM_TYPES_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_CFI_UPDATE		(0x10)		/* Update original CFI */
+#define TPM_CFI_KEEP		(0x00)		/* Keep original CFI */
+#define TPM_PBIT_UPDATE		(0x10)		/* Update the PBIT */
+#define TPM_PBIT_KEEP		(0x00)		/* Keep original PBIT */
+#define TPM_VID_UPDATE		(0x1000)	/* Update the VID */
+#define TPM_VID_KEEP		(0x0000)	/* Keep original VID */
+#define TPM_TPID_UPDATE		(0x00010000)	/* Update the TPID */
+#define TPM_TPID_KEEP		(0x00000000)	/* Keep original TPID */
+#define TPM_TRG_PORT_MAX	(6)		/* The max number of target port */
+#define TPM_POLICER_INVALID	(0xff)
+#define TPM_CNM_FIELD_MAX	(6)		/* The max number of fields in CnM rule */
+#define TPM_RULE_ID_INVALID	(0)
+
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+enum tpm_error_code_t {
+	TPM_OK		= 0,		/* Operation succeeded                   */
+	TPM_FAIL,			/* Operation failed                      */
+	TPM_BAD_VALUE,		/* Illegal value (general)               */
+	TPM_OUT_OF_RANGE,		/* The value is out of range             */
+	TPM_BAD_PARAM,		/* Illegal parameter in function called  */
+	TPM_BAD_PTR,		/* Illegal pointer value                 */
+	TPM_BAD_SIZE,		/* Illegal size                          */
+	TPM_BAD_STATE,		/* Illegal state of state machine        */
+	TPM_SET_ERROR,		/* Set operation failed                  */
+	TPM_GET_ERROR,		/* Get operation failed                  */
+	TPM_CREATE_ERROR,		/* Fail while creating an item           */
+	TPM_NOT_FOUND,		/* Item not found                        */
+	TPM_NO_MORE,		/* No more items found                   */
+	TPM_NO_SUCH,		/* No such item                          */
+	TPM_TIMEOUT,		/* Time Out                              */
+	TPM_NO_CHANGE,		/* Parameter(s) is already in this value */
+	TPM_NOT_SUPPORTED,		/* This request is not support           */
+	TPM_NOT_IMPLEMENTED,		/* Request supported but not implemented */
+	TPM_NOT_INITIALIZED,		/* The item is not initialized           */
+	TPM_NO_RESOURCE,		/* Resource not available (memory ...)   */
+	TPM_FULL,		/* Item is full (Queue or table etc...)  */
+	TPM_EMPTY,		/* Item is empty (Queue or table etc...) */
+	TPM_INIT_ERROR,		/* Error occured while INIT process      */
+	TPM_HW_ERROR,		/* Hardware error                        */
+	TPM_TX_ERROR,		/* Transmit operation not succeeded      */
+	TPM_RX_ERROR,		/* Recieve operation not succeeded       */
+	TPM_NOT_READY,			/* The other side is not ready yet       */
+	TPM_ALREADY_EXIST,		/* Tried to create existing item         */
+	TPM_OUT_OF_CPU_MEM,		/* Cpu memory allocation failed.         */
+	TPM_NOT_STARTED,		/* Not started yet                       */
+	TPM_BUSY,		/* Item is busy.                         */
+	TPM_TERMINATE,		/* Item terminates it's work.            */
+	TPM_NOT_ALLOWED,		/* Operation NOT allowed                 */
+	TPM_CONTINUE,	/* Continue                              */
+	TPM_RETRY,			/* Operation failed need retry           */
+};
+
+enum tpm_gmacs_enum_t {
+	TPM_INVALID_GMAC = -1,
+	TPM_ENUM_GMAC_0,
+	TPM_ENUM_GMAC_1,
+	TPM_ENUM_GMAC_LPK,
+	TPM_ENUM_PMAC = 7,
+	TPM_MAX_GMAC = TPM_ENUM_PMAC,
+	TPM_MAX_NUM_GMACS
+};
+
+/* MIB reset level */
+enum tpm_reset_level_enum_t {
+	TPM_ENUM_RESET_LEVEL_HIGH,	/* Reset all TPM configuration and reset TPM to none started state	*/
+	TPM_ENUM_RESET_LEVEL_MEDIUM,	/* Reset all TPM configuration including parser config			*/
+	TPM_ENUM_RESET_LEVEL_LOW,	/* Reset TPM configuration except parser config				*/
+	TPM_ENUM_MAX_RESET_LEVEL = TPM_ENUM_RESET_LEVEL_LOW
+};
+
+enum tpm_field_match_t {
+	/* L2 */
+	TPM_MATCH_ETH_DST           = 0x000001,	/* Match Ethernet Destination Address */
+	TPM_MATCH_ETH_SRC           = 0x000002,	/* Match Ethernet Source Address */
+	TPM_MATCH_VID_OUTER         = 0x000004,	/* Match Outer VID */
+	TPM_MATCH_PBITS_OUTER       = 0x000008,	/* Match Outer Pbits */
+	TPM_MATCH_VID_INNER         = 0x000010,	/* Match Inner VID */
+	TPM_MATCH_PBITS_INNER       = 0x000020,	/* Match Inner Pbits */
+	TPM_MATCH_ETH_TYPE          = 0x000040,	/* Match Ethertype */
+
+	/* PPPoE */
+	TPM_MATCH_PPPOE_PROTO       = 0x000080,	/* Match PPPoE Protocol */
+	TPM_MATCH_PPPOE_SES         = 0x000100,	/* Match PPPoE SessionId */
+
+	/* IPV4/V6 */
+	TPM_MATCH_IPV4_PKT          = 0x000200,	/* Match IPv4 Packet, used together with other TPM_MATCH_IP_XX */
+	TPM_MATCH_IPV6_PKT          = 0x000400,	/* Match IPv6 Packet, used together with other TPM_MATCH_IP_XX */
+	TPM_MATCH_IP_SRC            = 0x000800,	/* Match IPV4/6 Source Address */
+	TPM_MATCH_IP_DST            = 0x001000,	/* Match IPV4/6 Destination Address */
+	TPM_MATCH_IP_DSCP           = 0x002000,	/* Match DSCP */
+	TPM_MATCH_IPV6_FLBL         = 0x004000,	/* Match IPV6 Flow Label */
+	TPM_MATCH_IP_PROTO          = 0x008000,	/* Match IPv4_Proto/IPv6_NH field */
+	TPM_MATCH_IP_VERSION        = 0x010000,	/* Match IP version field */
+	TPM_MATCH_L4_SRC            = 0x020000,	/* Match L4 Source Port (UDP or TCP) */
+	TPM_MATCH_L4_DST            = 0x040000,	/* Match L4 Destination Port (UDP or TCP) */
+	TPM_MATCH_IPV6_PREF         = 0x080000,	/* Match IPV6 address prefix */
+	TPM_MATCH_IPV6_SUFF         = 0x100000,	/* Match IPV6 address profix */
+	TPM_MATCH_ARP_TRGT_IP_ADDR  = 0x200000,	/* Match ARP TARGET IP ADDR */
+#if 0
+	TPM_MATCH_IP_TUN_IP_SRC     = 0x200000,	/* Match IP Tunnel Source Address */
+	TPM_MATCH_IP_TUN_IP_DST     = 0x400000,	/* Match IP Tunnel Destination Address */
+	TPM_MATCH_IP_TUN_IP_PROTO   = 0x800000	/* Tunneled protocol */
+#endif
+};
+
+#define TPM_MATCH_FIELD_ALL	(TPM_MATCH_ETH_DST|TPM_MATCH_ETH_SRC|TPM_MATCH_VID_OUTER \
+				|TPM_MATCH_PBITS_OUTER|TPM_MATCH_VID_INNER \
+				|TPM_MATCH_PBITS_INNER|TPM_MATCH_ETH_TYPE \
+				|TPM_MATCH_PPPOE_PROTO|TPM_MATCH_PPPOE_SES \
+				|TPM_MATCH_IPV4_PKT|TPM_MATCH_IPV6_PKT|TPM_MATCH_IP_SRC \
+				|TPM_MATCH_IP_DST|TPM_MATCH_IP_DSCP \
+				|TPM_MATCH_IPV6_FLBL|TPM_MATCH_IP_PROTO|TPM_MATCH_IP_VERSION\
+				|TPM_MATCH_L4_SRC|TPM_MATCH_L4_DST|TPM_MATCH_IPV6_PREF\
+				|TPM_MATCH_IPV6_SUFF|TPM_MATCH_ARP_TRGT_IP_ADDR) /* All TPM fields*/
+
+enum tpm_color_t {
+	TPM_COL_GREEN       = 0x00,	/* Treat as green for Classifier */
+	TPM_COL_YELLOW      = 0x01	/* Treat as yellow for Classifier */
+};
+
+
+enum tpm_packet_mod_t {
+/* L2 */
+	TPM_ETH_DST_SET     = 0x00001,	/* Modify ETH DST */
+	TPM_ETH_SRC_SET     = 0x00002,	/* Modify ETH SRC */
+	TPM_VLAN_MOD        = 0x00004,	/* Modify VLAN Tag(s) */
+	TPM_ETH_TYPE_SET    = 0x00008,	/* Modify Ethertype */
+/* Note: MH_SET not to be implemented, unless proven necessary. */
+
+	/* PPPoE */
+	TPM_PPOE_ADD        = 0x00010,	/* Add PPPoE encapsulation */
+	TPM_PPOE_DEL        = 0x00020,	/* Delete PPPoE encapsulation */
+
+/* IPV4/V6 */
+	TPM_IP_DSCP_SET     = 0x00100,	/* Set the DSCP value */
+	TPM_TTL_HOPL_DEC    = 0x00200,	/* Decrease the TTL/HOPL value by 1 */
+	TPM_IP_SRC_SET      = 0x00400,	/* Set the IPV4/6 Source Address */
+	TPM_IP_DST_SET      = 0x00800,	/* Set the IPV4/6 Destination Address */
+	TPM_L4_SRC_SET      = 0x01000,	/* Set the L4 Source Port (UDP or TCP) */
+	TPM_L4_DST_SET      = 0x02000	/* Set the L4 Destination Port (UDP or TCP) */
+};
+
+
+enum tpm_qos_sel_t {
+	TPM_QOS_NONE        = 0,	/* Do not use QoS Table */
+	TPM_QOS_DSCP        = 1,	/* Use DSCP to select QoS Table */
+	TPM_QOS_PBIT        = 2		/* Use Pbits to select QoS Table */
+};
+
+enum tpm_class_port_type_t {
+	TPM_CLASS_PP_PORT_BM,
+	TPM_CLASS_SWITCH_PORT_BM,
+	TPM_CLASS_VIRT_PORT
+};
+
+enum tpm_port_id_t {
+	TPM_PORTID_SPEC     = 0x1000,	/* Use specific port_id */
+	TPM_PORTID_ANY      = 0x0000	/* No specific port_id */
+};
+enum tpm_vlan_id_t {
+	TPM_ALL_VID		= 0xffff,	/* VID magic number for single/double tag */
+	TPM_NO_VID		= 0x0000,	/* VID magic number for untag */
+	TPM_SPEC_VID	= 0x1000,	/* Use specific vid */
+};
+enum tpm_vlan_oper_t {
+	TPM_VLANOP_NOOP,		/* no VLAN operation performed */
+	TPM_VLANOP_EXT_TAG_MOD,		/* modify external tag */
+	TPM_VLANOP_EXT_TAG_DEL,		/* delete external tag */
+	TPM_VLANOP_EXT_TAG_INS,		/* insert(prepend) external tag */
+	TPM_VLANOP_EXT_TAG_MOD_INS,	/* modify existing external tag and insert(prepend) new tag */
+	TPM_VLANOP_INS_2TAG,		/* insert(prepend) 2 new tags */
+	TPM_VLANOP_MOD_2TAG,		/* modify 2 tags */
+	TPM_VLANOP_SWAP_TAGS,		/* swap internal and external tags */
+	TPM_VLANOP_DEL_2TAG,		/* delete 2 existing tags */
+	TPM_VLANOP_INT_TAG_MOD,		/* modify existing internal tag */
+	TPM_VLANOP_EXT_TAG_DEL_INT_MOD,	/* delete existing external tag and modify internal tag */
+	TPM_VLANOP_SPLIT_MOD_PBIT,	/* split mod stage 2, only modify p-bit */
+	TPM_VLANOP_ILLEGAL		/* illegal VLAN operation */
+};
+
+union tpm_ipvx_add {
+	unsigned char   ipv4[4];	/* IPV4 Address */
+	unsigned char   ipv6[16];	/* IPV6 Address */
+};
+
+/* Port definition
+------------------------------------------------------------------------------*/
+enum tpm_pp_port_t {
+	TPM_PP_DROP     = 0x0000,	/* Drop packet */
+	TPM_PP_GMAC0    = 0x0001,	/* Packet Processor GMAC0 */
+	TPM_PP_GMAC1    = 0x0002,	/* Packet Processor GMAC1 */
+	TPM_PP_PMAC     = 0x0004,	/* Packet Processor PON_MAC */
+	TPM_PP_LPBK     = 0x0008,	/* Packet Processor Loopback Port */
+	TPM_PP_CPU      = 0x0010	/* CPU */
+};
+
+enum tpm_gmac_idx_t {
+	TPM_GMAC0_IDX = 0,		/* GMAC0 index         */
+	TPM_GMAC1_IDX,			/* GMAC1 index         */
+	TPM_LPK_MAC_IDX,		/* Loopback port index */
+	TPM_PMAC_IDX,			/* PMAC index          */
+	TPM_MAC_MAX_IDX = TPM_PMAC_IDX
+};
+
+/* Capability definition
+------------------------------------------------------------------------------*/
+enum tpm_vlan_num_enum_t {
+	TPM_NO_VLAN,
+	TPM_SINGLE_VLAN,
+	TPM_DOUBLE_VLAN,
+	TPM_TRIPLE_VLAN,
+	TPM_NOT_DOUBLE_VLAN,			/* untag or single tag */
+	TPM_ANY_VLAN,				/* vlan number is not relevant */
+};
+
+enum tpm_cap_type_t {
+	TPM_CAP_TYPE_EXACT_EXCEPT,		/* exact match type capability		*/
+	TPM_CAP_TYPE_CLS,			/* classification type capability	*/
+	TPM_CAP_TYPE_MAX = TPM_CAP_TYPE_CLS	/* maximum type				*/
+};
+
+enum tpm_bad_chksum_action_t {
+	TPM_BAD_CHKSUM_NO_DROP,		/* do not drop bad L3/4 checksum packet */
+	TPM_BAD_CHKSUM_DROP,		/* not drop bad L3/4 checksum packet */
+};
+
+/* Multicast definition
+------------------------------------------------------------------------------*/
+enum tpm_traffic_handler_t {
+	TPM_HANDLER_GEN_CLAS,		/* general classification	*/
+	TPM_HANDLER_EXACT_MATCH,	/* exact match			*/
+	TPM_HANDLER_MC			/* multicast			*/
+};
+
+enum tpm_mc_traffic_layer_t {
+	TPM_MC_TRAFFIC_L2,		/* Multicast L2	               */
+	TPM_MC_TRAFFIC_L3,		/* Multicast L3	               */
+	TPM_MC_LAYER_MAX
+};
+
+enum tpm_mc_flow_def_action_t {
+	TPM_MC_FLOW_DEFAULT_DROP,	/* drop packets by default	*/
+	TPM_MC_FLOW_DEFAULT_CPU		/* filter to CPU by default	*/
+};
+
+enum tpm_mc_switch_handler_t {
+	TPM_MC_SW_CFG_FALSE,		/* MC API does not set ATU and VTU */
+	TPM_MC_SW_CFG_TRUE		/* MC API set ATU and VTU       */
+};
+
+/* MISC definition
+------------------------------------------------------------------------------*/
+enum tpm_ipv6_support_t {
+	TPM_IPV6_NOT_SUPPORTED = 0,	/* does not support IPv6	*/
+	TPM_IPV6_SUPPORTED		/* support IPv6			*/
+};
+
+enum tpm_ttl_illegal_action_t {
+	TPM_TTL_ZERO_ACTION_NOT_CARE = 0,	/* does not care zero TTL		*/
+	TPM_TTL_ZERO_ACTION_DROP,		/* drop packets w/ zero TTL		*/
+	TPM_TTL_ZERO_ACTION_TO_CPU		/* filter packets w/ zero TTL to CPU	*/
+};
+
+enum tpm_tcp_flag_check_t {
+	TPM_TCP_FLAG_NOT_CHECK = 0,	/* does not check TCP flag	*/
+	TPM_TCP_FLAG_CHECK		/* check TCP flag		*/
+};
+
+enum tpm_qos_tbl_owner_t {
+	TPM_QOS_TABLE_DISABLED = 0,	/* does not use QoS table		*/
+	TPM_QOS_TABLE_OWNER_TPM,	/* QoS table is used by TPM		*/
+	TPM_QOS_TABLE_OWNER_USER	/* QoS table is used by customer	*/
+};
+
+enum tpm_init_param_mode_t {
+	TPM_INIT_PARAM_PRE_START = 0,	/* TPM init param before TPM starts	*/
+	TPM_INIT_PARAM_POST_START,	/* TPM init param after TPM starts	*/
+	TPM_INIT_PARAM_AUTO,		/* automatically select init db		*/
+};
+
+enum tpm_init_cnm_mode_t {
+	TPM_CNM_NOT_SUPPORTED = 0,	/* does not support CTC CnM		*/
+	TPM_CNM_SUPPORTED		/* support CTC CnM			*/
+};
+
+/* policer definition
+------------------------------------------------------------------------------*/
+enum tpm_plcr_token_unit_t {
+	TPM_PLCR_TOKEN_UNIT_BYTES = 0,	/* token unit is based on packet's bytes	*/
+	TPM_PLCR_TOKEN_UNIT_PACKETS	/* token unit is based on packet's number	*/
+};
+
+enum tpm_plcr_color_mode_t {
+	TPM_PLCR_BLIND_COLOR_MODE = 0,	/* blind color mode	*/
+	TPM_PLCR_AWARE_COLOR_MODE	/* aware color mode	*/
+};
+
+/* TPM Egress Rate Limit definition
+------------------------------------------------------------------------------*/
+/* Tx Scheduling mode on queue */
+enum tpm_egr_sched_mode_t {
+	TPM_SCHED_MODE_STRICT,
+	TPM_SCHED_MODE_WRR,
+};
+
+enum tpm_filter_frwd_mode_t {
+	TPM_FILTER_FRWD_DROP,
+	TPM_FILTER_FRWD_NO_DROP,
+};
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_pppoe_key_t {
+	unsigned short			ppp_session;	/* PPPoE session */
+	unsigned short			ppp_proto;	/* PPPoE Protocol */
+};
+
+/* VLAN modification commands */
+
+#if 0
+struct tpm_ip_tun {
+	unsigned int    ip_tun;		/* 6=DS-LITE, other_values not valid */
+	union ipvx_add  ip_src;		/* Source Tunnel IP address */
+	union ipvx_add  ip_dst;		/* Dest. Tunnel IP address */
+};
+#endif /*AVANTA_LP_A0*/
+
+struct tpm_addn_qual_t {
+	unsigned int			addn_qual_bm;	/* BM of additional qualifiers to handle (N-T) to match flow.
+							   Refer to enum tpm_field_match_t for values*/
+	unsigned short			ether_type;	/* ether_type: 0x0800(IPv4oE),0x86DD(IPv6oE),or 0x8864(PPPoE) */
+	unsigned short			ppp_proto;	/* ppp_proto values: 0x21(IPv4oPPPoE), 0x57(IPv6oPPPoE)*/
+#if 0
+	unsigned char           eth_dst[6];	/* Ethernet Destination Address */
+	unsigned char           eth_src[6];	/* Ethernet Source Address */
+	unsigned short          out_vid;	/* Outer VID, 0xffff->untagged */
+	unsigned char           out_pbit;	/* Outer pbits */
+	unsigned short          inn_vid;	/* Inner VID 0xffff->single tagged */
+	unsigned short          pppoe_ses;	/* 0xffff->no pppoe */
+	unsigned char           dscp;
+	struct tpm_ip_tun       ip_tun;		/* IPV6 Tunnel */
+#endif /*AVANTA_LP_A0*/
+};
+
+
+struct tpm_5t_t {
+	unsigned short			ip_ver;		/* IP version (4,6) */
+	unsigned short			l4_proto;	/* L4 protocol type, udp/tcp */
+	unsigned short			l4_src;		/* Source Port */
+	unsigned short			l4_dst;		/* Destination Port */
+	union tpm_ipvx_add		ip_src;		/* Source IP address */
+	union tpm_ipvx_add		ip_dst;		/* Destination IP address */
+};
+
+struct tpm_class_port_t {
+	enum tpm_class_port_type_t	port_type;
+	unsigned int			class_port;
+};
+
+struct tpm_exact_match_t {
+	struct tpm_class_port_t		port;
+	struct tpm_5t_t			ipvx_five_t;	/* IPV4 or IPV6 five-tuple */
+	struct tpm_addn_qual_t		*addn_qual;	/* Additional qualifiers (N-tuple) */
+};
+
+struct tpm_pkt_dest_t {
+	enum tpm_pp_port_t		pp_port;	/* Drop or cpu or packet processor port */
+	unsigned char			pon_tx;		/* T-cont (gpon) */
+	unsigned char			pp_queue;	/* Cpu rx_queue/pp_port tx_queue/t_cont|llid tx_queue (PON) */
+	unsigned short			port_id;	/* Internal SW port (0-7)/gemportid(GPON)(0-4095)/llid(EPON).
+							   To specify a port, set port_id param to PORTID_SPEC|value */
+};
+
+struct tpm_vlan_mod_t {
+	unsigned int			tpid;		/* Set TPID_UPDATE to update the TPID */
+	unsigned short			vid;		/* Set VID_UPDATE to update the vid */
+	unsigned char			cfi;		/* Set CFI_UPDATE to update the cfi */
+	unsigned char			pbit;		/* Set PBIT_UPDATE to update the pbits */
+};
+
+struct tpm_vlan_op_t {
+	enum tpm_vlan_oper_t		oper;		/* Vlan operation/modification command */
+	struct tpm_vlan_mod_t		out_vlan;	/* Structure for outer VLAN key */
+	struct tpm_vlan_mod_t		inn_vlan;	/* Structure for inner VLAN key */
+};
+
+struct tpm_ipvx_mod_t {
+	union tpm_ipvx_add		ip_src;		/*IPV4/IPV6  source address for packet modification */
+	union tpm_ipvx_add		ip_dst;		/*IPV4/IPV6  dest address for packet modification */
+	unsigned short			l4_src;		/*TCP/UDP  source port for packet modification */
+	unsigned short			l4_dst;		/*TCP/UDP  dest port for packet modification */
+	unsigned char			dscp;		/*dscp value for packet modification */
+};
+
+struct tpm_pkt_mod_t {
+	unsigned int			mod_bm;		/* Bitmap of modification fields, refer enum tpm_packet_mod_t */
+	unsigned char			eth_dst[6];	/* Ethernet source address for packet modification */
+	unsigned char			eth_src[6];	/* Ethernet dest address for packet modification */
+	struct tpm_vlan_op_t		vlan_op;	/* Vlan Operation and data for packet modification */
+	struct tpm_pppoe_key_t		pppoe_mod;	/* PPPoe data for inserting PPPoE tunnel */
+	struct tpm_ipvx_mod_t		ipvx;		/* IPV4/IPV6 and TCP/UDP data for packet modification */
+};
+
+struct tpm_pkt_action_t {
+	struct tpm_pkt_dest_t		dest;		/* Packet Destination Data */
+	enum tpm_color_t		color;		/* Packet color for policer and tx_queue thresholds */
+	struct tpm_pkt_mod_t		mod;		/* Packet Modification Data */
+};
+
+struct tpm_eth_add_key_t {
+	unsigned char			eth_add[6];	/* Ethernet Address */
+	unsigned char			eth_add_mask[6];/* Ethernet Address Mask*/
+};
+
+struct tpm_ipvx_add_key_t {
+	union tpm_ipvx_add		ip_add;		/* IPV4/IPV6 Address */
+	union tpm_ipvx_add		ip_add_mask;	/* IPV4/IPV6 Address Mask*/
+};
+
+struct tpm_ipvx_key_t {
+	unsigned short			ip_ver;		/* IP version (4,6) */
+	struct tpm_ipvx_add_key_t	ip_src;		/* Maskable IPV4/IPV6 source address */
+	struct tpm_ipvx_add_key_t	ip_dst;		/* Maskable IPV4/IPV6 dest address */
+	unsigned char			dscp;		/* IPV4/IPV6 dscp */
+	unsigned char			dscp_mask;	/* IPV4/IPV6 dscp mask*/
+	unsigned char			ip_proto;	/* IP protocol */
+	unsigned int			flow_label;	/* ipv6 only */
+	unsigned int			flow_label_mask;/* ipv6 only */
+};
+
+struct tpm_pkt_key_t {
+	struct tpm_class_port_t		port;
+	unsigned int			rule_type;	/* rules with smaller value has higher priority being matched*/
+							/* should be set together with cap/filter during TPM INIT */
+	unsigned int			field_match_bm;	/* Bitmap of packet fields to match. Refer tpm_field_match_t. */
+	struct tpm_eth_add_key_t	eth_dst;	/* Ethernet Destination address & mask */
+	struct tpm_eth_add_key_t	eth_src;	/* Ethernet Destination address & mask */
+	unsigned short			out_vid;	/* Outer Tag VID, 0x0000->untagged, 0xffff->tagged */
+							/* 0x1ABC->specific Outer VID=ABC */
+	unsigned char			out_pbit;	/* Outer Tag pbits */
+	unsigned short			inn_vid;	/* Inner VID,0x0000->not double-tagged,0xffff-> double-tagged */
+							/* 0x1ABC->specific Inner VID=ABC */
+	unsigned char			inn_pbit;	/* Inner Tag pbits */
+	unsigned short			ether_type;	/* Ethertype (after Vlan Tags)*/
+	struct tpm_pppoe_key_t		ppp_info;	/* PPPoE key (proto, ppp_session) */
+#if 0
+	struct tpm_ip_tun			ip_tun;		/* In A0, IPV6 Tunnel */
+#endif
+	struct tpm_ipvx_key_t		ipvx_add;	/*IPV4/IPV6 packet key */
+	struct tpm_ipvx_add_key_t	arp_ip_dst;	/* ARP IPV4 dest address */
+	unsigned short			l4_src;		/*UDP/TCP source port */
+	unsigned short			l4_dst;		/*UDP/TCP dest port */
+};
+
+struct tpm_qos_t {
+	enum tpm_qos_sel_t		qos_sel;	/* dscp or pbits */
+	unsigned char			qos_tbl;	/* For dscp tables(0-7), for pbits tables(0-63) */
+};
+
+
+struct tpm_qos_tbl_act_t {
+	struct tpm_pkt_dest_t		pp_port;	/* pp_port: Not set (drop or CPU). port_id: Not set SW port.*/
+	unsigned short			dscp;		/* dscp value for packet modification */
+	unsigned short			pbit;		/* pbit value for packet modification */
+	enum tpm_color_t		color;		/* Packet color for policer: green, yellow */
+};
+
+struct tpm_capability_t {
+	unsigned int			rule_type;	/* valid from 0 to 15, each rule_type has one or more caps */
+							/* capabilities within smaller rule_type get higher priority */
+							/* for example: */
+							/* rule_type 0 for all trap_to_cpu rules */
+							/* rule_type 1 for all L2 HWF rules */
+	unsigned int			field_match_bm;	/* capability field bitmap	*/
+	enum tpm_vlan_num_enum_t	tag_num;	/* allowed number of vlan_tags */
+	unsigned char			precedence;	/* priority of this capabilty within rule_type */
+	unsigned char			max_port_hits;	/* max port hit number */
+};
+
+struct tpm_port_mc_proto_handler_t {
+	enum tpm_pp_port_t		port;		/* PP port number		*/
+	enum tpm_traffic_handler_t	mc_proto_handler;/* multicast protocol handler	*/
+};
+
+/* TPID definition
+------------------------------------------------------------------------------*/
+struct tpm_tpid_combo_t {
+	bool				valid;		/* whether tpid combo is valid	*/
+	unsigned short			tpid1;		/* first tpid			*/
+	unsigned short			tpid2;		/* second tpid			*/
+};
+
+struct tpm_policer_entry_t {
+	enum tpm_plcr_token_unit_t	token_unit;	/* token in unit of bytes of packet number		*/
+	enum tpm_plcr_color_mode_t	color_mode;	/* color mode, blind or aware of former color		*/
+	unsigned int			cir;		/* commit information rate in unit of kbps or pps	*/
+	unsigned int			cbs;		/* commit burst size in unit of bytes or packet number	*/
+	unsigned int			ebs;		/* excess burst size in unit of bytes or packet number	*/
+};
+
+enum tpm_cnm_op_t {
+	TPM_CNM_OP_EQUAL = 2,	/* equal to */
+	TPM_CNM_OP_NOT_EQUAL,	/* not equal to */
+	TPM_CNM_OP_LESS_EQUAL,	/* less than or equal to */
+	TPM_CNM_OP_GREATER_EQUAL,		/* greater than or equal to */
+	TPM_CNM_OP_MAX = TPM_CNM_OP_GREATER_EQUAL,/* MAX OP number */
+};
+
+struct tpm_cnm_field_op_t {
+	enum tpm_cnm_op_t	op;
+	enum tpm_field_match_t	field;	/* field ID*/
+};
+
+struct tpm_cnm_key_t {
+	unsigned int			rule_num;	/* valid from 0 to 7 */
+	unsigned int			field_num;	/* item number in field_op struct */
+	struct tpm_cnm_field_op_t	field_op[TPM_CNM_FIELD_MAX];
+	struct tpm_pkt_key_t		match_key;
+};
+
+#endif /* _TPM_TYPES_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_utils.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_utils.h
new file mode 100644
index 0000000..ed90523
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/inc/tpm_utils.h
@@ -0,0 +1,79 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_utils.h						     **
+**									     **
+**  DESCRIPTION : This file contains api protypes and macro of tpm_utils.c   **
+**  DEPENDCY :			                                             **
+******************************************************************************/
+
+/***********************/
+/* h file declarations */
+/***********************/
+#ifndef _TPM_UTILS_H_
+#define _TPM_UTILS_H_
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+#define TPM_MEMBER_NUM(array)	(sizeof(array)/sizeof(array[0]))
+#define TPM_IS_MULTICAST_MAC(mac)	(((mac)[0] == 0x01) || (((mac)[0] == 0x33) && ((mac)[1] == 0x33)))
+#define TPM_IS_BROADCAST_MAC(mac)	(((mac)[0] == 0xFF) && ((mac)[1] == 0xFF) && \
+					((mac)[2] == 0xFF) && ((mac)[3] == 0xFF) && \
+					((mac)[4] == 0xFF) && ((mac)[5] == 0xFF))
+#define TPM_MAX_VALUE_BY_BITS(bits)	((1 << bits) - 1)
+/******************************************************************************/
+/*                              ENUMERATIONS                                  */
+/******************************************************************************/
+
+
+/******************************************************************************/
+/*                               STRUCTURES                                   */
+/******************************************************************************/
+struct tpm_enum_str_t {
+	int enum_value;	/* the value of enum		*/
+	char *enum_str;	/* the string name of enum	*/
+};
+
+struct tpm_enum_array_t {
+	int enum_num;				/* total enum number	*/
+	struct tpm_enum_str_t *enum_array;	/* enum array		*/
+};
+
+/******************************************************************************/
+/*                                PROTOTYPE                                   */
+/******************************************************************************/
+void print_help_buffer(char *helpbuf, int len);
+void parm_error_completion(int numparms, int reqdparms, const char *buf, int (*help_text_routine)(char *));
+int count_parameters(const char *buf);
+char *lookup_enum_str(struct tpm_enum_str_t enum_str[], int enum_num, int enum_value);
+unsigned int common_mask_gen(int bit_num);
+unsigned int int_bitmap_num_get(unsigned int bitmap);
+int int_array_high_bits_set(unsigned int *array, unsigned int array_len, unsigned int high_bit_num);
+
+#endif /* _TPM_UTILS_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_api.c
new file mode 100644
index 0000000..1b90512
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_api.c
@@ -0,0 +1,1293 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_api.c						     **
+**									     **
+**  DESCRIPTION : This file contains APIs supplied to customers              **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_add()
+*
+* DESCRIPTION: API performs exact match classification to all packets it should process, as
+*              defined in the Init configuration. (Typically all the Routed Unicast packets).
+*              At a minimum packets are matched with their Ethertype (and ppp_proto), and 5-tuple.
+*              There is no partial field classification.
+*              Additional classification fields will be added in AVANTA-LP-Ao.
+*              Packets forwarded to CPU cannot be modified.
+*
+* INPUTS:
+*	exact_match - Contains Match parameters to perform exact match.
+*			5_tuple + IP_version are mandatory, others are optional.
+*	action      - Contains parameters to classify the packet:
+*			Packet destination, modification and packet color for policer and tx_queue thresholds.
+*	policer_id  - Reference to previously created policer (0-15), 0xffff-> no policer
+*
+* OUTPUTS:
+*	rule_id     - Unique handle to this rule. Should be used for deleting the rule.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_add(struct tpm_exact_match_t	*exact_match,
+				unsigned short			num_pp_trgt,
+				struct tpm_pkt_action_t		action[],
+				unsigned char			policer_id,
+				unsigned int			*rule_id)
+{
+	int rc = TPM_OK;
+	struct tpm_mng_pkt_key_t	mng_match_key;
+	struct tpm_qos_t		qos;
+	struct tpm_pkt_key_t		pkt_key;
+
+	TPM_MEMSET_ZERO(mng_match_key);
+	TPM_MEMSET_ZERO(qos);
+	TPM_MEMSET_ZERO(pkt_key);
+
+	rc = tpm_mng_5t_key_build(&pkt_key, &qos, exact_match);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to mapping Key from 5T\n");
+
+	mng_match_key.pkt_key = &pkt_key;
+
+	rc = tpm_mng_cap_entry_add(TPM_API_PRIVATE_EXCT,
+				&mng_match_key,
+				num_pp_trgt,
+				action,
+				policer_id,
+				&qos,
+				rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add exact match rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del()
+*
+* DESCRIPTION: API deletes an exact_match_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del(struct tpm_5t_t *ipvx_five_t, unsigned int rule_id)
+{
+	int rc = TPM_OK;
+	struct tpm_pkt_key_t		pkt_key;
+	struct tpm_exact_match_t	exact_match;
+	struct tpm_qos_t		qos;
+
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(exact_match);
+	TPM_MEMSET_ZERO(qos);
+
+	if (NULL != ipvx_five_t) {
+		/* build key */
+		memcpy(&exact_match.ipvx_five_t, ipvx_five_t, sizeof(exact_match.ipvx_five_t));
+		rc = tpm_mng_5t_key_build(&pkt_key, &qos, &exact_match);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to build exact match key, ret(%d)\n", rc);
+
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PRIVATE_EXCT, &pkt_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+
+	rc = tpm_mng_cap_entry_del(TPM_API_PRIVATE_EXCT, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete exact match rule by rule_id(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del_all()
+*
+* DESCRIPTION: API deletes all exact_match rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del_all(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cap_entry_del_type(TPM_API_PRIVATE_EXCT);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete all gen cls rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_cntr_get()
+*
+* DESCRIPTION: API ges an exact_match_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_cntr_get(
+	struct tpm_5t_t *ipvx_five_t,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	int rc = TPM_OK;
+	struct tpm_pkt_key_t		pkt_key;
+	struct tpm_exact_match_t	exact_match;
+	struct tpm_qos_t		qos;
+
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(exact_match);
+	TPM_MEMSET_ZERO(qos);
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	if (NULL != ipvx_five_t) {
+		/* build key */
+		memcpy(&exact_match.ipvx_five_t, ipvx_five_t, sizeof(exact_match.ipvx_five_t));
+		rc = tpm_mng_5t_key_build(&pkt_key, &qos, &exact_match);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to build exact match key, ret(%d)\n", rc);
+
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PRIVATE_EXCT, &pkt_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+
+	rc = tpm_mng_cap_entry_cntr_get(rule_id, cntr);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to get hit counter of exact match rule by rule_id(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_add()
+*
+* DESCRIPTION: API handles packets that were compared to the exact_match_rules, and created an exception in that
+*		ruleset. I.e. they passed the exact_match rule_set without hitting any rule. Rules in this API are
+*		limited to forwarding packets to CPU or dropping. Consequently, packets cannot be modified.
+*
+* INPUTS:
+*	match_key    - Contains Match parameters to perform packet match according to predefined
+*			capabilities. Initial supported capabilities are l4_ports, l4_proto, and dscp. Keys
+*			matching any of the IPv4/v6/TCP/UDP fields, must match the (TPM_MATCH_IPV4_PKT)attribute.
+*
+*	action       - Contains parameters to classify the packet: Set packet destination (only to CPU or drop),
+*			and set packet color. No packet modification.
+*	policer_id   - See previous definition.
+*	qos          - Parameter can be used in [ext_qos_tbl] mode (configured in Init). This mode implies
+*			that callers of this API can perform direct table lookup on the Packet processor
+*			qos_tables, (See also tpm_qos_table_set API) and use the qos_table_lookup as part of
+*			the main key matching process. NULL pointer implies no qos_table is used.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_add(struct tpm_pkt_key_t	*match_key,
+				       struct tpm_pkt_action_t	*action,
+				       unsigned char		policer_id,
+				       struct tpm_qos_t		*qos,
+				       unsigned int		*rule_id)
+{
+	int rc = TPM_OK;
+	struct tpm_mng_pkt_key_t mng_match_key;
+
+	mng_match_key.pkt_key = match_key;
+	rc = tpm_mng_cap_entry_add(TPM_API_PUBLIC_EXCT_EXCPT,
+				   &mng_match_key,
+				   TPM_ACT_NUM_IS_1,
+				   action,
+				   policer_id,
+				   qos,
+				   rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add exact match expection rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del()
+*
+* DESCRIPTION: API deletes an exact_match_except_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del(struct tpm_pkt_key_t	*match_key, unsigned int	rule_id)
+{
+	int rc = TPM_OK;
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_EXCT_EXCPT, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+	rc = tpm_mng_cap_entry_del(TPM_API_PUBLIC_EXCT_EXCPT, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete exact match expection rule by rule_id(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del_all()
+*
+* DESCRIPTION: API deletes all  exact_match_except rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del_all(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cap_entry_del_type(TPM_API_PUBLIC_EXCT_EXCPT);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete all exact match expection rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_cntr_get()
+*
+* DESCRIPTION: API ges an exact_match_except_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_cntr_get(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_EXCT_EXCPT, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+	rc = tpm_mng_cap_entry_cntr_get(rule_id, cntr);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to get hit counter of exact match expection rule(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_add()
+*
+* DESCRIPTION: API processes all packets that are not handled by other API's. (I.e. Typically bridged packets).The API
+*		allows to use combined field-matching keys and masks (as pre-configured during Init) .
+*
+* INPUTS:
+*	match_key    - See previous definition.
+*	action       - See previous definition. Can set all action fields.
+*	policer_id   - See previous definition.
+*	qos          - See previous definition.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_add(struct tpm_pkt_key_t	*match_key,
+			    unsigned short		num_pp_trgt,
+			    struct tpm_pkt_action_t	action[],
+			    unsigned char		policer_id,
+			    struct tpm_qos_t		*qos,
+			    unsigned int		*rule_id)
+{
+	int rc = TPM_OK;
+	struct tpm_mng_pkt_key_t mng_match_key;
+
+	mng_match_key.pkt_key = match_key;
+	rc = tpm_mng_cap_entry_add(TPM_API_PUBLIC_CLS, &mng_match_key, num_pp_trgt, action, policer_id, qos, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add gen cls rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del()
+*
+* DESCRIPTION: API deletes an gen_cls_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del(struct tpm_pkt_key_t *match_key, unsigned int rule_id)
+{
+	int rc = TPM_OK;
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_CLS, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+	rc = tpm_mng_cap_entry_del(TPM_API_PUBLIC_CLS, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete gen cls rule by rule_id(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del_all()
+*
+* DESCRIPTION: API deletes all  generic classification rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del_all(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cap_entry_del_type(TPM_API_PUBLIC_CLS);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete all gen cls rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_cntr_get()
+*
+* DESCRIPTION: API ges an gen_cls_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_cntr_get(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_CLS, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+	rc = tpm_mng_cap_entry_cntr_get(rule_id, cntr);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to hit counter of gen cls rule(%d)\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_mc_flow_add()
+*
+* DESCRIPTION: API handles Multicast packets (Snooping or Proxy Routing) according to HGU/SFU requirements.
+*              The allowed field-matches are statically preconfigured for the most.
+*              Multicast streams that do not have a mc_flow rule, and are not IGMP/MLD, will be be dropped or sent to
+*              CPU (Init configured).
+*
+* INPUTS:
+*	match_key  - See previous definition.
+*			Fields that are allowed in the field-match bitmap:
+*			port, out_vid, ether_type, pppoe_proto
+*			ip_src (must have full host_mask).
+*			ip_dst OR eth_dst (In either case, must have full host_mask)
+*
+*	num_dest   - Number of Destination Action, meaning number of packet replications.
+*	action     - See previous definition. Can set all action fields.
+*
+* OUTPUTS:
+*	rule_id    - See previous definition
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_add(struct tpm_pkt_key_t	*match_key,
+		       unsigned short		num_dest,
+		       struct tpm_pkt_action_t	action[],
+		       int			*rule_id)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, match_key);
+	IF_NULL(TPM_API_MOD, rule_id);
+
+	rc = tpm_mng_mc_flow_add(match_key,
+				 num_dest,
+				 action,
+				 rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add multicast rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del()
+*
+* DESCRIPTION: API deletes an multicast rule
+*
+* INPUTS:
+*	rule_id     - Rule to delete
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del(unsigned int	rule_id)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_mc_flow_del(rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to del multicast rule[%d]\n", rule_id);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del_all()
+*
+* DESCRIPTION: API deletes all multicast rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del_all(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_mc_flow_del_all();
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to del all multicast rule\n");
+
+	return rc;
+}
+
+
+/*******************************************************************************
+* mv_tpm_cm_rule_add()
+*
+* DESCRIPTION: API adds a CnM rule that sets target queue and optionally p-bit for bridged packets.
+*                         The API allows using combined field-matching keys that no need to be pre-configured when Init.
+*                         Each CnM rule could have up to 6 fields:
+*                         Three of them :no bigger than 2 bytes, operator could be equal, not equal, GE or LE.
+*                         one of them    : no bigger than 16 bytes, operator could be equal, not equal.
+*                         one of them    : no bigger than 6 bytes, operator could be equal, not equal.
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*			rule_num: 0 to 7.
+*			field_num: each CnM rule has up to 6 fields.
+*			field_op   : each field operator could be equal, not equal, less or equal, greater or equal.
+*			match_key: contains the field key value, and source port. Only UNI port is allowed as src port.
+*	action           - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                        in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_add(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cm_rule_add(cnm_key, action);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add CnM rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del()
+*
+* DESCRIPTION: API deletes a CnM rule.
+*
+* INPUTS:
+*	rule_num: valid from 0 to 7
+*	port	: src port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cm_rule_del(port, rule_num);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to Delete CnM rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del_all()
+*
+* DESCRIPTION: API deletes all CnM rules of certain ports.
+*
+* INPUTS:
+*	port_bm: bit map of port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del_all(unsigned int port_bm)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cm_rule_del_all(port_bm);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to Delete all CnM rules on port(%d)\n", port_bm);
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_qos_table_entry_set()
+*
+* DESCRIPTION: API directly configures the packet processor Qos Tables (part of C2 Engine).
+*              The packet processor has 64 p-bit tables and 16 dscp tables, that can be used for mapping pbit/dscp
+*              values to Qos related parameters (GMAC/T-CONT, gemport, rx/tx_queue, packet_color for policer)
+*              Values returned by the mapping table can be used as part of a generic packet classification, as
+*              written in APIs using the qos_tbl.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_entry_set(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	int rc = TPM_OK;
+	enum tpm_qos_tbl_owner_t qos_tbl_ext;
+
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_QOS_TABLE_EXT, &qos_tbl_ext);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to get QoS table extention mode\n");
+
+	if (TPM_QOS_TABLE_OWNER_USER != qos_tbl_ext) {
+		TPM_OS_ERROR(TPM_API_MOD, "Qos table could be configured only under TPM_QOS_TABLE_OWNER_USER mode\n");
+		return TPM_BAD_PARAM;
+	}
+
+	rc = tpm_qos_tbl_entry_set(qos_select, qos_tbl, entry, qos_cfg);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to configure qos table entry\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_qos_table_set()
+*
+* DESCRIPTION: API configures all entries of a qos_table with value in param.
+*
+* INPUTS:
+*	qos_select  - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl         - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	qos_cfg         - Qos table parameter configuration array.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_set(enum tpm_qos_sel_t		qos_select,
+			 unsigned char			qos_tbl,
+			 struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	int rc = TPM_OK;
+	enum tpm_qos_tbl_owner_t qos_tbl_ext;
+
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_QOS_TABLE_EXT, &qos_tbl_ext);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to get QoS table extention mode\n");
+
+	if (TPM_QOS_TABLE_OWNER_USER != qos_tbl_ext) {
+		TPM_OS_ERROR(TPM_API_MOD, "Qos table could be configured only under TPM_QOS_TABLE_OWNER_USER mode\n");
+		return TPM_BAD_PARAM;
+	}
+
+	rc = tpm_qos_tbl_set(qos_select, qos_tbl, qos_cfg);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to configure qos table\n");
+
+	return rc;
+}
+
+
+/* TBD:
+*  1. mv_tpm_bridge_learning_mac_rule_add();	// Add mac for learning
+*  2. mv_tpm_bridge_learning_vid_add();		// Add vid for bridge learning
+*  3. mv_tpm_dynamic_field_rule_add();		// CnM
+*  4. mv_tpm_filter_rule_add();			// Perform White List filtering
+*  5. mv_tpm_policer_add();			// Add policer
+*  6. mv_tpm_init.				// Init parameters
+*/
+
+/*******************************************************************************
+* mv_tpm_plcr_add()
+*
+* DESCRIPTION: This API adds a policer entry.
+*
+* INPUTS:
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	policer_id    - policer ID.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_add(struct tpm_policer_entry_t	*policer_entry,
+		    unsigned char		*policer_id)
+{
+	int rc = TPM_OK;
+
+	tpm_mng_lock();
+	rc = tpm_plcr_entry_add(policer_entry, policer_id);
+	tpm_mng_unlock();
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add policer\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_plcr_del()
+*
+* DESCRIPTION: This API deletes a policer entry.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_del(unsigned char policer_id)
+{
+	int rc = TPM_OK;
+
+	tpm_mng_lock();
+	rc = tpm_plcr_entry_del(policer_id);
+	tpm_mng_unlock();
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete policer\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_plcr_clear()
+*
+* DESCRIPTION: This API deletes all policer entries.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_clear(void)
+{
+	int rc = TPM_OK;
+
+	tpm_mng_lock();
+	rc = tpm_plcr_entry_clear();
+	tpm_mng_unlock();
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to clear policer\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_sched_egr_mtu_set()
+*
+* DESCRIPTION: This API set the egress MTU on the port.
+*
+* INPUTS:
+*          gmac_idx    - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont       - valid for GPON PMAC, other set to 0
+*          tx_size_max - MTU, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_mtu_set(enum tpm_gmac_idx_t gmac_idx,
+			     unsigned char tcont_id,
+			     unsigned int tx_size_max)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sched_egr_mtu_set(gmac_idx,
+				   tcont_id,
+				   tx_size_max);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to set sched MTU\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_mode_set()
+*
+* DESCRIPTION: This API Set the egress scheduling mode, strict or wrr.
+*
+* INPUTS:
+*          gmac_idx  - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont     - valid for GPON PMAC, other set to 0
+*          queue_id  - queue index, 0-7
+*          mode      - scheduling mode, strict priority or WRR
+*          wrr_weight- 0-255, if mode is WRR
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_mode_set(enum tpm_gmac_idx_t gmac_idx,
+				    unsigned char tcont_id,
+				    unsigned char queue_id,
+				    enum tpm_egr_sched_mode_t mode,
+				    unsigned short wrr_weight)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sched_egr_queue_mode_set(gmac_idx,
+					  tcont_id,
+					  queue_id,
+					  mode,
+					  wrr_weight);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to set queue mode\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_rate_lim_set()
+*
+* DESCRIPTION: This API set the egress rate limit on the queue.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+					unsigned char tcont_id,
+					unsigned char queue_id,
+					unsigned int rate_lim_val,
+					unsigned int bucket_size)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sched_egr_queue_rate_lim_set(gmac_idx,
+					      tcont_id,
+					      queue_id,
+					      rate_lim_val,
+					      bucket_size);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to set queue rate limit\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_sched_egr_port_rate_lim_set()
+*
+* DESCRIPTION: This API set the egress rate limit on the port.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_port_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				       unsigned char tcont_id,
+				       unsigned int rate_lim_val,
+				       unsigned int bucket_size)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sched_egr_port_rate_lim_set(gmac_idx,
+					     tcont_id,
+					     rate_lim_val,
+					     bucket_size);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to set port rate limit\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_filter_rule_add()
+*
+* DESCRIPTION: This API adds a filter rule
+*
+* INPUTS:
+*          match_key      - See previous definition.
+*          frwd	     - defines packet forward, to drop or allow.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_add(
+	struct tpm_pkt_key_t		*match_key,
+	enum tpm_filter_frwd_mode_t	frwd,
+	unsigned int			*rule_id)
+{
+	int rc = TPM_OK;
+	struct tpm_mng_pkt_key_t mng_match_key;
+	unsigned int             act_num = 1;
+	struct tpm_pkt_action_t  action;
+	unsigned short           policer_id = TPM_POLICER_INVALID;
+	struct tpm_qos_t         qos;
+
+	TPM_MEMSET_ZERO(mng_match_key);
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	if (TPM_FILTER_FRWD_DROP == frwd)
+		action.dest.pp_port = TPM_PP_DROP;
+	else
+		/* do not lock queue_high */
+		action.dest.pp_port = TPM_PP_CPU;
+
+	mng_match_key.pkt_key = match_key;
+	rc = tpm_mng_cap_entry_add(TPM_API_PUBLIC_FLTR, &mng_match_key, act_num, &action, policer_id, &qos, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add gen cls rule\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del()
+*
+* DESCRIPTION: This API deletes a filter rule
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int		rule_id)
+{
+	int rc = TPM_OK;
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_FLTR, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+	rc = tpm_mng_cap_entry_del(TPM_API_PUBLIC_FLTR, rule_id);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete filter rule by rule_id(%d)\n", rule_id);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del_all()
+*
+* DESCRIPTION: This API deletes all filter rule
+*
+* INPUTS:
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del_all(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_mng_cap_entry_del_type(TPM_API_PUBLIC_FLTR);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to delete all filter rules\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* mv_tpm_filter_rule_cntr_get()
+*
+* DESCRIPTION: API ges an filter  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_cntr_get(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	if (NULL != match_key) {
+		/* get rule_id first */
+		rc = tpm_mng_rule_id_get(TPM_API_PUBLIC_FLTR, match_key, &rule_id);
+		IF_ERROR_STR(TPM_API_MOD, rc, "fail to get rule_id, ret(%d)\n", rc);
+	}
+
+	rc = tpm_mng_cap_entry_cntr_get(rule_id, cntr);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to hit counter of filter rule(%d)\n", rule_id);
+
+	return rc;
+}
+/*******************************************************************************
+* mv_tpm_filter_def_rule_cntr_get()
+*
+* DESCRIPTION: API gets an filter default rule hit counter.
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_def_rule_cntr_get(
+	unsigned char			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*cntr)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	/* get default rule_id first */
+	rc = tpm_mng_filter_def_rule_cntr_get(rule_type, field_bm, vlan_num, cntr);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to hit counter of filter def rule\n");
+
+	return rc;
+}
+/*******************************************************************************
+* mv_tpm_mtm_add()
+*
+* DESCRIPTION: API adds a MAC to port, to make it Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be added
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_add(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, mac);
+
+	rc = tpm_mng_mtm_add(port, mac);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to add an MAC(%pM) to port(%d)\n", mac, port);
+
+	return rc;
+}
+/*******************************************************************************
+* mv_tpm_mtm_del()
+*
+* DESCRIPTION: API removes a MAC from port, to make it not Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be removed
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_del(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_API_MOD, mac);
+
+	rc = tpm_mng_mtm_del(port, mac);
+	IF_ERROR_STR(TPM_API_MOD, rc, "fail to remove an MAC(%pM) from port(%d)\n", mac, port);
+
+	return rc;
+}
+
+
+/*************************************INIT API SECTION********************************************/
+
+/*******************************************************************************
+* tpm_init_spec_ipv6nh_add
+*
+* DESCRIPTION: The API will add wanted special IPV6 NH to tpm_start_db
+*
+* INPUTS:
+*	ipv6_special_nh - IPV6 NH need special treat
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Done before tpm_start call, and can not be called in running phase.
+*******************************************************************************/
+int tpm_init_spec_ipv6nh_add(unsigned char	ipv6_special_nh)
+{
+	int rc;
+	rc = tpm_db_spec_ipv6nh_set(ipv6_special_nh, TPM_PRS_INV_TCAM_IDX, TPM_PRS_SPEC_IPV6NH_ADD);
+
+	IF_ERROR(TPM_API_MOD, rc);
+
+	return TPM_OK;
+}
+EXPORT_SYMBOL(tpm_init_spec_ipv6nh_add);
+
+/*******************************************************************************
+* tpm_init_spec_ipv6nh_del()
+*
+* DESCRIPTION: The API will delete IPV6 NH from special treat list
+*
+* INPUTS:
+*	ipv6_special_nh - IPV6 NH need special treat
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_init_spec_ipv6nh_del(unsigned char	ipv6_special_nh)
+{
+	int rc;
+	rc = tpm_db_spec_ipv6nh_set(ipv6_special_nh, TPM_PRS_INV_TCAM_IDX, TPM_PRS_SPEC_IPV6NH_DEL);
+
+	IF_ERROR(TPM_API_MOD, rc);
+
+	return TPM_OK;
+}
+EXPORT_SYMBOL(tpm_init_spec_ipv6nh_del);
+
+/*******************************************************************************
+* tpm_mib_reset()
+*
+* DESCRIPTION: Performs MIB reset
+*
+* INPUTS:
+*	reset_level - The reset level determines the which elements will not be reset in the API call
+*			0: high level, reset all TPM configuration and reset TPM to none started state
+*			1: medium level, reset all TPM configuration including parser config
+*			2: low level, reset TPM configuration except parser config
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_mib_reset(enum tpm_reset_level_enum_t	reset_level)
+{
+	int rc;
+
+	rc = tpm_module_mib_reset(reset_level);
+
+	IF_ERROR(TPM_API_MOD, rc);
+
+	return TPM_OK;
+}
+EXPORT_SYMBOL(tpm_mib_reset);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
new file mode 100644
index 0000000..43a9860
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_db.c
@@ -0,0 +1,5916 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_db.c						     **
+**									     **
+**  DESCRIPTION : This file contains routine access to tpm_db                **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <linux/sort.h>
+
+/* Global TPM database */
+static struct tpm_db_t g_tpm_db;
+
+/* Global init configuration */
+static struct tpm_init_t g_init_cfg;
+
+static struct tpm_db_param_t g_tpm_init_pre_start_param[] = {
+	/* Parameter type                  Container     */
+	{TPM_DB_PARAM_SWITCH_INIT,	   &g_init_cfg.switch_init},
+	{TPM_DB_PARAM_MC_DATA_HANDLE,	   &g_init_cfg.mc_data_handle},
+	{TPM_DB_PARAM_MC_SW_HANDLE,	   &g_init_cfg.mc_sw_handle},
+	{TPM_DB_PARAM_MAX_UNI_NUM,	   &g_init_cfg.max_num_uni_ports},
+	{TPM_DB_PARAM_IPV6_SUPPORT,	   &g_init_cfg.ipv6_support},
+	{TPM_DB_PARAM_CPU_RX_QUEUE,	   &g_init_cfg.cpu_trap_rx_queue},
+	{TPM_DB_PARAM_TTL_ILLEGAL_ACTION,  &g_init_cfg.ttl_illegal_action},
+	{TPM_DB_PARAM_BAD_CHKSUM_ACTION,   &g_init_cfg.bad_chksum_action},
+	{TPM_DB_PARAM_TCP_FLAG_CHECK,	   &g_init_cfg.tcp_flag_check},
+	{TPM_DB_PARAM_TRACE_DEBUG_FLAG,	   &g_init_cfg.trace_debug_flag},
+	{TPM_DB_PARAM_QOS_TABLE_EXT,	   &g_init_cfg.qos_tbl_ext},
+	{TPM_DB_PARAM_CNM_SUPPORT,	   &g_init_cfg.cnm_support},
+};
+static unsigned int g_tpm_init_pre_start_param_num = (sizeof(g_tpm_init_pre_start_param)/sizeof(struct tpm_db_param_t));
+
+static struct tpm_db_param_t g_tpm_init_post_start_param[] = {
+	/* Parameter type                  Container     */
+	{TPM_DB_PARAM_SWITCH_INIT,	   &g_tpm_db.init_db.switch_init},
+	{TPM_DB_PARAM_MC_DATA_HANDLE,	   &g_init_cfg.mc_data_handle},
+	{TPM_DB_PARAM_MC_SW_HANDLE,	   &g_init_cfg.mc_sw_handle},
+	{TPM_DB_PARAM_MAX_UNI_NUM,	   &g_tpm_db.init_db.max_num_uni_ports},
+	{TPM_DB_PARAM_IPV6_SUPPORT,	   &g_tpm_db.init_db.ipv6_support},
+	{TPM_DB_PARAM_CPU_RX_QUEUE,	   &g_tpm_db.init_db.cpu_trap_rx_queue},
+	{TPM_DB_PARAM_TTL_ILLEGAL_ACTION,  &g_tpm_db.init_db.ttl_illegal_action},
+	{TPM_DB_PARAM_BAD_CHKSUM_ACTION,   &g_tpm_db.init_db.bad_chksum_action},
+	{TPM_DB_PARAM_TCP_FLAG_CHECK,	   &g_tpm_db.init_db.tcp_flag_check},
+	{TPM_DB_PARAM_TRACE_DEBUG_FLAG,	   &g_tpm_db.init_db.trace_debug_flag},
+	{TPM_DB_PARAM_QOS_TABLE_EXT,	   &g_tpm_db.init_db.qos_tbl_ext},
+	{TPM_DB_PARAM_CNM_SUPPORT,	   &g_tpm_db.init_db.cnm_support},
+};
+static unsigned int g_tpm_init_post_start_param_num = sizeof(g_tpm_init_post_start_param)/sizeof(struct tpm_db_param_t);
+
+/*******************************************************************************
+* tpm_db_prs_pre_all_set
+*
+* DESCRIPTION: The API will set TPM DB with all pre config of parser
+*
+* INPUTS:
+*	prs_pre_cfg    - parser pre config, including lu_id, special NH, TPID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_prs_pre_all_set(struct tpm_db_prs_t *parser_pre_cfg)
+{
+	IF_NULL(TPM_DB_MOD, parser_pre_cfg);
+
+	memcpy(&g_tpm_db.prs_db, parser_pre_cfg, sizeof(struct tpm_db_prs_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_prs_lu_id_set
+*
+* DESCRIPTION: The API will write classifier lookup ID information to tpm db
+*
+* INPUTS:
+*	traffic_type  - Traffic Type
+*
+* OUTPUTS:
+*	lu_id_data    - lookup ID information, such as result info, lu_id
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_prs_lu_id_set(unsigned int traffic_type, struct tpm_prs_lu_id_t *lu_id_data)
+{
+	unsigned int i;
+
+	IF_NULL(TPM_DB_MOD, lu_id_data);
+
+	/* Search Traffic Type */
+	for (i = LSP_GMAC0_DEFAULT; i < TPM_TRAFFIC_TYPE_MAX; i++) {
+		if (g_tpm_db.prs_db.prs_lu_id[i].traffic_type == traffic_type) {
+			memcpy(&g_tpm_db.prs_db.prs_lu_id[i], lu_id_data, sizeof(struct tpm_prs_lu_id_t));
+			break;
+		}
+	}
+	if (TPM_TRAFFIC_TYPE_MAX == i) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid Traffic type(%d)\n", traffic_type);
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_prs_lu_id_get
+*
+* DESCRIPTION: The API will get classifier lookup ID information
+*
+* INPUTS:
+*	traffic_type  - Traffic Type
+*
+* OUTPUTS:
+*	lu_id_data    - lookup ID information, such as result info, lu_id
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_prs_lu_id_get(unsigned int traffic_type, struct tpm_prs_lu_id_t *lu_id_data)
+{
+	unsigned int i;
+
+	IF_NULL(TPM_DB_MOD, lu_id_data);
+
+	/* Clear lu_id_data */
+	memset(lu_id_data, 0, sizeof(struct tpm_prs_lu_id_t));
+	/* Search Traffic Type */
+	for (i = LSP_GMAC0_DEFAULT; i < TPM_TRAFFIC_TYPE_MAX; i++) {
+		if (g_tpm_db.prs_db.prs_lu_id[i].traffic_type == traffic_type) {
+			memcpy(lu_id_data, &g_tpm_db.prs_db.prs_lu_id[i], sizeof(struct tpm_prs_lu_id_t));
+			break;
+		}
+	}
+	if (TPM_TRAFFIC_TYPE_MAX == i) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid Traffic type(%d)\n", traffic_type);
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_spec_ipv6nh_set
+*
+* DESCRIPTION: The API will set IPV6 special NH list in TPM DB.
+*
+* INPUTS:
+*	ipv6_nh    - IPV6 NH need special treat.
+*	tid        - parser rule TCAM Index
+*	add        - indicate add NH to list or delete it from list
+*			0: delete NH from special treat list
+*			1: add NH to special treat list
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*
+*******************************************************************************/
+int tpm_db_spec_ipv6nh_set(unsigned char ipv6_nh, unsigned int tid, enum tpm_prs_ipv6_spec_nh_op_t op)
+{
+	static unsigned char ipv6_nh_array[TPM_IPV6_NH_MAX_IDX] = {TPM_IPV6_NH_HH, TPM_IPV6_NH_DH,
+								   TPM_IPV6_NH_RH, TPM_IPV6_NH_FH,
+								   TPM_IPV6_NH_EH, TPM_IPV6_NH_AH};
+	int nh_idx;
+
+	/* find NH index */
+	for (nh_idx = TPM_IPV6_NH_HH_IDX; nh_idx < TPM_IPV6_NH_MAX_IDX; nh_idx++) {
+		if (ipv6_nh == ipv6_nh_array[nh_idx])
+			break;
+	}
+	if (nh_idx == TPM_IPV6_NH_MAX_IDX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid IPV6 Neat Header Value (%d)\n", ipv6_nh);
+		return TPM_BAD_PARAM;
+	}
+	/* Set IPV6 special NH */
+	if (TPM_PRS_SPEC_IPV6NH_ADD == op)
+		g_tpm_db.prs_db.ipv6_special_nh[nh_idx].nh = ipv6_nh;
+	else if (TPM_PRS_SPEC_IPV6NH_DEL == op)
+		g_tpm_db.prs_db.ipv6_special_nh[nh_idx].nh = TPM_PRS_INV_SPEC_IPV6_NH;
+	else {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid IPv6 special NH operation(%d)\n", op);
+		return TPM_BAD_PARAM;
+	}
+	g_tpm_db.prs_db.ipv6_special_nh[nh_idx].prs_idx = tid;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_spec_ipv6nh_get
+*
+* DESCRIPTION: The API will get IPV6 NH need special treat from list.
+*
+* INPUTS:
+*	ipv6_nh    - IPV6 NH array.
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*
+*******************************************************************************/
+int tpm_db_spec_ipv6nh_get(struct tpm_prs_ipv6_spec_nh_t ipv6_nh[])
+{
+	IF_NULL(TPM_DB_MOD, ipv6_nh);
+
+	memcpy(ipv6_nh, g_tpm_db.prs_db.ipv6_special_nh, sizeof(struct tpm_prs_ipv6_spec_nh_t) * TPM_PRS_IPV6_NH_COUNT);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_module_state_set
+*
+* DESCRIPTION: The API sets TPM module init state, either not started, or started
+*
+* INPUTS:
+*	state  - TPM module init state
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_module_state_set(enum tpm_module_state_t state)
+{
+	if (state > TPM_MODULE_STARTED) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid state(%d)\n", state);
+		return TPM_BAD_PARAM;
+	}
+
+	g_tpm_db.tpm_module_init_state = state;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_module_state_get
+*
+* DESCRIPTION: The API gets TPM module init state, either not started, or started
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	TPM module init state
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+unsigned int tpm_db_module_state_get(void)
+{
+	return g_tpm_db.tpm_module_init_state;
+}
+
+/*******************************************************************************
+* tpm_db_init_db_get
+*
+* DESCRIPTION: The API gets init data base
+*
+* INPUTS:
+*	type - type of init db.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	pointer to TPM init db
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+struct tpm_init_t *tpm_db_init_db_get(enum tpm_init_param_mode_t init_mode)
+{
+	if (TPM_INIT_PARAM_PRE_START == init_mode) {
+		return &g_init_cfg;
+	} else if (TPM_INIT_PARAM_POST_START == init_mode) {
+		return &g_tpm_db.init_db;
+	} else if (TPM_INIT_PARAM_AUTO == init_mode) {
+		if (TPM_MODULE_NOT_START == tpm_db_module_state_get())
+			return &g_init_cfg;
+		else if (TPM_MODULE_STARTED == tpm_db_module_state_get())
+			return &g_tpm_db.init_db;
+	}
+
+	return NULL;
+}
+
+/*******************************************************************************
+* tpm_db_init_switch_mode_set
+*
+* DESCRIPTION: The API set the switch head mode of Ethernet type GMAC.
+*
+* INPUTS:
+*	gmac  - Eth GMAC.
+*	mode  - switch head mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_init_switch_mode_set(enum tpm_gmacs_enum_t gmac, enum tpm_sw_head_mode_t mode)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, gmac, TPM_ENUM_GMAC_1);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	tpm_init->gmac_switch_mode[gmac] = mode;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_switch_mode_get
+*
+* DESCRIPTION: The API get the switch head mode of Ethernet type GMAC.
+*
+* INPUTS:
+*	gmac  - Eth GMAC.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	switch head mode.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+enum tpm_sw_head_mode_t tpm_db_init_switch_mode_get(enum tpm_gmacs_enum_t gmac)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, gmac, TPM_ENUM_GMAC_1);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	return tpm_init->gmac_switch_mode[gmac];
+}
+
+/*******************************************************************************
+* tpm_db_init_gmac_def_mh_set
+*
+* DESCRIPTION: The API set default MH for Ethernet type GMAC.
+*
+* INPUTS:
+*	gmac  - Eth GMAC.
+*	mh    - Marvell head.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_init_gmac_def_mh_set(enum tpm_gmacs_enum_t gmac, unsigned short mh)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, gmac, TPM_ENUM_GMAC_1);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	tpm_init->gmac_def_tx_mh[gmac] = mh;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_filter_type_set
+*
+* DESCRIPTION: The API set filter type.
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	priority		-  priority value of this filter within its rule type
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_init_filter_type_set(
+	unsigned char			rule_type,
+	unsigned char			priority,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num)
+{
+	struct tpm_init_t *tpm_init = NULL;
+	int loop;
+
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, rule_type, TPM_NUM_MAX_RULE_TYPE_NUM);
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, vlan_num, TPM_ANY_VLAN);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	for (loop = 0; loop < TPM_NUM_MAX_FILTER_TYPE; loop++) {
+		if (tpm_init->filter_cap[loop].valid)
+			continue;
+
+		/* here we found a free slot */
+		tpm_init->filter_cap[loop].valid = TPM_TRUE;
+		tpm_init->filter_cap[loop].rule_type = rule_type;
+		tpm_init->filter_cap[loop].precedence = priority;
+		tpm_init->filter_cap[loop].field_match_bm = field_bm;
+		tpm_init->filter_cap[loop].tag_num = vlan_num;
+
+		return TPM_OK;
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_init_filter_type_get()
+*
+* DESCRIPTION: get filter
+*
+* INPUTS:
+*	type    - filter type
+*	index   - filter index in DB, starting from 0
+*
+* OUTPUTS:
+*	filter     -
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_filter_type_get(unsigned int index, struct tpm_init_filter_t *filter)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, filter);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, index,
+		TPM_NUM_MAX_FILTER_TYPE, "invalid index number");
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	memcpy(filter, &tpm_init->filter_cap[index], sizeof(struct tpm_init_filter_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_gmac_def_mh_set
+*
+* DESCRIPTION: The API get the default MH for Ethernet type GMAC.
+*
+* INPUTS:
+*	gmac  - Eth GMAC.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	GMAC default TX Marvell head
+* COMMENTS:
+*	None
+*******************************************************************************/
+unsigned short tpm_db_init_gmac_def_mh_get(enum tpm_gmacs_enum_t gmac)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_POS_RANGE_VALIDATE(TPM_DB_MOD, gmac, TPM_ENUM_GMAC_1);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	return tpm_init->gmac_def_tx_mh[gmac];
+}
+
+/*******************************************************************************
+* tpm_db_init_capability_set()
+*
+* DESCRIPTION: set capability
+*
+* INPUTS:
+*	type  - Capability type
+*	cap   - Capbillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_capability_set(enum tpm_cap_type_t type, struct tpm_init_cap_conf_t *cap)
+{
+	int index = 0;
+	int size = 0;
+	struct tpm_init_cap_conf_t *l_cap = NULL;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, cap);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	if (TPM_CAP_TYPE_EXACT_EXCEPT == type) {
+		l_cap = &tpm_init->exact_match_except_cap[0];
+		size = sizeof(tpm_init->exact_match_except_cap)/sizeof(tpm_init->exact_match_except_cap[0]);
+	} else if (TPM_CAP_TYPE_CLS == type) {
+		l_cap = &tpm_init->generic_class_cap[0];
+		size = sizeof(tpm_init->exact_match_except_cap)/sizeof(tpm_init->exact_match_except_cap[0]);
+	} else {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) Capability is not supported\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Firstly try to get existed capability entry */
+	for (index = 0; index < size; index++) {
+		if ((cap->field_match_bm != ((struct tpm_init_cap_conf_t *)l_cap+index)->field_match_bm)
+		     || (cap->tag_num != ((struct tpm_init_cap_conf_t *)l_cap+index)->tag_num))
+			continue;
+		if ((cap->rule_type != ((struct tpm_init_cap_conf_t *)l_cap+index)->rule_type)
+		     && (TPM_CAP_TYPE_CLS == type))
+			continue;
+
+		break;
+	}
+
+	/* Secondly try to get a free capability entry in case capability was not found */
+	if (index == size) {
+		for (index = 0; index < size; index++) {
+			if (0 == ((struct tpm_init_cap_conf_t *)l_cap+index)->valid)
+				break;
+		}
+	}
+
+	if (index == size) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) Capability is full in DB\n", type);
+		return TPM_FULL;
+	}
+
+	l_cap += index;
+	memcpy(l_cap, cap, sizeof(struct tpm_init_cap_conf_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_capability_get()
+*
+* DESCRIPTION: get capability
+*
+* INPUTS:
+*	type    - Capability type
+*	index   - Capbillity index in DB, starting from 0
+*
+* OUTPUTS:
+*	cap     - Capability
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_capability_get(enum tpm_cap_type_t type, unsigned int index, struct tpm_init_cap_conf_t *cap)
+{
+	int size = 0;
+	struct tpm_init_cap_conf_t *l_cap = NULL;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, cap);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	if (TPM_CAP_TYPE_EXACT_EXCEPT == type) {
+		l_cap = &tpm_init->exact_match_except_cap[0];
+		size = sizeof(tpm_init->exact_match_except_cap)/sizeof(tpm_init->exact_match_except_cap[0]);
+	} else if (TPM_CAP_TYPE_CLS == type) {
+		l_cap = &tpm_init->generic_class_cap[0];
+		size = sizeof(tpm_init->generic_class_cap)/sizeof(tpm_init->generic_class_cap[0]);
+	} else {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) Capability is not supported\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	if (index >= size) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) index(%d) exceed max cap size(%d) in DB\n", type, index, size);
+		return TPM_FULL;
+	}
+
+	l_cap += index;
+	memcpy(cap, l_cap, sizeof(struct tpm_init_cap_conf_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_capability_del()
+*
+* DESCRIPTION: delete capability
+*
+* INPUTS:
+*	type  - Capability type
+*	cap   - Capbillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_capability_del(enum tpm_cap_type_t type, struct tpm_init_cap_conf_t *cap)
+{
+	int index = 0;
+	int size = 0;
+	struct tpm_init_cap_conf_t *l_cap = NULL;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, cap);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	if (TPM_CAP_TYPE_EXACT_EXCEPT == type) {
+		l_cap = &tpm_init->exact_match_except_cap[0];
+		size = sizeof(tpm_init->exact_match_except_cap)/sizeof(tpm_init->exact_match_except_cap[0]);
+	} else if (TPM_CAP_TYPE_CLS == type) {
+		l_cap = &tpm_init->generic_class_cap[0];
+		size = sizeof(tpm_init->exact_match_except_cap)/sizeof(tpm_init->exact_match_except_cap[0]);
+	} else {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) Capability is not supported\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	for (index = 0; index < size; index++) {
+		if ((TPM_TRUE == ((struct tpm_init_cap_conf_t *)l_cap+index)->valid)
+		     && (cap->field_match_bm == ((struct tpm_init_cap_conf_t *)l_cap+index)->field_match_bm)
+		     && (cap->tag_num == ((struct tpm_init_cap_conf_t *)l_cap+index)->tag_num)
+		     && (cap->rule_type == ((struct tpm_init_cap_conf_t *)l_cap+index)->rule_type))
+			break;
+	}
+
+	if (index == size) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Type(%d) Cap with field_bm(0x%x) no find in DB\n", type, cap->field_match_bm);
+		return TPM_NO_SUCH;
+	}
+
+	l_cap += index;
+	memset(l_cap, 0, sizeof(struct tpm_init_cap_conf_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mc_proto_handler_set()
+*
+* DESCRIPTION: set the handler type for multicast protocol packets
+*
+* INPUTS:
+*	handler  - multicast protocol packet handler
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mc_proto_handler_set(struct tpm_port_mc_proto_handler_t *handler)
+{
+	int index = 0;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, handler);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	for (index = 0; index < TPM_NUM_MAX_GMAC_PORTS; index++) {
+		if (handler->port == tpm_init->mc_proto_handler[index].port)
+			break;
+		if (TPM_DB_INIT_INVALID_VALUE == tpm_init->mc_proto_handler[index].port)
+			break;
+	}
+
+	if (index == TPM_NUM_MAX_GMAC_PORTS) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM DB for MC proto handler is full\n");
+		return TPM_FULL;
+	}
+
+	tpm_init->mc_proto_handler[index].port = handler->port;
+	tpm_init->mc_proto_handler[index].mc_proto_handler = handler->mc_proto_handler;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mc_proto_handler_get()
+*
+* DESCRIPTION: get the handler type for multicast protocol packets
+*
+* INPUTS:
+*	index - index of TPID for VLAN modification
+*
+* OUTPUTS:
+*	handler  - multicast protocol packet handler
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mc_proto_handler_get(unsigned int index, struct tpm_port_mc_proto_handler_t *handler)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	if (index >= TPM_NUM_MAX_GMAC_PORTS) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM MC proto handler index(%d) is out of scope\n", index);
+		return TPM_FULL;
+	}
+
+	IF_NULL(TPM_DB_MOD, handler);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	handler->port = tpm_init->mc_proto_handler[index].port;
+	handler->mc_proto_handler = tpm_init->mc_proto_handler[index].mc_proto_handler;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mc_flow_def_set()
+*
+* DESCRIPTION: set the default action for multicast packets
+*
+* INPUTS:
+*	mc_flow_layer  - 0: L2 or 1: L3
+*       mc_flow_def    - default action
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mc_flow_def_set(enum tpm_mc_traffic_layer_t mc_flow_layer, enum tpm_mc_flow_def_action_t mc_flow_def)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mc_flow_layer, TPM_MC_TRAFFIC_L2, TPM_MC_TRAFFIC_L3);
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mc_flow_def, TPM_MC_FLOW_DEFAULT_DROP, TPM_MC_FLOW_DEFAULT_CPU);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	tpm_init->mc_flow_def[mc_flow_layer] = mc_flow_def;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mc_flow_def_get()
+*
+* DESCRIPTION: get the handler type for multicast protocol packets
+*
+* INPUTS:
+*	mc_flow_layer - 0: L2 or 1: L3
+*
+* OUTPUTS:
+*	mc_flow_def   - default action
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mc_flow_def_get(enum tpm_mc_traffic_layer_t mc_flow_layer, enum tpm_mc_flow_def_action_t *mc_flow_def)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mc_flow_layer, TPM_MC_TRAFFIC_L2, TPM_MC_TRAFFIC_L3);
+	IF_NULL(TPM_DB_MOD, mc_flow_def);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	*mc_flow_def = tpm_init->mc_flow_def[mc_flow_layer];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mod_tpid_set()
+*
+* DESCRIPTION: set the TPID for VLAN modification
+*
+* INPUTS:
+*	tpid  - the TPID for VLAN modification
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mod_tpid_set(unsigned short tpid)
+{
+	int index = 0;
+	struct tpm_init_t *tpm_init = NULL;
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	/* Do nothing in case the VLAN MOD TPID already exists */
+	for (index = 0; index < TPM_NUM_VLAN_ETYPE_REGS; index++) {
+		if (tpid == tpm_init->mod_vlan_tpid[index]) {
+			TPM_OS_ERROR(TPM_DB_MOD, "TPM VLAN MOD TPID(0x%x) already exists\n", tpid);
+			return TPM_ALREADY_EXIST;
+		}
+	}
+
+	for (index = 0; index < TPM_NUM_VLAN_ETYPE_REGS; index++) {
+		if (TPM_INVALID_TPID == tpm_init->mod_vlan_tpid[index])
+			break;
+	}
+
+	if (index == TPM_NUM_VLAN_ETYPE_REGS) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM DB for MOD VLAN TPID is full\n");
+		return TPM_FULL;
+	}
+
+	tpm_init->mod_vlan_tpid[index] = tpid;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_mod_tpid_get()
+*
+* DESCRIPTION: get the TPID for VLAN modification
+*
+* INPUTS:
+*	index - index of TPID for VLAN modification
+*
+* OUTPUTS:
+*	tpid  - the TPID for VLAN modification
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_mod_tpid_get(unsigned int index, unsigned short *tpid)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	if (index >= TPM_NUM_VLAN_ETYPE_REGS) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM MOD VLAN TPID index(%d) is out of scope\n", index);
+		return TPM_FULL;
+	}
+
+	IF_NULL(TPM_DB_MOD, tpid);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	*tpid = tpm_init->mod_vlan_tpid[index];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_tpid_combo_set()
+*
+* DESCRIPTION: set the TPID combo for single tag, dual tag
+*
+* INPUTS:
+*	tpid_combo  - the TPID for VLAN modification
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_tpid_combo_set(struct tpm_tpid_combo_t *tpid_combo)
+{
+	int index = 0;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, tpid_combo);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	/* Check whether the TPID combo already exists */
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++) {
+		if ((true == tpm_init->tpid_combo[index].valid) &&
+		    (tpid_combo->tpid1 == tpm_init->tpid_combo[index].tpid1) &&
+		    (tpid_combo->tpid2 == tpm_init->tpid_combo[index].tpid2)) {
+			TPM_OS_ERROR(TPM_DB_MOD, "TPM TPID combo TPID1(0x%x) TPID2(0x%x) already exists\n",
+				     tpid_combo->tpid1, tpid_combo->tpid2);
+			return TPM_ALREADY_EXIST;
+		}
+	}
+
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++) {
+		if (false == tpm_init->tpid_combo[index].valid)
+			break;
+	}
+
+	if (index == TPM_NUM_MAX_TPID_COMBO) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM DB for TPID combo is full\n");
+		return TPM_FULL;
+	}
+
+	tpm_init->tpid_combo[index].tpid1 = tpid_combo->tpid1;
+	tpm_init->tpid_combo[index].tpid2 = tpid_combo->tpid2;
+	tpm_init->tpid_combo[index].valid = true;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_tpid_combo_get()
+*
+* DESCRIPTION: get the TPID combo for single tag, dual tag
+*
+* INPUTS:
+*	index - index of TPID combo
+*
+* OUTPUTS:
+*	tpid_combo  - the TPID combo
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_tpid_combo_get(unsigned int index, struct tpm_tpid_combo_t *tpid_combo)
+{
+	struct tpm_init_t *tpm_init = NULL;
+
+	if (index >= TPM_NUM_MAX_TPID_COMBO) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM TPID combo index(%d) is out of scope\n", index);
+		return TPM_FULL;
+	}
+
+	IF_NULL(TPM_DB_MOD, tpid_combo);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	memcpy(tpid_combo, &tpm_init->tpid_combo[index], sizeof(struct tpm_tpid_combo_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_init_tpid_combo_del()
+*
+* DESCRIPTION: delete the TPID combo for single tag, dual tag
+*
+* INPUTS:
+*	tpid_combo  - the TPID combo
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_db_init_tpid_combo_del(struct tpm_tpid_combo_t *tpid_combo)
+{
+	int index = 0;
+	struct tpm_init_t *tpm_init = NULL;
+
+	IF_NULL(TPM_DB_MOD, tpid_combo);
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_AUTO);
+	IF_NULL(TPM_DB_MOD, tpm_init);
+
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++) {
+		if ((true == tpm_init->tpid_combo[index].valid) &&
+		    (tpid_combo->tpid1 == tpm_init->tpid_combo[index].tpid1) &&
+		    (tpid_combo->tpid2 == tpm_init->tpid_combo[index].tpid2))
+			break;
+	}
+
+	if (index == TPM_NUM_MAX_TPID_COMBO) {
+		TPM_OS_ERROR(TPM_DB_MOD, "TPM DB for TPID combo TPID1(0x%x) TPID2(0x%x) was not found\n",
+			     tpid_combo->tpid1, tpid_combo->tpid2);
+		return TPM_NO_SUCH;
+	}
+
+	tpm_init->tpid_combo[index].tpid1 = 0;
+	tpm_init->tpid_combo[index].tpid2 = 0;
+	tpm_init->tpid_combo[index].valid = false;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_generic_param_set
+*
+* DESCRIPTION: The API is a generic route to set TPM database parameters
+*	whose data types are 'unsigned int'
+*
+* INPUTS:
+*	type   - The internal TPM DB parameter type.
+*	value  - Parameter value.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_generic_param_set(enum tpm_db_param_type_t type, unsigned int value)
+{
+	int index = 0;
+	unsigned int param_num = 0;
+	struct tpm_db_param_t *init_param = NULL;
+
+	if (type >= TPM_DB_PARAM_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid param type(%d), allowed max type(%d)\n",
+			     type, TPM_DB_PARAM_MAX);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_MODULE_NOT_START == tpm_db_module_state_get()) {
+		param_num = g_tpm_init_pre_start_param_num;
+		init_param = g_tpm_init_pre_start_param;
+	} else if (TPM_MODULE_STARTED == tpm_db_module_state_get()) {
+		param_num = g_tpm_init_post_start_param_num;
+		init_param = g_tpm_init_post_start_param;
+	} else{
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid TPM module state(%d)\n", tpm_db_module_state_get());
+		return TPM_NOT_ALLOWED;
+	}
+
+	/* Seach for the entry */
+	for (index = 0; index < param_num; index++) {
+		if (init_param[index].type == type)
+			break;
+	}
+	if (index == param_num) {
+		TPM_OS_ERROR(TPM_DB_MOD, "could not find param type(%d)\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	*init_param[index].value = value;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_generic_param_get
+*
+* DESCRIPTION: The API is a generic route to get TPM database parameters
+*	whose data types are 'unsigned int'
+*
+* INPUTS:
+*	type  - The internal TPM DB parameter type.
+*
+* OUTPUTS:
+*	value  - Parameter value..
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_generic_param_get(enum tpm_db_param_type_t type, unsigned int *value)
+{
+	int index = 0;
+	unsigned int param_num = 0;
+	struct tpm_db_param_t *init_param = NULL;
+
+	if (type >= TPM_DB_PARAM_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid param type(%d), allowed max type(%d)\n",
+			     type, TPM_DB_PARAM_MAX);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_MODULE_NOT_START == tpm_db_module_state_get()) {
+		param_num = g_tpm_init_pre_start_param_num;
+		init_param = g_tpm_init_pre_start_param;
+	} else if (TPM_MODULE_STARTED == tpm_db_module_state_get()) {
+		param_num = g_tpm_init_post_start_param_num;
+		init_param = g_tpm_init_post_start_param;
+	} else{
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid TPM module state(%d)\n", tpm_db_module_state_get());
+		return TPM_NOT_ALLOWED;
+	}
+
+	/* Seach for the entry */
+	for (index = 0; index < param_num; index++) {
+		if (init_param[index].type == type)
+			break;
+	}
+	if (index == param_num) {
+		TPM_OS_ERROR(TPM_DB_MOD, "could not find param type(%d)\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	*value = *init_param[index].value;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c2_lkp_type_list_head_get()
+*
+* DESCRIPTION: Get the head of the lookup type list.
+*
+* INPUTS:
+*          lkp_type  - C2 lookup type
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The head pointer of list.
+*
+*******************************************************************************/
+struct list_head *tpm_db_c2_lkp_type_list_head_get(unsigned char lkp_type)
+{
+	return &g_tpm_db.c2_db.c2_lu_type_head_db[lkp_type];
+}
+
+/*******************************************************************************
+* tpm_db_c2_free_list_head_get()
+*
+* DESCRIPTION: Get the head of free list.
+*
+* INPUTS:
+*          None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The head pointer of list.
+*
+*******************************************************************************/
+struct list_head *tpm_db_c2_free_list_head_get(void)
+{
+	return &g_tpm_db.c2_db.c2_free_head_db;
+}
+
+/*******************************************************************************
+* tpm_db_c2_index_node_get()
+*
+* DESCRIPTION: Get the index node in the list according to their db index.
+*
+* INPUTS:
+*          c2_node_idx  - the db index of C2 index node.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The node pointer.
+*
+*******************************************************************************/
+struct tpm_c2_index_t *tpm_db_c2_index_node_get(unsigned int c2_node_idx)
+{
+	/* Para check */
+	if (c2_node_idx >= TPM_C2_ENTRY_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return NULL;
+	}
+	return &g_tpm_db.c2_db.c2_index_db[c2_node_idx];
+}
+
+/*******************************************************************************
+* tpm_db_c2_index_node_set()
+*
+* DESCRIPTION: Set the index node in the list according to their db index.
+*
+* INPUTS:
+*          c2_node_idx   - the db index of C2 index node.
+*          c2_index_node - the new value of the node to set.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_c2_index_node_set(unsigned int c2_node_idx,
+			     struct tpm_c2_index_t *c2_index_node)
+{
+	/* Param check */
+	if (c2_node_idx >= TPM_C2_ENTRY_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	IF_NULL(TPM_DB_MOD, c2_index_node);
+
+	memcpy(&g_tpm_db.c2_db.c2_index_db[c2_node_idx], c2_index_node, sizeof(struct tpm_c2_index_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c2_data_get()
+*
+* DESCRIPTION: Get the C2 entry data from DB according to their db index.
+*
+* INPUTS:
+*          c2_node_idx   - the db index of C2 entry data.
+*
+* OUTPUTS:
+*          c2_data       - C2 entry data.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_c2_data_get(unsigned int c2_db_idx,
+		       struct tpm_c2_data_t *c2_data)
+{
+	/* Param check */
+	if (c2_db_idx > TPM_C2_LAST_ENTRY) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	IF_NULL(TPM_DB_MOD, c2_data);
+
+	memcpy(c2_data, &g_tpm_db.c2_db.c2_data_db[c2_db_idx], sizeof(struct tpm_c2_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c2_data_set()
+*
+* DESCRIPTION: Set the C2 entry data to DB according to their allocated db index.
+*
+* INPUTS:
+*          c2_node_idx   - the db index of C2 entry data.
+*          c2_data       - C2 entry data.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_c2_data_set(unsigned int c2_db_idx,
+		       struct tpm_c2_data_t *c2_data)
+{
+	/* Param check */
+	if (c2_db_idx > TPM_C2_LAST_ENTRY) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	IF_NULL(TPM_DB_MOD, c2_data);
+
+	memcpy(&g_tpm_db.c2_db.c2_data_db[c2_db_idx], c2_data, sizeof(struct tpm_c2_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_free_logic_idx_get()
+*
+* DESCRIPTION: Get a free logic index from list.
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	logic_idx - logical index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_free_logic_idx_get(unsigned int *logic_idx)
+{
+	int idx;
+
+	IF_NULL(TPM_DB_MOD, logic_idx);
+
+	/* search for valid C3 logical index */
+	for (idx = 0; idx < MV_PP2_CLS_C3_HASH_TBL_SIZE; idx++) {
+		if (g_tpm_db.c3_db.hash_idx_tbl[idx].valid == TPM_C3_ENTRY_INVALID)
+			break;
+	}
+
+	if (idx < MV_PP2_CLS_C3_HASH_TBL_SIZE) {
+		*logic_idx = idx;
+		return TPM_OK;
+	} else {
+		*logic_idx = 0;
+		return TPM_FULL;
+	}
+}
+
+/*******************************************************************************
+* tpm_db_c3_entry_add()
+*
+* DESCRIPTION: Add C3 entry to DB.
+*
+* INPUTS:
+*	logic_idx      - logical index
+*	hash_idx       - multihash index
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_entry_add(unsigned int	logic_idx,
+			unsigned int	hash_idx)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, hash_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid multihash index");
+
+	/* add or update hash index table */
+	g_tpm_db.c3_db.hash_idx_tbl[logic_idx].valid = TPM_C3_ENTRY_VALID;
+	g_tpm_db.c3_db.hash_idx_tbl[logic_idx].hash_idx = hash_idx;
+
+	/* add or update logical index table */
+	g_tpm_db.c3_db.logic_idx_tbl[hash_idx].valid = TPM_C3_ENTRY_VALID;
+	g_tpm_db.c3_db.logic_idx_tbl[hash_idx].logic_idx = logic_idx;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_entry_del()
+*
+* DESCRIPTION: Delete C3 entry to DB.
+*
+* INPUTS:
+*	logic_idx - logical index
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_entry_del(int logic_idx)
+{
+	unsigned int hash_idx;
+	struct tpm_c3_hash_index_entry_t *p_hash_entry = NULL;
+	struct tpm_c3_logic_index_entry_t *p_logic_entry = NULL;
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+
+	/* get hash index entry */
+	p_hash_entry = &g_tpm_db.c3_db.hash_idx_tbl[logic_idx];
+	if (p_hash_entry->valid == TPM_C3_ENTRY_VALID) {
+		/* clear hash entry */
+		hash_idx = p_hash_entry->hash_idx;
+		p_hash_entry->valid = TPM_C3_ENTRY_INVALID;
+		p_hash_entry->hash_idx = TPM_C3_INVALID_ENTRY_NUM;
+
+		/* get logical index entry by hash index and clear it */
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, hash_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid hash index");
+		p_logic_entry = &g_tpm_db.c3_db.logic_idx_tbl[hash_idx];
+		p_logic_entry->valid = TPM_C3_ENTRY_INVALID;
+		p_logic_entry->logic_idx = TPM_C3_INVALID_ENTRY_NUM;
+	} else {
+		TPM_OS_ERROR(TPM_DB_MOD, "hash entry is invalid, do not need to delete it\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_hash_idx_get()
+*
+* DESCRIPTION: Get C3 multihash index by logical index.
+*
+* INPUTS:
+*	logic_idx - logical index
+*
+* OUTPUTS:
+*	hash_idx  - multihash index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_hash_idx_get(unsigned int	logic_idx,
+			   unsigned int	*hash_idx)
+{
+	struct tpm_c3_hash_index_entry_t *p_hash_entry = NULL;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	IF_NULL(TPM_DB_MOD, hash_idx);
+
+	/* get hash index entry */
+	p_hash_entry = &g_tpm_db.c3_db.hash_idx_tbl[logic_idx];
+	if (p_hash_entry->valid == TPM_C3_ENTRY_VALID) {
+
+		*hash_idx = p_hash_entry->hash_idx;
+		return TPM_OK;
+	} else {
+
+		return TPM_NO_SUCH;
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_logic_idx_get()
+*
+* DESCRIPTION: Get the multihash index.
+*
+* INPUTS:
+*	hash_idx  - multihash index
+*
+* OUTPUTS:
+*	logic_idx - logical index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_logic_idx_get(unsigned int	hash_idx,
+			    unsigned int	*logic_idx)
+{
+	struct tpm_c3_logic_index_entry_t *p_logic_entry = NULL;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, hash_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid hash index");
+	IF_NULL(TPM_DB_MOD, logic_idx);
+
+	/* get hash index entry */
+	p_logic_entry = &g_tpm_db.c3_db.logic_idx_tbl[hash_idx];
+	if (p_logic_entry->valid == TPM_C3_ENTRY_VALID) {
+
+		*logic_idx = p_logic_entry->logic_idx;
+		return TPM_OK;
+	} else {
+
+		return TPM_NO_SUCH;
+	}
+}
+
+/*******************************************************************************
+* tpm_db_c3_hash_idx_update()
+*
+* DESCRIPTION: Update the multihash index.
+*
+* INPUTS:
+*	hash_pair_arr  - multihash modification array
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_hash_idx_update(MV_PP2_CLS3_HASH_PAIR *hash_pair_arr)
+{
+	int idx;
+	unsigned int old_idx;
+	unsigned int new_idx;
+	unsigned int logic_idx;
+	struct tpm_c3_hash_index_entry_t *p_hash_entry = NULL;
+	struct tpm_c3_logic_index_entry_t *p_logic_entry = NULL;
+
+	IF_NULL(TPM_DB_MOD, hash_pair_arr);
+
+	/* update the multihash mapping in loop */
+	for (idx = 0; idx < hash_pair_arr->pair_num; idx++) {
+		old_idx = hash_pair_arr->old_idx[idx];
+		new_idx = hash_pair_arr->new_idx[idx];
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, old_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid hash index");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, new_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid hash index");
+
+		p_logic_entry = &g_tpm_db.c3_db.logic_idx_tbl[old_idx];
+		if (p_logic_entry->valid == TPM_C3_ENTRY_INVALID) {
+			TPM_OS_ERROR(TPM_DB_MOD, "hash entry is invalid w/ index(%d)\n", old_idx);
+			return TPM_BAD_VALUE;
+		}
+
+		logic_idx = p_logic_entry->logic_idx;
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1,
+					   "invalid logical index");
+
+		/* update logical index table */
+		p_logic_entry->valid = TPM_C3_ENTRY_INVALID;
+		p_logic_entry->logic_idx = TPM_C3_INVALID_ENTRY_NUM;
+		p_logic_entry = &g_tpm_db.c3_db.logic_idx_tbl[new_idx];
+		p_logic_entry->valid = TPM_C3_ENTRY_VALID;
+		p_logic_entry->logic_idx = logic_idx;
+
+		/* update hash index table */
+		p_hash_entry = &g_tpm_db.c3_db.hash_idx_tbl[logic_idx];
+		p_hash_entry->valid = TPM_C3_ENTRY_VALID;
+		p_hash_entry->hash_idx = new_idx;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_scan_param_set()
+*
+* DESCRIPTION: set scan parameters.
+*
+* INPUTS:
+*	scan_config  - scan configuration parameters
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_scan_param_set(struct tpm_c3_scan_config_t *scan_config)
+{
+	struct tpm_c3_scan_config_t *p_scan_config = NULL;
+
+	IF_NULL(TPM_DB_MOD, scan_config);
+
+	p_scan_config = &g_tpm_db.c3_db.scan_config;
+	memcpy(p_scan_config, scan_config, sizeof(struct tpm_c3_scan_config_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_scan_param_get()
+*
+* DESCRIPTION: get scan parameters.
+*
+* INPUTS:
+*	Nones
+*
+* OUTPUTS:
+*	can_config  - scan configuration parameters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_scan_param_get(struct tpm_c3_scan_config_t *scan_config)
+{
+	struct tpm_c3_scan_config_t *p_scan_config = NULL;
+
+	IF_NULL(TPM_DB_MOD, scan_config);
+
+	p_scan_config = &g_tpm_db.c3_db.scan_config;
+	memcpy(scan_config, p_scan_config, sizeof(struct tpm_c3_scan_config_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_search_depth_set()
+*
+* DESCRIPTION: set cuckoo search depth.
+*
+* INPUTS:
+*	search_depth  - cuckoo search depth
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_search_depth_set(unsigned int search_depth)
+{
+	g_tpm_db.c3_db.max_search_depth = search_depth;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_search_depth_get()
+*
+* DESCRIPTION: get cuckoo search depth.
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	search_depth  - cuckoo search depth
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_c3_search_depth_get(unsigned int *search_depth)
+{
+	IF_NULL(TPM_DB_MOD, search_depth);
+
+	*search_depth = g_tpm_db.c3_db.max_search_depth;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c3_init()
+*
+* DESCRIPTION: Perform DB Initialization for C3 engine.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_c3_init(void)
+{
+	int idx;
+
+	/* Clear C3 db */
+	memset(&g_tpm_db.c3_db, 0, sizeof(struct tpm_db_c3_t));
+
+	/* Init C3 multihash index table and logical index table */
+	for (idx = 0; idx < MV_PP2_CLS_C3_HASH_TBL_SIZE; idx++) {
+		g_tpm_db.c3_db.hash_idx_tbl[idx].valid = TPM_C3_ENTRY_INVALID;
+		g_tpm_db.c3_db.logic_idx_tbl[idx].valid = TPM_C3_ENTRY_INVALID;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c4_port_to_ruleset_set()
+*
+* DESCRIPTION: This routine sets port to ruleset
+*
+* INPUTS:
+*          src_port   - could be UNI port or PHY port
+*          rule_set   - C4 engine ruleSet No.
+*          rule_number   - rule number of this ruleSet.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+unsigned int tpm_db_c4_port_to_ruleset_set(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		rule_set,
+	unsigned int		rule_number)
+{
+	IF_NULL(TPM_DB_MOD, src_port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, rule_number,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, rule_set,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet");
+
+	memcpy(&g_tpm_db.c4_db.ruleset_config[rule_set].src_port, src_port,
+		sizeof(struct tpm_class_port_t));
+	g_tpm_db.c4_db.ruleset_config[rule_set].rule_number = rule_number;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c4_port_to_ruleset_get()
+*
+* DESCRIPTION: This routine gets ruleSet from port
+*
+* INPUTS:
+*          src_port   - could be UNI port or PHY port
+*
+* OUTPUTS:
+*          rule_set   - C4 engine ruleSet No.
+*          rule_number   - rule number of this ruleSet.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+unsigned int tpm_db_c4_port_to_ruleset_get(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		*rule_set,
+	unsigned int		*rule_number)
+{
+	int loop;
+
+	IF_NULL(TPM_DB_MOD, src_port);
+	IF_NULL(TPM_DB_MOD, rule_set);
+	IF_NULL(TPM_DB_MOD, rule_number);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, src_port->class_port,
+		TPM_NUM_MAX_UNI_PORTS, "invalid port number");
+
+	for (loop = 0; loop < MV_PP2_CLS_C4_GRPS_NUM; loop++) {
+		if (memcmp(&g_tpm_db.c4_db.ruleset_config[loop].src_port, src_port,
+			sizeof(struct tpm_class_port_t)))
+			continue;
+
+		*rule_set = loop;
+		*rule_number = g_tpm_db.c4_db.ruleset_config[loop].rule_number;
+		return TPM_OK;
+	}
+
+	return TPM_NOT_FOUND;
+}
+
+/*******************************************************************************
+* tpm_db_c4_rule_add()
+*
+* DESCRIPTION: This routine adds a C4 rule
+*
+* INPUTS:
+*          c4_entry
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+unsigned int tpm_db_c4_rule_add(
+	struct tpm_c4_add_entry_t *c4_entry)
+{
+	IF_NULL(TPM_DB_MOD, c4_entry);
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, c4_entry->rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, c4_entry->ruleSet,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet");
+
+	memcpy(&g_tpm_db.c4_db.rule_entries[c4_entry->ruleSet][c4_entry->rule_num].rule_entry,
+		c4_entry, sizeof(struct tpm_c4_add_entry_t));
+
+	g_tpm_db.c4_db.rule_entries[c4_entry->ruleSet][c4_entry->rule_num].valid = TPM_TRUE;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c4_rule_del()
+*
+* DESCRIPTION: This routine deletes a C4 rule
+*
+* INPUTS:
+*          rule_set   - C4 engine ruleSet No.
+*          rule_number   - rule number of this ruleSet.
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+unsigned int tpm_db_c4_rule_del(
+	unsigned int		rule_set,
+	unsigned int		rule_number)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_number,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_set,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet");
+
+	TPM_MEMSET_ZERO(g_tpm_db.c4_db.rule_entries[rule_set][rule_number].rule_entry);
+
+	g_tpm_db.c4_db.rule_entries[rule_set][rule_number].valid = TPM_FALSE;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c4_rule_get()
+*
+* DESCRIPTION: This routine gets a C4 rule
+*
+* INPUTS:
+*          rule_set   - C4 engine ruleSet No.
+*          rule_number   - rule number of this ruleSet.
+*
+* OUTPUTS:
+*	c4_entry
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+unsigned int tpm_db_c4_rule_get(
+	unsigned int		rule_set,
+	unsigned int		rule_number,
+	struct tpm_db_c4_rule_t *db_c4_rule)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_number,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_set,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet");
+
+	memcpy(db_c4_rule, &g_tpm_db.c4_db.rule_entries[rule_set][rule_number],
+		sizeof(struct tpm_db_c4_rule_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c4_init()
+*
+* DESCRIPTION: Perform DB Initialization for C4 engine.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_c4_init(void)
+{
+	/* Clear C4 db */
+	memset(&g_tpm_db.c4_db, 0, sizeof(struct tpm_db_c4_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_flow_cap_add
+*
+* DESCRIPTION: The API adds a flow_cap conf
+*
+* INPUTS:
+*           flow_cap_arr
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_flow_cap_add(struct tpm_db_mng_flow_cap_conf_t *flow_cap_arr)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, flow_cap_arr);
+
+	/* go through flow_cap_conf, find the first open slot */
+	for (loop = 0; loop < TPM_DB_MNG_FLOW_CAP_MAX; loop++) {
+		if (!g_tpm_db.mng_db.flow_cap_cfg[loop].valid)
+			break;
+	}
+
+	if (loop == TPM_DB_MNG_FLOW_CAP_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "no free space for flow_cap\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	memcpy(&(g_tpm_db.mng_db.flow_cap_cfg[loop]), flow_cap_arr,
+		sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	g_tpm_db.mng_db.flow_cap_cfg[loop].valid = TPM_TRUE;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_flow_cap_update
+*
+* DESCRIPTION: The API updates a flow_cap conf
+*
+* INPUTS:
+*           flow_cap
+*           flow_cap_updated
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_flow_cap_update(
+	struct tpm_db_mng_flow_cap_conf_t *flow_cap,
+	struct tpm_db_mng_flow_cap_conf_t *flow_cap_updated
+)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, flow_cap);
+	IF_NULL(TPM_DB_MOD, flow_cap_updated);
+
+	/* go through flow_cap_conf, find the cap */
+	for (loop = 0; loop < TPM_DB_MNG_FLOW_CAP_MAX; loop++) {
+		if (!memcmp(&g_tpm_db.mng_db.flow_cap_cfg[loop],
+			flow_cap, sizeof(struct tpm_db_mng_flow_cap_conf_t)))
+			break;
+	}
+
+	if (loop == TPM_DB_MNG_FLOW_CAP_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "do not find flow_cap\n");
+		return TPM_NO_SUCH;
+	}
+
+	memcpy(&(g_tpm_db.mng_db.flow_cap_cfg[loop]), flow_cap_updated,
+		sizeof(struct tpm_db_mng_flow_cap_conf_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_flow_in_cap_get
+*
+* DESCRIPTION: get all the flow_id that matches cap
+*
+* INPUTS:
+*           api_type
+*           field_match_bm
+*
+* OUTPUTS:
+*           flow_cap_arr        - flows in the cap
+*           flow_num             - number of flows in the cap
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_flow_in_cap_get(
+	enum tpm_mng_api_type_t   api_type,
+	unsigned int              rule_type,
+	unsigned int              field_match_bm,
+	enum tpm_vlan_num_enum_t  vlan_num,
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr[],
+	int *flow_num)
+{
+	int loop = 0;
+	int cur_num = 0;
+
+	IF_NULL(TPM_DB_MOD, flow_cap_arr);
+	IF_NULL(TPM_DB_MOD, flow_num);
+
+	/* go through flow_cap_conf, find all the flows that have this caps */
+	for (loop = 0; loop < TPM_DB_MNG_FLOW_CAP_MAX; loop++) {
+		if (!g_tpm_db.mng_db.flow_cap_cfg[loop].valid)
+			break;
+
+		if ((g_tpm_db.mng_db.flow_cap_cfg[loop].cap_api_type != api_type)
+			|| (g_tpm_db.mng_db.flow_cap_cfg[loop].cap_field_bm != field_match_bm)
+			|| (g_tpm_db.mng_db.flow_cap_cfg[loop].vlan_num != vlan_num))
+			continue;
+
+		if ((g_tpm_db.mng_db.flow_cap_cfg[loop].cap_api_type == TPM_API_PUBLIC_CLS)
+			&& (g_tpm_db.mng_db.flow_cap_cfg[loop].rule_type != rule_type))
+			continue;
+
+		if ((g_tpm_db.mng_db.flow_cap_cfg[loop].cap_api_type == TPM_API_PRIVATE_MC_DS) &&
+			(rule_type == TPM_MC_DEF_DIP_TYPE) &&
+			(g_tpm_db.mng_db.flow_cap_cfg[loop].rule_type != rule_type))
+			continue;
+
+		memcpy(&(flow_cap_arr[cur_num++]),
+			&(g_tpm_db.mng_db.flow_cap_cfg[loop]),
+			sizeof(struct tpm_db_mng_flow_cap_conf_t));
+	}
+
+	*flow_num = cur_num;
+
+	if (0 == cur_num) {
+		/* find no cap, error */
+		TPM_OS_ERROR(TPM_PRS_MOD,
+			"input cap was not initialized when TPM INIT, api_type: %s, field_bm: 0x%x, vlan_num: %s\n",
+			tpm_utils_cap_type_str_get(api_type), field_match_bm, tpm_utils_vlan_num_str_get(vlan_num));
+		return TPM_NO_SUCH;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cap_in_flow_get
+*
+* DESCRIPTION: get all the caps in a certain flow_log_id
+*
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           cap_arr      -   cap array, must be memset 0 before calling this routine
+*           cap_num    -   number of caps in this flow
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cap_in_flow_get(enum tpm_mng_flow_log_id_t flow_id,
+					struct tpm_db_mng_flow_cap_conf_t cap_arr[],
+					int *cap_num)
+{
+	int loop = 0;
+	int cur_num = 0;
+
+	IF_NULL(TPM_DB_MOD, cap_arr);
+	IF_NULL(TPM_DB_MOD, cap_num);
+
+	/* go through flow_cap_conf */
+	while (g_tpm_db.mng_db.flow_cap_cfg[loop].valid) {
+		if (g_tpm_db.mng_db.flow_cap_cfg[loop].flow_log_id != flow_id) {
+			loop++;
+			continue;
+		}
+		memcpy(&cap_arr[cur_num], &(g_tpm_db.mng_db.flow_cap_cfg[loop]),
+			sizeof(struct tpm_db_mng_flow_cap_conf_t));
+		loop++;
+		cur_num++;
+	}
+
+	*cap_num = cur_num;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_next_cls_pri_get
+*
+* DESCRIPTION: get the next cls table pri this flow_id should be using
+*
+* INPUTS:
+*           flow_id
+*           next_pri
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_next_cls_pri_get(enum tpm_mng_flow_log_id_t flow_id,
+				     int *next_pri)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, next_pri);
+
+	*next_pri = 0;
+	/* go through flow_cap_conf, get the next cls pri */
+	while (g_tpm_db.mng_db.flow_cap_cfg[loop].valid) {
+		if (g_tpm_db.mng_db.flow_cap_cfg[loop].flow_log_id != flow_id) {
+			loop++;
+			continue;
+		}
+
+		if (*next_pri < g_tpm_db.mng_db.flow_cap_cfg[loop].cls_pri)
+			*next_pri = g_tpm_db.mng_db.flow_cap_cfg[loop].cls_pri;
+
+		loop++;
+	}
+
+	/* reserve a pri for cap with port_type phy and uni/vir */
+	*next_pri = *next_pri + TPM_MNG_PRI_CAP_RESERVE;
+
+	if (*next_pri > TPM_MNG_CLS_PRI_MAX) {
+		TPM_OS_ERROR(TPM_PRS_MOD, "PRI value has exceeded max(%d)\n", *next_pri);
+		return TPM_NO_RESOURCE;
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_rule_id_get
+*
+* DESCRIPTION: get rule_id for a api entry
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+*                          rule_id
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_rule_id_get(void)
+{
+	static int api_rule_id = TPM_DB_MNG_API_RULE_IDX_START;
+
+	return api_rule_id++;
+}
+
+/*******************************************************************************
+* tpm_db_mng_clear
+*
+* DESCRIPTION: clear manager post init DB
+*
+* INPUTS:
+*           NONE.
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_mng_clear()
+{
+	TPM_MEMSET_ZERO(g_tpm_db.mng_db.api_data);
+	TPM_MEMSET_ZERO(g_tpm_db.mng_db.virt_pid_cfg);
+	TPM_MEMSET_ZERO(g_tpm_db.mng_db.flow_cap_cfg);
+	TPM_MEMSET_ZERO(g_tpm_db.mng_db.c2_lu_type_cntr);
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_add
+*
+* DESCRIPTION: add a api entry data into db
+*
+* INPUTS:
+*           api_data
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_add(struct tpm_db_mng_api_data_t *api_data)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, api_data);
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if (g_tpm_db.mng_db.api_data[loop].valid)
+			continue;
+		memcpy(&g_tpm_db.mng_db.api_data[loop], api_data,
+			sizeof(struct tpm_db_mng_api_data_t));
+		g_tpm_db.mng_db.api_data[loop].valid = TPM_TRUE;
+		return TPM_OK;
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_get
+*
+* DESCRIPTION: get api entry for a api rule id
+*
+* INPUTS:
+*           rule_id
+*           api_data
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_get(
+	int rule_id,
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, api_data);
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if ((!g_tpm_db.mng_db.api_data[loop].valid)
+		     || (g_tpm_db.mng_db.api_data[loop].api_rule_id != rule_id)) {
+			continue;
+		}
+		memcpy(api_data, &g_tpm_db.mng_db.api_data[loop],
+			sizeof(struct tpm_db_mng_api_data_t));
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_set
+*
+* DESCRIPTION: update api entry for a api rule id
+*
+* INPUTS:
+*           rule_id
+*           api_data
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_set(
+	int rule_id,
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, api_data);
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if ((!g_tpm_db.mng_db.api_data[loop].valid)
+		     || (g_tpm_db.mng_db.api_data[loop].api_rule_id != rule_id)) {
+			continue;
+		}
+		memcpy(&g_tpm_db.mng_db.api_data[loop], api_data,
+			sizeof(struct tpm_db_mng_api_data_t));
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_del
+*
+* DESCRIPTION: del api entry for a api rule id
+*
+* INPUTS:
+*           rule_id
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_del(int rule_id)
+{
+	int loop = 0;
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if ((!g_tpm_db.mng_db.api_data[loop].valid)
+		     || (g_tpm_db.mng_db.api_data[loop].api_rule_id != rule_id)) {
+			continue;
+		}
+		TPM_MEMSET_ZERO(g_tpm_db.mng_db.api_data[loop]);
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_type_first_get
+*
+* DESCRIPTION: get the first valid api entry for a api type
+*
+* INPUTS:
+*           cap_api_type
+*           api_data
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_type_first_get(
+	enum tpm_mng_api_type_t     cap_api_type,
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int loop = 0;
+
+	IF_NULL(TPM_DB_MOD, api_data);
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if ((!g_tpm_db.mng_db.api_data[loop].valid)
+		     || (g_tpm_db.mng_db.api_data[loop].cap_api_type != cap_api_type)) {
+			continue;
+		}
+		memcpy(api_data, &g_tpm_db.mng_db.api_data[loop],
+			sizeof(struct tpm_db_mng_api_data_t));
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_entry_type_next_get
+*
+* DESCRIPTION: get next valid api entry for a api type
+*
+* INPUTS:
+*
+* OUTPUTS:
+*           api_data
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_api_entry_type_next_get(
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int loop = 0;
+	int this = TPM_FALSE;
+
+	IF_NULL(TPM_DB_MOD, api_data);
+
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_MAX; loop++) {
+		if ((!g_tpm_db.mng_db.api_data[loop].valid)
+		     || (g_tpm_db.mng_db.api_data[loop].cap_api_type != api_data->cap_api_type)) {
+			continue;
+		}
+
+		if (TPM_TRUE == this) {
+			/* this is next */
+			memcpy(api_data, &g_tpm_db.mng_db.api_data[loop],
+				sizeof(struct tpm_db_mng_api_data_t));
+			return TPM_OK;
+		} else if (g_tpm_db.mng_db.api_data[loop].api_rule_id == api_data->api_rule_id)
+			this = TPM_TRUE;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cap_hit_num_get
+*
+* DESCRIPTION: get hit number of a cap
+*
+* INPUTS:
+*           api_type
+*           cap_field_bm
+*
+* OUTPUTS:
+*           hit_number
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cap_hit_num_get(
+	enum tpm_mng_api_type_t   api_type,
+	unsigned int		  rule_type,
+	enum tpm_field_match_t    cap_field_bm,
+	enum tpm_vlan_num_enum_t  vlan_num,
+	int                       *hit_number)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, hit_number);
+
+	/* get from tpm_db */
+	for (i = 0; i < TPM_DB_MNG_CAP_MAX; i++) {
+		if (!g_tpm_db.mng_db.cap_cfg[i].valid)
+			break;
+		if (g_tpm_db.mng_db.cap_cfg[i].cap_api_type != api_type)
+			continue;
+		if (g_tpm_db.mng_db.cap_cfg[i].cap_field_bm != cap_field_bm)
+			continue;
+		if (g_tpm_db.mng_db.cap_cfg[i].rule_type != rule_type)
+			continue;
+		if (g_tpm_db.mng_db.cap_cfg[i].vlan_num != vlan_num)
+			continue;
+
+		/* here we find the cap */
+		*hit_number = g_tpm_db.mng_db.cap_cfg[i].hit_number;
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cmp_prec
+*
+* DESCRIPTION: The routine compares two caps according to the rule precedence
+*
+* INPUTS:
+*	rl1 - the first cap
+*	rl2 - the second cap
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	if cap1<cap2 returns -1, if cap1>cap2 returns 1, else returns 0
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_db_mng_cmp_prec(const void *cap1, const void *cap2)
+{
+	IF_NULL(TPM_DB_MOD, cap1);
+	IF_NULL(TPM_DB_MOD, cap2);
+
+	if (((struct tpm_db_mng_cap_conf_t *)cap1)->rule_type < ((struct tpm_db_mng_cap_conf_t *)cap2)->rule_type)
+		return -1;
+	else if (((struct tpm_db_mng_cap_conf_t *)cap1)->rule_type > ((struct tpm_db_mng_cap_conf_t *)cap2)->rule_type)
+		return 1;
+	else if (((struct tpm_db_mng_cap_conf_t *)cap1)->prec < ((struct tpm_db_mng_cap_conf_t *)cap2)->prec)
+		return -1;
+	else if (((struct tpm_db_mng_cap_conf_t *)cap1)->prec > ((struct tpm_db_mng_cap_conf_t *)cap2)->prec)
+		return 1;
+	else
+		return 0;
+}
+
+/*******************************************************************************
+* tpm_db_mng_pub_cap_get
+*
+* DESCRIPTION: get all the public caps that user configures
+*
+* INPUTS:
+*           api_type
+*           field_match_bm
+*           flow_cap_arr
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_pub_cap_get(struct tpm_db_mng_cap_conf_t cap_arr[],
+					int  *arr_len)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, cap_arr);
+	IF_NULL(TPM_DB_MOD, arr_len);
+
+	*arr_len = 0;
+
+	/* get from tpm_db */
+	for (i = 0; i < TPM_DB_MNG_CAP_MAX; i++) {
+		if (!g_tpm_db.mng_db.cap_cfg[i].valid)
+			break;
+	}
+
+	*arr_len = i;
+	memcpy(cap_arr, g_tpm_db.mng_db.cap_cfg, (i * sizeof(struct tpm_db_mng_cap_conf_t)));
+
+	sort(&cap_arr[0], *arr_len,
+		sizeof(struct tpm_db_mng_cap_conf_t), tpm_db_mng_cmp_prec, NULL);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_pub_cap_set
+*
+* DESCRIPTION: set public caps that user configures
+*
+* INPUTS:
+*           api_type
+*           cap
+*
+* OUTPUTS:
+*           NONE.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_pub_cap_set(enum tpm_mng_api_type_t cap_api_type, struct tpm_init_cap_conf_t *cap)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, cap);
+
+	/* get free slot from tpm_db */
+	for (i = 0; i < TPM_DB_MNG_CAP_MAX; i++) {
+		if (!g_tpm_db.mng_db.cap_cfg[i].valid)
+			break;
+	}
+
+	if (i == TPM_DB_MNG_CAP_MAX) {
+		TPM_OS_ERROR(TPM_PRS_MOD, "No more cap slot\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	g_tpm_db.mng_db.cap_cfg[i].valid = TPM_TRUE;
+	g_tpm_db.mng_db.cap_cfg[i].cap_field_bm = cap->field_match_bm;
+	g_tpm_db.mng_db.cap_cfg[i].prec = cap->precedence;
+	g_tpm_db.mng_db.cap_cfg[i].hit_number = cap->max_port_hits;
+	g_tpm_db.mng_db.cap_cfg[i].vlan_num = cap->tag_num;
+	g_tpm_db.mng_db.cap_cfg[i].rule_type = cap->rule_type;
+	g_tpm_db.mng_db.cap_cfg[i].cap_api_type = cap_api_type;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_virt_pid_get
+*
+* DESCRIPTION: get virt_pid from gemport
+*
+* INPUTS:
+*	       gemport:
+*
+* OUTPUTS:
+*	       virt_port_id
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_virt_pid_get(
+	int           gemport,
+	int          *virt_port_id)
+{
+	int i;
+	IF_NULL(TPM_DB_MOD, virt_port_id);
+
+	for (i = 0; i < TPM_DB_MNG_VIRT_PID_MAX; i++) {
+		if (!g_tpm_db.mng_db.virt_pid_cfg[i].valid)
+			continue;
+		if (g_tpm_db.mng_db.virt_pid_cfg[i].gemport != gemport)
+			continue;
+
+		/* here we found it */
+		*virt_port_id = i;
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+
+/*******************************************************************************
+* tpm_db_mng_flt_def_rule_set
+*
+* DESCRIPTION: set default filter rule ID
+*
+* INPUTS:
+*	       rule_type:
+*	       field_bm:
+*	       vlan_num:
+*	       rule_id:
+*
+* OUTPUTS:
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_flt_def_rule_set(
+	unsigned int			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			rule_id)
+{
+	int loop;
+
+	for (loop = 0; loop < TPM_NUM_MAX_FILTER_TYPE; loop++) {
+		if (g_tpm_db.mng_db.filter_def_rule[loop].valid)
+			continue;
+
+		/* here we found a slot */
+		g_tpm_db.mng_db.filter_def_rule[loop].valid = TPM_TRUE;
+		g_tpm_db.mng_db.filter_def_rule[loop].filter_type.rule_type = rule_type;
+		g_tpm_db.mng_db.filter_def_rule[loop].filter_type.cap_field_bm = field_bm;
+		g_tpm_db.mng_db.filter_def_rule[loop].filter_type.vlan_num = vlan_num;
+		g_tpm_db.mng_db.filter_def_rule[loop].def_rule_id = rule_id;
+
+		return TPM_OK;
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_mng_flt_def_rule_get
+*
+* DESCRIPTION: get default filter rule ID
+*
+* INPUTS:
+*	       rule_type:
+*	       field_bm:
+*	       vlan_num:
+*
+* OUTPUTS:
+*	       rule_id:
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_flt_def_rule_get(
+	unsigned int			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*rule_id)
+{
+	int loop;
+
+	for (loop = 0; loop < TPM_NUM_MAX_FILTER_TYPE; loop++) {
+
+		if (g_tpm_db.mng_db.filter_def_rule[loop].valid != TPM_TRUE)
+			continue;
+
+		if (g_tpm_db.mng_db.filter_def_rule[loop].filter_type.rule_type != rule_type)
+			continue;
+
+		if (g_tpm_db.mng_db.filter_def_rule[loop].filter_type.cap_field_bm != field_bm)
+			continue;
+
+		if (g_tpm_db.mng_db.filter_def_rule[loop].filter_type.vlan_num != vlan_num)
+			continue;
+
+		/* here we found it */
+		*rule_id = g_tpm_db.mng_db.filter_def_rule[loop].def_rule_id;
+
+		TPM_MEMSET_ZERO(g_tpm_db.mng_db.filter_def_rule[loop]);
+		return TPM_OK;
+	}
+
+	return TPM_NO_SUCH;
+}
+
+/*******************************************************************************
+* tpm_db_mng_virt_pid_add
+*
+* DESCRIPTION: add new virt_pid for gemport
+*
+* INPUTS:
+*	       gemport:
+*
+* OUTPUTS:
+*	       virt_port_id
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_virt_pid_add(
+	int           gemport,
+	int          *virt_port_id)
+{
+	int i;
+	int api_loop;
+
+	IF_NULL(TPM_DB_MOD, virt_port_id);
+
+	for (i = 0; i < TPM_DB_MNG_VIRT_PID_MAX; i++) {
+		if (g_tpm_db.mng_db.virt_pid_cfg[i].valid)
+			continue;
+
+		/* here we found a free slot */
+		g_tpm_db.mng_db.virt_pid_cfg[i].valid = TPM_TRUE;
+		g_tpm_db.mng_db.virt_pid_cfg[i].gemport = gemport;
+		*virt_port_id = i;
+		return TPM_OK;
+	}
+
+	/* no free slot, need to remove a unused one */
+	for (i = 0; i < TPM_DB_MNG_VIRT_PID_MAX; i++) {
+		/* go through api db */
+		for (api_loop = 0; api_loop < TPM_DB_MNG_API_RULE_MAX; api_loop++) {
+			/* go through api db */
+			if (!g_tpm_db.mng_db.api_data[api_loop].valid)
+				continue;
+
+			if (g_tpm_db.mng_db.api_data[api_loop].match_key.port.port_type != TPM_CLASS_VIRT_PORT)
+				continue;
+
+			if (g_tpm_db.mng_db.api_data[api_loop].match_key.port.class_port
+			      != g_tpm_db.mng_db.virt_pid_cfg[i].gemport)
+				continue;
+
+			break;
+		}
+		if (api_loop == TPM_DB_MNG_API_RULE_MAX) {
+			*virt_port_id = i;
+			g_tpm_db.mng_db.virt_pid_cfg[i].gemport = gemport;
+			return TPM_OK;
+		}
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_mng_mc_atu_add
+*
+* DESCRIPTION: set Multicast switch related info into DB.
+*
+* INPUTS:
+*	       switch_port - switch UNI port
+*              mac         - MAC address
+*
+* OUTPUTS:
+*	       None.
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_atu_add(unsigned int switch_port, unsigned char *mac)
+{
+	int loop;
+
+	IF_NULL(TPM_DB_MOD, mac);
+
+	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
+		/* If MAC exist, increase ref_cnt */
+		if ((!memcmp(mac, g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].gdmac, MAC_ADDR_SIZE)) &&
+		    g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt > 0) {
+			g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt++;
+			return TPM_OK;
+		}
+	}
+
+	/* Find a free slot */
+	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
+		if (g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt == 0) {
+			memcpy(g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].gdmac, mac, MAC_ADDR_SIZE);
+			g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt++;
+			return TPM_OK;
+		}
+	}
+
+	/* No resource */
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_mng_mc_atu_del
+*
+* DESCRIPTION: decrease ref_cnt of MAC.
+*
+* INPUTS:
+*	       switch_port - switch UNI port
+*              mac         - MAC address
+*
+* OUTPUTS:
+*	       ref_cnt     - MAC reference count after del.
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_atu_del(unsigned int switch_port, unsigned char *mac, unsigned int *ref_cnt)
+{
+	int loop;
+
+	IF_NULL(TPM_DB_MOD, mac);
+	IF_NULL(TPM_DB_MOD, ref_cnt);
+
+	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
+		/* If MAC exist, increase ref_cnt */
+		if ((!memcmp(mac, g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].gdmac, MAC_ADDR_SIZE)) &&
+		    g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt > 0) {
+			g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt--;
+			*ref_cnt = g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt;
+			return TPM_OK;
+		}
+	}
+
+	return TPM_NOT_FOUND;
+}
+
+/*******************************************************************************
+* tpm_db_mng_mc_atu_get
+*
+* DESCRIPTION: Get the atu info with MAC on swicth port.
+*
+* INPUTS:
+*	       switch_port - switch UNI port
+*              mac         - MAC address
+*
+* OUTPUTS:
+*	       atu         - ATU info.
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_atu_get(unsigned int switch_port, unsigned char *mac, struct tpm_db_mng_mc_atu *atu)
+{
+	int loop;
+
+	IF_NULL(TPM_DB_MOD, mac);
+	IF_NULL(TPM_DB_MOD, atu);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, switch_port,
+				   TPM_NUM_MAX_UNI_PORTS - 1, "invalid switch port");
+
+	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
+		/* If MAC exist, increase ref_cnt */
+		if ((!memcmp(mac, g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].gdmac, MAC_ADDR_SIZE)) &&
+		    g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop].mac_ref_cnt > 0) {
+			memcpy(atu,
+			       &g_tpm_db.mng_db.mc_switch[switch_port].switch_atu[loop],
+			       sizeof(struct tpm_db_mng_mc_atu));
+			return TPM_OK;
+		}
+	}
+
+	return TPM_NOT_FOUND;
+}
+
+/*******************************************************************************
+* tpm_db_mng_mc_vtu_set
+*
+* DESCRIPTION: Set VTU for vid on the switch port woth egress mode.
+*
+* INPUTS:
+*	       switch_port - switch UNI port
+*              vid         - VLAN vid
+*              egress_mode - egress mode for the vlan on the port
+*
+* OUTPUTS:
+*	       None.
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_vtu_set(unsigned int switch_port, unsigned int vid, enum tpm_sw_vlan_egress_mode_t egress_mode)
+{
+
+	/* Para check */
+	if (switch_port >= TPM_NUM_MAX_UNI_PORTS ||
+	    vid > TPM_MAX_VLAN_ID_VALUE ||
+	    egress_mode > TPM_SW_VLAN_EGRESS_KEEP_VLAN)
+		return TPM_BAD_PARAM;
+
+	g_tpm_db.mng_db.mc_switch[switch_port].switch_vtu.vid[vid] = vid;
+	g_tpm_db.mng_db.mc_switch[switch_port].switch_vtu.egress_mode[vid] = egress_mode;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_mc_vtu_del
+*
+* DESCRIPTION:  Remove switch port from member of VID.
+*
+* INPUTS:
+*	       switch_port - switch UNI port
+*              vid         - VLAN vid
+*
+* OUTPUTS:
+*	       None.
+*
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_vtu_del(unsigned int switch_port, unsigned int vid)
+{
+
+	/* Para check */
+	if (switch_port >= TPM_NUM_MAX_UNI_PORTS ||
+	    vid > TPM_MAX_VLAN_ID_VALUE)
+		return TPM_BAD_PARAM;
+
+	g_tpm_db.mng_db.mc_switch[switch_port].switch_vtu.vid[vid] = TPM_INVALID_VLAN_ID;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_mng_mc_init()
+*
+* DESCRIPTION: Perform DB Initialization for Multicast in Mng.
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_mc_init(void)
+{
+	int i, switch_port;
+
+	/* Initlize VTU vid to invalid value, 0xFFFF */
+	for (switch_port = 0; switch_port < TPM_NUM_MAX_UNI_PORTS; switch_port++) {
+		for (i = 0; i < (TPM_MAX_VLAN_ID_VALUE + 1); i++)
+			g_tpm_db.mng_db.mc_switch[switch_port].switch_vtu.vid[i] = TPM_INVALID_VLAN_ID;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cm_rule_add()
+*
+* DESCRIPTION: Add CnM rule into DB.
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cm_rule_add(
+	struct tpm_cnm_key_t	*cnm_key,
+	struct tpm_pkt_action_t	*action)
+{
+	int ruleSet;
+	int ret;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, cnm_key->rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+
+	/* get ruleSet from DB */
+	ret = tpm_db_mng_cm_ruleset_get(&cnm_key->match_key.port, &ruleSet);
+	IF_ERROR_STR(TPM_MNG_MOD, ret, "fail to get ruleSet from DB\n");
+
+	memcpy(&g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][cnm_key->rule_num].action,
+		action, sizeof(struct tpm_pkt_action_t));
+	memcpy(&g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][cnm_key->rule_num].cnm_key,
+		cnm_key, sizeof(struct tpm_cnm_key_t));
+	g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][cnm_key->rule_num].valid = TPM_TRUE;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cm_rule_get()
+*
+* DESCRIPTION: get CnM rule from DB.
+*
+* INPUTS:
+*	port
+*	rule_num
+*
+* OUTPUTS
+*	cnm_rule
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cm_rule_get(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num,
+	struct tpm_db_mng_ctc_cnm_rule_t *cnm_rule)
+{
+	int ruleSet;
+	int ret;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+
+	/* get ruleSet from DB */
+	ret = tpm_db_mng_cm_ruleset_get(port, &ruleSet);
+	IF_ERROR_STR(TPM_MNG_MOD, ret, "fail to get ruleSet from DB\n");
+
+	memcpy(cnm_rule,
+		&g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][rule_num],
+		sizeof(struct tpm_db_mng_ctc_cnm_rule_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cm_rule_del()
+*
+* DESCRIPTION: Delete CnM rule from DB.
+*
+* INPUTS:
+*	port
+*	rule_num
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cm_rule_del(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num)
+{
+	int ruleSet;
+	int ret;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+
+	/* get ruleSet from DB */
+	ret = tpm_db_mng_cm_ruleset_get(port, &ruleSet);
+	IF_ERROR_STR(TPM_MNG_MOD, ret, "fail to get ruleSet from DB\n");
+
+	TPM_MEMSET_ZERO(g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][rule_num]);
+
+	g_tpm_db.mng_db.cnm_data.cnm_rule[ruleSet][rule_num].valid = TPM_FALSE;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_mng_cm_ruleset_set()
+*
+* DESCRIPTION: set ruleSet of a certain port into DB.
+*
+* INPUTS:
+*	port
+*	ruleSet
+*
+* OUTPUTS:
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cm_ruleset_set(
+	struct tpm_class_port_t	*port,
+	unsigned int ruleSet)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, ruleSet,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, port->class_port,
+		TPM_NUM_MAX_UNI_PORTS_BM, "invalid port number");
+
+	memcpy(&g_tpm_db.mng_db.cnm_data.src_port[ruleSet],
+		port, sizeof(struct tpm_class_port_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_cm_ruleset_get()
+*
+* DESCRIPTION: get ruleSet of a certain port from DB.
+*
+* INPUTS:
+*	port
+*
+* OUTPUTS:
+*	ruleSet
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_cm_ruleset_get(
+	struct tpm_class_port_t	*port,
+	unsigned int *ruleSet)
+{
+	int loop;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, port->class_port,
+		TPM_NUM_MAX_UNI_PORTS_BM, "invalid port number");
+	for (loop = 0; loop < MV_PP2_CLS_C4_GRPS_NUM; loop++) {
+		if (port->class_port != g_tpm_db.mng_db.cnm_data.src_port[loop].class_port)
+			continue;
+		*ruleSet = loop;
+		return TPM_OK;
+	}
+
+	return TPM_NOT_FOUND;
+}
+
+/*******************************************************************************
+* tpm_db_mng_c2_lu_type_cntr_op()
+*
+* DESCRIPTION: increase or decrease cntr of C2 lu type.
+*
+* INPUTS:
+*	lu_type
+*	increase	- true means increase cntr, false decrease cntr
+*
+* OUTPUTS:
+*	ruleSet
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_c2_lu_type_cntr_op(unsigned int lu_type,
+	unsigned char increase)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, lu_type,
+		TPM_C2_LKP_TYPE_MAX, "invalid lu_type number\n");
+
+	if (TPM_TRUE == increase)
+		g_tpm_db.mng_db.c2_lu_type_cntr[lu_type]++;
+	else
+		g_tpm_db.mng_db.c2_lu_type_cntr[lu_type]--;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_free_c2_lu_type_get()
+*
+* DESCRIPTION: get a free C2 lu type.
+*
+* INPUTS:
+*
+* OUTPUTS:
+*	lu_type
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mng_free_c2_lu_type_get(unsigned char *lu_type)
+{
+	int loop;
+
+	for (loop = 0; loop < TPM_C2_LKP_TYPE_MAX; loop++) {
+		if (g_tpm_db.mng_db.c2_lu_type_cntr[loop])
+			continue;
+
+		g_tpm_db.mng_db.c2_lu_type_cntr[loop]++;
+		*lu_type = loop;
+		return TPM_OK;
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_data_allocate
+*
+* DESCRIPTION: The routine allocate a tpm_db_mng_api_data_t structure, since
+*		it is 1KB and should not be used as local param in routine.
+*
+* INPUTS:
+*              NONE
+*
+* OUTPUTS:
+*           mng_api_data
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_db_mng_api_data_allocate(
+	struct tpm_db_mng_api_data_t **api_data)
+{
+	/* Allocate tpm_db_mng_api_data_t from mempool */
+	*api_data = (struct tpm_db_mng_api_data_t *)tpm_common_mempool_alloc(g_tpm_db.mng_db.api_data_pool);
+	if (NULL == *api_data) {
+		/* no free slot anymore */
+		TPM_OS_ERROR(TPM_DB_MOD, "no free api_data mem\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_data_release
+*
+* DESCRIPTION: The routine release a tpm_db_mng_api_data_t structure that was allocated by routine.
+*		tpm_db_mng_api_data_allocate before.
+* INPUTS:
+*           mng_api_data
+*
+* OUTPUTS:
+*           NONE
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_db_mng_api_data_release(
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	tpm_common_mempool_free(g_tpm_db.mng_db.api_data_pool, api_data);
+}
+
+/*******************************************************************************
+* tpm_db_mng_api_data_pool_init
+*
+* DESCRIPTION: The routine create a tpm_db_mng_api_data_t structure mem pool .
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_db_mng_api_data_pool_init(void)
+{
+	g_tpm_db.mng_db.api_data_pool = tpm_common_mempool_create
+					(TPM_DB_MNG_API_DATA_POOL_SIZE,
+					sizeof(struct tpm_db_mng_api_data_t),
+					GFP_USER);
+	if (NULL == g_tpm_db.mng_db.api_data_pool) {
+		TPM_OS_ERROR(TPM_DB_MOD, "failed allocating g_tpm_db_mng_api_data_pool\n");
+		return TPM_FAIL;
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_c2_init()
+*
+* DESCRIPTION: Perform DB Initialization for C2 section.
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_c2_init(void)
+{
+	int i;
+
+	/* Clear C2 db */
+	memset(&g_tpm_db.c2_db, 0, sizeof(struct tpm_db_c2_t));
+
+	/* Init c2_hw_idx to C2 corresponding c2 hw index in c2 data db and index db */
+	for (i = 0; i < TPM_C2_ENTRY_MAX; i++) {
+		g_tpm_db.c2_db.c2_data_db[i].valid = TPM_C2_ENTRY_INVALID;
+		g_tpm_db.c2_db.c2_index_db[i].valid = TPM_C2_ENTRY_INVALID;
+		g_tpm_db.c2_db.c2_index_db[i].c2_hw_idx = i;
+	}
+
+	/* Init C2 list head */
+	INIT_LIST_HEAD(&g_tpm_db.c2_db.c2_free_head_db);
+	for (i = 0; i < TPM_C2_LKP_TYPE_MAX; i++)
+		INIT_LIST_HEAD(&g_tpm_db.c2_db.c2_lu_type_head_db[i]);
+
+	/* Init free list, last entry is used for default entry, always not avaliable */
+	for (i = TPM_C2_LAST_ENTRY - 1; i >= 0; i--) {
+		list_add(&g_tpm_db.c2_db.c2_index_db[i].list_node, &g_tpm_db.c2_db.c2_free_head_db);
+		/* Change index node valid status after adding to free list */
+		g_tpm_db.c2_db.c2_index_db[i].valid = TPM_C2_ENTRY_VALID;
+	}
+	/* Reserve the last one for default miss entry */
+	g_tpm_db.c2_db.c2_index_db[TPM_C2_LAST_ENTRY].valid = TPM_C2_ENTRY_VALID;
+	g_tpm_db.c2_db.c2_data_db[TPM_C2_LAST_ENTRY].valid = TPM_C2_ENTRY_VALID;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_fl_ctrl_set
+*
+* DESCRIPTION: The routine sets the CLS control structure
+*
+* INPUTS:
+*	fl_ctrl - flow control structure
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_fl_ctrl_set(struct tpm_db_cls_fl_ctrl_t         *fl_ctrl)
+{
+	 IF_NULL(TPM_DB_MOD, fl_ctrl);
+
+	 memcpy(&g_tpm_db.cls_db.fl_ctrl, fl_ctrl, sizeof(struct tpm_db_cls_fl_ctrl_t));
+
+	 return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_fl_ctrl_get
+*
+* DESCRIPTION: The routine gets the CLS control structure
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	fl_ctrl - flow control structure
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_fl_ctrl_get(struct tpm_db_cls_fl_ctrl_t         *fl_ctrl)
+{
+	 IF_NULL(TPM_DB_MOD, fl_ctrl);
+
+	 memcpy(fl_ctrl, &g_tpm_db.cls_db.fl_ctrl, sizeof(struct tpm_db_cls_fl_ctrl_t));
+
+	 return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_fl_rule_set
+*
+* DESCRIPTION: The routine sets a single rule in a rule flow
+*
+* INPUTS:
+*	off - the rule offset
+*	fl_rule - the flow the rule is in
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_fl_rule_set(unsigned int			off,
+			struct tpm_db_cls_fl_rule_t	*fl_rule)
+{
+	IF_NULL(TPM_DB_MOD, fl_rule);
+
+	if (MV_PP2_CLS_FLOWS_TBL_SIZE <= off) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+	memcpy(&g_tpm_db.cls_db.fl_rule[off], fl_rule, sizeof(struct tpm_db_cls_fl_rule_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_fl_rule_get
+*
+* DESCRIPTION: The routine gets a single rule in a rule flow
+*
+* INPUTS:
+*	off - the rule offset
+*
+* OUTPUTS:
+*	fl_rule - the flow the rule is in
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_fl_rule_get(unsigned int			off,
+			struct tpm_db_cls_fl_rule_t	*fl_rule)
+{
+	 IF_NULL(TPM_DB_MOD, fl_rule);
+
+	if (MV_PP2_CLS_FLOWS_TBL_SIZE <= off) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+	memcpy(fl_rule, &g_tpm_db.cls_db.fl_rule[off], sizeof(struct tpm_db_cls_fl_rule_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_fl_rule_list_get
+*
+* DESCRIPTION: The routine gets a whole rule flow
+*
+* INPUTS:
+*	off - the first rule offset
+*	len - the flow length
+*
+* OUTPUTS:
+*	fl_rl_list - the flow the rules are in
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_fl_rule_list_get(unsigned int		off,
+			    unsigned int		len,
+			    struct tpm_db_cls_fl_rule_t	*fl_rl_list)
+{
+	IF_NULL(TPM_DB_MOD, fl_rl_list);
+
+	if (MV_PP2_CLS_FLOWS_TBL_SIZE <= off ||
+	    MV_PP2_CLS_FLOWS_TBL_SIZE <= off + len) {
+		TPM_OS_ERROR(TPM_DB_MOD, "requested rule list too big [offset=%d length=%d]\n", off, len);
+		return TPM_BAD_PARAM;
+	}
+
+	memcpy(fl_rl_list, &g_tpm_db.cls_db.fl_rule[off],
+			sizeof(struct tpm_db_cls_fl_rule_t) * len);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_lkp_dcod_set
+*
+* DESCRIPTION: The routine sets a lookup decode entry
+*
+* INPUTS:
+*	fl_log_id - index of the entry (logical flow ID)
+*	lkp_dcod - the lookup decode entry structure
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_lkp_dcod_set(unsigned int			fl_log_id,
+			struct tpm_db_cls_lkp_dcod_t	*lkp_dcod)
+{
+	IF_NULL(TPM_DB_MOD, lkp_dcod);
+
+	if (TPM_MNG_FLOW_ID_MAX <= fl_log_id) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	memcpy(&g_tpm_db.cls_db.lkp_dcod[fl_log_id], lkp_dcod, sizeof(struct tpm_db_cls_lkp_dcod_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_lkp_dcod_get
+*
+* DESCRIPTION: The routine gets a lookup decode entry
+*
+* INPUTS:
+*	fl_log_id - index of the entry (logical flow ID)
+*
+* OUTPUTS:
+*	lkp_dcod - the lookup decode entry structure
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_lkp_dcod_get(unsigned int		fl_log_id,
+			struct tpm_db_cls_lkp_dcod_t	*lkp_dcod)
+{
+	IF_NULL(TPM_DB_MOD, lkp_dcod);
+
+	if (TPM_MNG_FLOW_ID_MAX <= fl_log_id) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+	memcpy(lkp_dcod, &g_tpm_db.cls_db.lkp_dcod[fl_log_id], sizeof(struct tpm_db_cls_lkp_dcod_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_rl_off_lkp_dcod_get
+*
+* DESCRIPTION: The routine returns the lookup decode entry for a flow rule
+*
+* INPUTS:
+*	rl_off - flow rule offset to search
+*
+* OUTPUTS:
+*	lkp_dcod - the lookup decode entry structure
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_rl_off_lkp_dcod_get(unsigned short		rl_off,
+				struct tpm_db_cls_lkp_dcod_t	*lkp_dcod)
+{
+	unsigned int			i;
+	struct tpm_db_cls_lkp_dcod_t	*p_lkp_dcod;
+
+	IF_NULL(TPM_DB_MOD, lkp_dcod);
+
+	if (MV_PP2_CLS_FLOWS_TBL_SIZE <= rl_off) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	for (i = 0; i < TPM_MNG_FLOW_ID_MAX; i++) {
+		p_lkp_dcod = &g_tpm_db.cls_db.lkp_dcod[i];
+		if (p_lkp_dcod->flow_off <= rl_off && p_lkp_dcod->flow_off + p_lkp_dcod->flow_len  >= rl_off)
+			break;
+	}
+
+	if (i == TPM_MNG_FLOW_ID_MAX) {
+		TPM_OS_ERROR(TPM_DB_MOD, "rule offset [%d] not found\n", rl_off);
+		return TPM_NOT_FOUND;
+	}
+
+	memcpy(lkp_dcod, &g_tpm_db.cls_db.lkp_dcod[i], sizeof(struct tpm_db_cls_lkp_dcod_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_rl_off_free_nr
+*
+* DESCRIPTION: The routine returns the number of free logical rule entries
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	free_nr - number of free logical rule entries
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_rl_off_free_nr(unsigned int		*free_nr)
+{
+	IF_NULL(TPM_DB_MOD, free_nr);
+
+	*free_nr = ((TPM_CLS_LOG2OFF_TBL_SIZE) - g_tpm_db.cls_db.log2off[TPM_CLS_FREE_LOG2OFF]);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_rl_off_free_set
+*
+* DESCRIPTION: The routine allocates a new logical rule number and assignes it with offset
+*
+* INPUTS:
+*	off - the offset the rule is at
+*
+* OUTPUTS:
+*	log - the new logical rule number
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_rl_off_free_set(unsigned short	off,
+			   unsigned short	*log)
+{
+	IF_NULL(TPM_DB_MOD, log);
+
+	if (MV_PP2_CLS_FLOWS_TBL_SIZE <= off) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	if ((TPM_CLS_LOG2OFF_TBL_SIZE - g_tpm_db.cls_db.log2off[TPM_CLS_FREE_LOG2OFF]) == 0)
+		return TPM_NO_RESOURCE;
+
+	*log = g_tpm_db.cls_db.log2off[TPM_CLS_FREE_LOG2OFF];
+
+	g_tpm_db.cls_db.log2off[*log] = off;
+
+	g_tpm_db.cls_db.log2off[TPM_CLS_FREE_LOG2OFF]++;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_rl_off_get
+*
+* DESCRIPTION: The routine returns the offset of a rule according to logical rule number
+*
+* INPUTS:
+*	log - the new logical rule number
+*
+* OUTPUTS:
+*	off - the offset the rule is at
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_rl_off_get(unsigned short	*off,
+			unsigned short		log)
+{
+	IF_NULL(TPM_DB_MOD, off);
+
+	if (TPM_CLS_LOG2OFF_TBL_SIZE < log) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_CLS_FREE_FL_LOG == g_tpm_db.cls_db.log2off[log])
+		return TPM_NO_RESOURCE;
+
+	*off = g_tpm_db.cls_db.log2off[log];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_rl_off_set
+*
+* DESCRIPTION: The routine updates a logical rule with a new offset
+*
+* INPUTS:
+*	off - the new offset the rule is at
+*	log - the logical rule number
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_error_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_db_cls_rl_off_set(unsigned short	off,
+			unsigned short		log)
+{
+	if (TPM_CLS_LOG2OFF_TBL_SIZE < log) {
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+	g_tpm_db.cls_db.log2off[log] = off;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_cls_init
+*
+* DESCRIPTION: The routine initializes the CLS DBs
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_db_cls_init(void)
+{
+	int	i;
+
+	/* set the CLS control to default values */
+	memset(&g_tpm_db.cls_db, 0, sizeof(g_tpm_db.cls_db));
+
+	g_tpm_db.cls_db.fl_ctrl.f_end = MV_PP2_CLS_FLOWS_TBL_SIZE - 1;
+
+	for (i = TPM_CLS_LOG2OFF_START; i < TPM_CLS_LOG2OFF_TBL_SIZE; i++)
+		g_tpm_db.cls_db.log2off[i] = TPM_CLS_FREE_FL_LOG;
+
+	g_tpm_db.cls_db.log2off[TPM_CLS_FREE_LOG2OFF] = TPM_CLS_LOG2OFF_START;
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_db_pme_cmd_first_free_set()
+*
+* DESCRIPTION: Update the first free PME instruction entry.
+*
+* INPUTS:
+*          area_type  - PME instruction table divide type
+*          first_free - New first free PME entry
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_cmd_first_free_set(enum tpm_pme_cmd_area_type_t area_type, unsigned int first_free)
+{
+	switch (area_type) {
+	case TPM_PME_CMD_AREA_JMP:
+		if ((g_tpm_db.pme_db.pme_misc_data.jmp_start +
+		    g_tpm_db.pme_db.pme_misc_data.jmp_area_size) <= first_free)
+			return TPM_FULL;
+		g_tpm_db.pme_db.pme_misc_data.jmp_first_free = first_free;
+		break;
+	case TPM_PME_CMD_AREA_TEMPL:
+		if ((g_tpm_db.pme_db.pme_misc_data.templ_start +
+		    g_tpm_db.pme_db.pme_misc_data.templ_area_size) <= first_free)
+			return TPM_FULL;
+		g_tpm_db.pme_db.pme_misc_data.templ_first_free = first_free;
+		break;
+	case TPM_PME_CMD_AREA_SUBR:
+		if ((g_tpm_db.pme_db.pme_misc_data.subr_start +
+		    g_tpm_db.pme_db.pme_misc_data.subr_area_size) <= first_free)
+			return TPM_FULL;
+		g_tpm_db.pme_db.pme_misc_data.subr_first_free = first_free;
+		break;
+	default:
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_cmd_first_free_get()
+*
+* DESCRIPTION: Get the first free PME instruction entry.
+*
+* INPUTS:
+*          area_type  - PME instruction table divide type
+*
+* OUTPUTS:
+*          first_free - First available CMD entry
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_cmd_first_free_get(enum tpm_pme_cmd_area_type_t area_type, unsigned int *first_free)
+{
+	IF_NULL(TPM_DB_MOD, first_free);
+
+	switch (area_type) {
+	case TPM_PME_CMD_AREA_JMP:
+		*first_free = g_tpm_db.pme_db.pme_misc_data.jmp_first_free;
+		break;
+	case TPM_PME_CMD_AREA_TEMPL:
+		*first_free = g_tpm_db.pme_db.pme_misc_data.templ_first_free;
+		break;
+	case TPM_PME_CMD_AREA_SUBR:
+		*first_free = g_tpm_db.pme_db.pme_misc_data.subr_first_free;
+		break;
+	default:
+		TPM_OS_ERROR(TPM_DB_MOD, "Invalid parameter\n");
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_unit_size_get()
+*
+* DESCRIPTION: Get the range unit size.
+*
+* INPUTS:
+*          tbl_idx   - data table index, 0 - private, 1 - share
+*          rng_idx   - range index
+*
+* OUTPUTS:
+*          unit_size - Range data unit size
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_rng_unit_size_get(unsigned int tbl_idx, unsigned int rng_idx, unsigned int *unit_size)
+{
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, unit_size);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_PRI_RNG_MAX, "Invalid Range Index");
+		*unit_size = g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx].unit_size;
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_SHA_RNG_MAX, "Invalid range index");
+		*unit_size = g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx].unit_size;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_info_get()
+*
+* DESCRIPTION: Get the range management info.
+*
+* INPUTS:
+*          tbl_idx  - data table index, 0 - private, 1 - share
+*          rng_idx  - range index
+*
+* OUTPUTS:
+*          rng_mng_info - range management information
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_rng_info_get(unsigned int tbl_idx,
+				 unsigned int rng_idx,
+				 struct tpm_pme_tbl_rng_t *rng_mng_info)
+{
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, rng_mng_info);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_PRI_RNG_MAX, "Invalid range index");
+		memcpy(rng_mng_info,
+		       &g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx],
+		       sizeof(struct tpm_pme_tbl_rng_t));
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_SHA_RNG_MAX, "Invalid range index");
+		memcpy(rng_mng_info,
+		       &g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx],
+		       sizeof(struct tpm_pme_tbl_rng_t));
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_unit_state_get()
+*
+* DESCRIPTION: Get the range unit state, occupied or not.
+*
+* INPUTS:
+*          tbl_idx  - data table index, 0 - private, 1 - share
+*          rng_idx  - range index
+*
+* OUTPUTS:
+*          state    - state array, one bit stands one unit
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_rng_unit_state_get(unsigned int tbl_idx,
+				       unsigned int rng_idx,
+				       unsigned int *state)
+{
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, state);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_PRI_RNG_MAX, "Invalid range index");
+		memcpy(state,
+		       &g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx].unit_state,
+		       sizeof(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx].unit_state));
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_SHA_RNG_MAX, "Invalid range index");
+		memcpy(state,
+		       &g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx].unit_state,
+		       sizeof(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx].unit_state));
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_unit_state_set()
+*
+* DESCRIPTION: Set the range unit state, occupied or not.
+*
+* INPUTS:
+*          tbl_idx  - data table index, 0 - private, 1 - share
+*          rng_idx  - range index
+*          state    - state array, one bit stands one unit
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_rng_unit_state_set(unsigned int tbl_idx,
+				       unsigned int rng_idx,
+				       unsigned int *state)
+{
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, state);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_PRI_RNG_MAX, "Invalid range index");
+		memcpy(&g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx].unit_state,
+		       state,
+		       sizeof(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[rng_idx].unit_state));
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, rng_idx, TPM_PME_SHA_RNG_MAX, "Invalid range index");
+		memcpy(&g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx].unit_state,
+		       state,
+		       sizeof(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[rng_idx].unit_state));
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_pme_data_free_db_idx_get()
+*
+* DESCRIPTION: Get the index of available DATA DB entry.
+*
+* INPUTS:
+*          tbl_idx - data table index
+*
+* OUTPUTS:
+*          db_idx - available data DB index.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_free_db_idx_get(unsigned int tbl_idx, unsigned int *db_idx)
+{
+	unsigned int db_max;
+	int i;
+
+	IF_NULL(TPM_DB_MOD, db_idx);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL)
+		db_max = TPM_PME_PRIVATE_SET_MAX;
+	else
+		db_max = TPM_PME_SHARE_SET_MAX;
+
+	for (i = 0; i < db_max; i++) {
+		if (tbl_idx == TPM_PME_PRIVATE_TBL &&
+		    g_tpm_db.pme_db.pri_data_db[i].valid == TPM_DATA_INVALID) {
+			*db_idx = i;
+			break;
+		}
+		if (tbl_idx == TPM_PME_SHARE_TBL &&
+		    g_tpm_db.pme_db.sha_data_db[i].valid == TPM_DATA_INVALID) {
+			*db_idx = i;
+			break;
+		}
+	}
+	if (i == db_max)
+		*db_idx = TPM_PME_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_set()
+*
+* DESCRIPTION: Set DATA DB entry.
+*
+* INPUTS:
+*          tbl_idx            - data table index, 0-private, 1-share
+*          db_idx             - db index.
+*          mod_data_set       - data db.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_set(unsigned int tbl_idx, unsigned int db_idx, struct tpm_pme_data_entry_set_t *mod_data_set)
+{
+	unsigned int db_max;
+
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, mod_data_set);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+	if (tbl_idx == TPM_PME_PRIVATE_TBL)
+		db_max = TPM_PME_PRIVATE_SET_MAX;
+	else
+		db_max = TPM_PME_SHARE_SET_MAX;
+	if (db_idx >= db_max)
+		return TPM_OUT_OF_RANGE;
+	/* Set DB */
+	if (tbl_idx == TPM_PME_PRIVATE_TBL)
+		memcpy(&g_tpm_db.pme_db.pri_data_db[db_idx],
+		       mod_data_set,
+		       sizeof(struct tpm_pme_data_entry_set_t));
+	else
+		memcpy(&g_tpm_db.pme_db.sha_data_db[db_idx],
+		       mod_data_set,
+		       sizeof(struct tpm_pme_data_entry_set_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_get()
+*
+* DESCRIPTION: Get DATA DB entry.
+*
+* INPUTS:
+*          tbl_idx            - data table index.
+*          db_idx             - db index.
+*
+* OUTPUTS:
+*          mod_data_set       - data db.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_data_get(unsigned int tbl_idx, unsigned int db_idx, struct tpm_pme_data_entry_set_t *mod_data_set)
+{
+	unsigned int db_max;
+
+	/* Param check */
+	IF_NULL(TPM_DB_MOD, mod_data_set);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Invalid table index%d\n", tbl_idx);
+	if (tbl_idx == TPM_PME_PRIVATE_TBL)
+		db_max = TPM_PME_PRIVATE_SET_MAX;
+	else
+		db_max = TPM_PME_SHARE_SET_MAX;
+	if (db_idx >= db_max)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_OUT_OF_RANGE, "Out of max DB index\n");
+	/* Set DB */
+	if (tbl_idx == TPM_PME_PRIVATE_TBL)
+		memcpy(mod_data_set,
+			&g_tpm_db.pme_db.pri_data_db[db_idx],
+			sizeof(struct tpm_pme_data_entry_set_t));
+	else
+		memcpy(mod_data_set,
+			&g_tpm_db.pme_db.sha_data_db[db_idx],
+			sizeof(struct tpm_pme_data_entry_set_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_instr_templ_set()
+*
+* DESCRIPTION: Set the instruction template to DB.
+*
+* INPUTS:
+*          db_idx      - instruction template DB index
+*          instr_templ - instruction template
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_instr_templ_set(unsigned int db_idx, struct tpm_pme_templ_data_t *instr_templ)
+{
+	IF_NULL(TPM_DB_MOD, instr_templ);
+
+	if (db_idx >= TPM_PME_INSTR_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_OUT_OF_RANGE, "Out of max DB index\n");
+
+	memcpy(&g_tpm_db.pme_db.templ_db[db_idx], instr_templ, sizeof(struct tpm_pme_templ_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_instr_templ_get()
+*
+* DESCRIPTION: Get the instruction template from DB.
+*
+* INPUTS:
+*          db_idx      - instruction template DB index
+*
+* OUTPUTS:
+*          instr_templ - instruction template
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_instr_templ_get(unsigned int db_idx, struct tpm_pme_templ_data_t *instr_templ)
+{
+	IF_NULL(TPM_DB_MOD, instr_templ);
+
+	if (db_idx >= TPM_PME_INSTR_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_OUT_OF_RANGE, "Out of max DB index\n");
+
+	memcpy(instr_templ, &g_tpm_db.pme_db.templ_db[db_idx], sizeof(struct tpm_pme_templ_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_instr_templ_free_idx_get()
+*
+* DESCRIPTION: Get the index of available instr templ DB entry.
+*
+* INPUTS:
+*          None.
+*
+* OUTPUTS:
+*          db_idx - available instr templ DB index.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_instr_templ_free_idx_get(unsigned int *db_idx)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, db_idx);
+
+	for (i = 0; i < TPM_PME_INSTR_TEMPL_MAX; i++) {
+		if (g_tpm_db.pme_db.templ_db[i].valid == TPM_INSTR_TEMPL_INVALID) {
+			*db_idx = i;
+			break;
+		}
+	}
+	if (i == TPM_PME_INSTR_TEMPL_MAX)
+		*db_idx = TPM_PME_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_vlan_permu_stat_set()
+*
+* DESCRIPTION: Set the vlan subr Permutations statistics to DB.
+*
+* INPUTS:
+*          vlan_op     - VLAN Op
+*          permu       - Outer VLAN permutation
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_vlan_permu_stat_set(unsigned int vlan_op, struct tpm_pme_vlan_skip_permu_t *permu)
+{
+	IF_NULL(TPM_DB_MOD, permu);
+
+	if (vlan_op >= VLANOP_MAX_CNT)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max VLAN Op Num\n");
+
+	memcpy(&g_tpm_db.pme_db.vlan_permu_stat[vlan_op], permu, sizeof(struct tpm_pme_vlan_skip_permu_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_vlan_permu_stat_get()
+*
+* DESCRIPTION: Get the vlan subr Permutations statistics from DB.
+*
+* INPUTS:
+*          vlan_op    - VLAN subr Op
+*
+* OUTPUTS:
+*          permu      - Outer VLAN Permutation
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_vlan_permu_stat_get(unsigned int vlan_op, struct tpm_pme_vlan_skip_permu_t *permu)
+{
+	IF_NULL(TPM_DB_MOD, permu);
+
+	if (vlan_op >= VLANOP_MAX_CNT)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max VLAN Op Num\n");
+
+	memcpy(permu, &g_tpm_db.pme_db.vlan_permu_stat[vlan_op], sizeof(struct tpm_pme_vlan_skip_permu_t));
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_pme_vlan_subr_set()
+*
+* DESCRIPTION: Set the vlan subr to DB.
+*
+* INPUTS:
+*          db_idx    - VLAN subr DB index
+*          vlan_subr - VLAN subroutine
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_vlan_subr_set(unsigned int db_idx, struct tpm_pme_vlan_subr_t *vlan_subr)
+{
+	IF_NULL(TPM_DB_MOD, vlan_subr);
+
+	if (db_idx >= TPM_VLAN_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max VLAN DB Num\n");
+
+	memcpy(&g_tpm_db.pme_db.vlan_db[db_idx], vlan_subr, sizeof(struct tpm_pme_vlan_subr_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_vlan_subr_get()
+*
+* DESCRIPTION: Get the vlan subr from DB.
+*
+* INPUTS:
+*          db_idx    - VLAN subr DB index
+*
+* OUTPUTS:
+*          vlan_subr - VLAN subroutine
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_vlan_subr_get(unsigned int db_idx, struct tpm_pme_vlan_subr_t *vlan_subr)
+{
+	IF_NULL(TPM_DB_MOD, vlan_subr);
+
+	if (db_idx >= TPM_VLAN_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max VLAN DB Num\n");
+
+	memcpy(vlan_subr, &g_tpm_db.pme_db.vlan_db[db_idx], sizeof(struct tpm_pme_vlan_subr_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_vlan_free_idx_get()
+*
+* DESCRIPTION: Get the index of available vlan subr DB entry.
+*
+* INPUTS:
+*          None.
+*
+* OUTPUTS:
+*          db_idx - available VLAN subr DB index.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_vlan_free_idx_get(unsigned int *db_idx)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, db_idx);
+
+	for (i = 0; i < TPM_VLAN_TEMPL_MAX; i++) {
+		if (g_tpm_db.pme_db.vlan_db[i].valid == TPM_VLAN_SUBR_INVALID) {
+			*db_idx = i;
+			break;
+		}
+	}
+	if (i == TPM_VLAN_TEMPL_MAX)
+		*db_idx = TPM_PME_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_addr_rep_subr_set()
+*
+* DESCRIPTION: Set the vlan subr to DB.
+*
+* INPUTS:
+*          db_idx        - subr DB index
+*          addr_rep_subr - Addr rep subroutine
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_addr_rep_subr_set(unsigned int db_idx, struct tpm_pme_addr_rep_subr_t *addr_rep_subr)
+{
+	IF_NULL(TPM_DB_MOD, addr_rep_subr);
+
+	if (db_idx >= TPM_ADDR_REP_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max Addr Subr DB Num\n");
+
+	memcpy(&g_tpm_db.pme_db.addr_rep_db[db_idx], addr_rep_subr, sizeof(struct tpm_pme_addr_rep_subr_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_addr_rep_subr_get()
+*
+* DESCRIPTION: Get the vlan subr from DB.
+*
+* INPUTS:
+*          db_idx        - subr DB index
+*
+* OUTPUTS:
+*          addr_rep_subr - addr rep subroutine
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_addr_rep_subr_get(unsigned int db_idx, struct tpm_pme_addr_rep_subr_t *addr_rep_subr)
+{
+	IF_NULL(TPM_DB_MOD, addr_rep_subr);
+
+	if (db_idx >= TPM_ADDR_REP_TEMPL_MAX)
+		IF_ERROR_STR(TPM_DB_MOD, TPM_BAD_PARAM, "Out of max Addr Subr DB Num\n");
+
+	memcpy(addr_rep_subr, &g_tpm_db.pme_db.addr_rep_db[db_idx], sizeof(struct tpm_pme_addr_rep_subr_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_addr_rep_free_idx_get()
+*
+* DESCRIPTION: Get the index of available addr rep subr DB entry.
+*
+* INPUTS:
+*          None.
+*
+* OUTPUTS:
+*          db_idx - available VLAN subr DB index.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_addr_rep_free_idx_get(unsigned int *db_idx)
+{
+	int i;
+
+	IF_NULL(TPM_DB_MOD, db_idx);
+
+	for (i = 0; i < REPLACE_ADDR_OP_MAX; i++) {
+		if (g_tpm_db.pme_db.addr_rep_db[i].valid == TPM_ADDR_REP_SUBR_INVALID) {
+			*db_idx = i;
+			break;
+		}
+	}
+	if (i == REPLACE_ADDR_OP_MAX)
+		*db_idx = TPM_PME_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_lock()
+*
+* DESCRIPTION: Get spink lock of the range, with software IRQ disabled
+*
+* INPUTS:
+*        tbl_idx - data table
+*        rng_idx - data range
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_data_rng_lock(unsigned int tbl_idx, unsigned int rng_idx)
+{
+	if (tbl_idx == TPM_PME_PRIVATE_TBL &&
+	    rng_idx < TPM_PME_PRI_RNG_MAX)
+		spin_lock_bh(&g_tpm_db.pme_db.pme_misc_data.pri_tbl_lock[rng_idx]);
+
+	if (tbl_idx == TPM_PME_SHARE_TBL &&
+	    rng_idx < TPM_PME_SHA_RNG_MAX)
+		spin_lock_bh(&g_tpm_db.pme_db.pme_misc_data.sha_tbl_lock[rng_idx]);
+}
+
+/*******************************************************************************
+* tpm_db_pme_data_rng_unlock()
+*
+* DESCRIPTION: Get spink lock of the range, with software IRQ enabled
+*
+* INPUTS:
+*        tbl_idx - data table
+*        rng_idx - data range
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_data_rng_unlock(unsigned int tbl_idx, unsigned int rng_idx)
+{
+	if (tbl_idx == TPM_PME_PRIVATE_TBL &&
+	    rng_idx < TPM_PME_PRI_RNG_MAX)
+		spin_unlock_bh(&g_tpm_db.pme_db.pme_misc_data.pri_tbl_lock[rng_idx]);
+
+	if (tbl_idx == TPM_PME_SHARE_TBL &&
+	    rng_idx < TPM_PME_SHA_RNG_MAX)
+		spin_unlock_bh(&g_tpm_db.pme_db.pme_misc_data.sha_tbl_lock[rng_idx]);
+}
+
+/*******************************************************************************
+* tpm_db_pme_hw_lock()
+*
+* DESCRIPTION: Get spink lock of PME HW access
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_hw_lock(void)
+{
+	spin_lock(&g_tpm_db.pme_db.pme_misc_data.hw_lock);
+}
+
+/*******************************************************************************
+* tpm_db_pme_hw_unlock()
+*
+* DESCRIPTION: Release spink lock of PME HW access
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_hw_unlock(void)
+{
+	spin_unlock(&g_tpm_db.pme_db.pme_misc_data.hw_lock);
+}
+
+/*******************************************************************************
+* tpm_db_pme_templ_lock()
+*
+* DESCRIPTION: Lock the instruction template when operate the template, rd/wr
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_templ_lock(void)
+{
+	spin_lock_bh(&g_tpm_db.pme_db.pme_misc_data.instr_templ_lock);
+}
+
+/*******************************************************************************
+* tpm_db_pme_templ_unlock()
+*
+* DESCRIPTION: Release spink lock of PME instruction template
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+void tpm_db_pme_templ_unlock(void)
+{
+	spin_unlock_bh(&g_tpm_db.pme_db.pme_misc_data.instr_templ_lock);
+}
+
+
+
+/*******************************************************************************
+* tpm_db_pme_init()
+*
+* DESCRIPTION: Perform DB Initialization for PME section.
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_pme_init(void)
+{
+	int i;
+
+	/* Clear PME db */
+	memset(&g_tpm_db.pme_db, 0, sizeof(struct tpm_db_pme_t));
+
+	/* Init Spin Lock */
+	spin_lock_init(&g_tpm_db.pme_db.pme_misc_data.hw_lock);
+	spin_lock_init(&g_tpm_db.pme_db.pme_misc_data.instr_templ_lock);
+	for (i = TPM_PME_PRI_RNG_NO_MOD; i < TPM_PME_PRI_RNG_MAX; i++)
+		spin_lock_init(&g_tpm_db.pme_db.pme_misc_data.pri_tbl_lock[i]);
+	for (i = TPM_PME_SHA_RNG_MAC; i < TPM_PME_SHA_RNG_MAX; i++)
+		spin_lock_init(&g_tpm_db.pme_db.pme_misc_data.sha_tbl_lock[i]);
+
+	/* Init PME instruction table division */
+	/* JUMP Area */
+	g_tpm_db.pme_db.pme_misc_data.jmp_start = TPM_PME_JMP_START;
+	g_tpm_db.pme_db.pme_misc_data.jmp_area_size = TPM_PME_JMP_AREA_SIZE;
+	g_tpm_db.pme_db.pme_misc_data.jmp_first_free = TPM_PME_JMP_START;
+	/* TEMPL Area */
+	g_tpm_db.pme_db.pme_misc_data.templ_start = TPM_PME_TEMPLATE_START;
+	g_tpm_db.pme_db.pme_misc_data.templ_area_size = TPM_PME_TEMPLATE_AREA_SIZE;
+	g_tpm_db.pme_db.pme_misc_data.templ_first_free = TPM_PME_TEMPLATE_START;
+	/* SUBR Area */
+	g_tpm_db.pme_db.pme_misc_data.subr_start = TPM_PME_SUBR_START;
+	g_tpm_db.pme_db.pme_misc_data.subr_area_size = TPM_PME_SUBR_AREA_SIZE;
+	g_tpm_db.pme_db.pme_misc_data.subr_first_free = TPM_PME_SUBR_START;
+
+	/* Init PME private table range managenment */
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_NO_MOD].start = TPM_PME_PRI_NO_MOD_START;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_NO_MOD].case_num_max = TPM_PME_PRI_NO_MOD_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_NO_MOD].unit_size = TPM_PME_PRI_NO_MOD_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_NO_MOD].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_NO_MOD].unit_state,
+				TPM_PME_STATE_INT_NUM,
+				sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_PRI_NO_MOD_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_L2_SW].start = TPM_PME_PRI_L2_SW_START;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_L2_SW].case_num_max = TPM_PME_PRI_L2_SW_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_L2_SW].unit_size = TPM_PME_PRI_L2_SW_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_L2_SW].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_L2_SW].unit_state,
+				TPM_PME_STATE_INT_NUM,
+				sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_PRI_L2_SW_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_ROUTE].start = TPM_PME_PRI_ROUTE_START;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_ROUTE].case_num_max = TPM_PME_PRI_ROUTE_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_ROUTE].unit_size = TPM_PME_PRI_ROUTE_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_ROUTE].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_ROUTE].unit_state,
+				TPM_PME_STATE_INT_NUM,
+				sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_PRI_ROUTE_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_US_NAPT].start = TPM_PME_PRI_NAPT_US_START;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_US_NAPT].case_num_max = TPM_PME_PRI_NAPT_US_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_US_NAPT].unit_size = TPM_PME_PRI_NAPT_US_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_US_NAPT].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_US_NAPT].unit_state,
+			TPM_PME_STATE_INT_NUM,
+			sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_PRI_NAPT_US_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_DS_NAPT].start = TPM_PME_PRI_NAPT_DS_START;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_DS_NAPT].case_num_max = TPM_PME_PRI_NAPT_DS_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_DS_NAPT].unit_size = TPM_PME_PRI_NAPT_DS_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_DS_NAPT].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.pri_rng_mng[TPM_PME_PRI_RNG_DS_NAPT].unit_state,
+			TPM_PME_STATE_INT_NUM,
+			sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_PRI_NAPT_DS_CASE_MAX))
+		return TPM_FAIL;
+
+	/* Init PME share table range managenment */
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_MAC].start = TPM_PME_SHA_MAC_START;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_MAC].case_num_max = TPM_PME_SHA_MAC_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_MAC].unit_size = TPM_PME_SHA_MAC_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_MAC].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_MAC].unit_state,
+				TPM_PME_STATE_INT_NUM,
+				sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_SHA_MAC_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_SA_SIP].start = TPM_PME_SHA_SA_SIP_START;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_SA_SIP].case_num_max = TPM_PME_SHA_SA_SIP_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_SA_SIP].unit_size = TPM_PME_SHA_SA_SIP_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_SA_SIP].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_SA_SIP].unit_state,
+				TPM_PME_STATE_INT_NUM,
+				sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_SHA_SA_SIP_CASE_MAX))
+		return TPM_FAIL;
+
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_DA_SA_DIP].start = TPM_PME_SHA_DA_SA_DIP_START;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_DA_SA_DIP].case_num_max =
+											TPM_PME_SHA_DA_SA_DIP_CASE_MAX;
+	g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_DA_SA_DIP].unit_size =
+										TPM_PME_SHA_DA_SA_DIP_UNIT_BYTES;
+	TPM_MEMSET_ZERO(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_DA_SA_DIP].unit_state);
+	if (int_array_high_bits_set(g_tpm_db.pme_db.pme_misc_data.sha_rng_mng[TPM_PME_SHA_RNG_DA_SA_DIP].unit_state,
+			TPM_PME_STATE_INT_NUM,
+			sizeof(unsigned int) * BYTE_BITS * TPM_PME_STATE_INT_NUM - TPM_PME_SHA_DA_SA_DIP_CASE_MAX))
+		return TPM_FAIL;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_gmac_conn_get()
+*
+* DESCRIPTION:      Function to get the Connection of an Ethernet GMAC
+*
+* INPUTS:
+* gmac             - GMAC number
+* OUTPUTS:
+* gmac_con         - GMAC internal Physical connection (see tpm_gmac_conn_t)
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_err_t.
+*
+* COMMENTS:  It need implement in future, here it is supposed that GMAC0 connect
+* to switch port6, GMAC1 connect to PHY directly
+*
+*******************************************************************************/
+int tpm_db_gmac_conn_get(enum tpm_gmacs_enum_t gmac, enum tpm_gmac_conn_t *gmac_con)
+{
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	MV_U32			regVal;
+#endif
+	IF_NULL(TPM_DB_MOD, gmac_con);
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (gmac != TPM_ENUM_GMAC_0 &&	gmac != TPM_ENUM_GMAC_1)
+		return TPM_BAD_PARAM;
+
+	regVal = mvPp2RdReg(MV_PP2_MH_REG(MV_PPV2_PORT_PHYS(gmac)));
+	if (regVal & MV_PP2_MH_EN_MASK) {
+		if (gmac == TPM_ENUM_GMAC_0)
+			*gmac_con = TPM_GMAC_CON_SWITCH_6;
+		else
+			*gmac_con = TPM_GMAC_CON_SWITCH_4;
+	} else
+		*gmac_con = TPM_GMAC_CON_GE_PHY;
+
+#else
+	*gmac_con = TPM_GMAC_CON_GE_PHY;
+#endif
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_plcr_free_id_get()
+*
+* DESCRIPTION: Get a free policer ID.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	policer_id - policer ID.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_free_id_get(unsigned char *policer_id)
+{
+	unsigned int idx;
+	struct tpm_db_plcr_entry_t *plcr_arr = NULL;
+	IF_NULL(TPM_DB_MOD, policer_id);
+
+	for (idx = TPM_PLCR_MIN_ENTRY_ID; idx < MV_PP2_PLCR_NUM; idx++) {
+		plcr_arr = &g_tpm_db.plcr_db.plcr_arr[idx];
+		if (plcr_arr->valid == TPM_PLCR_ENTRY_VALID_STATE)
+			continue;
+		/* save policer ID in case free policer entry is found */
+		*policer_id = idx;
+		break;
+	}
+
+	/* in case no free policer entry found */
+	if (idx == MV_PP2_PLCR_NUM) {
+		*policer_id = TPM_POLICER_INVALID;
+		TPM_OS_ERROR(TPM_DB_MOD, "policer table is full, no free policer\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_entry_set()
+*
+* DESCRIPTION: Set policer entry by policer ID.
+*
+* INPUTS:
+*	policer_id - policer ID.
+*	plcr_entry - policer entry
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_entry_set(unsigned char			policer_id,
+			  struct tpm_db_plcr_entry_t	*plcr_entry)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, policer_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+	IF_NULL(TPM_DB_MOD, plcr_entry);
+
+	memcpy(&g_tpm_db.plcr_db.plcr_arr[policer_id], plcr_entry, sizeof(struct tpm_db_plcr_entry_t));
+
+	/* Clear this policer entry in invalid case */
+	if (g_tpm_db.plcr_db.plcr_arr[policer_id].valid == TPM_PLCR_ENTRY_INVALID_STATE) {
+		TPM_MEMSET_ZERO(g_tpm_db.plcr_db.plcr_arr[policer_id]);
+		g_tpm_db.plcr_db.plcr_arr[policer_id].valid = TPM_PLCR_ENTRY_INVALID_STATE;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_entry_get()
+*
+* DESCRIPTION: Get policer entry by policer ID.
+*
+* INPUTS:
+*	policer_id - policer ID.
+*
+* OUTPUTS:
+*	plcr_entry - policer entry
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_entry_get(unsigned char			policer_id,
+			  struct tpm_db_plcr_entry_t	*plcr_entry)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, policer_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+	IF_NULL(TPM_DB_MOD, plcr_entry);
+
+	memcpy(plcr_entry, &g_tpm_db.plcr_db.plcr_arr[policer_id], sizeof(struct tpm_db_plcr_entry_t));
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_ref_cnt_update()
+*
+* DESCRIPTION: Update policer entry reference counter.
+*
+* INPUTS:
+*	policer_id - plicer ID.
+*	cnt_action - policer reference counter action.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_ref_cnt_update(unsigned char			policer_id,
+			       enum tpm_plcr_ref_cnt_action_t	cnt_action)
+{
+	unsigned int idx;
+	struct tpm_db_plcr_entry_t *plcr_arr = NULL;
+
+	TPM_DECIMAL_RANGE_VALIDATE_STR(TPM_DB_MOD, policer_id, TPM_PLCR_MIN_ENTRY_ID, MV_PP2_PLCR_NUM - 1,
+				       "invalid policer ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, cnt_action, TPM_PLCR_REF_CNT_CLEAR_ALL,
+				   "invalid reference counter action");
+
+	/* check the policer ID */
+	plcr_arr = &g_tpm_db.plcr_db.plcr_arr[policer_id];
+	if (((cnt_action == TPM_PLCR_REF_CNT_INC) ||
+	     (cnt_action == TPM_PLCR_REF_CNT_DEC) ||
+	     (cnt_action == TPM_PLCR_REF_CNT_CLEAR))
+	    && (plcr_arr->valid == TPM_PLCR_ENTRY_INVALID_STATE)) {
+		TPM_OS_ERROR(TPM_DB_MOD, "policer ID(%d) is invalid\n", policer_id);
+		return TPM_NOT_INITIALIZED;
+	}
+
+	/* action to reference counter */
+	switch (cnt_action) {
+	case TPM_PLCR_REF_CNT_INC:
+		plcr_arr->ref_cnt++;
+		break;
+	case TPM_PLCR_REF_CNT_DEC:
+		plcr_arr->ref_cnt--;
+		break;
+	case TPM_PLCR_REF_CNT_CLEAR:
+		plcr_arr->ref_cnt = 0;
+		break;
+	case TPM_PLCR_REF_CNT_CLEAR_ALL:
+		for (idx = TPM_PLCR_MIN_ENTRY_ID; idx < MV_PP2_PLCR_NUM; idx++) {
+			plcr_arr = &g_tpm_db.plcr_db.plcr_arr[idx];
+			if (plcr_arr->valid == TPM_PLCR_ENTRY_VALID_STATE)
+				plcr_arr->ref_cnt = 0;
+		}
+		break;
+	default:
+		TPM_OS_ERROR(TPM_DB_MOD, "invalid reference counter action(%d)\n", cnt_action);
+		break;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_gen_cfg_set()
+*
+* DESCRIPTION: Set policer general configuration to DB.
+*
+* INPUTS:
+*	gen_cfg - general configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_gen_cfg_set(struct tpm_policer_gen_cfg_t *gen_cfg)
+{
+	IF_NULL(TPM_DB_MOD, gen_cfg);
+
+	memcpy(&g_tpm_db.plcr_db.gen_cfg, gen_cfg, sizeof(struct tpm_policer_gen_cfg_t));
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_gen_cfg_get()
+*
+* DESCRIPTION: Get policer general configuration from DB.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	gen_cfg - general configuration.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_gen_cfg_get(struct tpm_policer_gen_cfg_t *gen_cfg)
+{
+	IF_NULL(TPM_DB_MOD, gen_cfg);
+
+	memcpy(gen_cfg, &g_tpm_db.plcr_db.gen_cfg, sizeof(struct tpm_policer_gen_cfg_t));
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_early_drop_set()
+*
+* DESCRIPTION: Get policer early dorp parameters.
+*
+* INPUTS:
+*	early_drop - early drop parameters
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_early_drop_set(struct tpm_policer_early_drop_t *early_drop)
+{
+	IF_NULL(TPM_DB_MOD, early_drop);
+
+	memcpy(&g_tpm_db.plcr_db.early_drop, early_drop, sizeof(struct tpm_policer_early_drop_t));
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_early_drop_get()
+*
+* DESCRIPTION: Get policer early dorp parameters.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	early_drop - early drop parameters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_early_drop_get(struct tpm_policer_early_drop_t *early_drop)
+{
+	IF_NULL(TPM_DB_MOD, early_drop);
+
+	memcpy(early_drop, &g_tpm_db.plcr_db.early_drop, sizeof(struct tpm_policer_early_drop_t));
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_plcr_init()
+*
+* DESCRIPTION: Initialize policer DB.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_plcr_init(void)
+{
+	unsigned int idx = 0;
+	unsigned int gmac = 0;
+
+	/* clear TPM policer DB */
+	TPM_MEMSET_ZERO(g_tpm_db.plcr_db);
+
+	/* set policer entry to invalid state */
+	for (idx = 0; idx < MV_PP2_PLCR_NUM; idx++)
+		g_tpm_db.plcr_db.plcr_arr[idx].valid = TPM_PLCR_ENTRY_INVALID_STATE;
+
+	/* disable early drop and queue threshold index */
+	g_tpm_db.plcr_db.early_drop.state = TPM_PLCR_EARLY_DROP_DISABLE;
+	for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+		g_tpm_db.plcr_db.early_drop.rxq_idx[idx] = TPM_PLCR_INVALID_Q_THESH_IDX;
+
+	for (gmac = 0; gmac < TPM_NUM_TX_PORTS; gmac++) {
+		for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+			g_tpm_db.plcr_db.early_drop.txq_idx[gmac][idx] = TPM_PLCR_INVALID_Q_THESH_IDX;
+	}
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_db_qos_tbl_entry_set()
+*
+* DESCRIPTION: This API sets a qos table entry to db.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_entry   - Qos parameter configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_qos_tbl_entry_set(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_entry)
+{
+	int qos_tbl_size = 0;
+	int loop = 0;
+	enum tpm_db_qos_status_t	*tbl_stat;
+	struct tpm_db_qos_tbl_entry_t	*qos_tbl_entry;
+
+	IF_NULL(TPM_DB_MOD, qos_entry);
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE,
+					   "invalid qos_tbl entry number");
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE,
+					   "invalid qos_tbl entry number");
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_QOS_DSCP == qos_select) {
+		memcpy(&g_tpm_db.qos_db.dscp_tbl[qos_tbl].dscp_entry[entry].qos_entry,
+			qos_entry,
+			sizeof(struct tpm_qos_tbl_act_t));
+		g_tpm_db.qos_db.dscp_tbl[qos_tbl].dscp_entry[entry].entry_stat = TPM_QOS_TBL_STATUS_INITED;
+
+		/* keep qos table pointer */
+		qos_tbl_entry = g_tpm_db.qos_db.dscp_tbl[qos_tbl].dscp_entry;
+		qos_tbl_size = MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE;
+		tbl_stat = &g_tpm_db.qos_db.dscp_tbl[qos_tbl].tbl_stat;
+	} else if (TPM_QOS_PBIT == qos_select) {
+		memcpy(&g_tpm_db.qos_db.pri_tbl[qos_tbl].pri_entry[entry].qos_entry,
+			qos_entry,
+			sizeof(struct tpm_qos_tbl_act_t));
+		g_tpm_db.qos_db.pri_tbl[qos_tbl].pri_entry[entry].entry_stat = TPM_QOS_TBL_STATUS_INITED;
+
+		/* keep qos table pointer */
+		qos_tbl_entry = g_tpm_db.qos_db.pri_tbl[qos_tbl].pri_entry;
+		qos_tbl_size = MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE;
+		tbl_stat = &g_tpm_db.qos_db.pri_tbl[qos_tbl].tbl_stat;
+	}
+
+	/* update table stat if necessary */
+	for (loop = 0; loop < qos_tbl_size; loop++) {
+		if (qos_tbl_entry[loop].entry_stat == TPM_QOS_TBL_STATUS_UNINITED)
+			return TPM_OK;
+	}
+
+	/* all entries in this table have been inited */
+	*tbl_stat = TPM_QOS_TBL_STATUS_INITED;
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_db_qos_tbl_entry_get()
+*
+* DESCRIPTION: This API gets a qos table entry from db.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*
+* OUTPUTS:
+*	qos_entry    - Qos parameter configuration.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_qos_tbl_entry_get(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_db_qos_tbl_entry_t	*qos_entry)
+{
+	IF_NULL(TPM_DB_MOD, qos_entry);
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE,
+					   "invalid qos_tbl entry number");
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE,
+					   "invalid qos_tbl entry number");
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_QOS_DSCP == qos_select) {
+		memcpy(qos_entry,
+			&g_tpm_db.qos_db.dscp_tbl[qos_tbl].dscp_entry[entry],
+			sizeof(struct tpm_db_qos_tbl_entry_t));
+	} else if (TPM_QOS_PBIT == qos_select) {
+		memcpy(qos_entry,
+			&g_tpm_db.qos_db.pri_tbl[qos_tbl].pri_entry[entry],
+			sizeof(struct tpm_db_qos_tbl_entry_t));
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_qos_tbl_status_get()
+*
+* DESCRIPTION: This API gets a qos table status from db.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*
+* OUTPUTS:
+*	status          - Table status.
+*	ref_cnt         - reference count.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_qos_tbl_status_get(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       enum tpm_db_qos_status_t	*status,
+			       int			*ref_cnt)
+{
+	IF_NULL(TPM_DB_MOD, status);
+	IF_NULL(TPM_DB_MOD, ref_cnt);
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		*status =  g_tpm_db.qos_db.dscp_tbl[qos_tbl].tbl_stat;
+		*ref_cnt = g_tpm_db.qos_db.dscp_tbl[qos_tbl].ref_count;
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		*status = g_tpm_db.qos_db.pri_tbl[qos_tbl].tbl_stat;
+		*ref_cnt = g_tpm_db.qos_db.pri_tbl[qos_tbl].ref_count;
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_qos_tbl_ref_cnt_updt()
+*
+* DESCRIPTION: This API update qos table reference count to db.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	cnt_action   - reference counter action
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_db_qos_tbl_ref_cnt_updt(enum tpm_qos_sel_t	qos_select,
+			       unsigned char			qos_tbl,
+			       enum tpm_qos_tbl_ref_cnt_action_t	cnt_action)
+{
+	int *ref_cnt = 0;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, cnt_action, TPM_QOS_TBL_REF_CNT_DEC, "invalid qos_tbl");
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		ref_cnt = &g_tpm_db.qos_db.dscp_tbl[qos_tbl].ref_count;
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		ref_cnt = &g_tpm_db.qos_db.pri_tbl[qos_tbl].ref_count;
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_QOS_TBL_REF_CNT_DEC == cnt_action)
+		*ref_cnt = (*ref_cnt) - 1;
+	else
+		*ref_cnt = (*ref_cnt) + 1;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_qos_init()
+*
+* DESCRIPTION: Initialize QOS module DB.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_db_qos_init(void)
+{
+	unsigned int idx = 0;
+	unsigned int idx_in = 0;
+
+	/* clear TPM QOS DB */
+	TPM_MEMSET_ZERO(g_tpm_db.qos_db);
+
+	/* set policer entry to invalid state */
+	for (idx = 0; idx < MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM; idx++) {
+		g_tpm_db.qos_db.pri_tbl[idx].tbl_stat = TPM_QOS_TBL_STATUS_UNINITED;
+		g_tpm_db.qos_db.pri_tbl[idx].ref_count = 0;
+		for (idx_in = 0; idx_in < MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE; idx_in++)
+			g_tpm_db.qos_db.pri_tbl[idx].pri_entry[idx_in].entry_stat = TPM_QOS_TBL_STATUS_UNINITED;
+	}
+	for (idx = 0; idx < MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM; idx++) {
+		g_tpm_db.qos_db.dscp_tbl[idx].tbl_stat = TPM_QOS_TBL_STATUS_UNINITED;
+		g_tpm_db.qos_db.dscp_tbl[idx].ref_count = 0;
+		for (idx_in = 0; idx_in < MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE; idx_in++)
+			g_tpm_db.qos_db.dscp_tbl[idx].dscp_entry[idx_in].entry_stat = TPM_QOS_TBL_STATUS_UNINITED;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mc_dup_list_head_get()
+*
+* DESCRIPTION: Get the head of the dup list.
+*
+* INPUTS:
+*          dup_flowid  - The first HW index in the list
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The head pointer of list.
+*
+*******************************************************************************/
+struct list_head *tpm_db_mc_dup_list_head_get(unsigned char dup_flowid)
+{
+	return &g_tpm_db.mc_db.mct_dup_head_db[dup_flowid];
+}
+
+/*******************************************************************************
+* tpm_db_mc_free_list_head_get()
+*
+* DESCRIPTION: Get the head of free list.
+*
+* INPUTS:
+*          None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The head pointer of list.
+*
+*******************************************************************************/
+struct list_head *tpm_db_mc_free_list_head_get(void)
+{
+	return &g_tpm_db.mc_db.mct_free_head_db;
+}
+
+/*******************************************************************************
+* tpm_db_mc_index_node_get()
+*
+* DESCRIPTION: Get the index node in the list according to their db index.
+*
+* INPUTS:
+*          mct_node_idx  - the db index of MCT index node.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+*          The node pointer.
+*
+*******************************************************************************/
+struct tpm_mc_index_t *tpm_db_mc_index_node_get(unsigned int mct_node_idx)
+{
+	/* Para check */
+	if (mct_node_idx >= MV_PP2_MC_TBL_SIZE)
+		return NULL;
+
+	return &g_tpm_db.mc_db.mct_index_db[mct_node_idx];
+}
+
+/*******************************************************************************
+* tpm_db_mc_index_node_set()
+*
+* DESCRIPTION: Set the index node in the list according to their db index.
+*
+* INPUTS:
+*          mct_node_idx   - the db index of MCT index node.
+*          mct_index_node - the new value of the node to set.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_mc_index_node_set(unsigned int mct_node_idx,
+			     struct tpm_mc_index_t *mct_index_node)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mct_node_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_DB_MOD, mct_index_node);
+
+	memcpy(&g_tpm_db.mc_db.mct_index_db[mct_node_idx], mct_index_node, sizeof(struct tpm_mc_index_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mc_data_get()
+*
+* DESCRIPTION: Get the MCT entry data from DB according to their db index.
+*
+* INPUTS:
+*          mct_node_idx   - the db index of MCT entry data.
+*
+* OUTPUTS:
+*          mct_data       - MCT entry data.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_mc_data_get(unsigned int mct_db_idx,
+		       struct tpm_mc_data_t *mct_data)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mct_db_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_DB_MOD, mct_data);
+
+	memcpy(mct_data, &g_tpm_db.mc_db.mct_data_db[mct_db_idx], sizeof(struct tpm_mc_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mct_data_set()
+*
+* DESCRIPTION: Set the MCT entry data to DB according to their allocated db index.
+*
+* INPUTS:
+*          mct_node_idx   - the db index of MCT entry data.
+*          mct_data       - MCt entry data.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_mc_data_set(unsigned int mct_db_idx,
+		       struct tpm_mc_data_t *mct_data)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, mct_db_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_DB_MOD, mct_data);
+
+	memcpy(&g_tpm_db.mc_db.mct_data_db[mct_db_idx], mct_data, sizeof(struct tpm_mc_data_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_mc_init()
+*
+* DESCRIPTION: Perform DB Initialization for MCT(Multicast Table) section.
+*
+* INPUTS: None.
+*
+* OUTPUTS: None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_mc_init(void)
+{
+	int i;
+
+	/* Clear MCT db */
+	memset(&g_tpm_db.mc_db, 0, sizeof(struct tpm_db_mc_t));
+
+	/* Init mct_hw_idx to MCT corresponding mct hw index in mct data db and index db */
+	for (i = 0; i < MV_PP2_MC_TBL_SIZE; i++) {
+		g_tpm_db.mc_db.mct_data_db[i].valid = TPM_MC_ENTRY_INVALID;
+		g_tpm_db.mc_db.mct_index_db[i].valid = TPM_MC_ENTRY_INVALID;
+		g_tpm_db.mc_db.mct_index_db[i].mct_hw_idx = i;
+	}
+
+	/* Init MCT list head */
+	INIT_LIST_HEAD(&g_tpm_db.mc_db.mct_free_head_db);
+	for (i = 0; i < MV_PP2_MC_TBL_SIZE; i++)
+		INIT_LIST_HEAD(&g_tpm_db.mc_db.mct_dup_head_db[i]);
+
+	/* Init free list */
+	for (i = MV_PP2_MC_TBL_SIZE - 1; i >= 0; i--) {
+		list_add(&g_tpm_db.mc_db.mct_index_db[i].list_node, &g_tpm_db.mc_db.mct_free_head_db);
+		/* Change index node valid status after adding to free list */
+		g_tpm_db.mc_db.mct_index_db[i].valid = TPM_MC_ENTRY_VALID;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_rate_get()
+*
+* DESCRIPTION: Get the switch port ingress rate limit from DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*
+* OUTPUTS:
+*          rate   - rate limit.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_rate_get(enum tpm_sw_port_t port, unsigned int *rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+	IF_NULL(TPM_DB_MOD, rate);
+
+	*rate = g_tpm_db.sw_db.sw_port_ingr_rate[port];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_rate_set()
+*
+* DESCRIPTION: Set the switch port ingress rate limit to DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*          rate   - rate limit.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_rate_set(enum tpm_sw_port_t port, unsigned int rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+
+	g_tpm_db.sw_db.sw_port_ingr_rate[port] = rate;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_mc_rate_get()
+*
+* DESCRIPTION: Get the switch port ingress multicast rate limit from DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*
+* OUTPUTS:
+*          rate   - multicast rate limit.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_mc_rate_get(enum tpm_sw_port_t port, unsigned int *rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+	IF_NULL(TPM_DB_MOD, rate);
+
+	*rate = g_tpm_db.sw_db.sw_port_ingr_mc_rate[port];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_mc_rate_set()
+*
+* DESCRIPTION: Set the switch port ingress multicast rate limit to DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*          rate   - multicast rate limit.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_mc_rate_set(enum tpm_sw_port_t port, unsigned int rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+
+	g_tpm_db.sw_db.sw_port_ingr_mc_rate[port] = rate;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_bc_rate_get()
+*
+* DESCRIPTION: Get the switch port ingress rate broadcast limit from DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*
+* OUTPUTS:
+*          rate   - broadcast rate limit.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_bc_rate_get(enum tpm_sw_port_t port, unsigned int *rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+	IF_NULL(TPM_DB_MOD, rate);
+
+	*rate = g_tpm_db.sw_db.sw_port_ingr_bc_rate[port];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_db_sw_port_ingr_bc_rate_set()
+*
+* DESCRIPTION: Set the switch port ingress broadcast rate limit to DB according to switch port.
+*
+* INPUTS:
+*          port   - switch port.
+*          rate   - broadcast rate limit.
+*
+* OUTPUTS:
+*          None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+*******************************************************************************/
+int tpm_db_sw_port_ingr_bc_rate_set(enum tpm_sw_port_t port, unsigned int rate)
+{
+	/* Param check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_DB_MOD, port, 0, TPM_SW_PORT_MAX);
+
+	g_tpm_db.sw_db.sw_port_ingr_bc_rate[port] = rate;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_db_init()
+*
+* DESCRIPTION: Perform DB Initialization.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_db_init(void)
+{
+	int ret_code;
+
+	/* Erase DB */
+	TPM_MEMSET_ZERO(g_tpm_db);
+	TPM_MEMSET_ZERO(g_init_cfg);
+
+	/* Set TPM module state */
+	ret_code = tpm_db_module_state_set(TPM_MODULE_NOT_START);
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Failed to set TPM module stat\n");
+
+	/* Initialize init module DB */
+	ret_code = tpm_init_db_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init module DB\n");
+
+	/* Pre Config Parser DB */
+	ret_code = tpm_prs_db_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in Pre-config Parser DB\n");
+
+	/* PME DB init */
+	ret_code = tpm_db_pme_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init PME DB\n");
+
+	/* Policer DB init */
+	ret_code = tpm_db_plcr_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init policer DB\n");
+
+	/* QOS DB init */
+	ret_code = tpm_db_qos_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init QOS DB\n");
+
+	/* Mnc MC DB init */
+	ret_code = tpm_db_mng_mc_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init MNG MC DB\n");
+
+	/* MC DB init */
+	ret_code = tpm_db_mc_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init MC DB\n");
+
+	/* api_data_pool init */
+	tpm_db_mng_api_data_pool_init();
+	IF_ERROR_STR(TPM_DB_MOD, ret_code, "Error in init mng_api_data_pool\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_device.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_device.c
new file mode 100644
index 0000000..edaf60f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_device.c
@@ -0,0 +1,1366 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_device.c                                                      **
+**                                                                           **
+**  DESCRIPTION : This file implements TPM character device                  **
+**  DEPENDCY :                                                               **
+******************************************************************************/
+#include "tpm_header.h"
+
+static int tpm_cdev_open_num;
+static struct tpm_module_cdev_t tpm_dev;
+/* udev class's */
+static struct class  *tpm_udev_class;
+static struct device *tpm_udev_dev;
+/* ioctl mempool */
+static struct tpm_ioctl_mpools_t tpm_ioctl_mpools = {NULL, NULL, NULL, NULL};
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+struct semaphore		tpm_sfs_2_ioctl_sem;
+struct tpm_ioctl_mng_t		tpm_sfs_2_ioctl_command;
+#endif
+
+/*******************************************************************************
+* tpm_cdev_init_ioctl
+*
+* DESCRIPTION: The routine is to implent TPM init ioctl..
+*
+* INPUTS:
+*           tpm_ioctl_init  - TPM init parameters
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_cdev_init_ioctl(struct tpm_ioctl_init_t *tpm_ioctl_init)
+{
+	int ret = TPM_OK;
+
+	/* Parameter Check */
+	IF_NULL(TPM_IOCTL_MOD, tpm_ioctl_init);
+
+	switch (tpm_ioctl_init->cmd) {
+	case TPM_IOCTL_INIT_GMAC_MODE_SET:
+		/* Call Corresponding API */
+		ret = tpm_init_switch_mode_set(tpm_ioctl_init->gmac_mode.gmac_idx,
+					       tpm_ioctl_init->gmac_mode.mode);
+		break;
+	case TPM_IOCTL_INIT_GMAC_DEF_MH_SET:
+		ret = tpm_init_gmac_def_mh_set(tpm_ioctl_init->gmac_def_tx_mh.gmac_idx,
+					       tpm_ioctl_init->gmac_def_tx_mh.mh);
+		break;
+	case TPM_IOCTL_INIT_SWITCH_SET:
+		ret = tpm_init_switch_init_set(tpm_ioctl_init->switch_init);
+		break;
+	case TPM_IOCTL_INIT_EXACT_CAP_ADD:
+		ret = tpm_init_capability_set(TPM_CAP_TYPE_EXACT_EXCEPT,
+					     &tpm_ioctl_init->tpm_capability);
+		break;
+	case TPM_IOCTL_INIT_GEN_CAP_ADD:
+		ret = tpm_init_capability_set(TPM_CAP_TYPE_CLS,
+					     &tpm_ioctl_init->tpm_capability);
+		break;
+	case TPM_IOCTL_INIT_EXACT_CAP_DEL:
+		ret = tpm_init_capability_del(TPM_CAP_TYPE_EXACT_EXCEPT,
+					     &tpm_ioctl_init->tpm_capability);
+		break;
+	case TPM_IOCTL_INIT_GEN_CAP_DEL:
+		ret = tpm_init_capability_del(TPM_CAP_TYPE_CLS,
+					     &tpm_ioctl_init->tpm_capability);
+		break;
+	case TPM_IOCTL_INIT_MC_DEF_ACT_SET:
+		ret = (tpm_init_mc_flow_default_set(TPM_MC_TRAFFIC_L2, tpm_ioctl_init->mc_def_act[TPM_MC_TRAFFIC_L2])) |
+		      (tpm_init_mc_flow_default_set(TPM_MC_TRAFFIC_L3, tpm_ioctl_init->mc_def_act[TPM_MC_TRAFFIC_L3]));
+		break;
+	case TPM_IOCTL_INIT_MC_PROTO_HANDLE_SET:
+		ret = tpm_init_mc_proto_handler_set(&tpm_ioctl_init->mc_proto_handler);
+		break;
+	case TPM_IOCTL_INIT_MC_DATA_HANDLE_SET:
+		ret = tpm_init_mc_data_handler_set(tpm_ioctl_init->mc_data_handle);
+		break;
+	case TPM_IOCTL_INIT_MC_SW_HANDLE_SET:
+		ret = tpm_init_mc_sw_handler_set(tpm_ioctl_init->mc_sw_handle);
+		break;
+	case TPM_IOCTL_INIT_UNI_NUM_SET:
+		ret = tpm_init_uni_port_num_set(tpm_ioctl_init->uni_count);
+		break;
+	case TPM_IOCTL_INIT_IPV6_SUPPORT_SET:
+		ret = tpm_init_ipv6_support_set(tpm_ioctl_init->ipv6_support);
+		break;
+	case TPM_IOCTL_INIT_TRAP_QUEUE_SET:
+		ret = tpm_init_cpu_trap_queue_set(tpm_ioctl_init->cpu_trap_rx_queue);
+		break;
+	case TPM_IOCTL_INIT_ILLEGAL_TTL_ACT_SET:
+		ret = tpm_init_ttl_illegal_action_set(tpm_ioctl_init->illegal_ttl_action);
+		break;
+	case TPM_IOCTL_INIT_TCP_FLAG_CHECK_SET:
+		ret = tpm_init_tcp_flag_check_set(tpm_ioctl_init->tcp_flag_check);
+		break;
+	case TPM_IOCTL_INIT_MOD_VLAN_TPID_SET:
+		ret = tpm_init_mod_vlan_tpid_set(tpm_ioctl_init->mod_vlan_tpid);
+		break;
+	case TPM_IOCTL_INIT_TPID_COMB_ADD:
+		ret = tpm_init_tpid_combo_set(&tpm_ioctl_init->tpid_combo);
+		break;
+	case TPM_IOCTL_INIT_TPID_COMB_DEL:
+		ret = tpm_init_tpid_combo_del(&tpm_ioctl_init->tpid_combo);
+		break;
+	case TPM_IOCTL_INIT_TRACE_FLAG_SET:
+		ret = tpm_init_trace_debug_flag_set(tpm_ioctl_init->trace_debug_flag);
+		break;
+	case TPM_IOCTL_INIT_QOS_TBL_OWNER_SET:
+		ret = tpm_init_qos_tbl_ext_set(tpm_ioctl_init->qos_tbl_owner);
+		break;
+	case TPM_IOCTL_INIT_MODULE_START:
+		ret = tpm_module_start();
+		break;
+	case TPM_IOCTL_INIT_MIB_RESET:
+		ret = tpm_module_mib_reset(tpm_ioctl_init->reset_level);
+		break;
+	default:
+		ret = TPM_BAD_PARAM;
+		break;
+	}
+	IF_ERROR_STR(TPM_IOCTL_MOD, ret, "TPM init(%d) failed\n", tpm_ioctl_init->cmd);
+
+	return ret;
+}
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+/*******************************************************************************
+* tpm_cdev_switch_ioctl
+*
+* DESCRIPTION: The routine is to implent TPM switch ioctl..
+*
+* INPUTS:
+*           tpm_ioctl_switch  - TPM switch operation parameters
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_cdev_switch_ioctl(struct tpm_ioctl_switch_oper_t *tpm_ioctl_switch)
+{
+	int ret = TPM_OK;
+
+	/* Parameter Check */
+	IF_NULL(TPM_IOCTL_MOD, tpm_ioctl_switch);
+
+	switch (tpm_ioctl_switch->cmd) {
+	case TPM_IOCTL_SWITCH_VLAN_INGRESS_SET:
+		ret = mv_tpm_sw_vlan_ingress_mode_set(tpm_ioctl_switch->switch_port,
+						      tpm_ioctl_switch->ingress_mode);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_INGRESS_GET:
+		ret = mv_tpm_sw_vlan_ingress_mode_get(tpm_ioctl_switch->switch_port,
+						      &tpm_ioctl_switch->ingress_mode);
+		break;
+	case TPM_IOCTL_SWITCH_PBIT_VID_SET:
+		ret = mv_tpm_sw_pvid_set(tpm_ioctl_switch->switch_port,
+					 tpm_ioctl_switch->pvid.vid,
+					 tpm_ioctl_switch->pvid.pri);
+		break;
+	case TPM_IOCTL_SWITCH_PBIT_VID_GET:
+		ret = mv_tpm_sw_pvid_get(tpm_ioctl_switch->switch_port,
+					 &tpm_ioctl_switch->pvid.vid,
+					 &tpm_ioctl_switch->pvid.pri);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_SET:
+		ret = mv_tpm_sw_vlan_set(tpm_ioctl_switch->switch_port,
+					 tpm_ioctl_switch->vlan_grp.min_vlan,
+					 tpm_ioctl_switch->vlan_grp.max_vlan,
+					 tpm_ioctl_switch->vlan_grp.mode);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_DEL:
+		ret = mv_tpm_sw_vlan_del(tpm_ioctl_switch->switch_port,
+					 tpm_ioctl_switch->vlan_grp.min_vlan,
+					 tpm_ioctl_switch->vlan_grp.max_vlan);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_GET:
+		ret = mv_tpm_sw_vlan_get(tpm_ioctl_switch->vlan_grp.vlan,
+					 &tpm_ioctl_switch->vlan_grp.fwd_bm,
+					 &tpm_ioctl_switch->vlan_grp.tag_bm);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_FILTER_SET:
+		ret = mv_tpm_sw_vlan_filter_set(tpm_ioctl_switch->switch_port,
+						tpm_ioctl_switch->vlan_filter_mode);
+		break;
+	case TPM_IOCTL_SWITCH_VLAN_FILTER_GET:
+		ret = mv_tpm_sw_enable_state_get(tpm_ioctl_switch->switch_port,
+						 &tpm_ioctl_switch->vlan_filter_mode);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STATE_SET:
+		ret = mv_tpm_sw_enable_state_set(tpm_ioctl_switch->switch_port,
+						 tpm_ioctl_switch->port_enable);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STATE_GET:
+		ret = mv_tpm_sw_enable_state_get(tpm_ioctl_switch->switch_port,
+						 &tpm_ioctl_switch->port_enable);
+		break;
+	case TPM_IOCTL_SWITCH_FLOW_CTL_SET:
+		ret = mv_tpm_sw_flow_control_set(tpm_ioctl_switch->switch_port,
+						 tpm_ioctl_switch->flow_ctl.enable,
+						 tpm_ioctl_switch->flow_ctl.pause_interval);
+		break;
+	case TPM_IOCTL_SWITCH_FLOW_CTL_GET:
+		ret = mv_tpm_sw_flow_control_get(tpm_ioctl_switch->switch_port,
+						 &tpm_ioctl_switch->flow_ctl.enable,
+						 &tpm_ioctl_switch->flow_ctl.pause_interval);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_ISOLATE_SET:
+		ret = mv_tpm_sw_isolate_mask_set(tpm_ioctl_switch->switch_port,
+						 tpm_ioctl_switch->port_isolate_mask);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_ISOLATE_GET:
+		ret = mv_tpm_sw_isolate_mask_get(tpm_ioctl_switch->switch_port,
+						 &tpm_ioctl_switch->port_isolate_mask);
+		break;
+	case TPM_IOCTL_SWITCH_FLOOD_CTL_SET:
+		ret = mv_tpm_sw_flood_control_mask_set(tpm_ioctl_switch->switch_port,
+						       tpm_ioctl_switch->flood_ctl.pkt_type,
+						       tpm_ioctl_switch->flood_ctl.port_mask);
+		break;
+	case TPM_IOCTL_SWITCH_FLOOD_CTL_GET:
+		ret = mv_tpm_sw_flood_control_mask_get(tpm_ioctl_switch->switch_port,
+						       tpm_ioctl_switch->flood_ctl.pkt_type,
+						       &tpm_ioctl_switch->flood_ctl.port_mask);
+		break;
+	case TPM_IOCTL_SWITCH_ONU_CNT_CLEAR:
+		ret = mv_tpm_sw_all_count_clear();
+		break;
+	case TPM_IOCTL_SWITCH_PORT_CNT_CLEAR:
+		ret = mv_tpm_sw_port_count_clear(tpm_ioctl_switch->switch_port);
+		break;
+	case TPM_IOCTL_SWITCH_LINK_MODE_SET:
+		ret = mv_tpm_sw_link_mode_set(tpm_ioctl_switch->switch_port,
+					      tpm_ioctl_switch->link_mode.auto_en,
+					      tpm_ioctl_switch->link_mode.speed,
+					      tpm_ioctl_switch->link_mode.duplex);
+		break;
+	case TPM_IOCTL_SWITCH_LINK_MODE_GET:
+		ret = mv_tpm_sw_link_mode_get(tpm_ioctl_switch->switch_port,
+					      &tpm_ioctl_switch->link_mode.auto_en,
+					      &tpm_ioctl_switch->link_mode.speed,
+					      &tpm_ioctl_switch->link_mode.duplex);
+		break;
+	case TPM_IOCTL_SWITCH_LINK_STATE_GET:
+		ret = mv_tpm_sw_link_state_get(tpm_ioctl_switch->switch_port,
+					       &tpm_ioctl_switch->link_state.link,
+					       &tpm_ioctl_switch->link_state.speed,
+					       &tpm_ioctl_switch->link_state.duplex);
+		break;
+	case TPM_IOCTL_SWITCH_RATE_LIMIT_SET:
+		ret = mv_tpm_sw_rate_limit_set(tpm_ioctl_switch->switch_port,
+					       tpm_ioctl_switch->rate_cfg.dir,
+					       tpm_ioctl_switch->rate_cfg.enable,
+					       tpm_ioctl_switch->rate_cfg.mode,
+					       tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_RATE_LIMIT_GET:
+		ret = mv_tpm_sw_rate_limit_get(tpm_ioctl_switch->switch_port,
+					       tpm_ioctl_switch->rate_cfg.dir,
+					       &tpm_ioctl_switch->rate_cfg.enable,
+					       &tpm_ioctl_switch->rate_cfg.mode,
+					       &tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_MC_PROTO_RATE_SET:
+		ret = mv_tpm_sw_mc_proto_rate_set(tpm_ioctl_switch->switch_port,
+						  tpm_ioctl_switch->rate_cfg.dir,
+						  tpm_ioctl_switch->rate_cfg.enable,
+						  tpm_ioctl_switch->rate_cfg.mode,
+						  tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_MC_PROTO_RATE_GET:
+		ret = mv_tpm_sw_mc_proto_rate_get(tpm_ioctl_switch->switch_port,
+						  tpm_ioctl_switch->rate_cfg.dir,
+						  &tpm_ioctl_switch->rate_cfg.enable,
+						  &tpm_ioctl_switch->rate_cfg.mode,
+						  &tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_MC_DATA_RATE_SET:
+		ret = mv_tpm_sw_mc_data_rate_set(tpm_ioctl_switch->switch_port,
+						 tpm_ioctl_switch->rate_cfg.dir,
+						 tpm_ioctl_switch->rate_cfg.enable,
+						 tpm_ioctl_switch->rate_cfg.mode,
+						 tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_MC_DATA_RATE_GET:
+		ret = mv_tpm_sw_mc_data_rate_get(tpm_ioctl_switch->switch_port,
+						 tpm_ioctl_switch->rate_cfg.dir,
+						 &tpm_ioctl_switch->rate_cfg.enable,
+						 &tpm_ioctl_switch->rate_cfg.mode,
+						 &tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_BC_RATE_SET:
+		ret = mv_tpm_sw_broadcast_rate_set(tpm_ioctl_switch->switch_port,
+						   tpm_ioctl_switch->rate_cfg.dir,
+						   tpm_ioctl_switch->rate_cfg.enable,
+						   tpm_ioctl_switch->rate_cfg.mode,
+						   tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_BC_RATE_GET:
+		ret = mv_tpm_sw_broadcast_rate_get(tpm_ioctl_switch->switch_port,
+						   tpm_ioctl_switch->rate_cfg.dir,
+						   &tpm_ioctl_switch->rate_cfg.enable,
+						   &tpm_ioctl_switch->rate_cfg.mode,
+						   &tpm_ioctl_switch->rate_cfg.rate);
+		break;
+	case TPM_IOCTL_SWITCH_MIRROR_SET:
+		ret = mv_tpm_sw_mirror_set(tpm_ioctl_switch->switch_port,
+					   tpm_ioctl_switch->mirror.dir,
+					   tpm_ioctl_switch->mirror.enable,
+					   tpm_ioctl_switch->mirror.dport);
+		break;
+	case TPM_IOCTL_SWITCH_MIRROR_GET:
+		ret = mv_tpm_sw_mirror_get(tpm_ioctl_switch->switch_port,
+					   tpm_ioctl_switch->mirror.dir,
+					   &tpm_ioctl_switch->mirror.enable,
+					   &tpm_ioctl_switch->mirror.dport);
+		break;
+	case TPM_IOCTL_SWITCH_LPK_SET:
+		ret = mv_tpm_sw_loopback_set(tpm_ioctl_switch->switch_port,
+					     tpm_ioctl_switch->loopback.dir,
+					     tpm_ioctl_switch->loopback.enable);
+		break;
+	case TPM_IOCTL_SWITCH_LPK_GET:
+		ret = mv_tpm_sw_loopback_get(tpm_ioctl_switch->switch_port,
+					     tpm_ioctl_switch->loopback.dir,
+					     &tpm_ioctl_switch->loopback.enable);
+		break;
+	case TPM_IOCTL_SWITCH_AGING_SET:
+		ret = mv_tpm_sw_mac_aging_time_set(tpm_ioctl_switch->age_time);
+		break;
+	case TPM_IOCTL_SWITCH_AGING_GET:
+		ret = mv_tpm_sw_mac_aging_time_get(&tpm_ioctl_switch->age_time);
+		break;
+	case TPM_IOCTL_SWITCH_MAC_LIMIT_SET:
+		ret = mv_tpm_sw_mac_learn_limit_set(tpm_ioctl_switch->switch_port,
+						    tpm_ioctl_switch->mac_learn_limit.enable,
+						    tpm_ioctl_switch->mac_learn_limit.limit);
+		break;
+	case TPM_IOCTL_SWITCH_MAC_LIMIT_GET:
+		ret = mv_tpm_sw_mac_learn_limit_get(tpm_ioctl_switch->switch_port,
+						    &tpm_ioctl_switch->mac_learn_limit.enable,
+						    &tpm_ioctl_switch->mac_learn_limit.limit);
+		break;
+	case TPM_IOCTL_SWITCH_MAC_ADDR_ADD:
+		ret = mv_tpm_sw_mac_address_add(tpm_ioctl_switch->mac_addr_op.port_bm,
+						tpm_ioctl_switch->mac_addr_op.mac,
+						tpm_ioctl_switch->mac_addr_op.vlan,
+						tpm_ioctl_switch->mac_addr_op.mode);
+		break;
+	case TPM_IOCTL_SWITCH_MAC_ADDR_DEL:
+		ret = mv_tpm_sw_mac_address_del(tpm_ioctl_switch->switch_port,
+						tpm_ioctl_switch->mac_addr_op.mac,
+						tpm_ioctl_switch->mac_addr_op.vlan);
+		break;
+	case TPM_IOCTL_SWITCH_FILTER_MODE_SET:
+		ret = mv_tpm_sw_mac_filter_mode_set(tpm_ioctl_switch->switch_port,
+						    tpm_ioctl_switch->filter_mode);
+		break;
+	case TPM_IOCTL_SWITCH_FILTER_MODE_GET:
+		ret = mv_tpm_sw_mac_filter_mode_get(tpm_ioctl_switch->switch_port,
+						    &tpm_ioctl_switch->filter_mode);
+		break;
+	case TPM_IOCTL_SWITCH_FILTER_ENTRY_ADD:
+		ret = mv_tpm_sw_mac_filter_entry_add(tpm_ioctl_switch->switch_port,
+						     tpm_ioctl_switch->mac_addr_op.mac,
+						     tpm_ioctl_switch->mac_addr_op.vlan,
+						     tpm_ioctl_switch->mac_addr_op.mode);
+		break;
+	case TPM_IOCTL_SWITCH_FILTER_ENTRY_DEL:
+		ret = mv_tpm_sw_mac_filter_entry_del(tpm_ioctl_switch->switch_port,
+						     tpm_ioctl_switch->mac_addr_op.mac,
+						     tpm_ioctl_switch->mac_addr_op.vlan,
+						     tpm_ioctl_switch->mac_addr_op.mode);
+		break;
+	case TPM_IOCTL_SWITCH_ONU_MAC_CLEAR:
+		ret = mv_tpm_sw_mac_address_clear();
+		break;
+	case TPM_IOCTL_SWITCH_PORT_MAC_TBL_CLEAR:
+		ret = mv_tpm_sw_mac_table_clear(tpm_ioctl_switch->switch_port,
+						tpm_ioctl_switch->mac_clear_mode);
+		break;
+	case TPM_IOCTL_SWITCH_QOS_SET:
+		ret = mv_tpm_sw_qos_set(tpm_ioctl_switch->switch_port,
+					tpm_ioctl_switch->qos.queue,
+					tpm_ioctl_switch->qos.mode,
+					tpm_ioctl_switch->qos.weight);
+		break;
+	case TPM_IOCTL_SWITCH_QOS_GET:
+		ret = mv_tpm_sw_qos_get(tpm_ioctl_switch->switch_port,
+					tpm_ioctl_switch->qos.queue,
+					&tpm_ioctl_switch->qos.mode,
+					&tpm_ioctl_switch->qos.weight);
+		break;
+	case TPM_IOCTL_SWITCH_MTU_SET:
+		ret = mv_tpm_sw_mtu_set(tpm_ioctl_switch->mtu);
+		break;
+	case TPM_IOCTL_SWITCH_MTU_GET:
+		ret = mv_tpm_sw_mtu_get(&tpm_ioctl_switch->mtu);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STAT1_GET:
+		ret = mv_tpm_sw_stat1_get(tpm_ioctl_switch->switch_port,
+					  tpm_ioctl_switch->count_reset,
+					  &tpm_ioctl_switch->switch_stat1);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STAT2_GET:
+		ret = mv_tpm_sw_stat2_get(tpm_ioctl_switch->switch_port,
+					  tpm_ioctl_switch->count_reset,
+					  &tpm_ioctl_switch->switch_stat2);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STAT3_GET:
+		ret = mv_tpm_sw_stat3_get(tpm_ioctl_switch->switch_port,
+					  tpm_ioctl_switch->count_reset,
+					  &tpm_ioctl_switch->switch_stat3);
+		break;
+	case TPM_IOCTL_SWITCH_PORT_STAT_ALL_GET:
+		ret = mv_tpm_sw_stat_all_get(tpm_ioctl_switch->switch_port,
+					     tpm_ioctl_switch->count_reset,
+					     &tpm_ioctl_switch->switch_stat_all);
+		break;
+	default:
+		ret = TPM_BAD_PARAM;
+		break;
+	}
+	IF_ERROR_STR(TPM_IOCTL_MOD, ret, "Switch op(%d) failed\n", tpm_ioctl_switch->cmd);
+
+	return ret;
+}
+#endif
+
+/*******************************************************************************
+* tpm_cdev_acl_rule_ioctl
+*
+* DESCRIPTION: The routine is to implent ACL rule operation (ADD, DEL, etc.)
+*
+* INPUTS:
+*           tpm_ioctl_acl_rule_t  - Parameters for ACL rule operation
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_cdev_acl_rule_ioctl(struct tpm_ioctl_acl_rule_t *tpm_ioctl_acl_rule)
+{
+	int ret = TPM_OK;
+
+	/* Parameter Check */
+	IF_NULL(TPM_IOCTL_MOD, tpm_ioctl_acl_rule);
+
+	switch (tpm_ioctl_acl_rule->cmd) {
+	case TPM_IOCTL_ACL_EXACT_ADD:
+		ret = mv_tpm_exact_match_rule_add(&tpm_ioctl_acl_rule->exact_add_para.exact_match,
+						  tpm_ioctl_acl_rule->exact_add_para.num_pp_trgt,
+						  tpm_ioctl_acl_rule->exact_add_para.action,
+						  tpm_ioctl_acl_rule->exact_add_para.policer_id,
+						  &tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_EXACT_DEL:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_exact_match_rule_del(NULL, tpm_ioctl_acl_rule->rule_id);
+		} else {
+			ret = mv_tpm_exact_match_rule_del(&tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t,
+								 tpm_ioctl_acl_rule->rule_id);
+		}
+		break;
+	case TPM_IOCTL_ACL_EXACT_DEL_ALL:
+		ret = mv_tpm_exact_match_rule_del_all();
+		break;
+	case TPM_IOCTL_ACL_EXACT_CNTR_GET:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_exact_match_rule_cntr_get(NULL,
+							       tpm_ioctl_acl_rule->rule_id,
+							       &tpm_ioctl_acl_rule->cntr);
+		} else {
+			ret =
+			mv_tpm_exact_match_rule_cntr_get(&tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t,
+							 tpm_ioctl_acl_rule->rule_id,
+							 &tpm_ioctl_acl_rule->cntr);
+		}
+		break;
+	case TPM_IOCTL_ACL_EXACT_EXCEPT_ADD:
+		ret = mv_tpm_exact_match_except_rule_add(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+							 tpm_ioctl_acl_rule->rule_add_para.action,
+							 tpm_ioctl_acl_rule->rule_add_para.policer_id,
+							 &tpm_ioctl_acl_rule->rule_add_para.qos,
+							 &tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_EXACT_EXCEPT_DEL:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_exact_match_except_rule_del(NULL, tpm_ioctl_acl_rule->rule_id);
+		} else {
+			ret = mv_tpm_exact_match_except_rule_del(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+								 tpm_ioctl_acl_rule->rule_id);
+		}
+		break;
+	case TPM_IOCTL_ACL_EXACT_EXCEPT_DEL_ALL:
+		ret = mv_tpm_exact_match_except_rule_del_all();
+		break;
+	case TPM_IOCTL_ACL_EXACT_EXCEPT_CNTR_GET:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_exact_match_except_rule_cntr_get(NULL,
+								      tpm_ioctl_acl_rule->rule_id,
+								      &tpm_ioctl_acl_rule->cntr);
+		} else {
+			ret = mv_tpm_exact_match_except_rule_cntr_get(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+							  tpm_ioctl_acl_rule->rule_id,
+							  &tpm_ioctl_acl_rule->cntr);
+		}
+		break;
+	case TPM_IOCTL_ACL_GEN_CLS_ADD:
+		ret = mv_tpm_gen_cls_rule_add(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+					      tpm_ioctl_acl_rule->rule_add_para.num_pp_trgt,
+					      tpm_ioctl_acl_rule->rule_add_para.action,
+					      tpm_ioctl_acl_rule->rule_add_para.policer_id,
+					      &tpm_ioctl_acl_rule->rule_add_para.qos,
+					      &tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_GEN_CLS_DEL:
+		ret = mv_tpm_gen_cls_rule_del(NULL, tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_GEN_CLS_DEL_ALL:
+		ret = mv_tpm_gen_cls_rule_del_all();
+		break;
+	case TPM_IOCTL_ACL_GEN_CLS_CNTR_GET:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_gen_cls_rule_cntr_get(NULL,
+							   tpm_ioctl_acl_rule->rule_id,
+							   &tpm_ioctl_acl_rule->cntr);
+		} else {
+			ret = mv_tpm_gen_cls_rule_cntr_get(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+							  tpm_ioctl_acl_rule->rule_id,
+							  &tpm_ioctl_acl_rule->cntr);
+		}
+		break;
+	case TPM_IOCTL_ACL_MC_FLOW_ADD:
+		ret = mv_tpm_mc_flow_add(&tpm_ioctl_acl_rule->rule_add_para.match_key,
+					 tpm_ioctl_acl_rule->rule_add_para.num_pp_trgt,
+					 tpm_ioctl_acl_rule->rule_add_para.action,
+					 &tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_MC_FLOW_DEL:
+		ret = mv_tpm_mc_flow_del(tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_MC_FLOW_DEL_ALL:
+		ret = mv_tpm_mc_flow_del_all();
+		break;
+	case TPM_IOCTL_ACL_CM_ADD:
+		ret = mv_tpm_cm_rule_add(&tpm_ioctl_acl_rule->cm_add_para.cnm_key,
+					 &tpm_ioctl_acl_rule->cm_add_para.action);
+		break;
+	case TPM_IOCTL_ACL_CM_DEL:
+		ret = mv_tpm_cm_rule_del(&tpm_ioctl_acl_rule->cm_add_para.cnm_key.match_key.port,
+					 tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_CM_DEL_ALL:
+		ret = mv_tpm_cm_rule_del_all(tpm_ioctl_acl_rule->cm_add_para.cnm_key.match_key.port.class_port);
+		break;
+	case TPM_IOCTL_ACL_FILTER_ADD:
+		ret = mv_tpm_filter_rule_add(&tpm_ioctl_acl_rule->filter_add_para.match_key,
+					     tpm_ioctl_acl_rule->filter_add_para.frwd,
+					     &tpm_ioctl_acl_rule->rule_id);
+		break;
+	case TPM_IOCTL_ACL_FILTER_DEL:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_filter_rule_del(NULL, tpm_ioctl_acl_rule->rule_id);
+		} else {
+			ret = mv_tpm_filter_rule_del(&tpm_ioctl_acl_rule->filter_add_para.match_key,
+						     tpm_ioctl_acl_rule->rule_id);
+		}
+		break;
+	case TPM_IOCTL_ACL_FILTER_DEL_ALL:
+		ret = mv_tpm_filter_rule_del_all();
+		break;
+	case TPM_IOCTL_ACL_FILTER_CNTR_GET:
+		if (TPM_RULE_ID_INVALID != tpm_ioctl_acl_rule->rule_id) {
+			ret = mv_tpm_filter_rule_cntr_get(NULL, tpm_ioctl_acl_rule->rule_id, &tpm_ioctl_acl_rule->cntr);
+		} else {
+			ret = mv_tpm_filter_rule_cntr_get(&tpm_ioctl_acl_rule->filter_add_para.match_key,
+							  tpm_ioctl_acl_rule->rule_id,
+							  &tpm_ioctl_acl_rule->cntr);
+		}
+		break;
+	case TPM_IOCTL_ACL_FILTER_DEF_CNTR_GET:
+		ret = mv_tpm_filter_def_rule_cntr_get(tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.rule_type,
+						      tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.field_bm,
+						      tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.vlan_num,
+						      &tpm_ioctl_acl_rule->cntr);
+		break;
+	case TPM_IOCTL_ACL_MTM_ADD:
+		ret = mv_tpm_mtm_add(tpm_ioctl_acl_rule->mtm_add_para.port, tpm_ioctl_acl_rule->mtm_add_para.mac);
+		break;
+	case TPM_IOCTL_ACL_MTM_DEL:
+		ret = mv_tpm_mtm_del(tpm_ioctl_acl_rule->mtm_add_para.port, tpm_ioctl_acl_rule->mtm_add_para.mac);
+		break;
+	default:
+		ret = TPM_BAD_PARAM;
+		break;
+	}
+	IF_ERROR_STR(TPM_IOCTL_MOD, ret, "ACL rule op(%d) failed\n", tpm_ioctl_acl_rule->cmd);
+
+	return ret;
+}
+
+/*******************************************************************************
+* tpm_cdev_pp_oper_ioctl
+*
+* DESCRIPTION: The routine is to implent PP operation
+*
+* INPUTS:
+*           tpm_ioctl_acl_rule_t  - Parameters for ACL rule operation
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_cdev_pp_oper_ioctl(struct tpm_ioctl_pp_oper_t *pp_oper)
+{
+	int ret = TPM_OK;
+
+	/* Parameter Check */
+	IF_NULL(TPM_IOCTL_MOD, pp_oper);
+
+	switch (pp_oper->cmd) {
+	case TPM_IOCTL_PP_SCHED_EGR_MTU_SET:
+		ret = mv_tpm_sched_egr_mtu_set(pp_oper->pp_sched_egr_mtu.gmac_idx,
+					       pp_oper->pp_sched_egr_mtu.tcont_id,
+					       pp_oper->pp_sched_egr_mtu.tx_size_max);
+		break;
+	case TPM_IOCTL_PP_SCHED_EGR_Q_MODE_SET:
+		ret = mv_tpm_sched_egr_queue_mode_set(pp_oper->pp_sched_egr_q_mode.gmac_idx,
+						pp_oper->pp_sched_egr_q_mode.tcont_id,
+						pp_oper->pp_sched_egr_q_mode.queue_id,
+						pp_oper->pp_sched_egr_q_mode.mode,
+						pp_oper->pp_sched_egr_q_mode.wrr_weight);
+		break;
+	case TPM_IOCTL_PP_SCHED_EGR_Q_RATE_LIM_SET:
+		ret = mv_tpm_sched_egr_queue_rate_lim_set(pp_oper->pp_sched_egr_q_rate_lim.gmac_idx,
+							pp_oper->pp_sched_egr_q_rate_lim.tcont_id,
+							pp_oper->pp_sched_egr_q_rate_lim.queue_id,
+							pp_oper->pp_sched_egr_q_rate_lim.rate_lim_val,
+							pp_oper->pp_sched_egr_q_rate_lim.bucket_size);
+		break;
+	case TPM_IOCTL_PP_SCHED_EGR_PORT_RATE_LIM_SET:
+		ret = mv_tpm_sched_egr_port_rate_lim_set(pp_oper->pp_sched_egr_port_rate_lim.gmac_idx,
+							pp_oper->pp_sched_egr_port_rate_lim.tcont_id,
+							pp_oper->pp_sched_egr_port_rate_lim.rate_lim_val,
+							pp_oper->pp_sched_egr_port_rate_lim.bucket_size);
+		break;
+	case TPM_IOCTL_PP_QOS_TBL_ENTRY_SET:
+		ret = mv_tpm_qos_table_entry_set(pp_oper->pp_qos_tbl_set.qos_select,
+						pp_oper->pp_qos_tbl_set.qos_tbl,
+						pp_oper->pp_qos_tbl_set.entry,
+						&pp_oper->pp_qos_tbl_set.qos_cfg);
+		break;
+	case TPM_IOCTL_PP_QOS_TBL_SET:
+		ret = mv_tpm_qos_table_set(pp_oper->pp_qos_tbl_set.qos_select,
+					pp_oper->pp_qos_tbl_set.qos_tbl,
+					&pp_oper->pp_qos_tbl_set.qos_cfg);
+		break;
+	case TPM_IOCTL_PP_PLCR_ADD:
+		ret = mv_tpm_plcr_add(&pp_oper->pp_plcr.policer_entry,
+				&pp_oper->pp_plcr.policer_id);
+		break;
+	case TPM_IOCTL_PP_PLCR_DEL:
+		ret = mv_tpm_plcr_del(pp_oper->pp_plcr.policer_id);
+		break;
+	case TPM_IOCTL_PP_PLCR_DEL_ALL:
+		ret = mv_tpm_plcr_clear();
+		break;
+	default:
+		ret = TPM_BAD_PARAM;
+		break;
+	}
+	IF_ERROR_STR(TPM_IOCTL_MOD, ret, "PP op(%d) failed\n", pp_oper->cmd);
+
+	return ret;
+}
+
+/*******************************************************************************
+* tpm_mempool_select
+*
+* DESCRIPTION: The routine select mempool according to size.
+*
+* INPUTS:
+*           size  - allocated pool size, unit:Byte
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static struct tpm_common_mempool_t *tpm_mempool_select(unsigned int size)
+{
+	struct tpm_common_mempool_t	*pool = NULL;
+
+	if (size <= MPOOL_S_MAX_BUFF_SIZE)
+		pool = tpm_ioctl_mpools.mpool_s;
+	else if (size <= MPOOL_M_MAX_BUFF_SIZE && size > MPOOL_S_MAX_BUFF_SIZE)
+		pool = tpm_ioctl_mpools.mpool_m;
+	else if (size <= MPOOL_L_MAX_BUFF_SIZE && size > MPOOL_M_MAX_BUFF_SIZE)
+		pool = tpm_ioctl_mpools.mpool_l;
+	else if (size <= MPOOL_H_MAX_BUFF_SIZE && size > MPOOL_L_MAX_BUFF_SIZE)
+		pool = tpm_ioctl_mpools.mpool_h;
+
+	return pool;
+}
+
+/*******************************************************************************
+* tpm_cdev_ioctl
+*
+* DESCRIPTION: The routine is TPM char device ioctl implement function.
+*
+* INPUTS:
+*           inode  - device node, for Linux version under 2.6.36
+*           filp   - file node
+*           cmd    - IOCTL command from user
+*           arg    - parameter to run command
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_RC_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           Since Linux2.6.36, kernel ioctl structure has been updated
+*******************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+int tpm_cdev_ioctl(struct inode *inode,
+		   struct file *filp,
+		   unsigned int cmd,
+		   unsigned long arg)
+#else
+long tpm_cdev_ioctl(struct file *filp,
+		    unsigned int cmd,
+		    unsigned long arg)
+#endif
+{
+	int				rcode;
+	int				ret = -EINVAL;
+	void				*mem_buff = NULL;
+	struct tpm_common_mempool_t	*pool = NULL;
+	unsigned int			struct_size = 0;
+
+	switch (cmd) {
+	/* TPM Init Section */
+	case MV_TPM_IOCTL_INIT_SECTION:
+	{
+		struct tpm_ioctl_init_t *tpm_ioctl_init = NULL;
+		struct_size = sizeof(struct tpm_ioctl_init_t);
+		pool = tpm_mempool_select(struct_size);
+		if (NULL == pool)
+			goto ioctlErr;
+		/* Allocate mempool */
+		tpm_ioctl_init = (struct tpm_ioctl_init_t *)tpm_common_mempool_alloc(pool);
+		if (NULL == tpm_ioctl_init) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) tpm_common_mempool_alloc(%p) failed\n",
+				     __func__, __LINE__, pool);
+			ret = -ENOMEM;
+			goto ioctlErr;
+		}
+		mem_buff = tpm_ioctl_init;
+		/* Copy user space parameter to kernel space */
+		if (copy_from_user(tpm_ioctl_init,
+				  (struct tpm_ioctl_init_t *)arg,
+				  sizeof(struct tpm_ioctl_init_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_from_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		/* Excute command */
+		rcode = tpm_cdev_init_ioctl(tpm_ioctl_init);
+		if (rcode != TPM_OK)
+			goto ioctlErr;
+		/* Copy data needed to user space */
+		if (copy_to_user((struct tpm_ioctl_init_t *)arg,
+				tpm_ioctl_init,
+				sizeof(struct tpm_ioctl_init_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_to_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+	}
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	/* TPM Switch Section */
+	case MV_TPM_IOCTL_SWITCH_SECTION:
+	{
+		struct tpm_ioctl_switch_oper_t *tpm_ioctl_switch = NULL;
+		struct_size = sizeof(struct tpm_ioctl_switch_oper_t);
+		pool = tpm_mempool_select(struct_size);
+		if (NULL == pool)
+			goto ioctlErr;
+		/* Allocate mempool */
+		tpm_ioctl_switch = (struct tpm_ioctl_switch_oper_t *)tpm_common_mempool_alloc(pool);
+		if (NULL == tpm_ioctl_switch) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) tpm_common_mempool_alloc(%p) failed\n",
+				__func__, __LINE__, pool);
+			ret = -ENOMEM;
+			goto ioctlErr;
+		}
+		mem_buff = tpm_ioctl_switch;
+		/* Copy user space parameter to kernel space */
+		if (copy_from_user(tpm_ioctl_switch,
+				  (struct tpm_ioctl_switch_oper_t *)arg,
+				  sizeof(struct tpm_ioctl_switch_oper_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_from_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		/* Excute command */
+		rcode = tpm_cdev_switch_ioctl(tpm_ioctl_switch);
+		if (rcode != TPM_OK)
+			goto ioctlErr;
+		/* Copy data needed to user space */
+		if (copy_to_user((struct tpm_ioctl_switch_oper_t *)arg,
+				tpm_ioctl_switch,
+				sizeof(struct tpm_ioctl_switch_oper_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_to_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+	}
+#endif
+	/* TPM ALC Rule Section */
+	case MV_TPM_IOCTL_ACL_RULE_SECTION:
+	{
+		struct tpm_ioctl_acl_rule_t *tpm_ioctl_acl_rule = NULL;
+		struct_size = sizeof(struct tpm_ioctl_acl_rule_t);
+		pool = tpm_mempool_select(struct_size);
+		if (NULL == pool)
+			goto ioctlErr;
+		/* Allocate mempool */
+		tpm_ioctl_acl_rule = (struct tpm_ioctl_acl_rule_t *)tpm_common_mempool_alloc(pool);
+		if (NULL == tpm_ioctl_acl_rule) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) tpm_common_mempool_alloc(%p) failed\n",
+				     __func__, __LINE__, pool);
+			ret = -ENOMEM;
+			goto ioctlErr;
+		}
+		mem_buff = tpm_ioctl_acl_rule;
+		/* Copy user space parameter to kernel space */
+		if (copy_from_user(tpm_ioctl_acl_rule,
+				  (struct tpm_ioctl_acl_rule_t *)arg,
+				  sizeof(struct tpm_ioctl_acl_rule_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_from_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		/* Excute command */
+		rcode = tpm_cdev_acl_rule_ioctl(tpm_ioctl_acl_rule);
+		if (rcode != TPM_OK)
+			goto ioctlErr;
+		/* Copy data needed to user space */
+		if (copy_to_user((struct tpm_ioctl_acl_rule_t *)arg,
+				tpm_ioctl_acl_rule,
+				sizeof(struct tpm_ioctl_acl_rule_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_to_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+	}
+	/* TPM PP operation Section */
+	case MV_TPM_IOCTL_PP_SECTION:
+	{
+		struct tpm_ioctl_pp_oper_t *pp_oper = NULL;
+		struct_size = sizeof(struct tpm_ioctl_pp_oper_t);
+		pool = tpm_mempool_select(struct_size);
+		if (NULL == pool)
+			goto ioctlErr;
+		/* Allocate mempool */
+		pp_oper = (struct tpm_ioctl_pp_oper_t *)tpm_common_mempool_alloc(pool);
+		if (NULL == pp_oper) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) tpm_common_mempool_alloc(%p) failed\n",
+				__func__, __LINE__, pool);
+			ret = -ENOMEM;
+			goto ioctlErr;
+		}
+		mem_buff = pp_oper;
+		/* Copy user space parameter to kernel space */
+		if (copy_from_user(pp_oper,
+				  (struct tpm_ioctl_pp_oper_t *)arg,
+				  sizeof(struct tpm_ioctl_pp_oper_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_from_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		/* Excute command */
+		rcode = tpm_cdev_pp_oper_ioctl(pp_oper);
+		if (rcode != TPM_OK)
+			goto ioctlErr;
+		/* Copy data needed to user space */
+		if (copy_to_user((struct tpm_ioctl_pp_oper_t *)arg,
+				pp_oper,
+				sizeof(struct tpm_ioctl_pp_oper_t))) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) copy_to_user failed\n", __func__, __LINE__);
+			goto ioctlErr;
+		}
+		ret = 0;
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+ioctlErr:
+		if (mem_buff != NULL)
+			tpm_common_mempool_free(pool, mem_buff);
+
+	return ret;
+}
+
+/*******************************************************************************
+* tpm_cdev_open
+*
+* DESCRIPTION: Open TPM char device
+*
+* INPUTS:
+*           inode  - device node
+*           filp   - file node
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns 0.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_cdev_open(struct inode *inode, struct file *filp)
+{
+	struct tpm_module_cdev_t *dev;
+
+	tpm_cdev_open_num++;
+	try_module_get(THIS_MODULE);
+
+	/* find the device structure */
+	dev = container_of(inode->i_cdev, struct tpm_module_cdev_t, cdev);
+	filp->private_data = dev;
+
+	return 0;
+}
+
+/*******************************************************************************
+* tpm_cdev_release
+*
+* DESCRIPTION: Close TPM char device
+*
+* INPUTS:
+*           inode  - device node
+*           filp   - file node
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns 0.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_cdev_release(struct inode *inode, struct file *filp)
+{
+	tpm_cdev_open_num--;
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+/*******************************************************************************
+* tpm_cdev_read
+*
+* DESCRIPTION: The function waites for data to be written to tpm_sfs_2_ioctl_command
+*               and copies it to user space to be used by IOCTLed
+*
+* INPUTS:
+*	    *file -  file descriptor
+*           *buf  -  user buffer
+*           count -  user buffer byte size
+*
+* OUTPUTS:
+*	    *ppos - position in file
+* RETURN:
+* On success, the function returns 0.
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+static ssize_t tpm_cdev_read(struct file *file,
+			     char __user *buf,
+			     size_t count,
+			     loff_t *ppos)
+{
+	int val;
+
+	val = down_interruptible(&tpm_sfs_2_ioctl_sem);
+	if (val != 0)
+		return val;
+
+	if (copy_to_user(buf, &tpm_sfs_2_ioctl_command, sizeof(struct tpm_ioctl_mng_t))) {
+		printk(KERN_ERR "ERROR: (%s:%d) copy_from_user failed\n", __func__, __LINE__);
+		return -EFAULT;
+	}
+
+	return sizeof(struct tpm_ioctl_mng_t);
+}
+#endif
+
+
+/* TPM device file operations */
+const struct file_operations tpm_cdev_fops = {
+	.owner   = THIS_MODULE,
+	.open    = tpm_cdev_open,
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+	.read    = tpm_cdev_read,
+#endif
+	.release = tpm_cdev_release,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
+	.ioctl   = tpm_cdev_ioctl
+#else
+	.unlocked_ioctl   = tpm_cdev_ioctl
+#endif
+};
+
+
+/*******************************************************************************
+* tpm_init_ioctl_mempools
+*
+* DESCRIPTION: The function allocates 3 memory pools for IOCTL operations
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+static int tpm_ioctl_mempools_init(void)
+{
+	struct tpm_mempool_alloc_t {
+		bool enable;
+		unsigned int entry_num;
+		unsigned int max_size;
+	};
+	struct tpm_mempool_alloc_t mempool_alloc[TPM_MPOOL_TYPE_MAX] = {{false, 0, 0},
+									{false, 0, 0},
+									{false, 0, 0},
+									{false, 0, 0} };
+	unsigned int ioctl_struct_size[] = {sizeof(struct tpm_ioctl_init_t),
+					sizeof(struct tpm_ioctl_switch_oper_t),
+					sizeof(struct tpm_ioctl_acl_rule_t)};
+	int i;
+
+	/* Check which type mempool are allocated and get its max size */
+	for (i = 0; i < (sizeof(ioctl_struct_size) / sizeof(unsigned int)); i++) {
+		if (ioctl_struct_size[i] <= MPOOL_S_MAX_BUFF_SIZE) {
+			mempool_alloc[TPM_MPOOL_TYPE_SMALL].enable = true;
+			mempool_alloc[TPM_MPOOL_TYPE_SMALL].entry_num++;
+			if (mempool_alloc[TPM_MPOOL_TYPE_SMALL].max_size < ioctl_struct_size[i])
+				mempool_alloc[TPM_MPOOL_TYPE_SMALL].max_size = ioctl_struct_size[i];
+		} else if (ioctl_struct_size[i] <= MPOOL_M_MAX_BUFF_SIZE &&
+			   ioctl_struct_size[i] > MPOOL_S_MAX_BUFF_SIZE) {
+			mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].enable = true;
+			mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].entry_num++;
+			if (mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].max_size < ioctl_struct_size[i])
+				mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].max_size = ioctl_struct_size[i];
+		} else if (ioctl_struct_size[i] <= MPOOL_L_MAX_BUFF_SIZE &&
+			  ioctl_struct_size[i] > MPOOL_M_MAX_BUFF_SIZE) {
+			mempool_alloc[TPM_MPOOL_TYPE_LARGE].enable = true;
+			mempool_alloc[TPM_MPOOL_TYPE_LARGE].entry_num++;
+			if (mempool_alloc[TPM_MPOOL_TYPE_LARGE].max_size < ioctl_struct_size[i])
+				mempool_alloc[TPM_MPOOL_TYPE_LARGE].max_size = ioctl_struct_size[i];
+		} else if (ioctl_struct_size[i] <= MPOOL_H_MAX_BUFF_SIZE &&
+			   ioctl_struct_size[i] > MPOOL_L_MAX_BUFF_SIZE) {
+			mempool_alloc[TPM_MPOOL_TYPE_HUGE].enable = true;
+			mempool_alloc[TPM_MPOOL_TYPE_HUGE].entry_num++;
+			if (mempool_alloc[TPM_MPOOL_TYPE_HUGE].max_size < ioctl_struct_size[i])
+				mempool_alloc[TPM_MPOOL_TYPE_HUGE].max_size = ioctl_struct_size[i];
+		} else if (ioctl_struct_size[i] > MPOOL_H_MAX_BUFF_SIZE) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "IOCTL mempool size is too large(%d/%d)\n",
+				     ioctl_struct_size[i], MPOOL_H_MAX_BUFF_SIZE);
+			return TPM_FAIL;
+		}
+	}
+
+	/* Allocate mempool according to ioctl struct */
+	if (tpm_ioctl_mpools.mpool_s == NULL &&
+	    mempool_alloc[TPM_MPOOL_TYPE_SMALL].enable == true) {
+		tpm_ioctl_mpools.mpool_s = tpm_common_mempool_create(mempool_alloc[TPM_MPOOL_TYPE_SMALL].entry_num,
+								     mempool_alloc[TPM_MPOOL_TYPE_SMALL].max_size,
+								     GFP_USER);
+		if (NULL == tpm_ioctl_mpools.mpool_s) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) failed allocating tpm_ioctl_mpools.mpool_s\n",
+				__func__, __LINE__);
+			return TPM_FAIL;
+		}
+
+		TPM_OS_INFO(TPM_IOCTL_MOD, "(%s:%d) init tpm_ioctl_mpools.mpool_s, number=%d, size=%d pool=0x%p\n",
+			__func__, __LINE__, mempool_alloc[TPM_MPOOL_TYPE_SMALL].entry_num,
+			    mempool_alloc[TPM_MPOOL_TYPE_SMALL].max_size, tpm_ioctl_mpools.mpool_s);
+	}
+
+	if (tpm_ioctl_mpools.mpool_m == NULL &&
+	    mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].enable == true) {
+		tpm_ioctl_mpools.mpool_m = tpm_common_mempool_create(mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].entry_num,
+								     mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].max_size,
+								     GFP_USER);
+		if (NULL == tpm_ioctl_mpools.mpool_m) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) failed allocating tpm_ioctl_mpools.mpool_m\n",
+				     __func__, __LINE__);
+			return TPM_FAIL;
+		}
+
+		TPM_OS_INFO(TPM_IOCTL_MOD, "(%s:%d) init tpm_ioctl_mpools.mpool_m, number=%d, size=%d pool=0x%p\n",
+			    __func__, __LINE__, mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].entry_num,
+			    mempool_alloc[TPM_MPOOL_TYPE_MEDIAM].max_size, tpm_ioctl_mpools.mpool_m);
+	}
+
+	if (tpm_ioctl_mpools.mpool_l == NULL &&
+	    mempool_alloc[TPM_MPOOL_TYPE_LARGE].enable == true) {
+		tpm_ioctl_mpools.mpool_l = tpm_common_mempool_create(mempool_alloc[TPM_MPOOL_TYPE_LARGE].entry_num,
+								     mempool_alloc[TPM_MPOOL_TYPE_LARGE].max_size,
+								     GFP_USER);
+		if (NULL == tpm_ioctl_mpools.mpool_l) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) failed allocating tpm_ioctl_mpools.mpool_l\n",
+				     __func__, __LINE__);
+			return TPM_FAIL;
+		}
+
+		TPM_OS_INFO(TPM_IOCTL_MOD, "(%s:%d) init tpm_ioctl_mpools.mpool_l, number=%d, size=%d pool=0x%p\n",
+			    __func__, __LINE__, mempool_alloc[TPM_MPOOL_TYPE_LARGE].entry_num,
+			    mempool_alloc[TPM_MPOOL_TYPE_LARGE].max_size, tpm_ioctl_mpools.mpool_l);
+	}
+
+	if (tpm_ioctl_mpools.mpool_h == NULL &&
+	    mempool_alloc[TPM_MPOOL_TYPE_HUGE].enable == true) {
+		tpm_ioctl_mpools.mpool_h = tpm_common_mempool_create(mempool_alloc[TPM_MPOOL_TYPE_HUGE].entry_num,
+								     mempool_alloc[TPM_MPOOL_TYPE_HUGE].max_size,
+								     GFP_USER);
+		if (NULL == tpm_ioctl_mpools.mpool_h) {
+			TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) failed allocating tpm_ioctl_mpools.mpool_h\n",
+				     __func__, __LINE__);
+			return TPM_FAIL;
+		}
+
+		TPM_OS_INFO(TPM_IOCTL_MOD, "(%s:%d) init tpm_ioctl_mpools.mpool_h, number=%d, size=%d pool=0x%p\n",
+			    __func__, __LINE__, mempool_alloc[TPM_MPOOL_TYPE_HUGE].entry_num,
+			    mempool_alloc[TPM_MPOOL_TYPE_HUGE].max_size, tpm_ioctl_mpools.mpool_h);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_ioctl_mempools_release
+*
+* DESCRIPTION: The function release mempool if allocated
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+static int tpm_ioctl_mempools_release(void)
+{
+	if (tpm_ioctl_mpools.mpool_s != NULL) {
+		tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_s);
+		tpm_ioctl_mpools.mpool_s = NULL;
+	}
+	if (tpm_ioctl_mpools.mpool_m != NULL) {
+		tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_m);
+		tpm_ioctl_mpools.mpool_m = NULL;
+	}
+	if (tpm_ioctl_mpools.mpool_l != NULL) {
+		tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_l);
+		tpm_ioctl_mpools.mpool_l = NULL;
+	}
+	if (tpm_ioctl_mpools.mpool_h != NULL) {
+		tpm_common_mempool_destroy(tpm_ioctl_mpools.mpool_h);
+		tpm_ioctl_mpools.mpool_h = NULL;
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_device_create
+*
+* DESCRIPTION: The function will create the char device and memory pools for TPM
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+int tpm_device_create(void)
+{
+	int ret;
+	dev_t dev = MKDEV(MV_TPM_MAJOR, 0);
+
+	ret = register_chrdev_region(dev, TPM_DEVICES_COUNT, TPM_DEV_NAME);
+	if (ret < 0) {
+		TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) TPM Char Device\n", __func__, __LINE__);
+		return TPM_FAIL;
+	}
+
+	/* initialize ioctl mempools */
+	if (tpm_ioctl_mempools_init() != TPM_OK)
+		return TPM_FAIL;
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+	/* initialize ioctl debug semaphore, used for signalling between user space and sysfs  */
+	sema_init(&tpm_sfs_2_ioctl_sem, 0);
+#endif
+
+	cdev_init(&tpm_dev.cdev, &tpm_cdev_fops);
+	tpm_dev.cdev.owner = THIS_MODULE;
+	tpm_dev.cdev.ops   = &tpm_cdev_fops;
+
+	ret = cdev_add(&tpm_dev.cdev, dev, 1);
+	if (ret < 0) {
+		TPM_OS_ERROR(TPM_IOCTL_MOD, "(%s:%d) TPM Char Device Add\n", __func__, __LINE__);
+		cdev_del(&tpm_dev.cdev);
+		unregister_chrdev_region(dev, TPM_DEVICES_COUNT);
+		return TPM_FAIL;
+	}
+
+	/* create device for udev */
+	tpm_udev_class = class_create(THIS_MODULE, TPM_DEV_NAME);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	tpm_udev_dev   = device_create(tpm_udev_class, NULL, dev, TPM_DEV_NAME);
+#else
+	tpm_udev_dev   = device_create(tpm_udev_class, NULL, dev, NULL, TPM_DEV_NAME);
+#endif
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_device_release
+*
+* DESCRIPTION: The function will release user interface of TPM device
+*
+* INPUTS:
+*	   None.
+*
+* OUTPUTS:
+*	   None.
+* RETURN:
+* On success, TPM_OK; Or TPM_FAIL
+*
+*******************************************************************************/
+int tpm_device_release(void)
+{
+	dev_t dev = MKDEV(MV_TPM_MAJOR, 0);
+
+	/* Release mempool for ioctl */
+	if (tpm_ioctl_mempools_release() != TPM_OK)
+		return TPM_FAIL;
+
+	device_destroy(tpm_udev_class, dev);
+	class_unregister(tpm_udev_class);
+	class_destroy(tpm_udev_class);
+
+	unregister_chrdev_region(dev, TPM_DEVICES_COUNT);
+
+	return TPM_OK;
+}
+
+
+static int __init mv_tpm_module_init(void)
+{
+	/* Creat user interface for TPM char devcie */
+	if (tpm_device_create()) {
+		printk(KERN_ERR "= TPM device interface create failed =\n");
+		return -1;
+	}
+
+	/* TPM init */
+	if (tpm_module_init()) {
+		printk(KERN_ERR "= TPM device init failed =\n");
+		return -1;
+	}
+	/*printk(KERN_INFO "= TPM Module Init ended successfully =\n");*/
+
+	return 0;
+}
+
+
+static void __exit mv_tpm_module_exit(void)
+{
+	/* Release TPM device and interface */
+	if (tpm_device_release()) {
+		printk(KERN_ERR "= TPM device interface release failed =\n");
+		return;
+	}
+	/*printk(KERN_INFO "= TPM Module Exit =\n");*/
+}
+
+module_init(mv_tpm_module_init);
+module_exit(mv_tpm_module_exit);
+
+MODULE_AUTHOR("TPMv2 Team");
+MODULE_DESCRIPTION("TPM Driver for Marvell Avanta-LP");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_init.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_init.c
new file mode 100644
index 0000000..4db3f29
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_init.c
@@ -0,0 +1,1588 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_init.c						     **
+**									     **
+**  DESCRIPTION : This file implements TPM init routine		     **
+**  DEPENDCY : TPM submodule init routine		     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************
+ * Type Definition
+ ******************************************************************************/
+
+static struct tpm_enum_str_t g_init_enum_switch_mode[] = {
+	{ TPM_SW_HEAD_NONE,		"TPM_SW_HEAD_NONE"},
+	{ TPM_SW_HEAD_MH,		"TPM_SW_HEAD_MH"},
+	{ TPM_SW_HEAD_MH_ETYPE_DSA,	"TPM_SW_HEAD_MH_ETYPE_DSA"},
+	{ TPM_SW_HEAD_DSA,		"TPM_SW_HEAD_DSA"},
+	{ TPM_SW_HEAD_EXT_DSA,		"TPM_SW_HEAD_EXT_DSA"},
+};
+
+static struct tpm_enum_str_t g_init_enum_switch_init[] = {
+	{ TPM_SW_MODE_NOT_INIT,	"TPM_SW_MODE_NOT_INIT"},
+	{ TPM_SW_MODE_INIT,	"TPM_SW_MODE_INIT"},
+};
+
+static struct tpm_enum_str_t g_init_enum_mc_def_action[] = {
+	{ TPM_MC_FLOW_DEFAULT_DROP,	"TPM_MC_FLOW_DEFAULT_DROP"},
+	{ TPM_MC_FLOW_DEFAULT_CPU,	"TPM_MC_FLOW_DEFAULT_CPU"},
+};
+
+static struct tpm_enum_str_t g_init_enum_mc_proto_handler[] = {
+	{ TPM_HANDLER_GEN_CLAS,		"TPM_HANDLER_GEN_CLAS"},
+	{ TPM_HANDLER_EXACT_MATCH,	"TPM_HANDLER_EXACT_MATCH"},
+	{ TPM_HANDLER_MC,		"TPM_HANDLER_MC"},
+};
+
+static struct tpm_enum_str_t g_init_enum_mc_switch_handler[] = {
+	{ TPM_MC_SW_CFG_FALSE,		"TPM_SW_HANDLER_NOT_MC_API"},
+	{ TPM_MC_SW_CFG_TRUE,		"TPM_SW_HANDLER_MC_API"},
+};
+
+static struct tpm_enum_str_t g_init_enum_ipv6_support[] = {
+	{ TPM_IPV6_NOT_SUPPORTED,	"TPM_IPV6_NOT_SUPPORTED"},
+	{ TPM_IPV6_SUPPORTED,		"TPM_IPV6_SUPPORTED"},
+};
+
+static struct tpm_enum_str_t g_init_enum_ttl_illegal_action[] = {
+	{ TPM_TTL_ZERO_ACTION_NOT_CARE,	"TPM_TTL_ZERO_ACTION_NOT_CARE"},
+	{ TPM_TTL_ZERO_ACTION_DROP,	"TPM_TTL_ZERO_ACTION_DROP"},
+	{ TPM_TTL_ZERO_ACTION_TO_CPU,	"TPM_TTL_ZERO_ACTION_TO_CPU"},
+};
+
+static struct tpm_enum_str_t g_init_enum_tcp_flag_check[] = {
+	{ TPM_TCP_FLAG_NOT_CHECK,	"TPM_TCP_FLAG_NOT_CHECK"},
+	{ TPM_TCP_FLAG_CHECK,		"TPM_TCP_FLAG_CHECK"},
+};
+
+static struct tpm_enum_str_t g_init_enum_qos_tbl_owner[] = {
+	{ TPM_QOS_TABLE_DISABLED,	"TPM_QOS_TABLE_DISABLED"},
+	{ TPM_QOS_TABLE_OWNER_TPM,	"TPM_QOS_TABLE_OWNER_TPM"},
+	{ TPM_QOS_TABLE_OWNER_USER,	"TPM_QOS_TABLE_OWNER_USER"},
+};
+
+static struct tpm_enum_str_t g_init_enum_capability_field[] = {
+	{ TPM_MATCH_ETH_DST,		"MATCH_ETH_DST"},
+	{ TPM_MATCH_ETH_SRC,		"MATCH_ETH_SRC"},
+	{ TPM_MATCH_VID_OUTER,		"MATCH_VID_OUTER"},
+	{ TPM_MATCH_PBITS_OUTER,	"MATCH_PBITS_OUTER"},
+	{ TPM_MATCH_VID_INNER,		"MATCH_VID_INNER"},
+	{ TPM_MATCH_PBITS_INNER,	"MATCH_PBITS_INNER"},
+	{ TPM_MATCH_ETH_TYPE,		"MATCH_ETH_TYPE"},
+	{ TPM_MATCH_PPPOE_PROTO,	"MATCH_PPPOE_PROTO"},
+	{ TPM_MATCH_PPPOE_SES,		"MATCH_PPPOE_SES"},
+	{ TPM_MATCH_IPV4_PKT,		"MATCH_IPV4_PKT"},
+	{ TPM_MATCH_IPV6_PKT,		"MATCH_IPV6_PKT"},
+	{ TPM_MATCH_IP_SRC,		"MATCH_IP_SRC"},
+	{ TPM_MATCH_IP_DST,		"MATCH_IP_DST"},
+	{ TPM_MATCH_IP_DSCP,		"MATCH_IP_DSCP"},
+	{ TPM_MATCH_IP_PROTO,		"MATCH_IP_PROTO"},
+	{ TPM_MATCH_IP_VERSION,		"MATCH_IP_VERSION"},
+	{ TPM_MATCH_IPV6_FLBL,		"MATCH_IPV6_FLBL"},
+	{ TPM_MATCH_IPV6_SUFF,		"TPM_MATCH_IPV6_SUFF"},
+	{ TPM_MATCH_IPV6_PREF,		"TPM_MATCH_IPV6_PREF"},
+	{ TPM_MATCH_L4_SRC,		"MATCH_L4_SRC"},
+	{ TPM_MATCH_L4_DST,		"MATCH_L4_DST"},
+	{ TPM_MATCH_ARP_TRGT_IP_ADDR,	"MATCH_ARP_TRGT_IP_ADDR"},
+#if 0
+	{ TPM_MATCH_IP_TUN_IP_SRC,	"MATCH_IP_TUN_IP_SRC"},
+	{ TPM_MATCH_IP_TUN_IP_DST,	"MATCH_IP_TUN_IP_DST"},
+	{ TPM_MATCH_IP_TUN_IP_PROTO,	"MATCH_IP_TUN_IP_PROTO"},
+#endif
+};
+
+static struct tpm_enum_str_t g_init_enum_tpm_state[] = {
+	{ TPM_MODULE_NOT_START,	"TPM Not Start"},
+	{ TPM_MODULE_STARTED,	"TPM Started"},
+};
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+/******************************************************************************
+* tpm_init_lookup_enum_str()
+*
+* DESCRIPTION:
+*	This routine lookups enum string according to enum value
+*
+* INPUTS:
+*	enum_array   - pointer to enum array
+*	enum_value   - the enum value to be matched
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Enum string
+*******************************************************************************/
+char *tpm_init_lookup_enum_str(enum tpm_init_enum_str_t enum_type, int enum_val)
+{
+	switch (enum_type) {
+	case TPM_INIT_ENUM_SWITCH_MODE:
+		return lookup_enum_str(g_init_enum_switch_mode, TPM_MEMBER_NUM(g_init_enum_switch_mode), enum_val);
+	case TPM_INIT_ENUM_SWITCH_INIT:
+		return lookup_enum_str(g_init_enum_switch_init, TPM_MEMBER_NUM(g_init_enum_switch_init), enum_val);
+	case TPM_INIT_ENUM_MC_DEF_ACTION:
+		return lookup_enum_str(g_init_enum_mc_def_action, TPM_MEMBER_NUM(g_init_enum_mc_def_action), enum_val);
+	case TPM_INIT_ENUM_MC_HANDLER:
+		return lookup_enum_str(g_init_enum_mc_proto_handler,
+				       TPM_MEMBER_NUM(g_init_enum_mc_proto_handler), enum_val);
+	case TPM_INIT_ENUM_SW_HANDLER:
+		return lookup_enum_str(g_init_enum_mc_switch_handler,
+				       TPM_MEMBER_NUM(g_init_enum_mc_switch_handler), enum_val);
+	case TPM_INIT_ENUM_IPV6_SUPPORT:
+		return lookup_enum_str(g_init_enum_ipv6_support, TPM_MEMBER_NUM(g_init_enum_ipv6_support), enum_val);
+	case TPM_INIT_ENUM_TTL_ILLEGAL_ACTION:
+		return lookup_enum_str(g_init_enum_ttl_illegal_action,
+				       TPM_MEMBER_NUM(g_init_enum_ttl_illegal_action), enum_val);
+	case TPM_INIT_ENUM_TCP_FLAG_CHECK:
+		return lookup_enum_str(g_init_enum_tcp_flag_check,
+				       TPM_MEMBER_NUM(g_init_enum_tcp_flag_check), enum_val);
+	case TPM_INIT_ENUM_QOS_TABLE_OWNER:
+		return lookup_enum_str(g_init_enum_qos_tbl_owner, TPM_MEMBER_NUM(g_init_enum_qos_tbl_owner), enum_val);
+	case TPM_INIT_ENUM_CAPABILITY_FIELD:
+		return lookup_enum_str(g_init_enum_capability_field,
+				       TPM_MEMBER_NUM(g_init_enum_capability_field), enum_val);
+	case TPM_INIT_ENUM_MODULE_STATE:
+		return lookup_enum_str(g_init_enum_tpm_state, TPM_MEMBER_NUM(g_init_enum_tpm_state), enum_val);
+	default:
+		return NULL;
+	}
+}
+
+/*******************************************************************************
+* tpm_init_switch_mode_set()
+*
+* DESCRIPTION: set switch mode, MH or DSA
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mode      - switch header mode
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_switch_mode_set(enum tpm_gmacs_enum_t gmac, enum tpm_sw_head_mode_t mode)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, gmac, TPM_ENUM_GMAC_1, "Invalid gmac value");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, mode, TPM_SW_HEAD_EXT_DSA, "Invalid switch head mode");
+
+	rc = tpm_db_init_switch_mode_set(gmac, mode);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set gmac(%d), switch mode(%d)\n", gmac, mode);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_gmac_def_mh_set()
+*
+* DESCRIPTION: set GMAC default TX MH
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mh        - Marvell head
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_gmac_def_mh_set(enum tpm_gmacs_enum_t gmac, unsigned short mh)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, gmac, TPM_ENUM_GMAC_1, "Invalid gmac value");
+
+	rc = tpm_db_init_gmac_def_mh_set(gmac, mh);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set gmac(%d), TX MH(0x%x)\n", gmac, mh);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_switch_init_set()
+*
+* DESCRIPTION: set the flag whether need to init switch
+*
+* INPUTS:
+*	gmac      - GMAC port number
+*	mh        - Marvell head
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_switch_init_set(enum tpm_sw_init_mode_t sw_init_mode)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, sw_init_mode, TPM_SW_MODE_INIT, "Invalid switch init mode");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_SWITCH_INIT, sw_init_mode);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set switch init mode(%d)\n", sw_init_mode);
+
+	return TPM_OK;
+}
+
+/******************************************************************************
+* tpm_init_field_num_get()
+*
+* DESCRIPTION:
+*	This routine gets the total field number by input bitmap
+*
+* INPUTS:
+*	bitmap   - field bitmap
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Total bitmap bit number
+*******************************************************************************/
+unsigned int tpm_init_field_num_get(unsigned int bitmap)
+{
+	unsigned int num = 0;
+	int idx;
+
+	for (idx = 0; idx < 32; idx++) {
+		if ((1 << idx) > TPM_MATCH_FIELD_ALL)
+			break;
+		if (((1 << idx) == TPM_MATCH_IPV4_PKT) ||
+		((1 << idx) == TPM_MATCH_IPV6_PKT))
+			continue;
+		if ((1 << idx) & bitmap)
+			num++;
+	}
+
+	return num;
+}
+
+/*******************************************************************************
+* tpm_init_capability_set()
+*
+* DESCRIPTION: set capability
+*
+* INPUTS:
+*	type      - Capability type
+*	cap       - Capabillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_capability_set(enum tpm_cap_type_t type, struct tpm_capability_t *cap)
+{
+	unsigned int cap_all;
+	struct tpm_init_cap_conf_t l_cap;
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, type, TPM_CAP_TYPE_MAX, "Invalid capability type");
+	IF_NULL(TPM_INIT_MOD, cap);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, cap->rule_type, TPM_NUM_MAX_RULE_TYPE_NUM, "Invalid rule_type");
+
+#if 0 /* to alow asis rule */
+	/* To verify capability */
+	if (0 == cap->field_match_bm) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal\n", cap->field_match_bm);
+		return TPM_BAD_PARAM;
+	}
+#endif
+	cap_all = TPM_MATCH_FIELD_ALL;
+	if (0 != (cap->field_match_bm & (~cap_all))) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) contains un-supported field(0x%x)\n",
+			     cap->field_match_bm, (cap->field_match_bm & (~cap_all)));
+		return TPM_BAD_PARAM;
+	}
+	if (tpm_init_field_num_get(cap->field_match_bm) > TPM_NUM_MAX_FILED_NUM) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal, could have up to %d fileds\n",
+			     cap->field_match_bm, TPM_NUM_MAX_FILED_NUM);
+		return TPM_BAD_PARAM;
+	}
+
+	if (cap->tag_num > TPM_ANY_VLAN) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "tag_num(%d) exceeds MAX value(%d)\n",
+			     cap->tag_num, TPM_ANY_VLAN);
+		return TPM_BAD_PARAM;
+	}
+
+	if (cap->precedence > (TPM_NUM_MAX_PRECEDENCE - 1)) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "precedence(%d) exceeds MAX value(%d)\n",
+			     cap->precedence, (TPM_NUM_MAX_PRECEDENCE - 1));
+		return TPM_BAD_PARAM;
+	}
+
+	if ((cap->max_port_hits < TPM_NUM_MIN_PORT_HITS) ||
+	    (cap->max_port_hits > TPM_NUM_MAX_PORT_HITS)) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "max_port_hits(%d) illegal, should range from %d to %d\n",
+			     cap->max_port_hits, TPM_NUM_MIN_PORT_HITS, TPM_NUM_MAX_PORT_HITS);
+		return TPM_BAD_PARAM;
+	}
+	if ((0 != cap->rule_type)
+	     && (TPM_CAP_TYPE_CLS != type)) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "rule_type should be 0 for non_CLS capabilities.\n");
+		return TPM_BAD_PARAM;
+	}
+
+	/* Save capability to db */
+	l_cap.rule_type      = cap->rule_type;
+	l_cap.field_match_bm = cap->field_match_bm;
+	l_cap.tag_num        = cap->tag_num;
+	l_cap.precedence     = cap->precedence;
+	l_cap.max_port_hits  = cap->max_port_hits;
+	l_cap.valid          = TPM_TRUE;
+	rc = tpm_db_init_capability_set(type, &l_cap);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to save capability\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_capability_del()
+*
+* DESCRIPTION: delete capability
+*
+* INPUTS:
+*	type      - Capability type
+*	cap       - Capbillity value
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_capability_del(enum tpm_cap_type_t type, struct tpm_capability_t *cap)
+{
+	unsigned int cap_all;
+	struct tpm_init_cap_conf_t l_cap;
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, type, TPM_CAP_TYPE_MAX, "Invalid capability type");
+
+	IF_NULL(TPM_INIT_MOD, cap);
+
+	/* To verify capability */
+	if (0 == cap->field_match_bm) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal\n", cap->field_match_bm);
+		return TPM_BAD_PARAM;
+	}
+	cap_all = TPM_MATCH_FIELD_ALL;
+	if (0 != (cap->field_match_bm & (~cap_all))) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) contains un-supported field(0x%x)\n",
+			     cap->field_match_bm, (cap->field_match_bm & (~cap_all)));
+		return TPM_BAD_PARAM;
+	}
+	if (int_bitmap_num_get(cap->field_match_bm) > TPM_NUM_MAX_FILED_NUM) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal, could have up to %d fileds\n",
+			     cap->field_match_bm, TPM_NUM_MAX_FILED_NUM);
+		return TPM_BAD_PARAM;
+	}
+
+	/* No need to verify precedence and max port hits in delete case */
+
+	/* Delete capability from db */
+	l_cap.rule_type      = cap->rule_type;
+	l_cap.field_match_bm = cap->field_match_bm;
+	l_cap.tag_num        = cap->tag_num;
+	l_cap.precedence     = cap->precedence;
+	l_cap.max_port_hits  = cap->max_port_hits;
+	l_cap.valid          = TPM_TRUE;
+	rc = tpm_db_init_capability_del(type, &l_cap);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to save capability\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_mc_data_handler_set()
+*
+* DESCRIPTION: set the handler mode for multicast data packet.
+*
+* INPUTS:
+*	data_handle  - multicast data handler
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_data_handler_set(enum tpm_traffic_handler_t data_handle)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, data_handle, TPM_HANDLER_MC, "Invalid mc traffic handler");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_MC_DATA_HANDLE, data_handle);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set mc data handler mode(%d)\n", data_handle);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_bad_chksum_action_set()
+*
+* DESCRIPTION: set the action of bad L3/4 checksum packet.
+*
+* INPUTS:
+*	action  -
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_bad_chksum_action_set(enum tpm_bad_chksum_action_t action)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, action, TPM_BAD_CHKSUM_DROP, "Invalid bad L3/4 checksum action");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_BAD_CHKSUM_ACTION, action);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set bad L3/4 checksum action(%d)\n", action);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_mc_flow_default_set()
+*
+* DESCRIPTION: set the default action for multicast data flow
+*
+* INPUTS:
+*       mc_layer     - MC flow layer
+*	mc_flow_def  - multicast data flow default action
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_flow_default_set(enum tpm_mc_traffic_layer_t mc_layer, enum tpm_mc_flow_def_action_t mc_flow_def)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, mc_layer, TPM_MC_TRAFFIC_L3, "Invalid mc flow layer");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, mc_flow_def, TPM_MC_FLOW_DEFAULT_CPU, "Invalid mc flow default act");
+
+	rc = tpm_db_init_mc_flow_def_set(mc_layer, mc_flow_def);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set mc flow default action(%d)\n", mc_flow_def);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_mc_proto_handler_set()
+*
+* DESCRIPTION: set the handler for multicast protocol packets
+*
+* INPUTS:
+*	mc_proto_handler - multicast protocol handler
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_proto_handler_set(struct tpm_port_mc_proto_handler_t *handler)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_INIT_MOD, handler);
+
+	if ((handler->port != TPM_PP_GMAC0) &&
+	    (handler->port != TPM_PP_GMAC1) &&
+	    (handler->port != TPM_PP_PMAC)) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid port(0x%x)\n", handler->port);
+		return TPM_BAD_PARAM;
+	}
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, handler->mc_proto_handler, TPM_HANDLER_MC, "Invalid mc proto handler");
+
+	rc = tpm_db_init_mc_proto_handler_set(handler);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set mc proto handler, PP port(0x%x), handler(%d)\n",
+		     handler->port, handler->mc_proto_handler);
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_init_mc_sw_handler_set()
+*
+* DESCRIPTION: set the handler of swicth ATU and VTU set, done by MC API or not.
+*
+* INPUTS:
+*	sw_handle  - MC swicth ATU&VTU handler
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mc_sw_handler_set(enum tpm_mc_switch_handler_t sw_handle)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, sw_handle, TPM_MC_SW_CFG_TRUE, "Invalid mc switch handler");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_MC_SW_HANDLE, sw_handle);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set mc switch handler mode(%d)\n", sw_handle);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_uni_port_num_set()
+*
+* DESCRIPTION: set the the number of UNI ports
+*
+* INPUTS:
+*	uni_port_num - Maximum UNI port number
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_uni_port_num_set(unsigned int uni_port_num)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, uni_port_num, TPM_NUM_MAX_UNI_PORTS, "Illegal MAX UNI port number");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_MAX_UNI_NUM, uni_port_num);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set MAX UNI port number(%d)\n", uni_port_num);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_ipv6_support_set()
+*
+* DESCRIPTION: set the flag that whether support IPv6
+*
+* INPUTS:
+*	ipv6_support -  IPv6 support flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_ipv6_support_set(enum tpm_ipv6_support_t ipv6_support)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, ipv6_support, TPM_IPV6_SUPPORTED, "Invalid ipv6_support value");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_IPV6_SUPPORT, ipv6_support);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set ipv6_support(%d)\n", ipv6_support);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_cpu_trap_queue_set()
+*
+* DESCRIPTION: set the CPU trap RX queue
+*
+* INPUTS:
+*	cpu_trap_queue - CPU trap RX queue
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_cpu_trap_queue_set(unsigned int cpu_trap_queue)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, cpu_trap_queue, TPM_NUM_MAX_QUEUE, "Invalid CPU trap queue");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_CPU_RX_QUEUE, cpu_trap_queue);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set CPU trap queue(%d)\n", cpu_trap_queue);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_ttl_illegal_action_set()
+*
+* DESCRIPTION: set the action for illegal TTL
+*
+* INPUTS:
+*	ttl_illegal_action - action for illegal TTL
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_ttl_illegal_action_set(enum tpm_ttl_illegal_action_t ttl_illegal_action)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, ttl_illegal_action, TPM_TTL_ZERO_ACTION_TO_CPU,
+				   "Invalid TTL illegal action");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_TTL_ILLEGAL_ACTION, ttl_illegal_action);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set TTL illegal action(%d)\n", ttl_illegal_action);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_mod_vlan_tpid_set()
+*
+* DESCRIPTION: set the Ethernet type(TPID) used by TPM VLAN modification
+*
+* INPUTS:
+*	mod_vlan_tpid - Ethernet type(TPID) used by TPM VLAN modification
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_mod_vlan_tpid_set(unsigned short mod_vlan_tpid)
+{
+	int rc = TPM_OK;
+
+	if (mod_vlan_tpid == TPM_INVALID_TPID) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid MOD VLAN TPID(0x%x)\n", mod_vlan_tpid);
+		return TPM_BAD_PARAM;
+	}
+
+	rc = tpm_db_init_mod_tpid_set(mod_vlan_tpid);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set MOD VLAN TPID(0x%x)\n", mod_vlan_tpid);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_tpid_combo_set()
+*
+* DESCRIPTION: set TPID combo up to dual VLAN tag
+*
+* INPUTS:
+*	tpid_combo  - TPID combo up to dual VLAN tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tpid_combo_set(struct tpm_tpid_combo_t *tpid_combo)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_INIT_MOD, tpid_combo);
+
+	if (TPM_INVALID_TPID == tpid_combo->tpid1) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid TPID combo, TPID1(0x%x), TPID2(0x%x)\n",
+			     tpid_combo->tpid1, tpid_combo->tpid2);
+		return TPM_BAD_PARAM;
+	}
+
+	rc = tpm_db_init_tpid_combo_set(tpid_combo);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set TPID combo, TPID1(0x%x), TPID2(0x%x)\n",
+		     tpid_combo->tpid1, tpid_combo->tpid2);
+
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_tpid_combo_del()
+*
+* DESCRIPTION: delete TPID combo up to dual VLAN tag
+*
+* INPUTS:
+*	tpid_combo  - TPID combo up to dual VLAN tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tpid_combo_del(struct tpm_tpid_combo_t *tpid_combo)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_INIT_MOD, tpid_combo);
+
+	if (TPM_INVALID_TPID == tpid_combo->tpid1) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid TPID combo, TPID1(0x%x), TPID2(0x%x)\n",
+			     tpid_combo->tpid1, tpid_combo->tpid2);
+		return TPM_BAD_PARAM;
+	}
+
+	rc = tpm_db_init_tpid_combo_del(tpid_combo);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to delete TPID combo, TPID1(0x%x), TPID2(0x%x)\n",
+		     tpid_combo->tpid1, tpid_combo->tpid2);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_tcp_flag_check_set()
+*
+* DESCRIPTION: set the flag that whether check TCP flag
+*
+* INPUTS:
+*	tcp_flag_check - whether check TCP flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_tcp_flag_check_set(enum tpm_tcp_flag_check_t tcp_flag_check)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, tcp_flag_check, TPM_TCP_FLAG_CHECK, "Invalid TCP flag check mode");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_TCP_FLAG_CHECK, tcp_flag_check);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to TCP flag check mode(%d)\n", tcp_flag_check);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_trace_debug_flag_set()
+*
+* DESCRIPTION: set the trace and debug flag
+*
+* INPUTS:
+*	trace_debug_flag - Flag to control TPM trace and debug level
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_trace_debug_flag_set(unsigned int trace_debug_flag)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_TRACE_DEBUG_FLAG, trace_debug_flag);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to trace and debug flag(%d)\n", trace_debug_flag);
+
+	/* Set trace and debug level */
+	if (TPM_MODULE_STARTED == tpm_db_module_state_get()) {
+		rc = tpm_log_trace_level_set(trace_debug_flag);
+		IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set TPM trace and debuf level\n");
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_qos_tbl_ext_set()
+*
+* DESCRIPTION: set the QoS table extention mode
+*
+* INPUTS:
+*	qos_tbl_ext  - QoS table extention mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_qos_tbl_ext_set(enum tpm_qos_tbl_owner_t qos_tbl_ext)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, qos_tbl_ext, TPM_QOS_TABLE_OWNER_USER, "Invalid QoS tbl exten mode");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_QOS_TABLE_EXT, qos_tbl_ext);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set QoS table extention mode(%d)\n", qos_tbl_ext);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_cnm_support_set()
+*
+* DESCRIPTION: set the flag that whether support CTC CnM
+*
+* INPUTS:
+*	cnm_support -  CTC CnM support flag
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_cnm_support_set(enum tpm_init_cnm_mode_t cnm_support)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, cnm_support, TPM_CNM_SUPPORTED, "Invalid cnm_support value");
+
+	rc = tpm_db_generic_param_set(TPM_DB_PARAM_CNM_SUPPORT, cnm_support);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set cnm_support(%d)\n", cnm_support);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_module_state_set()
+*
+* DESCRIPTION: The API sets TPM module init state, either not started, or started
+*
+* INPUTS:
+*	state  - TPM module init state
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_init_module_state_set(enum tpm_module_state_t state)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, state, TPM_MODULE_STARTED, "Invalid TPM module state");
+
+	rc = tpm_db_module_state_set(state);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "failed to set TPM module state(%d)\n", state);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_filter_type_set()
+*
+* DESCRIPTION: set a filter section
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	priority		-  priority value of this filter within its rule type
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_init_filter_type_set(
+	unsigned char			rule_type,
+	unsigned char			priority,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, rule_type, TPM_NUM_MAX_RULE_TYPE_NUM, "Invalid rule_type value\n");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD, vlan_num, TPM_ANY_VLAN, "Invalid vlan_num value\n");
+
+	rc = tpm_db_init_filter_type_set(rule_type, priority, field_bm, vlan_num);
+	IF_ERROR_STR(TPM_INIT_MOD, rc,
+		"failed to set filter type: rule_type(%d), priority(%d), field_bm(0x%x), vlan_num(%d)\n",
+		rule_type, priority, field_bm, vlan_num);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_cfg_validate()
+*
+* DESCRIPTION: Perform TPM init configuration validation.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+int tpm_init_cfg_validate(void)
+{
+	struct tpm_init_t *init_cfg = NULL;
+	struct tpm_init_cap_conf_t *cap = NULL;
+	unsigned int cap_all = 0;
+	int index;
+
+	init_cfg = tpm_db_init_db_get(TPM_INIT_PARAM_PRE_START);
+	IF_NULL(TPM_INIT_MOD, init_cfg);
+
+	/* GMAC switch mode */
+	for (index = 0; index < TPM_NUM_ETH_GMACS; index++) {
+		if (init_cfg->gmac_switch_mode[index] > TPM_SW_HEAD_EXT_DSA) {
+			TPM_OS_ERROR(TPM_INIT_MOD, "Invalid GMAC switch header mode(%d) for GMAC(%d)\n",
+				     init_cfg->gmac_switch_mode[index], index);
+			return TPM_BAD_VALUE;
+		}
+	}
+
+	/* GMAC default TX MH */
+
+	/* Switch init mode */
+	if (init_cfg->switch_init > TPM_SW_MODE_INIT) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid switch init mode(%d)\n", init_cfg->switch_init);
+		return TPM_BAD_VALUE;
+	}
+
+	/* Capability */
+	cap_all = TPM_MATCH_FIELD_ALL;
+	for (index = 0; index < TPM_NUM_MAX_CAPABILITIES; index++) {
+		if (init_cfg->exact_match_except_cap[index].field_match_bm != 0) {
+			cap = &init_cfg->exact_match_except_cap[index];
+			/* To verify capability */
+#if 0 /* to alow asis rule */
+			if (0 == cap->field_match_bm) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal\n", cap->field_match_bm);
+				return TPM_BAD_PARAM;
+			}
+#endif
+			cap_all = TPM_MATCH_FIELD_ALL;
+			if (0 != (cap->field_match_bm & (~cap_all))) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) contains un-supported field(0x%x)\n",
+					     cap->field_match_bm, (cap->field_match_bm & (~cap_all)));
+				return TPM_BAD_PARAM;
+			}
+			if (tpm_init_field_num_get(cap->field_match_bm) > TPM_NUM_MAX_FILED_NUM) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal, could have %d fileds\n",
+					     cap->field_match_bm, TPM_NUM_MAX_FILED_NUM);
+				return TPM_BAD_PARAM;
+			}
+
+			if (cap->precedence > (TPM_NUM_MAX_PRECEDENCE - 1)) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "precedence(%d) exceeds MAX value(%d)\n",
+					     cap->precedence, (TPM_NUM_MAX_PRECEDENCE - 1));
+				return TPM_BAD_PARAM;
+			}
+
+			if ((cap->max_port_hits < TPM_NUM_MIN_PORT_HITS) ||
+			    (cap->max_port_hits > TPM_NUM_MAX_PORT_HITS)) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "max_port_hits(%d) illegal, should range from %d to %d\n",
+					     cap->max_port_hits, TPM_NUM_MIN_PORT_HITS, TPM_NUM_MAX_PORT_HITS);
+				return TPM_BAD_PARAM;
+			}
+		}
+
+		if (init_cfg->generic_class_cap[index].field_match_bm != 0) {
+			cap = &init_cfg->generic_class_cap[index];
+			/* To verify capability */
+#if 0 /* to alow asis rule */
+			if (0 == cap->field_match_bm) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal\n", cap->field_match_bm);
+				return TPM_BAD_PARAM;
+			}
+#endif
+			cap_all = TPM_MATCH_FIELD_ALL;
+			if (0 != (cap->field_match_bm & (~cap_all))) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) contains un-supported field(0x%x)\n",
+					     cap->field_match_bm, (cap->field_match_bm & (~cap_all)));
+				return TPM_BAD_PARAM;
+			}
+			if (tpm_init_field_num_get(cap->field_match_bm) > TPM_NUM_MAX_FILED_NUM) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "field_match_bm(0x%x) is illegal, could have %d fileds\n",
+					     cap->field_match_bm, TPM_NUM_MAX_FILED_NUM);
+				return TPM_BAD_PARAM;
+			}
+
+			if (cap->precedence > (TPM_NUM_MAX_PRECEDENCE - 1)) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "precedence(%d) exceeds MAX value(%d)\n",
+					     cap->precedence, (TPM_NUM_MAX_PRECEDENCE - 1));
+				return TPM_BAD_PARAM;
+			}
+
+			if ((cap->max_port_hits < TPM_NUM_MIN_PORT_HITS) ||
+			    (cap->max_port_hits > TPM_NUM_MAX_PORT_HITS)) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "max_port_hits(%d) illegal, should range from %d to %d\n",
+					     cap->max_port_hits, TPM_NUM_MIN_PORT_HITS, TPM_NUM_MAX_PORT_HITS);
+				return TPM_BAD_PARAM;
+			}
+		}
+	}
+
+	/* Multicast data flow default action check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD,
+				   init_cfg->mc_flow_def[TPM_MC_TRAFFIC_L2],
+				   TPM_MC_FLOW_DEFAULT_CPU,
+				   "Invalid multicast data flow L2 default action\n");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_INIT_MOD,
+				   init_cfg->mc_flow_def[TPM_MC_TRAFFIC_L3],
+				   TPM_MC_FLOW_DEFAULT_CPU,
+				   "Invalid multicast data flow L3 default action\n");
+
+	/* Multicast protocol handler */
+	for (index = 0; index < TPM_NUM_MAX_GMAC_PORTS; index++) {
+		if ((init_cfg->mc_proto_handler[index].port == TPM_PP_GMAC0 ||
+		     init_cfg->mc_proto_handler[index].port == TPM_PP_GMAC1 ||
+		     init_cfg->mc_proto_handler[index].port == TPM_PP_PMAC) &&
+		    (init_cfg->mc_proto_handler[index].mc_proto_handler > TPM_HANDLER_MC)) {
+			TPM_OS_ERROR(TPM_INIT_MOD, "Invalid multicast protocol handler(%d) for GMAC(0x%x)\n",
+				     init_cfg->mc_proto_handler[index].mc_proto_handler,
+				     init_cfg->mc_proto_handler[index].port);
+			return TPM_BAD_VALUE;
+		}
+	}
+
+	/* Maximum UNI port number */
+	if (init_cfg->max_num_uni_ports > TPM_NUM_MAX_UNI_PORTS) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid max UNI port number(%d), could not exceed(%d)\n",
+			     init_cfg->max_num_uni_ports, TPM_NUM_MAX_UNI_PORTS);
+		return TPM_BAD_VALUE;
+	}
+
+	/* IPv6 Support */
+	if (init_cfg->ipv6_support > TPM_IPV6_SUPPORTED) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid IPv6 support state(%d)\n",
+			     init_cfg->ipv6_support);
+		return TPM_BAD_VALUE;
+	}
+
+	/* CPU default trap RX queue */
+	if (init_cfg->cpu_trap_rx_queue >= TPM_NUM_MAX_QUEUE) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid CPU default trap RX queue(%d)\n",
+			     init_cfg->cpu_trap_rx_queue);
+		return TPM_BAD_VALUE;
+	}
+
+	/* TTL illegal action */
+	if (init_cfg->ttl_illegal_action > TPM_TTL_ZERO_ACTION_TO_CPU) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid TTL illegal action(%d)\n",
+			     init_cfg->ttl_illegal_action);
+		return TPM_BAD_VALUE;
+	}
+
+	/* TCP flag check mode */
+	if (init_cfg->tcp_flag_check > TPM_TCP_FLAG_CHECK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid TCP flag check mode(%d)\n",
+			     init_cfg->tcp_flag_check);
+		return TPM_BAD_VALUE;
+	}
+
+	/* TPID for VLAN modification */
+
+	/* TPID combo */
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++) {
+		if (init_cfg->tpid_combo[index].valid == true) {
+			if (TPM_INVALID_TPID == init_cfg->tpid_combo[index].tpid1) {
+				TPM_OS_ERROR(TPM_INIT_MOD, "Invalid TPID combo, TPID1(0x%x), TPID2(0x%x)\n",
+					     init_cfg->tpid_combo->tpid1, init_cfg->tpid_combo->tpid2);
+				return TPM_BAD_PARAM;
+			}
+		}
+	}
+
+	/* QoS table owner */
+	if (init_cfg->qos_tbl_ext > TPM_QOS_TABLE_OWNER_USER) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid QoS table owner(%d)\n",
+			     init_cfg->qos_tbl_ext);
+		return TPM_BAD_VALUE;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_cfg_set()
+*
+* DESCRIPTION: Set init configuration to runing database.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+int tpm_init_cfg_set(void)
+{
+	int rc;
+	int index;
+	struct tpm_init_t *init_cfg = NULL;
+	struct tpm_init_t *init_db = NULL;
+	struct tpm_init_cap_conf_t filter_cap;
+
+	init_cfg = tpm_db_init_db_get(TPM_INIT_PARAM_PRE_START);
+	IF_NULL(TPM_INIT_MOD, init_cfg);
+
+	init_db = tpm_db_init_db_get(TPM_INIT_PARAM_POST_START);
+	IF_NULL(TPM_INIT_MOD, init_db);
+
+	memcpy(init_db, init_cfg, sizeof(struct tpm_init_t));
+
+	/* Set trace and debug level */
+	rc = tpm_log_trace_level_set(init_db->trace_debug_flag);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set TPM trace and debuf level\n");
+
+	/* Save capability */
+	for (index = 0; index < TPM_NUM_MAX_CAPABILITIES; index++) {
+		if (init_db->exact_match_except_cap[index].valid == TPM_TRUE) {
+			rc = tpm_db_mng_pub_cap_set(TPM_API_PUBLIC_EXCT_EXCPT, &init_db->exact_match_except_cap[index]);
+			IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set exact match capability\n");
+		} else {
+			continue;
+		}
+	}
+	for (index = 0; index < TPM_NUM_MAX_CAPABILITIES; index++) {
+		if (init_db->generic_class_cap[index].valid == TPM_TRUE) {
+			rc = tpm_db_mng_pub_cap_set(TPM_API_PUBLIC_CLS, &init_db->generic_class_cap[index]);
+			IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set general classification capability\n");
+		} else {
+			continue;
+		}
+	}
+
+	/* add filter caps */
+	for (index = 0; index < TPM_NUM_MAX_FILTER_TYPE; index++) {
+		if (init_db->filter_cap[index].valid == TPM_TRUE) {
+
+			/* build cap */
+			filter_cap.field_match_bm = init_db->filter_cap[index].field_match_bm;
+			filter_cap.rule_type = init_db->filter_cap[index].rule_type;
+			filter_cap.tag_num = init_db->filter_cap[index].tag_num;
+			filter_cap.precedence = init_db->filter_cap[index].precedence;
+			filter_cap.max_port_hits = TPM_NUM_MIN_PORT_HITS;
+
+			rc = tpm_db_mng_pub_cap_set(TPM_API_PUBLIC_FLTR, &filter_cap);
+			IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set general classification capability\n");
+		} else {
+			continue;
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_init_db_init()
+*
+* DESCRIPTION: Perform DB Initialization for init module.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+int tpm_init_db_init(void)
+{
+	struct tpm_init_t *tpm_init = NULL;
+	int index;
+
+	tpm_init = tpm_db_init_db_get(TPM_INIT_PARAM_PRE_START);
+
+	/* Set GMAC switch mode default value: MH */
+	tpm_init->gmac_switch_mode[0] = TPM_SW_HEAD_MH;
+	tpm_init->gmac_switch_mode[1] = TPM_SW_HEAD_MH;
+
+	/* Set GMAC TX MH default value: 0x0F */
+	tpm_init->gmac_def_tx_mh[0] = 0x0F;
+	tpm_init->gmac_def_tx_mh[1] = 0x0F;
+
+	/* Set switch init default value: enbaled */
+	tpm_init->switch_init = TPM_SW_MODE_INIT;
+
+	/* Set default multicast flow default action  */
+	tpm_init->mc_flow_def[TPM_MC_TRAFFIC_L2] = TPM_MC_FLOW_DEFAULT_DROP;
+	tpm_init->mc_flow_def[TPM_MC_TRAFFIC_L3] = TPM_MC_FLOW_DEFAULT_CPU;
+
+	/* Set default multicast protocol handler */
+	tpm_init->mc_proto_handler[0].port = TPM_PP_GMAC0;
+	tpm_init->mc_proto_handler[0].mc_proto_handler = TPM_HANDLER_MC;
+	tpm_init->mc_proto_handler[1].port = TPM_PP_GMAC1;
+	tpm_init->mc_proto_handler[1].mc_proto_handler = TPM_HANDLER_MC;
+	tpm_init->mc_proto_handler[2].port = TPM_PP_PMAC;
+	tpm_init->mc_proto_handler[2].mc_proto_handler = TPM_HANDLER_MC;
+
+	/* Set default UNI port number */
+	tpm_init->max_num_uni_ports = TPM_NUM_DEFAULT_UNI_PORTS;
+
+	/* Set default IPv6 support */
+	tpm_init->ipv6_support = TPM_IPV6_NOT_SUPPORTED;
+
+	/* Set default CPU trap RX queue */
+	tpm_init->cpu_trap_rx_queue = TPM_NUM_DEFAULT_CPU_QUEUE;
+
+	/* Set default TTL illegal action */
+	tpm_init->ttl_illegal_action = TPM_TTL_ZERO_ACTION_DROP;
+
+	/* Set default bad chksum action */
+	tpm_init->bad_chksum_action = TPM_BAD_CHKSUM_NO_DROP;
+
+	/* Set default TCP flag check mode */
+	tpm_init->tcp_flag_check = TPM_TCP_FLAG_NOT_CHECK;
+
+	/* Clear all of the MOD TPID*/
+	for (index = 0; index < TPM_NUM_VLAN_ETYPE_REGS; index++)
+		tpm_init->mod_vlan_tpid[index] = TPM_INVALID_TPID;
+
+	/* Disable all of the TPID combo by default */
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++)
+		tpm_init->tpid_combo[index].valid = false;
+
+	/* Clear filter cap db by default */
+	for (index = 0; index < TPM_NUM_MAX_FILTER_TYPE; index++)
+		tpm_init->filter_cap[index].valid = TPM_FALSE;
+
+	/* Set default trace and debug level, currently open all module */
+	tpm_init->trace_debug_flag = TPM_WARN_TRACE_LEVEL | TPM_ALL_MOD;
+
+	/* Set default QoS table usage */
+	tpm_init->qos_tbl_ext = TPM_QOS_TABLE_OWNER_TPM;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_module_init()
+*
+* DESCRIPTION: Initialize the TPM module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* Comments:
+*	This function will be called once TPM kernel module is loaded
+*
+*******************************************************************************/
+int tpm_module_init(void)
+{
+	int rc;
+
+	/* Reset DB */
+	rc = tpm_db_init();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Error in Init DB\n");
+
+	/* Init Sysfs */
+	rc = tpm_sysfs_init();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Error in Initialization of TPM Sysfs\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_module_start()
+*
+* DESCRIPTION: Starts the TPM module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* Comments:
+*	This function will be triggered by other applications
+*
+*******************************************************************************/
+int tpm_module_start(void)
+{
+	int rc;
+
+	/* Check TPM module state at first */
+	if (TPM_MODULE_STARTED == tpm_db_module_state_get()) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "TPM module already starts, could not start again\n");
+		return TPM_INIT_ERROR;
+	}
+
+	/* Set TPM module state to forbiden setting of TPM init param */
+	rc = tpm_init_module_state_set(TPM_MODULE_STARTED);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set TPM module state\n");
+
+	/* Validate TPM init configuration */
+	rc = tpm_init_cfg_validate();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to validate TPM init configuration\n");
+		goto err;
+	}
+
+	/* Set init configuration to running DB */
+	rc = tpm_init_cfg_set();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to set init configuration to running DB\n");
+		goto err;
+	}
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	/* Start TPM switch module */
+	rc = tpm_sw_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start switch module\n");
+		goto err;
+	}
+#endif
+	/* Set and start TPM parser module */
+	rc = tpm_prs_init();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start parser module\n");
+		goto err;
+	}
+
+	/* CLS Init */
+	rc = tpm_cls_init();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start CLS module\n");
+		goto err;
+	}
+
+	/* C2 Init */
+	rc = tpm_c2_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start C2 module\n");
+		goto err;
+	}
+
+	/* C2 QoS table Init */
+	rc = tpm_qos_tbl_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start QoS table module\n");
+		goto err;
+	}
+
+	/* C3 Init */
+	rc = tpm_c3_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start C3 module\n");
+		goto err;
+	}
+
+	/* C4 Init */
+	rc = tpm_c4_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start C4 module\n");
+		goto err;
+	}
+
+	/* MNG Init */
+	rc = tpm_mng_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start TPM management module\n");
+		goto err;
+	}
+
+	/* PME init */
+	rc = tpm_pme_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start TPM PME module\n");
+		goto err;
+	}
+
+	/* PLCR init */
+	rc = tpm_plcr_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start TPM policer module\n");
+		goto err;
+	}
+
+	/* MCT Init */
+	rc = tpm_mc_start();
+	if (rc != TPM_OK) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Failed to start MCT module\n");
+		goto err;
+	}
+
+	/* Always prints the indication */
+	printk(KERN_INFO "TPM module starts successfully\n");
+
+	return TPM_OK;
+err:
+	/* Rollback TPM module state */
+	rc = tpm_init_module_state_set(TPM_MODULE_NOT_START);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Failed to set TPM module state\n");
+
+	TPM_OS_ERROR(TPM_INIT_MOD, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
+	TPM_OS_ERROR(TPM_INIT_MOD, "              Failed to start TPM module\n");
+	TPM_OS_ERROR(TPM_INIT_MOD, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");
+
+	return TPM_INIT_ERROR;
+}
+
+/*******************************************************************************
+* tpm_module_mib_reset()
+*
+* DESCRIPTION: handle TPM module MIB reset on fly
+*
+* INPUTS:
+*	reset_level  - reset level, determine which parts are reset in TPM
+*			0: high level, reset all TPM configuration and reset TPM to none started state
+*			1: medium level, reset all TPM configuration including parser config
+*			2: low level, reset TPM configuration except parser config
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_module_mib_reset(enum tpm_reset_level_enum_t reset_level)
+{
+	int rc;
+
+	if (reset_level > TPM_ENUM_MAX_RESET_LEVEL) {
+		TPM_OS_ERROR(TPM_INIT_MOD, "Invalid reset_level(%d)\n", reset_level);
+		return TPM_BAD_PARAM;
+	}
+
+	/* High level specific reset */
+	if (TPM_ENUM_RESET_LEVEL_HIGH == reset_level) {
+
+		/* Set TPM module state to none started */
+		rc = tpm_init_module_state_set(TPM_MODULE_NOT_START);
+		IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM parser reset failed\n");
+	}
+
+	/* High and medium level specific reset */
+	if ((TPM_ENUM_RESET_LEVEL_HIGH == reset_level) ||
+	    (TPM_ENUM_RESET_LEVEL_MEDIUM == reset_level)) {
+
+		/* Reset parser */
+		rc = tpm_prs_reset();
+		IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM parser reset failed\n");
+	}
+
+	/* Init CLS sub-module */
+	rc = tpm_cls_init();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM CLS module init failed\n");
+
+	/* Reset C2 sub-module */
+	rc = tpm_c2_reset();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM C2 module reset failed\n");
+
+	/* Reset C3 sub-module */
+	rc = tpm_c3_reset();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM C3 module reset failed\n");
+
+	/* Reset Manager sub-module */
+	rc = tpm_mng_reset();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM MNG module reset failed\n");
+
+	/* Reset PME sub-module */
+	rc = tpm_pme_reset();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM PME module reset failed\n");
+
+	/* Reset Policer sub-module */
+	rc = tpm_plcr_reset();
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "TPM PLCR module reset failed\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_log.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_log.c
new file mode 100644
index 0000000..8cc398f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_log.c
@@ -0,0 +1,85 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_log.c						     **
+**									     **
+**  DESCRIPTION : This file contains routines for trace log of tpm           **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* Global variables */
+unsigned int g_tpm_trace_flag = TPM_WARN_TRACE_LEVEL | TPM_ALL_MOD;
+
+/*******************************************************************************
+* tpm_log_trace_level_set
+*
+* DESCRIPTION: The routine sets TPM trace and debug level
+*
+* INPUTS:
+*	trace_level - TPM trace level
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_log_trace_level_set(unsigned int trace_level)
+{
+	g_tpm_trace_flag = trace_level;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_log_trace_level_get
+*
+* DESCRIPTION: The routine gets TPM trace and debug level
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	TPM trace level
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+unsigned int tpm_log_trace_level_get(void)
+{
+	return g_tpm_trace_flag;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
new file mode 100644
index 0000000..740d4b1
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_mng.c
@@ -0,0 +1,8220 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* API lock, so far only support one lock total */
+static spinlock_t tpm_api_call_lock;
+
+/* to save stack size, make big structures global params */
+static struct tpm_db_mng_cap_conf_t g_cap_arr[TPM_DB_MNG_CAP_MAX];
+static struct tpm_db_mng_flow_cap_conf_t g_flow_cap_arr[TPM_MNG_FLOW_PER_CAP_MAX];
+
+/* Indicates "tpm_mng_flow_cfg_init" is updated or not, only need once at most */
+static int g_flow_cfg_update_flag;
+static struct tpm_db_mng_flow_conf_t tpm_mng_flow_cfg_init[TPM_MNG_FLOW_ID_MAX] = {
+
+	/* IPV4_UC_RTR */
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_UC_RTR_NF_NPPOE_UNTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_NPPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_NPPOE_DTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_UNTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID               , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_UC_RTR_NF_NPPOE_UNTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_NPPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_NPPOE_DTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_UNTAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_NF_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_UC_RTR_FRAG_NPPOE_UNTAG_ID    , 0},
+		{IPV4_UC_RTR_FRAG_NPPOE_STAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_NPPOE_DTAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_UNTAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_UC_RTR_FRAG_NPPOE_UNTAG_ID    , 0},
+		{IPV4_UC_RTR_FRAG_NPPOE_STAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_NPPOE_DTAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_UNTAG_ID     , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_STAG_ID	    , 0},
+		{IPV4_UC_RTR_FRAG_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* IPV6_UC_RTR */
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_UC_RTR_NOEX_NPPOE_UNTAG_ID    , 0},
+		{IPV6_UC_RTR_NOEX_NPPOE_STAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_UNTAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_STAG_ID	    , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_UC_RTR_NOEX_NPPOE_UNTAG_ID    , 0},
+		{IPV6_UC_RTR_NOEX_NPPOE_STAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_UNTAG_ID     , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_STAG_ID	    , 0},
+		{IPV6_UC_RTR_NOEX_PPOE_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG_ID , 0},
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_STAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_STAG_ID   , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_DTAG_ID   , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG_ID , 0},
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_STAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG_ID  , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_STAG_ID   , 0},
+		{IPV6_UC_RTR_SPEC_EX_PPOE_DTAG_ID   , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* NON_IP_MTM */
+	{TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{NON_IP_MTM_UNTAG_ID		    , 0},
+		{NON_IP_MTM_STAG_ID		    , 0},
+		{NON_IP_MTM_DTAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{NON_IP_MTM_UNTAG_ID		    , 0},
+		{NON_IP_MTM_STAG_ID		    , 0},
+		{NON_IP_MTM_DTAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* Multicast */
+	{TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_MC_RTR_UNTAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_MC_RTR_TAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_MC_RTR_UNTAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_MC_RTR_TAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	{TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_MC_RTR_UNTAG_ID		    , 0},
+		{IPV4_MC_RTR_TAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_MC_RTR_UNTAG_ID		    , 0},
+		{IPV6_MC_RTR_TAG_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* IPV4_UC_BRG */
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_UNTAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_UNTAG_ID	  , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_STAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_STAG_ID	    , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_DTAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_DTAG_ID     , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_UNTAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_UNTAG_ID	  , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_STAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_STAG_ID	  , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV4_UC_BRG_NF_DTAG_ID	    , 0},
+		{IPV4_UC_BRG_FRAG_DTAG_ID	  , TPM_MNG_IPV4_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* IPV6_UC_BRG */
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_UNTAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_UNTAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_STAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_STAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_PON, TPM_WAY_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_DTAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_DTAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_UNTAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_UNTAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_STAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_STAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{IPV6_UC_BRG_NF_DTAG_ID	    , 0},
+		{IPV6_UC_BRG_FRAG_DTAG_ID	  , TPM_MNG_IPV6_UC_BRG_FRAG_PRI_START},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+	/* NOT_IP_BRG */
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{NON_IP_BRG_UNTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID       , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{NON_IP_BRG_STAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{NON_IP_BRG_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON, TPM_WAY_PON, 0,
+		{
+		{NON_IP_BRG_UNTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_PON, TPM_WAY_PON, 0,
+		{
+		{NON_IP_BRG_STAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_PON, TPM_WAY_PON, 0,
+		{
+		{NON_IP_BRG_DTAG_ID	    , 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_ARP_PON, TPM_WAY_PON, 0,
+		{
+		{NON_IP_ARP_ID			, 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{NON_IP_ARP_ID			, 0},
+		{TPM_MNG_ILLEGAL_LUID	    , 0},
+		}
+	},
+
+
+	/* UNEXPECTED */
+	{TPM_MNG_FLOW_ID_UNEXPECTED_PKT_PON, TPM_WAY_PON, 0,
+		{
+		{LSP_GMAC0_DEFAULT_ID		    , 0},
+		{LSP_LPK_GMAC_DEFAULT_ID	    , 0},
+		{LSP_PON_DEFAULT_ID		    , 0},
+		{UNEXPECTED_PKT_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_UNEXPECTED_PKT_NPON, TPM_WAY_NON_PON, 0,
+		{
+		{LSP_GMAC0_DEFAULT_ID		    , 0},
+		{LSP_LPK_GMAC_DEFAULT_ID	    , 0},
+		{LSP_PON_DEFAULT_ID		    , 0},
+		{UNEXPECTED_PKT_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID	            , 0},
+		}
+	},
+	{TPM_MNG_FLOW_ID_LOOPBACK_PORT, TPM_WAY_NON_PON, 0,
+		{
+		{LOOPBACK_PKT_ID		    , 0},
+		{TPM_MNG_ILLEGAL_LUID		    , 0},
+		}
+	},
+
+};
+
+/* config of private caps */
+/* so far, CPU queue is a default cap for every flow_id, it is init hardcoded */
+static struct tpm_db_mng_flow_cap_conf_t tpm_mng_pri_cap_cfg[] = {
+
+	/* FIELD_BM, CAP_TYPE, FLOW_ID,
+	     CLS_PRI, ENG_NO, LU_TYPE, C2_PRI, C2_KEY_BM */
+
+	/* IPV4_UC_RTR, TTL */
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_PON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_NPON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	/* IPV6_UC_RTR, TTL */
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_PON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	{TPM_MATCH_TTL, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_NPON,
+	 TPM_MNG_CLS_PRI_TTL, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TTL, 0, 0},
+
+	/* IPV4_UC_RTR, TCP_FLAG_RF */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_RF, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_RF, 0, 0},
+
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_RF, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_RF, 0, 0},
+
+	/* IPV6_UC_RTR, TCP_FLAG_RF */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_RF, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_RF, 0, 0},
+
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_RF, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_RF, 0, 0},
+
+	/* IPV4_UC_RTR, 5T */
+	{TPM_MATCH_IPV4_5T, TPM_API_PRIVATE_EXCT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 TPM_MNG_CLS_PRI_IPVX, TPM_ENGINE_C3_B, TPM_MNG_PRI_LU_TYPE_C3_IPV4_5T, 0, 0},
+
+	{TPM_MATCH_IPV4_5T, TPM_API_PRIVATE_EXCT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,
+	 TPM_MNG_CLS_PRI_IPVX, TPM_ENGINE_C3_B, TPM_MNG_PRI_LU_TYPE_C3_IPV4_5T, 0, 0},
+
+	/* IPV6_UC_RTR, 5T */
+	{TPM_MATCH_IPV6_5T, TPM_API_PRIVATE_EXCT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON,
+	 TPM_MNG_CLS_PRI_IPVX, TPM_ENGINE_C3_B, TPM_MNG_PRI_LU_TYPE_C3_IPV6_5T, 0, 0},
+
+	{TPM_MATCH_IPV6_5T, TPM_API_PRIVATE_EXCT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,
+	 TPM_MNG_CLS_PRI_IPVX, TPM_ENGINE_C3_B, TPM_MNG_PRI_LU_TYPE_C3_IPV6_5T, 0, 0},
+
+	/* IPV4_UC_RTR, TCP_FLAG_S */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_S, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_S, 0, 0},
+
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_S, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_S, 0, 0},
+
+	/* IPV6_UC_RTR, TCP_FLAG_S */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_S, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_S, 0, 0},
+
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S, TPM_API_PRIVATE_EXCT_DEFAULT, TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,
+	 TPM_MNG_CLS_PRI_TCP_FLAG_S, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_TCP_FLAG_S, 0, 0},
+
+	/* IPV4_MC US */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT, TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_IGMP_SNP, 0, 0},
+
+	/* IPV4_MC DS */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT, TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_IGMP_SNP, 0, 0},
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT, TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_IGMP_SNP, 0, 0},
+
+	/* IPV6_MC US */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT, TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MLD_SNP, 0, 0},
+
+	/* IPV6_MC DS */
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT, TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MLD_SNP, 0, 0},
+	{TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT, TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MNG_MC_CLS_PRI_IGMP_SNP, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MLD_SNP, 0, 0},
+
+	/* loopback port MH cap */
+	{TPM_MATCH_MH, TPM_API_PRIVATE_LPBK_MH, TPM_MNG_FLOW_ID_LOOPBACK_PORT,
+	 TPM_MNG_CLS_PRI_CPU_Q, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_LOOPBACK_MH, 0, 0},
+};
+
+/* config Multicast private caps, MAC based cap and IP based cap */
+static struct tpm_db_mng_flow_cap_conf_t tpm_mng_mc_pri_cap_cfg[] = {
+/* IP based section */
+#ifdef CONFIG_MV_ETH_PP2_1 /* Z1 does not support PPPoE proto check */
+	/* VID + PPPoE + SIP + DIP, IPV4 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_VID_PPOE_SIP_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_VID_PPOE_SIP_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* VID + PPPoE + SIP + DIP, IPV6 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_VID_PPOE_SIP_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_VID_PPOE_SIP_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+#endif
+	/* VID + SIP + DIP, IPV4 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_VID_SIP_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_VID_SIP_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* VID + SIP + DIP, IPV6 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_VID_SIP_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_VID_SIP_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+#ifdef CONFIG_MV_ETH_PP2_1 /* Z1 does not support PPPoE proto check */
+	/* VID + PPPoE + DIP, IPV4 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_VID_PPOE_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_VID_PPOE_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* VID + PPPoE + DIP, IPv6 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_VID_PPOE_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_VID_PPOE_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+#endif
+	/* VID + DIP, IPV4 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_VID_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_VID_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* VID + DIP, IPV6 */
+	{TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_VID_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_VID_DIP, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+#ifdef CONFIG_MV_ETH_PP2_1 /* Z1 does not support PPPoE proto check */
+	/* Tag + PPPoE + DIP, IPV4 */
+	{TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_TAG_PPOE_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_PPOE_DIP, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* Tag + PPPoE + DIP, IPV6 */
+	{TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_TAG_PPOE_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_PPOE_DIP, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+#endif
+
+	/* Tag + DIP, IPV4 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_TAG_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_DIP, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* Tag + DIP, IPV6 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_TAG_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_TAG_DIP, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+#ifdef CONFIG_MV_ETH_PP2_1 /* Z1 does not support PPPoE proto check */
+	/* Untag + PPPoE + DIP, IPV4 */
+	{TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_UNTAG_PPOE_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_PPOE_DIP, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	 /* Untag + PPPoE + DIP, IPV6 */
+	{TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MC_UNTAG_PPOE_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_PPOE_DIP, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+#endif
+
+	/* Untag + DIP, IPV4 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_UNTAG_DIP_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_DIP, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+	/* Untag + DIP, IPV6 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MC_UNTAG_DIP_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C2_MC_UNTAG_DIP, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+/* MAC based section */
+	/* DMAC+SMAC+VID IPv4 and non-ip */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_ETH_SRC | TPM_MATCH_VID_OUTER,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_DMAC_SMAC_VID_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_DMAC_SMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+SMAC+VID IPv6 */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_ETH_SRC | TPM_MATCH_VID_OUTER | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_DMAC_SMAC_VID_PRI, TPM_ENGINE_C3_A, TPM_MNG_PRI_LU_TYPE_C3_MC_DMAC_SMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+VID IPv4 and non-ip */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_VID_OUTER,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_DMAC_VID_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+VID IPV6 */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_VID_OUTER | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_DMAC_VID_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+Tag IPv4 and non-ip */
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_DMAC_TAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+Tag IPv6 */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_DMAC_TAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG, 0, 0,
+	 TPM_SINGLE_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+Untag IPv4 and non-ip */
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_DMAC_UNTAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_UNTAG, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC+Untag IPv6 */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MC_DMAC_UNTAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_UNTAG, 0, 0,
+	 TPM_NO_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* Multicast US cap (IPV4/IPV6/NON-IP), no modification to them */
+	/* DMAC+VID */
+	{TPM_MATCH_ETH_DST | TPM_MATCH_VID_OUTER,
+	 TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON,
+	 TPM_MC_DMAC_VID_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	{TPM_MATCH_ETH_DST | TPM_MATCH_VID_OUTER,
+	 TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON,
+	 TPM_MC_DMAC_VID_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_VID, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	/* DMAC */
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON,
+	 TPM_MC_DMAC_TAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_US, TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON,
+	 TPM_MC_DMAC_TAG_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DMAC_TAG, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DATA_TRAFFIC_TYPE, 0},
+
+/* Default rule section */
+	/* L3, PPoE ethertype, 0x8864, default rule */
+	/* IPV4 */
+	{TPM_MATCH_ETH_TYPE,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_PPOE_ETH_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_PPOE_ETH_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	 /* IPV6 */
+	 {TPM_MATCH_ETH_TYPE,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MC_PPOE_ETH_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_PPOE_ETH_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	 /* IPV4 */
+	{TPM_MATCH_ETH_TYPE,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_PPOE_ETH_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_PPOE_ETH_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	 /* IPV6 */
+	{TPM_MATCH_ETH_TYPE,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_PPOE_ETH_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_PPOE_ETH_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+
+	/*L2, DIP, default rule */
+	/* IPV4 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_IP_BASE_DIP_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_IP_BASE_DIP_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	 /* IPV6 */
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,
+	 TPM_MC_IP_BASE_DIP_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	{TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PKT,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,
+	 TPM_MC_IP_BASE_DIP_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_DIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+
+	/* L2, non-ip, default rule */
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,
+	 TPM_MC_NONIP_MAC_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_NONIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+	{TPM_MATCH_ETH_DST,
+	 TPM_API_PRIVATE_MC_DS, TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,
+	 TPM_MC_NONIP_MAC_DEF_PRI, TPM_ENGINE_C2, TPM_MNG_PRI_LU_TYPE_C2_MC_NONIP_DEF, 0, 0,
+	 TPM_ANY_VLAN, TPM_MC_DEF_DIP_TYPE, 0},
+
+};
+
+struct tpm_cls_fl_rule_list_t g_tpm_mng_flow_rules;
+
+/*******************************************************************************
+* tpm_mng_vlan_num_get
+*
+* DESCRIPTION: The routine get vlan number from pkt_key
+*
+* INPUTS:
+*              pkt_key:
+*
+* OUTPUTS:
+*           vlan_num
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_vlan_num_get(
+	struct tpm_pkt_key_t *pkt_key,
+	enum tpm_vlan_num_enum_t *vlan_num)
+{
+	IF_NULL(TPM_MNG_MOD, pkt_key);
+	IF_NULL(TPM_MNG_MOD, vlan_num);
+
+	/* get vlan_num */
+	if (!(pkt_key->field_match_bm & TPM_MATCH_VID_OUTER)
+	&& !(pkt_key->field_match_bm & TPM_MATCH_VID_INNER))
+		*vlan_num = TPM_ANY_VLAN;
+	else if ((pkt_key->field_match_bm & TPM_MATCH_VID_INNER)
+		&& (pkt_key->inn_vid == TPM_ALL_VID))
+		*vlan_num = TPM_DOUBLE_VLAN;
+	else if ((pkt_key->field_match_bm & TPM_MATCH_VID_INNER)
+		&& (pkt_key->inn_vid == TPM_NO_VID))
+		*vlan_num = TPM_NOT_DOUBLE_VLAN;
+	else if ((pkt_key->field_match_bm & TPM_MATCH_VID_OUTER)
+		&& (pkt_key->out_vid == TPM_ALL_VID))
+		*vlan_num = TPM_SINGLE_VLAN;
+	else if ((pkt_key->field_match_bm & TPM_MATCH_VID_OUTER)
+		&& (pkt_key->out_vid == TPM_NO_VID))
+		*vlan_num = TPM_NO_VLAN;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_add_cap_entry_print
+*
+* DESCRIPTION: The routine print a API entry
+*
+* INPUTS:
+*              cap:
+*              please refer to tpm_c2_rule_add
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_mng_add_cap_entry_print(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_pkt_key_t  *match_key,
+	unsigned int             act_num,
+	struct tpm_pkt_action_t   *action,
+	unsigned short           policer_id)
+{
+	int ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+
+	/* allocate api data */
+	ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR_RET_VOID(TPM_MNG_MOD, ret, "allocate api_data structure mem failed!\n");
+
+	memcpy(&api_data->action, action, sizeof(api_data->action));
+	memcpy(&api_data->match_key, match_key, sizeof(api_data->match_key));
+	api_data->policer_id = policer_id;
+	api_data->cap_api_type = api_type;
+	api_data->num_dest = act_num;
+
+	tpm_sfs_api_rule_date_dump(api_data);
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_mng_rule_id_get
+*
+* DESCRIPTION: The routine gets rule_id from Key value.
+*
+* INPUTS:
+*           cap_api_type -
+*           pkt_key         -
+*
+* OUTPUTS:
+*           rule_id
+*
+* RETURNS:
+*
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_rule_id_get(
+	enum tpm_mng_api_type_t	cap_api_type,
+	struct tpm_pkt_key_t	*pkt_key,
+	unsigned int		*rule_id)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+
+	IF_NULL(TPM_MNG_MOD, pkt_key);
+	IF_NULL(TPM_MNG_MOD, rule_id);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_entry_type_first_get(cap_api_type, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "get API rule_id failed!\n");
+
+	for (; tpm_ret == TPM_OK; tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data)) {
+		if (TPM_API_PRIVATE_EXCT == cap_api_type)
+			/* for exact match, port is not relervant */
+			TPM_MEMSET_ZERO(api_data->match_key.port);
+
+		if (!memcmp(pkt_key, &api_data->match_key, sizeof(api_data->match_key))) {
+			*rule_id = api_data->api_rule_id;
+			/* release api data */
+			tpm_db_mng_api_data_release(api_data);
+			return TPM_OK;
+		}
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_NOT_FOUND;
+}
+
+/*******************************************************************************
+* tpm_mng_cpu_queue_high_get
+*
+* DESCRIPTION: The routine get CPU Q high
+*
+* INPUTS:
+*           port              port_id
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+*           cpu queue high
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cpu_queue_high_get(struct tpm_class_port_t *port)
+{
+	int queue = 0;
+
+	if (port->port_type == TPM_CLASS_PP_PORT_BM)
+		if (TPM_PP_PMAC == port->class_port)
+			queue = TPM_MNG_PON_QHIGH;
+		else
+			queue = port->class_port / 2;
+	else if (port->port_type == TPM_CLASS_SWITCH_PORT_BM)
+		queue = TPM_PP_GMAC0 / 2;
+	else if (port->port_type == TPM_CLASS_VIRT_PORT)
+		queue = TPM_MNG_PON_QHIGH;
+
+	return queue;
+}
+
+/*******************************************************************************
+* tpm_mng_flow_way_get
+*
+* DESCRIPTION: The routine get way of flow
+*
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           way
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_flow_way_get(enum tpm_mng_flow_log_id_t flow_id,
+				     int *way)
+{
+	int loop;
+	int loop_max = sizeof(tpm_mng_flow_cfg_init) / sizeof(struct tpm_db_mng_flow_conf_t);
+
+	IF_NULL(TPM_MNG_MOD, way);
+	/* get way of flow_id */
+	for (loop = 0; loop < loop_max; loop++) {
+		if (tpm_mng_flow_cfg_init[loop].flow_log_id == flow_id) {
+			*way = tpm_mng_flow_cfg_init[loop].way;
+			return TPM_OK;
+		}
+	}
+	return TPM_FAIL;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_flow_cfg_update
+*
+* DESCRIPTION: Update tpm_mng_flow_cfg_init for multicast flow when MC traffic
+*              is not handled as multicast
+*
+* INPUTS:
+*           flow_cfg_idx - The flow index in tpm_mng_flow_cfg_init array.
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           If multicast pkt handle mode is not MC, handle it as UC bridge packet.
+*******************************************************************************/
+static int tpm_mng_mc_flow_cfg_update(int flow_cfg_idx)
+{
+	int log_id_d, loop_d;
+	int i, j;
+	int loop_max = sizeof(tpm_mng_flow_cfg_init) / sizeof(struct tpm_db_mng_flow_conf_t);
+
+	switch (tpm_mng_flow_cfg_init[flow_cfg_idx].flow_log_id) {
+	case TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON:
+		log_id_d = TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON;
+	case TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON:
+		if (tpm_mng_flow_cfg_init[flow_cfg_idx].flow_log_id ==
+		    TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON)
+			log_id_d = TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_PON;
+	case TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON:
+		if (tpm_mng_flow_cfg_init[flow_cfg_idx].flow_log_id ==
+		    TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON)
+			log_id_d = TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_PON;
+	case TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON:
+		if (tpm_mng_flow_cfg_init[flow_cfg_idx].flow_log_id ==
+		    TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON)
+			log_id_d = TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_PON;
+
+		/* Search array index with log_id_d */
+		for (loop_d = 0; loop_d < loop_max; loop_d++) {
+			if (tpm_mng_flow_cfg_init[loop_d].flow_log_id == log_id_d)
+				break;
+		}
+		if (loop_d == loop_max)
+			return TPM_FAIL;
+
+		/* Update tpm_mng_flow_cfg_init */
+		for (i = 0; i < TPM_DB_MNG_FLOW_LUID_MAX; i++) {
+			if (tpm_mng_flow_cfg_init[flow_cfg_idx].luid_conf[i].luid ==
+			    TPM_MNG_ILLEGAL_LUID)
+				break;
+			for (j = 0; j < TPM_DB_MNG_FLOW_LUID_MAX; j++) {
+				if (tpm_mng_flow_cfg_init[loop_d].luid_conf[j].luid ==
+				TPM_MNG_ILLEGAL_LUID) {
+					tpm_mng_flow_cfg_init[loop_d].luid_conf[j].luid =
+					tpm_mng_flow_cfg_init[flow_cfg_idx].luid_conf[i].luid;
+					break;
+				}
+			}
+			tpm_mng_flow_cfg_init[flow_cfg_idx].luid_conf[i].luid = TPM_MNG_ILLEGAL_LUID;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_get_flow_cfg
+*
+* DESCRIPTION: The routine get flow cfg
+*
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           flow_cfg
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_get_flow_cfg(enum tpm_mng_flow_log_id_t flow_id,
+				 struct tpm_db_mng_flow_conf_t *flow_cfg)
+{
+	int tpm_ret;
+	int loop;
+	unsigned int data_handle;
+	int loop_max = sizeof(tpm_mng_flow_cfg_init) / sizeof(struct tpm_db_mng_flow_conf_t);
+
+	/* Get multicast handle mode */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	/* Update tpm_mng_flow_cfg_init according to multicast packet handle mode */
+	if ((data_handle != TPM_HANDLER_MC) && (g_flow_cfg_update_flag == TPM_MNG_FLOW_NO_UPDATE)) {
+		/* If multicast pkt handle mode is not MC, handle it as UC bridge packet */
+		for (loop = 0; loop < loop_max; loop++) {
+			/* If multicast pkt handle mode is not MC, handle it as UC bridge packet */
+			tpm_ret = tpm_mng_mc_flow_cfg_update(loop);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "tpm_mng_flow_cfg_init update for MC failed\n");
+		}
+		g_flow_cfg_update_flag = TPM_MNG_FLOW_UPDATED;
+	}
+
+	/* get cfg of flow_id */
+	for (loop = 0; loop < loop_max; loop++) {
+		if (tpm_mng_flow_cfg_init[loop].flow_log_id == flow_id) {
+			memcpy(flow_cfg, &tpm_mng_flow_cfg_init[loop], sizeof(struct tpm_db_mng_flow_conf_t));
+			return TPM_OK;
+		}
+	}
+	return TPM_FAIL;
+}
+/*******************************************************************************
+* tpm_mng_decode_tbl_set
+*
+* DESCRIPTION: The routine set decode table to CLS
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_decode_tbl_set(enum tpm_mng_flow_log_id_t flow_id, int flow_len)
+{
+	struct tpm_cls_lkp_dcod_entry_t lkp_dcod_conf;
+	struct tpm_db_mng_flow_conf_t flow_cfg;
+	struct tpm_class_port_t port;
+	int  tpm_ret;
+	int  loop;
+	int  way;
+	int  cpu_queue_low;
+	int  cpu_queue_high;
+
+	TPM_MEMSET_ZERO(lkp_dcod_conf);
+	TPM_MEMSET_ZERO(flow_cfg);
+
+	tpm_ret = tpm_mng_get_flow_cfg(flow_id, &flow_cfg);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get Cfg failed for flow_id(%d)\n", flow_id);
+
+	tpm_ret = tpm_mng_flow_way_get(flow_id, &way);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get way failed for flow_id(%d)\n", flow_id);
+
+	port.port_type = TPM_CLASS_PP_PORT_BM;
+	if (way == TPM_WAY_NON_PON)
+		port.class_port = TPM_PP_GMAC0;
+	else
+		port.class_port = TPM_PP_PMAC;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue_low);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+
+	cpu_queue_high = tpm_mng_cpu_queue_high_get(&port);
+
+	lkp_dcod_conf.cpu_q = ((cpu_queue_high << 3) | cpu_queue_low);
+	lkp_dcod_conf.flow_log_id = flow_id;
+	lkp_dcod_conf.way = flow_cfg.way;
+	lkp_dcod_conf.flow_len = flow_len;
+
+	for (loop = 0; loop < TPM_CLS_LOG_FLOW_LUID_MAX; loop++) {
+		if (flow_cfg.luid_conf[loop].luid != TPM_MNG_ILLEGAL_LUID) {
+			lkp_dcod_conf.luid_list[loop].luid = flow_cfg.luid_conf[loop].luid;
+			lkp_dcod_conf.luid_list[loop].first_pri = flow_cfg.luid_conf[loop].c2_pri;
+		} else
+			break;
+	}
+	lkp_dcod_conf.luid_num = loop;
+	tpm_ret = tpm_cls_lkp_dcod_set(&lkp_dcod_conf);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set Cfg to CLS failed for flow_id(%d)\n", flow_id);
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_decode_tbl_enable
+*
+* DESCRIPTION: The routine enable decode table to CLS
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_decode_tbl_enable(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	int  tpm_ret;
+	int  ipv6_enable;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		&& (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+
+		tpm_ret = tpm_cls_lkp_dcod_enable(flow_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "enable decode table failed for flow_id(%d)\n", flow_id);
+	}
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_def_flow_entry_crt
+*
+* DESCRIPTION: The routine creates a flow entry
+*
+* INPUTS:
+*           cap_arr:           cap entry
+*           src_port_cfgn   flow entry for which port to be created
+*           uni_port_bm     uni port number to create flow entry for
+*
+* OUTPUTS:
+*           flow_rules:       flow rule list
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_def_flow_entry_crt(
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr,
+	struct tpm_cls_fl_rule_list_t *flow_rules,
+	enum tpm_mng_src_port_type_t src_port_cfg,
+	int                         uni_port_bm)
+{
+	struct tpm_cls_fl_rule_entry_t fl_rule_entry;
+	struct tpm_mng_pkt_key_t  tpm_pkt_key;
+	struct tpm_field_match_info field_info[TPM_MNG_MAX_FIELD_NUM];
+	struct tpm_pkt_key_t pkt_key;
+	int cur_number = flow_rules->fl_len;
+	int way;
+	int loop;
+	int tpm_ret;
+	bool l4_prot_check = true;
+
+	IF_NULL(TPM_MNG_MOD, cap_arr);
+	IF_NULL(TPM_MNG_MOD, flow_rules);
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+
+	tpm_ret = tpm_mng_flow_way_get(cap_arr->flow_log_id, &way);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get flow_id way failed for flow_id(%d)\n", cap_arr->flow_log_id);
+
+	if (cap_arr->cap_api_type < TPM_API_PRIVATE_START)
+		fl_rule_entry.enabled = TPM_FALSE;
+	else
+		fl_rule_entry.enabled = TPM_TRUE;
+
+	fl_rule_entry.engine = cap_arr->eng_no;
+	fl_rule_entry.fl_log_id = cap_arr->flow_log_id;
+	fl_rule_entry.lu_type = cap_arr->lu_type;
+	fl_rule_entry.prio = cap_arr->cls_pri;
+
+	/* get field ID */
+	TPM_MEMSET_ZERO(field_info);
+	TPM_MEMSET_ZERO(tpm_pkt_key);
+	TPM_MEMSET_ZERO(pkt_key);
+	tpm_pkt_key.pkt_key = &pkt_key;
+
+	/* if using C3_B & proto match do not check L4_Prot in HEK, use L4_info of C3 */
+	if ((cap_arr->eng_no == TPM_ENGINE_C3_B) && (TPM_MATCH_IP_PROTO & cap_arr->cap_field_bm))
+		l4_prot_check = false;
+	else
+		l4_prot_check = true;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD,
+				"cap api_type(%d) flow_log_id(%d) lu_type(%d) cls_pri(%d) eng_no(%d) c2_key_bm(0x%x)\n"
+				"uni_port_bm(0x%x) way(%d) fl_rule.enabled(%d)\n",
+				cap_arr->cap_api_type, cap_arr->flow_log_id, cap_arr->lu_type, cap_arr->cls_pri,
+				cap_arr->eng_no, cap_arr->c2_key_bm, uni_port_bm, way, fl_rule_entry.enabled);
+
+	tpm_ret = tpm_field_bm_to_field_info(cap_arr->c2_key_bm,
+			&tpm_pkt_key, TPM_MNG_MAX_FIELD_NUM,
+			l4_prot_check, field_info);
+	IF_ERROR(TPM_MNG_MOD, tpm_ret);
+
+	for (loop = 0; loop < TPM_MNG_MAX_FIELD_NUM; loop++) {
+		if (field_info[loop].valid)
+			fl_rule_entry.field_id[loop] = field_info[loop].field_id;
+		else
+			break;
+	}
+	fl_rule_entry.field_id_cnt = loop;
+	/* vir/uni port */
+	if ((TPM_WAY_PON == way) && (src_port_cfg & TPM_CAP_PORT_VIR)) {
+		fl_rule_entry.port_bm = 0;
+		fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_VIR;
+		memcpy(&flow_rules->fl[cur_number],
+			&fl_rule_entry,
+			sizeof(fl_rule_entry));
+		cur_number++;
+	} else if ((TPM_WAY_NON_PON == way) && (src_port_cfg & TPM_CAP_PORT_UNI)) {
+		fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_UNI;
+#ifndef CONFIG_MV_ETH_PP2_1
+		if (cap_arr->cap_api_type != TPM_API_PRIVATE_CNM) {
+			for (loop = 0; loop < TPM_NUM_MAX_UNI_PORTS; loop++) {
+				if (0 == ((1 << loop) & uni_port_bm))
+					continue;
+
+				fl_rule_entry.port_bm = 1 << loop;
+				memcpy(&flow_rules->fl[cur_number],
+					&fl_rule_entry,
+					sizeof(fl_rule_entry));
+				cur_number++;
+			}
+		} else {
+			/* C4 engine take portID from packet not CLS */
+			if (uni_port_bm & TPM_UNI_PORTS_BM) {
+				fl_rule_entry.port_bm = uni_port_bm & TPM_UNI_PORTS_BM;
+				memcpy(&flow_rules->fl[cur_number],
+					&fl_rule_entry,
+					sizeof(fl_rule_entry));
+				cur_number++;
+			}
+		}
+#else
+		if (uni_port_bm & TPM_UNI_PORTS_BM) {
+			fl_rule_entry.port_bm = uni_port_bm & TPM_UNI_PORTS_BM;
+			memcpy(&flow_rules->fl[cur_number],
+				&fl_rule_entry,
+				sizeof(fl_rule_entry));
+			cur_number++;
+		}
+#endif
+	}
+
+	/* physical port */
+	if ((TPM_WAY_PON == way) && (src_port_cfg & TPM_CAP_PORT_PON)) {
+		fl_rule_entry.port_bm = TPM_SRC_PORT_PON;
+		fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_PHY;
+		memcpy(&flow_rules->fl[cur_number],
+			&fl_rule_entry,
+			sizeof(fl_rule_entry));
+		cur_number++;
+	} else if (TPM_WAY_NON_PON == way) {
+#ifndef CONFIG_MV_ETH_PP2_1
+		if (src_port_cfg & TPM_CAP_PORT_G0) {
+			fl_rule_entry.port_bm = TPM_SRC_PORT_G0;
+			fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_PHY;
+			memcpy(&flow_rules->fl[cur_number],
+				&fl_rule_entry,
+				sizeof(fl_rule_entry));
+			cur_number++;
+		}
+		if (src_port_cfg & TPM_CAP_PORT_G1) {
+			fl_rule_entry.port_bm = TPM_SRC_PORT_G1;
+			fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_PHY;
+			memcpy(&flow_rules->fl[cur_number],
+				&fl_rule_entry,
+				sizeof(fl_rule_entry));
+			cur_number++;
+		}
+		if (src_port_cfg & TPM_CAP_PORT_LPBK) {
+			fl_rule_entry.port_bm = TPM_SRC_PORT_LPBK;
+			fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_PHY;
+			memcpy(&flow_rules->fl[cur_number],
+				&fl_rule_entry,
+				sizeof(fl_rule_entry));
+			cur_number++;
+		}
+#else
+		fl_rule_entry.port_bm = 0;
+		if (src_port_cfg & TPM_CAP_PORT_G0)
+			fl_rule_entry.port_bm |= TPM_SRC_PORT_G0;
+		if (src_port_cfg & TPM_CAP_PORT_G1)
+			fl_rule_entry.port_bm |= TPM_SRC_PORT_G1;
+		if (src_port_cfg & TPM_CAP_PORT_LPBK)
+			fl_rule_entry.port_bm |= TPM_SRC_PORT_LPBK;
+
+		fl_rule_entry.port_type = TPM_SRC_PORT_TYPE_PHY;
+		memcpy(&flow_rules->fl[cur_number],
+			&fl_rule_entry,
+			sizeof(fl_rule_entry));
+		cur_number++;
+#endif
+	}
+
+	flow_rules->fl_len = cur_number;
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_def_flow_tbl_create
+*
+* DESCRIPTION: The routine creates flow tables for all the flow_log_id
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_def_flow_tbl_create(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_cls_fl_rule_entry_t *flow_rules;
+	struct tpm_cls_fl_rule_list_t *flow_rules_list = &g_tpm_mng_flow_rules;
+	enum tpm_mng_src_port_type_t src_port_cfg;
+	enum tpm_mng_src_port_type_t src_port_cfg_phy;
+	enum tpm_mng_src_port_type_t src_port_cfg_uni_vir;
+	int loop;
+	int tpm_ret;
+	int uni_num;
+	int uni_port_bm = 0;
+	int hit_num;
+	int  ipv6_enable;
+	int cap_num;
+	flow_rules = flow_rules_list->fl;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &uni_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get max uni port number failed\n");
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	/* get uni_port_bm */
+	for (loop = 0; loop < uni_num; loop++)
+		uni_port_bm |= (1 << loop);
+
+	/* go through flow_cap_conf */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		&& (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+		flow_rules_list->fl_len = 0;
+		memset(flow_rules_list, 0, sizeof(g_tpm_mng_flow_rules));
+		TPM_MEMSET_ZERO(cap_arr);
+
+		/* get all the cap in this flow */
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+
+		/* go through caps */
+		for (loop = 0; loop < cap_num; loop++) {
+			/* do not handle merged caps */
+			if (cap_arr[loop].c2_pri != 0)
+				continue;
+
+			if (cap_arr[loop].cap_api_type >= TPM_API_PRIVATE_START) {
+				/* for private cap, hit number is hardcoded */
+				if ((cap_arr[loop].cap_api_type == TPM_API_PRIVATE_CNM)
+				     || (cap_arr[loop].cap_api_type == TPM_API_PRIVATE_LPBK_MH))
+					hit_num = 1;
+				else
+					hit_num = 2;
+			} else {
+				tpm_ret = tpm_db_mng_cap_hit_num_get(cap_arr[loop].cap_api_type,
+					cap_arr[loop].rule_type, cap_arr[loop].cap_field_bm,
+					cap_arr[loop].vlan_num, &hit_num);
+
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+				"get CAP hit num failed, cap_type(%d), field_bm(0x%x), vlan_num(%d), rule_type(%d)\n",
+				cap_arr[loop].cap_api_type, cap_arr[loop].cap_field_bm,
+				cap_arr[loop].vlan_num, cap_arr[loop].rule_type);
+			}
+
+			/* for cap which represent several merged caps, hit number is always 2 */
+			if ((loop + 1 < cap_num)
+				&& (cap_arr[loop + 1].c2_pri != 0))
+				hit_num = 2;
+
+			if (hit_num == 1)
+				src_port_cfg = TPM_CAP_PORT_VIR | TPM_CAP_PORT_UNI;
+			else
+				src_port_cfg = TPM_CAP_PORT_G0 | TPM_CAP_PORT_G1
+						| TPM_CAP_PORT_PON  | TPM_CAP_PORT_VIR
+						| TPM_CAP_PORT_UNI;
+			src_port_cfg_phy = src_port_cfg & (~(TPM_CAP_PORT_UNI | TPM_CAP_PORT_VIR));
+			src_port_cfg_uni_vir = src_port_cfg & (~(TPM_CAP_PORT_G0 | TPM_CAP_PORT_G1 | TPM_CAP_PORT_PON));
+
+			switch (cap_arr[loop].cap_api_type) {
+			case TPM_API_PUBLIC_CLS:
+			case TPM_API_PUBLIC_FLTR:
+			case TPM_API_PUBLIC_EXCT_EXCPT:
+			case TPM_API_PRIVATE_EXCT:
+			case TPM_API_PRIVATE_MC_US:
+				/* phy + vir */
+				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
+					flow_rules_list,
+					src_port_cfg_uni_vir, uni_port_bm);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+
+				if (src_port_cfg_phy) {
+					/* this cap takes both phy and vir/uni port, so takes 2 cls_pri */
+					cap_arr[loop].cls_pri++;
+					tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
+						flow_rules_list,
+						src_port_cfg_phy, 0);
+					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+				}
+
+				break;
+			case TPM_API_PRIVATE_EXCT_DEFAULT:
+			case TPM_API_PRIVATE_CPU_Q:
+			case TPM_API_PRIVATE_CNM_PBIT:
+			case TPM_API_PRIVATE_MC_DS:
+				/* phy */
+				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
+					flow_rules_list,
+					src_port_cfg_phy, 0);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+
+				break;
+			case TPM_API_PRIVATE_LPBK_MH:
+				/* LOOPBACK */
+				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
+					flow_rules_list,
+					TPM_CAP_PORT_LPBK, 0);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+
+				break;
+			case TPM_API_PRIVATE_CNM:
+				/* uini */
+				tpm_ret = tpm_mng_def_flow_entry_crt(&cap_arr[loop],
+					flow_rules_list,
+					src_port_cfg_uni_vir, uni_port_bm);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "creat flow entry failed\n");
+
+				break;
+
+			/* following is not supported yet */
+			case TPM_API_PRIVATE_CLS:
+				break;
+
+			default:
+				TPM_OS_ERROR(TPM_MNG_MOD,
+					"api_type not supported(%d)\n",
+					cap_arr[loop].cap_api_type);
+				return TPM_FAIL;
+			}
+
+		}
+
+		/* set decode table */
+		tpm_ret = tpm_mng_decode_tbl_set(flow_id, flow_rules_list->fl_len);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set decode table failed for flow_id(%d)\n", flow_id);
+		tpm_ret = tpm_cls_fl_rule_add(flow_rules_list);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create flow_tbl failed for flow_id(%d)\n", flow_id);
+
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_unused_lkp_dcod_to_cpu
+*
+* DESCRIPTION: The routine creates default lookup decode table entries for all unhandled LUID
+*		This routine is a dirty workaround and should be replaced with assignment
+*		of new CLS entries for each LUID and use CPU default C2 rule to handle traffic comming
+*		from PON/P0/P1 and LB ports
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           TODO: replace this routine with a better implementation!!
+*******************************************************************************/
+static int tpm_mng_unused_lkp_dcod_to_cpu(void)
+{
+	unsigned int		i, w;
+	MV_PP2_CLS_LKP_ENTRY	fe;
+	int			en;
+	int			rc;
+	int			way[2] = {TPM_WAY_NON_PON, TPM_WAY_PON};
+	struct tpm_class_port_t port;
+	int			cpu_q_h,
+				cpu_q_l;
+
+	port.port_type = TPM_CLASS_PP_PORT_BM;
+
+	for (i = IPV4_UC_RTR_NF_NPPOE_UNTAG_ID; i < UNEXPECTED_PKT_ID; i++) {
+		for (w = 0; w < sizeof(way)/sizeof(int); w++) {
+			mvPp2ClsSwLkpClear(&fe);
+			rc = mvPp2ClsHwLkpRead(i, way[w], &fe);
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			rc = mvPp2ClsSwLkpEnGet(&fe, &en);
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			if (en)
+				continue;
+
+			rc = mvPp2ClsSwLkpFlowSet(&fe, 0);
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			port.class_port = (TPM_WAY_PON == way[w]) ? TPM_PP_PMAC : TPM_PP_GMAC0;
+
+			rc = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_q_l);
+			IF_ERROR_STR(TPM_MNG_MOD, rc, "get CPU_RX_QUEUE failed\n");
+
+			cpu_q_h = tpm_mng_cpu_queue_high_get(&port);
+
+			rc = mvPp2ClsSwLkpRxqSet(&fe, ((cpu_q_h << 3) | cpu_q_l));
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			rc = mvPp2ClsSwLkpEnSet(&fe, 0);
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			rc = mvPp2ClsHwLkpWrite(i, way[w], &fe);
+			IF_ERROR(TPM_MNG_MOD, rc)
+
+			TPM_OS_DEBUG(TPM_MNG_MOD, "set default RXQ[%2d] for luid[%2d] way[%d] in lkp_decode table\n",
+				((cpu_q_h << 3) | cpu_q_l),
+				i, way[w]);
+		}
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_match_untag_flow
+*
+* DESCRIPTION: The routine tells if cap with untag should have a flow entry in flow_log_id's flow table
+*
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_untag_flow(enum tpm_mng_flow_log_id_t flow_id)
+{
+	/* only checks tag flow */
+	if ((flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_NPON))
+		return TPM_FALSE;
+
+	return TPM_TRUE;
+}
+/*******************************************************************************
+* tpm_mng_cap_match_tag_flow
+*
+* DESCRIPTION: The routine tells if cap with tag should have a flow entry in flow_log_id's flow table
+*		some flow_ids take all untag/tag/double tag, also in match this routine
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_tag_flow(enum tpm_mng_flow_log_id_t flow_id)
+{
+	/* only checks tag flow */
+	if ((flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON))
+		return TPM_FALSE;
+
+	return TPM_TRUE;
+}
+/*******************************************************************************
+* tpm_mng_cap_match_dtag_flow
+*
+* DESCRIPTION: The routine tells if cap with 2 tags should have a flow entry in flow_log_id's flow table
+*		some flow_ids take all untag/tag/double tag, also in match this routine
+* INPUTS:
+*           flow_id
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_dtag_flow(enum tpm_mng_flow_log_id_t flow_id)
+{
+	/* only checks double tag flow */
+	if ((flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_PON)
+		&& (flow_id != TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON))
+		return TPM_FALSE;
+
+	return TPM_TRUE;
+}
+/*******************************************************************************
+* tpm_mng_cap_match_l2_flow
+*
+* DESCRIPTION: The routine tells if cap should have a flow entry in L2 flow_log_id's flow table
+*
+* INPUTS:
+*           flow_id
+*           cap_arr
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_l2_flow(struct tpm_db_mng_cap_conf_t *cap_arr,
+				     enum tpm_mng_flow_log_id_t flow_id)
+{
+	IF_NULL(TPM_MNG_MOD, cap_arr);
+
+	/* this routine only checks l2 public caps */
+	if (flow_id < TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON)
+		return TPM_FALSE;
+	if (flow_id >= TPM_MNG_FLOW_ID_UNEXPECTED_PKT_PON
+	     && flow_id <= TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON)
+		return TPM_FALSE;
+
+	/* check ipv4/6 */
+	if ((cap_arr->cap_field_bm & (TPM_MATCH_PPPOE_PROTO | TPM_MATCH_PPPOE_SES))
+	     && ((flow_id < TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON)
+		|| (flow_id > TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON)))
+		return TPM_FALSE;
+	if (((cap_arr->cap_field_bm >= TPM_MATCH_IPV4_PKT)
+		  && (!(cap_arr->cap_field_bm & TPM_MATCH_ARP_TRGT_IP_ADDR)))
+	     && ((flow_id >= TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON)
+		&& (flow_id <= TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON)))
+		return TPM_FALSE;
+
+	/* check tag */
+	if ((cap_arr->cap_field_bm & (TPM_MATCH_VID_INNER | TPM_MATCH_PBITS_INNER))
+	     || (cap_arr->vlan_num == TPM_DOUBLE_VLAN)) {
+		/* has to be double tag */
+		if (!tpm_mng_cap_match_dtag_flow(flow_id))
+			return TPM_FALSE;
+	}
+	if (cap_arr->cap_field_bm & (TPM_MATCH_VID_OUTER | TPM_MATCH_PBITS_OUTER)) {
+		/* has to be single or double tag */
+		if ((!tpm_mng_cap_match_dtag_flow(flow_id))
+		     && (!tpm_mng_cap_match_tag_flow(flow_id)))
+			return TPM_FALSE;
+	}
+
+	if (cap_arr->vlan_num == TPM_SINGLE_VLAN) {
+		/* has to be single tag */
+		if (!tpm_mng_cap_match_tag_flow(flow_id))
+			return TPM_FALSE;
+	}
+
+	if (cap_arr->vlan_num == TPM_NO_VLAN) {
+		/* has to be untag */
+		if (!tpm_mng_cap_match_untag_flow(flow_id))
+			return TPM_FALSE;
+	}
+
+	if (cap_arr->vlan_num == TPM_NOT_DOUBLE_VLAN) {
+		/* has to be untag/single tag */
+		if (tpm_mng_cap_match_dtag_flow(flow_id))
+			return TPM_FALSE;
+	}
+	if (cap_arr->cap_field_bm & TPM_MATCH_ARP_TRGT_IP_ADDR) {
+		if (((cap_arr->cap_field_bm & ~TPM_MATCH_ARP_TRGT_IP_ADDR) < TPM_MATCH_IPV4_PKT)
+		     && ((flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON)
+			  && (flow_id != TPM_MNG_FLOW_ID_NOT_IP_ARP_PON)))
+			return TPM_FALSE;
+	}
+
+	return TPM_TRUE;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_match_l3_flow
+*
+* DESCRIPTION: The routine tells if cap should have a flow entry in L3 flow_log_id's flow table
+*
+* INPUTS:
+*           flow_id
+*           cap_arr
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_l3_flow(struct tpm_db_mng_cap_conf_t *cap_arr,
+				     enum tpm_mng_flow_log_id_t flow_id)
+
+{
+	IF_NULL(TPM_MNG_MOD, cap_arr);
+
+	/* this routine only checks l3 public caps */
+	if (flow_id >= TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON)
+		return TPM_FALSE;
+	if (flow_id >= TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON
+	     && flow_id <= TPM_MNG_FLOW_ID_UNEXPECTED_PKT_NPON)
+		return TPM_FALSE;
+
+	/* check ipv4/6 */
+	if ((cap_arr->cap_field_bm >= TPM_MATCH_IPV4_PKT)
+		&& ((flow_id == TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON)
+		|| (flow_id == TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON)))
+		return TPM_FALSE;
+
+	return TPM_TRUE;
+}
+/*******************************************************************************
+* tpm_mng_cnm_flow_check
+*
+* DESCRIPTION: The routine tells if a flow is non MTM
+*
+* INPUTS:
+*           flow_id
+*           cap_arr
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cnm_flow_check(enum tpm_mng_flow_log_id_t flow_id)
+
+{
+	/* this routine only checks US non-MTM flows */
+	if ((flow_id == TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_UNEXPECTED_PKT_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON)
+		|| (flow_id == TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON))
+
+		return TPM_TRUE;
+	else
+		return TPM_FALSE;
+
+}
+
+/*******************************************************************************
+* tpm_mng_cap_match_flow
+*
+* DESCRIPTION: The routine tells if cap should have a flow entry in flow_log_id's flow table
+*
+* INPUTS:
+*           flow_id
+*           cap_arr
+*
+* OUTPUTS:
+*           NONE
+*
+* RETURNS:
+* On success, the function returns TPM_TRUE, otherwise return TPM_FALSE.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_match_flow(struct tpm_db_mng_cap_conf_t *cap_arr,
+				     enum tpm_mng_flow_log_id_t flow_id)
+{
+	int  ipv6_enable;
+	int  tpm_ret;
+
+	IF_NULL(TPM_MNG_MOD, cap_arr);
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		&& (ipv6_enable != TPM_IPV6_SUPPORTED))
+		return TPM_FALSE;
+
+	/* for loopback type, non cap match */
+	if (flow_id == TPM_MNG_FLOW_ID_LOOPBACK_PORT)
+		return TPM_FALSE;
+
+	/* check IPv4/6 */
+	if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		&& (cap_arr->cap_field_bm & TPM_MATCH_IPV4_PKT))
+		return TPM_FALSE;
+
+	if ((flow_id < TPM_MNG_FLOW_ID_IPV6_START)
+		&& ((cap_arr->cap_field_bm & TPM_MATCH_IPV6_PKT)
+		|| (cap_arr->cap_field_bm & TPM_MATCH_IPV6_FLBL)
+		|| (cap_arr->cap_field_bm & TPM_MATCH_IPV6_PREF)
+		|| (cap_arr->cap_field_bm & TPM_MATCH_IPV6_SUFF)))
+		return TPM_FALSE;
+
+	/* check cap field match flow */
+	if ((cap_arr->cap_api_type == TPM_API_PUBLIC_CLS)
+		|| (cap_arr->cap_api_type == TPM_API_PUBLIC_FLTR)) {
+		if (!tpm_mng_cap_match_l2_flow(cap_arr, flow_id))
+			return TPM_FALSE;
+	}
+	if (cap_arr->cap_api_type == TPM_API_PUBLIC_EXCT_EXCPT) {
+		if (!tpm_mng_cap_match_l3_flow(cap_arr, flow_id))
+			return TPM_FALSE;
+	}
+
+	return TPM_TRUE;
+}
+
+/*******************************************************************************
+* tpm_mng_engine_get
+*
+* DESCRIPTION: The routine get engine No based on field ID size.
+*
+* INPUTS:
+*           field_bm
+*
+* OUTPUTS:
+*           eng_no: engine No.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_engine_get(enum tpm_field_match_t field_bm, enum tpm_engine_no_t *eng_no)
+{
+	int tpm_ret;
+	struct tpm_mng_pkt_key_t  tpm_pkt_key;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_c2_add_entry_t c2_entry;
+	unsigned char hek[TPM_C2_HEK_OFF_MAX];
+	unsigned char hek_mask[TPM_C2_HEK_OFF_MAX];
+
+	TPM_MEMSET_ZERO(tpm_pkt_key);
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(c2_entry);
+
+	pkt_key.field_match_bm = field_bm;
+	tpm_pkt_key.pkt_key = &pkt_key;
+	c2_entry.field_bm = field_bm;
+	c2_entry.field_bm_mask = field_bm;
+	c2_entry.mng_pkt_key = &tpm_pkt_key;
+
+	/* check if C2 could hold this field_bm */
+	tpm_ret = tpm_c2_tcam_hek_get(field_bm, &c2_entry, hek, hek_mask);
+	if (TPM_OK == tpm_ret)
+		*eng_no = TPM_ENGINE_C2;
+	else if ((field_bm == TPM_MATCH_IPV4_5T)
+		  ||	(field_bm == TPM_MATCH_IPV6_5T)) {
+		/* if it is for 5T, then use C3_B */
+		*eng_no = TPM_ENGINE_C3_B;
+	} else
+		*eng_no = TPM_ENGINE_C3_A;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_check
+*
+* DESCRIPTION: The routine checks cap configuration
+*
+* INPUTS:
+*           cap
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_check(struct tpm_db_mng_cap_conf_t *cap)
+{
+	int tpm_ret;
+	unsigned int cnm_support;
+
+	/* check PPPOE with IPvX */
+	if ((cap->cap_field_bm & (TPM_MATCH_PPPOE_PROTO | TPM_MATCH_PPPOE_SES))
+		&& (cap->cap_field_bm >= TPM_MATCH_IPV4_PKT))
+		IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+		"PPPOE should not be checked with IPvX field together, invalid field_bm(0x%x)\n",
+		cap->cap_field_bm);
+
+	/* check ARP with IPvX */
+	if (cap->cap_field_bm & TPM_MATCH_ARP_TRGT_IP_ADDR)
+		if ((cap->cap_field_bm & ~TPM_MATCH_ARP_TRGT_IP_ADDR) >= TPM_MATCH_IPV4_PKT)
+			IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			   "ARP should not be checked with IPvX field together, invalid field_bm(0x%x)\n",
+			   cap->cap_field_bm);
+
+	/* check IPvX */
+	if (cap->cap_field_bm >= TPM_MATCH_IPV4_PKT) {
+		if (cap->cap_field_bm & TPM_MATCH_ARP_TRGT_IP_ADDR) {
+			;/* ARP has been checked */
+		} else if ((cap->cap_field_bm & TPM_MATCH_IPV6_FLBL)
+			  || (cap->cap_field_bm & TPM_MATCH_IPV6_PREF)
+			  || (cap->cap_field_bm & TPM_MATCH_IPV6_SUFF)) {
+			if (cap->cap_field_bm & TPM_MATCH_IPV4_PKT)
+				IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+				   "IPV6_FLBL, IPV6_PREF and IPV6_SUFF should not be checked with IPv4,"
+				   " invalid field_bm(0x%x)\n", cap->cap_field_bm);
+		} else if (!(cap->cap_field_bm & TPM_MATCH_IPV4_PKT)
+			    && !(cap->cap_field_bm & TPM_MATCH_IPV6_PKT)) {
+			IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			   "IPV4 or IPV6 should be set with TPM_MATCH_IPV4_PKT/TPM_MATCH_IPV6_PKT,"
+			   " invalid field_bm(0x%x)\n", cap->cap_field_bm);
+		} else if ((cap->cap_field_bm & TPM_MATCH_IPV4_PKT)
+			  && (cap->cap_field_bm & TPM_MATCH_IPV6_PKT))
+			IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			   "IPV4 and IPV6 should not be set together,"
+			   " invalid field_bm(0x%x)\n", cap->cap_field_bm);
+	}
+
+	/* CnM Check for Cap */
+
+	/* Check CnM is supported or not */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* If CnM not supported, return OK */
+	if (cnm_support == TPM_CNM_SUPPORTED && cap->cap_api_type == TPM_API_PUBLIC_CLS) {
+		if (!(cap->cap_field_bm & (TPM_MATCH_VID_OUTER |
+					   TPM_MATCH_PBITS_OUTER |
+					   TPM_MATCH_VID_INNER |
+					   TPM_MATCH_PBITS_INNER))) {
+			if (cap->vlan_num == TPM_ANY_VLAN)
+				IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			   "CnM supported, Cap must indicate tag info of pkt with vlan_num or VLAN related fields\n");
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_add
+*
+* DESCRIPTION: The routine add all the user cap configuration
+*
+* INPUTS:
+*           cap_arr
+*           arr_len
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_add(struct tpm_db_mng_cap_conf_t cap_arr[],
+			   int                     arr_len)
+{
+	/* add public L3, L2 caps */
+	int loop;
+	int db_ret;
+	int tpm_ret;
+	int cls_pri;
+	int lu_type_c2 = TPM_MNG_PRI_LU_TYPE_C2_LAST;
+	int lu_type_c3 = TPM_MNG_PRI_LU_TYPE_C3_LAST;
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr;
+	enum tpm_engine_no_t engine;
+	int lu_type;
+	int flow_match_num = 0;
+
+	IF_NULL(TPM_MNG_MOD, cap_arr);
+
+	for (loop = 0; loop < arr_len; loop++) {
+
+		/* check field bm first */
+		tpm_ret = tpm_mng_cap_check(&cap_arr[loop]);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "capability field bm invalid\n");
+
+		/* check if should be in C2 or C3 */
+		tpm_ret = tpm_mng_engine_get(cap_arr[loop].cap_field_bm, &engine);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get engine No failed\n");
+
+		if (TPM_ENGINE_C2 == engine)
+			lu_type = (++lu_type_c2);
+		else
+			lu_type = (++lu_type_c3);
+
+		/* keep how many flows this cap matches, if 0 return error */
+		flow_match_num = 0;
+
+		for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+			tpm_ret = tpm_mng_cap_match_flow(&cap_arr[loop], flow_id);
+			if (!tpm_ret)
+				continue;
+
+			flow_match_num++;
+
+			TPM_MEMSET_ZERO(flow_cap_arr);
+			flow_cap_arr.flow_log_id = flow_id ;
+
+			flow_cap_arr.eng_no = engine;
+			flow_cap_arr.lu_type = lu_type;
+
+			db_ret = tpm_db_mng_next_cls_pri_get(flow_id, &cls_pri);
+			IF_ERROR_STR(TPM_MNG_MOD, db_ret, "get cls pri failed\n");
+
+			flow_cap_arr.cls_pri = cls_pri;
+			flow_cap_arr.vlan_num = cap_arr[loop].vlan_num;
+			flow_cap_arr.cap_api_type = cap_arr[loop].cap_api_type;
+			flow_cap_arr.cap_field_bm = cap_arr[loop].cap_field_bm;
+			flow_cap_arr.c2_key_bm = cap_arr[loop].cap_field_bm;
+			flow_cap_arr.rule_type = cap_arr[loop].rule_type;
+
+			db_ret = tpm_db_mng_flow_cap_add(&flow_cap_arr);
+			IF_ERROR_STR(TPM_MNG_MOD, db_ret, "add flow_cap entry failed\n");
+
+		}
+
+		if (0 == flow_match_num) {
+			TPM_OS_ERROR(TPM_MNG_MOD,
+			"cap not match any flowId, could not be added, rule_type(%d), field_bm(0x%x), vlan_num(%d)\n",
+			cap_arr[loop].rule_type, cap_arr[loop].cap_field_bm,
+			cap_arr[loop].vlan_num)
+			return TPM_INIT_ERROR;
+		}
+	}
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mng_cap_merge_flow
+*
+* DESCRIPTION: The routine handles cap merge in one flow
+*
+* INPUTS:
+*	cap_num
+*	cap_arr_in: cap list before merge
+*
+* OUTPUTS:
+*	cap_arr_out: cap list after merge
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_merge_flow(
+	int cap_num,
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr_in,
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr_out)
+{
+	int loop;
+	int loop_in;
+	int loop_in_in;
+	int tpm_ret;
+	int c2_pri;
+	int cls_pri;
+	int field_bm;
+	enum tpm_engine_no_t eng_no;
+
+	IF_NULL(TPM_MNG_MOD, cap_arr_in);
+	IF_NULL(TPM_MNG_MOD, cap_arr_out);
+
+	memcpy(cap_arr_out, cap_arr_in, cap_num * sizeof(struct tpm_db_mng_flow_cap_conf_t));
+
+	/* go through caps, not start with CPU queue */
+	loop = 1;
+	while (loop < cap_num) {
+		/* if it is not C2 cap, or is not CLS cap, or this cap does not have field_bm, could not be merged */
+		if ((cap_arr_in[loop].eng_no != TPM_ENGINE_C2)
+		     || (cap_arr_in[loop].cap_api_type != TPM_API_PUBLIC_CLS)
+		     || (cap_arr_in[loop].cap_field_bm == 0)) {
+			loop++;
+			continue;
+		}
+
+		loop_in = loop + 1;
+		field_bm = cap_arr_in[loop].cap_field_bm;
+		c2_pri = cap_arr_in[loop].c2_pri;
+		cls_pri = cap_arr_in[loop].cls_pri;
+		while (loop_in < cap_num) {
+			/* if it is not C2 cap, or is not CLS cap, or does not have field_bm, could not be merged */
+			if ((cap_arr_in[loop_in].eng_no != TPM_ENGINE_C2)
+			     || (cap_arr_in[loop].cap_api_type != TPM_API_PUBLIC_CLS)
+			     || (cap_arr_in[loop_in].cap_field_bm == 0))
+				break;
+
+			/* if field_bm is 0, could not be merged, since it always hit */
+			if (!cap_arr_in[loop_in].cap_field_bm)
+				break;
+
+			/* no more than 4 fields in one cap */
+			if (int_bitmap_num_get((field_bm | cap_arr_in[loop_in].cap_field_bm)) > TPM_MNG_MAX_FIELD_NUM)
+				break;
+
+			tpm_ret = tpm_mng_engine_get((field_bm | cap_arr_in[loop_in].cap_field_bm), &eng_no);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get engine No failed\n");
+			if (eng_no != TPM_ENGINE_C2)
+				break;
+
+			field_bm |= cap_arr_in[loop_in].cap_field_bm;
+			loop_in++;
+		}
+
+		if (loop_in != (loop + 1))
+			cap_arr_out[loop].c2_key_bm = field_bm;
+
+		for (loop_in_in = (loop + 1); loop_in_in < loop_in; loop_in_in++) {
+			/* update DB */
+			cap_arr_out[loop_in_in].c2_key_bm = field_bm;
+			cap_arr_out[loop_in_in].c2_pri = (++c2_pri);
+			cap_arr_out[loop_in_in].cls_pri = cls_pri;
+			cap_arr_out[loop_in_in].lu_type = cap_arr_out[loop].lu_type;
+		}
+		loop = loop_in;
+	}
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_cap_c2_lu_type_reassign
+*
+* DESCRIPTION: The routine reassign c2_lu_type value
+*
+* INPUTS:
+*           cap
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_c2_lu_type_reassign(struct tpm_db_mng_flow_cap_conf_t *cap)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_db_mng_flow_cap_conf_t cap_tmp;
+	struct tpm_mng_reassigned_lu_type_t reassigned_lu_type[TPM_MNG_FLOW_ID_MAX];
+	int reassigned_lu_type_num = 0;
+	unsigned char new_lu_type;
+	int cur_lu_type;
+	int loop;
+	int loop_in;
+	int loop_reassign;
+	int tpm_ret;
+	int cap_num;
+
+	TPM_MEMSET_ZERO(reassigned_lu_type);
+
+	/* for the caps with the same lu_type, but different C2_key_bm, reassign lu_type to it */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		TPM_MEMSET_ZERO(cap_arr);
+
+		/* get all the caps in this flow */
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		for (loop = 0; loop < cap_num; loop++) {
+			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
+				continue;
+
+			if (cap_arr[loop].c2_pri != 0)
+				continue;
+
+			if ((cap_arr[loop].cap_field_bm == cap->cap_field_bm)
+			     && (cap_arr[loop].lu_type == cap->lu_type)
+			     && (cap_arr[loop].cap_api_type == cap->cap_api_type)
+			     && (cap_arr[loop].c2_key_bm != cap->c2_key_bm)) {
+
+				/* if this lu_type has been reassigned */
+				for (loop_reassign = 0; loop_reassign < reassigned_lu_type_num; loop_reassign++)
+					if (cap_arr[loop].c2_key_bm == reassigned_lu_type[loop_reassign].c2_key_bm) {
+						new_lu_type = reassigned_lu_type[loop_reassign].new_lu_type;
+						break;
+					}
+
+				/* this one need to be reassigned */
+				if (loop_reassign == reassigned_lu_type_num) {
+					tpm_ret = tpm_db_mng_free_c2_lu_type_get(&new_lu_type);
+					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get free C2 lu_type failed\n");
+				}
+				loop_in = loop;
+				cur_lu_type = cap_arr[loop].lu_type;
+				while ((cap_arr[loop_in].eng_no == TPM_ENGINE_C2)
+					&& (cur_lu_type == cap_arr[loop_in].lu_type)) {
+					memcpy(&cap_tmp, &cap_arr[loop_in], sizeof(cap_tmp));
+					cap_tmp.lu_type = new_lu_type;
+					tpm_ret = tpm_db_mng_flow_cap_update(&cap_arr[loop_in], &cap_tmp);
+					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "update CAP fail, flow_id(%d)\n", flow_id);
+					loop_in++;
+				}
+
+				/* keep the reassigned lu_type */
+				reassigned_lu_type[reassigned_lu_type_num].c2_key_bm = cap_arr[loop].c2_key_bm;
+				reassigned_lu_type[reassigned_lu_type_num].new_lu_type = new_lu_type;
+				reassigned_lu_type_num++;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_merge
+*
+* DESCRIPTION: The routine merge several caps into one, to save CLS hit
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_merge(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_cap_conf_t cap_l3_tmp;
+	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	struct tpm_db_mng_flow_cap_conf_t *cap_arr_tmp;
+	int loop;
+	int tpm_ret;
+	int cap_num;
+
+	TPM_MEMSET_ZERO(g_flow_cap_arr);
+	TPM_MEMSET_ZERO(cap_l3_tmp);
+	cap_arr_tmp = g_flow_cap_arr;
+
+	/* mark temp l3 cap to keep all L3 flows from cap merge */
+	cap_l3_tmp.cap_field_bm = TPM_MATCH_IPV4_PKT;
+
+	/* go through flow_cap_conf */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		TPM_MEMSET_ZERO(cap_arr);
+
+		/* do not merge Multicast/L3 cap, since there is not so many of them,
+		     and there are some default rules could not be merged.
+		  */
+		if ((TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON == flow_id)
+			|| (TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON == flow_id)
+			|| (TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON == flow_id)
+			|| (TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON == flow_id)
+			|| (tpm_mng_cap_match_l3_flow(&cap_l3_tmp, flow_id)))
+			continue;
+
+		/* get all the caps in this flow */
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+
+		tpm_ret = tpm_mng_cap_merge_flow(cap_num, cap_arr, cap_arr_tmp);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "merge CAPs failed for flow_id(%d)\n", flow_id);
+
+		for (loop = 0; loop < cap_num; loop++) {
+			tpm_ret = tpm_db_mng_flow_cap_update(&cap_arr[loop], &cap_arr_tmp[loop]);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "update CAPs failed for flow_id(%d)\n", flow_id);
+		}
+	}
+
+	/* set cntr for all C2 lu_type */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		TPM_MEMSET_ZERO(cap_arr);
+
+		/* get all the caps in this flow */
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		for (loop = 0; loop < cap_num; loop++) {
+			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
+				continue;
+
+			tpm_ret = tpm_db_mng_c2_lu_type_cntr_op(cap_arr[loop].lu_type, TPM_TRUE);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+				     "update cntr for C2 lu_type(%d) fail\n", cap_arr[loop].lu_type);
+		}
+	}
+
+	/* for the caps with the same lu_type, but different C2_key_bm, reassign lu_type to it */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		TPM_MEMSET_ZERO(cap_arr);
+
+		/* get all the caps in this flow */
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+		for (loop = 0; loop < cap_num; loop++) {
+			if (cap_arr[loop].eng_no != TPM_ENGINE_C2)
+				continue;
+
+			if (cap_arr[loop].c2_pri != 0)
+				continue;
+
+			tpm_ret = tpm_mng_cap_c2_lu_type_reassign(&cap_arr[loop]);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "not engough C2 lu_type resource\n");
+		}
+	}
+	return TPM_OK;
+}
+
+#ifndef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* tpm_mng_cpu_qhigh_cap_add
+*
+* DESCRIPTION: The routine add CPU Q high cap into all the flow_log_id
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cpu_qhigh_cap_add(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr;
+	int tpm_ret;
+	int  ipv6_enable;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	flow_cap_arr.cap_field_bm = 0;
+	flow_cap_arr.cap_api_type = TPM_API_PRIVATE_CPU_Q;
+	flow_cap_arr.cls_pri = TPM_MNG_CLS_PRI_CPU_Q;
+	flow_cap_arr.eng_no = TPM_ENGINE_C2;
+	flow_cap_arr.lu_type = TPM_MNG_PRI_LU_TYPE_C2_CPU_Q;
+	flow_cap_arr.c2_key_bm = 0;
+	flow_cap_arr.c2_pri = 0;
+	flow_cap_arr.vlan_num = TPM_ANY_VLAN;
+	flow_cap_arr.rule_type = 0;
+
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+			&& (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+		if (flow_id == TPM_MNG_FLOW_ID_LOOPBACK_PORT)
+			continue;
+		flow_cap_arr.flow_log_id = flow_id;
+		tpm_ret = tpm_db_mng_flow_cap_add(&flow_cap_arr);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP failed for flow_id(%d)\n", flow_id);
+	}
+	return TPM_OK;
+}
+#endif
+
+/*******************************************************************************
+* tpm_mng_cnm_pbit_asis_cap_add
+*
+* DESCRIPTION: The routine add CnM pbit keep as-is cap into all the flow_log_id
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cnm_pbit_asis_cap_add(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr;
+	int tpm_ret;
+	unsigned int cnm_support, ipv6_enable;
+
+	/* Check CnM is supported or not */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* If CnM not supported, return OK */
+	if (cnm_support == TPM_CNM_NOT_SUPPORTED)
+		return TPM_OK;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	flow_cap_arr.cap_field_bm = 0;
+	flow_cap_arr.cap_api_type = TPM_API_PRIVATE_CNM_PBIT;
+	flow_cap_arr.cls_pri = TPM_MNG_CLS_PRI_CNM_PBIT;
+	flow_cap_arr.eng_no = TPM_ENGINE_C2;
+	flow_cap_arr.lu_type = TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT;
+	flow_cap_arr.c2_key_bm = 0;
+	flow_cap_arr.c2_pri = 0;
+	flow_cap_arr.vlan_num = TPM_ANY_VLAN;
+	flow_cap_arr.rule_type = 0;
+
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		/* Only add for CLS Tag flow */
+		if (flow_id == TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON ||
+		    flow_id == TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON ||
+		    flow_id == TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON ||
+		    flow_id == TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON ||
+		    flow_id == TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON ||
+		    (ipv6_enable == TPM_IPV6_SUPPORTED && flow_id == TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON) ||
+		    (ipv6_enable == TPM_IPV6_SUPPORTED && flow_id == TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON)) {
+			flow_cap_arr.flow_log_id = flow_id;
+			tpm_ret = tpm_db_mng_flow_cap_add(&flow_cap_arr);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP failed for flow_id(%d)\n", flow_id);
+		}
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cnm_cap_add
+*
+* DESCRIPTION: The routine add CnM cap into all the flow_log_id
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cnm_cap_add(void)
+{
+	enum tpm_mng_flow_log_id_t flow_id;
+	struct tpm_db_mng_flow_cap_conf_t flow_cap_arr;
+	int tpm_ret;
+	int  ipv6_enable;
+	unsigned int cnm_support;
+
+	/* Check CnM is supported or not */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* If CnM not supported, return OK */
+	if (cnm_support == TPM_CNM_NOT_SUPPORTED)
+		return TPM_OK;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	flow_cap_arr.cap_field_bm = TPM_MNG_CNM_FIELD_BM;
+	flow_cap_arr.cap_api_type = TPM_API_PRIVATE_CNM;
+	flow_cap_arr.cls_pri = TPM_MNG_GEN_CLS_PRI_CNM;
+	flow_cap_arr.eng_no = TPM_ENGINE_C4;
+	flow_cap_arr.lu_type = 0;
+	flow_cap_arr.c2_key_bm = 0;
+	flow_cap_arr.c2_pri = 0;
+	flow_cap_arr.vlan_num = TPM_ANY_VLAN;
+	flow_cap_arr.rule_type = TPM_MNG_CNM_LU_TYPE;
+
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		     && (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+		/* only for non-MTM flow */
+		if (!tpm_mng_cnm_flow_check(flow_id))
+			continue;
+		flow_cap_arr.flow_log_id = flow_id;
+		tpm_ret = tpm_db_mng_flow_cap_add(&flow_cap_arr);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CnM CAP failed for flow_id(%d)\n", flow_id);
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_pri_cap_add
+*
+* DESCRIPTION: The routine add all private cap, except cpu queue high
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_pri_cap_add(void)
+{
+	int loop;
+	int loop_max = sizeof(tpm_mng_pri_cap_cfg) / sizeof(struct tpm_db_mng_flow_cap_conf_t);
+	int tpm_ret;
+	int  ipv6_enable;
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	for (loop = 0; loop < loop_max; loop++) {
+		if ((tpm_mng_pri_cap_cfg[loop].flow_log_id >= TPM_MNG_FLOW_ID_IPV6_START)
+			&& (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+
+		/* all private cap does not care vlan */
+		tpm_mng_pri_cap_cfg[loop].vlan_num = TPM_ANY_VLAN;
+
+		/* all private cap does not have rule_type */
+		tpm_mng_pri_cap_cfg[loop].rule_type = TPM_MNG_RULE_TYPE_INVALID;
+
+		tpm_mng_pri_cap_cfg[loop].c2_key_bm = tpm_mng_pri_cap_cfg[loop].cap_field_bm;
+		tpm_ret = tpm_db_mng_flow_cap_add(&tpm_mng_pri_cap_cfg[loop]);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP failed for cap num(%d)\n", loop);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_cap_add
+*
+* DESCRIPTION: The routine add all multicast cap supported.
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_cap_add(void)
+{
+	int tpm_ret;
+	int loop;
+	int loop_max;
+	unsigned int data_handle, ipv6_enable;
+	struct tpm_db_mng_flow_cap_conf_t *cap_tmp;
+
+	/* Check the handler mod of multicast packet, if not MC, no need to add cap */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	if (data_handle != TPM_HANDLER_MC)
+		return TPM_OK;
+
+	cap_tmp = tpm_mng_mc_pri_cap_cfg;
+	loop_max = sizeof(tpm_mng_mc_pri_cap_cfg) / sizeof(struct tpm_db_mng_flow_cap_conf_t);
+
+	/* Check IPV6 supported */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	/* Add MC cap */
+	for (loop = 0; loop < loop_max; loop++) {
+		if (TPM_IPV6_NOT_SUPPORTED == ipv6_enable) {
+			if (cap_tmp[loop].flow_log_id == TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON ||
+			    cap_tmp[loop].flow_log_id == TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON ||
+			    cap_tmp[loop].flow_log_id == TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON)
+				continue;
+		}
+		cap_tmp[loop].c2_key_bm = cap_tmp[loop].cap_field_bm;
+		tpm_ret = tpm_db_mng_flow_cap_add(&cap_tmp[loop]);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add MC CAP failed for cap num(%d)\n", loop);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_pkt_key_mask_check
+*
+* DESCRIPTION: The routine checks if input param has mask value
+*
+* INPUTS:
+*	       pMask:      pointer to the mask.
+*	       mask_len: mask length.
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_pkt_key_mask_check(
+	char *pMask,
+	char mask_len)
+{
+	int loop;
+
+	for (loop = 0; loop < mask_len; loop++)
+		if (pMask[loop] != BYTE_MASK)
+			return TPM_FAIL;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_c3_mask_check
+*
+* DESCRIPTION: The routine checks if API input param has mask value
+*
+* INPUTS:
+*	       match_key:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_c3_mask_check(
+	struct tpm_mng_pkt_key_t  *match_key)
+{
+	int ret;
+
+	if (match_key->pkt_key->field_match_bm & TPM_MATCH_ETH_DST) {
+		ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->eth_dst.eth_add_mask,
+						MAC_ADDR_SIZE);
+		IF_ERROR_STR(TPM_MNG_MOD, ret,
+			"this capability is in C3 engine, should not have non 0xff mask value in ETH_DST field\n");
+	}
+	if (match_key->pkt_key->field_match_bm & TPM_MATCH_ETH_SRC) {
+		ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->eth_src.eth_add_mask,
+						MAC_ADDR_SIZE);
+		IF_ERROR_STR(TPM_MNG_MOD, ret,
+			"this capability is in C3 engine, should not have non 0xff mask value in ETH_SRC field\n");
+	}
+	if (match_key->pkt_key->field_match_bm & TPM_MATCH_IPV4_PKT) {
+		if (match_key->pkt_key->field_match_bm & TPM_MATCH_IP_SRC) {
+			ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->ipvx_add.ip_src.ip_add_mask.ipv4,
+							IPV4_ADDR_SIZE);
+			IF_ERROR_STR(TPM_MNG_MOD, ret,
+				"this cap is in C3 engine, should not have non 0xff mask value in IP_SRC field\n");
+		}
+		if (match_key->pkt_key->field_match_bm & TPM_MATCH_IP_DST) {
+			ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv4,
+							IPV4_ADDR_SIZE);
+			IF_ERROR_STR(TPM_MNG_MOD, ret,
+			"this capability is in C3 engine, should not have non 0xff mask value in IP_DST field\n");
+		}
+	} else if (match_key->pkt_key->field_match_bm & TPM_MATCH_IPV6_PKT) {
+		if (match_key->pkt_key->field_match_bm & TPM_MATCH_IP_SRC) {
+			ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->ipvx_add.ip_src.ip_add_mask.ipv6,
+							IPV6_ADDR_SIZE);
+			IF_ERROR_STR(TPM_MNG_MOD, ret,
+				"this cap is in C3 engine, should not have non 0xff mask value in IP_SRC field\n");
+		}
+		if (match_key->pkt_key->field_match_bm & TPM_MATCH_IP_DST) {
+			ret = tpm_mng_pkt_key_mask_check(match_key->pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv6,
+							IPV6_ADDR_SIZE);
+			IF_ERROR_STR(TPM_MNG_MOD, ret,
+				"this cap is in C3 engine, should not have non 0xff mask value in IP_DST field\n");
+		}
+	}
+	if ((match_key->pkt_key->field_match_bm & TPM_MATCH_IP_DSCP)
+		    && (match_key->pkt_key->ipvx_add.dscp_mask != BYTE_MASK)) {
+		IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			"this capability is in C3 engine, should not have non 0xff mask value in DSCP field\n");
+	}
+	if ((match_key->pkt_key->field_match_bm & TPM_MATCH_IPV6_FLBL)
+		    && (match_key->pkt_key->ipvx_add.flow_label_mask != ~((unsigned int)0))) {
+		IF_ERROR_STR(TPM_MNG_MOD, TPM_BAD_PARAM,
+			"this capability is in C3 engine, should not have non 0xff mask value in IPV6_FLBL field\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_5t_key_build
+*
+* DESCRIPTION: The routine build mng key from exact_match API
+*
+* INPUTS:
+*	       gemport:
+*
+* OUTPUTS:
+*	       virt_port_id
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_5t_key_build(
+	struct tpm_pkt_key_t		*pkt_key,
+	struct tpm_qos_t		*qos,
+	struct tpm_exact_match_t	*exact_match)
+{
+	/* set qos table */
+	qos->qos_sel = TPM_QOS_NONE;
+
+	/* set src port */
+	memcpy(&pkt_key->port, &exact_match->port, sizeof(exact_match->port));
+
+	/* mapping pkt_key */
+	pkt_key->l4_dst = exact_match->ipvx_five_t.l4_dst;
+	pkt_key->l4_src = exact_match->ipvx_five_t.l4_src;
+	pkt_key->ipvx_add.ip_proto = exact_match->ipvx_five_t.l4_proto;
+	memcpy(&pkt_key->ipvx_add.ip_dst.ip_add,
+		&exact_match->ipvx_five_t.ip_dst,
+		sizeof(exact_match->ipvx_five_t.ip_dst));
+	memcpy(&pkt_key->ipvx_add.ip_src.ip_add,
+		&exact_match->ipvx_five_t.ip_src,
+		sizeof(exact_match->ipvx_five_t.ip_src));
+	TPM_MEMSET_FF(pkt_key->ipvx_add.ip_dst.ip_add_mask);
+	TPM_MEMSET_FF(pkt_key->ipvx_add.ip_src.ip_add_mask);
+
+	/* set parse_bm */
+	if (IPV4_VER == exact_match->ipvx_five_t.ip_ver)
+		pkt_key->field_match_bm = TPM_MATCH_IPV4_5T;
+	else if (IPV6_VER == exact_match->ipvx_five_t.ip_ver) {
+		pkt_key->field_match_bm = TPM_MATCH_IPV6_5T;
+	} else {
+		TPM_OS_ERROR(TPM_MNG_MOD, "invalid input IP version(%d)\n",
+			exact_match->ipvx_five_t.ip_ver);
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_virt_port_id_get
+*
+* DESCRIPTION: The routine get virt port id from gem_port
+*
+* INPUTS:
+*	       gemport:
+*
+* OUTPUTS:
+*	       virt_port_id
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_virt_port_id_get(
+	int           gemport,
+	int          *virt_port_id)
+{
+	int tpm_ret;
+
+	/* check if gemport already has a virt_port_id */
+	tpm_ret = tpm_db_mng_virt_pid_get(gemport, virt_port_id);
+	if (TPM_OK == tpm_ret)
+		return TPM_OK;
+
+	/* get new virt_port_id from db */
+	tpm_ret = tpm_db_mng_virt_pid_add(gemport, virt_port_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get virtual port number failed\n");
+
+	tpm_ret = mvPp2ClsHwVirtPortSet(*virt_port_id, gemport);
+	if (MV_OK != tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD,
+			"set virtual port number failed, virt_port_id(%d), gemport(%d), ret(%d)\n",
+			*virt_port_id, gemport, tpm_ret);
+		return TPM_NO_RESOURCE;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_action_clear_all
+*
+* DESCRIPTION: The routine clear all actions of C2 entry
+*
+* INPUTS:
+*	       action:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_action_clear_all(struct tpm_engine_pkt_action_t	*action)
+{
+	IF_NULL(TPM_MNG_MOD, action);
+
+	action->color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	action->pri_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->dscp_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->gemp_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->q_low_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->q_high_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->policer_act = TPM_ACTION_TYPE_NO_UPDT;
+	action->flowid_act = TPM_ACTION_FLOWID_DISABLE;
+	action->frwd_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_filter_first_rule_check
+*
+* DESCRIPTION: The routine checks if this is the first rule of the filter type
+*
+* INPUTS:
+*	       vlan_num:
+*	       match_key:
+*
+* OUTPUTS:
+*	       api_data_out: the first rule of this filter type
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+bool tpm_mng_filter_first_rule_check(
+	enum tpm_vlan_num_enum_t	vlan_num,
+	struct tpm_mng_pkt_key_t	*match_key,
+	struct tpm_db_mng_api_data_t	*api_data_out)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_db_mng_api_data_t *api_data_new = NULL;
+	enum tpm_vlan_num_enum_t vlan_num_loop;
+
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, api_data_out);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data_new);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "allocate api_data structure mem failed!\n");
+
+	/* go through api data, to check filter action */
+	tpm_ret = tpm_db_mng_api_entry_type_first_get(TPM_API_PUBLIC_FLTR, api_data_new);
+	while (TPM_OK == tpm_ret) {
+
+		memcpy(api_data, api_data_new, sizeof(struct tpm_db_mng_api_data_t));
+		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data_new);
+
+		if (match_key->pkt_key->field_match_bm != api_data->match_key.field_match_bm)
+			continue;
+
+		if (match_key->pkt_key->rule_type != api_data->match_key.rule_type)
+			continue;
+
+		/* need to check vlan_num also */
+		if (tpm_mng_vlan_num_get(&api_data->match_key, &vlan_num_loop)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "fail to get vlan num\n");
+			continue;
+		}
+
+		if (vlan_num_loop != vlan_num)
+			continue;
+
+		/* there has already been a filter rule */
+		memcpy(api_data_out, api_data, sizeof(struct tpm_db_mng_api_data_t));
+
+		/* release api data */
+		tpm_db_mng_api_data_release(api_data);
+		tpm_db_mng_api_data_release(api_data_new);
+		return TPM_FALSE;
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	tpm_db_mng_api_data_release(api_data_new);
+	return TPM_TRUE;
+}
+/*******************************************************************************
+* tpm_mng_filter_last_rule_check
+*
+* DESCRIPTION: The routine checks if this is the last rule of the filter type
+*
+* INPUTS:
+*	       api_data_in:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+bool tpm_mng_filter_last_rule_check(
+	struct tpm_db_mng_api_data_t *api_data_in)
+{
+	int tpm_ret = TPM_OK;
+	int filter_cnt = 0;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_db_mng_api_data_t *api_data_new = NULL;
+	enum tpm_vlan_num_enum_t vlan_num_in;
+	enum tpm_vlan_num_enum_t vlan_num;
+
+	IF_NULL(TPM_MNG_MOD, api_data_in);
+
+	/* check api_type first */
+	if (TPM_API_PUBLIC_FLTR != api_data_in->cap_api_type)
+		return TPM_FALSE;
+
+	/* get vlan_num */
+	tpm_ret = tpm_mng_vlan_num_get(&api_data_in->match_key, &vlan_num_in);
+	if (tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "fail to get vlan num, ret(%d)\n", tpm_ret);
+		return TPM_FALSE;
+	}
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data_new);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "allocate api_data structure mem failed!\n");
+
+	/* go through api data, to check filter action */
+	tpm_ret = tpm_db_mng_api_entry_type_first_get(TPM_API_PUBLIC_FLTR, api_data_new);
+	while (TPM_OK == tpm_ret) {
+
+		memcpy(api_data, api_data_new, sizeof(struct tpm_db_mng_api_data_t));
+		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data_new);
+
+		if (api_data_in->match_key.field_match_bm != api_data->match_key.field_match_bm)
+			continue;
+
+		if (api_data_in->match_key.rule_type != api_data->match_key.rule_type)
+			continue;
+
+		/* need to check vlan_num also */
+		if (tpm_mng_vlan_num_get(&api_data->match_key, &vlan_num)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "fail to get vlan num\n");
+			continue;
+		}
+
+		if (vlan_num != vlan_num_in)
+			continue;
+
+		/* there has already been a filter rule */
+		filter_cnt++;
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	tpm_db_mng_api_data_release(api_data_new);
+
+	if (filter_cnt <= 1)
+		/* this is the last rule */
+		return TPM_TRUE;
+	else
+		return TPM_FALSE;
+
+}
+
+/*******************************************************************************
+* tpm_mng_filter_def_c2_rule_create
+*
+* DESCRIPTION: The routine create a default C2 entry for filter type if necessary
+*
+* INPUTS:
+*	       eng_entry:
+*	       c2_entry:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_filter_def_c2_rule_create(
+	struct tpm_mng_eng_add_entry_t	*eng_entry,
+	struct tpm_c2_add_entry_t	*c2_entry)
+{
+	int tpm_ret;
+	int rule_id;
+	struct tpm_c2_add_entry_t	def_c2_entry;
+	struct tpm_db_mng_api_data_t	*api_data = NULL;
+
+	TPM_MEMSET_ZERO(def_c2_entry);
+	IF_NULL(TPM_MNG_MOD, eng_entry);
+	IF_NULL(TPM_MNG_MOD, c2_entry);
+
+	/* this is the first rule of the filter type, create c2 default rule */
+	memcpy(&def_c2_entry, c2_entry, sizeof(def_c2_entry));
+	def_c2_entry.priority++;
+
+	/* clear HEK */
+	def_c2_entry.field_bm = 0;
+	def_c2_entry.field_bm_mask = 0;
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_mng_filter_first_rule_check(eng_entry->vlan_num, eng_entry->match_key, api_data);
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	if (TPM_FALSE == tpm_ret)
+		/* this is not the first rule of the filter type */
+		return TPM_OK;
+
+	/* set default action */
+	if (eng_entry->action->dest.pp_port == TPM_PP_DROP) {
+		/* need do-nothing default rule */
+		tpm_ret = tpm_mng_action_clear_all(&def_c2_entry.action);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C2 entry actions failed\n");
+	} else {
+		/* need drop default rule */
+		def_c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+	}
+
+	/* if src port is UNI/GEM, default rule does not check src port */
+	if ((TPM_SRC_PORT_TYPE_UNI == def_c2_entry.port.port_type)
+	     || (TPM_SRC_PORT_TYPE_VIR == def_c2_entry.port.port_type))
+		def_c2_entry.port.port_mask = 0;
+
+	tpm_ret = tpm_c2_rule_add(&def_c2_entry, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "add filter default C2 entry failed\n");
+
+	tpm_ret = tpm_db_mng_flt_def_rule_set(eng_entry->cap->rule_type, eng_entry->cap->cap_field_bm,
+				eng_entry->cap->vlan_num, rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set filter default C2 entry rule_id in DB failed\n");
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_filter_def_c2_rule_delete
+*
+* DESCRIPTION: The routine delete default C2 entry for filter type if necessary
+*
+* INPUTS:
+*	       eng_entry:
+*	       c2_entry:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_filter_def_c2_rule_delete(
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int tpm_ret;
+	int rule_id;
+	enum tpm_vlan_num_enum_t	vlan_num;
+
+	IF_NULL(TPM_MNG_MOD, api_data);
+
+	if (!tpm_mng_filter_last_rule_check(api_data))
+		return TPM_OK;
+
+	/* get vlan_num */
+	tpm_ret = tpm_mng_vlan_num_get(&api_data->match_key, &vlan_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to get vlan num, ret(%d)\n", tpm_ret);
+
+	/* get rule_id */
+	tpm_ret = tpm_db_mng_flt_def_rule_get(api_data->match_key.rule_type,
+			api_data->match_key.field_match_bm,
+			vlan_num,
+			&rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get filter default C2 entry failed\n");
+
+	tpm_ret = tpm_c2_rule_del(rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "remove filter default C2 entry failed\n");
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_filter_def_c3_rule_create
+*
+* DESCRIPTION: The routine create a default c3 entry for filter type if necessary
+*
+* INPUTS:
+*	       eng_entry:
+*	       c3_entry:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_filter_def_c3_rule_create(
+	struct tpm_mng_eng_add_entry_t	*eng_entry,
+	struct tpm_c3_add_entry_t	*c3_entry)
+{
+	int tpm_ret;
+	int rule_id;
+	struct tpm_c3_add_entry_t	def_c3_entry;
+	struct tpm_db_mng_api_data_t	*api_data = NULL;
+
+	IF_NULL(TPM_MNG_MOD, eng_entry);
+	IF_NULL(TPM_MNG_MOD, c3_entry);
+	TPM_MEMSET_ZERO(def_c3_entry);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_mng_filter_first_rule_check(eng_entry->vlan_num, eng_entry->match_key, api_data);
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	if (TPM_FALSE == tpm_ret)
+		/* this is not the first rule of the filter type */
+		return TPM_OK;
+
+	/* this is the first rule of the filter type, create c3 default rule */
+	memcpy(&def_c3_entry, c3_entry, sizeof(def_c3_entry));
+
+	/* clear HEK */
+	/* set default action */
+	if (eng_entry->action->dest.pp_port == TPM_PP_DROP) {
+		/* need do-nothing default rule */
+		tpm_ret = tpm_mng_action_clear_all(&def_c3_entry.action);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all c3 entry actions failed\n");
+	} else {
+		/* need drop default rule */
+		def_c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+	}
+
+	tpm_ret = tpm_c3_default_rule_add(&def_c3_entry, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "add filter default c3 entry failed\n");
+
+	tpm_ret = tpm_db_mng_flt_def_rule_set(eng_entry->cap->rule_type, eng_entry->cap->cap_field_bm,
+				eng_entry->cap->vlan_num, rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set filter default c3 entry rule_id in DB failed\n");
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_filter_def_c3_rule_delete
+*
+* DESCRIPTION: The routine delete default c3 entry for filter type if necessary
+*
+* INPUTS:
+*	       eng_entry:
+*	       c3_entry:
+*
+* OUTPUTS:
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_filter_def_c3_rule_delete(
+	struct tpm_db_mng_api_data_t *api_data)
+{
+	int tpm_ret;
+	int rule_id;
+	enum tpm_vlan_num_enum_t	vlan_num;
+
+	if (!tpm_mng_filter_last_rule_check(api_data))
+		return TPM_OK;
+
+	/* get vlan_num */
+	tpm_ret = tpm_mng_vlan_num_get(&api_data->match_key, &vlan_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to get vlan num, ret(%d)\n", tpm_ret);
+
+	/* get rule_id */
+	tpm_ret = tpm_db_mng_flt_def_rule_get(api_data->match_key.rule_type,
+			api_data->match_key.field_match_bm,
+			vlan_num,
+			&rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get filter default c3 entry failed\n");
+
+	tpm_ret = tpm_c3_rule_del(rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "remove filter default c3 entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_c2_entry_add
+*
+* DESCRIPTION: The routine add C2 entry
+*
+* INPUTS:
+*              eng_entry: Engine entry para
+* OUTPUTS:
+*              rule_id: rule logical index
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static int tpm_mng_c2_entry_add(struct tpm_mng_eng_add_entry_t *eng_entry,
+				unsigned int                   *rule_id)
+{
+	struct tpm_c2_add_entry_t c2_entry;
+	enum tpm_qos_src_t	qos_src;
+	int tpm_ret;
+	int virt_port_id;
+	unsigned int cnm_support;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n");
+
+	/* Para Check */
+	IF_NULL(TPM_MNG_MOD, eng_entry);
+	IF_NULL(TPM_MNG_MOD, eng_entry->cap);
+	IF_NULL(TPM_MNG_MOD, eng_entry->match_key);
+	IF_NULL(TPM_MNG_MOD, eng_entry->action);
+	IF_NULL(TPM_MNG_MOD, eng_entry->pkt_mod);
+	IF_NULL(TPM_MNG_MOD, rule_id);
+
+	TPM_OS_DEBUG(TPM_C2_MOD, "port_type %d class_port %d lu_type %d c2_pri %d c2_key_bm 0x%x cap_field_bm 0x%x\n",
+			eng_entry->match_key->pkt_key->port.port_type,
+			eng_entry->match_key->pkt_key->port.class_port,
+			eng_entry->cap->lu_type,
+			eng_entry->cap->c2_pri,
+			eng_entry->cap->c2_key_bm,
+			eng_entry->cap->cap_field_bm);
+
+	/* Get CnM support flag */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	TPM_MEMSET_ZERO(c2_entry);
+	c2_entry.port.port_type = eng_entry->match_key->pkt_key->port.port_type;
+	/* src port */
+	if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_PP_PORT_BM) {
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC)
+			c2_entry.port.port_value |= TPM_SRC_PORT_PON;
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC0)
+			c2_entry.port.port_value |= TPM_SRC_PORT_G0;
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC1)
+			c2_entry.port.port_value |= TPM_SRC_PORT_G1;
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_LPBK)
+			c2_entry.port.port_value |= TPM_SRC_PORT_LPBK;
+	} else if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM) {
+		c2_entry.port.port_value = eng_entry->match_key->pkt_key->port.class_port;
+	} else {
+		/* get virtual port number */
+		tpm_ret = tpm_mng_virt_port_id_get(eng_entry->match_key->pkt_key->port.class_port, &virt_port_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get virtual port number failed\n");
+		c2_entry.port.port_value = virt_port_id;
+	}
+	c2_entry.port.port_mask = TPM_MNG_ALL_PORT_MASK;
+
+	c2_entry.lkp_type = eng_entry->cap->lu_type;
+	c2_entry.lkp_type_mask = TPM_MNG_ALL_LUTYPE_MASK;
+	c2_entry.priority = eng_entry->cap->c2_pri;
+	c2_entry.field_bm = eng_entry->cap->c2_key_bm;
+	c2_entry.field_bm_mask = eng_entry->cap->cap_field_bm;
+	c2_entry.mng_pkt_key = eng_entry->match_key;
+
+	if (eng_entry->policer_id != TPM_POLICER_INVALID) {
+		c2_entry.qos_info.policer_id = eng_entry->policer_id;
+		c2_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	}
+	if (NULL == eng_entry->qos || eng_entry->qos->qos_sel == TPM_QOS_NONE) {
+		qos_src = TPM_QOS_SRC_ACTION_TBL;
+
+		/* Set Pbit update if need to modify, temp only for CnM */
+		if (cnm_support == TPM_CNM_SUPPORTED &&
+		    (!(eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC)) &&
+		    (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE ||
+		     eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE))
+			c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	} else {
+		qos_src = TPM_QOS_SRC_DSCP_PBIT_TBL;
+		c2_entry.qos_info.qos_tbl_index = eng_entry->qos->qos_tbl;
+		if (eng_entry->qos->qos_sel == TPM_QOS_DSCP)
+			c2_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_DSCP;
+		else
+			c2_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_PRI;
+
+		c2_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry.action.dscp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		/* CnM pbit as-is lookup type only update pbit, not lock */
+		if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
+			c2_entry.action.gemp_act = TPM_ACTION_TYPE_NO_UPDT;
+			c2_entry.action.pri_act = TPM_ACTION_TYPE_UPDT;
+			c2_entry.action.dscp_act = TPM_ACTION_TYPE_NO_UPDT;
+		}
+	}
+
+	if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
+		c2_entry.action.q_high_act = TPM_ACTION_TYPE_NO_UPDT;
+		c2_entry.action.q_low_act = TPM_ACTION_TYPE_NO_UPDT;
+	} else {
+		c2_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c2_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	}
+
+	c2_entry.qos_info.pri_dscp_src = qos_src;
+	c2_entry.qos_info.gemport_src = qos_src;
+	c2_entry.qos_info.q_low_src = qos_src;
+	c2_entry.qos_info.q_high_src = qos_src;
+	c2_entry.qos_info.color_src = qos_src;
+
+	c2_entry.qos_value.pri = 0;
+	c2_entry.qos_value.dscp = 0;
+	c2_entry.qos_value.q_low = eng_entry->action->dest.pp_queue;
+
+	/* Set Pbit update if need to modify, temp only for CnM */
+	if (cnm_support == TPM_CNM_SUPPORTED &&
+	    (!(eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC))) {
+		if (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE)
+			c2_entry.qos_value.pri = eng_entry->action->mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE);
+		else if (eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE)
+			c2_entry.qos_value.pri = eng_entry->action->mod.vlan_op.inn_vlan.pbit & (~TPM_PBIT_UPDATE);
+	}
+
+	if (TPM_PP_DROP == eng_entry->action->dest.pp_port)
+		c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+	else if (TPM_PP_CPU == eng_entry->action->dest.pp_port) {
+		/* for filter rule, do not set HWF */
+		if (eng_entry->cap->cap_api_type != TPM_API_PUBLIC_FLTR) {
+			c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF_LOCK;
+			c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK;
+			c2_entry.qos_value.q_high = tpm_mng_cpu_queue_high_get(&eng_entry->match_key->pkt_key->port);
+			if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_LPBK) {
+				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_G0)
+					c2_entry.qos_value.q_high = TPM_RXQ_QH_GMAC0;
+				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_G1)
+					c2_entry.qos_value.q_high = TPM_RXQ_QH_GMAC1;
+				if ((eng_entry->match_key->mh & eng_entry->match_key->mh_mask) == TPM_PME_LPBK_MH_PON)
+					c2_entry.qos_value.q_high = TPM_RXQ_QH_PON;
+			}
+		} else {
+			tpm_ret = tpm_mng_action_clear_all(&c2_entry.action);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C3 entry actions failed\n");
+		}
+	} else {
+		c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+		c2_entry.action.color_act = ((eng_entry->action->color == TPM_COL_GREEN) ?
+					     TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK : TPM_COLOR_ACTION_TYPE_YELLOW);
+		/* Special handle CnM pbit as-is rule */
+		if (TPM_MNG_PRI_LU_TYPE_C2_CNM_PBIT == eng_entry->cap->lu_type) {
+			c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+			c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+		}
+		if (TPM_PP_PMAC == eng_entry->action->dest.pp_port) {
+			if (eng_entry->action->dest.port_id & TPM_PORTID_SPEC) {
+				c2_entry.qos_value.gemp = (eng_entry->action->dest.port_id & (~TPM_PORTID_SPEC));
+				c2_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+			}
+			c2_entry.qos_value.q_high = eng_entry->action->dest.pon_tx;
+		} else
+			c2_entry.qos_value.q_high = eng_entry->action->dest.pp_port + TPM_MNG_DST_PORT_G0_START;
+	}
+
+	/* Modification info */
+	memcpy(&c2_entry.pkt_mod, eng_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+
+	/* Duplication info */
+	memcpy(&c2_entry.flow_info, eng_entry->dup_info, sizeof(struct tpm_duplicate_t));
+
+	if (eng_entry->cap->cap_api_type == TPM_API_PRIVATE_CPU_Q) {
+		c2_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF;
+		c2_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT;
+		c2_entry.action.q_low_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+		c2_entry.qos_value.q_low = 0;
+		c2_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	} else if (eng_entry->cap->cap_api_type == TPM_API_PUBLIC_FLTR) {
+		/* create default rule if it is the first filter rule of this type */
+		tpm_ret = tpm_mng_filter_def_c2_rule_create(eng_entry, &c2_entry);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C2 entry actions failed\n");
+	}
+
+	tpm_ret = tpm_c2_rule_add(&c2_entry, rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "add C2 entry failed\n");
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_c3_entry_add
+*
+* DESCRIPTION: The routine add C3 entry
+*
+* INPUTS:
+*              eng_entry: Engine entry para
+* OUTPUTS:
+*              rule_id: rule logical index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+static int tpm_mng_c3_entry_add(struct tpm_mng_eng_add_entry_t *eng_entry,
+				unsigned int                   *rule_id)
+{
+	struct tpm_c3_add_entry_t c3_entry;
+	enum tpm_qos_src_t	qos_src;
+	int tpm_ret;
+	int virt_port_id;
+	unsigned int cnm_support;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+
+	/* Para Check */
+	IF_NULL(TPM_MNG_MOD, eng_entry);
+	IF_NULL(TPM_MNG_MOD, eng_entry->cap);
+	IF_NULL(TPM_MNG_MOD, eng_entry->match_key);
+	IF_NULL(TPM_MNG_MOD, eng_entry->action);
+	IF_NULL(TPM_MNG_MOD, eng_entry->pkt_mod);
+	IF_NULL(TPM_MNG_MOD, rule_id);
+
+	/* Get CnM support flag */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.port.port_type = eng_entry->match_key->pkt_key->port.port_type;
+
+	/* src port */
+	if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_PP_PORT_BM) {
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_PMAC)
+			c3_entry.port.port_value |= TPM_SRC_PORT_PON;
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC0)
+			c3_entry.port.port_value |= TPM_SRC_PORT_G0;
+		if (eng_entry->match_key->pkt_key->port.class_port & TPM_PP_GMAC1)
+			c3_entry.port.port_value |= TPM_SRC_PORT_G1;
+	} else if (eng_entry->match_key->pkt_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM) {
+		c3_entry.port.port_value = eng_entry->match_key->pkt_key->port.class_port;
+	} else {
+		/* get virtual port number */
+		tpm_ret = tpm_mng_virt_port_id_get(eng_entry->match_key->pkt_key->port.class_port, &virt_port_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get virtual port number failed\n");
+		c3_entry.port.port_value = virt_port_id;
+	}
+	c3_entry.port.port_mask = TPM_MNG_ALL_PORT_MASK;
+
+	c3_entry.lkp_type = eng_entry->cap->lu_type;
+	c3_entry.mng_pkt_key = eng_entry->match_key;
+
+	if (eng_entry->policer_id != TPM_POLICER_INVALID) {
+		c3_entry.qos_info.policer_id = eng_entry->policer_id;
+		c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	}
+	if (NULL == eng_entry->qos || eng_entry->qos->qos_sel == TPM_QOS_NONE) {
+		qos_src = TPM_QOS_SRC_ACTION_TBL;
+
+		/* Set Pbit update if need to modify, temp only for CnM */
+		if (cnm_support == TPM_CNM_SUPPORTED &&
+		    (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE ||
+		     eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE))
+			c3_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	} else {
+		qos_src = TPM_QOS_SRC_DSCP_PBIT_TBL;
+		c3_entry.qos_info.qos_tbl_index = eng_entry->qos->qos_tbl;
+		if (eng_entry->qos->qos_sel == TPM_QOS_DSCP)
+			c3_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_DSCP;
+		else
+			c3_entry.qos_info.qos_tbl_type = TPM_QOS_TBL_TYPE_PRI;
+
+		c3_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c3_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c3_entry.action.dscp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	}
+
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+
+	c3_entry.qos_info.pri_dscp_src = qos_src;
+	c3_entry.qos_info.gemport_src = qos_src;
+	c3_entry.qos_info.q_low_src = qos_src;
+	c3_entry.qos_info.q_high_src = qos_src;
+	c3_entry.qos_info.color_src = qos_src;
+
+	c3_entry.qos_value.pri = 0;
+	c3_entry.qos_value.dscp = 0;
+	c3_entry.qos_value.q_low = eng_entry->action->dest.pp_queue;
+
+	/* Set Pbit update if need to modify, temp only for CnM */
+	if (cnm_support == TPM_CNM_SUPPORTED) {
+		if (eng_entry->action->mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE)
+			c3_entry.qos_value.pri = eng_entry->action->mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE);
+		else if (eng_entry->action->mod.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE)
+			c3_entry.qos_value.pri = eng_entry->action->mod.vlan_op.inn_vlan.pbit & (~TPM_PBIT_UPDATE);
+	}
+
+	if (TPM_PP_DROP == eng_entry->action->dest.pp_port)
+		c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+	else if (TPM_PP_CPU == eng_entry->action->dest.pp_port) {
+		/* for filter rule, do not set HWF */
+		if (eng_entry->cap->cap_api_type != TPM_API_PUBLIC_FLTR) {
+			c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF_LOCK;
+			c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK;
+			c3_entry.qos_value.q_high = tpm_mng_cpu_queue_high_get(&eng_entry->match_key->pkt_key->port);
+		} else {
+			tpm_ret = tpm_mng_action_clear_all(&c3_entry.action);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C2 entry actions failed\n");
+		}
+	} else {
+		c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+		c3_entry.action.color_act = ((eng_entry->action->color == TPM_COL_GREEN) ?
+					     TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK : TPM_COLOR_ACTION_TYPE_YELLOW);
+		if (TPM_PP_PMAC == eng_entry->action->dest.pp_port) {
+			if (eng_entry->action->dest.port_id & TPM_PORTID_SPEC) {
+				c3_entry.qos_value.gemp = (eng_entry->action->dest.port_id & (~TPM_PORTID_SPEC));
+				c3_entry.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+			}
+			c3_entry.qos_value.q_high = eng_entry->action->dest.pon_tx;
+		} else
+			c3_entry.qos_value.q_high = eng_entry->action->dest.pp_port + TPM_MNG_DST_PORT_G0_START;
+	}
+
+	/* Modification info */
+	memcpy(&c3_entry.pkt_mod, eng_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+
+	/* Duplication info */
+	memcpy(&c3_entry.flow_info, eng_entry->dup_info, sizeof(struct tpm_duplicate_t));
+
+	if (eng_entry->cap->cap_api_type == TPM_API_PRIVATE_CPU_Q) {
+		c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF;
+		c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT;
+		c3_entry.action.q_low_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+		c3_entry.qos_value.q_low = 0;
+	} else if (eng_entry->cap->cap_api_type == TPM_API_PUBLIC_FLTR) {
+		/* create default rule if it is the first filter rule of this type */
+		tpm_ret = tpm_mng_filter_def_c3_rule_create(eng_entry, &c3_entry);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "clear all C2 entry actions failed\n");
+	}
+
+	tpm_ret = tpm_c3_rule_add(&c3_entry, rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "add C3 entry failed\n");
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mh_remove
+*
+* DESCRIPTION: judge whether the marvell header needs to be removed.
+*
+* INPUTS:
+*              port: action target pp port.
+* OUTPUTS:
+*
+* If the target pp port needs to remove marvell header,
+* the function returns true, otherwise returns false.
+*
+* COMMENTS:
+*******************************************************************************/
+static bool tpm_mng_mh_remove(enum tpm_pp_port_t pp_port)
+{
+	MV_U32			regVal;
+	enum prs_gmacs_enum	port;
+
+	switch (pp_port) {
+	case TPM_PP_PMAC:
+		return false;
+	case TPM_PP_GMAC0:
+		port = ENUM_GMAC_0;
+	case TPM_PP_GMAC1:
+		if (TPM_PP_GMAC1 == pp_port)
+			port = ENUM_GMAC_1;
+		regVal = mvPp2RdReg(MV_PP2_MH_REG(MV_PPV2_PORT_PHYS(port)));
+		/* check port MH enable */
+		if (regVal & MV_PP2_MH_EN_MASK)
+			return false;
+		else
+			return true;
+	default:
+		return false;
+	}
+
+}
+
+/*******************************************************************************
+* tpm_mng_mod_create
+*
+* DESCRIPTION: The routine create modification for rule.
+*
+* INPUTS:
+*              match_key: The packet fields to check, for mod, to check IP ver.
+*              act_num  : action number, including dst num and mod num.
+*              action   : Packet action array, from which modification data got
+*              qos_sel  : Qos source info
+* OUTPUTS:
+*              pkt_mod  : Array of Instr/Data pointer and L4 checksum update flag.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           Note: Only action[0] can take QoS from QoS table(pri/dscp table)
+*******************************************************************************/
+static int tpm_mng_mod_create(
+	struct tpm_mng_pkt_key_t    *match_key,
+	unsigned int                act_num,
+	struct tpm_pkt_action_t     *action,
+	enum tpm_qos_sel_t          qos_sel,
+	struct tpm_engine_pkt_mod_t *pkt_mod)
+{
+	int tpm_ret;
+	unsigned int ext_mod_bm;
+	struct tpm_pme_pkt_mod_t pme_mod_data[TPM_ACT_NUM_MAX];
+	enum tpm_gmac_conn_t gmac_con;
+	int i, j, k, act_idx;
+	unsigned char merge_mod[TPM_ACT_NUM_MAX][TPM_ACT_NUM_MAX];
+	bool mh_rem_1, mh_rem_2;
+
+	/* Parameter Check */
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, pkt_mod);
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MNG_MOD, qos_sel, TPM_QOS_NONE, TPM_QOS_PBIT);
+
+	TPM_MEMSET_FF(merge_mod);
+
+	for (act_idx = 0; act_idx < act_num; act_idx++) {
+		/* Update mod_bm */
+		ext_mod_bm = action[act_idx].mod.mod_bm;
+		if (ext_mod_bm) {
+			ext_mod_bm |= TPM_VLAN_MOD;
+			/* For mod except no_mod and pure VLAN mod, they are all based on DSCP */
+			if (ext_mod_bm & (~TPM_VLAN_MOD))
+				ext_mod_bm |= TPM_IP_DSCP_SET;
+		}
+
+		/* Clear pme_mod_data array and init */
+		TPM_MEMSET_ZERO(pme_mod_data[act_idx]);
+		/* Init pme_mod_data */
+		memcpy(&pme_mod_data[act_idx].mod_data, &action[act_idx].mod, sizeof(struct tpm_pkt_mod_t));
+
+		switch (action[act_idx].dest.pp_port) {
+		case TPM_PP_DROP:
+		case TPM_PP_CPU:
+			/* Drop or to CPU, no Mod, break directly */
+			break;
+		case TPM_PP_GMAC0:
+			/* Get GMAC Connect info */
+			tpm_ret = tpm_db_gmac_conn_get(TPM_ENUM_GMAC_0, &gmac_con);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC%d connect info get failed\n", TPM_ENUM_GMAC_0);
+		case TPM_PP_GMAC1:
+			if (action[act_idx].dest.pp_port == TPM_PP_GMAC1) {
+				/* Get GMAC Connect info */
+				tpm_ret = tpm_db_gmac_conn_get(TPM_ENUM_GMAC_1, &gmac_con);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC%d connect info get failed\n", TPM_ENUM_GMAC_1);
+			}
+			if (gmac_con == TPM_GMAC_CON_SWITCH_6 ||
+			    gmac_con == TPM_GMAC_CON_SWITCH_4) {
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_MH_T1_MOD;
+				/* UNI port */
+				if (TPM_PORTID_SPEC & action->dest.port_id) {
+						pme_mod_data[act_idx].mh_value =
+							(1 << (action[act_idx].dest.port_id & (~TPM_PORTID_SPEC)));
+				} else {
+					pme_mod_data[act_idx].mh_value = TPM_UNI_PORTS_BM;
+				}
+			} else if (gmac_con == TPM_GMAC_CON_GE_PHY) {
+#ifndef CONFIG_MV_ETH_PP2_1
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_MH_DEL;
+#else
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_MH_T1_MOD;
+#endif
+			} else {
+				tpm_ret = TPM_BAD_PARAM;
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC connection info NOT correct\n");
+			}
+			break;
+		case TPM_PP_PMAC:
+			pme_mod_data[act_idx].inter_mod_bm |= TPM_MH_T1_MOD;
+			/* Gemport */
+			pme_mod_data[act_idx].mh_value = (action[act_idx].dest.port_id & (~TPM_PORTID_SPEC));
+			break;
+		default:
+			tpm_ret = TPM_BAD_VALUE;
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid target port %d\n", action[act_idx].dest.pp_port);
+			break;
+		}
+
+		/* QoS Src */
+		if ((act_idx == TPM_ACT_IDX0) && (qos_sel != TPM_QOS_NONE)) {
+			pme_mod_data[act_idx].inter_mod_bm |= TPM_QOS_FROM_DESC;
+			/* Update inter mod_bm for PON */
+			if (action[act_idx].dest.pp_port == TPM_PP_PMAC) {
+				pme_mod_data[act_idx].inter_mod_bm &= (~TPM_MH_T1_MOD);
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_MH_T5_MOD;
+			} else if (0 == pme_mod_data[act_idx].mod_data.mod_bm) {
+				/* for DS external 0 mod_bm, do not set TPM_QOS_FROM_DESC
+				  * for US is OK, since gemport comes from qos table
+				  */
+				pme_mod_data[act_idx].inter_mod_bm &= (~TPM_QOS_FROM_DESC);
+			}
+		}
+		/* Check IPv4 or IPv6 */
+		if (match_key->pkt_key->field_match_bm & TPM_MATCH_IPV6_PKT) {
+			pme_mod_data[act_idx].inter_mod_bm |= TPM_MOD_PKT_IS_IP6;
+		} else {/* Default is IPV4 */
+			if (ext_mod_bm & TPM_IP_DSCP_SET ||
+			    ext_mod_bm & TPM_TTL_HOPL_DEC ||
+			    ext_mod_bm & TPM_IP_SRC_SET ||
+			    ext_mod_bm & TPM_IP_DST_SET)
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_IPV4_CHECK_MOD;
+			/* Gen L4 Checksum */
+			if (ext_mod_bm & TPM_L4_SRC_SET ||
+			    ext_mod_bm & TPM_L4_DST_SET) {
+				pkt_mod[act_idx].l4_chksum_update_flag = TPM_L4_CKSUM_GEN;
+				pme_mod_data[act_idx].inter_mod_bm |= TPM_L4_CHECK_MOD;
+			}
+		}
+	}
+
+	/* Mod merge to save PME resource */
+	for (act_idx = 0; act_idx < act_num; act_idx++) {
+		/* To CPU or Drop, no need modification */
+		if (action[act_idx].dest.pp_port == TPM_PP_DROP ||
+		    action[act_idx].dest.pp_port == TPM_PP_CPU)
+			continue;
+		/* Check the act_idx has been recorded in merge_mod or not */
+		for (j = 0; j < act_num; j++) {
+			for (k = 0 ; k < act_num; k++) {
+				if (merge_mod[j][k] == act_idx)
+					break;
+			}
+			if (k < act_num)
+				break;
+		}
+		if (j < act_num)
+			continue;
+
+		merge_mod[act_idx][0] = act_idx;
+
+		for (i = act_idx + 1; i < act_num; i++) {
+			mh_rem_1 = tpm_mng_mh_remove(action[act_idx].dest.pp_port);
+			mh_rem_2 = tpm_mng_mh_remove(action[i].dest.pp_port);
+			/* pme_mod_data completely same, share mod */
+			if (!memcmp(&pme_mod_data[act_idx], &pme_mod_data[i], sizeof(struct tpm_pme_pkt_mod_t)) &&
+				(mh_rem_1 == mh_rem_2)) {
+				merge_mod[act_idx][i] = i;
+			} else if (!memcmp(&pme_mod_data[act_idx].mod_data,
+					&pme_mod_data[i].mod_data,
+					sizeof(struct tpm_pkt_mod_t)) &&
+				(pme_mod_data[act_idx].inter_mod_bm == pme_mod_data[i].inter_mod_bm) &&
+				(action[act_idx].dest.pp_port != TPM_PP_PMAC) &&
+				(mh_rem_1 == mh_rem_2)) {
+				pme_mod_data[act_idx].mh_value |= pme_mod_data[i].mh_value;
+				merge_mod[act_idx][i] = i;
+			}
+		}
+	}
+	/* Debug Info */
+	if ((TPM_MNG_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) {
+		for (i = 0; i < act_num; i++) {
+			if (merge_mod[i][0] != 0xFF) {
+				TPM_OS_DEBUG(TPM_MNG_MOD, "Act[%d] share modification with\n", merge_mod[i][0]);
+				for (j = 1; j < act_num; j++) {
+					if (merge_mod[i][j] != 0xFF)
+						TPM_OS_DEBUG(TPM_MNG_MOD, "Act[%d]\n", merge_mod[i][j]);
+				}
+				TPM_OS_DEBUG(TPM_MNG_MOD, "\n");
+			}
+		}
+	}
+	/* Create Modification */
+	for (act_idx = 0; act_idx < act_num; act_idx++) {
+		if (merge_mod[act_idx][0] == 0xFF)
+			continue;
+
+		mh_rem_1 = tpm_mng_mh_remove(action[act_idx].dest.pp_port);
+		tpm_ret = tpm_pme_mod_create(&pme_mod_data[merge_mod[act_idx][0]],
+					     &pkt_mod[merge_mod[act_idx][0]].mod_cmd_idx,
+					     &pkt_mod[merge_mod[act_idx][0]].mod_data_idx,
+					     mh_rem_1);
+		if (tpm_ret != TPM_OK) {
+			/* Release Mod created before act_idx */
+			for (k = 0; k < act_idx; k++) {
+				if ((merge_mod[k][0] != 0xFF) && (pkt_mod[merge_mod[k][0]].mod_cmd_idx != 0)) {
+					if (tpm_pme_mod_release(pkt_mod[merge_mod[k][0]].mod_cmd_idx,
+								pkt_mod[merge_mod[k][0]].mod_data_idx)) {
+						TPM_OS_ERROR(TPM_MNG_MOD,
+							     "Mod Release fail, cmd_idx=%d, data_idx=%d\n",
+							     pkt_mod[merge_mod[k][0]].mod_cmd_idx,
+							     pkt_mod[merge_mod[k][0]].mod_data_idx);
+					}
+				}
+			}
+		}
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Act[%d], Mod create fail\n", merge_mod[act_idx][0]);
+		for (i = 1; i < act_num; i++) {
+			if (merge_mod[act_idx][i] != 0xFF) {
+				pkt_mod[merge_mod[act_idx][i]].mod_cmd_idx =
+					pkt_mod[merge_mod[act_idx][0]].mod_cmd_idx;
+				pkt_mod[merge_mod[act_idx][i]].mod_data_idx =
+					pkt_mod[merge_mod[act_idx][0]].mod_data_idx;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_add_cap_entry_check
+*
+* DESCRIPTION: The routine check api entry add params
+*
+* INPUTS:
+*	       match_key:	API entry adding input param
+*	       act_num:	API entry adding input param
+*	       action:	API entry adding input param
+*	       policer_id:	API entry adding input param
+*	       qos:		API entry adding input param
+*	       vlan_num:	vlan_num gets from the match_key
+*	       flow_cap:	all the flow caps that API entry belongs to
+* OUTPUTS:
+*	    NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_add_cap_entry_check(
+	struct tpm_mng_pkt_key_t  *match_key,
+	unsigned int              act_num,
+	struct tpm_pkt_action_t   *action,
+	unsigned short           policer_id,
+	struct tpm_qos_t          *qos,
+	enum tpm_vlan_num_enum_t  vlan_num,
+	struct tpm_db_mng_flow_cap_conf_t *flow_cap)
+{
+	int hit_num_allowed;
+	int hit_num_curr = 1;
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_db_mng_api_data_t *api_data_new = NULL;
+	enum tpm_class_port_type_t bigger_port_type;
+	enum tpm_class_port_type_t smaller_port_type;
+	enum tpm_plcr_entry_state_t state;
+	unsigned int smaller_port_bm;
+	int uni_num, act_idx;
+	enum tpm_mng_api_type_t   api_type;
+	enum tpm_gmac_conn_t gmac_con;
+	unsigned int uni_max_num = 0;
+
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, qos);
+	IF_NULL(TPM_MNG_MOD, match_key->pkt_key);
+
+	/* get api_type */
+	api_type = flow_cap->cap_api_type;
+
+	/* check policer_id */
+	if ((policer_id != TPM_POLICER_INVALID)
+	     && (policer_id > TPM_POLICER_ID_MAX)) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "Invalid policer_id(%d)!\n", policer_id);
+		return TPM_BAD_PARAM;
+	}
+	tpm_ret = tpm_plcr_entry_state_get(policer_id, &state);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get policer entry state failed\n");
+	if (state != TPM_PLCR_ENTRY_VALID_STATE) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "policer_id(%d) is invalid\n", policer_id);
+		return TPM_BAD_PARAM;
+	}
+
+	/* check qos table mode, and qos table index value */
+	if (qos->qos_sel != TPM_QOS_NONE) {
+		if (flow_cap->eng_no != TPM_ENGINE_C2) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "Qos table could only be used in C2 engine\n");
+			return TPM_BAD_PARAM;
+		}
+
+		tpm_ret = tpm_qos_tbl_state_check(qos->qos_sel, qos->qos_tbl);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "qos table has not been inited yet\n");
+	}
+
+	/* check src port */
+	if (match_key->pkt_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM) {
+		tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &uni_num);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get max uni port number failed\n");
+
+		if (match_key->pkt_key->port.class_port >= (1 << uni_num)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "Invalid src uni port(%d)!\n", match_key->pkt_key->port.class_port);
+			return TPM_BAD_PARAM;
+		}
+	} else if (match_key->pkt_key->port.port_type == TPM_CLASS_PP_PORT_BM) {
+		if ((match_key->pkt_key->port.class_port != TPM_PP_GMAC0)
+		     && (match_key->pkt_key->port.class_port != TPM_PP_GMAC1)
+		     && (match_key->pkt_key->port.class_port != TPM_PP_LPBK)
+		     && (match_key->pkt_key->port.class_port != TPM_PP_PMAC)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "Invalid src PHY port(%d)!\n", match_key->pkt_key->port.class_port);
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	/* Check action num */
+	if (!act_num || act_num > TPM_ACT_NUM_MAX) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "Invalid action number(%d)!\n", act_num);
+		return TPM_BAD_PARAM;
+	}
+	/* check dst port */
+	if ((api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+	     || (api_type == TPM_API_PUBLIC_FLTR)) {
+		if ((action[TPM_ACT_IDX0].dest.pp_port != TPM_PP_DROP)
+		     && (action[TPM_ACT_IDX0].dest.pp_port != TPM_PP_CPU)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "Invalid DST port(%d)!\n", action[TPM_ACT_IDX0].dest.pp_port);
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	/* Dest UNI check */
+	tpm_ret = tpm_db_gmac_conn_get(TPM_ENUM_GMAC_1, &gmac_con);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC1 connect info get failed\n");
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &uni_max_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get switch max uni num failed\n");
+
+	for (act_idx = 0; act_idx < act_num; act_idx++) {
+		if ((action[act_idx].dest.pp_port == TPM_PP_GMAC0 ||
+		     ((gmac_con == TPM_GMAC_CON_SWITCH_4) ? (action[act_idx].dest.pp_port == TPM_PP_GMAC1) : false)) &&
+		    (action[act_idx].dest.port_id & TPM_PORTID_SPEC)) {
+			if ((action[act_idx].dest.port_id & (~TPM_PORTID_SPEC)) >= uni_max_num) {
+				TPM_OS_ERROR(TPM_MNG_MOD, "Invalid DST UNI port(%d), max UNI(%d)!\n",
+					     (action[act_idx].dest.port_id & (~TPM_PORTID_SPEC)), (uni_max_num - 1));
+				return TPM_BAD_PARAM;
+			}
+		}
+	}
+
+	/* check Issue engine hit number for public cap */
+	if (api_type >= TPM_API_PRIVATE_START)
+		return TPM_OK;
+
+	tpm_ret = tpm_db_mng_cap_hit_num_get(api_type,
+		flow_cap->rule_type, match_key->pkt_key->field_match_bm,
+		flow_cap->vlan_num, &hit_num_allowed);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CAP hit number failed\n");
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data_new);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "allocate api_data structure mem failed!\n");
+
+	/* go through api data, to check the hit number */
+	tpm_ret = tpm_db_mng_api_entry_type_first_get(api_type, api_data_new);
+
+	while (TPM_OK == tpm_ret) {
+		memcpy(api_data, api_data_new, sizeof(struct tpm_db_mng_api_data_t));
+		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data_new);
+
+		if (match_key->pkt_key->field_match_bm != api_data->match_key.field_match_bm)
+			continue;
+
+		if (match_key->pkt_key->rule_type != api_data->match_key.rule_type)
+			continue;
+
+		if (match_key->pkt_key->port.port_type == api_data->match_key.port.port_type)
+			continue;
+
+		/* find the bigger port_type */
+		if (match_key->pkt_key->port.port_type > api_data->match_key.port.port_type) {
+			bigger_port_type = match_key->pkt_key->port.port_type;
+			smaller_port_type = api_data->match_key.port.port_type;
+			smaller_port_bm = api_data->match_key.port.class_port;
+		} else {
+			smaller_port_type = match_key->pkt_key->port.port_type;
+			bigger_port_type = api_data->match_key.port.port_type;
+			smaller_port_bm = match_key->pkt_key->port.class_port;
+		}
+		/* uni and vir can not be in the same flow */
+		if (smaller_port_type >= TPM_CLASS_SWITCH_PORT_BM)
+			continue;
+
+		/* smaller is PHY */
+		if ((smaller_port_bm & TPM_PP_PMAC) && (bigger_port_type == TPM_CLASS_VIRT_PORT)) {
+			hit_num_curr++;
+			break;
+		}
+		if ((smaller_port_bm & (TPM_PP_GMAC0 | TPM_PP_GMAC1)) &&
+		    (bigger_port_type == TPM_CLASS_SWITCH_PORT_BM)) {
+			hit_num_curr++;
+			break;
+		}
+
+		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data);
+	}
+
+	if (hit_num_curr > hit_num_allowed) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "issue engine hit number exceed, allowed(%d), current(%d)!\n",
+			hit_num_allowed, hit_num_curr);
+		/* release api data */
+		tpm_db_mng_api_data_release(api_data);
+		tpm_db_mng_api_data_release(api_data_new);
+		return TPM_BAD_PARAM;
+	}
+
+	if (TPM_API_PUBLIC_FLTR == api_type) {
+		/* go through api data, to check action of the first rule of this filter */
+		if (!tpm_mng_filter_first_rule_check(vlan_num, match_key, api_data))
+			if (api_data->action[TPM_ACT_IDX0].dest.pp_port != action[TPM_ACT_IDX0].dest.pp_port) {
+				TPM_OS_ERROR(TPM_MNG_MOD,
+					"same filter type should follow same frwd, current frwd(%d), input frwd(%d)!\n",
+					api_data_new->action[TPM_ACT_IDX0].dest.pp_port,
+					action[TPM_ACT_IDX0].dest.pp_port);
+				/* release api data */
+				tpm_db_mng_api_data_release(api_data);
+				tpm_db_mng_api_data_release(api_data_new);
+				return TPM_BAD_PARAM;
+			}
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	tpm_db_mng_api_data_release(api_data_new);
+
+	/* check pkt_key field mask value */
+	if ((flow_cap->eng_no == TPM_ENGINE_C3_A)
+	     || (flow_cap->eng_no == TPM_ENGINE_C3_B)) {
+		tpm_ret = tpm_mng_c3_mask_check(match_key);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+			"for C3 engine API rule, should not have any non 0xff mask value\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_log_idx_map_pkt_mod
+*
+* DESCRIPTION: The routine map API logic index to pkt_mod, including cmd_idx,
+* data_idx and L4_checksum update.
+*
+* INPUTS:
+*              logic_idx - API rule logic index
+* OUTPUTS:
+*              num_dest  - number of mod.
+*              pkt_mod   - mod info, contain cmd_idx, data_idx, and L4_checksum update
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_log_idx_map_pkt_mod(int logic_idx, unsigned int *num_dest, struct tpm_engine_pkt_mod_t pkt_mod[])
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_entry = NULL;
+
+	IF_NULL(TPM_MNG_MOD, num_dest);
+	IF_NULL(TPM_MNG_MOD, pkt_mod);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_entry);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* Search DB for logical index */
+	tpm_ret = tpm_db_mng_api_entry_get(logic_idx, api_entry);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_entry, "API DB data get failed\n");
+
+	/*copy pkt_mod */
+	memcpy(pkt_mod, api_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t) * TPM_ACT_NUM_MAX);
+	*num_dest = api_entry->num_dest;
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_entry);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_dup_cnt_calc
+*
+* DESCRIPTION: The routine calculate duplication count.
+*
+* INPUTS:
+*              act_num  : action number, including dst num and mod num.
+*              action   : Packet action array, from which modification data got.
+* OUTPUTS:
+*              dup_cnt  : Dup list indo, cnt and flow_id
+*              merge    : merge array indicates the action merge.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mng_dup_cnt_calc(
+	unsigned int                act_num,
+	struct tpm_pkt_action_t     *action,
+	unsigned int                *dup_cnt,
+	unsigned char               merge[][TPM_ACT_NUM_MAX])
+{
+	unsigned char merge_act[TPM_ACT_NUM_MAX][TPM_ACT_NUM_MAX];
+	int act_idx, i, j, k;
+	unsigned int dup_count = 0;
+
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, dup_cnt);
+	IF_NULL(TPM_MNG_MOD, merge);
+
+	TPM_MEMSET_FF(merge_act);
+
+	/* Action Merge, action[0] should be done in C2/3 engine, keep forever */
+	for (act_idx = 0; act_idx < act_num; act_idx++) {
+		for (j = 0; j < act_num; j++) {
+			for (k = 0; k < act_num; k++) {
+				if (merge_act[j][k] == act_idx)
+					break;
+			}
+			if (k < act_num)
+				break;
+		}
+		if (j < act_num)
+			continue;
+
+		merge_act[act_idx][0] = act_idx;
+
+		for (i = act_idx + 1; i <= act_num; i++) {
+			if (!memcmp(&action[act_idx], &action[i], sizeof(struct tpm_pkt_action_t))) {
+				merge_act[act_idx][i] = i;
+			} else if ((!memcmp(&action[act_idx].mod, &action[i].mod, sizeof(struct tpm_pkt_mod_t))) &&
+				(action[act_idx].color == action[i].color) &&
+				(action[act_idx].dest.pp_port == action[i].dest.pp_port &&
+				action[act_idx].dest.pon_tx == action[i].dest.pon_tx &&
+				action[act_idx].dest.pp_queue == action[i].dest.pp_queue &&
+				action[act_idx].dest.pp_port != TPM_PP_PMAC)) {
+				merge_act[act_idx][i] = i;
+			}
+		}
+	}
+
+	for (act_idx = 1; act_idx < act_num; act_idx++) {
+		if (merge_act[act_idx][0] != 0xFF)
+			dup_count++;
+	}
+
+	*dup_cnt = dup_count;
+
+	for (i = 0; i < TPM_ACT_NUM_MAX; i++) {
+		for (j = 0; j < TPM_ACT_NUM_MAX; j++)
+			merge[i][j] = merge_act[i][j];
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mct_entry_build
+*
+* DESCRIPTION: The routine bulid MC table entry with action array..
+*
+* INPUTS:
+*              src_port  : src port
+*              act_num   : action number
+*              action    : Packet action, from which modification data got.
+*              pkt_mod   : packet modification info.
+* OUTPUTS:
+*              mct_entry : MC table entry array
+*              dup_cnt   : The duplication node count needed.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mng_mct_entry_build(const struct tpm_class_port_t *src_port,
+				   unsigned int                act_num,
+				   struct tpm_pkt_action_t     *action,
+				   struct tpm_engine_pkt_mod_t *pkt_mod,
+				   struct tpm_mc_tbl_entry_t   *mct_entry,
+				   unsigned int                *dup_cnt)
+{
+	int tpm_ret;
+	unsigned int temp_cnt;
+	unsigned char merge_act[TPM_ACT_NUM_MAX][TPM_ACT_NUM_MAX];
+	int act_idx, k;
+
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, pkt_mod);
+	IF_NULL(TPM_MNG_MOD, mct_entry);
+
+	if (act_num == 0)
+		return TPM_OK;
+
+	tpm_ret = tpm_mng_dup_cnt_calc(act_num, action, dup_cnt, merge_act);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Dup count call fail\n");
+
+	temp_cnt = 0;
+
+	for (act_idx = 1; act_idx < act_num; act_idx++) {
+		if (merge_act[act_idx][0] != TPM_MNG_MERGE_INVALID) {
+			/* Convert action to MC table entry */
+			mct_entry[temp_cnt].action.queue |= action[merge_act[act_idx][0]].dest.pp_queue;
+			mct_entry[temp_cnt].action.frwd = TPM_MC_FRWD_TO_TX;
+			if (TPM_PP_PMAC == action[merge_act[act_idx][0]].dest.pp_port) {
+				if (action[merge_act[act_idx][0]].dest.port_id & TPM_PORTID_SPEC) {
+					mct_entry[temp_cnt].mct_mod.gem =
+						(action[merge_act[act_idx][0]].dest.port_id & (~TPM_PORTID_SPEC));
+					mct_entry[temp_cnt].mct_mod.gem_mod_en = TPM_MC_MOD_ENABLE;
+				}
+				mct_entry[temp_cnt].action.queue |=
+					(action[merge_act[act_idx][0]].dest.pon_tx << TPM_QUEUE_HIGH_SHIFT);
+			} else if (TPM_PP_CPU == action[merge_act[act_idx][0]].dest.pp_port) {
+				/* MC table to CPU through LB port */
+				mct_entry[temp_cnt].action.queue |= action[merge_act[act_idx][0]].dest.pp_queue;
+				mct_entry[temp_cnt].action.queue |= (TPM_TX_PORT_LPBK_IDX << TPM_QUEUE_HIGH_SHIFT);
+				mct_entry[temp_cnt].action.frwd = TPM_MC_FRWD_TO_TX;
+				if (src_port->port_type == TPM_CLASS_PP_PORT_BM) {
+					if (src_port->class_port == TPM_PP_GMAC0)
+						mct_entry[temp_cnt].mct_mod.pkt_mod.mod_cmd_idx =
+												TPM_PME_LPBK_GMAC0_IPTR;
+					if (src_port->class_port == TPM_PP_GMAC1)
+						mct_entry[temp_cnt].mct_mod.pkt_mod.mod_cmd_idx =
+												TPM_PME_LPBK_GMAC1_IPTR;
+					if (src_port->class_port == TPM_PP_PMAC)
+						mct_entry[temp_cnt].mct_mod.pkt_mod.mod_cmd_idx = TPM_PME_LPBK_PON_IPTR;
+				} else if (src_port->port_type == TPM_CLASS_SWITCH_PORT_BM) {
+					mct_entry[temp_cnt].mct_mod.pkt_mod.mod_cmd_idx = TPM_PME_LPBK_GMAC0_IPTR;
+				} else if (src_port->port_type == TPM_CLASS_VIRT_PORT) {
+					mct_entry[temp_cnt].mct_mod.pkt_mod.mod_cmd_idx = TPM_PME_LPBK_PON_IPTR;
+				}
+			} else if (TPM_PP_DROP == action[merge_act[act_idx][0]].dest.pp_port) {
+				continue;
+			} else {
+				mct_entry[temp_cnt].action.queue |=
+					((action[merge_act[act_idx][0]].dest.pp_port + TPM_MNG_DST_PORT_G0_START) <<
+					 TPM_QUEUE_HIGH_SHIFT);
+				/* Record port bitmap */
+				for (k = 0; k < act_num; k++) {
+					if (merge_act[act_idx][k] == TPM_MNG_MERGE_INVALID)
+						continue;
+					mct_entry[temp_cnt].action.port_id_bm |=
+					(1 << (action[merge_act[act_idx][k]].dest.port_id & (~TPM_PORTID_SPEC)));
+				}
+			}
+
+			/* Mod */
+			if (TPM_PP_CPU != action[merge_act[act_idx][0]].dest.pp_port) {
+				if (action[merge_act[act_idx][0]].mod.mod_bm & TPM_IP_DSCP_SET) {
+					mct_entry[temp_cnt].mct_mod.dscp_mod_en = TPM_MC_MOD_ENABLE;
+					mct_entry[temp_cnt].mct_mod.dscp = action[merge_act[act_idx][0]].mod.ipvx.dscp;
+				}
+				if (action[merge_act[act_idx][0]].mod.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE) {
+					mct_entry[temp_cnt].mct_mod.pri_mod_en = TPM_MC_MOD_ENABLE;
+					mct_entry[temp_cnt].mct_mod.pri =
+					action[merge_act[act_idx][0]].mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE);
+				}
+				memcpy(&mct_entry[temp_cnt].mct_mod.pkt_mod,
+				&pkt_mod[merge_act[act_idx][0]],
+				sizeof(struct tpm_engine_pkt_mod_t));
+			}
+
+			/* Record dup count*/
+			temp_cnt++;
+		}
+	}
+
+	if (temp_cnt != *dup_cnt) {
+		tpm_ret = TPM_BAD_VALUE;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Dup count mismatch\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_dup_create
+*
+* DESCRIPTION: The routine create dup list for rule.
+*
+* INPUTS:
+*              src_port : src port
+*              act_num  : action number, including dst num and mod num.
+*              action   : Packet action array, from which modification data got.
+*              pkt_mod  : Modification info array, DPTR and IPTR.
+* OUTPUTS:
+*              dup_info : Dup list indo, cnt and flow_id
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mng_dup_create(
+	const struct tpm_class_port_t *src_port,
+	unsigned int                act_num,
+	struct tpm_pkt_action_t     *action,
+	struct tpm_engine_pkt_mod_t *pkt_mod,
+	struct tpm_duplicate_t      *dup_info)
+{
+	int tpm_ret;
+	struct tpm_mc_tbl_entry_t mct_entry[TPM_ACT_NUM_MAX];
+	unsigned int flow_id = 0, dup_count = 0;
+
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, pkt_mod);
+	IF_NULL(TPM_MNG_MOD, dup_info);
+
+	TPM_MEMSET_ZERO(mct_entry);
+
+	/* Build MCT entry */
+	tpm_ret = tpm_mng_mct_entry_build(src_port, act_num, action, pkt_mod, mct_entry, &dup_count);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM MNG MCT entry build fail\n");
+	/* Create dup list */
+	tpm_ret = tpm_mc_dup_list_create(dup_count, mct_entry, &flow_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM Dup list Create failed\n");
+
+	/* Return dup info */
+	dup_info->flow_cnt = dup_count;
+	dup_info->flow_id = flow_id;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cap_entry_add
+*
+* DESCRIPTION: The routine add a API entry
+*
+* INPUTS:
+*              cap:
+*              please refer to tpm_c2_rule_add
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_entry_add(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_mng_pkt_key_t  *match_key,
+	unsigned int             act_num,
+	struct tpm_pkt_action_t   *action,
+	unsigned short           policer_id,
+	struct tpm_qos_t          *qos,
+	unsigned int            *rule_id)
+{
+	int tpm_ret;
+	int loop = 0;
+	int loop_in = 0;
+	int eng_index = 0;
+	struct tpm_mng_eng_add_entry_t eng_entry;
+	struct tpm_cls_fl_rule_entry_t *flow_rules;
+	struct tpm_cls_fl_rule_list_t *flow_rules_list = &g_tpm_mng_flow_rules;
+	enum tpm_mng_src_port_type_t src_port_cfg;
+	enum tpm_qos_sel_t	qos_sel;
+	enum tpm_vlan_num_enum_t  vlan_num = TPM_ANY_VLAN;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_engine_pkt_mod_t pkt_mod[TPM_ACT_NUM_MAX];
+	enum tpm_engine_no_t	eng_no = TPM_ENGINE_C2;
+	unsigned int		field_match_bm;
+	unsigned int		vlan_out;
+	unsigned int		vlan_in;
+	int flow_num;
+	int hit_num = 0;
+	unsigned int cnm_support;
+	unsigned char pbit_update_status = 0;
+	unsigned int vlan_op_code;
+	struct tpm_duplicate_t dup_info;
+	struct tpm_pkt_action_t action_tmp;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n");
+	if ((TPM_MNG_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE))
+		tpm_mng_add_cap_entry_print(api_type, match_key->pkt_key, act_num, action, policer_id);
+
+	flow_rules_list->fl_len = 0;
+	flow_rules = flow_rules_list->fl;
+	memset(flow_rules_list, 0, sizeof(struct tpm_cls_fl_rule_list_t));
+	TPM_MEMSET_ZERO(g_flow_cap_arr);
+	TPM_MEMSET_ZERO(eng_entry);
+	TPM_MEMSET_ZERO(pkt_mod);
+	TPM_MEMSET_ZERO(dup_info);
+
+	/* get vlan_num */
+	tpm_ret = tpm_mng_vlan_num_get(match_key->pkt_key, &vlan_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get vlan_num failed\n");
+
+	/* handle vlan magic number of 0x1000 */
+	vlan_out = match_key->pkt_key->out_vid;
+	vlan_in = match_key->pkt_key->inn_vid;
+	match_key->pkt_key->out_vid &= ~(TPM_SPEC_VID);
+	match_key->pkt_key->inn_vid &= ~(TPM_SPEC_VID);
+	field_match_bm = match_key->pkt_key->field_match_bm;
+	if (vlan_num != TPM_ANY_VLAN) {
+		match_key->pkt_key->field_match_bm &= ~(TPM_MNG_ALL_VLAN_FIELD_BM);
+
+		/* Handle case that check out VID for double or triple Tag packet */
+		if ((vlan_num == TPM_DOUBLE_VLAN || vlan_num == TPM_TRIPLE_VLAN) &&
+		    (field_match_bm & TPM_MATCH_VID_OUTER) &&
+		    (match_key->pkt_key->out_vid & TPM_SPEC_VID))
+			match_key->pkt_key->field_match_bm |= TPM_MATCH_VID_OUTER;
+
+		if (vlan_num == TPM_TRIPLE_VLAN &&
+		    (field_match_bm & TPM_MATCH_VID_INNER) &&
+		    (match_key->pkt_key->inn_vid & TPM_SPEC_VID))
+			match_key->pkt_key->field_match_bm |= TPM_MATCH_VID_INNER;
+	}
+
+	/* find caps first */
+	tpm_ret = tpm_db_mng_flow_in_cap_get(api_type,
+			match_key->pkt_key->rule_type,
+			match_key->pkt_key->field_match_bm,
+			vlan_num, g_flow_cap_arr, &flow_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+		"find no cap for api_type(%d), field_bm(%x), rule_type(%d), vlan_num(%d)\n",
+			api_type, match_key->pkt_key->field_match_bm,
+			match_key->pkt_key->rule_type, vlan_num);
+
+	tpm_ret = tpm_mng_add_cap_entry_check(match_key, act_num,
+			action, policer_id, qos, vlan_num, g_flow_cap_arr);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "validation failed for api entry add\n");
+
+	/* handle packet duplication, TO_CPU could not be the first action */
+	if ((act_num > 1)
+		&& (TPM_PP_CPU == action->dest.pp_port)) {
+		/* exchange action 0 and 1 */
+		memcpy(&action_tmp, action, sizeof(action_tmp));
+		memcpy(action, &action[TPM_ACT_NUM_IS_1], sizeof(action_tmp));
+		memcpy(&action[TPM_ACT_NUM_IS_1], &action_tmp, sizeof(action_tmp));
+	}
+
+	/* Creat Modification, No API Lock needed */
+
+	qos_sel = qos->qos_sel;
+	vlan_op_code = action[TPM_ACT_IDX0].mod.vlan_op.oper;
+	if (vlan_op_code == TPM_VLANOP_EXT_TAG_DEL_INT_MOD)
+		pbit_update_status = action[TPM_ACT_IDX0].mod.vlan_op.inn_vlan.pbit;
+	else
+		pbit_update_status = action[TPM_ACT_IDX0].mod.vlan_op.out_vlan.pbit;
+
+	/* Get CnM support value */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* Always support pbit update for US CLS if CnM supported */
+	if (cnm_support == TPM_CNM_SUPPORTED &&
+	    TPM_API_PUBLIC_CLS == api_type &&
+	    vlan_num != TPM_NO_VLAN &&
+	    action->dest.pp_port == TPM_PP_PMAC &&
+	    action[TPM_ACT_IDX0].mod.vlan_op.oper != TPM_VLANOP_DEL_2TAG &&
+	    (!(pbit_update_status & TPM_PBIT_UPDATE))) {
+		if (action[TPM_ACT_IDX0].mod.vlan_op.oper != TPM_VLANOP_EXT_TAG_DEL) {
+			if (action[TPM_ACT_IDX0].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_DEL_INT_MOD)
+				action[TPM_ACT_IDX0].mod.vlan_op.inn_vlan.pbit |= TPM_PBIT_UPDATE;
+			else
+				action[TPM_ACT_IDX0].mod.vlan_op.out_vlan.pbit |= TPM_PBIT_UPDATE;
+			if (vlan_op_code == TPM_VLANOP_NOOP) {
+				action[TPM_ACT_IDX0].mod.vlan_op.oper = TPM_VLANOP_EXT_TAG_MOD;
+				action[TPM_ACT_IDX0].mod.mod_bm |= TPM_VLAN_MOD;
+			}
+			if (TPM_QOS_NONE == qos_sel)
+				qos_sel = TPM_QOS_PBIT;
+		} else {
+			if (vlan_num == TPM_DOUBLE_VLAN ||
+			    vlan_num == TPM_TRIPLE_VLAN) {
+				action[TPM_ACT_IDX0].mod.vlan_op.oper = TPM_VLANOP_EXT_TAG_DEL_INT_MOD;
+				action[TPM_ACT_IDX0].mod.vlan_op.inn_vlan.pbit |= TPM_PBIT_UPDATE;
+				if (TPM_QOS_NONE == qos_sel)
+					qos_sel = TPM_QOS_PBIT;
+			}
+		}
+	}
+
+	if (TPM_API_PRIVATE_CNM_PBIT != api_type) {
+		tpm_ret = tpm_mng_mod_create(match_key,
+					     act_num,
+					     action,
+					     qos_sel,
+					     pkt_mod);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "TPM Mod Create failed\n");
+		if ((TPM_MNG_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) {
+			for (loop = 0; loop < act_num; loop++) {
+				TPM_OS_DEBUG(TPM_MNG_MOD, "Act[%d] Mod, HWFM_IPtr=%d, HWFM_DPtr=%d, L4_Cksum_Flag=%d\n",
+					     loop, pkt_mod[loop].mod_cmd_idx, pkt_mod[loop].mod_data_idx,
+					     pkt_mod[loop].l4_chksum_update_flag);
+			}
+		}
+	}
+
+	/* Restore pbit update status after mod create */
+	if (cnm_support == TPM_CNM_SUPPORTED &&
+	    TPM_API_PUBLIC_CLS == api_type &&
+	    vlan_num != TPM_NO_VLAN &&
+	    action->dest.pp_port == TPM_PP_PMAC &&
+	    vlan_op_code != TPM_VLANOP_DEL_2TAG &&
+	    (!(pbit_update_status & TPM_PBIT_UPDATE))) {
+		if (vlan_op_code != TPM_VLANOP_EXT_TAG_DEL) {
+			if (vlan_op_code == TPM_VLANOP_EXT_TAG_DEL_INT_MOD)
+				action[TPM_ACT_IDX0].mod.vlan_op.inn_vlan.pbit &= (~TPM_PBIT_UPDATE);
+			else
+				action[TPM_ACT_IDX0].mod.vlan_op.out_vlan.pbit &= (~TPM_PBIT_UPDATE);
+			action[TPM_ACT_IDX0].mod.vlan_op.oper = vlan_op_code;
+			if (vlan_op_code == TPM_VLANOP_NOOP)
+				action[TPM_ACT_IDX0].mod.mod_bm &= (~TPM_VLAN_MOD);
+		} else {
+			if (vlan_num == TPM_DOUBLE_VLAN ||
+			    vlan_num == TPM_TRIPLE_VLAN) {
+				action[TPM_ACT_IDX0].mod.vlan_op.oper = TPM_VLANOP_EXT_TAG_DEL;
+				action[TPM_ACT_IDX0].mod.vlan_op.inn_vlan.pbit &= (~TPM_PBIT_UPDATE);
+			}
+		}
+	}
+
+	/* Init classfier engine entry */
+	eng_entry.vlan_num = vlan_num;
+	eng_entry.match_key = match_key;
+	eng_entry.act_num = act_num;
+	eng_entry.action = action;
+	eng_entry.policer_id = policer_id;
+	eng_entry.qos = qos;
+	eng_entry.pkt_mod = pkt_mod;
+
+	tpm_mng_lock();
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+	memset(api_data, 0xff, sizeof(struct tpm_db_mng_api_data_t));
+
+	/* Create Packet replication list */
+	tpm_ret = tpm_mng_dup_create(&match_key->pkt_key->port, act_num, action, pkt_mod, &dup_info);
+	if (TPM_OK != tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "failed to create dup list, error(%d)\n", tpm_ret);
+		goto fail;
+	}
+	TPM_OS_DEBUG(TPM_MNG_MOD, "Dup info: dup cnt=%d, flow_id=%d\n", dup_info.flow_cnt, dup_info.flow_id);
+
+	/* Init classfier engine entry with dup info */
+	eng_entry.dup_info = &dup_info;
+
+	for (loop = 0; loop < flow_num; loop++) {
+		/* C2/3 entry with different lu_type will be created */
+		for (loop_in = 0; loop_in < loop; loop_in++)
+			if ((g_flow_cap_arr[loop].lu_type == g_flow_cap_arr[loop_in].lu_type)
+			     && (g_flow_cap_arr[loop].c2_key_bm == g_flow_cap_arr[loop_in].c2_key_bm))
+				break;
+
+		/* if lu_type has been created, move on */
+		if (loop_in != loop)
+			continue;
+
+		eng_entry.cap = &g_flow_cap_arr[loop];
+		eng_no = g_flow_cap_arr[loop].eng_no;
+
+		/* create C2/C3 and CLS entry */
+		if (eng_no == TPM_ENGINE_C2) {
+			tpm_ret = tpm_mng_c2_entry_add(&eng_entry, rule_id);
+			if (TPM_OK != tpm_ret) {
+				TPM_OS_ERROR(TPM_MNG_MOD, "add C2 entry for api_type(%d), field_bm(%d) failed\n",
+					api_type, match_key->pkt_key->field_match_bm);
+				goto fail;
+			}
+		} else	if (eng_no == TPM_ENGINE_C3_A ||
+			    eng_no == TPM_ENGINE_C3_B) {
+			tpm_ret = tpm_mng_c3_entry_add(&eng_entry, rule_id);
+			if (TPM_OK != tpm_ret) {
+				TPM_OS_ERROR(TPM_MNG_MOD, "add C3 entry for api_type(%d), field_bm(%d) failed\n",
+					api_type, match_key->pkt_key->field_match_bm);
+				goto fail;
+			}
+		} else {
+			TPM_OS_INFO(TPM_MNG_MOD, "unsupported engine(%d), api_type(%d), field_bm(%d)\n",
+				eng_no, api_type, match_key->pkt_key->field_match_bm);
+		}
+
+		if (eng_no == TPM_ENGINE_C2)
+			api_data->c2_rule_id[eng_index++] = *rule_id;
+		else if (eng_no == TPM_ENGINE_C3_A ||
+			 eng_no == TPM_ENGINE_C3_B)
+			api_data->c3_rule_id[eng_index++] = *rule_id;
+	}
+
+	for (loop = 0; loop < flow_num; loop++) {
+		/* enable CLS entry */
+		if (match_key->pkt_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM) {
+			src_port_cfg = (TPM_CAP_PORT_UNI);
+		} else if (match_key->pkt_key->port.port_type == TPM_CLASS_VIRT_PORT) {
+			src_port_cfg = (TPM_CAP_PORT_VIR);
+		} else {
+			src_port_cfg = match_key->pkt_key->port.class_port;
+			if (g_flow_cap_arr[loop].cap_api_type < TPM_API_PRIVATE_START) {
+				tpm_ret = tpm_db_mng_cap_hit_num_get(g_flow_cap_arr[0].cap_api_type,
+					g_flow_cap_arr[0].rule_type , g_flow_cap_arr[0].cap_field_bm,
+					g_flow_cap_arr[0].vlan_num, &hit_num);
+				if (TPM_OK != tpm_ret) {
+					TPM_OS_ERROR(TPM_MNG_MOD, "get CAP hit number failed\n");
+					goto rmv_entry;
+				}
+			} else if ((g_flow_cap_arr[loop].cap_api_type == TPM_API_PRIVATE_EXCT)
+				    || (g_flow_cap_arr[loop].cap_api_type == TPM_API_PRIVATE_MC_US))
+				hit_num = 2;
+			else
+				hit_num = 1;
+
+			if (hit_num == 2)
+				g_flow_cap_arr[loop].cls_pri++;
+		}
+		tpm_ret = tpm_mng_def_flow_entry_crt(&g_flow_cap_arr[loop],
+			flow_rules_list,
+			src_port_cfg, match_key->pkt_key->port.class_port);
+		if (TPM_OK != tpm_ret) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "failed to add default flow list, error(%d)\n", tpm_ret);
+			goto rmv_entry;
+		}
+	}
+
+	tpm_ret = tpm_cls_fl_rule_enable(flow_rules_list);
+	if (TPM_OK != tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "failed to enable flow list, error(%d)\n", tpm_ret);
+		goto rmv_entry;
+	}
+
+	/* increase ref count */
+	if (qos->qos_sel != TPM_QOS_NONE) {
+		tpm_ret = tpm_qos_tbl_ref_cnt_update(qos->qos_sel, qos->qos_tbl, TPM_QOS_TBL_REF_CNT_INC);
+		if (TPM_OK != tpm_ret) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "update qos table ref count failed\n");
+			goto rmv_entry;
+		}
+	}
+
+	/* recover original field_match_bm and vid */
+	match_key->pkt_key->field_match_bm = field_match_bm;
+	match_key->pkt_key->out_vid = vlan_out;
+	match_key->pkt_key->inn_vid = vlan_in;
+
+	/* keep the api data */
+	memcpy(api_data->action, action, sizeof(struct tpm_pkt_action_t) * act_num);
+	memcpy(api_data->pkt_mod, &pkt_mod, sizeof(struct tpm_engine_pkt_mod_t) * act_num);
+	memcpy(&api_data->dup_info, &dup_info, sizeof(struct tpm_duplicate_t));
+
+	/* get api_rule index */
+	api_data->api_rule_id = tpm_db_mng_api_rule_id_get();
+
+	*rule_id = api_data->api_rule_id;
+	api_data->cap_api_type = api_type;
+
+	for (loop = 0; loop < flow_rules_list->fl_len; loop++)
+		api_data->flow_rule_id[loop] = flow_rules_list->fl[loop].rl_log_id;
+
+	memcpy(&api_data->match_key, match_key->pkt_key, sizeof(struct tpm_pkt_key_t));
+	api_data->policer_id = policer_id;
+	if (qos)
+		memcpy(&api_data->qos, qos, sizeof(struct tpm_qos_t));
+
+	api_data->num_dest = act_num;
+	tpm_ret = tpm_db_mng_api_entry_add(api_data);
+	if (TPM_OK != tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "find no cap for api_type(%d), field_bm(%d)\n",
+			api_type, match_key->pkt_key->field_match_bm);
+		goto rmv_entry;
+	}
+
+	if (policer_id != TPM_POLICER_INVALID) {
+		tpm_ret = tpm_plcr_ref_cnt_update(policer_id, TPM_PLCR_REF_CNT_INC);
+		if (TPM_OK != tpm_ret) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "failed to increase policer reference counter\n");
+			goto rmv_entry;
+		}
+	}
+
+	tpm_mng_unlock();
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+	return TPM_OK;
+
+rmv_entry:
+	/* remove engine entry */
+	if (eng_no == TPM_ENGINE_C2) {
+		tpm_ret = tpm_c2_rule_del(*rule_id);
+		if (TPM_OK != tpm_ret) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "find no cap for api_type(%d), field_bm(%d)\n",
+				api_type, match_key->pkt_key->field_match_bm);
+		}
+	} else	if (eng_no == TPM_ENGINE_C3_A ||
+		    eng_no == TPM_ENGINE_C3_B) {
+		tpm_ret = tpm_c3_rule_del(*rule_id);
+		if (TPM_OK != tpm_ret) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "find no cap for api_type(%d), field_bm(%d)\n",
+				api_type, match_key->pkt_key->field_match_bm);
+		}
+	}
+fail:
+	/* Unlock */
+	tpm_mng_unlock();
+
+	/* Release Modification */
+	for (loop = 0; loop < act_num; loop++) {
+		if (pkt_mod[loop].mod_cmd_idx) {
+			if (tpm_pme_mod_release(pkt_mod[loop].mod_cmd_idx, pkt_mod[loop].mod_data_idx))
+				TPM_OS_ERROR(TPM_MNG_MOD, "Modification Release failed, cmd_idx=%d, data_idx=%d\n",
+					     pkt_mod[loop].mod_cmd_idx, pkt_mod[loop].mod_data_idx);
+		}
+	}
+
+	/* Release Dup list if there is */
+	if (dup_info.flow_cnt) {
+		if (tpm_mc_dup_list_release(dup_info.flow_id))
+			TPM_OS_ERROR(TPM_MNG_MOD, "Dup list %d release fail\n", dup_info.flow_id);
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	return TPM_FAIL;
+}
+
+
+/*******************************************************************************
+* tpm_mng_cap_entry_del
+*
+* DESCRIPTION: The routine del a API entry
+*
+* INPUTS:
+*              cap_api_type:   api type of this rule
+*              rule_id:
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_entry_del(
+	enum tpm_mng_api_type_t	cap_api_type,
+	unsigned int rule_id)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	unsigned short fl_rule_log_id_list[TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX];
+	int loop, i;
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_entry_get(rule_id, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "find no api entry for rule_id(%d)\n", rule_id);
+
+	/* check API type */
+	if (cap_api_type != api_data->cap_api_type)
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, TPM_NO_SUCH, api_data,
+			"api type of rule(%d) is not the same with api call (%s)\n",
+			rule_id, tpm_utils_cap_type_str_get(cap_api_type));
+
+	/* only disable CLS entry for public api_type */
+	if (api_data->cap_api_type < TPM_API_PRIVATE_START) {
+		/* get CLS entry number */
+		for (loop = 0; loop < TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX; loop++) {
+			if (api_data->flow_rule_id[loop] == TPM_DB_MNG_RULE_ID_INVALID)
+				break;
+
+			fl_rule_log_id_list[loop] = api_data->flow_rule_id[loop];
+		}
+		/* disable CLS entry */
+		tpm_ret = tpm_cls_fl_rule_disable(fl_rule_log_id_list, loop, &api_data->match_key.port);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to disable CLS entry for rule_id(%d)\n",
+					rule_id);
+	}
+
+	/* remove C2/C3 entry */
+	for (loop = 0; loop < TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX; loop++) {
+		if (api_data->c2_rule_id[loop] != TPM_DB_MNG_RULE_ID_INVALID) {
+			/* remove C2 rule */
+			tpm_ret = tpm_c2_rule_del(api_data->c2_rule_id[loop]);
+			IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+				"fail to remove C2 entry for api_rule_id(%d), c2_rule_id(%d)\n",
+				rule_id, api_data->c2_rule_id[loop]);
+
+			/* remove filter default rule if necessary */
+			tpm_ret = tpm_mng_filter_def_c2_rule_delete(api_data);
+			IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+				"fail to remove filter default C2 entry\n");
+		}
+		if (api_data->c3_rule_id[loop] != TPM_DB_MNG_RULE_ID_INVALID) {
+			/* remove C3 rule */
+			tpm_ret = tpm_c3_rule_del(api_data->c3_rule_id[loop]);
+			IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+				"fail to remove C3 entry for api_rule_id(%d), c3_rule_id(%d)\n",
+				rule_id, api_data->c3_rule_id[loop]);
+
+			/* remove filter default rule if necessary */
+			tpm_ret = tpm_mng_filter_def_c3_rule_delete(api_data);
+			IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+				"fail to remove filter default C3 entry\n");
+		}
+	}
+
+	/* release modification */
+	for (loop = 0; loop < api_data->num_dest; loop++) {
+		if (loop) {
+			for (i = 0; i < loop; i++) {
+				if (api_data->pkt_mod[i].mod_data_idx == api_data->pkt_mod[loop].mod_data_idx)
+					break;
+			}
+			if (i < loop)
+				continue;
+		}
+		if (api_data->pkt_mod[loop].mod_cmd_idx) {
+			tpm_ret = tpm_pme_mod_release(api_data->pkt_mod[loop].mod_cmd_idx,
+						      api_data->pkt_mod[loop].mod_data_idx);
+			IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+				"fail to release modification entry for api_rule_id(%d)\n", rule_id);
+		}
+	}
+
+	/* Release dup list if there is */
+	if (api_data->dup_info.flow_cnt) {
+		tpm_ret = tpm_mc_dup_list_release(api_data->dup_info.flow_id);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+			"fail to release dup list for api_rule_id(%d)\n", rule_id);
+	}
+
+	/* decrease ref count */
+	if (api_data->qos.qos_sel != TPM_QOS_NONE) {
+		tpm_ret = tpm_qos_tbl_ref_cnt_update(api_data->qos.qos_sel,
+						     api_data->qos.qos_tbl,
+						     TPM_QOS_TBL_REF_CNT_DEC);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "update qos table ref count failed\n");
+	}
+
+	/* remove api_data */
+	tpm_ret = tpm_db_mng_api_entry_del(rule_id);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to remove api data entry for api_rule_id(%d)\n",
+				rule_id);
+
+	if (api_data->policer_id != TPM_POLICER_INVALID) {
+		tpm_ret = tpm_plcr_ref_cnt_update(api_data->policer_id, TPM_PLCR_REF_CNT_DEC);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+					"failed to decrease policer reference counter\n");
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mng_cap_entry_cntr_get
+*
+* DESCRIPTION: The routine gets a API entry counter
+*
+* INPUTS:
+*              rule_id:
+* OUTPUTS:
+*           cntr
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_entry_cntr_get(unsigned int rule_id, unsigned int *cntr)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_entry_get(rule_id, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "find no api entry for rule_id(%d)\n", rule_id);
+
+	/* so far, each API rule only has one C2/C3 entry */
+	if (api_data->c2_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* get C2 rule cntr */
+		tpm_ret = tpm_c2_hit_cntr_get(api_data->c2_rule_id[0], cntr);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+			"fail to get C2 entry cntr, api_rule_id(%d), c2_rule_id(%d)\n",
+			rule_id, api_data->c2_rule_id[0]);
+
+	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* get C3 rule cntr */
+		tpm_ret = tpm_c3_hit_count_get(api_data->c3_rule_id[0], cntr);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+			"fail to get C3 entry cntr, api_rule_id(%d), c3_rule_id(%d)\n",
+			rule_id, api_data->c3_rule_id[0]);
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_filter_def_rule_cntr_get()
+*
+* DESCRIPTION: routine gets an filter default rule hit counter.
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_filter_def_rule_cntr_get(
+	unsigned char			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*cntr)
+{
+	int tpm_ret = TPM_OK;
+	unsigned int rule_id;
+	int flow_num;
+
+	IF_NULL(TPM_API_MOD, cntr);
+
+	TPM_MEMSET_ZERO(g_flow_cap_arr);
+
+	/* find caps first */
+	tpm_ret = tpm_db_mng_flow_in_cap_get(TPM_API_PUBLIC_FLTR,
+			rule_type, field_bm, vlan_num,
+			g_flow_cap_arr, &flow_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret,
+		"find no filter with field_bm(%x), rule_type(%d), vlan_num(%d)\n",
+			field_bm, rule_type, vlan_num);
+
+	/* get default C2/C3 rule_id */
+	tpm_ret = tpm_db_mng_flt_def_rule_get(rule_type, field_bm, vlan_num, &rule_id);
+	if (tpm_ret != TPM_OK) {
+		TPM_OS_INFO(TPM_API_MOD,
+		"no filter rule, so no default rule, cntr 0 for filter of rule_type(%d),field_bm(%d),vlan_num(%d)\n",
+		rule_type, field_bm, vlan_num);
+		*cntr = 0;
+		return TPM_OK;
+	}
+
+	if (TPM_ENGINE_C2 == g_flow_cap_arr[0].eng_no)
+		tpm_ret = tpm_c2_hit_cntr_get(rule_id, cntr);
+	else
+		tpm_ret = tpm_c3_hit_count_get(rule_id, cntr);
+
+	IF_ERROR_STR(TPM_API_MOD, tpm_ret, "fail to hit counter of filter rule(%d)\n", rule_id);
+
+	return tpm_ret;
+}
+
+
+/*******************************************************************************
+* tpm_mng_cap_entry_del_type
+*
+* DESCRIPTION: The routine del all API entry for a api_type
+*
+* INPUTS:
+*              api_type:
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cap_entry_del_type(enum tpm_mng_api_type_t       cap_api_type)
+{
+	int tpm_ret;
+	int tpm_ret_loop;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_db_mng_api_data_t *api_data_new = NULL;
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data_new);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "allocate api_data structure mem failed!\n");
+
+	tpm_ret_loop = tpm_db_mng_api_entry_type_first_get(cap_api_type, api_data_new);
+	while (TPM_OK == tpm_ret_loop) {
+		memcpy(api_data, api_data_new, sizeof(struct tpm_db_mng_api_data_t));
+		tpm_ret_loop = tpm_db_mng_api_entry_type_next_get(api_data_new);
+
+		tpm_ret = tpm_mng_cap_entry_del(cap_api_type, api_data->api_rule_id);
+		IF_ERROR_STR_REL_TWO_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, api_data_new,
+			"fail to remove api entry for rule_id(%d)\n", api_data->api_rule_id);
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	tpm_db_mng_api_data_release(api_data_new);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cpu_c2_entry_add
+*
+* DESCRIPTION: The routine add all the entry for private cap to CPU
+*
+* INPUTS:
+*              api_type:
+*              match_key:
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cpu_c2_entry_add(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_mng_pkt_key_t  *match_key,
+	unsigned int            *rule_id)
+{
+	enum tpm_pp_port_t        pp_port;
+	struct tpm_pkt_action_t   action;
+	int tpm_ret;
+	int cpu_queue;
+	struct tpm_qos_t	  qos;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n");
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+	action.dest.pp_port = TPM_PP_CPU;
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+
+	for (pp_port = TPM_PP_GMAC0; pp_port <= TPM_PP_PMAC; pp_port <<= 1) {
+
+		action.dest.pp_queue = cpu_queue;
+		match_key->pkt_key->port.class_port = pp_port;
+		match_key->pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+
+		tpm_ret = tpm_mng_cap_entry_add(api_type, match_key, TPM_ACT_NUM_IS_1,
+						&action, TPM_POLICER_INVALID,
+						&qos, rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU C2 entry failed for port(%d)\n", pp_port);
+	}
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cnm_pbit_asis_entry_add
+*
+* DESCRIPTION: The routine add all the entry for private cap to keep pbit AS-IS for CnM
+*
+* INPUTS:
+*              api_type:
+*              match_key:
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_cnm_pbit_asis_entry_add(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_mng_pkt_key_t  *match_key,
+	unsigned int            *rule_id)
+{
+	struct tpm_pkt_action_t   action;
+	int tpm_ret;
+	struct tpm_qos_t	  qos;
+	unsigned int cnm_support;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n");
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	/* Check CnM is supported or not */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* If CnM not supported, return OK */
+	if (cnm_support == TPM_CNM_NOT_SUPPORTED) {
+		TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+		return TPM_OK;
+	}
+
+	qos.qos_sel = TPM_QOS_PBIT;
+	qos.qos_tbl = TPM_MNG_CNM_PBIT_TBL;
+
+	match_key->pkt_key->port.class_port = TPM_PP_GMAC0;
+	match_key->pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+	action.dest.pp_port = TPM_PP_PMAC;
+
+	tpm_ret = tpm_mng_cap_entry_add(api_type, match_key, TPM_ACT_NUM_IS_1,
+					&action, TPM_POLICER_INVALID,
+					&qos, rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CNM pbit AS-IS entry failed for port(%d)\n", TPM_PP_GMAC0);
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_drop_c2_entry_add
+*
+* DESCRIPTION: The routine add all the entry for private cap to drop
+*
+* INPUTS:
+*              api_type:
+*              match_key:
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_drop_c2_entry_add(
+	enum tpm_mng_api_type_t   api_type,
+	struct tpm_mng_pkt_key_t  *match_key,
+	unsigned int            *rule_id)
+{
+	enum tpm_pp_port_t        pp_port;
+	struct tpm_pkt_action_t   action;
+	int tpm_ret;
+	struct tpm_qos_t	  qos;
+
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	action.dest.pp_port = TPM_PP_DROP;
+	for (pp_port = TPM_PP_GMAC0; pp_port <= TPM_PP_PMAC; pp_port <<= 1) {
+		match_key->pkt_key->port.class_port = pp_port;
+		match_key->pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+
+		tpm_ret = tpm_mng_cap_entry_add(api_type, match_key, TPM_ACT_NUM_IS_1,
+						&action, TPM_POLICER_INVALID,
+						&qos, rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add DROP C2 entry failed for port(%d)\n", pp_port);
+	}
+	return TPM_OK;
+}
+
+#ifndef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* tpm_mng_create_cpu_q_c2_entry
+*
+* DESCRIPTION: The routine add all the C2 entry for private cap to CPU
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_cpu_q_c2_entry(void)
+{
+	struct tpm_pkt_key_t      match_key;
+	struct tpm_mng_pkt_key_t  match_mng_key;
+	unsigned int            rule_id;
+	int			tpm_ret;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+	/* create CPU_Q entries */
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+
+	match_mng_key.pkt_key = &match_key;
+
+	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_CPU_Q,
+					&match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP C2 entry failed\n");
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+
+	return TPM_OK;
+}
+#endif
+
+/*******************************************************************************
+* tpm_mng_create_cnm_pbit_asis_entry
+*
+* DESCRIPTION: The routine add all the C2 entry for private cap to CPU
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_cnm_pbit_asis_entry(void)
+{
+	struct tpm_pkt_key_t      match_key;
+	struct tpm_mng_pkt_key_t  match_mng_key;
+	unsigned int            rule_id;
+	int			tpm_ret;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+	/* create CPU_Q entries */
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+
+	match_mng_key.pkt_key = &match_key;
+
+	tpm_ret = tpm_mng_cnm_pbit_asis_entry_add(TPM_API_PRIVATE_CNM_PBIT,
+						  &match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CNM pbit AS-IS C2 entry failed\n");
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_create_mc_proto_c2_entry
+*
+* DESCRIPTION: The routine add all the C2 entry for private IGMP/MLD cap to CPU
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_mc_proto_c2_entry(struct tpm_mng_pkt_key_t *match_mng_key)
+{
+	struct tpm_pkt_action_t   action;
+	unsigned int            rule_id;
+	int			tpm_ret;
+	int                     uni_num;
+	int                     loop;
+	int                     cpu_queue;
+	struct tpm_qos_t	qos;
+
+	IF_NULL(TPM_MNG_MOD, match_mng_key);
+
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+
+	/* create IPv4 IGMP entries */
+	action.dest.pp_port = TPM_PP_CPU;
+	action.dest.pp_queue = cpu_queue;
+
+	/* DS */
+	match_mng_key->pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+	match_mng_key->pkt_key->port.class_port = TPM_PP_PMAC;
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS, match_mng_key, TPM_ACT_NUM_IS_1,
+					&action, TPM_POLICER_INVALID,
+					&qos, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add multicast proto DS C2 entry failed\n");
+
+	/* US */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &uni_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get max uni port number failed\n");
+
+	action.dest.pp_queue = cpu_queue;
+	match_mng_key->pkt_key->port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+	for (loop = 0; loop < uni_num; loop++) {
+		match_mng_key->pkt_key->port.class_port = (1 << loop);
+		tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_US, match_mng_key, TPM_ACT_NUM_IS_1,
+						&action, TPM_POLICER_INVALID,
+						&qos, &rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add multicast proto US C2 entry failed\n");
+
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_create_igmp_c2_entry
+*
+* DESCRIPTION: The routine add all the C2 entry for private IGMP cap to CPU
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_igmp_c2_entry(void)
+{
+	struct tpm_pkt_key_t      match_key;
+	struct tpm_mng_pkt_key_t  match_mng_key;
+	int			tpm_ret;
+	int			ipv6_enable;
+
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6_enable failed\n");
+
+	/* create IPv4 IGMP entries */
+	match_mng_key.pkt_key = &match_key;
+	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV4_PKT;
+	match_key.ipvx_add.ip_proto = TPM_MNG_IGMP_PROT_VALUE;
+
+	tpm_ret = tpm_mng_create_mc_proto_c2_entry(&match_mng_key);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add IGMP C2 entry failed\n");
+
+	/* add IPv6 rules */
+	if (ipv6_enable != TPM_IPV6_SUPPORTED)
+		return TPM_OK;
+
+	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_IPV6_PKT;
+	match_key.ipvx_add.ip_proto = TPM_MNG_MLD_NH_VALUE;
+
+	tpm_ret = tpm_mng_create_mc_proto_c2_entry(&match_mng_key);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add MLD C2 entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_create_lpbk_mh_c2_entry
+*
+* DESCRIPTION: The routine add the C2 entry for MH check from different MAC
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_lpbk_mh_c2_entry(void)
+{
+	struct tpm_pkt_key_t      match_key;
+	struct tpm_mng_pkt_key_t  match_mng_key;
+	int			tpm_ret;
+	unsigned int		rule_id;
+	struct tpm_pkt_action_t   action;
+	struct tpm_qos_t	  qos;
+	int cpu_queue;
+
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	action.dest.pp_port = TPM_PP_CPU;
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+
+	/* create loopback MH entries */
+	match_mng_key.pkt_key = &match_key;
+	match_mng_key.pkt_key->field_match_bm = TPM_MATCH_MH;
+	match_mng_key.mh_mask = TPM_MNG_LPBK_MH_MASK;
+	match_mng_key.pkt_key->port.port_type = TPM_CLASS_PP_PORT_BM;
+	match_mng_key.pkt_key->port.class_port = TPM_PP_LPBK;
+	action.dest.pp_queue = cpu_queue;
+
+	/* Trap to CPU through GMAC0 */
+	match_mng_key.mh = TPM_PME_LPBK_MH_G0;
+
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
+					&action, TPM_POLICER_INVALID,
+					&qos, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+
+	/* Trap to CPU through GMAC1 */
+	match_mng_key.mh = TPM_PME_LPBK_MH_G1;
+
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
+					&action, TPM_POLICER_INVALID,
+					&qos, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+
+	/* Trap to CPU through PON */
+	match_mng_key.mh = TPM_PME_LPBK_MH_PON;
+
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_LPBK_MH, &match_mng_key, TPM_ACT_NUM_IS_1,
+					&action, TPM_POLICER_INVALID,
+					&qos, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add lpbk_mh_C2 entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_create_ipvx_c2_entry
+*
+* DESCRIPTION: The routine add all the C2 entry for private IPvX 5T cap
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_create_ipvx_c2_entry(void)
+{
+	struct tpm_pkt_key_t      match_key;
+	struct tpm_mng_pkt_key_t  match_mng_key;
+	unsigned int            rule_id;
+	int			tpm_ret;
+	int			ttl_action;
+
+	/* create IPvx entries */
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+	match_mng_key.pkt_key = &match_key;
+
+	/* TTL == 0, drop */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_TTL_ILLEGAL_ACTION, &ttl_action);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get invalid TTL action failed\n");
+
+	match_key.field_match_bm = TPM_MATCH_TTL;
+	match_mng_key.ttl = 0;
+
+	if (ttl_action == TPM_TTL_ZERO_ACTION_NOT_CARE) {
+		/* do nothing */
+	} else if (ttl_action == TPM_TTL_ZERO_ACTION_DROP) {
+		tpm_ret = tpm_mng_drop_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+						&match_mng_key, &rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL DROP C2 entry failed\n");
+	} else if (ttl_action == TPM_TTL_ZERO_ACTION_TO_CPU) {
+		tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+						&match_mng_key, &rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL == 0 CPU C2 entry failed\n");
+	}
+	/* TTL == 1, to CPU */
+	match_mng_key.ttl = 1;
+	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+					&match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TTL == 1 CPU C2 entry failed\n");
+
+	/* TCP FLAG RST FIN, to CPU */
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(match_mng_key);
+	match_mng_key.pkt_key = &match_key;
+
+	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_RF;
+	match_mng_key.pkt_key->ipvx_add.ip_proto = MV_IP_PROTO_TCP;
+	match_mng_key.tcp_flag = 0x1;
+	match_mng_key.tcp_flag_mask = 0x1;
+	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+					&match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG FIN CPU C2 entry failed\n");
+
+	match_mng_key.tcp_flag = 0x4;
+	match_mng_key.tcp_flag_mask = 0x4;
+	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+					&match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG RST CPU C2 entry failed\n");
+
+	/* TCP FLAG SYN, to CPU */
+	match_key.field_match_bm = TPM_MATCH_IP_PROTO | TPM_MATCH_TCP_FLAG_S;
+	match_mng_key.tcp_flag = 0x2;
+	match_mng_key.tcp_flag_mask = 0x2;
+	tpm_ret = tpm_mng_cpu_c2_entry_add(TPM_API_PRIVATE_EXCT_DEFAULT,
+					&match_mng_key, &rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add TCP FLAG SYN CPU C2 entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_def_c2_entry_create
+*
+* DESCRIPTION: The routine add all the C2 entry for private cap
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_def_c2_entry_create(void)
+{
+	int			tpm_ret;
+
+	/* create all the C2/C3 entries for private caps */
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* create CPU_Q entries */
+	tpm_ret = tpm_mng_create_cpu_q_c2_entry();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP C2 entry failed\n");
+#endif
+
+	/* create CNM P-bit AS-IS entries */
+	tpm_ret = tpm_mng_create_cnm_pbit_asis_entry();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CNM pbit as-is C2 entry failed\n");
+
+	/* create IPvx 5T entries */
+	tpm_ret = tpm_mng_create_ipvx_c2_entry();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add IPvx 5T C2 entry failed\n");
+
+	/* create IGMP entries */
+	tpm_ret = tpm_mng_create_igmp_c2_entry();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add IGMP C2 entry failed\n");
+
+	/* create Loopback MH entries */
+	tpm_ret = tpm_mng_create_lpbk_mh_c2_entry();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add Loopback MH C2 entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_def_c3_entry_create
+*
+* DESCRIPTION: The routine add all the C3 entry
+*
+* INPUTS:
+*	NONE:
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_def_c3_entry_create(void)
+{
+	struct tpm_c3_add_entry_t	c3_entry;
+	unsigned int			logic_idx;
+	int cpu_queue;
+	int idx;
+	int tpm_ret;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "enter!\n")
+
+	TPM_MEMSET_ZERO(c3_entry);
+
+	/* fill QoS and Action */
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_NO_UPDT;
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &cpu_queue);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CPU_RX_QUEUE failed\n");
+
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_NO_UPDT;
+	c3_entry.qos_value.q_low  = cpu_queue;
+
+	for (idx = 0; idx <= KEY_CTRL_LKP_TYPE_MAX; idx++) {
+
+		c3_entry.lkp_type = idx;
+		tpm_ret = tpm_c3_default_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add C3 default entry failed\n");
+	}
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "leave!\n")
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_spid_set
+*
+* DESCRIPTION: The routine set SPID Extraction Mode and value
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_spid_set(enum tpm_gmacs_enum_t gmac)
+{
+	int			tpm_ret = 0;
+	int			i;
+	enum tpm_sw_head_mode_t switch_mode = 0;
+	enum tpm_mng_spid_ex_mode_t spid_mode = 0;
+
+	/* get switch conf */
+	switch_mode = tpm_db_init_switch_mode_get(gmac);
+
+	if (TPM_SW_HEAD_NONE == switch_mode)
+		return TPM_OK;
+	else if (TPM_SW_HEAD_MH == switch_mode)
+		spid_mode = TPM_SPID_MODE_MH;
+	else if (TPM_SW_HEAD_MH_ETYPE_DSA == switch_mode
+		  || TPM_SW_HEAD_DSA == switch_mode)
+		spid_mode = TPM_SPID_MODE_EXTERNAL_SW;
+	else if (TPM_SW_HEAD_EXT_DSA == switch_mode)
+		spid_mode = TPM_SPID_MODE_CASCADED_SW;
+
+	/* set spid mode */
+	tpm_ret = mvPp2ClsHwPortSpidSet(gmac, spid_mode);
+	if (MV_OK != tpm_ret) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "set spid mode for GMAC(%d) failed, err code(%d)\n", gmac, tpm_ret);
+		return tpm_ret;
+	}
+
+	if (gmac == TPM_ENUM_GMAC_0) {
+		for (i = 0; i < TPM_CPU_SWITCH_PORT; i++) {
+			tpm_ret = mvPp2ClsHwUniPortSet(i, i);
+			if (MV_OK != tpm_ret) {
+				TPM_OS_ERROR(TPM_MNG_MOD, "set spid value for UNI(%d)failed, err code(%d)\n",
+					i, tpm_ret);
+				return tpm_ret;
+			}
+		}
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_way_set
+*
+* DESCRIPTION: The routine set port way value
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_way_set(void)
+{
+	int			tpm_ret = 0;
+	enum tpm_gmacs_enum_t	port;
+
+	for (port = TPM_ENUM_GMAC_0; port < TPM_ENUM_PMAC; port++) {
+		tpm_ret = mvPp2ClsHwPortWaySet(port, TPM_MNG_PORT_WAY_GMAC);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set way(%d) to port(%d) failed\n", port, TPM_MNG_PORT_WAY_GMAC);
+	}
+
+	tpm_ret = mvPp2ClsHwPortWaySet(port, TPM_MNG_PORT_WAY_PMAC);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set way(%d) to port(%d) failed\n", port, TPM_MNG_PORT_WAY_PMAC);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_c4_ruleset_init
+*
+* DESCRIPTION: The routine set C4 ruleSet of each UNI port
+*
+* INPUTS:
+*	       NONE:
+*
+* OUTPUTS:
+*	    NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	    None
+*******************************************************************************/
+int tpm_mng_c4_ruleset_init(void)
+{
+	int			tpm_ret = 0;
+	int			uni_port;
+	struct tpm_class_port_t	src_port;
+
+	src_port.port_type = TPM_SRC_PORT_TYPE_UNI;
+
+	for (uni_port = 0; uni_port < TPM_NUM_MAX_UNI_PORTS; uni_port++) {
+		src_port.class_port = (1 << uni_port);
+		tpm_ret = tpm_c4_port_to_ruleset_set(&src_port, uni_port, MV_PP2_CLS_C4_GRP_SIZE);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set C4 ruleSet of UNI(%d) failed\n", uni_port);
+
+		/* update DB */
+		tpm_ret = tpm_db_mng_cm_ruleset_set(&src_port, uni_port);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "update ruleSet of UNI(%d) DB failed\n", uni_port);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_upstream_gem_port_src_select
+*
+* DESCRIPTION:    Defines the source of the GEM port ID and the mgpid bit to be written to the TX descriptor.
+*                         The mgpid bit will receive values as following:
+*                         When the GEM Port ID source is from Classifier, then as generated by the Classifiier
+*                         Otherwise the mgpid will be set to "1".
+*                         The GEM Port ID will receive value as presented below:
+*                         -Enumeration:
+*                         Value Name         Description
+*                         0x0  "GPON_header"  GPON header bits [11:0]
+*                         0x1  "DSA_tag"  extended DSA tag word 1, bits[11:0]
+*                         0x2  "Classifier"  Gem Port Id from Classifier
+*                         0x3  "DSA_fields"  GEM_PID[11] =  target device [0] = DSA_WORD1[0]
+*                         GEM_PID[10:5] = target port[5:0] = DSA_WORD1[10:5]
+*                         GEM_PID[4:0] = src_id[4:0] = DSA_WORD1[24:20]
+*                         0x4  "Zero"  "0"
+*
+* INPUTS:
+*               gem_src:        GEM port ID Source Select
+*
+* OUTPUTS:
+*               NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*              None
+*******************************************************************************/
+int tpm_mng_upstream_gem_port_src_select(enum tpm_mng_gem_port_src_select_t gem_src)
+{
+	unsigned int	regVal = 0;
+
+	/*select the source of the GEM port ID for packets from GMAC0*/
+	regVal = mvPp2RdReg(MV_PP2_RX_CTRL_REG(ENUM_GMAC_0));
+
+	regVal &= ~MV_PP2_RX_GEMPID_SRC_MASK;
+	regVal |= (gem_src << MV_PP2_RX_GEMPID_SRC_OFFS);
+
+	mvPp2WrReg(MV_PP2_RX_CTRL_REG(ENUM_GMAC_0), regVal);
+
+	/*select the source of the GEM port ID for packets from GMAC1*/
+	regVal = mvPp2RdReg(MV_PP2_RX_CTRL_REG(ENUM_GMAC_1));
+
+	regVal &= ~MV_PP2_RX_GEMPID_SRC_MASK;
+	regVal |= (gem_src << MV_PP2_RX_GEMPID_SRC_OFFS);
+
+	mvPp2WrReg(MV_PP2_RX_CTRL_REG(ENUM_GMAC_1), regVal);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_dst_port_bm_update
+*
+* DESCRIPTION: The routine update the DS UNI bitmap with PME API.
+*
+* INPUTS:
+*              dptr    : Modification data pointer
+*              port_bm : new port bit map.
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is used to update DS traffic UNI dest port set.
+*******************************************************************************/
+int tpm_mng_dst_port_bm_update(unsigned int dptr, unsigned int port_bm)
+{
+	int tpm_ret;
+
+	tpm_ret = tpm_pme_priv_first_data_update(dptr, (unsigned short)port_bm);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Port bitmap update fail\n")
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_lock
+*
+* DESCRIPTION: The routine wrapper mng lock
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+void tpm_mng_lock(void)
+{
+	spin_lock_bh(&tpm_api_call_lock);
+}
+
+/*******************************************************************************
+* tpm_mng_unlock
+*
+* DESCRIPTION: The routine wrapper mng unlock
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+void tpm_mng_unlock(void)
+{
+	spin_unlock_bh(&tpm_api_call_lock);
+}
+
+/*******************************************************************************
+* tpm_mng_lock_init
+*
+* DESCRIPTION: The routine init mng lock
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+void tpm_mng_lock_init(void)
+{
+	spin_lock_init(&tpm_api_call_lock);
+}
+
+
+/*******************************************************************************
+* tpm_mng_mc_default_set
+*
+* DESCRIPTION: The routine add mc default rule and internal switch if needed.
+*
+* INPUTS:
+*           NONE
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_default_set(void)
+{
+	int tpm_ret;
+	unsigned int data_handle, mc_def_act;
+	unsigned int rule_id;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t match_key;
+	struct tpm_pkt_action_t action;
+	struct tpm_qos_t qos;
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	unsigned int switch_init, sw_port;
+#endif
+	unsigned int ipv6_enable;
+
+	/* Chekc the handler mod eof multicast mode, if not MC, no need to add defaut rule  */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	if (data_handle != TPM_HANDLER_MC)
+		return TPM_OK;
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	/* Check switch init status, enable or disable */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &switch_init);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get switch init status failed\n");
+#endif
+	/* Check IPV6 supported */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+	/* Add MC default rule */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(match_key);
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(qos);
+
+	match_key.pkt_key = &pkt_key;
+
+	/* Src Port */
+	pkt_key.port.port_type = TPM_CLASS_PP_PORT_BM;
+	pkt_key.port.class_port = TPM_PP_PMAC;
+
+	/* QoS */
+	qos.qos_sel = TPM_QOS_NONE;
+
+	/* Add L3 default rule, check PPPoE ether type */
+	pkt_key.field_match_bm = TPM_MATCH_ETH_TYPE;
+	pkt_key.ether_type = MV_PPPOE_TYPE;
+	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+	/* Get L3 default rule action, drop or to CPU */
+	tpm_ret = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L3, &mc_def_act);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get L3 MC default action failed\n");
+	if (mc_def_act == TPM_MC_FLOW_DEFAULT_DROP)
+		action.dest.pp_port = TPM_PP_DROP;
+	else
+		action.dest.pp_port = TPM_PP_CPU;
+	/* Add rule */
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
+					&match_key,
+					TPM_ACT_NUM_IS_1,/* One dest num, CPU or Drop */
+					&action,
+					TPM_POLICER_INVALID,
+					&qos,
+					&rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L3 MC default rule\n");
+
+	/* Add L2 MC default rule for IPVx, Check DIP or MAC */
+
+	/* IPV4 */
+	pkt_key.field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV4_PKT;
+	pkt_key.ipvx_add.ip_dst.ip_add.ipv4[0] = TPM_IPV4_MC_IP;
+	pkt_key.ipvx_add.ip_dst.ip_add_mask.ipv4[0] = TPM_IPV4_MC_IP_MASK;
+	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+	/* Get default rule action, drop or to CPU */
+	tpm_ret = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L2, &mc_def_act);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC default action failed\n");
+	if (mc_def_act == TPM_MC_FLOW_DEFAULT_DROP)
+		action.dest.pp_port = TPM_PP_DROP;
+	else
+		action.dest.pp_port = TPM_PP_CPU;
+
+	/* Add L2 MC default rule */
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
+					&match_key,
+					TPM_ACT_NUM_IS_1,/* One dest num, CPU or Drop */
+					&action,
+					TPM_POLICER_INVALID,
+					&qos,
+					&rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 IPv4 MC default rule\n");
+
+	if (ipv6_enable == TPM_IPV6_SUPPORTED) {
+		/* Check IPV6 DIP prefix */
+		pkt_key.field_match_bm = TPM_MATCH_IP_DST | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PKT;
+		pkt_key.ipvx_add.ip_dst.ip_add.ipv6[0] = TPM_IPV6_MC_IP;
+		pkt_key.ipvx_add.ip_dst.ip_add_mask.ipv6[0] = TPM_IPV6_MC_IP_MASK;
+		pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+		/* Add IPv6 default rule */
+		tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
+						&match_key,
+						TPM_ACT_NUM_IS_1,/* One dest num, CPU or Drop */
+						&action,
+						TPM_POLICER_INVALID,
+						&qos,
+						&rule_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 IPv6 MC default rule\n");
+	}
+
+	/* Add L2 MC default rule for non-ip MC */
+	pkt_key.field_match_bm = TPM_MATCH_ETH_DST;
+	pkt_key.eth_dst.eth_add[0] = TPM_MC_MAC;
+	pkt_key.eth_dst.eth_add_mask[0] = TPM_MC_MAC_MASK;
+	pkt_key.rule_type = TPM_MC_DEF_DIP_TYPE;
+
+	/* Add L2 MC default rule */
+	tpm_ret = tpm_mng_cap_entry_add(TPM_API_PRIVATE_MC_DS,
+					&match_key,
+					TPM_ACT_NUM_IS_1,/* One dest num, CPU or Drop */
+					&action,
+					TPM_POLICER_INVALID,
+					&qos,
+					&rule_id);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add L2 NON-IP MC default rule\n");
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	if (TPM_SW_MODE_INIT == switch_init) {
+		/* Block unknown IPV4 multicast packet */
+		for (sw_port = TPM_SW_PORT_0; sw_port <= TPM_SW_PORT_3; sw_port++) {
+			tpm_ret = tpm_sw_port_flood_control_mask_set(sw_port,
+								     TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST,
+								     TPM_MC_UNKNOWN_BLOCK);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to set switch flood mask\n");
+		}
+	}
+#endif
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cnm_qos_tbl_reserve
+*
+* DESCRIPTION: The routine reserve a pbit table for CnM.
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           If CLS does not want p-bit modification and there is no C4 entry is hit,
+*           the new p-bit value is unknown. In order to avoid the issue,
+*           one p-bit QoS table will be used to keep the p-bit AS-IS.
+*******************************************************************************/
+int tpm_mng_cnm_qos_tbl_reserve(void)
+{
+	int tpm_ret;
+	unsigned int cnm_support;
+	int pbit;
+	struct tpm_qos_tbl_act_t qos_pbit;
+
+	/* Clear qos_pbit */
+	TPM_MEMSET_ZERO(qos_pbit);
+
+	/* Check CnM is supported or not */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get CnM support value failed\n");
+
+	/* If CnM support, reserve the last pbit table entry, #63 */
+	if (cnm_support == TPM_CNM_SUPPORTED) {
+		for (pbit = 0; pbit <= TPM_MAX_PBITS_VALUE; pbit++) {
+			/* Kepp Pbit AS-IS */
+			qos_pbit.pbit = pbit;
+			/* Set the entry */
+			tpm_ret = tpm_qos_tbl_entry_set(TPM_QOS_PBIT,
+							TPM_MNG_CNM_PBIT_TBL,
+							pbit,
+							&qos_pbit);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "QoS table entry set failed\n");
+		}
+		/* Update reference count for the table reserved */
+		tpm_ret = tpm_qos_tbl_ref_cnt_update(TPM_QOS_PBIT,
+						     TPM_MNG_CNM_PBIT_TBL,
+						     TPM_QOS_TBL_REF_CNT_INC);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM pbit table reference counter update failed\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_engine_action_update
+*
+* DESCRIPTION: The routine update the engine rule with action and mod.
+*
+* INPUTS:
+*              rule_idx : rule logical index
+*              src_port : packet src port
+*              action   : new action
+*              pkt_mod  : new pkt mod
+* OUTPUTS:
+*              None.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_engine_action_update(unsigned int rule_idx,
+				 struct tpm_class_port_t *src_port,
+				 struct tpm_pkt_action_t *action,
+				 struct tpm_engine_pkt_mod_t *pkt_mod)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_engine_sram_t entry_sram;
+	struct tpm_c2_data_t c2_data;
+	struct tpm_c3_data_t c3_data;
+
+	IF_NULL(TPM_MNG_MOD, src_port);
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, pkt_mod);
+
+	TPM_MEMSET_ZERO(entry_sram);
+	TPM_MEMSET_ZERO(c2_data);
+	TPM_MEMSET_ZERO(c3_data);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* Read API data */
+	tpm_ret = tpm_db_mng_api_entry_get(rule_idx, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to access DB\n");
+
+	if (api_data->c2_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Get SRAM */
+		tpm_ret = tpm_c2_rule_sram_get(api_data->c2_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM get fail\n");
+	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Get C3 data */
+		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], &c3_data);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 entry get fail\n");
+		/* Get SRAM */
+		memcpy(&entry_sram.action, &c3_data.action, sizeof(struct tpm_engine_pkt_action_t));
+		memcpy(&entry_sram.qos_value, &c3_data.qos_value, sizeof(struct tpm_qos_value_t));
+		memcpy(&entry_sram.dup_info, &c3_data.dup_info, sizeof(struct tpm_duplicate_t));
+	}
+
+	if (TPM_PP_DROP == action->dest.pp_port) {
+		entry_sram.action.color_act = TPM_COLOR_ACTION_TYPE_RED_LOCK;
+	} else if (TPM_PP_CPU == action->dest.pp_port) {
+		entry_sram.action.frwd_act = TPM_FRWD_ACTION_TYPE_SWF_LOCK;
+		entry_sram.qos_value.q_high = tpm_mng_cpu_queue_high_get(src_port);
+	} else {
+		entry_sram.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+		entry_sram.action.color_act = ((action->color == TPM_COL_GREEN) ?
+					     TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK : TPM_COLOR_ACTION_TYPE_YELLOW);
+		if (TPM_PP_PMAC == action->dest.pp_port) {
+			if (action->dest.port_id & TPM_PORTID_SPEC) {
+				entry_sram.qos_value.gemp = (action->dest.port_id & (~TPM_PORTID_SPEC));
+				entry_sram.action.gemp_act = TPM_ACTION_TYPE_UPDT_LOCK;
+			}
+			entry_sram.qos_value.q_high = action->dest.pon_tx;
+		} else
+			entry_sram.qos_value.q_high = action->dest.pp_port + TPM_MNG_DST_PORT_G0_START;
+	}
+	/* Update pkt mod */
+	memcpy(&entry_sram.pkt_mod, pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+
+	/* Check rule on C2 or C3 */
+	if (api_data->c2_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Update SRAM */
+		tpm_ret = tpm_c2_rule_sram_update(api_data->c2_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM update fail\n");
+	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Update SRAM */
+		tpm_ret = tpm_c3_rule_sram_update(api_data->c3_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 SRAM update fail\n");
+	}
+
+	/* Update MNG DB */
+	memcpy(&api_data->action[0], action, sizeof(struct tpm_pkt_action_t));
+	memcpy(&api_data->pkt_mod[0], pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	tpm_ret = tpm_db_mng_api_entry_set(rule_idx, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to access DB\n");
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_entry_dup_update
+*
+* DESCRIPTION: The routine update the dup info of C2 or C3 entry.
+*
+* INPUTS:
+*              rule_idx: rule logical index
+*              dup_cnt : duplication count
+*              flow_id : pointer to MC table
+* OUTPUTS:
+*              None.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_entry_dup_update(unsigned int rule_idx, unsigned int dup_cnt, unsigned int flow_id)
+{
+	int tpm_ret;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	struct tpm_engine_sram_t entry_sram;
+	struct tpm_c2_data_t c2_data;
+	struct tpm_c3_data_t c3_data;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MNG_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MNG_MOD, dup_cnt, 0, TPM_MC_DUP_MAX);
+
+	TPM_MEMSET_ZERO(entry_sram);
+	TPM_MEMSET_ZERO(c2_data);
+	TPM_MEMSET_ZERO(c3_data);
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* Read API data */
+	tpm_ret = tpm_db_mng_api_entry_get(rule_idx, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to access DB\n");
+
+	/* Check rule on C2 or C3 */
+	if (api_data->c2_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Get SRAM */
+		tpm_ret = tpm_c2_rule_sram_get(api_data->c2_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM get fail\n");
+		/* Update Dup */
+		entry_sram.dup_info.flow_cnt = dup_cnt;
+		entry_sram.dup_info.flow_id = flow_id;
+		/* Update SRAM */
+		tpm_ret = tpm_c2_rule_sram_update(api_data->c2_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C2 SRAM update fail\n");
+	} else if (api_data->c3_rule_id[0] != TPM_DB_MNG_RULE_ID_INVALID) {
+		/* Get C3 data */
+		tpm_ret = tpm_c3_entry_get(api_data->c3_rule_id[0], &c3_data);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 entry get fail\n");
+		/* Get SRAM */
+		memcpy(&entry_sram.action, &c3_data.action, sizeof(struct tpm_engine_pkt_action_t));
+		memcpy(&entry_sram.qos_value, &c3_data.qos_value, sizeof(struct tpm_qos_value_t));
+		memcpy(&entry_sram.pkt_mod, &c3_data.pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+		/* Update Dup */
+		entry_sram.dup_info.flow_cnt = dup_cnt;
+		entry_sram.dup_info.flow_id = flow_id;
+		/* Update SRAM */
+		tpm_ret = tpm_c3_rule_sram_update(api_data->c3_rule_id[0], &entry_sram);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "C3 SRAM update fail\n");
+	}
+
+	/* Update MNG DB */
+	api_data->dup_info.flow_cnt = dup_cnt;
+	api_data->dup_info.flow_id = flow_id;
+	tpm_ret = tpm_db_mng_api_entry_set(rule_idx, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "fail to access DB\n");
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_misc_cfg_init
+*
+* DESCRIPTION: The routine configures MISC items.
+*
+* INPUTS:
+*              None
+* OUTPUTS:
+*              None.
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_misc_cfg_init(void)
+{
+	int tpm_ret;
+	int port;
+	int reg_val;
+	int reg_val_read_back;
+	int bad_chksum_action;
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	enum tpm_gmac_conn_t gmac_con;
+	int gport_id;
+	unsigned int sw_init, sw_port = TPM_GMAC0_CONNECT_SW_PORT;
+
+	/* Clear swicth vlan tunnel on CPU port and GMAC1 port */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &sw_init);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get switch init status failed\n");
+	if (TPM_SW_MODE_INIT == sw_init) {
+		for (gport_id = TPM_ENUM_GMAC_0; gport_id <= TPM_ENUM_GMAC_1; gport_id++) {
+			/* Get GMAC Connect info */
+			tpm_ret = tpm_db_gmac_conn_get(gport_id, &gmac_con);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GMAC%d connect info get failed\n", gport_id);
+			if (gmac_con == TPM_GMAC_CON_SWITCH_4)
+				sw_port = TPM_GMAC1_CONNECT_SW_PORT;
+			else if (gmac_con == TPM_GMAC_CON_SWITCH_6)
+				sw_port = TPM_GMAC0_CONNECT_SW_PORT;
+			tpm_ret = mv_switch_vlan_tunnel_set(sw_port, TPM_VLAN_TUNNEL_FALSE);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch vlan tunnel set on port(%d) failed\n", sw_port);
+		}
+	}
+#endif
+
+	/* get default action for bad checksum packets */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_BAD_CHKSUM_ACTION, &bad_chksum_action);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get bad checksum action failed\n");
+
+	for (port = TPM_ENUM_GMAC_0; port < TPM_MAX_GMAC; port++) {
+		reg_val = mvPp2RdReg(MV_PP2_RX_CTRL_REG(port));
+		if (TPM_BAD_CHKSUM_DROP == bad_chksum_action)
+			reg_val |= MV_PP2_RX_DROP_ON_CSUM_ERR_MASK;
+		else
+			reg_val &= (~MV_PP2_RX_DROP_ON_CSUM_ERR_MASK);
+
+		reg_val_read_back = mvPp2WrReg(MV_PP2_RX_CTRL_REG(port), reg_val);
+		IF_ERROR_STR(TPM_MNG_MOD, (reg_val_read_back != reg_val), "set bad checksum action failed\n");
+	}
+
+	/* Enable MH on loopback port */
+	reg_val = mvPp2RdReg(MV_PP2_MH_REG(TPM_ENUM_GMAC_LPK));
+	reg_val |= MV_PP2_MH_EN_MASK;
+	reg_val_read_back = mvPp2WrReg(MV_PP2_MH_REG(TPM_ENUM_GMAC_LPK), reg_val);
+	IF_ERROR_STR(TPM_MNG_MOD, (reg_val_read_back != reg_val), "Lpk port MH set failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_reset
+*
+* DESCRIPTION: The routine restarts the MNG module
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_reset(void)
+{
+	int tpm_ret;
+	int arr_len;
+
+	tpm_db_mng_clear();
+
+	/* configures MISC items */
+	tpm_ret = tpm_mng_misc_cfg_init();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "configures MISC items failed\n");
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* add cpu_q_h cap */
+	tpm_ret = tpm_mng_cpu_qhigh_cap_add();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CPU_Q CAP failed\n");
+#endif
+	/* Reserve QoS pbit table for CnM */
+	tpm_ret = tpm_mng_cnm_qos_tbl_reserve();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "reserve pbit table for CnM failed");
+
+	/* add cnm pbit keep as-is cap */
+	tpm_ret = tpm_mng_cnm_pbit_asis_cap_add();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CnM pbit AS-IS CAP failed\n");
+
+	/* add cnm cap */
+	tpm_ret = tpm_mng_cnm_cap_add();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add CnM CAP failed");
+
+	/* init tpm_mng_flow_cap_conf */
+	tpm_ret = tpm_mng_pri_cap_add();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add PRI CAP failed\n");
+
+	/* add multicast cap */
+	tpm_ret = tpm_mng_mc_cap_add();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add MC CAP failed\n");
+
+	/* add all public caps from user */
+	TPM_MEMSET_ZERO(g_cap_arr);
+	tpm_ret = tpm_db_mng_pub_cap_get(g_cap_arr, &arr_len);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "GET PUB CAP failed\n");
+
+	tpm_ret = tpm_mng_cap_add(g_cap_arr, arr_len);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Add PUB CAP failed\n");
+
+	/* merge caps */
+	tpm_ret = tpm_mng_cap_merge();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "merge caps failed\n");
+
+	/* create default flow table */
+	tpm_ret = tpm_mng_def_flow_tbl_create();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create flow_tbl failed\n");
+
+	/* add C2 default entries */
+	tpm_ret = tpm_mng_def_c2_entry_create();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create C2 default entries failed\n");
+
+	/* add C3 default entries */
+	tpm_ret = tpm_mng_def_c3_entry_create();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create C3 default entries failed\n");
+
+	tpm_ret = tpm_mng_unused_lkp_dcod_to_cpu();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "create default rules for non handled LUID entries failed\n");
+
+	/* enable decode table */
+	tpm_ret = tpm_mng_decode_tbl_enable();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "enable decode table failed\n");
+
+	/* Set default MC */
+	tpm_ret = tpm_mng_mc_default_set();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "multicast default set failed\n");
+
+	/* set C4 ruleSet conf */
+	tpm_ret = tpm_mng_c4_ruleset_init();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set C4 ruleSet conf failed\n");
+
+	/* select the source of the GEM port ID */
+	tpm_ret = tpm_mng_upstream_gem_port_src_select(TPM_GEM_PORT_FROM_CLASSIFIER);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set C4 ruleSet conf failed\n");
+
+	return TPM_OK;
+}
+
+/* ############## Multicast Section ############### */
+
+/*******************************************************************************
+* tpm_mng_mc_flow_add_check
+*
+* DESCRIPTION: The routine wil check input parameters of multicast API.
+*
+* INPUTS:
+*           match_key   - multicast match key
+*           num_dest    - number of destination port or action
+*           action      - rule action array
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_flow_add_check(struct tpm_pkt_key_t *match_key,
+			      unsigned short num_dest,
+			      struct tpm_pkt_action_t action[])
+{
+	int tpm_ret;
+
+	/* Input parameter check */
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+
+	if (num_dest == 0 || num_dest > TPM_ACT_NUM_MAX) {
+		tpm_ret = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invlaid dest number(%d)\n", num_dest);
+	}
+
+	/* L3 check */
+	if (match_key->field_match_bm & (TPM_MATCH_IP_DST | TPM_MATCH_IP_SRC)) {
+		if ((!(match_key->field_match_bm & (TPM_MATCH_IPV4_PKT | TPM_MATCH_IPV6_PKT))) ||
+		    ((match_key->field_match_bm & TPM_MATCH_IPV4_PKT) &&
+		     (match_key->field_match_bm & TPM_MATCH_IPV6_PKT))) {
+			tpm_ret = TPM_BAD_PARAM;
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invlaid key match bm(0x%x)\n", match_key->field_match_bm);
+		}
+	}
+
+	return TPM_OK;
+}
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+/*******************************************************************************
+* tpm_mng_mc_switch_atu_set
+*
+* DESCRIPTION: The routine add or del ATU entry from swicth
+*
+* INPUTS:
+*           match_key    - multicast match key
+*           num_dest     - number of destination port or action
+*           action       - rule action array
+*           orig_port_bm - Original port bit map of ATU entry
+*           api_op       - Ops, add or delete or update
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_switch_atu_set(struct tpm_pkt_key_t *match_key,
+			      unsigned short num_dest,
+			      struct tpm_pkt_action_t action[],
+			      unsigned char orig_port_bm,
+			      enum tpm_mng_api_op_t api_op)
+{
+	int tpm_ret;
+	unsigned int dst_port, i;
+	unsigned char port_bm = 0, add_bm = 0, del_bm = 0, keep_bm = 0;
+	unsigned int ref_cnt = 0;
+	unsigned int port_id_tmp;
+	struct tpm_db_mng_mc_atu atu_tmp;
+	unsigned char gmac_addr[MAC_ADDR_SIZE] = {0};
+
+	/* Para check */
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	if (num_dest > TPM_ACT_NUM_MAX) {
+		tpm_ret = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid dest number(%d)\n", num_dest);
+	}
+
+	/* Configure switch ATU */
+	/* Get GDMAC */
+	if (match_key->field_match_bm & TPM_MATCH_ETH_DST) {
+		memcpy(gmac_addr, match_key->eth_dst.eth_add, MAC_ADDR_SIZE);
+	} else if (match_key->field_match_bm & TPM_MATCH_IP_DST) {
+		/* DIP -> GDMAC */
+		if (match_key->field_match_bm & TPM_MATCH_IPV4_PKT) {/* IPv4 */
+			gmac_addr[0] = 0x01;
+			gmac_addr[1] = 0x00;
+			gmac_addr[2] = 0x5E;
+			gmac_addr[3] = match_key->ipvx_add.ip_dst.ip_add.ipv4[1] & TPM_IGMP_MAC_ADDR_MASK;
+			gmac_addr[4] = match_key->ipvx_add.ip_dst.ip_add.ipv4[2];
+			gmac_addr[5] = match_key->ipvx_add.ip_dst.ip_add.ipv4[3];
+		} else if (match_key->field_match_bm & TPM_MATCH_IPV6_PKT) {/* IPv6 */
+			gmac_addr[0] = 0x33;
+			gmac_addr[1] = 0x33;
+			gmac_addr[2] = match_key->ipvx_add.ip_dst.ip_add.ipv6[12];
+			gmac_addr[3] = match_key->ipvx_add.ip_dst.ip_add.ipv6[13];
+			gmac_addr[4] = match_key->ipvx_add.ip_dst.ip_add.ipv6[14];
+			gmac_addr[5] = match_key->ipvx_add.ip_dst.ip_add.ipv6[15];
+		} else {
+			tpm_ret = TPM_BAD_PARAM;
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid matcgh bm(0x%x)\n", match_key->field_match_bm);
+		}
+	}
+
+	/* Get port bitmap */
+	for (dst_port = 0; dst_port < num_dest; dst_port++) {
+		/* check dst is switch port */
+		if (!(action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+			continue;
+		port_bm |= (1 << (action[dst_port].dest.port_id & (~TPM_PORTID_SPEC)));
+	}
+
+	add_bm = (~orig_port_bm) & port_bm;
+	del_bm = (~port_bm) & orig_port_bm;
+	keep_bm = port_bm & orig_port_bm;
+
+	if (api_op != TPM_MNG_API_DEL) {
+		/* Check the MAC is added into ATU by other rules */
+		for (i = 0; i < TPM_NUM_MAX_UNI_PORTS; i++) {
+			tpm_ret = tpm_db_mng_mc_atu_get(i,
+							gmac_addr,
+							&atu_tmp);
+			if (tpm_ret == TPM_OK) {/* Found the MAC on the port */
+				port_bm |= (1 << i);
+				keep_bm |= (1 << i);
+			}
+		}
+	}
+
+	if (api_op == TPM_MNG_API_ADD) {
+		/* Add GDMAC to ATU */
+		tpm_ret = tpm_sw_port_mac_address_add(port_bm,
+						      gmac_addr,
+						      0,
+						      TPM_SW_MAC_ADDR_STATIC/*TPM_SW_MAC_ADDR_MULTICAST*/);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch multi MAC add failed\n");
+		/* Record ATU to MNG DB */
+		for (dst_port = 0; dst_port < num_dest; dst_port++) {
+			if (!(action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+				continue;
+			port_id_tmp = action[dst_port].dest.port_id & (~TPM_PORTID_SPEC);
+			tpm_ret = tpm_db_mng_mc_atu_add(port_id_tmp,
+							gmac_addr);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Set ATU to MNG DB fail\n");
+		}
+	} else if (api_op == TPM_MNG_API_UPDATE) {
+		/* Add GDMAC to ATU */
+		tpm_ret = tpm_sw_port_mac_address_add((keep_bm | add_bm),
+						      gmac_addr,
+						      0,
+						      TPM_SW_MAC_ADDR_STATIC/*TPM_SW_MAC_ADDR_MULTICAST*/);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch multi MAC add failed\n");
+		for (port_id_tmp = 0; port_id_tmp <= TPM_NUM_MAX_UNI_PORTS; port_id_tmp++) {
+			if ((1 << port_id_tmp) & add_bm) {
+				tpm_ret = tpm_db_mng_mc_atu_add(port_id_tmp,
+								gmac_addr);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Set ATU to MNG DB fail\n");
+			}
+			/* Delete related port */
+			if ((1 << port_id_tmp) & del_bm) {
+				tpm_ret = tpm_db_mng_mc_atu_del(port_id_tmp,
+								gmac_addr,
+								&ref_cnt);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG DB mc ATU Del failed\n");
+				if (!ref_cnt) {/* Only ref_cnt is 0, del it from switch */
+					tpm_ret = tpm_sw_port_mac_address_del(port_id_tmp,
+									      gmac_addr,
+									      0);
+					IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch multi MAC Del failed\n");
+				}
+			}
+		}
+	} else {
+		/* Del GDMAC from ATU */
+		for (dst_port = 0; dst_port < num_dest; dst_port++) {
+			/* check dst is switch port */
+			if (!(action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+				continue;
+			port_id_tmp = action[dst_port].dest.port_id & (~TPM_PORTID_SPEC);
+			tpm_ret = tpm_db_mng_mc_atu_del(port_id_tmp,
+							gmac_addr,
+							&ref_cnt);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG DB mc ATU Del failed\n");
+			if (!ref_cnt) {/* Only ref_cnt is 0, del it from switch */
+				tpm_ret = tpm_sw_port_mac_address_del(port_id_tmp,
+								      gmac_addr,
+								      0);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch multi MAC Del failed\n");
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_switch_vtu_set
+*
+* DESCRIPTION: The routine add or del VTU entry from swicth
+*
+* INPUTS:
+*           match_key     - multicast match key
+*           num_dest      - number of destination port or action
+*           action        - rule action array
+*           orig_api_data - original API data, used for update.
+*           api_op        - Ops, add or delete
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_switch_vtu_set(struct tpm_pkt_key_t *match_key,
+			      unsigned short num_dest,
+			      struct tpm_pkt_action_t action[],
+			      struct tpm_db_mng_api_data_t *orig_api_data,
+			      enum tpm_mng_api_op_t api_op)
+{
+	int tpm_ret;
+	unsigned int dst_port;
+	unsigned int vtu_need_flag = 0;
+	unsigned int vid_tmp, port_id_tmp;
+
+	/* Para check */
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	if (api_op == TPM_MNG_API_UPDATE)
+		IF_NULL(TPM_MNG_MOD, orig_api_data);
+
+	if (num_dest > TPM_ACT_NUM_MAX) {
+		tpm_ret = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid dest number(%d)\n", num_dest);
+	}
+
+	/* Configure Switch VTU */
+	/* VLAN Ops corresponding engress mode
+	*  VLAN NOOP - VTU no care
+	*  VLAN MOD  - AS-IS or KEEP VLAN
+	*  VLAN DEL  - done in PP, no care
+	*  VLAN INS  - AS-IS or KEEP VLAN
+	*/
+	/* Hanlde update first */
+	if (api_op == TPM_MNG_API_UPDATE) {
+		for (dst_port = 0; dst_port < orig_api_data->num_dest; dst_port++) {
+			/* check dst is switch port */
+			if (!(orig_api_data->action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+				continue;
+			port_id_tmp = orig_api_data->action[dst_port].dest.port_id & (~TPM_PORTID_SPEC);
+			if (action[dst_port].mod.mod_bm & TPM_VLAN_MOD) {
+				/* VLAN insert or translation */
+				if ((orig_api_data->action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_MOD ||
+				     orig_api_data->action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_INS) &&
+				    orig_api_data->action[dst_port].mod.vlan_op.out_vlan.vid & TPM_VID_UPDATE) {
+					vid_tmp = orig_api_data->action[dst_port].mod.vlan_op.out_vlan.vid &
+						  TPM_VID_MASK;
+					vtu_need_flag++;
+				}
+			}
+			/* check vid in key */
+			if (((orig_api_data->action[dst_port].mod.mod_bm & TPM_VLAN_MOD) &&
+			    (orig_api_data->action[dst_port].mod.vlan_op.oper == TPM_VLANOP_NOOP ||
+			     orig_api_data->action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_DEL)) ||
+			    (!(orig_api_data->action[dst_port].mod.mod_bm & TPM_VLAN_MOD))) {
+				if (match_key->field_match_bm & TPM_MATCH_VID_OUTER) {
+					/* Untag, no relevant with VTU, need switch fallback mode */
+					/* Taged, no care VID, no need to config VTU, need switch fallback mode */
+					if (match_key->out_vid & TPM_SPEC_VID) {
+						/* Specific VID */
+						vid_tmp = match_key->out_vid & (~TPM_SPEC_VID) & TPM_VID_MASK;
+						vtu_need_flag++;
+					}
+				}
+			}
+			/* Delete original VTU */
+			if (vtu_need_flag) {
+				/* Del record from MNG DB */
+				tpm_ret = tpm_db_mng_mc_vtu_del(port_id_tmp,
+								vid_tmp);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Del VTU in DB fail\n");
+				tpm_ret = tpm_sw_port_vlan_del(port_id_tmp,
+							       vid_tmp,
+							       vid_tmp);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Switch vlan delete fail\n");
+			}
+		}
+	}
+
+	/* Handle new action */
+	for (dst_port = 0; dst_port < num_dest; dst_port++) {
+		/* check dst is switch port */
+		if (!(action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+			continue;
+		port_id_tmp = action[dst_port].dest.port_id & (~TPM_PORTID_SPEC);
+		if (action[dst_port].mod.mod_bm & TPM_VLAN_MOD) {
+			/* VLAN insert or translation */
+			if ((action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_MOD ||
+			     action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_INS) &&
+			    action[dst_port].mod.vlan_op.out_vlan.vid & TPM_VID_UPDATE) {
+				vid_tmp = action[dst_port].mod.vlan_op.out_vlan.vid & TPM_VID_MASK;
+				vtu_need_flag++;
+			}
+		}
+		/* add vid in key */
+		if (((action[dst_port].mod.mod_bm & TPM_VLAN_MOD) &&
+		    (action[dst_port].mod.vlan_op.oper == TPM_VLANOP_NOOP ||
+		     action[dst_port].mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_DEL)) ||
+		    (!(action[dst_port].mod.mod_bm & TPM_VLAN_MOD))) {
+			if (match_key->field_match_bm & TPM_MATCH_VID_OUTER) {
+				/* Untag, no relevant with VTU, need switch fallback mode */
+				/* Taged, no care VID, no need to config VTU, need switch fallback mode */
+				if (match_key->out_vid & TPM_SPEC_VID) {
+					/* Specific VID */
+					vid_tmp = match_key->out_vid & (~TPM_SPEC_VID) & TPM_VID_MASK;
+					vtu_need_flag++;
+				}
+			}
+		}
+		/* Add VTU */
+		if (vtu_need_flag) {
+			if (api_op == TPM_MNG_API_ADD) {
+				tpm_ret = tpm_sw_port_vlan_set(port_id_tmp,
+							       vid_tmp,
+							       vid_tmp,
+							       TPM_SW_VLAN_EGRESS_KEEP_VLAN);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Switch vlan set fail\n");
+				/* Record to DB */
+				tpm_ret = tpm_db_mng_mc_vtu_set(port_id_tmp,
+								vid_tmp,
+								TPM_SW_VLAN_EGRESS_KEEP_VLAN);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Set VTU to DB fail\n");
+			} else {
+				/* Del record from MNG DB */
+				tpm_ret = tpm_db_mng_mc_vtu_del(port_id_tmp,
+								vid_tmp);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Del VTU in DB fail\n");
+				tpm_ret = tpm_sw_port_vlan_del(port_id_tmp,
+							       vid_tmp,
+							       vid_tmp);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Switch vlan delete fail\n");
+			}
+			vtu_need_flag = 0;
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_switch_set
+*
+* DESCRIPTION: The routine set swictch according to MC.
+*
+* INPUTS:
+*           match_key     - multicast match key
+*           num_dest      - number of destination port or action
+*           action        - rule action array
+*           orig_api_data - Original API data
+*           api_op        - Ops, add or delete or update
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_switch_set(struct tpm_pkt_key_t		*match_key,
+			  unsigned short		num_dest,
+			  struct tpm_pkt_action_t	action[],
+			  struct tpm_db_mng_api_data_t  *orig_api_data,
+			  enum tpm_mng_api_op_t		api_op)
+{
+	int tpm_ret;
+	unsigned int switch_init, sw_handle, dst_port;
+	unsigned char ori_port_bm = 0;
+
+	/* Para check */
+	IF_NULL(TPM_MNG_MOD, match_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	if (api_op == TPM_MNG_API_UPDATE)
+		IF_NULL(TPM_MNG_MOD, orig_api_data);
+
+	if (num_dest > TPM_ACT_NUM_MAX) {
+		tpm_ret = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Invalid dest number(%d)\n", num_dest);
+	}
+
+	/* Check switch handler, handle by user or API */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_SW_HANDLE, &sw_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get switch handler failed\n");
+	if (sw_handle == TPM_MC_SW_CFG_FALSE)
+		return TPM_OK;
+
+	/* Check switch init status, enable or disable */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &switch_init);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get switch init status failed\n");
+	if (TPM_SW_MODE_NOT_INIT == switch_init) {
+		/* Switch is not initialized, user will config it themselves, return OK directly */
+		TPM_OS_DEBUG(TPM_MNG_MOD, "Internal switch is not initialized\n");
+		return TPM_OK;
+	}
+
+	/* Get original port bitmap */
+	if (api_op == TPM_MNG_API_UPDATE) {
+		for (dst_port = 0; dst_port < orig_api_data->num_dest; dst_port++) {
+			/* check dst is switch port */
+			if (!(orig_api_data->action[dst_port].dest.port_id & TPM_PORTID_SPEC))
+				continue;
+			ori_port_bm |= (1 << (orig_api_data->action[dst_port].dest.port_id & (~TPM_PORTID_SPEC)));
+		}
+	}
+
+	/* Configure switch ATU */
+	tpm_ret = tpm_mng_mc_switch_atu_set(match_key,
+					    num_dest,
+					    action,
+					    ori_port_bm,
+					    api_op);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch ATU set failed\n");
+
+	/* Configure Switch VTU */
+	tpm_ret = tpm_mng_mc_switch_vtu_set(match_key,
+					    num_dest,
+					    action,
+					    orig_api_data,
+					    api_op);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "switch VTU set failed\n");
+
+	return TPM_OK;
+}
+#else/* No swicth, it is empty function, return OK */
+int tpm_mng_mc_switch_set(struct tpm_pkt_key_t		*match_key,
+			  unsigned short		num_dest,
+			  struct tpm_pkt_action_t	action[],
+			  struct tpm_db_mng_api_data_t  *orig_api_data,
+			  enum tpm_mng_api_op_t		api_op)
+{
+	return TPM_OK;
+}
+#endif
+
+/*******************************************************************************
+* tpm_mng_mc_entry_update
+*
+* DESCRIPTION: The routine update mc flow rule.
+*
+* INPUTS:
+*           src_port    - src port
+*           rule_index  - original MC rule index
+*           num_dest    - Number of Destination Action, meaning number of packet replications.
+*           action      - Ecah packet copy's action needed, such as dest and modfication.
+*           old_api_data - used as local param, so the stack is not so big.
+*
+* OUTPUTS:
+*           rule_index  - new rule index
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static int tpm_mng_mc_entry_update(const struct tpm_class_port_t *src_port,
+				   unsigned int			*rule_index,
+				   unsigned short		num_dest,
+				   struct tpm_pkt_action_t	*action,
+				   struct tpm_db_mng_api_data_t *old_api_data)
+{
+	int tpm_ret;
+	struct tpm_mng_pkt_key_t mng_match_key;
+	struct tpm_mc_tbl_entry_t mct_entry[TPM_ACT_NUM_MAX];
+	struct tpm_pkt_action_t temp_act;
+	struct tpm_engine_pkt_mod_t pkt_mod[TPM_ACT_NUM_MAX];
+	struct tpm_engine_pkt_mod_t old_pkt_mod[TPM_ACT_NUM_MAX];
+	struct tpm_engine_pkt_mod_t temp_mod;
+	unsigned int old_num_dest;
+	unsigned int free_cnt = 0;
+	unsigned int new_dup_cnt, new_flow_id;
+	unsigned int new_rule_idx;
+	bool root_act_found = false;
+	unsigned char merge_act[TPM_ACT_NUM_MAX][TPM_ACT_NUM_MAX];
+	int loop, i, j;
+	unsigned short uni_bm = 0;
+	int api_type = 0;
+
+	IF_NULL(TPM_MNG_MOD, rule_index);
+	IF_NULL(TPM_MNG_MOD, action);
+
+	/* Get MC table free entry count */
+	free_cnt = tpm_mc_free_entry_cnt_get();
+
+	/* Get new action dup count */
+	tpm_ret = tpm_mng_dup_cnt_calc(num_dest, action, &new_dup_cnt, merge_act);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "New action dup count get fail\n");
+
+	memset(old_api_data, 0, sizeof(struct tpm_db_mng_api_data_t));
+	/* Get original dup info */
+	tpm_ret = tpm_db_mng_api_entry_get(*rule_index, old_api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "api_entry get fail wirh rule id[%d]\n", *rule_index);
+
+	/* Check HW MC table available resource */
+	if (new_dup_cnt > (free_cnt + old_api_data->dup_info.flow_cnt)) {
+		tpm_ret = TPM_NO_RESOURCE;
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "No enough MC table entry to update\n");
+	}
+
+	TPM_MEMSET_ZERO(mng_match_key);
+	mng_match_key.pkt_key = &old_api_data->match_key;
+
+	/* Get cap type */
+	if (old_api_data->match_key.port.port_type == TPM_CLASS_SWITCH_PORT_BM ||
+	    (old_api_data->match_key.port.port_type == TPM_CLASS_PP_PORT_BM &&
+	     old_api_data->match_key.port.class_port != TPM_PP_PMAC))
+		api_type = TPM_API_PRIVATE_MC_US;
+	else
+		api_type = TPM_API_PRIVATE_MC_DS;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "API type[%d]\n", api_type);
+
+	/* Try to create new rule to replace original one */
+	if (new_dup_cnt <= free_cnt) {
+		/* Create new rule */
+		tpm_ret = tpm_mng_cap_entry_add(api_type,
+						&mng_match_key,
+						num_dest,
+						action,
+						TPM_POLICER_INVALID,
+						&old_api_data->qos,
+						&new_rule_idx);
+		if (tpm_ret == TPM_OK) {
+			TPM_OS_DEBUG(TPM_MNG_MOD, "Replace Original Multicast rule with new one\n");
+			/* Delete Original rule */
+			tpm_ret = tpm_mng_cap_entry_del(api_type, *rule_index);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Original rule release fail\n");
+			/* Return new rule index */
+			*rule_index = new_rule_idx;
+			return TPM_OK;
+		}
+	}
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "Update Original Multicast rule[%d]\n", *rule_index);
+
+	/* Build modification info */
+	TPM_MEMSET_ZERO(pkt_mod);
+	for (loop = 0; loop < num_dest; loop++) {
+		if (merge_act[loop][0] == TPM_MNG_MERGE_INVALID)
+			continue;
+		/* Reuse original mod */
+		for (i = 0; i < old_api_data->num_dest; i++) {
+			/* Check Mod info */
+			if (!memcmp(&old_api_data->action[i].mod,
+				&action[merge_act[loop][0]].mod,
+				sizeof(struct tpm_pkt_mod_t))) {
+				uni_bm = 0;
+				for (j = 0; j < num_dest; j++) {
+					if (merge_act[loop][j] != 0xFF)
+						uni_bm |= (1 << action[merge_act[loop][j]].dest.port_id);
+						memcpy(&pkt_mod[merge_act[loop][j]],
+						&old_api_data->pkt_mod[i],
+						sizeof(struct tpm_engine_pkt_mod_t));
+				}
+				/* Update MH BM */
+				tpm_ret = tpm_mng_dst_port_bm_update(old_api_data->pkt_mod[i].mod_data_idx, uni_bm);
+				IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MH BM update fail\n");
+				break;
+			}
+		}
+		/* Need create new mod */
+		if (i == old_api_data->num_dest) {
+			/* Create new mod */
+			tpm_ret = tpm_mng_mod_create(&mng_match_key,
+						     1,
+						     &action[merge_act[loop][0]],
+						     TPM_QOS_NONE,
+						     &pkt_mod[merge_act[loop][0]]);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Mod create fail\n");
+			uni_bm = 1 << action[merge_act[loop][0]].dest.port_id;
+			for (j = 1; j < num_dest; j++) {
+				if (merge_act[loop][j] != 0xFF) {
+					uni_bm |= (1 << action[merge_act[loop][j]].dest.port_id);
+					memcpy(&pkt_mod[merge_act[loop][j]],
+					       &pkt_mod[merge_act[loop][0]],
+					       sizeof(struct tpm_engine_pkt_mod_t));
+				}
+			}
+			/* Update MH BM */
+			tpm_ret = tpm_mng_dst_port_bm_update(pkt_mod[merge_act[loop][0]].mod_data_idx, uni_bm);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MH BM update fail\n");
+		}
+	}
+
+	/* Check root action */
+	for (loop = 0; loop < num_dest; loop++) {
+		if (merge_act[loop][0] == 0xFF)
+			continue;
+		/* Check Mod info */
+		if (memcmp(&old_api_data->action[0].mod,
+			   &action[merge_act[loop][0]].mod,
+			   sizeof(struct tpm_pkt_mod_t)))
+			continue;
+		/* Check color */
+		if (old_api_data->action[0].color != action[merge_act[loop][0]].color)
+			continue;
+		/* Check dest */
+		if ((old_api_data->action[0].dest.pp_port == action[merge_act[loop][0]].dest.pp_port) &&
+		    (old_api_data->action[0].dest.pon_tx == action[merge_act[loop][0]].dest.pon_tx) &&
+		    (old_api_data->action[0].dest.pp_queue == action[merge_act[loop][0]].dest.pp_queue))
+			break;
+	}
+
+	/* Root action need keep, only need to update UNI bitmap in PME private data */
+	if (loop < num_dest) {
+		root_act_found = true;
+		TPM_OS_DEBUG(TPM_MNG_MOD, "Root action keep\n");
+		/* Adjust the order of action and pkt mod */
+		if (loop) {
+			memcpy(&temp_act, &action[merge_act[loop][0]], sizeof(struct tpm_pkt_action_t));
+			memcpy(&action[merge_act[loop][0]], &action[0], sizeof(struct tpm_pkt_action_t));
+			memcpy(&action[0], &temp_act, sizeof(struct tpm_pkt_action_t));
+
+			memcpy(&temp_mod, &pkt_mod[merge_act[loop][0]], sizeof(struct tpm_engine_pkt_mod_t));
+			memcpy(&pkt_mod[merge_act[loop][0]], &pkt_mod[0], sizeof(struct tpm_engine_pkt_mod_t));
+			memcpy(&pkt_mod[0], &temp_mod, sizeof(struct tpm_engine_pkt_mod_t));
+		}
+	} else {
+		/* Root action will be removed, and find a new act replace it */
+		/* Check dup action, to find a act not in original act array */
+		for (loop = 0; loop < num_dest; loop++) {
+			if (merge_act[loop][0] == 0xFF)
+				continue;
+			for (i = 0; i < old_api_data->num_dest; i++) {
+				/* Check Mod info */
+				if ((!memcmp(&old_api_data->action[i].mod,
+					     &action[merge_act[loop][0]].mod,
+					     sizeof(struct tpm_pkt_mod_t))) &&
+				    (old_api_data->action[i].color == action[merge_act[loop][0]].color) &&
+				    ((old_api_data->action[i].dest.pp_port ==
+				      action[merge_act[loop][0]].dest.pp_port) &&
+				     (old_api_data->action[i].dest.pon_tx == action[merge_act[loop][0]].dest.pon_tx) &&
+				     (old_api_data->action[i].dest.pp_queue ==
+				      action[merge_act[loop][0]].dest.pp_queue)))
+					break;
+			}
+			if (i == old_api_data->num_dest)
+				break;
+		}
+		if (loop < num_dest) {
+			/* New action found, adjust the order of action and pkt_mod */
+			memcpy(&temp_act, &action[merge_act[loop][0]], sizeof(struct tpm_pkt_action_t));
+			memcpy(&action[merge_act[loop][0]], &action[0], sizeof(struct tpm_pkt_action_t));
+			memcpy(&action[0], &temp_act, sizeof(struct tpm_pkt_action_t));
+
+			memcpy(&temp_mod, &pkt_mod[merge_act[loop][0]], sizeof(struct tpm_engine_pkt_mod_t));
+			memcpy(&pkt_mod[merge_act[loop][0]], &pkt_mod[0], sizeof(struct tpm_engine_pkt_mod_t));
+			memcpy(&pkt_mod[0], &temp_mod, sizeof(struct tpm_engine_pkt_mod_t));
+		}
+
+	}
+
+	/* Build MCT entry */
+	TPM_MEMSET_ZERO(mct_entry);
+	tpm_ret = tpm_mng_mct_entry_build(src_port, num_dest, action, pkt_mod, mct_entry, &new_dup_cnt);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG MCT entry build fail\n");
+	if (root_act_found == false) {
+		/* Update SRAM of root rule with action[0] and pkt_mod[0] */
+		tpm_ret = tpm_mng_engine_action_update(old_api_data->api_rule_id,
+						       &old_api_data->match_key.port,
+						       &action[0],
+						       &pkt_mod[0]);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG action update fail\n");
+	}
+	/* Update dup list */
+	if (old_api_data->dup_info.flow_cnt) {
+		tpm_ret = tpm_mc_dup_list_update(old_api_data->api_rule_id,
+						 old_api_data->dup_info.flow_id,
+						 new_dup_cnt,
+						 mct_entry,
+						 tpm_mng_entry_dup_update,
+						 tpm_mng_dst_port_bm_update);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG dup list update fail\n");
+	} else {
+		/* Create a new dup list */
+		tpm_ret = tpm_mc_dup_list_create(new_dup_cnt,
+						 mct_entry,
+						 &new_flow_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Dup list create fail\n");
+		/* Update it to root rule */
+		tpm_ret = tpm_mng_entry_dup_update(old_api_data->api_rule_id,
+						   new_dup_cnt,
+						   new_flow_id);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Update dup info for rule(%d) fail\n", old_api_data->api_rule_id);
+	}
+
+	/* Record original info */
+	for (loop = 0; loop < old_api_data->num_dest; loop++)
+		memcpy(&old_pkt_mod[loop], &old_api_data->pkt_mod[loop], sizeof(struct tpm_engine_pkt_mod_t));
+
+	old_num_dest = old_api_data->num_dest;
+
+	/* Move the last entry in dup list to root action */
+	tpm_ret = tpm_db_mng_api_entry_get(*rule_index, old_api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "api_entry get fail wirh rule id[%d]\n", *rule_index);
+
+	/* Update num dest and pkt mod to DB */
+	old_api_data->num_dest = num_dest;
+	for (i = 0; i < num_dest; i++) {
+		memcpy(&old_api_data->action[i], &action[i], sizeof(struct tpm_pkt_action_t));
+		memcpy(&old_api_data->pkt_mod[i], &pkt_mod[i], sizeof(struct tpm_engine_pkt_mod_t));
+	}
+	tpm_ret = tpm_db_mng_api_entry_set(*rule_index, old_api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "api_entry set fail wirh rule id[%d]\n", *rule_index);
+
+	/* Release pkt mod which no used any more */
+	for (loop = 0; loop < old_num_dest; loop++) {
+		if (loop) {
+			/* Avoid repeadly handle */
+			for (i = 0; i < loop; i++) {
+				if (!memcmp(&old_pkt_mod[i],
+					    &old_pkt_mod[loop],
+					    sizeof(struct tpm_engine_pkt_mod_t)))
+					break;
+			}
+			if (i < loop)
+				continue;
+		}
+		if (old_pkt_mod[loop].mod_cmd_idx) {
+			for (j = 0; j < num_dest; j++) {
+				if (!memcmp(&old_pkt_mod[loop],
+					    &pkt_mod[j],
+					    sizeof(struct tpm_engine_pkt_mod_t)))
+					break;
+			}
+			if (j < num_dest)
+				continue;
+			TPM_OS_DEBUG(TPM_MNG_MOD, "PME mod_cmd_idx[%d], mod_data_idx[%d] will be released\n",
+					old_pkt_mod[loop].mod_cmd_idx, old_pkt_mod[loop].mod_data_idx);
+			tpm_ret = tpm_pme_mod_release(old_pkt_mod[loop].mod_cmd_idx,
+						      old_pkt_mod[loop].mod_data_idx);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to release modification entry\n");
+		}
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mng_mc_flow_add
+*
+* DESCRIPTION: The routine add mc flow rule.
+*
+* INPUTS:
+*           match_key  - Fields that are allowed in the field-match bitmap:
+*			 port, out_vid, ether_type, pppoe_proto
+*			 ip_src (must have full host_mask).
+*			 ip_dst OR eth_dst (In either case, must have full host_mask)
+*           num_dest   - Number of Destination Action, meaning number of packet replications.
+*           action     - Ecah packet copy's action needed, such as dest and modfication.
+*
+* OUTPUTS:
+*           rule_id    - logical rule index in DB
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_flow_add(struct tpm_pkt_key_t	*match_key,
+			unsigned short		num_dest,
+			struct tpm_pkt_action_t	action[],
+			int			*rule_id)
+{
+	int tpm_ret;
+	unsigned int data_handle;
+	struct tpm_mng_pkt_key_t mng_match_key;
+	struct tpm_qos_t qos;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	unsigned int old_rule_id = TPM_DB_MNG_RULE_ID_INVALID;
+	int api_type = 0;
+	struct tpm_pkt_action_t	action_tmp;
+
+	/* Chekc the handler mod eof multicast mode, if not MC, no need to add defaut rule  */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	if (data_handle != TPM_HANDLER_MC) {
+		tpm_ret = TPM_NOT_ALLOWED;
+		IF_ERROR_STR(TPM_MNG_MOD,
+			     tpm_ret,
+			     "Multicast traffic is handled as non-multicast mode[%d]\n",
+			     data_handle);
+	}
+
+	/* MC check */
+	tpm_ret = tpm_mng_mc_flow_add_check(match_key,
+					    num_dest,
+					    action);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Multicast flow check fail\n");
+
+	/* handle packet duplication, TO_CPU could not be the first action */
+	if ((num_dest > 1)
+	&& (TPM_PP_CPU == action->dest.pp_port)) {
+		/* exchange action 0 and 1 */
+		memcpy(&action_tmp, action, sizeof(action_tmp));
+		memcpy(action, &action[TPM_ACT_NUM_IS_1], sizeof(action_tmp));
+		memcpy(&action[TPM_ACT_NUM_IS_1], &action_tmp, sizeof(action_tmp));
+	}
+
+	/* Get cap type */
+	if (match_key->port.port_type == TPM_CLASS_SWITCH_PORT_BM ||
+	    (match_key->port.port_type == TPM_CLASS_PP_PORT_BM &&
+	     match_key->port.class_port != TPM_PP_PMAC))
+		api_type = TPM_API_PRIVATE_MC_US;
+	else
+		api_type = TPM_API_PRIVATE_MC_DS;
+
+	TPM_OS_DEBUG(TPM_MNG_MOD, "API type[%d]\n", api_type);
+
+	qos.qos_sel = TPM_QOS_NONE;
+
+	TPM_MEMSET_ZERO(mng_match_key);
+
+	mng_match_key.pkt_key = match_key;
+
+	mng_match_key.pkt_key->rule_type = TPM_MC_DATA_TRAFFIC_TYPE;
+
+	/* Adjust IPv4 filed_bm when check DMAC, in order to co-exist with non-ip */
+	if (match_key->field_match_bm & TPM_MATCH_ETH_DST)
+		match_key->field_match_bm &= (~TPM_MATCH_IPV4_PKT);
+
+	/* Check the rule with same match_key exist or not, if exist, only update the MC rule */
+	tpm_ret = tpm_mng_rule_id_get(api_type,
+				      match_key,
+				      &old_rule_id);
+	if (tpm_ret != TPM_OK) {
+		if (tpm_ret != TPM_NOT_FOUND)
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "Rule index get fail with match key\n");
+		old_rule_id = TPM_DB_MNG_RULE_ID_INVALID;
+	}
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* if old_rule_id valid, update it */
+	if (old_rule_id != TPM_DB_MNG_RULE_ID_INVALID) {
+		TPM_OS_DEBUG(TPM_MNG_MOD, "Update existed MC rule[%d]\n", old_rule_id);
+		tpm_ret = tpm_mng_mc_entry_update(&match_key->port,
+						  &old_rule_id,
+						  num_dest,
+						  action,
+						  api_data);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "MC rule (%d) update fail\n", old_rule_id);
+		*rule_id = old_rule_id;
+
+		/* Get existed api_entry */
+		tpm_ret = tpm_db_mng_api_entry_get(old_rule_id, api_data);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "api_entry get fail wirh rule id[%d]\n",
+					old_rule_id);
+
+		/* Update Switch ATU according to actions */
+		tpm_ret = tpm_mng_mc_switch_set(match_key,
+						num_dest,
+						action,
+						api_data,
+						TPM_MNG_API_UPDATE);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Switch MC set fail\n");
+	} else {
+		TPM_OS_DEBUG(TPM_MNG_MOD, "Create new Multicast rule\n");
+		tpm_ret = tpm_mng_cap_entry_add(api_type,
+						&mng_match_key,
+						num_dest,
+						action,
+						TPM_POLICER_INVALID,
+						&qos,
+						rule_id);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Add multicast rule fail\n");
+
+		/* Set Switch ATU according to actions */
+		tpm_ret = tpm_mng_mc_switch_set(match_key,
+						num_dest,
+						action,
+						api_data,
+						TPM_MNG_API_ADD);
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Switch MC set fail\n");
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_flow_del
+*
+* DESCRIPTION: The routine delete MC rule with rule index.
+*
+* INPUTS:
+*           rule_id - rule logical index allocated when add the rule.
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_flow_del(unsigned int rule_id)
+{
+	int tpm_ret;
+	unsigned int data_handle;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+
+	/* Chekc the handler mod eof multicast mode, if not MC, no need to add defaut rule  */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	if (data_handle != TPM_HANDLER_MC) {
+		tpm_ret = TPM_NOT_ALLOWED;
+		IF_ERROR_STR(TPM_MNG_MOD,
+			     tpm_ret,
+			     "Multicast traffic is handled as non-multicast mode[%d]\n",
+			     data_handle);
+	}
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* Get API data from DB */
+	tpm_ret = tpm_db_mng_api_entry_get(rule_id, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "API[%d] data get fail\n", rule_id);
+
+	/* Check API type */
+	if (api_data->cap_api_type != TPM_API_PRIVATE_MC_DS &&
+	    api_data->cap_api_type != TPM_API_PRIVATE_MC_US) {
+		tpm_ret = TPM_NOT_ALLOWED;
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+			"API[%d] is NOT MC rule, del not allowed\n", rule_id);
+	}
+
+	/* Del Switch ATU according to actions from MNG DB */
+	tpm_ret = tpm_mng_mc_switch_set(&api_data->match_key,
+					api_data->num_dest,
+					api_data->action,
+					NULL,
+					TPM_MNG_API_DEL);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Switch MC del fail\n");
+
+	/* Delete cap rule */
+	tpm_ret = tpm_mng_cap_entry_del(api_data->cap_api_type, rule_id);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Multicast rule[%d] delete fail\n", rule_id);
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_mc_flow_del_all
+*
+* DESCRIPTION: The routine delete all MC rules added.
+*
+* INPUTS:
+*           None.
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_mc_flow_del_all(void)
+{
+	int tpm_ret;
+	int loop;
+	unsigned int data_handle;
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	unsigned short mc_api_idx[TPM_DB_MNG_MC_API_RULE_MAX] = {0};
+	unsigned int mc_api_cnt = 0;
+
+	/* Chekc the handler mod eof multicast mode, if not MC, no need to add defaut rule  */
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_MC_DATA_HANDLE, &data_handle);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get MC data handler mode failed\n");
+	if (data_handle != TPM_HANDLER_MC) {
+		tpm_ret = TPM_NOT_ALLOWED;
+		IF_ERROR_STR(TPM_MNG_MOD,
+			     tpm_ret,
+			     "Multicast traffic is handled as non-multicast mode[%d]\n",
+			     data_handle);
+	}
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	/* Get first two rules, default, keep it */
+	tpm_ret = tpm_db_mng_api_entry_type_first_get(TPM_API_PRIVATE_MC_DS, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "first MC api rule get fail\n");
+	tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Next MC api rule get fail\n");
+	for (loop = 0; loop < TPM_DB_MNG_MC_API_RULE_MAX; loop++) {
+		tpm_ret = tpm_db_mng_api_entry_type_next_get(api_data);
+		if (tpm_ret == TPM_NO_SUCH)
+			break;
+		IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data, "Next MC api rule get fail\n");
+		mc_api_idx[mc_api_cnt++] = api_data->api_rule_id;
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+
+	/* Delete MC rules */
+	if (mc_api_cnt) {
+		for (loop = 0; loop < mc_api_cnt; loop++) {
+			tpm_ret = tpm_mng_mc_flow_del(mc_api_idx[loop]);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MC rule[%d] delete fail\n", mc_api_idx[loop]);
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cm_c4_entry_build()
+*
+* DESCRIPTION: routine build a c4_entry
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*	action       - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                       in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	c4_entry
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_cm_c4_entry_build(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action,
+			    struct tpm_c4_add_entry_t	*c4_entry)
+{
+	int tpm_ret;
+	int rule_set;
+	enum tpm_vlan_num_enum_t vlan_num;
+
+	IF_NULL(TPM_MNG_MOD, cnm_key);
+	IF_NULL(TPM_MNG_MOD, action);
+	IF_NULL(TPM_MNG_MOD, c4_entry);
+
+	memset(c4_entry, 0, sizeof(struct tpm_c4_add_entry_t));
+
+	/* get ruleSet */
+	tpm_ret = tpm_db_mng_cm_ruleset_get(&cnm_key->match_key.port, &rule_set);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to get ruleSet from DB\n");
+
+	c4_entry->ruleSet = rule_set;
+	c4_entry->rule_num = cnm_key->rule_num;
+	c4_entry->field_num = cnm_key->field_num;
+	memcpy(c4_entry->field_op, cnm_key->field_op, sizeof(cnm_key->field_op));
+	memcpy(&c4_entry->pkt_key, &cnm_key->match_key, sizeof(c4_entry->pkt_key));
+
+	/* get vlan_num */
+	tpm_ret = tpm_mng_vlan_num_get(&cnm_key->match_key, &vlan_num);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get vlan_num failed\n");
+
+	/* xlate vlan number */
+	if (TPM_NO_VLAN == vlan_num)
+		c4_entry->vlan_num = TPM_C4_VLAN_NUM_NOVLANTAGS;
+	else if (TPM_SINGLE_VLAN == vlan_num)
+		c4_entry->vlan_num = TPM_C4_VLAN_NUM_ONEVLANTAG;
+	else if (TPM_DOUBLE_VLAN == vlan_num)
+		c4_entry->vlan_num = TPM_C4_VLAN_NUM_TWOVLANTAGS;
+	else if (TPM_TRIPLE_VLAN == vlan_num)
+		c4_entry->vlan_num = TPM_C4_VLAN_NUM_THREEVLANTAGS;
+	else
+		c4_entry->vlan_num = TPM_C4_VLAN_NUM_TRUE;
+
+	c4_entry->pkt_key.out_vid &= ~(TPM_SPEC_VID);
+	c4_entry->pkt_key.inn_vid &= ~(TPM_SPEC_VID);
+
+	/* so far, do not need the following */
+	c4_entry->pppoe = TPM_C4_PPPOE_TRUE;
+	c4_entry->mac_to_me = TPM_C4_MAC_TO_ME_NOMAC_TO_ME;
+	c4_entry->l3_info = TPM_C4_L3_INFO_TRUE;
+	c4_entry->l4_info = TPM_C4_L4_INFO_TRUE;
+
+	/* q_low */
+	c4_entry->action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c4_entry->qos_value.q_low = action->dest.pp_queue;
+
+	/* pri */
+	if ((action->mod.mod_bm & TPM_VLAN_MOD)
+	     && (action->mod.vlan_op.oper == TPM_VLANOP_EXT_TAG_MOD)) {
+		c4_entry->action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+		c4_entry->qos_value.pri = (action->mod.vlan_op.out_vlan.pbit & (~TPM_PBIT_UPDATE));
+	} else
+		c4_entry->action.pri_act = TPM_ACTION_TYPE_NO_UPDT;
+
+	/* others do not touch */
+	c4_entry->action.color_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.dscp_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.gemp_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.q_high_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.policer_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.flowid_act = TPM_ACTION_TYPE_NO_UPDT;
+	c4_entry->action.frwd_act = TPM_ACTION_TYPE_NO_UPDT;
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_mng_cm_rule_add_check()
+*
+* DESCRIPTION: API checks a CnM rule add.
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*	action       - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                        in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_cm_rule_add_check(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action)
+{
+	IF_NULL(TPM_MNG_MOD, cnm_key);
+	IF_NULL(TPM_MNG_MOD, action);
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_MNG_MOD, cnm_key->rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number");
+
+	if (cnm_key->match_key.port.port_type != TPM_CLASS_SWITCH_PORT_BM) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "port type should be switch port\n");
+		return TPM_BAD_PARAM;
+	}
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_MNG_MOD, cnm_key->match_key.port.class_port,
+		TPM_NUM_MAX_UNI_PORTS_BM, "invalid port number");
+
+	/* only vlan mod is allowed */
+	if (action->mod.mod_bm & (~TPM_VLAN_MOD)) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "mod_bm(0x%x) is not valid, only vlan_mod is supported\n",
+			action->mod.mod_bm);
+		return TPM_BAD_PARAM;
+	}
+
+	/* only vlan mod with Pbit is allowed */
+	if (action->mod.mod_bm & (TPM_VLAN_MOD)) {
+		if ((action->mod.vlan_op.oper != TPM_VLANOP_NOOP)
+		     && (action->mod.vlan_op.oper != TPM_VLANOP_EXT_TAG_MOD)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "vlan_op(0x%x) is not valid, only EXT_TAG_MOD is supported\n",
+				action->mod.vlan_op.oper);
+			return TPM_BAD_PARAM;
+		}
+		if ((action->mod.vlan_op.out_vlan.cfi & TPM_CFI_UPDATE)
+		     || (action->mod.vlan_op.out_vlan.vid & TPM_VID_UPDATE)
+		     || (action->mod.vlan_op.out_vlan.tpid & TPM_TPID_UPDATE)) {
+			TPM_OS_ERROR(TPM_MNG_MOD, "only EXT_TAG_MOD with Pbit modification is supported\n");
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cm_rule_add()
+*
+* DESCRIPTION: API adds a CnM rule that sets target queue and optionally p-bit for bridged packets.
+*              The API allows using combined field-matching keys that do not need to be pre-configured during Init.
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*			rule_num: 0 to 7
+*			field_num: each CnM rule has up to 6 fields.
+*			field_op   : each field operator could be equal, not equal, less or equal, greater or equal.
+*			match_key: contains the field key value, and source port. Only UNI port is allowed as src port.
+*	action       - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                       in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_cm_rule_add(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action)
+{
+	int tpm_ret = TPM_OK;
+	struct tpm_c4_add_entry_t c4_entry;
+
+	tpm_ret = tpm_mng_cm_rule_add_check(cnm_key, action);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM rule add check failed\n");
+
+	tpm_ret = tpm_mng_cm_c4_entry_build(cnm_key, action, &c4_entry);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "build C4 entry failed\n");
+
+	tpm_ret = tpm_c4_entry_add(&c4_entry);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "CnM rule add fail\n");
+
+	/* update MNG DB */
+	tpm_ret = tpm_db_mng_cm_rule_add(cnm_key, action);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "fail to add CnM entry into DB\n");
+
+	return tpm_ret;
+}
+
+/*******************************************************************************
+* tpm_mng_cm_rule_del()
+*
+* DESCRIPTION: API deletes a CnM rule.
+*
+* INPUTS:
+*	rule_num: valid from 0 to 7
+*	port	: src port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_cm_rule_del(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num)
+{
+	int rc = TPM_OK;
+	unsigned int		rule_set;
+	struct tpm_db_mng_ctc_cnm_rule_t cnm_rule;
+
+	IF_NULL(TPM_MNG_MOD, port);
+
+	/* get cnm rule from MNG DB */
+	rc = tpm_db_mng_cm_rule_get(port, rule_num, &cnm_rule);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get CnM entry from DB\n");
+
+	if (!cnm_rule.valid) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "there is no rule to delete for port(%d), rule_num(%d)",
+			port->class_port, rule_num);
+		return TPM_BAD_PARAM;
+	}
+
+	/* get ruleSet */
+	rc = tpm_db_mng_cm_ruleset_get(port, &rule_set);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get ruleSet from DB\n");
+
+	rc = tpm_c4_entry_del(rule_set, rule_num);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to delete C4 entry rule_set(%d) rule_num(%d)\n",
+		rule_set, rule_num);
+
+	/* update MNG DB */
+	rc = tpm_db_mng_cm_rule_del(port, rule_num);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to delete CnM entry from DB\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mng_cm_rule_del_all()
+*
+* DESCRIPTION: API deletes all CnM rules of certain ports.
+*
+* INPUTS:
+*	port_bm: bit map of port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_cm_rule_del_all(unsigned int port_bm)
+{
+	int rc = TPM_OK;
+	int loop;
+	int loop_in;
+	struct tpm_class_port_t port;
+	struct tpm_db_mng_ctc_cnm_rule_t cnm_rule;
+
+	for (loop = 0; loop < TPM_NUM_MAX_UNI_PORTS; loop++) {
+
+		if (!((1 << loop) & port_bm))
+			continue;
+
+		port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+		port.class_port = (1 << loop);
+
+		for (loop_in = 0; loop_in < MV_PP2_CLS_C4_GRP_SIZE; loop_in++) {
+			/* check if rule exists */
+			rc = tpm_db_mng_cm_rule_get(&port, loop_in, &cnm_rule);
+			IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to get CnM rules from DB port(%d)\n", loop);
+
+			if (!cnm_rule.valid)
+				continue;
+
+			rc = tpm_mng_cm_rule_del(&port, loop_in);
+			IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to Delete all CnM rules on port(%d)\n", port_bm);
+		}
+	}
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_mng_mtm_add()
+*
+* DESCRIPTION: adds a MAC to port, to make it Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be added
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_mtm_add(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	int rc = TPM_OK;
+
+	/* Param check */
+	IF_NULL(TPM_MNG_MOD, mac);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_MNG_MOD, port,
+		TPM_ENUM_PMAC, "invalid port number");
+
+	rc = mvPrsMacDaAccept(port, mac, TPM_MNG_MTM_ADD);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to add an MAC(%pM) to port(%d)\n", mac, port);
+
+	return rc;
+}
+/*******************************************************************************
+* tpm_mng_mtm_del()
+*
+* DESCRIPTION: removes a MAC from port, to make it not Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be removed
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_mng_mtm_del(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	int rc = TPM_OK;
+
+	/* Param check */
+	IF_NULL(TPM_MNG_MOD, mac);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_MNG_MOD, port,
+		TPM_ENUM_PMAC, "invalid port number");
+
+	rc = mvPrsMacDaAccept(port, mac, TPM_MNG_MTM_DEL);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "fail to remove an MAC(%pM) from port(%d)\n", mac, port);
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_mng_start
+*
+* DESCRIPTION: The routine start the MNG module
+*
+* INPUTS:
+*              NONE:
+*
+* OUTPUTS:
+*           NONE
+*
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_mng_start(void)
+{
+	int tpm_ret;
+
+	tpm_mng_lock_init();
+
+	/* Enable LSP add parser rule, such as M2M, MH and defaulr flow rule of each port
+	mv_eth_ctrl_pnc(PRS_MAC_ENABLE | PRS_TAG_ENABLE | PRS_DEF_FLOW_ENABLE);*/
+
+	/* set CLS additional conf */
+	tpm_ret = tpm_mng_spid_set(TPM_ENUM_GMAC_0);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set SPID for GMAC0 failed\n");
+	tpm_ret = tpm_mng_spid_set(TPM_ENUM_GMAC_1);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set SPID for GMAC1 failed\n");
+
+	/* set port way conf */
+	tpm_ret = tpm_mng_way_set();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "set port way failed\n");
+
+	tpm_ret = tpm_mng_reset();
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "MNG reset failed\n");
+
+	return TPM_OK;
+}
+
+/* this routine is for automatic test */
+#ifdef TPM_AUTO_TEST
+void tpm_mng_cap_merge_auto_test(void)
+{
+	int cap_num;
+	int tpm_ret;
+	int loop;
+	struct tpm_db_mng_flow_cap_conf_t cap_arr_out[TPM_MNG_CAP_PER_FLOW_MAX];
+	static struct tpm_db_mng_flow_cap_conf_t cap_arr_in[] = {
+
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 0, TPM_ENGINE_C2, 0, 0, TPM_MATCH_TTL},
+
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 1, TPM_ENGINE_C2, 1, 0, TPM_MATCH_TTL},
+
+	{TPM_MATCH_VID_OUTER, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 2, TPM_ENGINE_C2, 2, 0, TPM_MATCH_VID_OUTER},
+
+	{(TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 3, TPM_ENGINE_C2, 3, 0, (TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER)},
+
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 4, TPM_ENGINE_C3_A, 1, 0, TPM_MATCH_TTL},
+
+	{TPM_MATCH_IP_SRC, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 0, TPM_MATCH_IP_SRC},
+
+	{(TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 6, TPM_ENGINE_C2, 6, 0, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_IP_PROTO), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 7, TPM_ENGINE_C2, 7, 0, (TPM_MATCH_VID_OUTER | TPM_MATCH_IP_PROTO)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 8, TPM_ENGINE_C2, 8, 0, (TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_TTL), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 9, TPM_ENGINE_C2, 9, 0, (TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_TYPE), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 10, TPM_ENGINE_C2, 10, 0, (TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_TYPE)},
+
+	{(TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 11, TPM_ENGINE_C2, 11, 0, (TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE)},
+
+	};
+
+	static struct tpm_db_mng_flow_cap_conf_t cap_arr_out_right[] = {
+	/* do not touch first one */
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 0, TPM_ENGINE_C2, 0, 0, TPM_MATCH_TTL},
+	/* second one */
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 1, TPM_ENGINE_C2, 1, 0, (TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{TPM_MATCH_VID_OUTER, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 1, TPM_ENGINE_C2, 1, 1, (TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 1, TPM_ENGINE_C2, 1, 2, (TPM_MATCH_ETH_TYPE | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+	/* C3 could not be merged */
+	{TPM_MATCH_TTL, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 4, TPM_ENGINE_C3_A, 1, 0, TPM_MATCH_TTL},
+	/* third one */
+	{TPM_MATCH_IP_SRC, TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 0, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 1, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_IP_PROTO), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 2, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 3, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_TTL), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 5, TPM_ENGINE_C2, 5, 4, (TPM_MATCH_IP_SRC | TPM_MATCH_IP_PROTO | TPM_MATCH_VID_OUTER | TPM_MATCH_TTL)},
+
+	{(TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_TYPE), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 10, TPM_ENGINE_C2, 10, 0, (TPM_MATCH_VID_OUTER | TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE)},
+
+	{(TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE), TPM_API_PUBLIC_CLS, TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,
+	 10, TPM_ENGINE_C2, 10, 1, (TPM_MATCH_VID_OUTER | TPM_MATCH_L4_DST | TPM_MATCH_ETH_TYPE)},
+	};
+
+	cap_num = sizeof(cap_arr_in) / sizeof(struct tpm_db_mng_flow_cap_conf_t);
+	tpm_ret = tpm_mng_cap_merge_flow(cap_num, cap_arr_in, cap_arr_out);
+	if (tpm_ret != TPM_OK) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "tpm_mng_cap_merge_auto_test failed\n");
+		return;
+	}
+
+	/* compare result */
+	if (memcmp(cap_arr_out, cap_arr_out_right, sizeof(cap_arr_out_right))) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "tpm_mng_cap_merge_auto_test failed\n");
+		printk(KERN_INFO "return is:\n");
+		for (loop = 0; loop < cap_num; loop++)
+			TPM_MNG_FLOW_CAP_PRINT(&(cap_arr_out[loop]));
+
+		printk(KERN_INFO "\nright return is:\n");
+		for (loop = 0; loop < cap_num; loop++)
+			TPM_MNG_FLOW_CAP_PRINT(&(cap_arr_out_right[loop]));
+
+		return;
+	}
+
+	printk(KERN_INFO "auto test for cap merge feature is done successfully!\n");
+	return;
+}
+
+void tpm_mng_cnm_auto_test(void)
+{
+	int tpm_ret;
+	struct tpm_cnm_key_t	cnm_key;
+	struct tpm_pkt_action_t	action;
+	struct tpm_db_c4_rule_t db_c4_rule_out;
+	struct tpm_db_c4_rule_t db_c4_rule_right;
+
+	TPM_MEMSET_ZERO(cnm_key);
+	TPM_MEMSET_ZERO(action);
+	TPM_MEMSET_ZERO(db_c4_rule_out);
+	TPM_MEMSET_ZERO(db_c4_rule_right);
+
+	/* prepare input */
+	cnm_key.field_num = 5;
+	cnm_key.rule_num = 0;
+	/* field keys:
+	  * DMAC,	==
+	  * VID_OUT,	>=
+	  * PBIT_OUT,	<=
+	  * SIP,		!=
+	  * ETY,		==
+	*/
+	cnm_key.field_op[0].field = TPM_MATCH_ETH_DST;
+	cnm_key.field_op[0].op = TPM_CNM_OP_EQUAL;
+	cnm_key.field_op[1].field = TPM_MATCH_VID_OUTER;
+	cnm_key.field_op[1].op = TPM_CNM_OP_GREATER_EQUAL;
+	cnm_key.field_op[2].field = TPM_MATCH_PBITS_OUTER;
+	cnm_key.field_op[2].op = TPM_CNM_OP_LESS_EQUAL;
+	cnm_key.field_op[3].field = (TPM_MATCH_IPV4_PKT | TPM_MATCH_IP_SRC);
+	cnm_key.field_op[3].op = TPM_CNM_OP_NOT_EQUAL;
+	cnm_key.field_op[4].field = TPM_MATCH_ETH_TYPE;
+	cnm_key.field_op[4].op = TPM_CNM_OP_EQUAL;
+
+	cnm_key.match_key.port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+	cnm_key.match_key.port.class_port = 0;
+
+	cnm_key.match_key.ether_type = 0x0800;
+	cnm_key.match_key.eth_dst.eth_add[0] = 0x0;
+	cnm_key.match_key.eth_dst.eth_add[1] = 0xab;
+	cnm_key.match_key.eth_dst.eth_add[2] = 0xcd;
+	cnm_key.match_key.eth_dst.eth_add[3] = 0xef;
+	cnm_key.match_key.eth_dst.eth_add[4] = 0x01;
+	cnm_key.match_key.eth_dst.eth_add[5] = 0x02;
+	cnm_key.match_key.out_vid = (100 | TPM_SPEC_VID);
+	cnm_key.match_key.out_pbit = 3;
+	cnm_key.match_key.ipvx_add.ip_src.ip_add.ipv4[0] = 192;
+	cnm_key.match_key.ipvx_add.ip_src.ip_add.ipv4[1] = 168;
+	cnm_key.match_key.ipvx_add.ip_src.ip_add.ipv4[2] = 100;
+	cnm_key.match_key.ipvx_add.ip_src.ip_add.ipv4[3] = 1;
+
+	action.color = TPM_COL_GREEN;
+	action.dest.pp_queue = 7;
+	action.mod.mod_bm = TPM_VLAN_MOD;
+	action.mod.vlan_op.oper = VLANOP_EXT_TAG_MOD;
+	action.mod.vlan_op.out_vlan.pbit = (7 | TPM_PBIT_UPDATE);
+
+	tpm_ret = mv_tpm_cm_rule_add(&cnm_key, &action);
+	if (tpm_ret != TPM_OK) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "mv_tpm_cm_rule_add failed\n");
+		return;
+	}
+
+	/* prepare out put */
+	db_c4_rule_right.valid = true;
+
+	db_c4_rule_right.rule_entry.action.color_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.dscp_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.gemp_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.q_high_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.policer_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.flowid_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.frwd_act = TPM_ACTION_TYPE_NO_UPDT;
+	db_c4_rule_right.rule_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	db_c4_rule_right.rule_entry.action.pri_act = TPM_ACTION_TYPE_UPDT_LOCK;
+
+	db_c4_rule_right.rule_entry.ruleSet = 0;
+	db_c4_rule_right.rule_entry.rule_num = 0;
+
+	db_c4_rule_right.rule_entry.pppoe = TPM_C4_PPPOE_TRUE;
+	db_c4_rule_right.rule_entry.mac_to_me = TPM_C4_MAC_TO_ME_NOMAC_TO_ME;
+	db_c4_rule_right.rule_entry.l3_info = TPM_C4_L3_INFO_TRUE;
+	db_c4_rule_right.rule_entry.l4_info = TPM_C4_L4_INFO_TRUE;
+	db_c4_rule_right.rule_entry.vlan_num = TPM_C4_VLAN_NUM_TRUE;
+
+	db_c4_rule_right.rule_entry.field_num = 5;
+	memcpy(&db_c4_rule_right.rule_entry.field_op,
+		&cnm_key.field_op,
+		sizeof(cnm_key.field_op));
+	memcpy(&db_c4_rule_right.rule_entry.pkt_key,
+		&cnm_key.match_key,
+		sizeof(cnm_key.match_key));
+	db_c4_rule_right.rule_entry.pkt_key.out_vid = 100;
+
+	db_c4_rule_right.rule_entry.qos_value.q_low = action.dest.pp_queue;
+	db_c4_rule_right.rule_entry.qos_value.pri = 7;
+
+	/* get result from DB */
+	tpm_ret = tpm_db_c4_rule_get(0, 0, &db_c4_rule_out);
+	if (tpm_ret != TPM_OK) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "c4 rule get failed\n");
+		return;
+	}
+
+	/* compare result */
+	if (memcmp(&db_c4_rule_out, &db_c4_rule_right, sizeof(db_c4_rule_right))) {
+		TPM_OS_ERROR(TPM_MNG_MOD, "tpm_mng_cnm_auto_test failed\n");
+		printk(KERN_INFO "return is:\n");
+		tpm_sfs_c4_entry_dump(&db_c4_rule_out.rule_entry);
+		printk(KERN_INFO "\nright return is:\n");
+		tpm_sfs_c4_entry_dump(&db_c4_rule_right.rule_entry);
+		return;
+	}
+
+	printk(KERN_INFO "auto test for CnM feature is done successfully!\n");
+	return;
+}
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_switch_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_switch_api.c
new file mode 100644
index 0000000..91c6d73
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_switch_api.c
@@ -0,0 +1,1924 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_switch_api.c                                                      **
+**                                                                           **
+**  DESCRIPTION : This file contains switch routine and APIs                 **
+**  DEPENDCY : None                                                          **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************
+ * Type Definition
+ ******************************************************************************/
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_set
+*
+* DESCRIPTION: The routine sets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_set(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_ingress_mode_set(port, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_ingress_mode_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_get
+*
+* DESCRIPTION: The routine gets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_get(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	*mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_ingress_mode_get(port, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_ingress_mode_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_set
+*
+* DESCRIPTION: The routine sets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_set(enum tpm_sw_port_t	port,
+		       unsigned short		vid,
+		       unsigned char		pri)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_pvid_set(port, vid, pri);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_pvid_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_get
+*
+* DESCRIPTION: The routine gets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_get(enum tpm_sw_port_t	port,
+		       unsigned short		*vid,
+		       unsigned char		*pri)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_pvid_get(port, vid, pri);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_pvid_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_set
+*
+* DESCRIPTION: The routine adds a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*	mode      - VLAN egress mode
+*			TPM_SW_VLAN_EGRESS_ASIS:        AS-IS
+*			TPM_SW_VLAN_EGRESS_NOT_IN_VLAN: not in this vlan
+*			TPM_SW_VLAN_EGRESS_STRIP_VLAN:  egress and strip vlan tag
+*			TPM_SW_VLAN_EGRESS_KEEP_VLAN:   egress and do not strip vlan tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_set(enum tpm_sw_port_t		port,
+		       unsigned short			min_vlan,
+		       unsigned short			max_vlan,
+		       enum tpm_sw_vlan_egress_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_set(port, min_vlan, max_vlan, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_del
+*
+* DESCRIPTION: The routine deletes a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_del(enum tpm_sw_port_t	port,
+		       unsigned short		min_vlan,
+		       unsigned short		max_vlan)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_del(port, min_vlan, max_vlan);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_del");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_get
+*
+* DESCRIPTION: The routine get VLAN information for specific switch port
+*
+* INPUTS:
+*	vlan    - VLAN ID value
+*
+* OUTPUTS:
+*	fwd_bm  - Bitmap of egress forwarding mode
+*		  0:do not forward, 1:forward
+*		  bit0:port 0, bit1:port 1 ...
+*	tag_bm  - Bitmap of egress VLAN tag mode
+*		  0:egress untagged, 1:egress tagged
+*		  bit0:port 0, bit1:port 1 ...
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_get(unsigned short		vlan,
+		       unsigned int		*fwd_bm,
+		       unsigned int		*tag_bm)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_get(vlan, fwd_bm, tag_bm);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_set
+*
+* DESCRIPTION:
+*	The API sets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*       enable - enable or disable filter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_filter_set(port, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_filter_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_get
+*
+* DESCRIPTION:
+*	The API gets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*
+* OUTPUTS:
+*       enable - enable or disable filter mode.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_vlan_filter_get(port, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_vlan_filter_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_set
+*
+* DESCRIPTION: The routine enable or disable switch port
+*
+* INPUTS:
+*	port   - switch port
+*	enable - enable or disable switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_enable_state_set(port, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_enable_state_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_get
+*
+* DESCRIPTION: The routine gets switch port PHY state
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	enable - enabled or disabled of switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_enable_state_get(port, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_enable_state_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_set
+*
+* DESCRIPTION: The routine configures switch port flow control
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable flow control
+*	interval  - interval time of pause frame
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable,
+			       unsigned int			interval)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_flow_control_set(port, enable, interval);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_flow_control_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_get
+*
+* DESCRIPTION: The routine gets switch port flow control configuration
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enabled or disabled of flow control
+*	interval  - interval time of pause frame
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable,
+			       unsigned int			*interval)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_flow_control_get(port, enable, interval);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to tpm_sw_port_flow_control_get tpm_sw_port_vlan_ingress_mode_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_set
+*
+* DESCRIPTION: The routine sets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port        - switch port
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_set(enum tpm_sw_port_t	port,
+			       unsigned int		port_mask)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_isolate_mask_set(port, port_mask);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_isolate_mask_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_get
+*
+* DESCRIPTION: The routine gets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	port_mask - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_get(enum tpm_sw_port_t	port,
+			       unsigned int		*port_mask)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_isolate_mask_get(port, port_mask);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_isolate_mask_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_set
+*
+* DESCRIPTION: The routine sets switch port flood control configuration
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: block
+*			1: do not block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_set(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			port_mask)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_flood_control_mask_set(port, pkt_type, port_mask);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_flood_control_mask_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_get
+*
+* DESCRIPTION: The routine gets flood control information
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*
+* OUTPUTS:
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: block
+*			1: do not block
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_get(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			*port_mask)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_flood_control_mask_get(port, pkt_type, port_mask);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_flood_control_mask_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_all_count_clear
+*
+* DESCRIPTION: The routine clears the counters of all switch ports
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_all_count_clear(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_all_count_clear();
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_all_count_clear");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_port_count_clear
+*
+* DESCRIPTION: The routine clears the counters of dedicated switch ports
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_port_count_clear(enum tpm_sw_port_t port)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_count_clear(port);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to tpm_sw_port_count_cleartpm_sw_port_vlan_ingress_mode_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_set
+*
+* DESCRIPTION: The routine sets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_set(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	auto_en,
+			    enum tpm_sw_speed_mode_t	speed,
+			    enum tpm_sw_duplex_mode_t	duplex)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_link_mode_set(port, auto_en, speed, duplex);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_link_mode_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_get
+*
+* DESCRIPTION: The routine gets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*
+* OUTPUTS:
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_get(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	*auto_en,
+			    enum tpm_sw_speed_mode_t	*speed,
+			    enum tpm_sw_duplex_mode_t	*duplex)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_link_mode_get(port, auto_en, speed, duplex);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_link_mode_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_state_get
+*
+* DESCRIPTION: The routine gets switch port dynamic link state, including
+*	whether link up, speed and dumplex mode.
+*
+* INPUTS:
+*	port    - switch port
+*
+* OUTPUTS:
+*	link    - link up or down state
+*			TPM_SW_PORT_STATE_DOWN:  link down
+*			TPM_SW_PORT_STATE_UP:    link up
+*	speed   - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*	duplex  - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_state_get(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_state_t	*link,
+			     enum tpm_sw_speed_mode_t	*speed,
+			     enum tpm_sw_duplex_mode_t	*duplex)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_link_state_get(port, link, speed, duplex);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_link_state_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_set(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		enable,
+			     enum tpm_sw_rate_limit_mode_t	mode,
+			     unsigned int			rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_rate_limit_set(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_rate_limit_set\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_get(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		*enable,
+			     enum tpm_sw_rate_limit_mode_t	*mode,
+			     unsigned int			*rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_rate_limit_get(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_rate_limit_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_set(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	enable,
+				enum tpm_sw_rate_limit_mode_t	mode,
+				unsigned int			rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mc_proto_rate_set(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mc_proto_rate_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mc_proto_rate_get(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mc_proto_rate_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	enable,
+			       enum tpm_sw_rate_limit_mode_t	mode,
+			       unsigned int			rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mc_data_rate_set(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mc_data_rate_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mc_data_rate_get(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mc_data_rate_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	enable,
+				 enum tpm_sw_rate_limit_mode_t	mode,
+				 unsigned int			rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_broadcast_rate_set(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_broadcast_rate_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_get(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_broadcast_rate_get(port, dir, enable, mode, rate);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_broadcast_rate_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_set
+*
+* DESCRIPTION: The routine sets port mirror
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_set(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	enable,
+			 enum tpm_sw_port_t		dport)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mirror_set(sport, dir, enable, dport);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mirror_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_get
+*
+* DESCRIPTION: The routine gets port mirror configuration
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_get(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	*enable,
+			 enum tpm_sw_port_t		*dport)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mirror_get(sport, dir, enable, dport);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mirror_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_set
+*
+* DESCRIPTION: The routine sets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port loopback
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_set(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_loopback_set(port, dir, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_loopback_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_get
+*
+* DESCRIPTION: The routine gets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port loopback
+
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_get(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	*enable)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_loopback_get(port, dir, enable);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_loopback_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_set
+*
+* DESCRIPTION: The routine sets switch aging time
+*
+* INPUTS:
+*	time  - switch aging time in unit of second
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_set(unsigned int time)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_mac_aging_time_set(time);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_mac_aging_time_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_get
+*
+* DESCRIPTION: The routine gets switch aging time
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	time  - switch aging time in unit of second
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_get(unsigned int *time)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_mac_aging_time_get(time);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_mac_aging_time_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_set
+*
+* DESCRIPTION: The routine sets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	enable,
+				  unsigned int			limit)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_learn_limit_set(port, enable, limit);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_learn_limit_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_get
+*
+* DESCRIPTION: The routine gets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	*enable,
+				  unsigned int			*limit)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_learn_limit_get(port, enable, limit);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_learn_limit_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_add
+*
+* DESCRIPTION: The routine adds MAC address
+*
+* INPUTS:
+*	port_bm - switch port bitmap
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - enable or disable port mirror
+*		TPM_SW_MAC_ADDR_DYNAMIC: dynamic MAC address
+*		TPM_SW_MAC_ADDR_STATIC:  static MAC address
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_add(unsigned char			port_bm,
+			      unsigned char			*mac,
+			      unsigned short			vlan,
+			      enum tpm_sw_mac_addr_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_address_add(port_bm, mac, vlan, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_address_add");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_del
+*
+* DESCRIPTION: The routine deletes MAC address
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_del(unsigned char	port,
+			      unsigned char	*mac,
+			      unsigned short	vlan)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_address_del((enum tpm_sw_port_t)port, mac, vlan);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_address_del");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_set
+*
+* DESCRIPTION: The routine sets MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_filter_mode_set(port, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_filter_mode_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_get
+*
+* DESCRIPTION: The routine gets MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	*mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_filter_mode_get(port, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_filter_mode_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_add
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_add(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_filter_entry_add(port, mac, vlan, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_filter_entry_add");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_del
+*
+* DESCRIPTION: The routine deletes MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_del(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_filter_entry_del(port, mac, vlan, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_filter_entry_del");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_clear
+*
+* DESCRIPTION: The routine clear all MAC addresses
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_clear(void)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_mac_address_clear();
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_mac_address_clear");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_table_clear
+*
+* DESCRIPTION: The routine clear MAC address based on port and type
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC clear mode
+*		TPM_SW_MAC_ADDR_DYNAMIC:   clear dynami mac
+*		TPM_SW_MAC_ADDR_STATIC:    clear static mac
+*		TPM_SW_MAC_ADDR_UNICAST:   clear unicast mac
+*		TPM_SW_MAC_ADDR_MULTICAST: clear multicast mac
+*		TPM_SW_MAC_ADDR_ALL:       clear all
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_table_clear(enum tpm_sw_port_t		port,
+			      enum tpm_sw_mac_addr_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_mac_table_clear(port, mode);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_mac_table_clear");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_qos_set
+*
+* DESCRIPTION: The routine sets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_set(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	mode,
+		      unsigned char		weight)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_qos_set(port, queue, mode, weight);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_qos_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_qos_get
+*
+* DESCRIPTION: The routine gets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*
+* OUTPUTS:
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_get(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	*mode,
+		      unsigned char		*weight)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_qos_get(port, queue, mode, weight);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_qos_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	mtu  - MTU of switch
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_set(unsigned int mtu)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_mtu_set(mtu);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_mtu_set");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	mtu  - MTU of switch
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_get(unsigned int *mtu)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_mtu_get(mtu);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_mtu_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat1_get
+*
+* DESCRIPTION: The routine gets performance counter 1
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 1
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat1_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat1_t	*stat)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_stat1_get(port, reset, stat);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_stat1_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat2_get
+*
+* DESCRIPTION: The routine gets performance counter 2
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 2
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat2_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat2_t	*stat)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_stat2_get(port, reset, stat);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_stat2_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat3_get
+*
+* DESCRIPTION: The routine gets performance counter 3
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat3_get(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat3_t	*stat)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_stat3_get(port, reset, stat);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_stat3_get");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat_all_get
+*
+* DESCRIPTION: The routine gets all switch performance counters
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - all performance counters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat_all_get(enum tpm_sw_port_t			port,
+			   enum tpm_sw_count_reset_t		reset,
+			   struct tpm_sw_port_stat_all_t	*stat)
+{
+	int rc = TPM_OK;
+
+	rc = tpm_sw_port_stat_all_get(port, reset, stat);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to call tpm_sw_port_stat_all_get");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_utils.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_utils.c
new file mode 100644
index 0000000..2324fc5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/conf/tpm_utils.c
@@ -0,0 +1,263 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_utils.c						     **
+**									     **
+**  DESCRIPTION :                                                            **
+**  DEPENDCY :			                                             **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+char g_unknown_str[] = "<unknown>";
+
+/*******************************************************************************
+* print_help_buffer
+*
+* DESCRIPTION:
+*           This function prints help buffer
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+
+void print_help_buffer(char *helpbuf, int len)
+{
+	int  indx;
+	char savech;
+
+	for (indx = 0; indx < len; indx += 1000) {
+		if (indx + 1000 < len) {
+			savech = helpbuf[indx + 1000];
+			helpbuf[indx + 1000] = 0;
+			printk(KERN_INFO "%s", &helpbuf[indx]);
+			helpbuf[indx + 1000] = savech;
+		} else {
+			printk(KERN_INFO "%s", &helpbuf[indx]);
+		}
+	}
+}
+
+/*******************************************************************************
+* parm_error_completion
+*
+* DESCRIPTION:
+*           This function prints out help message if buffer holds 1 parameter that
+*           starts '?'; else it prints out incorrect number of parameters message
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+void parm_error_completion(int numparms, int reqdparms, const char *buf, int (*help_text_routine)(char *))
+{
+	if (numparms == 1 && buf[0] == '?' && help_text_routine != NULL) {
+		char helpbuf[1024];
+		int  helpbuf_len;
+
+		helpbuf_len = help_text_routine(helpbuf);
+		print_help_buffer(helpbuf, helpbuf_len);
+	} else {
+		printk(KERN_INFO "Parse problem: parameters expected/found %d/%d\n", reqdparms, numparms);
+	}
+}
+
+/*******************************************************************************
+* count_parameters
+*
+* DESCRIPTION:
+*           This function counts the number of parameters provided
+* INPUTS:
+*       buf	- buffer with parameter string
+*
+* OUTPUTS:
+*       NONE.
+*
+* RETURNS:
+*       int
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int count_parameters(const char *buf)
+{
+	char bufcopy[513];
+	char **ap, *argv[20];
+	char *inputstring = bufcopy;
+	int  numparms = 0;
+
+	strcpy(bufcopy, buf);
+
+	for (ap = argv; ap < &argv[15] && (*ap = strsep(&inputstring, " \t")) != NULL;) {
+		if (**ap != '\0') {
+			ap++;
+			numparms++;
+		}
+	}
+
+	return numparms;
+}
+
+/******************************************************************************
+* lookup_enum_str()
+*
+* DESCRIPTION:
+*	This routine lookups enum string according to enum value
+*
+* INPUTS:
+*	enum_str   - enum string array
+*	enum_num   - enum number
+*	enum_value - the enum value to be matched
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Enum string
+*******************************************************************************/
+char *lookup_enum_str(struct tpm_enum_str_t enum_str[], int enum_num, int enum_value)
+{
+	int idx;
+
+	if (NULL == enum_str)
+		return g_unknown_str;
+
+	for (idx = 0; idx < enum_num; idx++) {
+		if (enum_value == enum_str[idx].enum_value)
+			return enum_str[idx].enum_str;
+	}
+	return g_unknown_str;
+}
+
+/******************************************************************************
+*
+* Function   : common_mask_gen
+*
+* Description: generate mask according to bits number
+*
+* Parameters :
+* INPUT bit_num - bit num needed
+* OUTPUT None
+* Returns    : mask
+* Comments: for example, bit_num = 2, mask = 0x3(b00000011)
+******************************************************************************/
+unsigned int common_mask_gen(int bit_num)
+{
+	unsigned int temp = 0x1;
+	int i;
+
+	/* para check */
+	if (bit_num < 0 ||
+	    bit_num > (sizeof(unsigned int) * BYTE_BITS))
+		return 0;
+
+	if (bit_num == 0)
+		return 0;
+
+	for (i = 1; i < bit_num; i++) {
+		temp = temp << 1;
+		temp |= 0x1;
+	}
+
+	return temp;
+}
+
+/******************************************************************************
+* int_bitmap_num_get()
+*
+* DESCRIPTION:
+*	This routine gets the total bit number of int type bitmap
+*
+* INPUTS:
+*	bitmap   - bitmap type value
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Total bitmap bit number
+*******************************************************************************/
+unsigned int int_bitmap_num_get(unsigned int bitmap)
+{
+	unsigned int num = 0;
+	int index;
+
+	for (index = 0; index < 32; index++) {
+		if ((1 << index) & bitmap)
+			num++;
+	}
+
+	return num;
+}
+
+/******************************************************************************
+* int_array_high_bits_set()
+*
+* DESCRIPTION:
+*	This routine set the high bits from user to 1
+*
+* INPUTS:
+*	array        - array need to operation
+*       array_len    - array size
+*       high_bit_num - the number of bits to set
+*
+* OUTPUTS:
+*	array        - array need to operation
+*
+* RETURNS:
+*	SUCCESS: 0; FAIL: -1.
+*******************************************************************************/
+int int_array_high_bits_set(unsigned int *array, unsigned int array_len, unsigned int high_bit_num)
+{
+	int i, j;
+	unsigned int unit_num = 0;
+
+	if (array == NULL || array_len == 0)
+		return -1;
+	if (high_bit_num == 0)
+		return 0;
+
+	i = array_len - 1;
+	unit_num = high_bit_num / (sizeof(unsigned int) * BYTE_BITS);
+	if (unit_num) {
+		for (; i >= (array_len - unit_num); i--)
+			memset(&array[i], 0xFF, sizeof(unsigned int));
+	}
+
+	j = sizeof(unsigned int) * BYTE_BITS - 1;
+	unit_num = high_bit_num % (sizeof(unsigned int) * BYTE_BITS);
+	if (unit_num) {
+		for (; j >= ((sizeof(unsigned int) * BYTE_BITS) - unit_num); j--)
+			array[i] |= (1 << j);
+	}
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
new file mode 100644
index 0000000..e011e2f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2.c
@@ -0,0 +1,2612 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_c2.c						     **
+**									     **
+**  DESCRIPTION : This file contains C2 engine sub-module routine and APIs   **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/*******************************************************************************
+* tpm_c2_new_logic_idx_allocate()
+*
+* DESCRIPTION: This routine will allocate logical index for one c2 rule entry
+*
+* INPUTS:
+*          reset   - indeicate it is reset or not
+*
+* RETURNS:
+*          logical index allocated or after reset
+*******************************************************************************/
+static unsigned int tpm_c2_new_logic_idx_allocate(bool reset)
+{
+	/* Base logical index for C2 entry, every time a new index is allocated, perform tpm_c2_logic_base_idx++ */
+	static unsigned int tpm_c2_logic_base_idx = TPM_C2_LOGIC_IDX_BASE;
+
+	tpm_c2_logic_base_idx++;
+	/* if c2_reset, restore tpm_c2_logic_base_idx to original value */
+	if (reset == true)
+		tpm_c2_logic_base_idx = TPM_C2_LOGIC_IDX_BASE;
+
+	return tpm_c2_logic_base_idx;
+}
+
+/*******************************************************************************
+* tpm_c2_free_list_add()
+*
+* DESCRIPTION: This routine will add one C2 TCAM to free list
+*
+* INPUTS:
+*          c2_hw_idx   - the free C2 TCAM entry
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_c2_free_list_add(unsigned int c2_hw_idx)
+{
+	struct list_head *free_list_head;
+	struct tpm_c2_index_t *c2_index_node, *temp_node;
+	unsigned int index;
+	bool bigger_found = false;
+
+	/* Get list head */
+	free_list_head = tpm_db_c2_free_list_head_get();
+
+	/* Check hw index already exist or not */
+	list_for_each_entry(temp_node, free_list_head, list_node) {
+		if (temp_node->c2_hw_idx == c2_hw_idx)
+			return TPM_OK;
+	}
+
+	/* Get the invalid index node */
+	for (index = 0; index < TPM_C2_ENTRY_MAX; index++) {
+		c2_index_node = tpm_db_c2_index_node_get(index);
+		if (c2_index_node == NULL)
+			return TPM_NO_SUCH;
+		if (c2_index_node->valid == TPM_C2_ENTRY_INVALID)
+			break;
+	}
+	if (index == TPM_C2_ENTRY_MAX)
+		return TPM_NO_SUCH;
+
+	c2_index_node->c2_hw_idx = c2_hw_idx;
+
+	/* Check free list empty */
+	if (list_empty(free_list_head)) {
+		list_add(&c2_index_node->list_node, free_list_head);
+	} else {
+		/* Add to free list */
+		list_for_each_entry(temp_node, free_list_head, list_node) {
+			if (temp_node->c2_hw_idx > c2_hw_idx) {
+				bigger_found = true;
+				list_add_tail(&c2_index_node->list_node, &temp_node->list_node);
+				break;
+			}
+		}
+		if (bigger_found == false)
+			list_add_tail(&c2_index_node->list_node, free_list_head);
+	}
+
+	/* Change Valid status to valid */
+	c2_index_node->valid = TPM_C2_ENTRY_VALID;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_data_entry_db_add()
+*
+* DESCRIPTION: Add HW TCAM entry data in data DB.
+*
+* INPUTS:
+*          c2_entry   - c2 TCAM entry data to record
+*
+* OUTPUTS:
+*          c2_db_idx  - the data db entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None.
+*******************************************************************************/
+static int tpm_c2_data_entry_db_add(struct tpm_c2_add_entry_t *c2_entry,
+				    unsigned int *c2_db_idx)
+{
+	int ret_code;
+	struct tpm_c2_data_t c2_entry_db;
+	unsigned int index;
+
+	IF_NULL(TPM_C2_MOD, c2_entry);
+	IF_NULL(TPM_C2_MOD, c2_db_idx);
+
+	/* Get available db entry for c2 entry */
+	for (index = 0; index < TPM_C2_ENTRY_MAX; index++) {
+		ret_code = tpm_db_c2_data_get(index, &c2_entry_db);
+		IF_ERROR(TPM_C2_MOD, ret_code);
+		if (c2_entry_db.valid == TPM_C2_ENTRY_INVALID)
+			break;
+	}
+	if (index == TPM_C2_ENTRY_MAX) {
+		TPM_OS_ERROR(TPM_C2_MOD, "No free space in DB\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	/* record c2 entry to DB */
+	memcpy(&c2_entry_db.port, &c2_entry->port, sizeof(struct tpm_src_port_t));
+	c2_entry_db.lkp_type = c2_entry->lkp_type;
+	c2_entry_db.lkp_type_mask = c2_entry->lkp_type_mask;
+	c2_entry_db.priority = c2_entry->priority;
+	c2_entry_db.field_bm = c2_entry->field_bm;
+	/* pkt Key */
+	c2_entry_db.mng_pkt_key.ttl = c2_entry->mng_pkt_key->ttl;
+	c2_entry_db.mng_pkt_key.tcp_flag = c2_entry->mng_pkt_key->tcp_flag;
+	c2_entry_db.mng_pkt_key.tcp_flag_mask = c2_entry->mng_pkt_key->tcp_flag_mask;
+	memcpy(&c2_entry_db.mng_pkt_key.pkt_key, c2_entry->mng_pkt_key->pkt_key, sizeof(struct tpm_pkt_key_t));
+	/* Qos */
+	memcpy(&c2_entry_db.qos_info, &c2_entry->qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&c2_entry_db.action, &c2_entry->action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&c2_entry_db.qos_value, &c2_entry->qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&c2_entry_db.pkt_mod, &c2_entry->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&c2_entry_db.flow_info, &c2_entry->flow_info, sizeof(struct tpm_duplicate_t));
+	c2_entry_db.valid = TPM_C2_ENTRY_VALID;
+
+	/* Write to db */
+	ret_code = tpm_db_c2_data_set(index, &c2_entry_db);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Return db index */
+	*c2_db_idx = index;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_data_entry_db_del()
+*
+* DESCRIPTION: Delete HW TCAM entry data record in data DB.
+*
+* INPUTS:
+*          c2_db_idx  - the data db entry index
+*
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_c2_data_entry_db_del(unsigned int c2_db_idx)
+{
+	struct tpm_c2_data_t c2_db_data;
+
+	memset(&c2_db_data, 0, sizeof(struct tpm_c2_data_t));
+	if (tpm_db_c2_data_set(c2_db_idx, &c2_db_data))
+		return TPM_SET_ERROR;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_lkp_type_list_pri_get()
+*
+* DESCRIPTION: Get the highest priority and lowest priority of the lookup type list.
+*
+* INPUTS:
+*          lkp_type   - lookup type of list
+*
+* OUTPUTS:
+*          hignest_pri  - highest priority
+*          lowest_pri   - lowest priority
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          The list can not be empty.
+*******************************************************************************/
+static int tpm_c2_lkp_type_list_pri_get(unsigned char lkp_type,
+					unsigned int *hignest_pri,
+					unsigned int *lowest_pri)
+{
+	struct list_head *lkp_type_list_head;
+	struct tpm_c2_index_t *c2_index_node;
+	struct tpm_c2_data_t c2_entry_data;
+
+	/* param check */
+	IF_NULL(TPM_C2_MOD, hignest_pri);
+	IF_NULL(TPM_C2_MOD, lowest_pri);
+
+	/* Get list head */
+	lkp_type_list_head = tpm_db_c2_lkp_type_list_head_get(lkp_type);
+
+	if (list_empty(lkp_type_list_head)) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list (%d) is empty\n", lkp_type);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Get first priority */
+	c2_index_node = list_first_entry(lkp_type_list_head,
+					 struct tpm_c2_index_t,
+					 list_node);
+	/* get C2 db entry data */
+	if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+		return TPM_GET_ERROR;
+	*hignest_pri = c2_entry_data.priority;
+	*lowest_pri = c2_entry_data.priority;
+
+	/* Search the list */
+	list_for_each_entry(c2_index_node, lkp_type_list_head, list_node) {
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if ((*hignest_pri) > c2_entry_data.priority)
+			*hignest_pri = c2_entry_data.priority;
+		if ((*lowest_pri) < c2_entry_data.priority)
+			*lowest_pri = c2_entry_data.priority;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_lkp_type_list_neighbour_pri_get()
+*
+* DESCRIPTION: The routine will get the neighbour priority of given priority.
+*
+* INPUTS:
+*          lkp_type   - lookup type of list
+*          priority   - interal priority.
+*          highest_pri- current highest priority of list
+*          lowest_pri - current highest priority of list
+*
+* OUTPUTS:
+*          pri_prev   - privious neighbour priority
+*          pri_next   - following(next) neighbour priority
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          The list can not be empty, meet: priority > highest, priority < lowest
+*******************************************************************************/
+static int tpm_c2_lkp_type_list_neighbour_pri_get(unsigned int lkp_type,
+						  unsigned int priority,
+						  unsigned int highest_pri,
+						  unsigned int lowest_pri,
+						  unsigned int *pri_prev,
+						  unsigned int *pri_next)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	struct tpm_c2_data_t c2_entry_data;
+	unsigned int pri_temp_h = 0, pri_temp_l = 0;
+
+	/* para check */
+	IF_NULL(TPM_C2_MOD, pri_prev);
+	IF_NULL(TPM_C2_MOD, pri_next);
+
+
+	if (priority < highest_pri || priority > lowest_pri) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid internal priority %d\n", priority);
+		return TPM_BAD_PARAM;
+	}
+
+	if (highest_pri == lowest_pri) {
+		*pri_prev = TPM_C2_LKP_TYPE_INVALID_PRI;
+		*pri_next = TPM_C2_LKP_TYPE_INVALID_PRI;
+		return TPM_OK;
+	}
+
+	/* Traverse lookup type list */
+	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
+		/* get C2 db entry data */
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if (priority > c2_entry_data.priority)
+			pri_temp_h = c2_entry_data.priority;
+		if (priority < c2_entry_data.priority && pri_temp_l == 0)
+			pri_temp_l = c2_entry_data.priority;
+	}
+
+	*pri_prev = pri_temp_h;
+	*pri_next = pri_temp_l;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_c2_lkp_type_pri_node_info_get()
+*
+* DESCRIPTION: Get the node information in the list with the same internal priority,
+*              including, first/last entry node in C2 HW, count of node with same priority
+*
+* INPUTS:
+*          lkp_type   - lookup type of list
+*          priority   - internal priority
+*
+* OUTPUTS:
+*          c2_hw_first_node  - first c2 hw node in C2 HW table
+*          c2_hw_last_node   - last c2 hw node in C2 HW table
+*          node_count        - count of node with the same priority
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_c2_lkp_type_pri_node_info_get(unsigned char lkp_type,
+					     unsigned int priority,
+					     struct tpm_c2_index_t **c2_hw_first_node,
+					     struct tpm_c2_index_t **c2_hw_last_node,
+					     unsigned int *node_count)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	struct tpm_c2_data_t c2_entry_data;
+	int i;
+
+	/* param check */
+	IF_NULL(TPM_C2_MOD, c2_hw_first_node);
+	IF_NULL(TPM_C2_MOD, c2_hw_last_node);
+	IF_NULL(TPM_C2_MOD, node_count);
+
+	i = 0;
+	/* Traverse lookup type list */
+	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
+		/* get C2 db entry data */
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if (c2_entry_data.priority == priority) {
+			if (i == 0) {
+				*c2_hw_first_node = c2_index_node;
+				*c2_hw_last_node = c2_index_node;
+			} else {
+				/* Find the first C2 HW entry in HW table */
+				if ((*c2_hw_first_node)->c2_hw_idx > c2_index_node->c2_hw_idx)
+					*c2_hw_first_node = c2_index_node;
+				/* Find the last C2 HW entry in HW table */
+				if ((*c2_hw_last_node)->c2_hw_idx < c2_index_node->c2_hw_idx)
+					*c2_hw_last_node = c2_index_node;
+			}
+			i++;
+		}
+	}
+
+	/* if no node with pri, return invalid index */
+	if (i == 0) {
+		*c2_hw_first_node = NULL;
+		*c2_hw_last_node = NULL;
+	}
+	*node_count = i;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_lkp_search_up_block_get()
+*
+* DESCRIPTION: Find the search block between priority pri_start and its privious
+*              neighbour priority.
+*
+* INPUTS:
+*          lkp_type   - lookup type of list
+*          pri_start  - start priority
+*
+* OUTPUTS:
+*          c2_search_start  - start C2 HW index to search
+*          c2_search_end    - end C2 HW index to search
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          The list can not be empty.
+*******************************************************************************/
+static int tpm_c2_lkp_search_up_block_get(unsigned char lkp_type,
+					  unsigned int pri_start,
+					  unsigned int *c2_search_start,
+					  unsigned int *c2_search_end)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	struct tpm_c2_data_t c2_entry_data;
+	unsigned int first_pri_find, prev_pri_find;
+	unsigned int next_pri;
+
+	/* Para check */
+	IF_NULL(TPM_C2_MOD, c2_search_start);
+	IF_NULL(TPM_C2_MOD, c2_search_end);
+
+	first_pri_find = 0;
+	prev_pri_find = 0;
+	next_pri = 0;
+	/* Traverse lookup type list */
+	list_for_each_entry_reverse(c2_index_node,
+				    tpm_db_c2_lkp_type_list_head_get(lkp_type),
+				    list_node) {
+		/* get C2 db entry data */
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if (c2_entry_data.priority == pri_start) {
+			if (first_pri_find == 0) {
+					*c2_search_end = c2_index_node->c2_hw_idx;
+			} else {
+				/* Find the last C2 HW entry in HW table */
+				if (*c2_search_end < c2_index_node->c2_hw_idx)
+					*c2_search_end = c2_index_node->c2_hw_idx;
+			}
+			first_pri_find++;
+		}
+		/* Find the next priority */
+		if (first_pri_find != 0 && c2_entry_data.priority != pri_start) {
+			if (prev_pri_find == 0) {
+				next_pri = c2_entry_data.priority;
+				*c2_search_start = c2_index_node->c2_hw_idx;
+			} else {
+				/* Find the last C2 HW entry in HW table */
+				if (*c2_search_start < c2_index_node->c2_hw_idx)
+					*c2_search_start = c2_index_node->c2_hw_idx;
+			}
+			prev_pri_find++;
+		}
+		/* Stop search */
+		if (prev_pri_find != 0 && c2_entry_data.priority != next_pri)
+			break;
+	}
+	/* if no node with pri, return invalid index */
+	if (first_pri_find == 0)
+		*c2_search_end = TPM_C2_ENTRY_INVALID_IDX;
+	if (prev_pri_find == 0) {
+		if (first_pri_find == 0)
+			*c2_search_start = TPM_C2_ENTRY_INVALID_IDX;
+		else
+			*c2_search_start = TPM_C2_FIRST_ENTRY;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_lkp_search_down_block_get()
+*
+* DESCRIPTION: Find the search block between priority pri_start and its next
+*              neighbour priority.
+*
+* INPUTS:
+*          lkp_type   - lookup type of list
+*          pri_start  - start priority
+*
+* OUTPUTS:
+*          c2_search_start  - start C2 HW index to search
+*          c2_search_end    - end C2 HW index to search
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          The list can not be empty.
+*******************************************************************************/
+static int tpm_c2_lkp_search_down_block_get(unsigned char lkp_type,
+					    unsigned int pri_start,
+					    unsigned int *c2_search_start,
+					    unsigned int *c2_search_end)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	struct tpm_c2_data_t c2_entry_data;
+	unsigned int first_pri_find, next_pri_find;
+	unsigned int next_pri;
+
+	/* Para check */
+	IF_NULL(TPM_C2_MOD, c2_search_start);
+	IF_NULL(TPM_C2_MOD, c2_search_end);
+
+	first_pri_find = 0;
+	next_pri_find = 0;
+	next_pri = 0;
+	/* Traverse lookup type list */
+	list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type), list_node) {
+		/* get C2 db entry data */
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if (c2_entry_data.priority == pri_start) {
+			if (first_pri_find == 0) {
+					*c2_search_start = c2_index_node->c2_hw_idx;
+			} else {
+				/* Find the first C2 HW entry in HW table */
+				if (*c2_search_start > c2_index_node->c2_hw_idx)
+					*c2_search_start = c2_index_node->c2_hw_idx;
+			}
+			first_pri_find++;
+		}
+		/* Find the next priority */
+		if (first_pri_find != 0 && c2_entry_data.priority > pri_start) {
+			if (next_pri_find == 0) {
+				next_pri = c2_entry_data.priority;
+				*c2_search_end = c2_index_node->c2_hw_idx;
+			} else {
+				/* Find the first C2 HW entry in HW table */
+				if (*c2_search_end > c2_index_node->c2_hw_idx)
+					*c2_search_end = c2_index_node->c2_hw_idx;
+			}
+			next_pri_find++;
+		}
+		/* Stop search */
+		if (next_pri_find != 0 && c2_entry_data.priority > next_pri)
+			break;
+	}
+	/* if no node with pri, return invalid index */
+	if (first_pri_find == 0)
+		*c2_search_start = TPM_C2_ENTRY_INVALID_IDX;
+	if (next_pri_find == 0) {
+		if (first_pri_find == 0)
+			*c2_search_end = TPM_C2_ENTRY_INVALID_IDX;
+		else
+			*c2_search_end = TPM_C2_LAST_ENTRY;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_lkp_type_list_add()
+*
+* DESCRIPTION: Add the new index node to lookup type list
+*
+* INPUTS:
+*          lkp_type     - lookup type
+*          priority     - new entry internal priority
+*          c2_hw_idx    - new entry HW index
+*          c2_db_idx    - DB index store new entry data
+*          c2_logic_idx - logic index allocated when add the C2 rule
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_c2_lkp_type_list_add(unsigned char lkp_type,
+				    unsigned int priority,
+				    unsigned int c2_hw_idx,
+				    unsigned int c2_db_idx,
+				    unsigned int c2_logic_idx)
+{
+	int ret_code;
+	struct list_head *lkp_type_list_head;
+	struct tpm_c2_index_t *c2_index_node, *temp_node;
+	struct tpm_c2_data_t c2_entry_data;
+	unsigned int highest_pri, lowest_pri;
+	unsigned int index;
+
+	/* Get list head */
+	lkp_type_list_head = tpm_db_c2_lkp_type_list_head_get(lkp_type);
+
+	/* Get the invalid index node */
+	for (index = 0; index < TPM_C2_ENTRY_MAX; index++) {
+		c2_index_node = tpm_db_c2_index_node_get(index);
+		if (c2_index_node == NULL)
+			return TPM_NO_SUCH;
+		if (c2_index_node->valid == TPM_C2_ENTRY_INVALID)
+			break;
+	}
+	if (index == TPM_C2_ENTRY_MAX)
+		return TPM_NO_SUCH;
+
+	c2_index_node->c2_hw_idx = c2_hw_idx;
+	c2_index_node->c2_data_db_idx = c2_db_idx;
+	c2_index_node->c2_logic_idx = c2_logic_idx;
+
+	/* Check lkp list is empty or not */
+	if (list_empty(lkp_type_list_head)) {
+		/* Just add the new node */
+		list_add(&c2_index_node->list_node, lkp_type_list_head);
+		/* Change Valid status to valid */
+		c2_index_node->valid = TPM_C2_ENTRY_VALID;
+		return TPM_OK;
+	}
+
+	ret_code = tpm_c2_lkp_type_list_pri_get(lkp_type, &highest_pri, &lowest_pri);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* New node with highest priority */
+	if (highest_pri >= priority) {
+		/* Just add the new node to first */
+		list_add(&c2_index_node->list_node, lkp_type_list_head);
+		/* Change Valid status to valid */
+		c2_index_node->valid = TPM_C2_ENTRY_VALID;
+		return TPM_OK;
+	}
+
+	/* New node with lowest priority */
+	if (highest_pri <= priority) {
+		/* Just add the new node to end */
+		list_add_tail(&c2_index_node->list_node, lkp_type_list_head);
+		/* Change Valid status to valid */
+		c2_index_node->valid = TPM_C2_ENTRY_VALID;
+		return TPM_OK;
+	}
+
+	/* New node not the highest and lowest, add it after first node with priority lower than new priority */
+	/* Traverse lookup type list */
+	list_for_each_entry(temp_node, lkp_type_list_head, list_node) {
+		/* get C2 db entry data */
+		if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_entry_data))
+			return TPM_GET_ERROR;
+		if (c2_entry_data.priority > priority) {
+			list_add_tail(&c2_index_node->list_node, &temp_node->list_node);
+			/* Change Valid status to valid */
+			c2_index_node->valid = TPM_C2_ENTRY_VALID;
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_entry_is_free
+*
+* DESCRIPTION: The API will to check whether the c2 entry is free or not.
+* INPUTS:
+*           c2_hw_idx     - first C2 entry index occupied
+*
+* OUTPUTS:
+*           c2_index_node - C2 index node if free, or NULL
+*
+* RETURNS:
+*         0 - free, 1 - occupied
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_entry_is_free(unsigned int c2_hw_idx,
+				struct tpm_c2_index_t **c2_index_node)
+{
+	struct list_head *list;
+
+	IF_NULL(TPM_C2_MOD, c2_index_node);
+
+	/* Traverse free list */
+	list_for_each(list, tpm_db_c2_free_list_head_get()) {
+		/* get list node */
+		*c2_index_node = list_entry(list, struct tpm_c2_index_t, list_node);
+		if ((*c2_index_node)->c2_hw_idx == c2_hw_idx)
+			return TPM_C2_ENTRY_FREE_TRUE;
+	}
+	*c2_index_node = NULL;
+	return TPM_C2_ENTRY_FREE_FALSE;
+}
+
+/*******************************************************************************
+* tpm_c2_free_slot_find
+*
+* DESCRIPTION: The API will find the first free slot between index1 and index2.
+*              If found free slot, delete it from free list.
+* INPUTS:
+*           index1  - first C2 entry index occupied
+*           index2  - second C2 entry index occupied
+*
+* OUTPUTS:
+*           c2_hw_idx - Free C2 HW entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           index2 must greater than index1.
+*******************************************************************************/
+static int tpm_c2_free_slot_find(unsigned int index1,
+				 unsigned int index2,
+				 unsigned int *free_idx)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	int found = 0;
+
+	IF_NULL(TPM_C2_MOD, free_idx);
+
+	if (index1 >= index2) {
+		*free_idx = TPM_C2_ENTRY_INVALID_IDX;
+		return TPM_OK;
+	}
+	/* Traverse free list */
+	list_for_each_entry(c2_index_node, tpm_db_c2_free_list_head_get(), list_node) {
+		if ((c2_index_node->c2_hw_idx > index1) &&
+		    (c2_index_node->c2_hw_idx < index2)) {
+			found++;
+			/* delete it from free list */
+			list_del(&c2_index_node->list_node);
+			/* Change to node valid status to invalid */
+			c2_index_node->valid = TPM_C2_ENTRY_INVALID;
+			*free_idx = c2_index_node->c2_hw_idx;
+			break;
+		}
+	}
+	if (found == 0)
+		*free_idx = TPM_C2_ENTRY_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_make_slot_high()
+*
+* DESCRIPTION: This routine is sub routine of "tpm_c2_make_slot"
+*
+* INPUTS:
+*          lkp_type   - lookup type
+*          priority   - priority for new slot
+*          highest_pri- highest priority of current lookup type list
+*          lowest_pri - lowest priority of current lookup type list
+* OUTPUTS:
+*          c2_hw_idx  - available C2 TCAM index for new rule
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+* COMMENTS:
+*           The lkp_type list can not be empty.
+*           priority <= highest_pri
+*******************************************************************************/
+static int tpm_c2_make_slot_high(unsigned int lkp_type,
+				 unsigned int priority,
+				 unsigned int highest_pri,
+				 unsigned int lowest_pri,
+				 unsigned int *c2_hw_idx)
+{
+	int ret_code;
+	struct tpm_c2_index_t *c2_index_node = NULL, *c2_first_node = NULL, *c2_last_node = NULL;
+	unsigned int free_idx, tpm_idx, node_count;
+	unsigned int c2_search_start, c2_search_end;
+	int pri_tmp, i;
+	MV_PP2_CLS_C2_ENTRY c2_entry;
+
+	/* No need to agjust C2 way */
+	if (TPM_C2_ENTRY_FREE_TRUE == tpm_c2_entry_is_free(TPM_C2_FIRST_ENTRY, &c2_index_node)) {
+		/* delete it from free list */
+		list_del(&c2_index_node->list_node);
+		/* Change to node valid status to invalid */
+		c2_index_node->valid = TPM_C2_ENTRY_INVALID;
+		/* return c2 hw index */
+		*c2_hw_idx = TPM_C2_FIRST_ENTRY;
+		return TPM_OK;
+	}
+
+	ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+						     highest_pri,
+						     &c2_first_node,
+						     &c2_last_node,
+						     &node_count);
+	if (ret_code) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list(%d) priority (%d) node info get failed\n",
+			     lkp_type, highest_pri);
+		return TPM_GET_ERROR;
+	}
+	if (c2_first_node != NULL &&
+	    c2_first_node->c2_hw_idx > TPM_C2_FIRST_ENTRY) {
+		/* Find the available slot */
+		ret_code = tpm_c2_free_slot_find(TPM_C2_FIRST_ENTRY, c2_first_node->c2_hw_idx, &free_idx);
+		if (ret_code) {
+			TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+				     TPM_C2_FIRST_ENTRY, c2_first_node->c2_hw_idx);
+			return TPM_GET_ERROR;
+		}
+		if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+			/* return c2 hw index */
+			*c2_hw_idx = free_idx;
+			return TPM_OK;
+		}
+	}
+
+	/* Search down and adjust C2 original entries */
+	for (pri_tmp = highest_pri; pri_tmp <= lowest_pri; pri_tmp++) {
+		/* Get search block */
+		ret_code = tpm_c2_lkp_search_down_block_get(lkp_type,
+							    pri_tmp,
+							    &c2_search_start,
+							    &c2_search_end);
+		if (ret_code) {
+			TPM_OS_ERROR(TPM_C2_MOD, "Search blcok get failed\n");
+			return TPM_GET_ERROR;
+		}
+		if (c2_search_start != TPM_C2_ENTRY_INVALID_IDX) {
+			ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+					     c2_search_start, c2_search_end);
+				return TPM_GET_ERROR;
+			}
+			if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+				/* Find free entry, adjust C2 table */
+				for (i = pri_tmp; i >= (int)highest_pri; i--) {
+					tpm_idx = free_idx;
+					/* Find the first entry with priority found free slot */
+					ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+										     i,
+										     &c2_first_node,
+										     &c2_last_node,
+										     &node_count);
+					if (ret_code)
+						return TPM_GET_ERROR;
+					if (c2_first_node != NULL) {
+						mvPp2ClsC2SwClear(&c2_entry);
+						mvPp2ClsC2HwRead(c2_first_node->c2_hw_idx, &c2_entry);
+						mvPp2ClsC2HwWrite(free_idx, &c2_entry);
+						/* Continue next move */
+						free_idx = c2_first_node->c2_hw_idx;
+						/* Update C2 index node of the lookup type */
+						c2_first_node->c2_hw_idx = tpm_idx;
+					}
+				}
+				*c2_hw_idx = free_idx;
+				return TPM_OK;
+			}
+		}
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_c2_make_slot_middle()
+*
+* DESCRIPTION: This routine is sub routine of "tpm_c2_make_slot"
+*
+* INPUTS:
+*          lkp_type   - lookup type
+*          priority   - priority for new slot
+*          highest_pri- highest priority of current lookup type list
+*          lowest_pri - lowest priority of current lookup type list
+* OUTPUTS:
+*          c2_hw_idx  - available C2 TCAM index for new rule
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+* COMMENTS:
+*           The lkp_type list can not be empty.
+*            priority > highest_pri; priority < lowest_pri
+*******************************************************************************/
+static int tpm_c2_make_slot_middle(unsigned int lkp_type,
+				   unsigned int priority,
+				   unsigned int highest_pri,
+				   unsigned int lowest_pri,
+				   unsigned int *c2_hw_idx)
+{
+	int ret_code;
+	struct tpm_c2_index_t *c2_index_node = NULL, *c2_first_node = NULL, *c2_last_node = NULL;
+	unsigned int free_idx, tpm_idx, node_count;
+	unsigned int c2_search_start, c2_search_end;
+	int pri_tmp, pri_prev, pri_next, i;
+	MV_PP2_CLS_C2_ENTRY c2_entry;
+
+	/* No need adjust other C2 entry way */
+	ret_code = tpm_c2_lkp_type_list_neighbour_pri_get(lkp_type,
+							  priority,
+							  highest_pri,
+							  lowest_pri,
+							  &pri_prev,
+							  &pri_next);
+	if (ret_code)
+		return TPM_GET_ERROR;
+	/* Get node info with priority */
+	if (pri_prev != TPM_C2_LKP_TYPE_INVALID_PRI) {
+		ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+							     pri_prev,
+							     &c2_first_node,
+							     &c2_last_node,
+							     &node_count);
+		if (ret_code)
+			return TPM_GET_ERROR;
+		if (c2_last_node != NULL)
+			c2_search_start = c2_last_node->c2_hw_idx;
+	}
+	if (pri_next != TPM_C2_LKP_TYPE_INVALID_PRI) {
+		ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+							     pri_next,
+							     &c2_first_node,
+							     &c2_last_node,
+							     &node_count);
+		if (ret_code)
+			return TPM_GET_ERROR;
+		if (c2_first_node != NULL)
+			c2_search_end = c2_first_node->c2_hw_idx;
+	}
+	/* Find the available before first node */
+	ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
+	if (ret_code) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+			     c2_search_start, c2_search_end);
+		return TPM_GET_ERROR;
+	}
+	if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+		/* return c2 hw index */
+		*c2_hw_idx = free_idx;
+
+		return TPM_OK;
+	}
+
+	/* Search up and adjust C2 original entries */
+	for (pri_tmp = pri_prev; pri_tmp >= (int)highest_pri; pri_tmp--) {
+		/* Get search block */
+		ret_code = tpm_c2_lkp_search_up_block_get(lkp_type,
+							  pri_tmp,
+							  &c2_search_start,
+							  &c2_search_end);
+		if (c2_search_end != TPM_C2_ENTRY_INVALID_IDX) {
+			/* Special handle entry 0 */
+			if (c2_search_start == TPM_C2_FIRST_ENTRY &&
+			    TPM_C2_ENTRY_FREE_TRUE == tpm_c2_entry_is_free(c2_search_start, &c2_index_node)) {
+					/* delete it from free list */
+					list_del(&c2_index_node->list_node);
+					/* Change to node valid status to invalid */
+					c2_index_node->valid = TPM_C2_ENTRY_INVALID;
+					free_idx = c2_search_start;
+			} else {
+				ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
+				if (ret_code) {
+					TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+						     c2_search_start, c2_search_end);
+					return TPM_GET_ERROR;
+				}
+			}
+			if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+				/* Find free entry, adjust C2 table */
+				for (i = pri_tmp; i <= pri_prev; i++) {
+					tpm_idx = free_idx;
+					/* Find the first entry with priority found free slot */
+					ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+										     i,
+										     &c2_first_node,
+										     &c2_last_node,
+										     &node_count);
+					if (ret_code)
+						return TPM_GET_ERROR;
+					if (c2_last_node != NULL) {
+						mvPp2ClsC2SwClear(&c2_entry);
+						mvPp2ClsC2HwRead(c2_last_node->c2_hw_idx, &c2_entry);
+						mvPp2ClsC2HwWrite(free_idx, &c2_entry);
+						/* Continue next move */
+						free_idx = c2_last_node->c2_hw_idx;
+						/* Update C2 index node of the lookup type */
+						c2_last_node->c2_hw_idx = tpm_idx;
+					}
+				}
+				*c2_hw_idx = free_idx;
+				return TPM_OK;
+			}
+		}
+	}
+
+	/* Search down and adjust C2 original entries */
+	for (pri_tmp = pri_next; pri_tmp <= (int)lowest_pri; pri_tmp++) {
+		/* Get search block */
+		ret_code = tpm_c2_lkp_search_down_block_get(lkp_type,
+							    pri_tmp,
+							    &c2_search_start,
+							    &c2_search_end);
+		if (c2_search_start != TPM_C2_ENTRY_INVALID_IDX) {
+			ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+					     c2_search_start, c2_search_end);
+				return TPM_GET_ERROR;
+			}
+			if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+				/* Find free entry, adjust C2 table */
+				for (i = pri_tmp; i >= pri_next; i--) {
+					tpm_idx = free_idx;
+					/* Find the first entry with priority found free slot */
+					ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+										     i,
+										     &c2_first_node,
+										     &c2_last_node,
+										     &node_count);
+					if (ret_code)
+						return TPM_GET_ERROR;
+					if (c2_last_node != NULL) {
+						mvPp2ClsC2SwClear(&c2_entry);
+						mvPp2ClsC2HwRead(c2_first_node->c2_hw_idx, &c2_entry);
+						mvPp2ClsC2HwWrite(free_idx, &c2_entry);
+						/* Continue next move */
+						free_idx = c2_first_node->c2_hw_idx;
+						/* Update C2 index node of the lookup type */
+						c2_first_node->c2_hw_idx = tpm_idx;
+					}
+				}
+				*c2_hw_idx = free_idx;
+				return TPM_OK;
+			}
+		}
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_c2_make_slot_low()
+*
+* DESCRIPTION: This routine is sub routine of "tpm_c2_make_slot"
+*
+* INPUTS:
+*          lkp_type   - lookup type
+*          priority   - priority for new slot
+*          highest_pri- highest priority of current lookup type list
+*          lowest_pri - lowest priority of current lookup type list
+* OUTPUTS:
+*          c2_hw_idx  - available C2 TCAM index for new rule
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+* COMMENTS:
+*           The lkp_type list can not be empty.
+*           priority >= lowest_pri
+*******************************************************************************/
+static int tpm_c2_make_slot_low(unsigned int lkp_type,
+				unsigned int priority,
+				unsigned int highest_pri,
+				unsigned int lowest_pri,
+				unsigned int *c2_hw_idx)
+{
+	int ret_code;
+	struct tpm_c2_index_t *c2_index_node = NULL, *c2_first_node = NULL, *c2_last_node = NULL;
+	unsigned int free_idx, tpm_idx, node_count;
+	unsigned int c2_search_start, c2_search_end;
+	int pri_tmp, i;
+	MV_PP2_CLS_C2_ENTRY c2_entry;
+
+	/* No need adjust other C2 entry way */
+	/* get last node with lowest priority */
+	ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+						     lowest_pri,
+						     &c2_first_node,
+						     &c2_last_node,
+						     &node_count);
+	if (ret_code) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list(%d) priority (%d) node info get failed\n",
+			     lkp_type, lowest_pri);
+		return TPM_GET_ERROR;
+	}
+	/* try to find the slot after last node with lowest_pri */
+	if (c2_last_node != NULL) {
+		/* Find the available slot */
+		ret_code = tpm_c2_free_slot_find(c2_last_node->c2_hw_idx, TPM_C2_LAST_ENTRY, &free_idx);
+		if (ret_code) {
+			TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+				     c2_last_node->c2_hw_idx, TPM_C2_LAST_ENTRY);
+			return TPM_GET_ERROR;
+		}
+		if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+			/* return c2 hw index */
+			*c2_hw_idx = free_idx;
+
+			return TPM_OK;
+		}
+	}
+	/* find available slot above node with current lowest priority */
+	/* Search up and adjust C2 original entries */
+	for (pri_tmp = lowest_pri; pri_tmp >= (int)highest_pri; pri_tmp--) {
+		/* Get search block */
+		ret_code = tpm_c2_lkp_search_up_block_get(lkp_type,
+							  pri_tmp,
+							  &c2_search_start,
+							  &c2_search_end);
+		if (c2_search_end != TPM_C2_ENTRY_INVALID_IDX) {
+			/* Special handle entry 0 */
+			if (c2_search_start == TPM_C2_FIRST_ENTRY &&
+			    TPM_C2_ENTRY_FREE_TRUE == tpm_c2_entry_is_free(c2_search_start, &c2_index_node)) {
+					/* delete it from free list */
+					list_del(&c2_index_node->list_node);
+					/* Change to node valid status to invalid */
+					c2_index_node->valid = TPM_C2_ENTRY_INVALID;
+					free_idx = c2_search_start;
+			} else {
+				ret_code = tpm_c2_free_slot_find(c2_search_start, c2_search_end, &free_idx);
+				if (ret_code) {
+					TPM_OS_ERROR(TPM_C2_MOD, "Free slot between (%d) and (%d) failed\n",
+						     c2_search_start, c2_search_end);
+					return TPM_GET_ERROR;
+				}
+			}
+			if (free_idx != TPM_C2_ENTRY_INVALID_IDX) {
+				/* Find free entry, adjust C2 table */
+				for (i = pri_tmp; i <= (int)lowest_pri; i++) {
+					tpm_idx = free_idx;
+					/* Find the first entry with priority found free slot */
+					ret_code = tpm_c2_lkp_type_pri_node_info_get(lkp_type,
+								i,
+								&c2_first_node,
+								&c2_last_node,
+								&node_count);
+					if (ret_code)
+						return TPM_GET_ERROR;
+					if (c2_last_node != NULL) {
+						mvPp2ClsC2SwClear(&c2_entry);
+						mvPp2ClsC2HwRead(c2_last_node->c2_hw_idx, &c2_entry);
+						mvPp2ClsC2HwWrite(free_idx, &c2_entry);
+						/* Continue next move */
+						free_idx = c2_last_node->c2_hw_idx;
+						/* Update C2 index node of the lookup type */
+						c2_last_node->c2_hw_idx = tpm_idx;
+					}
+				}
+				*c2_hw_idx = free_idx;
+				return TPM_OK;
+			}
+		}
+	}
+
+	return TPM_NO_RESOURCE;
+}
+
+/*******************************************************************************
+* tpm_c2_make_slot
+*
+* DESCRIPTION: The API is called when creating a new C2 entry in HW,
+*              and need to make room for it and adjust original C2 entries down or up.
+* INPUTS:
+*           lkp_type  - C2 entry lookup type
+*           priority  - C2 entry internal priority with same lookup type
+*
+* OUTPUTS:
+*           c2_hw_idx - Free C2 HW entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_make_slot(unsigned char lkp_type,
+			    unsigned int priority,
+			    unsigned int *c2_hw_idx)
+{
+	int ret_code = TPM_OK;
+	struct tpm_c2_index_t *c2_index_node = NULL;
+	unsigned int highest_pri = 0, lowest_pri = 0;
+
+	/* Patameter check */
+	IF_NULL(TPM_C2_MOD, c2_hw_idx);
+
+	/* check free list empty or not */
+	if (list_empty(tpm_db_c2_free_list_head_get())) {
+		TPM_OS_ERROR(TPM_C2_MOD, "No free C2 entry for lookup typs %d, priority %d\n", lkp_type, priority);
+		return TPM_NO_RESOURCE;
+	}
+
+	/* lkp type list empty, find any available slot */
+	if (list_empty(tpm_db_c2_lkp_type_list_head_get(lkp_type))) {
+		c2_index_node = list_first_entry(tpm_db_c2_free_list_head_get(),
+						 struct tpm_c2_index_t,
+						 list_node);
+		/* delete it from free list */
+		list_del(&c2_index_node->list_node);
+		/* Change to node valid status to invalid */
+		c2_index_node->valid = TPM_C2_ENTRY_INVALID;
+		/* return c2 hw index */
+		*c2_hw_idx = c2_index_node->c2_hw_idx;
+		return TPM_OK;
+	}
+
+	/* Get the highest priority and lowest priority */
+	ret_code = tpm_c2_lkp_type_list_pri_get(lkp_type, &highest_pri, &lowest_pri);
+	if (ret_code != TPM_OK) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Lookup type list(%d) priority get failed\n", lkp_type);
+		return TPM_GET_ERROR;
+	}
+
+	/* According to priority and current priority in list, search avaliable slot */
+	if (priority <= highest_pri)
+		ret_code = tpm_c2_make_slot_high(lkp_type, priority, highest_pri, lowest_pri, c2_hw_idx);
+	else if (priority >= lowest_pri)
+		ret_code = tpm_c2_make_slot_low(lkp_type, priority, highest_pri, lowest_pri, c2_hw_idx);
+	else
+		ret_code = tpm_c2_make_slot_middle(lkp_type, priority, highest_pri, lowest_pri, c2_hw_idx);
+
+	return ret_code;
+}
+
+/*******************************************************************************
+* tpm_c2_rule_add_check
+*
+* DESCRIPTION: The routine will check the input parameters when adding c2 rule.
+* INPUTS:
+*           c2_entry  - parameters needed when adding C2 entry
+*
+* OUTPUTS:
+*           None.
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_rule_add_check(struct tpm_c2_add_entry_t *c2_entry)
+{
+	struct tpm_field_match_info field_info[TPM_FLOW_FIELD_COUNT_MAX + 1];
+	int i;
+	unsigned int bits_cnt = 0;
+
+	/* check c2_entry NULL */
+	IF_NULL(TPM_C2_MOD, c2_entry);
+
+	/* Port check */
+	if (c2_entry->port.port_type > TPM_SRC_PORT_TYPE_VIR ||
+	    c2_entry->port.port_type < TPM_SRC_PORT_TYPE_PHY) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid port type(%d)\n", c2_entry->port.port_type);
+		return TPM_BAD_PARAM;
+	}
+	if (c2_entry->port.port_type == TPM_SRC_PORT_TYPE_VIR) {
+		if (c2_entry->port.port_value > TPM_VIRT_PORT_ID_MAX) {
+			TPM_OS_ERROR(TPM_C2_MOD, "Invalid Virt port ID(%d)\n", c2_entry->port.port_value);
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	/* Lookup type check */
+	if (c2_entry->lkp_type >= TPM_C2_LKP_TYPE_MAX) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid lookup type(%d)\n", c2_entry->lkp_type);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Packet key check  */
+	if (c2_entry->mng_pkt_key == NULL) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Input NULL pointer\n");
+		return TPM_BAD_PARAM;
+	}
+	/* Get field info */
+	memset(field_info, 0, sizeof(struct tpm_field_match_info) * (TPM_FLOW_FIELD_COUNT_MAX + 1));
+	if (tpm_field_bm_to_field_info(c2_entry->field_bm,
+				       c2_entry->mng_pkt_key,
+				       TPM_FLOW_FIELD_COUNT_MAX + 1,
+				       true,
+				       field_info)) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Field info get failed\n");
+		return TPM_BAD_PARAM;
+	}
+	/* Check field number, if greater than 4, invalid */
+	if (field_info[TPM_FLOW_FIELD_COUNT_MAX].valid == TPM_FIELD_VALID) {
+		TPM_OS_ERROR(TPM_C2_MOD, "At most 4 fileds are supported\n");
+		return TPM_BAD_PARAM;
+	}
+	/* Raw check field length(detail check will be done in tpm_c2_tcam_hek_get), total can not more than 8 bytes */
+	for (i = 0; i < TPM_FLOW_FIELD_COUNT_MAX; i++) {
+		if (field_info[i].valid == TPM_FIELD_VALID)
+			bits_cnt += tpm_field_size_get(field_info[i].field_id);
+	}
+	if (bits_cnt > TPM_C2_TCAM_KEY_LEN_MAX * BYTE_BITS) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Packet key length(%d bits) beyond C2 capability\n", bits_cnt);
+		return TPM_BAD_PARAM;
+	}
+
+	/* QOS check, TBD */
+
+	/* Action check, TBD */
+
+	/* Mod info check */
+	if (c2_entry->pkt_mod.mod_cmd_idx > TPM_HWF_MOD_IPTR_MAX) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid modification cmd index(%d)\n", c2_entry->pkt_mod.mod_cmd_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (c2_entry->pkt_mod.mod_data_idx > TPM_HW_MOD_DPTR_MAX) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid data index(%d)\n", c2_entry->pkt_mod.mod_data_idx);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Duplication flow info check */
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_tcam_common_field_hek_get
+*
+* DESCRIPTION: The routine will transfer pkacket key with common field whose
+*              field size do not greater than 32 bits to C2 HEK
+*
+* INPUTS:
+*           pkt_value         - field value
+*           pkt_value_mask    - field mask
+*           field_bytes       - bytes the filed occupied
+*           field_size        - field size
+*           bytes_used        - pointer to HEK bytes has been used
+*
+* OUTPUTS:
+*           c2_hek            - HEK for C2
+*           c2_hek_mask       - HEK mask for C2
+*           bytes_used        - pointer to record HEK bytes has been used
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_tcam_common_field_hek_get(unsigned int pkt_value,
+					    unsigned int pkt_value_mask,
+					    unsigned int field_bytes,
+					    unsigned int field_size,
+					    unsigned char filed_unmask,
+					    unsigned char c2_hek[],
+					    unsigned char c2_hek_mask[],
+					    unsigned int *bytes_used)
+{
+	int i;
+	unsigned int c2_hek_bytes_used;
+
+	/* Para check */
+	IF_NULL(TPM_C2_MOD, c2_hek);
+	IF_NULL(TPM_C2_MOD, c2_hek_mask);
+	IF_NULL(TPM_C2_MOD, bytes_used);
+
+	if (field_size == 0 ||
+	    field_bytes == 0)
+		return TPM_BAD_PARAM;
+
+	/* Parse packet key */
+	c2_hek_bytes_used = *bytes_used;
+	for (i = 0; i < field_bytes; i++) {
+		if (field_size % BYTE_BITS) {
+			if (i < (field_bytes - 1)) {
+				/* HEK Value */
+				c2_hek[c2_hek_bytes_used] =
+				(((pkt_value & common_mask_gen(field_size)) >>
+				  (BYTE_BITS * (field_bytes - 2 - i) + field_size % BYTE_BITS)) &
+				 BYTE_MASK);
+				/* HEK Mask */
+				c2_hek_mask[c2_hek_bytes_used] =
+				(((pkt_value_mask & common_mask_gen(field_size) &
+				   (filed_unmask ? (~(common_mask_gen(field_size))) : (common_mask_gen(field_size)))) >>
+				  (BYTE_BITS * (field_bytes - 2 - i) + field_size % BYTE_BITS)) &
+				 BYTE_MASK);
+			} else {
+				/* HEK Value */
+				c2_hek[c2_hek_bytes_used] =
+				((pkt_value << (BYTE_BITS - field_size % BYTE_BITS)) & BYTE_MASK);
+				/* HEK Mask */
+				if (!filed_unmask)
+					c2_hek_mask[c2_hek_bytes_used] =
+					((pkt_value_mask << (BYTE_BITS - field_size % BYTE_BITS)) & BYTE_MASK);
+			}
+		} else {
+			/* HEK Value */
+			c2_hek[c2_hek_bytes_used] =
+			(((pkt_value & common_mask_gen(field_size)) >>
+			  (BYTE_BITS * (field_bytes - 1 - i))) &
+			 BYTE_MASK);
+			/* HEK Mask */
+			c2_hek_mask[c2_hek_bytes_used] =
+			(((pkt_value_mask & common_mask_gen(field_size) &
+			   (filed_unmask ? (~(common_mask_gen(field_size))) : (common_mask_gen(field_size)))) >>
+			  (BYTE_BITS * (field_bytes - 1 - i))) &
+			 BYTE_MASK);
+		}
+		/* Increase HEK byte count */
+		c2_hek_bytes_used++;
+	}
+	/* Update bytes_used */
+	*bytes_used = c2_hek_bytes_used;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_tcam_shared_field_hek_get
+*
+* DESCRIPTION: The routine will transfer pkacket key with common field who
+*              shares one byte with other field to C2 HEK
+*
+* INPUTS:
+*           pkt_value         - field value
+*           pkt_value_mask    - field mask
+*           field_bytes       - bytes the filed occupied
+*           field_size        - field size
+*           comb_flag         - indicate combination is needed or not
+*           comb_offset       - combination bit offset
+*           bytes_used        - pointer to HEK bytes has been used
+*
+* OUTPUTS:
+*           c2_hek            - HEK for C2
+*           c2_hek_mask       - HEK mask for C2
+*           bytes_used        - pointer to record HEK bytes has been used
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_tcam_shared_field_hek_get(unsigned int pkt_value,
+					    unsigned int pkt_value_mask,
+					    unsigned int field_bytes,
+					    unsigned int field_size,
+					    unsigned char filed_unmask,
+					    bool comb_flag,
+					    unsigned char comb_offset,
+					    unsigned char c2_hek[],
+					    unsigned char c2_hek_mask[],
+					    unsigned int *bytes_used)
+{
+	int i;
+	unsigned int left_bits, c2_hek_bytes_used;
+	bool comb_flag1, comb_flag2;
+
+	/* Para check */
+	IF_NULL(TPM_C2_MOD, c2_hek);
+	IF_NULL(TPM_C2_MOD, c2_hek_mask);
+	IF_NULL(TPM_C2_MOD, bytes_used);
+
+	if (field_size == 0 ||
+	    field_bytes == 0)
+		return TPM_BAD_PARAM;
+
+	left_bits = field_size;
+	c2_hek_bytes_used = *bytes_used;
+	comb_flag1 = comb_flag;
+	comb_flag2 = comb_flag;
+	for (i = 0; i < field_bytes; i++) {
+		if (comb_flag2 && comb_flag1) {
+			c2_hek_bytes_used--;
+			/* HEK Value */
+			c2_hek[c2_hek_bytes_used] |=
+			(((pkt_value >> (field_size - comb_offset)) &
+			  common_mask_gen(comb_offset)) &
+			 BYTE_MASK);
+			/* HEK Mask */
+			c2_hek_mask[c2_hek_bytes_used] |=
+			(((pkt_value_mask >> (field_size - comb_offset)) &
+			  common_mask_gen(comb_offset) &
+			  (filed_unmask ? (~(common_mask_gen(comb_offset))) : common_mask_gen(comb_offset))) &
+			 BYTE_MASK);
+			if (((field_size % BYTE_BITS) + comb_offset) > BYTE_BITS ||
+			    (field_size > BYTE_BITS)) {
+				pkt_value &= common_mask_gen(field_size - comb_offset);
+				pkt_value_mask &= common_mask_gen(field_size - comb_offset);
+			}
+			c2_hek_bytes_used++;
+			left_bits = field_size - comb_offset;
+			comb_flag1 = false;
+		} else if (comb_flag2) {
+			if (left_bits % BYTE_BITS) {
+				if (i < (field_bytes - 1)) {
+					/* HEK Value */
+					c2_hek[c2_hek_bytes_used] =
+					((pkt_value & common_mask_gen(field_size)) >>
+					 (BYTE_BITS * (field_bytes - 2 - i) +
+					  left_bits % BYTE_BITS)) &
+					BYTE_MASK;
+					/* HEK Mask */
+					c2_hek_mask[c2_hek_bytes_used] =
+					((pkt_value_mask & common_mask_gen(field_size) &
+					  (filed_unmask ?
+					   (~(common_mask_gen(field_size))) : common_mask_gen(field_size))) >>
+					 (BYTE_BITS * (field_bytes - 2 - i) +
+					  left_bits % BYTE_BITS)) &
+					BYTE_MASK;
+				} else {
+					/* HEK Value */
+					c2_hek[c2_hek_bytes_used] =
+					(pkt_value << (BYTE_BITS - left_bits % BYTE_BITS)) &
+					BYTE_MASK;
+					/* HEK Mask */
+					if (!filed_unmask)
+						c2_hek_mask[c2_hek_bytes_used] =
+						(pkt_value_mask << (BYTE_BITS - left_bits % BYTE_BITS))&
+						BYTE_MASK;
+				}
+			} else {
+				/* HEK Value */
+				c2_hek[c2_hek_bytes_used] =
+				((pkt_value & common_mask_gen(field_size)) >>
+				 (BYTE_BITS * (field_bytes - 1 - i))) &
+				BYTE_MASK;
+				/* HEK Mask */
+				if (!filed_unmask)
+					c2_hek_mask[c2_hek_bytes_used] =
+					((pkt_value_mask & common_mask_gen(field_size)) >>
+					 (BYTE_BITS * (field_bytes - 1 - i))) &
+					BYTE_MASK;
+			}
+			c2_hek_bytes_used++;
+			comb_flag2 = false;
+		} else {
+			/* HEK Value */
+			c2_hek[c2_hek_bytes_used] =
+			((pkt_value & common_mask_gen(field_size)) >>
+			 (BYTE_BITS * (field_bytes - 1 - i))) &
+			BYTE_MASK;
+			/* HEK Mask */
+			c2_hek_mask[c2_hek_bytes_used] =
+			((pkt_value_mask & common_mask_gen(field_size) &
+			  (filed_unmask ? (~(common_mask_gen(field_size))) : common_mask_gen(field_size))) >>
+			 (BYTE_BITS * (field_bytes - 1 - i))) &
+			BYTE_MASK;
+			c2_hek_bytes_used++;
+		}
+	}
+	*bytes_used = c2_hek_bytes_used;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_field_unmask_check
+*
+* DESCRIPTION: The routine check the field is unmask or not
+*
+* INPUTS:
+*           field_id        - match fiels bit map
+*           field_unmask    - filed array need unmask
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* unmask, 0 - means need exact match the filed; 1 - means do not care the filed value
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static unsigned char tpm_c2_field_unmask_check(unsigned int field_id, struct tpm_field_match_info *field_unmask)
+{
+	unsigned char unmask = 0;
+	unsigned int idx;
+
+	if (field_unmask == NULL)
+		return unmask;
+
+	for (idx = 0; idx < TPM_FLOW_FIELD_COUNT_MAX; idx++) {
+		if (field_unmask[idx].valid == TPM_FIELD_VALID &&
+		    field_unmask[idx].field_id == field_id) {
+			unmask = 1;
+			break;
+		}
+	}
+
+	return unmask;
+}
+
+/*******************************************************************************
+* tpm_c2_tcam_hek_get
+*
+* DESCRIPTION: The routine will transfer pkacket key to C2 HEK
+*
+* INPUTS:
+*           field_bm    - match fiels bit map
+*           c2_entry    - C2 entry para to get packet key info
+*
+* OUTPUTS:
+*           hek         - HEK for C2
+*           hek_mask    - HEK mask for C2
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_tcam_hek_get(unsigned int field_bm,
+		       struct tpm_c2_add_entry_t *c2_entry,
+		       unsigned char hek[],
+		       unsigned char hek_mask[])
+{
+	int ret_code = TPM_OK;
+	struct tpm_field_match_info field_info[TPM_FLOW_FIELD_COUNT_MAX], field_unmask[TPM_FLOW_FIELD_COUNT_MAX];
+	unsigned char c2_hek[TPM_C2_HEK_OFF_MAX];
+	unsigned char c2_hek_mask[TPM_C2_HEK_OFF_MAX];
+	unsigned int field_bytes, field_id, field_size, pkt_value, pkt_value_mask;
+	unsigned int c2_hek_bytes_used = 0;/* used to recoed current bytes filled in HEK */
+	int field_num, i;
+	unsigned int pre_field_id = 0;
+	bool comb_flag = false;
+	unsigned char comb_offset = 0;
+	unsigned int field_id_array[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+
+	IF_NULL(TPM_C2_MOD, c2_entry);
+	IF_NULL(TPM_C2_MOD, hek);
+	IF_NULL(TPM_C2_MOD, hek_mask);
+
+	/* clear related structure */
+	memset(&field_info[0], 0, sizeof(struct tpm_field_match_info) * TPM_FLOW_FIELD_COUNT_MAX);
+	memset(c2_hek, 0, TPM_C2_HEK_OFF_MAX);
+	memset(c2_hek_mask, 0, TPM_C2_HEK_OFF_MAX);
+	/* get field info */
+	ret_code = tpm_field_bm_to_field_info(field_bm,
+					      c2_entry->mng_pkt_key,
+					      TPM_FLOW_FIELD_COUNT_MAX,
+					      true,
+					      field_info);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Get filed need to unmask */
+	ret_code = tpm_field_bm_to_field_info(field_bm &
+					      ((~(c2_entry->field_bm_mask)) | TPM_MATCH_IPV6_PKT | TPM_MATCH_IPV4_PKT),
+					      c2_entry->mng_pkt_key,
+					      TPM_FLOW_FIELD_COUNT_MAX,
+					      true,
+					      field_unmask);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set C2 TCAM HEK */
+	field_num = 0;
+	while (field_num < TPM_FLOW_FIELD_COUNT_MAX && field_info[field_num].valid == TPM_FIELD_VALID) {
+		field_id = field_info[field_num].field_id;
+		field_size = tpm_field_size_get(field_id);
+		if (field_size % BYTE_BITS)
+			field_bytes = (field_size / BYTE_BITS) + 1;
+		else
+			field_bytes = field_size / BYTE_BITS;
+
+		/* Organize pkt key according to field size and order */
+		switch (field_id) {
+		case MH_FIELD_ID:
+		case MH_UNTAGGED_PRI_FIELD_ID:
+		case OUT_VLAN_PRI_FIELD_ID:
+		case ETH_TYPE_FIELD_ID:
+		case PPPOE_FIELD_ID:
+		case IP_VER_FIELD_ID:
+		case IPV4_DSCP_FIELD_ID:
+		case IPV4_LEN_FIELD_ID:
+		case IPV4_TTL_FIELD_ID:
+		case IPV4_PROTO_FIELD_ID:
+		case IPV6_PAYLOAD_LEN_FIELD_ID:
+		case IPV6_NH_FIELD_ID:
+		case L4_SRC_FIELD_ID:
+		case L4_DST_FIELD_ID:
+		case TCP_FLAGS_FIELD_ID:
+			/* Get HEK data */
+			pkt_value = field_info[field_num].filed_value.int_data.parsed_int_val;
+			pkt_value_mask = field_info[field_num].filed_value.int_data.parsed_int_val_mask;
+			/* Store HEK in c2_hek, each filed byte boutary */
+			ret_code = tpm_c2_tcam_common_field_hek_get(pkt_value,
+								    pkt_value_mask,
+								    field_bytes,
+								    field_size,
+								    tpm_c2_field_unmask_check(field_id, field_unmask),
+								    c2_hek,
+								    c2_hek_mask,
+								    &c2_hek_bytes_used);
+			IF_ERROR(TPM_C2_MOD, ret_code);
+			/* Check HEK bytes number */
+			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
+				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				return TPM_BAD_PARAM;
+			}
+			break;
+		/* Share bits combination */
+		case GEM_PORT_ID_FIELD_ID:
+		case IN_VLAN_ID_FIELD_ID:
+		case OUT_VLAN_ID_FIELD_ID:
+			if (pre_field_id == OUT_VLAN_PRI_FIELD_ID && field_id == OUT_VLAN_ID_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 4;
+			}
+		case IPV4_ECN_FIELD_ID:
+			if (pre_field_id == IPV4_DSCP_FIELD_ID && field_id == IPV4_ECN_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 2;
+			}
+		case IPV6_DSCP_FIELD_ID:
+			if (pre_field_id == IP_VER_FIELD_ID || field_id == IPV6_DSCP_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 4;
+				if (pre_field_id != IP_VER_FIELD_ID)
+					c2_hek_bytes_used++;
+			}
+		case IPV6_ECN_FIELD_ID:
+			if (pre_field_id == IPV6_DSCP_FIELD_ID && field_id == IPV6_ECN_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 2;
+			}
+		case IPV6_FLOW_LBL_FIELD_ID:
+			if (field_id == IPV6_FLOW_LBL_FIELD_ID && pre_field_id == IPV6_ECN_FIELD_ID) {
+				comb_flag = true;
+				if (field_id_array[0] == IP_VER_FIELD_ID && field_id_array[1] == IPV6_DSCP_FIELD_ID)
+					comb_offset = 4;
+				if (field_id_array[1] != IPV6_DSCP_FIELD_ID)
+					comb_offset = 6;
+			}
+
+			/* Get HEK data */
+			pkt_value = field_info[field_num].filed_value.int_data.parsed_int_val;
+			pkt_value_mask = field_info[field_num].filed_value.int_data.parsed_int_val_mask;
+			/* Check Combination */
+			if (comb_flag &&
+			    (field_size < BYTE_BITS) &&
+			    ((field_size + comb_offset) > BYTE_BITS))
+				field_bytes++;
+
+			ret_code = tpm_c2_tcam_shared_field_hek_get(pkt_value,
+								    pkt_value_mask,
+								    field_bytes,
+								    field_size,
+								    tpm_c2_field_unmask_check(field_id, field_unmask),
+								    comb_flag,
+								    comb_offset,
+								    c2_hek,
+								    c2_hek_mask,
+								    &c2_hek_bytes_used);
+			IF_ERROR(TPM_C2_MOD, ret_code);
+			/* Check HEK bytes number */
+			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
+				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				return TPM_BAD_PARAM;
+			}
+			break;
+
+		case MAC_DA_FIELD_ID:
+		case MAC_SA_FIELD_ID:
+		case IPV4_SA_FIELD_ID:
+		case IPV4_DA_FIELD_ID:
+		case ARP_IPV4_DA_FIELD_ID:
+			for (i = 0; i < field_bytes; i++) {
+				if (field_id == MAC_DA_FIELD_ID || field_id == MAC_SA_FIELD_ID) {
+					/* HEK Value */
+					c2_hek[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.mac_addr.parsed_mac_addr[i];
+					/* HEK Mask */
+					if (!tpm_c2_field_unmask_check(field_id, field_unmask))
+						c2_hek_mask[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.mac_addr.parsed_mac_addr_mask[i];
+				} else {
+					/* HEK Value */
+					c2_hek[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.ipv4_addr.parsed_ipv4_addr[i];
+					/* HEK Mask */
+					if (!tpm_c2_field_unmask_check(field_id, field_unmask))
+						c2_hek_mask[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.ipv4_addr.parsed_ipv4_addr_mask[i];
+				}
+				c2_hek_bytes_used++;
+			}
+			/* Check HEK bytes number */
+			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
+				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				return TPM_BAD_PARAM;
+			}
+			break;
+
+		case IPV6_SA_PREF_FIELD_ID:
+		case IPV6_DA_PREF_FIELD_ID:
+			for (i = 0; i < field_bytes; i++) {
+				/* HEK Value */
+				c2_hek[c2_hek_bytes_used] =
+					field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr[i];
+				/* HEK Mask */
+				if (!tpm_c2_field_unmask_check(field_id, field_unmask))
+					c2_hek_mask[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr_mask[i];
+				c2_hek_bytes_used++;
+			}
+			/* Check HEK bytes number */
+			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
+				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				return TPM_BAD_PARAM;
+			}
+			break;
+
+		case IPV6_SA_SUFF_FIELD_ID:
+		case IPV6_DA_SUFF_FIELD_ID:
+			/* IPv6 suffix needs to be moved to MSB bytes for SRAM */
+			for (i = field_bytes; i < IPV6_ADDR_SIZE; i++) {
+				/* HEK Value */
+				c2_hek[c2_hek_bytes_used] =
+					field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr[i];
+				/* HEK Mask */
+				if (!tpm_c2_field_unmask_check(field_id, field_unmask))
+					c2_hek_mask[c2_hek_bytes_used] =
+						field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr_mask[i];
+				c2_hek_bytes_used++;
+			}
+			/* Check HEK bytes number */
+			if (c2_hek_bytes_used > TPM_C2_HEK_OFF_LKP_PORT_TYPE) {
+				TPM_OS_INFO(TPM_C2_MOD, "HEK bytes (%d) beyond C2 capcity\n", c2_hek_bytes_used);
+				return TPM_BAD_PARAM;
+			}
+			break;
+
+		case IPV6_SA_FIELD_ID:
+		case IPV6_DA_FIELD_ID:
+			/* IPv6 SIP and DIP cant fit into C2 SRAM */
+			return TPM_BAD_PARAM;
+
+		default:
+			TPM_OS_ERROR(TPM_C2_MOD, "Invalid field ID (%d) on C2 engine\n", field_id);
+			return TPM_BAD_PARAM;
+		}
+		/* record previous id */
+		pre_field_id = field_id;
+		field_id_array[field_num] = field_id;
+
+		/* Increase filed number */
+		field_num++;
+
+		/* Clear combine flag */
+		comb_flag = false;
+	}
+	/* Return hek and hek_mask */
+	for (i = 0; i < c2_hek_bytes_used; i++) {
+		hek[TPM_C2_HEK_OFF_BYTE7 - i] = c2_hek[i];
+		hek_mask[TPM_C2_HEK_OFF_BYTE7 - i] = c2_hek_mask[i];
+	}
+	/* HEK offs 8, lookup type, port type */
+	hek[TPM_C2_HEK_OFF_LKP_PORT_TYPE] = (c2_entry->port.port_type << TPM_C2_HEK_PORT_TYPE_OFFS) |
+					    (c2_entry->lkp_type << TPM_C2_HEK_LKP_TYPE_OFFS);
+	hek_mask[TPM_C2_HEK_OFF_LKP_PORT_TYPE] = TPM_C2_HEK_PORT_TYPE_MASK |
+						 ((c2_entry->lkp_type_mask << TPM_C2_HEK_LKP_TYPE_OFFS) &
+						 TPM_C2_HEK_LKP_TYPE_MASK);
+	/* HEK offs 9, port ID */
+	hek[TPM_C2_HEK_OFF_PORT_ID] = c2_entry->port.port_value;
+	hek_mask[TPM_C2_HEK_OFF_PORT_ID] = c2_entry->port.port_mask;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_tcam_set
+*
+* DESCRIPTION: The routine will get C2 entry data and write it to HW
+*
+* INPUTS:
+*           c2_entry    - C2 entry data
+*           c2_hw_idx   - C2 TCAM HW index
+*
+* OUTPUTS:
+*           c2_index  - The logical index of C2 entry, used to delete the entry
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_c2_tcam_set(struct tpm_c2_add_entry_t *c2_entry,
+			   unsigned int c2_hw_idx)
+{
+	int ret_code;
+	MV_PP2_CLS_C2_ENTRY tpm_c2_entry;
+	int hek_offs;
+	unsigned char hek_byte[TPM_C2_HEK_OFF_MAX], hek_byte_mask[TPM_C2_HEK_OFF_MAX];
+
+	IF_NULL(TPM_C2_MOD, c2_entry);
+
+	/* Clear C2 sw data */
+	memset(&tpm_c2_entry, 0, sizeof(MV_PP2_CLS_C2_ENTRY));
+
+	/* Set QOS table, selection and ID */
+	ret_code = mvPp2ClsC2QosTblSet(&tpm_c2_entry,
+				       c2_entry->qos_info.qos_tbl_index,
+				       c2_entry->qos_info.qos_tbl_type);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set color, cmd and source */
+	ret_code = mvPp2ClsC2ColorSet(&tpm_c2_entry,
+				      c2_entry->action.color_act,
+				      c2_entry->qos_info.color_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set priority(pbit), cmd, value(not from qos table) and source */
+	ret_code = mvPp2ClsC2PrioSet(&tpm_c2_entry,
+				     c2_entry->action.pri_act,
+				     c2_entry->qos_value.pri,
+				     c2_entry->qos_info.pri_dscp_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set DSCP, cmd, value(not from qos table) and source */
+	ret_code = mvPp2ClsC2DscpSet(&tpm_c2_entry,
+				     c2_entry->action.dscp_act,
+				     c2_entry->qos_value.dscp,
+				     c2_entry->qos_info.pri_dscp_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set gemport ID, cmd, value, and source */
+	ret_code = mvPp2ClsC2GpidSet(&tpm_c2_entry,
+				     c2_entry->action.gemp_act,
+				     c2_entry->qos_value.gemp,
+				     c2_entry->qos_info.gemport_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set queue low, cmd, value, and source */
+	ret_code = mvPp2ClsC2QueueLowSet(&tpm_c2_entry,
+					 c2_entry->action.q_low_act,
+					 c2_entry->qos_value.q_low,
+					 c2_entry->qos_info.q_low_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set queue high, cmd, value and source */
+	ret_code = mvPp2ClsC2QueueHighSet(&tpm_c2_entry,
+					  c2_entry->action.q_high_act,
+					  c2_entry->qos_value.q_high,
+					  c2_entry->qos_info.q_high_src);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set forward */
+	ret_code = mvPp2ClsC2ForwardSet(&tpm_c2_entry,
+					c2_entry->action.frwd_act);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	ret_code = mvPp2ClsC2PolicerSet(&tpm_c2_entry,
+					c2_entry->action.policer_act,
+					c2_entry->qos_info.policer_id,
+					TPM_PLCR_BANK0);
+#else
+	ret_code = mvPp2ClsC2PolicerSet(&tpm_c2_entry,
+					c2_entry->action.policer_act,
+					c2_entry->qos_info.policer_id);
+#endif
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set flowID(not for multicast) */
+	ret_code = mvPp2ClsC2FlowIdEn(&tpm_c2_entry,
+				      c2_entry->action.flowid_act);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set modification info */
+	ret_code = mvPp2ClsC2ModSet(&tpm_c2_entry,
+				    c2_entry->pkt_mod.mod_data_idx,
+				    c2_entry->pkt_mod.mod_cmd_idx,
+				    c2_entry->pkt_mod.l4_chksum_update_flag);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Set duplication */
+	ret_code = mvPp2ClsC2DupSet(&tpm_c2_entry, c2_entry->flow_info.flow_id, c2_entry->flow_info.flow_cnt);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to call mvPp2ClsC2DupSet\n");
+
+	/* Set C2 HEK */
+	memset(hek_byte, 0, TPM_C2_HEK_OFF_MAX);
+	memset(hek_byte_mask, 0, TPM_C2_HEK_OFF_MAX);
+	ret_code = tpm_c2_tcam_hek_get(c2_entry->field_bm,
+				       c2_entry,
+				       hek_byte,
+				       hek_byte_mask);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	for (hek_offs = TPM_C2_HEK_OFF_PORT_ID; hek_offs >= TPM_C2_HEK_OFF_BYTE0; hek_offs--) {
+		ret_code = mvPp2ClsC2TcamByteSet(&tpm_c2_entry,
+						 hek_offs,
+						 hek_byte[hek_offs],
+						 hek_byte_mask[hek_offs]);
+		IF_ERROR(TPM_C2_MOD, ret_code);
+	}
+
+	/* Write C2 entry data to HW */
+	ret_code = mvPp2ClsC2HwWrite(c2_hw_idx, &tpm_c2_entry);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_hit_cntr_clear_all
+*
+* DESCRIPTION: The routine will clear all HW hit counters
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_hit_cntr_clear_all()
+{
+	int		rc;
+	int		i;
+	unsigned int	cnt;
+
+	for (i = 0; i < MV_PP2_CLS_C2_TCAM_SIZE; i++) {
+		rc = mvPp2ClsC2HitCntrRead(i, &cnt);
+		IF_ERROR(TPM_C2_MOD, rc);
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_hit_cntr_all_get
+*
+* DESCRIPTION: The routine returns all hit counters above threshold
+*
+* INPUTS:
+*	hit_low_thresh - low threshold, hit counters above this will be returned
+*	num_of_cntrs - size of cntr_info
+*
+* OUTPUTS:
+*	cntr_info - returned counter array with logical and physical index
+*	num_of_cntrs - number of updated counters in cntr_info
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_hit_cntr_all_get(int			hit_low_thresh,
+			struct tpm_hit_cnt_t	cntr_info[],
+			unsigned int		*num_of_cntrs)
+{
+	int			i;
+	unsigned int		cnt;
+	unsigned int		rc;
+	unsigned int		cntr_idx;
+	struct tpm_c2_index_t	*c2_index_node;
+
+	IF_NULL(TPM_C2_MOD, cntr_info);
+	IF_NULL(TPM_C2_MOD, num_of_cntrs);
+
+	cntr_idx = 0;
+
+	for (i = 0; i < MV_PP2_CLS_C2_TCAM_SIZE; i++) {
+		rc = mvPp2ClsC2HitCntrRead(i, &cnt);
+		IF_ERROR(TPM_C2_MOD, rc);
+
+		if (cnt >= hit_low_thresh) {
+			if (*num_of_cntrs < cntr_idx) {
+				TPM_OS_ERROR(TPM_C2_MOD, "counter array too small, size = %d\n", *num_of_cntrs);
+				return TPM_FAIL;
+			}
+
+			c2_index_node = tpm_db_c2_index_node_get(i);
+			if (NULL == c2_index_node) {
+				TPM_OS_ERROR(TPM_C2_MOD, "C2 index %d error\n", i);
+				return TPM_FAIL;
+			}
+
+			if (TPM_C2_ENTRY_VALID != c2_index_node->valid) {
+				TPM_OS_ERROR(TPM_C2_MOD, "C2 index %d is not valid\n", i);
+				return TPM_FAIL;
+			}
+			cntr_info[cntr_idx].log_idx = c2_index_node->c2_logic_idx;
+			cntr_info[cntr_idx].phys_idx = i;
+			cntr_info[cntr_idx].cntr_val = cnt;
+			cntr_idx++;
+		}
+	}
+
+	/* update actual counters updated */
+	*num_of_cntrs = cntr_idx;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_hit_cntr_get
+*
+* DESCRIPTION: The routine returns hit counters of C2 entry
+*
+* INPUTS:
+*	c2_id - entry logic index
+*
+* OUTPUTS:
+*	cntr - returned counter
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_hit_cntr_get(int	c2_id,
+			unsigned int	*cntr)
+{
+	unsigned int		hw_id;
+	unsigned int		db_id;
+	unsigned int		rc;
+
+	IF_NULL(TPM_C2_MOD, cntr);
+
+	rc = tpm_c2_get_hw_idx_from_logic_idx(c2_id, &hw_id, &db_id);
+	IF_ERROR(TPM_C2_MOD, rc);
+
+	rc = mvPp2ClsC2HitCntrRead(hw_id, cntr);
+	IF_ERROR(TPM_C2_MOD, rc);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_get_hw_idx_from_logic_idx
+*
+* DESCRIPTION: The API will translate C2 entry logic index to HW index.
+* INPUTS:
+*           logic_idx - C2 entry logical index
+*
+* OUTPUTS:
+*           c2_hw_idx - C2 HW entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_get_hw_idx_from_logic_idx(unsigned int	logic_idx,
+				unsigned int		*c2_hw_idx,
+				unsigned int		*c2_db_idx)
+{
+	unsigned int index;
+	struct tpm_c2_index_t *c2_index_node;
+
+	IF_NULL(TPM_C2_MOD, c2_hw_idx);
+	IF_NULL(TPM_C2_MOD, c2_db_idx);
+
+	/* Get the valid index node */
+	for (index = 0; index < TPM_C2_ENTRY_MAX; index++) {
+		c2_index_node = tpm_db_c2_index_node_get(index);
+		if (c2_index_node == NULL)
+			return TPM_NO_SUCH;
+		if (c2_index_node->valid == TPM_C2_ENTRY_VALID &&
+		    c2_index_node->c2_logic_idx == logic_idx)
+			break;
+	}
+	if (index == TPM_C2_ENTRY_MAX) {
+		*c2_hw_idx = TPM_C2_ENTRY_INVALID_IDX;
+		return TPM_NO_SUCH;
+	}
+
+	*c2_hw_idx = c2_index_node->c2_hw_idx;
+	*c2_db_idx = index;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_free_entry_number_get
+*
+* DESCRIPTION: The routine will get the free entry in C2.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           free_entry_number - free entry entry number
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_free_entry_number_get(unsigned int *free_entry_number)
+{
+	unsigned int i = 0;
+	struct list_head *list;
+
+	IF_NULL(TPM_C2_MOD, free_entry_number);
+
+	/* Traverse free list */
+	list_for_each(list, tpm_db_c2_free_list_head_get())
+		i++;
+
+	*free_entry_number = i;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_rule_add
+*
+* DESCRIPTION: The API will add one C2 entry
+*
+* INPUTS:
+*           c2_entry        - contains all parameters needed for C2 rule adding
+*
+* OUTPUTS:
+*           c2_logic_index  - The logical index of C2 entry, used to delete the entry
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_rule_add(struct tpm_c2_add_entry_t *c2_entry,
+		    unsigned int *c2_logic_index)
+{
+	int ret_code;
+	unsigned int c2_db_idx, c2_logic_idx, c2_hw_idx = 0;
+
+	/* Parameter check */
+	ret_code = tpm_c2_rule_add_check(c2_entry);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+	IF_NULL(TPM_C2_MOD, c2_logic_index);
+
+	/* Make C2 slot */
+	ret_code = tpm_c2_make_slot(c2_entry->lkp_type,
+				    c2_entry->priority,
+				    &c2_hw_idx);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Write TCAM */
+	ret_code = tpm_c2_tcam_set(c2_entry, c2_hw_idx);
+	if (ret_code != TPM_OK) {
+		/* Return slot to free list */
+		tpm_c2_free_list_add(c2_hw_idx);
+		TPM_OS_ERROR(TPM_C2_MOD, "C2 TCAM(%d) set failed\n", c2_hw_idx);
+		return ret_code;
+	}
+
+	/* Update TPM DB */
+	ret_code = tpm_c2_data_entry_db_add(c2_entry, &c2_db_idx);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Allocate logical index for delete */
+	c2_logic_idx = tpm_c2_new_logic_idx_allocate(false);
+
+	/* Update corresponding lookup type list */
+	ret_code = tpm_c2_lkp_type_list_add(c2_entry->lkp_type,
+					    c2_entry->priority,
+					    c2_hw_idx,
+					    c2_db_idx,
+					    c2_logic_idx);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Return logic index */
+	*c2_logic_index = c2_logic_idx;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_rule_del
+*
+* DESCRIPTION: The API will delete one C2 entry
+*
+* INPUTS:
+*           c2_logic_index  - The logical index of C2 entry to delete
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_rule_del(unsigned int c2_logic_index)
+{
+	int ret_code;
+	struct tpm_c2_index_t *c2_index_node;
+	unsigned int c2_hw_idx, c2_db_idx, node_idx;
+
+	/* Get HW index and DB index */
+	for (node_idx = 0; node_idx < TPM_C2_ENTRY_MAX; node_idx++) {
+		c2_index_node = tpm_db_c2_index_node_get(node_idx);
+		if (c2_index_node == NULL) {
+			TPM_OS_ERROR(TPM_C2_MOD, "Invalid rule index(%d)\n", c2_logic_index);
+			return TPM_NO_SUCH;
+		}
+		if (c2_index_node->valid == TPM_C2_ENTRY_VALID &&
+		    c2_index_node->c2_logic_idx == c2_logic_index)
+			break;
+	}
+	if (node_idx == TPM_C2_ENTRY_MAX) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Invalid rule index(%d)\n", c2_logic_index);
+		return TPM_NO_SUCH;
+	}
+
+	c2_hw_idx = c2_index_node->c2_hw_idx;
+	c2_db_idx = c2_index_node->c2_data_db_idx;
+
+	/* Delete HW entry */
+	if (mvPp2ClsC2HwInv(c2_hw_idx)) {
+		TPM_OS_ERROR(TPM_C2_MOD, "Failed to invalid C2 TCAM entry(%d)\n", c2_hw_idx);
+		return TPM_HW_ERROR;
+	}
+
+	/* Invalid data db entry */
+	ret_code = tpm_c2_data_entry_db_del(c2_db_idx);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* delete index node from lkp type list, add to free list */
+	list_del(&c2_index_node->list_node);
+	memset(c2_index_node, 0, sizeof(struct tpm_c2_index_t));
+	ret_code = tpm_c2_free_list_add(c2_hw_idx);
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_rule_sram_get
+*
+* DESCRIPTION: The routine will get a SRAM of a existed rule.
+*
+* INPUTS:
+*	logic_idx - C2 logical index
+*
+* OUTPUTS:
+*	sram      - C2 new sram
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c2_rule_sram_get(unsigned int logic_index, struct tpm_engine_sram_t *sram)
+{
+	int ret_code;
+	struct tpm_c2_data_t c2_data;
+	unsigned int hw_idx, db_idx;
+
+	IF_NULL(TPM_MNG_MOD, sram);
+
+	/* Get C2 db idx */
+	ret_code = tpm_c2_get_hw_idx_from_logic_idx(logic_index,
+						    &hw_idx,
+						    &db_idx);
+	IF_ERROR_STR(TPM_MNG_MOD, ret_code, "C2 db idx get fail\n");
+
+	/* Get DB data */
+	ret_code = tpm_db_c2_data_get(db_idx, &c2_data);
+	IF_ERROR_STR(TPM_MNG_MOD, ret_code, "C2 db get fail\n");
+
+	/* Get SRAM */
+	memcpy(&sram->action, &c2_data.action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&sram->qos_info, &c2_data.qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&sram->qos_value, &c2_data.qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&sram->pkt_mod, &c2_data.pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&sram->dup_info, &c2_data.flow_info, sizeof(struct tpm_duplicate_t));
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_rule_sram_update
+*
+* DESCRIPTION: The routine will update C2 HW entry with new SRAM.
+*
+* INPUTS:
+*	logic_idx - C2 logical index
+*
+* OUTPUTS:
+*	sram      - C2 new sram
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c2_rule_sram_update(unsigned int logic_index, struct tpm_engine_sram_t *sram)
+{
+	int ret_code;
+	MV_PP2_CLS_C2_ENTRY hw_entry;
+	struct tpm_c2_data_t db_entry;
+	unsigned int hw_idx, db_idx;
+
+	IF_NULL(TPM_C2_MOD, sram);
+
+	TPM_MEMSET_ZERO(hw_entry);
+	TPM_MEMSET_ZERO(db_entry);
+
+	/* Get the HW and DB index */
+	ret_code = tpm_c2_get_hw_idx_from_logic_idx(logic_index, &hw_idx, &db_idx);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "fail to access get HW and DB index\n");
+
+	/* Read HW entry */
+	ret_code = mvPp2ClsC2HwRead(hw_idx, &hw_entry);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2HwRead fail\n");
+
+	/* Update SRAM */
+	/* Set QOS table, selection and ID */
+	ret_code = mvPp2ClsC2QosTblSet(&hw_entry,
+				       sram->qos_info.qos_tbl_index,
+				       sram->qos_info.qos_tbl_type);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2QosTblSet fail\n");
+
+	/* Set color, cmd and source */
+	ret_code = mvPp2ClsC2ColorSet(&hw_entry,
+				      sram->action.color_act,
+				      sram->qos_info.color_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2ColorSet fail\n");
+
+	/* Set priority(pbit), cmd, value(not from qos table) and source */
+	ret_code = mvPp2ClsC2PrioSet(&hw_entry,
+				     sram->action.pri_act,
+				     sram->qos_value.pri,
+				     sram->qos_info.pri_dscp_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2PrioSet fail\n");
+
+	/* Set DSCP, cmd, value(not from qos table) and source */
+	ret_code = mvPp2ClsC2DscpSet(&hw_entry,
+				     sram->action.dscp_act,
+				     sram->qos_value.dscp,
+				     sram->qos_info.pri_dscp_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2DscpSet fail\n");
+
+	/* Set gemport ID, cmd, value, and source */
+	ret_code = mvPp2ClsC2GpidSet(&hw_entry,
+				     sram->action.gemp_act,
+				     sram->qos_value.gemp,
+				     sram->qos_info.gemport_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2GpidSet fail\n");
+
+	/* Set queue low, cmd, value, and source */
+	ret_code = mvPp2ClsC2QueueLowSet(&hw_entry,
+					 sram->action.q_low_act,
+					 sram->qos_value.q_low,
+					 sram->qos_info.q_low_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2QueueLowSet fail\n");
+
+	/* Set queue high, cmd, value and source */
+	ret_code = mvPp2ClsC2QueueHighSet(&hw_entry,
+					  sram->action.q_high_act,
+					  sram->qos_value.q_high,
+					  sram->qos_info.q_high_src);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2QueueHighSet fail\n");
+
+	/* Set forward */
+	ret_code = mvPp2ClsC2ForwardSet(&hw_entry,
+					sram->action.frwd_act);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2ForwardSet fail\n");
+
+	/* Set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	ret_code = mvPp2ClsC2PolicerSet(&hw_entry,
+					sram->action.policer_act,
+					sram->qos_info.policer_id,
+					TPM_PLCR_BANK0);
+#else
+	ret_code = mvPp2ClsC2PolicerSet(&hw_entry,
+					sram->action.policer_act,
+					sram->qos_info.policer_id);
+#endif
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2PolicerSet fail\n");
+
+	/* Set flowID */
+	ret_code = mvPp2ClsC2FlowIdEn(&hw_entry,
+				      sram->action.flowid_act);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2FlowIDSet fail\n");
+
+	/* Set modification info */
+	ret_code = mvPp2ClsC2ModSet(&hw_entry,
+				    sram->pkt_mod.mod_data_idx,
+				    sram->pkt_mod.mod_cmd_idx,
+				    sram->pkt_mod.l4_chksum_update_flag);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "mvPp2ClsC2ModSet fail\n");
+
+	/* set duplication */
+	ret_code = mvPp2ClsC2DupSet(&hw_entry, sram->dup_info.flow_id, sram->dup_info.flow_cnt);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to call mvPp2ClsC2DupSet\n");
+
+	/* Write to HW again */
+	ret_code = mvPp2ClsC2HwWrite(hw_idx, &hw_entry);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to call mvPp2ClsC2HwWrite\n");
+
+	/* Update DB */
+	ret_code = tpm_db_c2_data_get(db_idx, &db_entry);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to read DB\n");
+
+	memcpy(&db_entry.action, &sram->action, sizeof(struct tpm_engine_pkt_action_t));
+	memcpy(&db_entry.qos_info, &sram->qos_info, sizeof(struct tpm_engine_qos_info_t));
+	memcpy(&db_entry.qos_value, &sram->qos_value, sizeof(struct tpm_qos_value_t));
+	memcpy(&db_entry.pkt_mod, &sram->pkt_mod, sizeof(struct tpm_engine_pkt_mod_t));
+	memcpy(&db_entry.flow_info, &sram->dup_info, sizeof(struct tpm_duplicate_t));
+
+	ret_code = tpm_db_c2_data_set(db_idx, &db_entry);
+	IF_ERROR_STR(TPM_C2_MOD, ret_code, "failed to set DB\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_reset
+*
+* DESCRIPTION: The API will clean all the entries in C2 engine,
+*              and clear C2 sub-module DB at the same time
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c2_reset(void)
+{
+	int ret_code;
+	unsigned int i;
+
+	/* Clear all TCAM entry, except last one added by LSP */
+	for (i = 0; i < TPM_C2_LAST_ENTRY; i++) {
+		if (mvPp2ClsC2HwInv(i))
+			return TPM_HW_ERROR;
+	}
+
+	/* Clear TPM C2 DB */
+	ret_code = tpm_db_c2_init();
+	IF_ERROR(TPM_C2_MOD, ret_code);
+
+	/* Reset logic index */
+	tpm_c2_new_logic_idx_allocate(true);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c2_start
+*
+* DESCRIPTION: The API will do following operations:
+*              1)Mark every C2 related DB entry invalid, C2_ENTRY_IDX_TBL and C2_ENTRY_DATA_TBL
+*              2)Add all the C2 DB entry in free list, except last one, 255
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_start.
+*******************************************************************************/
+int tpm_c2_start(void)
+{
+	if (tpm_c2_reset()) {
+		TPM_OS_ERROR(TPM_C2_MOD, "TPM C2 start failed\n");
+		return TPM_INIT_ERROR;
+	}
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2_qos.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2_qos.c
new file mode 100644
index 0000000..1909ccc
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c2_qos.c
@@ -0,0 +1,405 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+/*******************************************************************************
+* tpm_qos_tbl_entry_check()
+*
+* DESCRIPTION: This API verifies a qos table entry.
+*
+* INPUTS:
+*	qos_select   - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_qos_tbl_entry_check(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	enum tpm_qos_tbl_owner_t qos_tbl_ext;
+	int rc = 0;
+
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_QOS_TABLE_EXT, &qos_tbl_ext);
+	IF_ERROR_STR(TPM_API_MOD, rc, "failed to get QoS table extention mode\n");
+
+	if (TPM_QOS_TABLE_DISABLED == qos_tbl_ext) {
+		TPM_OS_ERROR(TPM_API_MOD, "Qos table could not be configured only under TPM_QOS_TABLE_DISABLED mode\n");
+		return TPM_BAD_PARAM;
+	}
+
+	IF_NULL(TPM_QOS_MOD, qos_cfg);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_select, TPM_QOS_PBIT, "invalid qos_select");
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE,
+					"invalid qos_tbl entry number");
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, entry, MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE,
+					"invalid qos_tbl entry number");
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->color, TPM_COL_YELLOW, "invalid color");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->dscp, TPM_DSCP_VALUE_MAX, "invalid dscp");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->pbit, TPM_PRI_VALUE_MAX, "invalid pbit");
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->pp_port.pp_port, TPM_PP_CPU, "invalid dst port");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->pp_port.pon_tx, TPM_TCONT_NUM_MAX, "invalid t-cont number");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_cfg->pp_port.pp_queue, TPM_NUM_MAX_QUEUE, "invalid queue number");
+
+	/* for DS, UNI port can not be configured in QOS table */
+	if ((qos_cfg->pp_port.pp_port != TPM_PP_PMAC)
+	     && (qos_cfg->pp_port.port_id & TPM_PORTID_SPEC)) {
+		TPM_OS_ERROR(TPM_QOS_MOD, "port_id can only be configured in QOS table for US!\n");
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_hw_entry_set()
+*
+* DESCRIPTION: This API sets a qos table entry to hardware.
+*
+* INPUTS:
+*	qos_select   - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_qos_tbl_hw_entry_set(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	int rc = TPM_OK;
+	int q_high = 0;
+	int queue = 0;
+	MV_PP2_CLS_C2_QOS_ENTRY qos;
+	unsigned char		qos_sel_hw = 0;
+
+	/* clear qos structure */
+	mvPp2ClsC2QosSwClear(&qos);
+
+	/* set Pbit */
+	rc = mvPp2ClsC2QosPrioSet(&qos, qos_cfg->pbit);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table Prio\n");
+
+	/* set DSCP */
+	rc = mvPp2ClsC2QosDscpSet(&qos, qos_cfg->dscp);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table dscp\n");
+
+	/* set color */
+	rc = mvPp2ClsC2QosColorSet(&qos, qos_cfg->color);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table color\n");
+
+	/* set gemport */
+	if ((TPM_PP_PMAC == qos_cfg->pp_port.pp_port)
+	     && (qos_cfg->pp_port.port_id & TPM_PORTID_SPEC)) {
+		/* set gemport */
+		rc = mvPp2ClsC2QosGpidSet(&qos, (qos_cfg->pp_port.port_id & ~TPM_PORTID_SPEC));
+		IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table color\n");
+	}
+
+	/* set queue */
+	if (TPM_PP_PMAC == qos_cfg->pp_port.pp_port)
+		q_high = qos_cfg->pp_port.pon_tx;
+	else
+		q_high = qos_cfg->pp_port.pp_port + TPM_MNG_DST_PORT_G0_START;
+
+	queue = (q_high << TPM_QUEUE_HIGH_SHIFT) + qos_cfg->pp_port.pp_queue;
+	rc = mvPp2ClsC2QosQueueSet(&qos, queue);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table queue\n");
+
+	if (qos_select == TPM_QOS_DSCP)
+		qos_sel_hw = TPM_QOS_TBL_TYPE_DSCP;
+	else
+		qos_sel_hw = TPM_QOS_TBL_TYPE_PRI;
+
+	/* set qos table HW */
+	rc = mvPp2ClsC2QosHwWrite(qos_tbl, qos_sel_hw, entry, &qos);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to set qos table to HW\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_ref_cnt_update()
+*
+* DESCRIPTION: This API update the reference counter for a qos table entry.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	cnt_action  - reference counter action
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_qos_tbl_ref_cnt_update(enum tpm_qos_sel_t	qos_select,
+				unsigned char		qos_tbl,
+				enum tpm_qos_tbl_ref_cnt_action_t	cnt_action)
+{
+	int rc = TPM_OK;
+
+	/* update the qos table reference counter in DB */
+	rc = tpm_db_qos_tbl_ref_cnt_updt(qos_select, qos_tbl, cnt_action);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to update qos table reference counter\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_state_check()
+*
+* DESCRIPTION: This API check if qos table has been inited.
+*
+* INPUTS:
+*	qos_select	- Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl		- There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_qos_tbl_state_check(enum tpm_qos_sel_t	qos_select,
+				unsigned char		qos_tbl)
+{
+	int rc = TPM_OK;
+	enum tpm_db_qos_status_t	status;
+	int ref_cnt;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_select, TPM_QOS_PBIT, "invalid qos_select");
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	/* get qos table status */
+	rc = tpm_db_qos_tbl_status_get(qos_select, qos_tbl, &status, &ref_cnt);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "failed to get qos table status from DB\n");
+
+	if (TPM_QOS_TBL_STATUS_UNINITED == status) {
+		TPM_OS_INFO(TPM_QOS_MOD, "qos_tbl has not been inited, qos_select(%d), qos_tbl(%d)\n",
+			qos_select, qos_tbl);
+		return TPM_NOT_INITIALIZED;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_qos_table_entry_set()
+*
+* DESCRIPTION: API directly configures the packet processor Qos Tables (part of C2 Engine).
+*              The packet processor has 64 p-bit tables and 16 dscp tables, that can be used for mapping pbit/dscp
+*              values to Qos related parameters (GMAC/T-CONT, gemport, rx/tx_queue, packet_color for policer)
+*              Values returned by the mapping table can be used as part of a generic packet classification, as
+*              written in APIs using the qos_tbl.
+*
+* INPUTS:
+*	qos_select   - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_qos_tbl_entry_set(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_QOS_MOD, qos_cfg);
+
+	/* validate input */
+	rc = tpm_qos_tbl_entry_check(qos_select, qos_tbl, entry, qos_cfg);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "validation failed on qos table entry\n");
+
+	/* update HW */
+	rc = tpm_qos_tbl_hw_entry_set(qos_select, qos_tbl, entry, qos_cfg);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "HW setting failed on qos table entry\n");
+
+	/* update DB */
+	rc = tpm_db_qos_tbl_entry_set(qos_select, qos_tbl, entry, qos_cfg);
+	IF_ERROR_STR(TPM_QOS_MOD, rc, "DB udpating failed on qos table entry\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_set()
+*
+* DESCRIPTION: API directly configures the packet processor Qos Tables (part of C2 Engine).
+*              The packet processor has 64 p-bit tables and 16 dscp tables, that can be used for mapping pbit/dscp
+*              values to Qos related parameters (GMAC/T-CONT, gemport, rx/tx_queue, packet_color for policer)
+*              Values returned by the mapping table can be used as part of a generic packet classification, as
+*              written in APIs using the qos_tbl.
+*
+* INPUTS:
+*	tpm_qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	qos_cfg        - Qos table parameter configuration array.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int tpm_qos_tbl_set(enum tpm_qos_sel_t	qos_select,
+			unsigned char		qos_tbl,
+			struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	int rc = TPM_OK;
+	int loop = 0;
+	int table_size = 0;
+
+	IF_NULL(TPM_QOS_MOD, qos_cfg);
+
+	if (TPM_QOS_DSCP == qos_select)
+		table_size = MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE;
+	else if (TPM_QOS_PBIT == qos_select)
+		table_size = MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE;
+	else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	for (loop = 0; loop < table_size; loop++) {
+		/* set qos table entry */
+		rc = tpm_qos_tbl_entry_set(qos_select, qos_tbl, loop, qos_cfg);
+		IF_ERROR_STR(TPM_QOS_MOD, rc, "configuration failed on qos table entry(%d)\n", loop);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_reset
+*
+* DESCRIPTION: The routine reset and re-satrt TPM qos table sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+int tpm_qos_tbl_reset(void)
+{
+	int rc = TPM_OK;
+
+	/* clear all qos tables, including Proi and DSCP */
+	mvPp2ClsC2QosHwClearAll();
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_qos_tbl_start
+*
+* DESCRIPTION: The routine starts TPM qos table sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_start
+*******************************************************************************/
+int tpm_qos_tbl_start(void)
+{
+	if (tpm_qos_tbl_reset() != TPM_OK) {
+		TPM_OS_ERROR(TPM_QOS_MOD, "TPM qos table start failed\n");
+		return TPM_INIT_ERROR;
+	}
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c3.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c3.c
new file mode 100644
index 0000000..6292bae
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c3.c
@@ -0,0 +1,1664 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* #define TPM_C3_DEBUG */
+
+/******************************************************************************
+ * Type Definition
+ ******************************************************************************/
+
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+
+/*******************************************************************************
+* tpm_c3_common_field_hek_get
+*
+* DESCRIPTION: The routine will transfer packet key with common field whose
+*              field size do not greater than 32 bits to C3 HEK
+*
+* INPUTS:
+*	pkt_value         - field value
+*	field_bytes       - bytes the field occupied
+*	field_size        - field size in unit of bits
+*
+* OUTPUTS:
+*	c3_hek            - HEK for C3
+*	bytes_used        - pointer to record HEK bytes has been used
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+static int tpm_c3_common_field_hek_get(unsigned int pkt_value,
+				       unsigned int field_bytes,
+				       unsigned int field_size,
+				       unsigned char c3_hek[],
+				       unsigned int *bytes_used)
+{
+	int idx;
+	unsigned int c3_hek_bytes_used;
+
+	/* NULL validation */
+	IF_NULL(TPM_C3_MOD, c3_hek);
+	IF_NULL(TPM_C3_MOD, bytes_used);
+
+	if (field_size == 0 ||
+	    field_bytes == 0)
+		return TPM_BAD_PARAM;
+
+	/* parse packet key */
+	c3_hek_bytes_used = *bytes_used;
+	for (idx = 0; idx < field_bytes; idx++) {
+		if (field_size % BYTE_BITS) {
+			if (idx < (field_bytes - 1)) {
+				/* HEK value */
+				c3_hek[c3_hek_bytes_used] =
+				((pkt_value  >> (BYTE_BITS * (field_bytes - 2 - idx) + field_size % BYTE_BITS)) &
+				 BYTE_MASK);
+			} else {
+				/* HEK value */
+				c3_hek[c3_hek_bytes_used] =
+				((pkt_value << (BYTE_BITS - field_size % BYTE_BITS)) & BYTE_MASK);
+			}
+		} else {
+			/* HEK value */
+			c3_hek[c3_hek_bytes_used] =
+			((pkt_value >> (BYTE_BITS * (field_bytes - 1 - idx))) & BYTE_MASK);
+		}
+		/* increase HEK byte count */
+		c3_hek_bytes_used++;
+	}
+	/* update bytes_used */
+	*bytes_used = c3_hek_bytes_used;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_shared_field_hek_get
+*
+* DESCRIPTION: The routine will transfer packet key with common field who
+*              shares one byte with other field to C3 HEK
+*
+* INPUTS:
+*	pkt_value         - field value
+*	field_bytes       - bytes the filed occupied
+*	field_size        - field size
+*	comb_flag         - indicate combination is needed or not
+*	comb_offset       - combination bit offset
+*	bytes_used        - pointer to HEK bytes has been used
+*
+* OUTPUTS:
+*	c3_hek            - HEK for C3
+*	bytes_used        - pointer to record HEK bytes has been used
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+static int tpm_c3_shared_field_hek_get(unsigned int pkt_value,
+				       unsigned int field_bytes,
+				       unsigned int field_size,
+				       bool comb_flag,
+				       unsigned char comb_offset,
+				       unsigned char c3_hek[],
+				       unsigned int *bytes_used)
+{
+	int idx;
+	unsigned int left_bits;
+	unsigned int c3_hek_bytes_used;
+	bool comb_flag1;
+	bool comb_flag2;
+
+	/* Para check */
+	IF_NULL(TPM_C3_MOD, c3_hek);
+	IF_NULL(TPM_C3_MOD, bytes_used);
+
+	if (field_size == 0 ||
+	    field_bytes == 0)
+		return TPM_BAD_PARAM;
+
+	left_bits = field_size;
+	c3_hek_bytes_used = *bytes_used;
+	comb_flag1 = comb_flag;
+	comb_flag2 = comb_flag;
+	for (idx = 0; idx < field_bytes; idx++) {
+		if (comb_flag2) {
+			if (comb_flag1) {
+				c3_hek_bytes_used--;
+				/* HEK value */
+				c3_hek[c3_hek_bytes_used] |=
+				((pkt_value >> (field_size - comb_offset)) & BYTE_MASK);
+				if (((field_size % BYTE_BITS) + comb_offset) > BYTE_BITS ||
+				    (field_size > BYTE_BITS)) {
+					pkt_value &= common_mask_gen(field_size - comb_offset);
+				}
+				c3_hek_bytes_used++;
+				left_bits = field_size - comb_offset;
+				comb_flag1 = false;
+			} else {
+				if (left_bits % BYTE_BITS) {
+					if (idx < (field_bytes - 1)) {
+						/* HEK value */
+						c3_hek[c3_hek_bytes_used] =
+						(pkt_value  >>
+						 (BYTE_BITS * (field_bytes - 2 - idx) + left_bits % BYTE_BITS)) &
+						BYTE_MASK;
+					} else {
+						/* HEK value */
+						c3_hek[c3_hek_bytes_used] =
+						(pkt_value << (BYTE_BITS - left_bits % BYTE_BITS)) & BYTE_MASK;
+					}
+				} else {
+					/* HEK value */
+					c3_hek[c3_hek_bytes_used] =
+					(pkt_value >> (BYTE_BITS * (field_bytes - 1 - idx))) & BYTE_MASK;
+				}
+				c3_hek_bytes_used++;
+				comb_flag2 = false;
+			}
+		} else {
+			/* HEK Value */
+			c3_hek[c3_hek_bytes_used] =
+			(pkt_value >> (BYTE_BITS * (field_bytes - 1 - idx))) & BYTE_MASK;
+			c3_hek_bytes_used++;
+		}
+	}
+	*bytes_used = c3_hek_bytes_used;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_hek_generate
+*
+* DESCRIPTION: The routine will generate C3 HEK by management key
+*
+* INPUTS:
+*	c3_entry - C3 entry para to get packet key info
+*
+* OUTPUTS:
+*	size     - size of HEK in unit of bytes
+*	hek      - HEK for C3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+static int tpm_c3_hek_generate(struct tpm_c3_add_entry_t *c3_entry,
+			       unsigned int *size,
+			       unsigned char hek[])
+{
+	struct tpm_field_match_info field_info[TPM_FLOW_FIELD_COUNT_MAX];
+	unsigned char c3_hek[TPM_C3_MAX_HASH_KEY_SIZE];
+	unsigned int field_bytes;
+	unsigned int field_id;
+	unsigned int field_size;
+	unsigned int pkt_value;
+	unsigned int pkt_value_mask;
+	unsigned int c3_hek_bytes_used = 0;/* used to recoed current bytes filled in HEK */
+	int field_num;
+	int idx;
+	unsigned int pre_field_id = 0;
+	bool comb_flag = false;
+	unsigned char comb_offset = 0;
+	unsigned int field_id_array[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_C3_MOD, c3_entry);
+	IF_NULL(TPM_C3_MOD, size);
+	IF_NULL(TPM_C3_MOD, hek);
+
+	/* clear related structure */
+	memset(&field_info[0], 0, sizeof(struct tpm_field_match_info) * TPM_FLOW_FIELD_COUNT_MAX);
+	memset(c3_hek, 0, TPM_C3_MAX_HASH_KEY_SIZE);
+
+	/* get field info */
+	rc = tpm_field_bm_to_field_info(c3_entry->mng_pkt_key->pkt_key->field_match_bm,
+					c3_entry->mng_pkt_key,
+					TPM_FLOW_FIELD_COUNT_MAX,
+					false,
+					field_info);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get field information\n");
+
+	/* Set C3 TCAM HEK */
+	field_num = 0;
+	while (field_num < TPM_FLOW_FIELD_COUNT_MAX && field_info[field_num].valid == TPM_FIELD_VALID) {
+		field_id = field_info[field_num].field_id;
+		field_size = tpm_field_size_get(field_id);
+		if (field_size % BYTE_BITS)
+			field_bytes = (field_size / BYTE_BITS) + 1;
+		else
+			field_bytes = field_size / BYTE_BITS;
+		/* Check HEK bytes number */
+		if (c3_hek_bytes_used >= TPM_C3_MAX_HASH_KEY_SIZE ||
+		   (field_bytes > (TPM_C3_MAX_HASH_KEY_SIZE - c3_hek_bytes_used))) {
+			TPM_OS_ERROR(TPM_C3_MOD, "HEK bytes (%d) beyond C3 capcity\n",
+				     (c3_hek_bytes_used + field_bytes));
+			return TPM_BAD_PARAM;
+		}
+		/* Organize pkt key according to field size and order */
+		switch (field_id) {
+		case MH_FIELD_ID:
+		case MH_UNTAGGED_PRI_FIELD_ID:
+		case OUT_VLAN_PRI_FIELD_ID:
+		case ETH_TYPE_FIELD_ID:
+		case PPPOE_FIELD_ID:
+		case IP_VER_FIELD_ID:
+		case IPV4_DSCP_FIELD_ID:
+		case IPV4_LEN_FIELD_ID:
+		case IPV4_TTL_FIELD_ID:
+		case IPV6_PAYLOAD_LEN_FIELD_ID:
+		case IPV6_NH_FIELD_ID:
+		case L4_SRC_FIELD_ID:
+		case L4_DST_FIELD_ID:
+		case TCP_FLAGS_FIELD_ID:
+			/* Get HEK data */
+			pkt_value = field_info[field_num].filed_value.int_data.parsed_int_val;
+			/* Store HEK in c3_hek, each filed byte boutary */
+			rc = tpm_c3_common_field_hek_get(pkt_value,
+							 field_bytes,
+							 field_size,
+							 c3_hek,
+							 &c3_hek_bytes_used);
+			IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get HEK\n");
+			break;
+		/* Share bits combination */
+		case GEM_PORT_ID_FIELD_ID:
+		case IN_VLAN_ID_FIELD_ID:
+		case OUT_VLAN_ID_FIELD_ID:
+			if (pre_field_id == OUT_VLAN_PRI_FIELD_ID && field_id == OUT_VLAN_ID_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 4;
+			}
+		/* fallthru */
+		case IPV4_ECN_FIELD_ID:
+			if (pre_field_id == IPV4_DSCP_FIELD_ID && field_id == IPV4_ECN_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 2;
+			}
+		/* fallthru */
+		case IPV6_DSCP_FIELD_ID:
+			if (pre_field_id == IP_VER_FIELD_ID || field_id == IPV6_DSCP_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 4;
+				if (pre_field_id != IP_VER_FIELD_ID)
+					c3_hek_bytes_used++;
+			}
+		/* fallthru */
+		case IPV6_ECN_FIELD_ID:
+			if (pre_field_id == IPV6_DSCP_FIELD_ID && field_id == IPV6_ECN_FIELD_ID) {
+				comb_flag = true;
+				comb_offset = 2;
+			}
+		/* fallthru */
+		case IPV6_FLOW_LBL_FIELD_ID:
+			if (field_id == IPV6_FLOW_LBL_FIELD_ID && pre_field_id == IPV6_ECN_FIELD_ID) {
+				comb_flag = true;
+				if (field_id_array[0] == IP_VER_FIELD_ID && field_id_array[1] == IPV6_DSCP_FIELD_ID)
+					comb_offset = 4;
+				if (field_id_array[1] != IPV6_DSCP_FIELD_ID)
+					comb_offset = 6;
+			}
+
+			/* Get HEK data */
+			pkt_value = field_info[field_num].filed_value.int_data.parsed_int_val;
+			pkt_value_mask = field_info[field_num].filed_value.int_data.parsed_int_val_mask;
+			/* Check Combination */
+			if (comb_flag &&
+			    (field_size < BYTE_BITS) &&
+			    ((field_size + comb_offset) > BYTE_BITS))
+				field_bytes++;
+
+			if (c3_hek_bytes_used >= TPM_C3_MAX_HASH_KEY_SIZE ||
+			   (field_bytes > (TPM_C3_MAX_HASH_KEY_SIZE - c3_hek_bytes_used))) {
+				TPM_OS_ERROR(TPM_C3_MOD, "HEK bytes (%d) beyond C3 capcity\n",
+					     (c3_hek_bytes_used + field_bytes));
+				return TPM_BAD_PARAM;
+			}
+
+			rc = tpm_c3_shared_field_hek_get(pkt_value,
+							 field_bytes,
+							 field_size,
+							 comb_flag,
+							 comb_offset,
+							 c3_hek,
+							 &c3_hek_bytes_used);
+			IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get HEK\n");
+			break;
+
+		case MAC_DA_FIELD_ID:
+		case MAC_SA_FIELD_ID:
+		case IPV4_SA_FIELD_ID:
+		case IPV4_DA_FIELD_ID:
+		case ARP_IPV4_DA_FIELD_ID:
+			for (idx = 0; idx < field_bytes; idx++) {
+				if (field_id == MAC_DA_FIELD_ID || field_id == MAC_SA_FIELD_ID) {
+					/* HEK value */
+					c3_hek[c3_hek_bytes_used] =
+						field_info[field_num].filed_value.mac_addr.parsed_mac_addr[idx];
+				} else {
+					/* HEK value */
+					c3_hek[c3_hek_bytes_used] =
+						field_info[field_num].filed_value.ipv4_addr.parsed_ipv4_addr[idx];
+				}
+				c3_hek_bytes_used++;
+			}
+			break;
+
+		case IPV6_SA_FIELD_ID:
+		case IPV6_DA_FIELD_ID:
+		case IPV6_SA_PREF_FIELD_ID:
+		case IPV6_DA_PREF_FIELD_ID:
+			for (idx = 0; idx < field_bytes; idx++) {
+				/* HEK value */
+				c3_hek[c3_hek_bytes_used] =
+					field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr[idx];
+				c3_hek_bytes_used++;
+			}
+			break;
+
+		case IPV6_SA_SUFF_FIELD_ID:
+		case IPV6_DA_SUFF_FIELD_ID:
+			/* IPv6 suffix needs to be moved to MSB bytes for SRAM */
+			for (idx = field_bytes; idx < IPV6_ADDR_SIZE; idx++) {
+				/* HEK value */
+				c3_hek[c3_hek_bytes_used] =
+					field_info[field_num].filed_value.ipv6_addr.parsed_ipv6_addr[idx];
+				c3_hek_bytes_used++;
+			}
+			break;
+
+		default:
+			TPM_OS_ERROR(TPM_C3_MOD, "Invalid field ID (%d) on C3 engine\n", field_id);
+			return TPM_BAD_PARAM;
+		}
+		/* record previous id */
+		pre_field_id = field_id;
+		field_id_array[field_num] = field_id;
+
+		/* increase field number */
+		field_num++;
+
+		/* Clear combine flag */
+		comb_flag = false;
+	}
+
+	/* save HEK */
+	*size = c3_hek_bytes_used;
+	for (idx = 0; idx < c3_hek_bytes_used; idx++)
+		hek[TPM_C3_MAX_HASH_KEY_SIZE - 1 - idx] = c3_hek[idx];
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_convert
+*
+* DESCRIPTION: The routine convert management C3 entry rule to LSP one
+*
+* INPUTS:
+*	mng_entry - CLS management C3 engine entry
+*
+* OUTPUTS:
+*	hw_entry - CLS LSP C3 engine entry
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_rule_convert(struct tpm_c3_add_entry_t *mng_entry, MV_PP2_CLS_C3_ENTRY *hw_entry)
+{
+	enum tpm_l4_type_t l4_type;
+	unsigned int hek_bytes;
+	int rc = TPM_OK;
+
+	/* NULL validation */
+	IF_NULL(TPM_C3_MOD, mng_entry);
+	IF_NULL(TPM_C3_MOD, hw_entry);
+
+	/* init c3 entry */
+	mvPp2ClsC3SwClear(hw_entry);
+
+	/* set L4 infor */
+	if (mng_entry->mng_pkt_key->pkt_key->field_match_bm & TPM_MATCH_IP_PROTO) {
+		if (mng_entry->mng_pkt_key->pkt_key->ipvx_add.ip_proto == IPPROTO_TCP)
+			l4_type = TPM_L4_TYPE_TCP;
+		else if (mng_entry->mng_pkt_key->pkt_key->ipvx_add.ip_proto == IPPROTO_UDP)
+			l4_type = TPM_L4_TYPE_UDP;
+		else
+			l4_type = TPM_L4_TYPE_TCP; /* default one */
+
+		rc = mvPp2ClsC3SwL4infoSet(hw_entry, l4_type);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3SwL4infoSet\n");
+	}
+
+	/* set lookup type */
+	rc = mvPp2ClsC3SwLkpTypeSet(hw_entry, mng_entry->lkp_type);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3SwLkpTypeSet\n");
+
+	/* set port ID */
+	rc = mvPp2ClsC3SwPortIDSet(hw_entry, mng_entry->port.port_type, mng_entry->port.port_value);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3SwPortIDSet\n");
+
+	/* set HEK */
+	rc = tpm_c3_hek_generate(mng_entry, &hek_bytes, hw_entry->key.hek.bytes);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call tpm_c3_hek_generate\n");
+	rc = mvPp2ClsC3SwHekSizeSet(hw_entry, hek_bytes);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3SwHekSizeSet\n");
+
+	/* set color */
+	rc = mvPp2ClsC3ColorSet(hw_entry, mng_entry->action.color_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ColorSet\n");
+
+	/* set queue high */
+	rc = mvPp2ClsC3QueueHighSet(hw_entry, mng_entry->action.q_high_act, mng_entry->qos_value.q_high);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueHighSet\n");
+
+	/* set queue low */
+	rc = mvPp2ClsC3QueueLowSet(hw_entry, mng_entry->action.q_low_act, mng_entry->qos_value.q_low);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueLowSet\n");
+
+	/* set forward */
+	rc = mvPp2ClsC3ForwardSet(hw_entry, mng_entry->action.frwd_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ForwardSet\n");
+
+	/* set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	rc = mvPp2ClsC3PolicerSet(hw_entry,
+				  mng_entry->action.policer_act,
+				  mng_entry->qos_info.policer_id,
+				  TPM_PLCR_BANK0);
+#else
+	rc = mvPp2ClsC3PolicerSet(hw_entry, mng_entry->action.policer_act, mng_entry->qos_info.policer_id);
+#endif
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3PolicerSet\n");
+
+	/* set flow ID */
+	rc = mvPp2ClsC3FlowIdEn(hw_entry, mng_entry->action.flowid_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3FlowIDSet\n");
+
+	/* set mod */
+	rc = mvPp2ClsC3ModSet(hw_entry,
+			      mng_entry->pkt_mod.mod_data_idx,
+			      mng_entry->pkt_mod.mod_cmd_idx,
+			      mng_entry->pkt_mod.l4_chksum_update_flag);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ModSet\n");
+
+	/* set duplication */
+	rc = mvPp2ClsC3DupSet(hw_entry, mng_entry->flow_info.flow_id, mng_entry->flow_info.flow_cnt);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3DupSet\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_default_rule_convert
+*
+* DESCRIPTION: The routine convert management C3 default entry rule to LSP one
+*
+* INPUTS:
+*	mng_entry - CLS management C3 engine entry
+*
+* OUTPUTS:
+*	hw_entry  - CLS LSP C3 engine entry
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_default_rule_convert(struct tpm_c3_add_entry_t *mng_entry, MV_PP2_CLS_C3_ENTRY *hw_entry)
+{
+	int rc = TPM_OK;
+
+	/* NULL validation */
+	IF_NULL(TPM_C3_MOD, mng_entry);
+	IF_NULL(TPM_C3_MOD, hw_entry);
+
+	/* init c3 entry */
+	mvPp2ClsC3SwClear(hw_entry);
+
+	/* set lookup type */
+	rc = mvPp2ClsC3SwLkpTypeSet(hw_entry, mng_entry->lkp_type);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3SwLkpTypeSet\n");
+
+	/* set color */
+	rc = mvPp2ClsC3ColorSet(hw_entry, mng_entry->action.color_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ColorSet\n");
+
+	/* set queue high */
+	rc = mvPp2ClsC3QueueHighSet(hw_entry, mng_entry->action.q_high_act, mng_entry->qos_value.q_high);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueHighSet\n");
+
+	/* set queue low */
+	rc = mvPp2ClsC3QueueLowSet(hw_entry, mng_entry->action.q_low_act, mng_entry->qos_value.q_low);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueLowSet\n");
+
+	/* set forward */
+	rc = mvPp2ClsC3ForwardSet(hw_entry, mng_entry->action.frwd_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ForwardSet\n");
+
+	/* set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	rc = mvPp2ClsC3PolicerSet(hw_entry,
+				  mng_entry->action.policer_act,
+				  mng_entry->qos_info.policer_id,
+				  TPM_PLCR_BANK0);
+#else
+	rc = mvPp2ClsC3PolicerSet(hw_entry, mng_entry->action.policer_act, mng_entry->qos_info.policer_id);
+#endif
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3PolicerSet\n");
+
+	/* set flow ID */
+	rc = mvPp2ClsC3FlowIdEn(hw_entry, mng_entry->action.flowid_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3FlowIDSet\n");
+
+	/* set mod */
+	rc = mvPp2ClsC3ModSet(hw_entry,
+			      mng_entry->pkt_mod.mod_data_idx,
+			      mng_entry->pkt_mod.mod_cmd_idx,
+			      mng_entry->pkt_mod.l4_chksum_update_flag);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ModSet\n");
+
+	/* set duplication */
+	rc = mvPp2ClsC3DupSet(hw_entry, mng_entry->flow_info.flow_id, mng_entry->flow_info.flow_cnt);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3DupSet\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_check
+*
+* DESCRIPTION: The routine validate C3 entry
+*
+* INPUTS:
+*	c3_entry - CLS C3 engine entry
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_rule_check(struct tpm_c3_add_entry_t *c3_entry)
+{
+	struct tpm_field_match_info field_info[TPM_FLOW_FIELD_COUNT_MAX + 1];
+	int idx;
+	MV_PP2_CLS_C3_ENTRY c3;
+	unsigned int bits_cnt = 0;
+	int rc = TPM_OK;
+
+	/* NULL validation */
+	IF_NULL(TPM_C3_MOD, c3_entry);
+
+	/* port check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, c3_entry->port.port_type, TPM_SRC_PORT_TYPE_VIR, "invalid port type");
+	if (c3_entry->port.port_type == TPM_SRC_PORT_TYPE_VIR) {
+		if (c3_entry->port.port_value > TPM_VIRT_PORT_ID_MAX) {
+			TPM_OS_ERROR(TPM_C3_MOD, "Invalid Virt port ID(%d)\n", c3_entry->port.port_value);
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	/* lookup type check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, c3_entry->lkp_type, KEY_CTRL_LKP_TYPE_MAX, "invalid lookup type");
+
+	/* packet key check  */
+	IF_NULL(TPM_C3_MOD, c3_entry->mng_pkt_key);
+
+	/* get field info */
+	memset(field_info, 0, sizeof(struct tpm_field_match_info) * (TPM_FLOW_FIELD_COUNT_MAX + 1));
+	if (tpm_field_bm_to_field_info(c3_entry->mng_pkt_key->pkt_key->field_match_bm,
+				       c3_entry->mng_pkt_key,
+				       TPM_FLOW_FIELD_COUNT_MAX + 1,
+				       false,
+				       field_info)) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Field info get failed\n");
+		return TPM_BAD_PARAM;
+	}
+
+	/* if not 5T, check field number, greater than 4, invalid */
+	if ((TPM_MATCH_IPV4_5T != c3_entry->mng_pkt_key->pkt_key->field_match_bm)
+	    && (TPM_MATCH_IPV6_5T != c3_entry->mng_pkt_key->pkt_key->field_match_bm)
+	    && (field_info[TPM_FLOW_FIELD_COUNT_MAX].valid == TPM_FIELD_VALID)) {
+		TPM_OS_ERROR(TPM_C3_MOD, "At most 4 fileds are supported\n");
+		return TPM_BAD_PARAM;
+	}
+	/* raw check field length, total can not more than 36 bytes */
+	for (idx = 0; idx < TPM_FLOW_FIELD_COUNT_MAX; idx++) {
+		if (field_info[idx].valid == TPM_FIELD_VALID)
+			bits_cnt += tpm_field_size_get(field_info[idx].field_id);
+	}
+	if (bits_cnt > TPM_C3_MAX_HASH_KEY_SIZE * BYTE_BITS) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Packet key length(%d bits) beyond C3 capability\n", bits_cnt);
+		return TPM_BAD_PARAM;
+	}
+
+	/* QOS check, TBD */
+
+	/* Action check, TBD */
+
+	/* Mod info check */
+	if (c3_entry->pkt_mod.mod_cmd_idx > TPM_HWF_MOD_IPTR_MAX) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Invalid modification cmd index(%d)\n", c3_entry->pkt_mod.mod_cmd_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (c3_entry->pkt_mod.mod_data_idx > TPM_HW_MOD_DPTR_MAX) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Invalid data index(%d)\n", c3_entry->pkt_mod.mod_data_idx);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Duplication flow info check */
+	rc = tpm_c3_rule_convert(c3_entry, &c3);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to convert C3 key\n");
+
+	/* For rule update, maybe 2 rules have the same key may co-exist for a short time,
+	*  so the repeat check will blcok rule update, remove it temporary, and in future commit
+	*  maybe a new method found to implement it.
+	*/
+	/*rc = mvPp2ClsC3HwDuplicateCheck(&c3);
+	if (rc != MV_OK) {
+		TPM_OS_ERROR(TPM_C3_MOD, "C3 already has entry w/ same key, conflict\n");
+		return TPM_BAD_PARAM;
+	}*/
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_default_rule_check
+*
+* DESCRIPTION: The routine validate C3 entry
+*
+* INPUTS:
+*	c3_entry - CLS C3 engine default entry
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_default_rule_check(struct tpm_c3_add_entry_t *c3_entry)
+{
+	int rc = TPM_OK;
+
+	/* NULL validation */
+	IF_NULL(TPM_C3_MOD, c3_entry);
+
+	/* lookup type check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, c3_entry->lkp_type, KEY_CTRL_LKP_TYPE_MAX, "invalid lookup type");
+
+	/* QOS check, TBD */
+
+	/* action check, TBD */
+
+	/* mod info check */
+	if (c3_entry->pkt_mod.mod_cmd_idx > TPM_HWF_MOD_IPTR_MAX) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Invalid modification cmd index(%d)\n", c3_entry->pkt_mod.mod_cmd_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (c3_entry->pkt_mod.mod_data_idx > TPM_HW_MOD_DPTR_MAX) {
+		TPM_OS_ERROR(TPM_C3_MOD, "Invalid data index(%d)\n", c3_entry->pkt_mod.mod_data_idx);
+		return TPM_BAD_PARAM;
+	}
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_add
+*
+* DESCRIPTION: The routine adds C3 entry
+*
+* INPUTS:
+*	c3_entry  - CLS C3 engine entry
+*
+* OUTPUTS:
+*	logic_idx - logical index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_rule_add(struct tpm_c3_add_entry_t	*c3_entry,
+		    unsigned int		*logic_idx)
+{
+	unsigned int l_logic_idx;
+	unsigned int hash_idx;
+	MV_PP2_CLS_C3_ENTRY c3;
+	int max_search_depth;
+	MV_PP2_CLS3_HASH_PAIR hash_pair_arr;
+	int rc = TPM_OK;
+#ifdef TPM_C3_DEBUG
+	int idx;
+#endif
+
+	/* validation */
+	IF_NULL(TPM_C3_MOD, c3_entry);
+	IF_NULL(TPM_C3_MOD, logic_idx);
+
+	/* check C3 rule */
+	rc = tpm_c3_rule_check(c3_entry);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to check C3 entry\n");
+
+	/* convert the C3 mng entry to LSP entry */
+	mvPp2ClsC3SwClear(&c3);
+	rc = tpm_c3_rule_convert(c3_entry, &c3);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call tpm_c3_rule_convert\n");
+
+#ifdef TPM_C3_DEBUG
+	mvPp2ClsC3SwDump(&c3);
+#endif
+
+	/* get free logical index, also check whether they is available entry */
+	rc = tpm_db_c3_free_logic_idx_get(&l_logic_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get free logical index\n");
+	*logic_idx = l_logic_idx;
+
+	/* add C3 entry */
+	rc = tpm_db_c3_search_depth_get(&max_search_depth);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to get TPM C3 max search depth\n");
+	TPM_MEMSET_ZERO(hash_pair_arr);
+#ifdef TPM_C3_DEBUG
+	printk(KERN_INFO "C3 HEK %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
+		c3.key.hek.bytes[35], c3.key.hek.bytes[34], c3.key.hek.bytes[33], c3.key.hek.bytes[32],
+		c3.key.hek.bytes[31], c3.key.hek.bytes[30], c3.key.hek.bytes[29], c3.key.hek.bytes[28]);
+#endif
+	rc = mvPp2ClsC3HwQueryAdd(&c3, max_search_depth, &hash_pair_arr);
+	/* do not need to release logic index since it is still not occuppied */
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to add C3 entry to HW\n");
+	hash_idx = c3.index;
+
+	/* update C3 DB multihash index */
+#ifdef TPM_C3_DEBUG
+	if (hash_pair_arr.pair_num) {
+		printk(KERN_INFO "hash pair number=%d\n", hash_pair_arr.pair_num);
+		for (idx = 0; idx < hash_pair_arr.pair_num; idx++)
+			printk(KERN_INFO "hash pair(%d) %x-->%x\n",
+				idx, hash_pair_arr.old_idx[idx], hash_pair_arr.new_idx[idx]);
+	}
+#endif
+	rc = tpm_db_c3_hash_idx_update(&hash_pair_arr);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to update C3 multihash index\n");
+
+	/* save to DB */
+	rc = tpm_db_c3_entry_add(l_logic_idx, hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to add C3 entry to DB\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_default_rule_add
+*
+* DESCRIPTION: The routine adds default C3 entry to handle the mismathched
+*              packets for specific lookup type
+*
+* INPUTS:
+*	c3_entry  - CLS C3 engine entry
+*
+* OUTPUTS:
+*	logic_idx - logical index
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_default_rule_add(struct tpm_c3_add_entry_t	*c3_entry,
+				unsigned int		*logic_idx)
+{
+	unsigned int l_logic_idx;
+	MV_PP2_CLS_C3_ENTRY c3;
+	int rc = TPM_OK;
+
+	/* validation */
+	IF_NULL(TPM_C3_MOD, c3_entry);
+	IF_NULL(TPM_C3_MOD, logic_idx);
+
+	/* check C3 rule */
+	rc = tpm_c3_default_rule_check(c3_entry);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to check C3 default entry\n");
+
+	/* convert the C3 mng entry to LSP entry */
+	TPM_MEMSET_ZERO(c3);
+	rc = tpm_c3_default_rule_convert(c3_entry, &c3);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call tpm_c3_default_rule_convert()\n");
+
+	/* get free logical index, aslo check whether there is free entry */
+	rc = tpm_db_c3_free_logic_idx_get(&l_logic_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get free logical index\n");
+	*logic_idx = l_logic_idx;
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* add C3 entry */
+	hash_idx = (c3_entry->lkp_type / 2) * MV_PP2_CLS_C3_BANK_SIZE + (c3_entry->lkp_type % 2);
+	rc = mvPp2ClsC3HwAdd(&c3, hash_idx, 0);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to add C3 entry to HW\n");
+
+	/* save to DB */
+	rc = tpm_db_c3_entry_add(l_logic_idx, hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to add C3 entry to DB\n");
+#else
+	rc = mvPp2ClsC3HwMissAdd(&c3, c3_entry->lkp_type);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to add C3 miss entry to HW\n");
+#endif
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_del
+*
+* DESCRIPTION: The routine deletes C3 entry
+*
+* INPUTS:
+*	logic_idx - logical index
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_rule_del(unsigned int logic_idx)
+{
+	unsigned int hash_idx;
+	int rc = TPM_OK;
+
+	/* check C3 rule, return OK if the there is no this logical index */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	rc = tpm_db_c3_hash_idx_get(logic_idx, &hash_idx);
+	if (rc != MV_OK) {
+		TPM_OS_INFO(TPM_C3_MOD, "The logical index(%d) does not exist", logic_idx);
+		return MV_OK;
+	}
+
+	/* delete C3 entry */
+	rc = mvPp2ClsC3HwDel(hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to delete C3 entry from HW\n");
+
+	/* remove from DB */
+	rc = tpm_db_c3_entry_del(logic_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to delete C3 entry from DB\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_get
+*
+* DESCRIPTION: The routine gets the C3 entries which occupy same multihash entries
+*
+* INPUTS:
+*	c3_entry      - CLS C3 engine entry
+*
+* OUTPUTS:
+*	entry_num     - number of matched multihash entries
+*	logic_idx_arr - logical index array
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is for future usage
+*******************************************************************************/
+int tpm_c3_rule_get(struct tpm_c3_add_entry_t	*c3_entry,
+		    unsigned int		*entry_num,
+		    unsigned int		*logic_idx_arr[])
+{
+	int rc = TPM_OK;
+
+	/* leave this routine to be implemented in future when needed */
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_hit_count_get
+*
+* DESCRIPTION: The routine gets hit counter by logical index
+*
+* INPUTS:
+*	logic_idx     - C3 logical index
+*
+* OUTPUTS:
+*	hit_count     - multihash entry hit counter
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_hit_count_get(int logic_idx, unsigned int *hit_count)
+{
+	unsigned int hash_idx;
+	int rc = TPM_OK;
+
+	/* validation */
+	IF_NULL(TPM_C3_MOD, hit_count);
+
+	/* check C3 rule, return OK if the there is no this logical index */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	rc = tpm_db_c3_hash_idx_get(logic_idx, &hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "The logical index(%d) does not exist", logic_idx);
+
+	/* get hit counter */
+	rc = mvPp2ClsC3HitCntrsRead(hash_idx, hit_count);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to read hit counter for logical index(%d)\n", logic_idx);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_hit_cntr_all_get
+*
+* DESCRIPTION: The routine returns all hit counters above threshold
+*
+* INPUTS:
+*	hit_low_thresh - low threshold, hit counters above this will be returned
+*	num_of_cntrs - size of cntr_info
+*
+* OUTPUTS:
+*	cntr_info - returned counter array with logical and physical index
+*	num_of_cntrs - number of updated counters in cntr_info
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c3_hit_cntr_all_get(int			hit_low_thresh,
+			struct tpm_hit_cnt_t	cntr_info[],
+			unsigned int		*num_of_cntrs)
+{
+	int			phys_i, log_i;
+	unsigned int		cnt;
+	unsigned int		rc;
+	unsigned int		cntr_idx;
+
+	IF_NULL(TPM_C3_MOD, cntr_info);
+	IF_NULL(TPM_C3_MOD, num_of_cntrs);
+
+	cntr_idx = 0;
+
+	for (phys_i = 0; phys_i < MV_PP2_CLS_C3_HASH_TBL_SIZE; phys_i++) {
+		rc = mvPp2ClsC3HitCntrsRead(phys_i, &cnt);
+		IF_ERROR(TPM_C2_MOD, rc);
+
+		if (cnt >= hit_low_thresh) {
+			if (*num_of_cntrs < cntr_idx) {
+				TPM_OS_ERROR(TPM_C3_MOD, "counter array too small, size = %d\n", *num_of_cntrs);
+				return TPM_FAIL;
+			}
+
+			rc = tpm_db_c3_logic_idx_get(phys_i, &log_i);
+			if (TPM_NO_SUCH == rc)
+				continue;
+
+			cntr_info[cntr_idx].log_idx = log_i;
+			cntr_info[cntr_idx].phys_idx = phys_i;
+			cntr_info[cntr_idx].cntr_val = cnt;
+			cntr_idx++;
+		}
+	}
+
+	/* update actual counters updated */
+	*num_of_cntrs = cntr_idx;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_scan_param_set
+*
+* DESCRIPTION: The routine sets scan configuration parameters
+*
+* INPUTS:
+*	scan_config - scan configuration
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine should be called before tpm_c3_scan_get
+*******************************************************************************/
+int tpm_c3_scan_param_set(struct tpm_c3_scan_config_t *scan_config)
+{
+	int type;
+	int rc = TPM_OK;
+
+	/* validation */
+	IF_NULL(TPM_C3_MOD, scan_config);
+	TPM_BIT_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->clear_before_scan, "invalid clear_before_scan");
+	TPM_BIT_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->lkp_type_scan, "invalid lkp_type_scan");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->lkp_type, MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX,
+				"invalid lookup type");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->scan_mode, TPM_SCAN_ABOVE_THRESHOLD, "invalid scan mode");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->start_entry, MV_PP2_CLS_C3_HASH_TBL_SIZE-1,
+				"invalid start entry");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->scan_delay, MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX,
+				"invalid scan delay");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, scan_config->scan_threshold, MV_PP2_V0_CLS3_SC_PROP_VAL_TH_MAX,
+				"invalid scan threshold");
+
+	/* set the configuration to HW */
+	rc = mvPp2ClsC3ScanThreshSet(scan_config->scan_mode, scan_config->scan_threshold);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set scan mode and theshold\n");
+
+	rc = mvPp2ClsC3ScanClearBeforeEnSet(scan_config->clear_before_scan);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set clear before scan\n");
+
+	if (scan_config->lkp_type_scan)
+		type = scan_config->lkp_type;
+	else
+		type = -1; /* LSP defined to indicate that do not care about lkp_type */
+	rc = mvPp2ClsC3ScanLkpTypeSet(type);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set scan lookup type\n");
+
+	rc = mvPp2ClsC3ScanStartIndexSet(scan_config->start_entry);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set scan start index\n");
+
+	rc = mvPp2ClsC3ScanDelaySet(scan_config->scan_delay);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set scan delay time\n");
+
+	/* save scan config to DB */
+	rc = tpm_db_c3_scan_param_set(scan_config);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set scan parameters to C3 DB\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_scan_result_get
+*
+* DESCRIPTION: The routine will trigger scan, wait and get scan results
+*
+* INPUTS:
+*	max_entry_num - Maximum entry number allowed
+*
+* OUTPUTS:
+*	entry_num     - entry number
+*	result_entry  - hold result entry, including hash_idx, logic_idx, hit_count
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_scan_result_get(unsigned int			max_entry_num,
+			   unsigned int			*entry_num,
+			   struct tpm_c3_scan_entry_t	result_entry[])
+{
+	int num;
+	int idx;
+	int hash_idx;
+	int hit_cnt;
+	int logic_idx;
+	int rc = TPM_OK;
+
+	/* validation */
+	IF_NULL(TPM_C3_MOD, entry_num);
+	IF_NULL(TPM_C3_MOD, result_entry);
+
+	/* trigger scan */
+	rc = mvPp2ClsC3ScanStart();
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to start scan\n");
+
+	/* Get scan entry number and compare w/ input one */
+	rc = mvPp2ClsC3ScanNumOfResGet(&num);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to get scan number\n");
+	if (max_entry_num < num)
+		num = max_entry_num;
+
+	*entry_num = 0;
+	/* Get multihash index and hit counter array */
+	for (idx = 0; idx < num; idx++) {
+		rc = mvPp2ClsC3ScanResRead(idx, &hash_idx, &hit_cnt);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to start scan\n");
+
+		/* get logical index by hash_idx */
+		rc = tpm_db_c3_logic_idx_get(hash_idx, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to get logical index\n");
+
+		/* fill array */
+		result_entry[idx].hash_idx  = hash_idx;
+		result_entry[idx].logic_idx = logic_idx;
+		result_entry[idx].hit_cnt   = hit_cnt;
+		(*entry_num)++;
+	}
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_entry_get
+*
+* DESCRIPTION: The routine will get C3 entry from HW with C3 logical index
+*
+* INPUTS:
+*	logic_idx  - C3 logical index
+*
+* OUTPUTS:
+*	c3_entry   - C3 entry data
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c3_entry_get(unsigned int logic_idx, struct tpm_c3_data_t *c3_entry)
+{
+	int rc = TPM_OK;
+	unsigned int hash_idx;
+	MV_PP2_CLS_C3_ENTRY c3_data;
+
+	/* Parameter check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	IF_NULL(TPM_C3_MOD, c3_entry);
+
+	/* Get HASH index */
+	rc = tpm_db_c3_hash_idx_get(logic_idx, &hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to access DB\n");
+
+	/* Read HW data with LSP API */
+	rc = mvPp2ClsC3HwRead(&c3_data, hash_idx);
+	if (rc) {
+		rc = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_C3_MOD, rc, "mvPp2ClsC3HwRead fail\n");
+	}
+
+	/* Convert c3_data to tpm c3_entry */
+	c3_entry->port.port_type = (c3_data.key.key_ctrl & KEY_CTRL_PRT_ID_MASK) >> KEY_CTRL_PRT_ID;
+	c3_entry->port.port_value = (c3_data.key.key_ctrl & KEY_CTRL_PRT_ID_TYPE_MASK) >> KEY_CTRL_PRT_ID_TYPE;
+	c3_entry->lkp_type = (c3_data.key.key_ctrl & KEY_CTRL_LKP_TYPE_MASK) >> KEY_CTRL_LKP_TYPE;
+	c3_entry->l4_type = (c3_data.key.key_ctrl & KEY_CTRL_L4_MASK) >> KEY_CTRL_L4;
+	c3_entry->hek_len = (c3_data.key.key_ctrl & KEY_CTRL_HEK_SIZE_MASK) >> KEY_CTRL_HEK_SIZE;
+
+	memcpy(c3_entry->hek, c3_data.key.hek.bytes, TPM_C3_MAX_HASH_KEY_SIZE);
+
+	c3_entry->action.color_act = (c3_data.sram.regs.actions & ACT_COLOR_MASK) >> ACT_COLOR;
+	c3_entry->action.q_low_act = (c3_data.sram.regs.actions & ACT_TBL_LOW_Q_MASK) >> ACT_TBL_LOW_Q;
+	c3_entry->action.q_high_act = (c3_data.sram.regs.actions & ACT_TBL_HIGH_Q_MASK) >> ACT_TBL_HIGH_Q;
+	c3_entry->action.policer_act = (c3_data.sram.regs.actions & ACT_POLICER_SELECT_MASK) >> ACT_POLICER_SELECT;
+	c3_entry->action.flowid_act = (c3_data.sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN;
+	c3_entry->action.frwd_act = (c3_data.sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD;
+
+	c3_entry->qos_value.q_high = (c3_data.sram.regs.qos_attr & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >>
+				     ACT_QOS_ATTR_MDF_HIGH_Q;
+	c3_entry->qos_value.q_low = (c3_data.sram.regs.qos_attr & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >>
+				    ACT_QOS_ATTR_MDF_LOW_Q;
+
+	c3_entry->pkt_mod.mod_cmd_idx = (c3_data.sram.regs.hwf_attr & ACT_HWF_ATTR_IPTR_MASK) >> ACT_HWF_ATTR_IPTR;
+	c3_entry->pkt_mod.mod_data_idx = (c3_data.sram.regs.hwf_attr & ACT_HWF_ATTR_DPTR_MASK) >> ACT_HWF_ATTR_DPTR;
+	c3_entry->pkt_mod.l4_chksum_update_flag = (c3_data.sram.regs.hwf_attr & ACT_HWF_ATTR_CHKSM_EN_MASK) >>
+						  ACT_HWF_ATTR_CHKSM_EN;
+
+	c3_entry->policer_id = (c3_data.sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID;
+	c3_entry->dup_info.flow_id = (c3_data.sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID;
+	c3_entry->dup_info.flow_cnt = (c3_data.sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT;
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_rule_sram_update
+*
+* DESCRIPTION: The routine will update C3 HW entry with new SRAM.
+*
+* INPUTS:
+*	logic_idx - C3 logical index
+*
+* OUTPUTS:
+*	sram      - C3 new sram
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*       NOTE: Unnecessary to update DB
+*******************************************************************************/
+int tpm_c3_rule_sram_update(unsigned int logic_idx, struct tpm_engine_sram_t *sram)
+{
+	int rc = TPM_OK;
+	unsigned int hash_idx;
+	MV_PP2_CLS_C3_ENTRY hw_entry;
+
+	/* Parameter check */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C3_MOD, logic_idx, MV_PP2_CLS_C3_HASH_TBL_SIZE-1, "invalid logical index");
+	IF_NULL(TPM_C3_MOD, sram);
+
+	TPM_MEMSET_ZERO(hw_entry);
+
+	/* Get HASH index */
+	rc = tpm_db_c3_hash_idx_get(logic_idx, &hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to access DB\n");
+
+	/* Read C3 HW entry */
+	rc = mvPp2ClsC3HwRead(&hw_entry, hash_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3HwRead\n");
+
+	/* Update C3 SRAM */
+	/* set color */
+	rc = mvPp2ClsC3ColorSet(&hw_entry, sram->action.color_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ColorSet\n");
+
+	/* set queue high */
+	rc = mvPp2ClsC3QueueHighSet(&hw_entry, sram->action.q_high_act, sram->qos_value.q_high);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueHighSet\n");
+
+	/* set queue low */
+	rc = mvPp2ClsC3QueueLowSet(&hw_entry, sram->action.q_low_act, sram->qos_value.q_low);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3QueueLowSet\n");
+
+	/* set forward */
+	rc = mvPp2ClsC3ForwardSet(&hw_entry, sram->action.frwd_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ForwardSet\n");
+
+	/* set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	rc = mvPp2ClsC3PolicerSet(&hw_entry, sram->action.policer_act, sram->qos_info.policer_id, TPM_PLCR_BANK0);
+#else
+
+	rc = mvPp2ClsC3PolicerSet(&hw_entry, sram->action.policer_act, sram->qos_info.policer_id);
+#endif
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3PolicerSet\n");
+
+	/* set flow ID */
+	rc = mvPp2ClsC3FlowIdEn(&hw_entry, sram->action.flowid_act);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3FlowIDSet\n");
+
+	/* set mod */
+	rc = mvPp2ClsC3ModSet(&hw_entry,
+			      sram->pkt_mod.mod_data_idx,
+			      sram->pkt_mod.mod_cmd_idx,
+			      sram->pkt_mod.l4_chksum_update_flag);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3ModSet\n");
+
+	/* set duplication */
+	rc = mvPp2ClsC3DupSet(&hw_entry, sram->dup_info.flow_id, sram->dup_info.flow_cnt);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3DupSet\n");
+
+	/* Write to HW again */
+	rc = mvPp2ClsC3HwAdd(&hw_entry, hash_idx, hw_entry.ext_index);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to call mvPp2ClsC3HwAdd\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_c3_reset
+*
+* DESCRIPTION: The routine reset and re-satrt TPM C3 sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+int tpm_c3_reset(void)
+{
+	int rc;
+
+	/* clear all C3 HW entries */
+	rc = mvPp2ClsC3HwDelAll();
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to delete C3 HW entries\n");
+
+	/* clear all C3 HW counters */
+	rc = mvPp2ClsC3HitCntrsClearAll();
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to clear C3 HW counters\n");
+
+	/* init TPM C3 DB */
+	rc = tpm_db_c3_init();
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to init TPM C3 DB\n");
+
+	/* set TPM C3 maximum search depth */
+	rc = tpm_db_c3_search_depth_set(CONFIG_MV_TPM_C3_SEARCH_DEPTH);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to set TPM C3 max search depth\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c3_start
+*
+* DESCRIPTION: The routine starts TPM C3 sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_start
+*******************************************************************************/
+int tpm_c3_start(void)
+{
+	if (tpm_c3_reset() != TPM_OK) {
+		TPM_OS_ERROR(TPM_C3_MOD, "TPM C3 start failed\n");
+		return TPM_INIT_ERROR;
+	}
+
+	return TPM_OK;
+}
+
+/* this routine is for UT, will be removed in future */
+int tpm_c3_test(void)
+{
+#ifdef TPM_C3_DEBUG
+#if 0 /* test case 1 */
+	int idx;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_c3_add_entry_t c3_entry;
+	unsigned int logic_idx;
+	int rc = TPM_OK;
+
+	/* init value */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.mng_pkt_key = &mng_pkt_key;
+	c3_entry.mng_pkt_key->pkt_key = &pkt_key;
+
+	/* set value */
+	c3_entry.port.port_type = TPM_SRC_PORT_TYPE_UNI;
+	c3_entry.port.port_value = 3;
+
+	c3_entry.lkp_type = 1;
+	c3_entry.mng_pkt_key->pkt_key->field_match_bm = TPM_MATCH_VID_OUTER;
+	c3_entry.mng_pkt_key->pkt_key->out_vid = 1000;
+
+	c3_entry.qos_info.policer_id = 0;
+
+	c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.flowid_act = TPM_ACTION_FLOWID_ENABLE;
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+
+	c3_entry.qos_value.q_high = 0;
+	c3_entry.qos_value.q_low = 5;
+
+	/* add rule */
+	for (idx = 0; idx < 1; idx++) {
+		rc = tpm_c3_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to add C3 rule\n");
+	}
+
+	return TPM_OK;
+#endif
+
+#if 0 /* test case 2 */
+	int idx;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_c3_add_entry_t c3_entry;
+	unsigned int logic_idx;
+	int rc = TPM_OK;
+
+	/* init value */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.mng_pkt_key = &mng_pkt_key;
+	c3_entry.mng_pkt_key->pkt_key = &pkt_key;
+
+	/* set value */
+	c3_entry.port.port_type = TPM_SRC_PORT_TYPE_UNI;
+	c3_entry.port.port_value = 3;
+
+	c3_entry.lkp_type = 1;
+	c3_entry.mng_pkt_key->pkt_key->field_match_bm = TPM_MATCH_VID_OUTER;
+	c3_entry.mng_pkt_key->pkt_key->out_vid = 1000;
+
+	c3_entry.qos_info.policer_id = 0;
+
+	c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.flowid_act = TPM_ACTION_FLOWID_ENABLE;
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+
+	c3_entry.qos_value.q_high = 0;
+	c3_entry.qos_value.q_low = 5;
+
+	/* add rule */
+	for (idx = 0; idx < 4096; idx++) {
+		c3_entry.mng_pkt_key->pkt_key->out_vid = idx;
+		rc = tpm_c3_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to add C3 rule\n");
+	}
+
+	return TPM_OK;
+#endif
+#if 0 /* test case 3 */
+	int idx;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_c3_add_entry_t c3_entry;
+	unsigned int logic_idx;
+	int rc = TPM_OK;
+
+	/* init value */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.mng_pkt_key = &mng_pkt_key;
+	c3_entry.mng_pkt_key->pkt_key = &pkt_key;
+
+	/* set value */
+	c3_entry.port.port_type = TPM_SRC_PORT_TYPE_UNI;
+	c3_entry.port.port_value = 3;
+
+	c3_entry.lkp_type = 1;
+	c3_entry.mng_pkt_key->pkt_key->field_match_bm =
+		/*TPM_MATCH_IPV6_PKT | */
+		TPM_MATCH_IP_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_L4_SRC
+		| TPM_MATCH_L4_DST;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_proto = IPPROTO_TCP;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_ver = 6;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv6[0] = 0x20;
+	for (idx = 0; idx < 15; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv6[1+idx] = idx;
+
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv6[0] = 0x20;
+	for (idx = 0; idx < 15; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv6[1+idx] = 0x10+idx;
+
+	c3_entry.mng_pkt_key->pkt_key->l4_dst = 0x1000;
+	c3_entry.mng_pkt_key->pkt_key->l4_src = 0x2000;
+
+	c3_entry.qos_info.policer_id = 0;
+
+	c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.flowid_act = TPM_ACTION_FLOWID_ENABLE;
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+
+	c3_entry.qos_value.q_high = 0;
+	c3_entry.qos_value.q_low = 5;
+
+	/* add rule */
+	for (idx = 0; idx < 1; idx++) {
+		rc = tpm_c3_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to add C3 rule\n");
+	}
+
+	return TPM_OK;
+#endif
+
+#if 0 /* test case 4 */
+	int idx;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_c3_add_entry_t c3_entry;
+	unsigned int logic_idx;
+	int rc = TPM_OK;
+
+	/* init value */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.mng_pkt_key = &mng_pkt_key;
+	c3_entry.mng_pkt_key->pkt_key = &pkt_key;
+
+	/* set value */
+	c3_entry.port.port_type = TPM_SRC_PORT_TYPE_UNI;
+	c3_entry.port.port_value = 3;
+
+	c3_entry.lkp_type = 1;
+	c3_entry.mng_pkt_key->pkt_key->field_match_bm =
+		/*TPM_MATCH_IPV6_PKT | */
+		TPM_MATCH_IP_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_L4_SRC
+		| TPM_MATCH_L4_DST;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_proto = IPPROTO_TCP;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_ver = 4;
+	for (idx = 0; idx < 4; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv4[idx] = idx;
+
+	for (idx = 0; idx < 4; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv4[idx] = 0x10+idx;
+
+	c3_entry.mng_pkt_key->pkt_key->l4_dst = 0x1000;
+	c3_entry.mng_pkt_key->pkt_key->l4_src = 0x2000;
+
+	c3_entry.qos_info.policer_id = 0;
+
+	c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.flowid_act = TPM_ACTION_FLOWID_ENABLE;
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+
+	c3_entry.qos_value.q_high = 0;
+	c3_entry.qos_value.q_low = 5;
+
+	/* add rule */
+	for (idx = 0; idx < 1; idx++) {
+		rc = tpm_c3_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to add C3 rule\n");
+	}
+
+	return TPM_OK;
+#endif
+
+#if 1 /* test case 5 */
+	int idx;
+	struct tpm_pkt_key_t pkt_key;
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_c3_add_entry_t c3_entry;
+	unsigned int logic_idx;
+	int rc = TPM_OK;
+
+	/* init value */
+	TPM_MEMSET_ZERO(pkt_key);
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	TPM_MEMSET_ZERO(c3_entry);
+	c3_entry.mng_pkt_key = &mng_pkt_key;
+	c3_entry.mng_pkt_key->pkt_key = &pkt_key;
+
+	/* set value */
+	c3_entry.port.port_type = TPM_SRC_PORT_TYPE_UNI;
+	c3_entry.port.port_value = 3;
+
+	c3_entry.lkp_type = 1;
+	c3_entry.mng_pkt_key->pkt_key->field_match_bm =
+		/*TPM_MATCH_IPV6_PKT | */
+		TPM_MATCH_IP_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST | TPM_MATCH_L4_SRC
+		| TPM_MATCH_L4_DST;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_proto = IPPROTO_TCP;
+	c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_ver = 4;
+	for (idx = 0; idx < 4; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv4[idx] = idx;
+
+	for (idx = 0; idx < 4; idx++)
+		c3_entry.mng_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv4[idx] = 0x10+idx;
+
+	c3_entry.mng_pkt_key->pkt_key->l4_dst = 0x1000;
+	c3_entry.mng_pkt_key->pkt_key->l4_src = 0x2000;
+
+	c3_entry.qos_info.policer_id = 0;
+
+	c3_entry.action.color_act = TPM_COLOR_ACTION_TYPE_NO_UPDT;
+	c3_entry.action.q_low_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.q_high_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.policer_act = TPM_ACTION_TYPE_UPDT_LOCK;
+	c3_entry.action.flowid_act = TPM_ACTION_FLOWID_ENABLE;
+	c3_entry.action.frwd_act = TPM_FRWD_ACTION_TYPE_HWF_LOCK;
+
+	c3_entry.qos_value.q_high = 0;
+	c3_entry.qos_value.q_low = 5;
+
+	/* add rule */
+	for (idx = 0; idx < 1; idx++) {
+		rc = tpm_c3_rule_add(&c3_entry, &logic_idx);
+		IF_ERROR_STR(TPM_C3_MOD, rc, "fail to add C3 rule\n");
+	}
+	/* delete rule */
+	rc = tpm_c3_rule_del(logic_idx);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "fail to delete C3 rule\n");
+
+	return TPM_OK;
+#endif
+#endif
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
new file mode 100644
index 0000000..65bf081
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_c4.c
@@ -0,0 +1,683 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_c4.c						     **
+**									     **
+**  DESCRIPTION : This file contains C4 engine sub-module routine and APIs   **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/*******************************************************************************
+* tpm_c4_pkt_field_len_get
+*
+* DESCRIPTION: The routine gets the length of field in Byte
+*
+* INPUTS:
+*	field_id -
+*
+* OUTPUTS:
+*	len        -length of field in Byte
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_c4_pkt_field_len_get(unsigned int field_id, unsigned int *len)
+{
+	int len_tmp = 0;
+
+	len_tmp = tpm_field_size_get(field_id);
+	if (0 == len_tmp) {
+		TPM_OS_ERROR(TPM_C4_MOD, "invalid field_id(0x%x)\n", field_id);
+		return TPM_BAD_PARAM;
+	}
+
+	/* here the len is bit, change to Byte */
+	if (len_tmp % BYTE_BITS)
+		len_tmp = (len_tmp / BYTE_BITS) + 1;
+	else
+		len_tmp = (len_tmp / BYTE_BITS);
+
+	*len = len_tmp;
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_eng_field_len_get
+*
+* DESCRIPTION: The routine gets the length of C4 field in Byte
+*
+* INPUTS:
+*	field_id -
+*
+* OUTPUTS:
+*	len        -length of field in Byte
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_c4_eng_field_len_get(unsigned int field_id, unsigned int *len)
+{
+	IF_NULL(TPM_C4_MOD, len);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, field_id,
+		TPM_C4_FIELD5_SIZE, "invalid field_id number\n");
+
+	if (field_id <= TPM_C4_FIELD_ID_3)
+		*len = TPM_C4_FIELD0_3_SIZE;
+	else if (field_id == TPM_C4_FIELD_ID_4)
+		*len = TPM_C4_FIELD4_SIZE;
+	else if (field_id == TPM_C4_FIELD_ID_5)
+		*len = TPM_C4_FIELD5_SIZE;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_field_cmp
+*
+* DESCRIPTION: The routine compares two fields according to the length and op
+*
+* INPUTS:
+*	field1 - the first field
+*	field2 - the second field
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	if field1<field2 returns -1, if field1>field2 returns 1, else returns 0
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_c4_field_cmp(const void *field1, const void *field2)
+{
+	int len1;
+	int len2;
+	int op1;
+	int op2;
+
+	IF_NULL(TPM_C4_MOD, field1);
+	IF_NULL(TPM_C4_MOD, field2);
+
+	len1 = tpm_field_size_get(((struct tpm_cnm_field_op_t *)field1)->field);
+	len2 = tpm_field_size_get(((struct tpm_cnm_field_op_t *)field2)->field);
+	op1 = ((struct tpm_cnm_field_op_t *)field1)->op;
+	op2 = ((struct tpm_cnm_field_op_t *)field2)->op;
+
+	if (len1 < len2)
+		return -1;
+	else if (len1 > len2)
+		return 1;
+	else if (op1 < op2)
+		return -1;
+	else if (op1 > op2)
+		return 1;
+	else
+		return 0;
+}
+/*******************************************************************************
+* tpm_c4_field_op_set
+*
+* DESCRIPTION: The routine sets the OP and field_in in struct tpm_cnm_field_op_t
+*
+* INPUTS:
+*	op_max -max valid value of OP
+*	field_op -input field_op
+*             field_info
+*
+* OUTPUTS:
+*	c4_field -output field_op
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_c4_field_op_set(
+	enum tpm_cnm_op_t op_max,
+	struct tpm_cnm_field_op_t	*field_op,
+	struct tpm_field_match_info	*field_info,
+	struct tpm_c4_field_t		*c4_field)
+{
+
+	if (field_op->op > op_max)
+		return TPM_BAD_PARAM;
+
+	if (c4_field->op != TPM_C4_OP_ALWAYS_TRUE)
+		return TPM_BAD_PARAM;
+
+	c4_field->op = field_op->op;
+	memcpy(&c4_field->field_info, field_info, sizeof(struct tpm_field_match_info));
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_c4_field_build
+*
+* DESCRIPTION: The routine sets the OP and field_in in struct tpm_cnm_field_op_t that follows
+*                         C4 HW entry, field 5 is for size 16B, field 4 is for size 6B, etc.
+*
+* INPUTS:
+*	field_num
+*	field_op -input field_op
+*
+* OUTPUTS:
+*	c4_field -output field_op
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_c4_field_build(
+	unsigned int			field_num,
+	struct tpm_pkt_key_t		*pkt_key,
+	struct tpm_cnm_field_op_t	*field_op,
+	struct tpm_c4_field_t		*c4_field)
+{
+	unsigned int ret;
+	int len;
+	int loop;
+	int loop_in;
+	struct tpm_c4_field_t *field_0_3 = &c4_field[TPM_C4_FIELD_ID_3];
+	struct tpm_cnm_field_op_t field_op_tmp[TPM_CNM_FIELD_MAX];
+	struct tpm_mng_pkt_key_t mng_pkt_key;
+	struct tpm_field_match_info	field_info[TPM_CNM_FIELD_MAX];
+	struct tpm_field_match_info	field_info_tmp[TPM_CNM_FIELD_MAX];
+
+	memset(c4_field, 0, (sizeof(struct tpm_c4_field_t) * TPM_CNM_FIELD_MAX));
+	/* set all c4_field to be invalid */
+	for (loop = 0; loop < TPM_CNM_FIELD_MAX; loop++)
+		c4_field[loop].op = TPM_C4_OP_ALWAYS_TRUE;
+
+	/* input field_id is tpm_field_match_t, translate into tpm_cls_field_id_t */
+	memcpy(&field_op_tmp, field_op, sizeof(field_op_tmp));
+
+	/* build mng_pkt_key */
+	TPM_MEMSET_ZERO(mng_pkt_key);
+	mng_pkt_key.pkt_key = pkt_key;
+
+	for (loop = 0; loop < field_num; loop++) {
+		ret = tpm_field_bm_to_field_info(field_op_tmp[loop].field, &mng_pkt_key,
+			1, false, &field_info_tmp[loop]);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get field_info field_id(0x%x)\n",
+			field_op[loop].field);
+		field_op_tmp[loop].field = field_info_tmp[loop].field_id;
+	}
+
+	/* sort field_op array based on field_length and op */
+	sort(&field_op_tmp[0], field_num,
+		sizeof(struct tpm_cnm_field_op_t), tpm_c4_field_cmp, NULL);
+
+	for (loop = 0; loop < field_num; loop++) {
+		for (loop_in = 0; loop_in < field_num; loop_in++) {
+			if (field_op_tmp[loop].field == field_info_tmp[loop_in].field_id) {
+				memcpy(&field_info[loop],
+				       &field_info_tmp[loop_in],
+				       sizeof(struct tpm_field_match_info));
+				break;
+			}
+		}
+	}
+
+	for (loop = field_num - 1; loop >= 0; loop--) {
+
+		ret = tpm_c4_pkt_field_len_get(field_op_tmp[loop].field, &len);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of field_id(0x%x)\n",
+			field_op_tmp[loop].field);
+
+		if (len > TPM_C4_FIELD4_SIZE) {
+			TPM_OS_ERROR(TPM_C4_MOD, "field_len(%d) should not be bigger than (%d), field_id(0x%x)\n",
+				len, TPM_C4_FIELD4_SIZE, field_op_tmp[loop].field);
+			return TPM_BAD_PARAM;
+		} else if (len > TPM_C4_FIELD5_SIZE) {
+			/* put it in field 4 */
+			ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
+				&field_op_tmp[loop],
+				&field_info[loop],
+				&c4_field[TPM_C4_FIELD_ID_4]);
+			IF_ERROR_STR(TPM_C4_MOD, ret,
+			"CnM key comb invalid, refer to the help.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
+			field_op_tmp[loop].op, len, field_op_tmp[loop].field);
+		} else if (len > TPM_C4_FIELD0_3_SIZE) {
+			/* try to put it in field 5 first */
+			ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
+				&field_op_tmp[loop],
+				&field_info[loop],
+				&c4_field[TPM_C4_FIELD_ID_5]);
+			if (ret) {
+				/* put it in field 4 */
+				ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
+					&field_op_tmp[loop],
+					&field_info[loop],
+					&c4_field[TPM_C4_FIELD_ID_4]);
+				IF_ERROR_STR(TPM_C4_MOD, ret,
+						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
+						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
+			}
+		} else {
+			/* try to put it in field 0 to 3 first, then 4 or 5 */
+			if (field_0_3 != NULL) {
+				ret = tpm_c4_field_op_set(TPM_CNM_OP_MAX,
+							  &field_op_tmp[loop],
+							  &field_info[loop],
+							  field_0_3);
+				IF_ERROR_STR(TPM_C4_MOD, ret,
+						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
+						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
+				if (field_0_3 != &c4_field[TPM_C4_FIELD_ID_0])
+					field_0_3--;
+				else
+					field_0_3 = NULL;
+			} else {
+				/* try to put it in field 5 first */
+				ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
+					&field_op_tmp[loop],
+					&field_info[loop],
+					&c4_field[TPM_C4_FIELD_ID_5]);
+				if (ret) {
+					/* put it in field 4 */
+					ret = tpm_c4_field_op_set(TPM_CNM_OP_NOT_EQUAL,
+						&field_op_tmp[loop], &field_info[loop],
+						&c4_field[TPM_C4_FIELD_ID_4]);
+					IF_ERROR_STR(TPM_C4_MOD, ret,
+						"CnM key comb invalid.Invalid op(%d), field_len(%d), field_id(0x%x)\n",
+						field_op_tmp[loop].op, len, field_op_tmp[loop].field);
+				}
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_port_to_ruleset_set()
+*
+* DESCRIPTION: This routine sets port to ruleset
+*
+* INPUTS:
+*          src_port   - could be UNI port or PHY port
+*          rule_set   - C4 engine ruleSet No.
+*          rule_number   - rule number of this ruleSet.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c4_port_to_ruleset_set(
+	struct tpm_class_port_t	*src_port,
+	unsigned int		rule_set,
+	unsigned int		rule_number)
+{
+	int ret;
+	int loop;
+	int port_id = 0;
+
+	IF_NULL(TPM_C4_MOD, src_port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, rule_number,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number\n");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, rule_set,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet\n");
+
+	for (loop = 0; loop < MV_PP2_MAX_PORTS; loop++)
+		if (src_port->class_port & (1 << loop)) {
+			port_id = loop;
+			break;
+		}
+
+	if (TPM_CLASS_SWITCH_PORT_BM == src_port->port_type) {
+		/* UNI port */
+		TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, port_id,
+			TPM_NUM_MAX_UNI_PORTS_BM, "invalid port value\n");
+
+		ret = mvPp2ClsC4HwUniToRulesSet(port_id, rule_set, rule_number);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set ruleSet(%d) of UNI port(%d)\n",
+			rule_set, port_id);
+
+	} else if (TPM_CLASS_PP_PORT_BM == src_port->port_type) {
+		/* PHY port */
+		TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, port_id,
+			(1 << (MV_PP2_MAX_PORTS - 1)), "invalid port value\n");
+
+		ret = mvPp2ClsC4HwPortToRulesSet(port_id, rule_set, rule_number);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set ruleSet(%d) of PHY port(%d)\n",
+			rule_set, port_id);
+	} else
+		IF_ERROR_STR(TPM_C4_MOD, TPM_BAD_PARAM, "invalid src port type(%d)\n", src_port->port_type);
+
+	/* update C4 DB */
+	ret = tpm_db_c4_port_to_ruleset_set(src_port, rule_set, rule_number);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set ruleSet(%d) of port(%d) into DB\n",
+		rule_set, src_port->class_port);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_entry_add()
+*
+* DESCRIPTION: This routine adds C4 entry
+*
+* INPUTS:
+*          c4_entry   -
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c4_entry_add(struct tpm_c4_add_entry_t *c4_entry)
+{
+	MV_PP2_CLS_C4_ENTRY c4_hw_entry;
+	unsigned int ret;
+	unsigned int len = 0;
+	unsigned int eng_field_len = 0;
+	unsigned int loop;
+	unsigned int loop_in;
+	unsigned int loop_in_max;
+	unsigned short short_value;
+	unsigned int int_value;
+	struct tpm_c4_field_t c4_field[TPM_CNM_FIELD_MAX];
+
+	IF_NULL(TPM_C4_MOD, c4_entry);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, c4_entry->rule_num,
+		MV_PP2_CLS_C4_GRP_SIZE, "invalid rule number\n");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_C4_MOD, c4_entry->ruleSet,
+		MV_PP2_CLS_C4_GRPS_NUM, "invalid ruleSet\n");
+
+	/* clear hw entry */
+	mvPp2ClsC4SwClear(&c4_hw_entry);
+
+	/* set ruleSet, rule_num */
+	c4_hw_entry.ruleIndex = c4_entry->rule_num;
+	c4_hw_entry.setIndex = c4_entry->ruleSet;
+
+	/* set vlan_num */
+	ret = mvPp2ClsC4SwVlanSet(&c4_hw_entry, c4_entry->vlan_num);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set vlan number(%d)\n", c4_entry->vlan_num);
+
+	/* set pppoe */
+	ret = mvPp2ClsC4SwPppoeSet(&c4_hw_entry, c4_entry->pppoe);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set pppoe(%d)\n", c4_entry->pppoe);
+
+	/* set mac_to_me */
+	ret = mvPp2ClsC4SwMacMeSet(&c4_hw_entry, c4_entry->mac_to_me);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set mac_to_me(%d)\n", c4_entry->mac_to_me);
+
+	/* set l3_info */
+	ret = mvPp2ClsC4SwL3InfoSet(&c4_hw_entry, c4_entry->l3_info);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set l3_info(%d)\n", c4_entry->l3_info);
+
+	/* set l4_info */
+	ret = mvPp2ClsC4SwL4InfoSet(&c4_hw_entry, c4_entry->l4_info);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set l4_info(%d)\n", c4_entry->l4_info);
+
+	/* build C4 key */
+	ret = tpm_c4_field_build(c4_entry->field_num, &c4_entry->pkt_key, c4_entry->field_op, c4_field);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to build c4_field\n");
+
+	for (loop = 0; loop < TPM_CNM_FIELD_MAX; loop++) {
+
+		/* set field_id and op */
+		ret = mvPp2ClsC4FieldsParamsSet(&c4_hw_entry, loop,
+			c4_field[loop].field_info.field_id, c4_field[loop].op);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param\n");
+
+		if (c4_field[loop].op == TPM_C4_OP_ALWAYS_TRUE)
+			continue;
+
+		/* get pkt field length */
+		ret = tpm_c4_pkt_field_len_get(c4_field[loop].field_info.field_id, &len);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of field_id(0x%x)\n",
+			c4_field[loop].field_info.field_id);
+
+		/* get eng field length */
+		ret = tpm_c4_eng_field_len_get(loop, &eng_field_len);
+		IF_ERROR_STR(TPM_C4_MOD, ret, "fail to get size of eng field(0x%x)\n", loop);
+
+		/* set field data value */
+		loop_in_max = (len / 2);
+		if (len % 2)
+			loop_in_max++;
+
+		if (len > 3) {
+			/* here we deal with IPv4/6 Address, MAC */
+			for (loop_in = 0; loop_in < loop_in_max; loop_in++) {
+
+				short_value =
+					(c4_field[loop].field_info.filed_value.ipv6_addr.parsed_ipv6_addr[loop_in * 2]
+					<< BYTE_BITS);
+				if ((loop_in == (loop_in_max - 1))
+				&& (len % 2))
+					;/* in this case do not set second byte of short */
+				else
+					short_value |=
+				c4_field[loop].field_info.filed_value.ipv6_addr.parsed_ipv6_addr[(loop_in * 2) + 1];
+				ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop,
+					((eng_field_len - 2) - (loop_in * 2)), short_value);
+				IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			}
+		} else if (len == 3) {
+			/* IPv6 flow lable */
+			int_value = (unsigned int)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
+			short_value = (int_value & 0xffff);
+			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, (eng_field_len - 2), short_value);
+			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+			short_value = (int_value >> SHORT_BITS);
+			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, (eng_field_len - 1), short_value);
+			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+
+		} else if (len == 2) {
+			short_value = (unsigned short)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
+			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, 0, short_value);
+			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+
+		} else if (len == 1) {
+			short_value = (unsigned char)c4_field[loop].field_info.filed_value.int_data.parsed_int_val;
+			short_value <<= BYTE_BITS;
+
+			/* some field need to be handled specialy */
+			if (OUT_VLAN_PRI_FIELD_ID == c4_field[loop].field_info.field_id) {
+				/* Pbit: xxx0 0000 */
+				short_value <<= TPM_C4_PBIT_OFFSET;
+			} else if (IP_VER_FIELD_ID == c4_field[loop].field_info.field_id) {
+				/* IP_ver: xxxx 0000 */
+				short_value <<= TPM_C4_IP_VER_OFFSET;
+			} else if (IPV4_DSCP_FIELD_ID == c4_field[loop].field_info.field_id) {
+				/* DSCP: xxxx xx00 */
+				short_value <<= TPM_C4_DSCP_OFFSET;
+			} else if (IPV6_DSCP_FIELD_ID == c4_field[loop].field_info.field_id) {
+				/* IPV6_DSCP: xxxx xx00 */
+				short_value <<= TPM_C4_DSCP_OFFSET;
+				short_value >>= TPM_C4_IP_VER_OFFSET;
+			}
+			ret = mvPp2ClsC4FieldsShortSet(&c4_hw_entry, loop, 0, short_value);
+			IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set c4 field param, field_id(%d)\n", loop);
+
+		}
+	}
+
+	/* set dscp */
+	ret = mvPp2ClsC4DscpSet(&c4_hw_entry, c4_entry->action.dscp_act, c4_entry->qos_value.dscp);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set dscp cmd(%d) and value(%d)\n",
+		c4_entry->action.dscp_act, c4_entry->qos_value.dscp);
+
+	/* set color */
+	ret = mvPp2ClsC4ColorSet(&c4_hw_entry, c4_entry->action.color_act);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set color cmd(%d)\n",
+		c4_entry->action.color_act);
+
+	/* set Pri */
+	ret = mvPp2ClsC4PrioSet(&c4_hw_entry, c4_entry->action.pri_act, c4_entry->qos_value.pri);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set pri cmd(%d) and value(%d)\n",
+		c4_entry->action.pri_act, c4_entry->qos_value.pri);
+
+	/* set gpid */
+	ret = mvPp2ClsC4GpidSet(&c4_hw_entry, c4_entry->action.gemp_act, c4_entry->qos_value.gemp);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set gpid cmd(%d) and value(%d)\n",
+		c4_entry->action.gemp_act, c4_entry->qos_value.gemp);
+
+	/* set policer */
+#ifdef CONFIG_MV_ETH_PP2_1
+	ret = mvPp2ClsC4PolicerSet(&c4_hw_entry, c4_entry->action.policer_act, c4_entry->policer_id, TPM_PLCR_BANK0);
+#else
+	ret = mvPp2ClsC4PolicerSet(&c4_hw_entry, c4_entry->action.policer_act, c4_entry->policer_id);
+#endif
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set policer_id cmd(%d) and value(%d)\n",
+		c4_entry->action.policer_act, c4_entry->policer_id);
+
+	/* set q_low */
+	ret = mvPp2ClsC4QueueLowSet(&c4_hw_entry, c4_entry->action.q_low_act, c4_entry->qos_value.q_low);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set q_low cmd(%d) and value(%d)\n",
+		c4_entry->action.q_low_act, c4_entry->qos_value.q_low);
+
+	/* set q_high */
+	ret = mvPp2ClsC4QueueHighSet(&c4_hw_entry, c4_entry->action.q_high_act, c4_entry->qos_value.q_high);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to set q_high cmd(%d) and value(%d)\n",
+		c4_entry->action.q_high_act, c4_entry->qos_value.q_high);
+
+	/* write C4 entry to HW */
+	ret = mvPp2ClsC4HwWrite(&c4_hw_entry, c4_entry->rule_num, c4_entry->ruleSet);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to write HW c4 entry, rule_num(%d), ruleSet(%d)\n",
+		c4_entry->rule_num, c4_entry->ruleSet);
+
+	/* update C4 DB */
+	ret = tpm_db_c4_rule_add(c4_entry);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to add C4 entry into DB\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_entry_del()
+*
+* DESCRIPTION: This routine deletes a C4 entry
+*
+* INPUTS:
+*          ruleSet   -
+*          rule_num   -
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_c4_entry_del(
+	unsigned int ruleSet,
+	unsigned int rule_num)
+{
+	unsigned int ret;
+	MV_PP2_CLS_C4_ENTRY C4;
+
+	mvPp2ClsC4SwClear(&C4);
+
+	ret = mvPp2ClsC4HwWrite(&C4, rule_num, ruleSet);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to delete HW c4 entry, rule_num(%d), ruleSet(%d)\n",
+		rule_num, ruleSet);
+
+	/* update C4 DB */
+	ret = tpm_db_c4_rule_del(ruleSet, rule_num);
+	IF_ERROR_STR(TPM_C4_MOD, ret, "fail to delete C4 entry from DB\n");
+
+	return TPM_OK;
+}
+/*******************************************************************************
+* tpm_c4_reset
+*
+* DESCRIPTION: The API will clean all the entries in C4 engine,
+*              and clear C4 sub-module DB at the same time
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+* RETURN:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_c4_reset(void)
+{
+	int ret_code;
+
+	/* clear all C4 HW entries */
+	mvPp2ClsC4HwClearAll();
+
+	/* Clear TPM C4 DB */
+	ret_code = tpm_db_c4_init();
+	IF_ERROR(TPM_C4_MOD, ret_code);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_c4_start
+*
+* DESCRIPTION: The API start C4 module:
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_start.
+*******************************************************************************/
+int tpm_c4_start(void)
+{
+	if (tpm_c4_reset()) {
+		TPM_OS_ERROR(TPM_C4_MOD, "TPM C4 start failed\n");
+		return TPM_INIT_ERROR;
+	}
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
new file mode 100644
index 0000000..821f121
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_cls.c
@@ -0,0 +1,2107 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+#define SAME_PRIO_ENABLED	0
+#undef TPM_CLS_DEBUG
+
+
+#ifdef TPM_CLS_DEBUG
+void debug_dump_cls_fl(char *name, struct tpm_cls_fl_t *flow)
+{
+	int i;
+
+	printk(KERN_INFO "dumping flow_log_id %d %s\n", flow->fl_log_id, name);
+
+	for (i = 0; i < flow->fl_len; i++) {
+		printk(KERN_INFO "en %d eng %d fid_cnt %d lut %2d port_bm %5d port_t %5d pri %2d ref_cnt %2d skip %d\n",
+			(int)flow->fl[i].enabled,
+			(int)flow->fl[i].engine,
+			(int)flow->fl[i].field_id_cnt,
+			(int)flow->fl[i].lu_type,
+			(int)flow->fl[i].port_bm,
+			(int)flow->fl[i].port_type,
+			(int)flow->fl[i].prio,
+			(int)flow->fl[i].ref_cnt,
+			(int)flow->fl[i].skip);
+	}
+}
+
+
+void debug_dump_lkp_dcod_db(char *name, struct tpm_db_cls_lkp_dcod_t	*lkp_dcod_db)
+{
+	int	i;
+
+	printk(KERN_INFO "dumping tpm_db_cls_lkp_dcod_t %s\n", name);
+
+	printk(KERN_INFO "CPUq %d enabled %d alloc_len %d flow_len %d flow_off %d luid_num %d way %d\n",
+			(int)lkp_dcod_db->cpu_q,
+			(int)lkp_dcod_db->enabled,
+			(int)lkp_dcod_db->flow_alloc_len,
+			(int)lkp_dcod_db->flow_len,
+			(int)lkp_dcod_db->flow_off,
+			(int)lkp_dcod_db->luid_num,
+			(int)lkp_dcod_db->way);
+
+	for (i = 0; i < lkp_dcod_db->luid_num; i++)
+		printk(KERN_INFO "luid[%d]=%d/%d ",
+				i, lkp_dcod_db->luid_list[i].luid, lkp_dcod_db->luid_list[i].first_pri);
+	printk(KERN_INFO "\n");
+}
+#endif
+
+
+/*******************************************************************************
+* tpm_cls_lkp_dcod_set
+*
+* DESCRIPTION: The API writes a single lookup decode entry to DB
+*
+* INPUTS:
+*	lkp_dcod_conf - lookup decode structure information
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_cls_lkp_dcod_set(struct tpm_cls_lkp_dcod_entry_t *lkp_dcod_conf)
+{
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod_db;
+	struct tpm_db_cls_fl_ctrl_t	fl_ctrl;
+	int				rc;
+
+	IF_NULL(TPM_CLS_MOD, lkp_dcod_conf)
+
+	if (lkp_dcod_conf->flow_log_id >= TPM_MNG_FLOW_ID_MAX) {
+		TPM_OS_ERROR(TPM_CLS_MOD, "Invalid input (flow_log_id=%d)\n", lkp_dcod_conf->flow_log_id);
+		return TPM_BAD_PARAM;
+	}
+
+	if (lkp_dcod_conf->luid_num >= TPM_CLS_LOG_FLOW_LUID_MAX) {
+		TPM_OS_ERROR(TPM_CLS_MOD, "Invalid input (luid_num=%d)\n", lkp_dcod_conf->luid_num);
+		return TPM_BAD_PARAM;
+	}
+
+	/* get the DB entry for log flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(lkp_dcod_conf->flow_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", lkp_dcod_conf->flow_log_id)
+
+	if (lkp_dcod_db.enabled == true) {
+		TPM_OS_ERROR(TPM_CLS_MOD, "log flowid %d already configured\n", lkp_dcod_conf->flow_log_id);
+		return TPM_FAIL;
+	}
+
+	rc = tpm_db_cls_fl_ctrl_get(&fl_ctrl);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* check that we have enough free space for flow */
+	if (fl_ctrl.f_end - fl_ctrl.f_start <= lkp_dcod_conf->flow_len) {
+		TPM_OS_ERROR(TPM_CLS_MOD, "not enough space for flow, request: %d, free:%d\n",
+			lkp_dcod_conf->flow_len, fl_ctrl.f_end - fl_ctrl.f_start);
+		return TPM_NO_RESOURCE;
+	}
+
+	lkp_dcod_db.flow_off	= fl_ctrl.f_start;
+	lkp_dcod_db.flow_alloc_len = lkp_dcod_conf->flow_len;
+	lkp_dcod_db.flow_len	= 0;
+	lkp_dcod_db.luid_num	= lkp_dcod_conf->luid_num;
+	memcpy(lkp_dcod_db.luid_list, lkp_dcod_conf->luid_list,
+	       sizeof(struct tpm_cls_luid_conf_t) * lkp_dcod_conf->luid_num);
+	lkp_dcod_db.way	= lkp_dcod_conf->way;
+	lkp_dcod_db.cpu_q	= lkp_dcod_conf->cpu_q;
+	lkp_dcod_db.enabled	= false;
+
+	rc = tpm_db_cls_lkp_dcod_set(lkp_dcod_conf->flow_log_id, &lkp_dcod_db);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* update the max flow length */
+	if (lkp_dcod_conf->flow_len > fl_ctrl.fl_max_len)
+		fl_ctrl.fl_max_len = lkp_dcod_conf->flow_len;
+
+	/* update the control start index */
+	fl_ctrl.f_start += lkp_dcod_conf->flow_len;
+
+	rc = tpm_db_cls_fl_ctrl_set(&fl_ctrl);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_lkp_dcod_hw_set
+*
+* DESCRIPTION: The routine write to HW the lookup decode entry
+*
+* INPUTS:
+*	fl - flow rules structure
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_lkp_dcod_hw_set(struct tpm_cls_fl_t	*fl)
+{
+	MV_PP2_CLS_LKP_ENTRY			fe;
+	int					rc;
+	unsigned short				luid, rl = 0;
+	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
+	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	unsigned short				rl_off;
+
+	IF_NULL(TPM_CLS_MOD, fl)
+
+	/* get the lookup DB for this logical flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(fl->fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl->fl_log_id)
+
+	if (lkp_dcod_db.enabled == false) {
+		/* entry not enabled for this log_flow id */
+		return TPM_OK;
+	}
+
+	/* get the rule list for this logical flow ID */
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+				fl->fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+
+	/* iterate over all LUIDs */
+	for (luid = 0; luid < lkp_dcod_db.luid_num; luid++) {
+		/* Exclude MAC default LookupID by LSP */
+		if (LUID_IS_LSP_RESERVED(lkp_dcod_db.luid_list[luid].luid))
+			continue;
+
+		/* found the rule, get it`s offset */
+		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db.flow[rl].rl_log_id);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* updated the HW */
+		mvPp2ClsSwLkpClear(&fe);
+
+		rc = mvPp2ClsSwLkpFlowSet(&fe, rl_off);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsSwLkpRxqSet(&fe, lkp_dcod_db.cpu_q);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsSwLkpEnSet(&fe, lkp_dcod_db.enabled);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsHwLkpWrite(lkp_dcod_db.luid_list[luid].luid, lkp_dcod_db.way, &fe);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		TPM_OS_DEBUG(TPM_CLS_MOD,
+				"fl_log_id[%2d] lid_nr[%2d] rl_log_id[%3d] prio[%2d] rl_off[%3d] luid[%2d] way[%d]\n",
+				fl->fl_log_id, luid, fl_rl_db.flow[rl].rl_log_id,
+				fl_rl_db.flow[rl].prio,
+				rl_off,
+				lkp_dcod_db.luid_list[luid].luid,
+				lkp_dcod_db.way);
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_lkp_dcod_hw_clear_all
+*
+* DESCRIPTION: The routine clears all HW lookup decode entries
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_lkp_dcod_hw_clear_all(void)
+{
+	int	lkpid,
+		rc;
+
+	for (lkpid = 0; lkpid < MV_PP2_CLS_LKP_TBL_SIZE ; lkpid++) {
+		if (LUID_IS_LSP_RESERVED(lkpid))
+			continue;
+
+		rc = mvPp2ClsHwLkpClear(lkpid, TPM_WAY_PON);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsHwLkpClear(lkpid, TPM_WAY_NON_PON);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_lkp_dcod_enable
+*
+* DESCRIPTION: The API enables a lookup decode entry for a logical flow ID
+*
+* INPUTS:
+*	fl_log_id - the logical flow ID to perform the operation
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_cls_lkp_dcod_enable(unsigned short	fl_log_id)
+{
+	MV_PP2_CLS_LKP_ENTRY			fe;
+	int					rc;
+	unsigned short				luid, rl = 0;
+	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
+	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	unsigned short				rl_off;
+
+	/* get the lookup DB for this logical flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl_log_id)
+
+	if (lkp_dcod_db.enabled == true) {
+		/* entry enabled for this log_flow id */
+		TPM_OS_WARN(TPM_CLS_MOD, "skipping enable of fl_log_id=%d, already enabled\n", fl_log_id)
+		return TPM_OK;
+	}
+
+	if (0 == lkp_dcod_db.flow_len) {
+		/* there are no flow rules */
+		TPM_OS_WARN(TPM_CLS_MOD, "skipping enable of fl_log_id=%d, no rules in flow\n", fl_log_id)
+		return TPM_OK;
+	}
+
+	/* get the rule list for this logical flow ID */
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+				fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+
+	fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+
+	/* iterate over all LUIDs */
+	for (luid = 0; luid < lkp_dcod_db.luid_num; luid++) {
+		/* Exclude MAC default LookupID by LSP */
+		if (LUID_IS_LSP_RESERVED(lkp_dcod_db.luid_list[luid].luid))
+			continue;
+
+		/* found the rule, get it`s offset */
+		rc = tpm_db_cls_rl_off_get(&rl_off, fl_rl_db.flow[rl].rl_log_id);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* updated the HW */
+		mvPp2ClsSwLkpClear(&fe);
+
+		rc = mvPp2ClsSwLkpFlowSet(&fe, rl_off);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsSwLkpRxqSet(&fe, lkp_dcod_db.cpu_q);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsSwLkpEnSet(&fe, 1);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		rc = mvPp2ClsHwLkpWrite(lkp_dcod_db.luid_list[luid].luid, lkp_dcod_db.way, &fe);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		TPM_OS_DEBUG(TPM_CLS_MOD,
+				"fl_log_id[%2d] luid_nr[%2d] rl_log_id[%3d] prio[%2d] rl_off[%3d] luid[%2d] way[%d]\n",
+				fl_log_id, luid, fl_rl_db.flow[rl].rl_log_id,
+				fl_rl_db.flow[rl].prio,
+				rl_off,
+				lkp_dcod_db.luid_list[luid].luid,
+				lkp_dcod_db.way);
+	}
+
+	/* update lkp_dcod DB */
+	lkp_dcod_db.enabled = true;
+	rc = tpm_db_cls_lkp_dcod_set(fl_log_id, &lkp_dcod_db);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* cmp_prio
+*
+* DESCRIPTION: The routine compares two rules according to the rule priority
+*
+* INPUTS:
+*	rl1 - the first rule
+*	rl2 - the second rule
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	if rl1<rl2 returns -1, if rl1>rl2 returns 1, else returns 0
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int cmp_prio(const void *rl1, const void *rl2)
+{
+	if (((struct tpm_cls_rl_entry_t *)rl1)->prio < ((struct tpm_cls_rl_entry_t *)rl2)->prio)
+		return -1;
+	else if (((struct tpm_cls_rl_entry_t *)rl1)->prio > ((struct tpm_cls_rl_entry_t *)rl2)->prio)
+		return 1;
+	else
+		return 0;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rl_eng_cnt_upd
+*
+* DESCRIPTION: The routine updates the engine count according to input params
+*
+* INPUTS:
+*	op - the operation to perform (increment/decrement)
+*	eng - the engine to update
+*
+* OUTPUTS:
+*	eng_cnt - the engine structure which is updated
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rl_eng_cnt_upd(enum tpm_cls_rl_cnt_op_t	op,
+					unsigned short			eng,
+					struct tpm_cls_fl_eng_cnt_t	*eng_cnt)
+{
+	IF_NULL(TPM_CLS_MOD, eng_cnt)
+
+	switch (eng) {
+	case TPM_ENGINE_C2:
+		(TPM_CNT_DEC == op) ? eng_cnt->c2-- : eng_cnt->c2++;
+		break;
+
+	case TPM_ENGINE_C3_A:
+	case TPM_ENGINE_C3_B:
+		(TPM_CNT_DEC == op) ? eng_cnt->c3-- : eng_cnt->c3++;
+		break;
+
+	case TPM_ENGINE_C4:
+		(TPM_CNT_DEC == op) ? eng_cnt->c4-- : eng_cnt->c4++;
+		break;
+
+	default:
+		TPM_OS_ERROR(TPM_CLS_MOD, "Invalid input [engine=%d op=%d]\n", eng, op);
+		return TPM_BAD_PARAM;
+	}
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_new_fl_rl_merge
+*
+* DESCRIPTION: The routine merges a single rule into a merged flow.
+*
+* INPUTS:
+*	new_rl_num - the rule number in the new flow
+*	new_fl_rls - the new flow that the new rule comes from
+*
+* OUTPUTS:
+*	mrg_fl_rls - the merged flow
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_new_fl_rl_merge(unsigned short		new_rl_num,
+				struct tpm_cls_fl_t	*new_fl_rls,
+				struct tpm_cls_fl_t	*mrg_fl_rls)
+{
+	int			rc;
+
+	IF_NULL(TPM_CLS_MOD, new_fl_rls)
+	IF_NULL(TPM_CLS_MOD, mrg_fl_rls)
+
+	/* copy rule to merged flow */
+	memcpy(&mrg_fl_rls->fl[mrg_fl_rls->fl_len],
+		&new_fl_rls->fl[new_rl_num],
+		sizeof(struct tpm_cls_rl_entry_t));
+
+	/* set the skip flag in the source */
+	new_fl_rls->fl[new_rl_num].skip = 1;
+
+	/* update merged flow length */
+	mrg_fl_rls->fl_len++;
+
+	/* update merge engine count */
+	rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC,
+					new_fl_rls->fl[new_rl_num].engine,
+					&mrg_fl_rls->eng_cnt);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* update new engine count */
+	rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_DEC,
+					new_fl_rls->fl[new_rl_num].engine,
+					&new_fl_rls->eng_cnt);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_rl_hit_cnt_upd
+*
+* DESCRIPTION: The routine updates the engine hit counter for a single rule.
+*		It scans the flow for an identical rule, if does not find
+*		it increments the engine counter
+*
+* INPUTS:
+*	rl - rule to insert information
+*	fl_rls - flow rules to check the new rule
+*
+* OUTPUTS:
+*	eng_hit_cnt - the hit counter per engine structure which is updated
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_rl_hit_cnt_upd(struct tpm_cls_rl_entry_t	*rl,
+				struct tpm_cls_fl_t		*fl_rls,
+				struct tpm_cls_fl_eng_cnt_t	*eng_hit_cnt)
+{
+	unsigned short	rl_i;
+	int		rc;
+
+	IF_NULL(TPM_CLS_MOD, rl)
+	IF_NULL(TPM_CLS_MOD, fl_rls)
+	IF_NULL(TPM_CLS_MOD, eng_hit_cnt)
+
+	/* scan the flow for an identical rule */
+	for (rl_i = 0; rl_i < fl_rls->fl_len; rl_i++) {
+		if ((fl_rls->fl[rl_i].engine		== rl->engine)		&&
+		    (fl_rls->fl[rl_i].lu_type		== rl->lu_type)		&&
+		    (fl_rls->fl[rl_i].prio		== rl->prio)		&&
+		    (fl_rls->fl[rl_i].field_id_cnt	== rl->field_id_cnt)	&&
+		    (!memcmp(fl_rls->fl[rl_i].field_id,
+				rl->field_id,
+				sizeof(rl->field_id)))) {
+			return TPM_OK;
+		}
+	}
+
+	/* did not find rule with same engine and priority
+	   increment hit counter				*/
+	rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC,
+					rl->engine,
+					eng_hit_cnt);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_rl_c4_validate
+*
+* DESCRIPTION: The routine validates C4 rule merge, searches for same priority rule
+*
+* INPUTS:
+*	rl - rule to insert information
+*	fl_rls - flow rules to check the new rule
+*
+* OUTPUTS:
+*	valid - returned validation indication
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_rl_c4_validate(struct tpm_cls_rl_entry_t	*rl,
+				struct tpm_cls_fl_t		*fl_rls,
+				bool				*valid)
+{
+	unsigned short	rl_i;
+
+	IF_NULL(TPM_CLS_MOD, rl)
+	IF_NULL(TPM_CLS_MOD, fl_rls)
+
+	/* scan the flow for an identical rule */
+	for (rl_i = 0; rl_i < fl_rls->fl_len; rl_i++) {
+		if ((fl_rls->fl[rl_i].engine	== TPM_ENGINE_C4) &&
+		    (fl_rls->fl[rl_i].prio	!= rl->prio)) {
+
+			TPM_OS_ERROR(TPM_CLS_MOD,
+				"add diff prio rule for C4 prohibited merged prio=%d new prio=%d fl_log_id=%d\n",
+				rl->prio,
+				fl_rls->fl[rl_i].prio,
+				fl_rls->fl_log_id);
+			*valid = false;
+			return TPM_OK;
+		}
+	}
+
+	*valid = true;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rls_merge
+*
+* DESCRIPTION: The routine merges two flows (cur and new) of the same logical flow ID
+*		into a merged flow, the routine gets the current flow from DB and
+*		sorts the new flow ascending according to rule priority.
+*		Then it eliminates from the new flow rules that exist in the current flow.
+*		It then merges the two flows into one according to HW limitations
+*		taking into account allocation and engine limitation.
+*
+* INPUTS:
+*	fl_log_id - merging flow logical rule ID
+*	cur_fl_rls - current flow rules
+*	new_fl_rls - new added flow rules
+*
+* OUTPUTS:
+*	mrg_fl_rls - merged flow rules
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rls_merge(unsigned short			fl_log_id,
+				struct tpm_cls_fl_t		*cur_fl_rls,
+				struct tpm_cls_fl_t		*new_fl_rls,
+				struct tpm_cls_fl_t		*mrg_fl_rls)
+{
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod_db;
+	unsigned short			rl;
+	int				rc;
+	unsigned short			cur_rl_cnt, new_rl_cnt;
+	unsigned short			rl_off;
+	unsigned short			rnd = 0;
+	struct tpm_cls_fl_eng_cnt_t	eng_hit_cnt;
+	bool				valid_c4;
+
+	IF_NULL(TPM_CLS_MOD, cur_fl_rls)
+	IF_NULL(TPM_CLS_MOD, new_fl_rls)
+	IF_NULL(TPM_CLS_MOD, mrg_fl_rls)
+
+	/* get the lookup DB for this logical flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl_log_id)
+
+	rl_off = lkp_dcod_db.flow_off;
+
+	memset(mrg_fl_rls, 0, sizeof(struct tpm_cls_fl_t));
+	memset(&eng_hit_cnt, 0, sizeof(eng_hit_cnt));
+
+	mrg_fl_rls->fl_log_id = fl_log_id;
+	cur_rl_cnt = cur_fl_rls->fl_len;
+	new_rl_cnt = new_fl_rls->fl_len;
+
+	/* max flow length check */
+	if (cur_rl_cnt + new_rl_cnt > TPM_CLS_FLOW_RULE_MAX) {
+		TPM_OS_ERROR(TPM_CLS_MOD, "cur_rl_cnt + new_rl_cnt too large [cur %d new %d]\n",
+			cur_rl_cnt, new_rl_cnt);
+		return TPM_NO_RESOURCE;
+	}
+
+	/* merge while loop */
+	while (cur_rl_cnt || new_rl_cnt) {
+		unsigned short		cur_rl = TPM_CLS_FLOW_RULE_MAX,
+					new_rl = TPM_CLS_FLOW_RULE_MAX;
+		bool			merge_new = false;
+
+#ifdef TPM_CLS_DEBUG
+		debug_dump_cls_fl("curr", cur_fl_rls);
+		debug_dump_cls_fl("new", new_fl_rls);
+#endif
+		/* update round number */
+		if (TPM_CLS_FL_RND_SIZE == eng_hit_cnt.c2 + eng_hit_cnt.c3 + eng_hit_cnt.c4)
+			rnd = 1;
+
+		cur_rl = TPM_CLS_FLOW_RULE_MAX;
+		new_rl = TPM_CLS_FLOW_RULE_MAX;
+
+		/* get first C4 rule from cur and new flows  */
+		if (new_fl_rls->eng_cnt.c4) {
+			for (rl = 0; rl < new_fl_rls->fl_len; rl++) {
+				if (!new_fl_rls->fl[rl].skip &&
+					(new_fl_rls->fl[rl].engine == TPM_ENGINE_C4)) {
+					break;
+				}
+			}
+			if (rl == new_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD,
+					"eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, new_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a new c4 rule, save index */
+			new_rl = rl;
+		}
+
+		if (cur_fl_rls->eng_cnt.c4) {
+			for (rl = 0; rl < cur_fl_rls->fl_len; rl++) {
+				if (!cur_fl_rls->fl[rl].skip &&
+					(cur_fl_rls->fl[rl].engine == TPM_ENGINE_C4)) {
+					break;
+				}
+			}
+			if (rl == cur_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD,
+					"eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, cur_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a current c4 rule, save index */
+			cur_rl = rl;
+		}
+
+		/* no C4 rules, proceed with C3 */
+		if (0 == new_fl_rls->eng_cnt.c4 &&
+		    0 == cur_fl_rls->eng_cnt.c4)
+			goto c3_ins;
+
+		/* decide which rule to merge according to rule priority */
+		if (cur_rl != TPM_CLS_FLOW_RULE_MAX)
+			merge_new = false;
+		else if (new_rl != TPM_CLS_FLOW_RULE_MAX)
+			merge_new = true;
+
+		/* perform merge validation */
+
+		/* max engine hits validation */
+		if (TPM_CLS_FL_RND_SIZE * TPM_CLS_FLOW_RND_MAX == (eng_hit_cnt.c2 + eng_hit_cnt.c3 + eng_hit_cnt.c4)) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "max CLS entries, failed to add\n");
+			return TPM_NO_RESOURCE;
+		}
+
+		/* max allocated flow length validation */
+		if (mrg_fl_rls->fl_len == lkp_dcod_db.flow_alloc_len) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "flow alloc length reached alloc_len=%d merge_fl_len=%d\n",
+					lkp_dcod_db.flow_alloc_len, mrg_fl_rls->fl_len);
+			return TPM_NO_RESOURCE;
+		}
+
+		/* perform single priority C4 validation */
+		if (true == merge_new)
+			rc = tpm_cls_rl_c4_validate(&new_fl_rls->fl[new_rl],
+							mrg_fl_rls,
+							&valid_c4);
+		else
+			rc = tpm_cls_rl_c4_validate(&cur_fl_rls->fl[cur_rl],
+							mrg_fl_rls,
+							&valid_c4);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		if (false == valid_c4)
+			return TPM_NO_RESOURCE;
+
+		/* validation done, update engine counters */
+		if (true == merge_new)
+			rc = tpm_cls_rl_hit_cnt_upd(&new_fl_rls->fl[new_rl],
+							mrg_fl_rls,
+							&eng_hit_cnt);
+		else
+			rc = tpm_cls_rl_hit_cnt_upd(&cur_fl_rls->fl[cur_rl],
+							mrg_fl_rls,
+							&eng_hit_cnt);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* merge the new rule */
+		if (true == merge_new) {
+			new_fl_rls->fl[new_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(new_rl, new_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge new C4 rule offset=%d fl_log_id=%d",
+					rl_off, new_fl_rls->fl_log_id)
+
+			/* update new rule count */
+			new_rl_cnt--;
+		} else {
+			cur_fl_rls->fl[cur_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(cur_rl, cur_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge cur C4 rule offset=%d fl_log_id=%d",
+					rl_off, cur_fl_rls->fl_log_id)
+
+			/* update current rule count */
+			cur_rl_cnt--;
+		}
+
+		rl_off++;
+		continue;
+
+c3_ins:
+		/* get first C3 rule */
+
+		/* no C3 rules, proceed with C2 */
+		if (0 == new_fl_rls->eng_cnt.c3 &&
+		    0 == cur_fl_rls->eng_cnt.c3)
+			goto c2_ins;
+
+		cur_rl = TPM_CLS_FLOW_RULE_MAX;
+		new_rl = TPM_CLS_FLOW_RULE_MAX;
+
+		/* get first C3 rule from cur and new flows  */
+		if (new_fl_rls->eng_cnt.c3) {
+			for (rl = 0; rl < new_fl_rls->fl_len; rl++) {
+				if (!new_fl_rls->fl[rl].skip &&
+				     (new_fl_rls->fl[rl].engine == TPM_ENGINE_C3_A
+				      || new_fl_rls->fl[rl].engine == TPM_ENGINE_C3_B)) {
+					break;
+				}
+			}
+			if (rl == new_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD, "eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, new_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a new c3 rule, save index */
+			new_rl = rl;
+		}
+
+		/* get first C3 rule */
+		if (cur_fl_rls->eng_cnt.c3) {
+			for (rl = 0; rl < cur_fl_rls->fl_len; rl++) {
+				if (!cur_fl_rls->fl[rl].skip &&
+				    (cur_fl_rls->fl[rl].engine == TPM_ENGINE_C3_A
+				     || cur_fl_rls->fl[rl].engine == TPM_ENGINE_C3_B)) {
+					break;
+				}
+			}
+			if (rl == cur_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD, "eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, cur_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a current c3 rule, save index */
+			cur_rl = rl;
+		}
+
+		/* no C3 rules, skip to C2 section */
+		if (cur_rl == TPM_CLS_FLOW_RULE_MAX &&
+		    new_rl == TPM_CLS_FLOW_RULE_MAX)
+			goto c2_ins;
+
+		/* decide which rule to merge according to rule priority */
+		if (cur_rl != TPM_CLS_FLOW_RULE_MAX &&
+		    new_rl != TPM_CLS_FLOW_RULE_MAX){
+			if (cur_fl_rls->fl[cur_rl].prio > new_fl_rls->fl[new_rl].prio)
+				merge_new = true;
+			else
+				merge_new = false;
+#if SAME_PRIO_ENABLED
+			else if (cur_fl_rls->fl[cur_rl].prio < new_fl_rls->fl[new_rl].prio)
+				merge_new = false;
+			else{
+				TPM_OS_ERROR(TPM_CLS_MOD, "add same prio rule prio=%d fl_log_id=%d rule #=%d\n",
+					cur_fl_rls->fl[cur_rl].prio,
+					cur_fl_rls->fl[cur_rl].rl_log_id,
+					cur_rl);
+				return TPM_FAIL;
+			}
+#endif
+		} else if (cur_rl != TPM_CLS_FLOW_RULE_MAX) {
+			merge_new = false;
+		} else if (new_rl != TPM_CLS_FLOW_RULE_MAX) {
+			merge_new = true;
+		}
+
+		/* perform merge validation */
+
+		/* round 0 full of C2 and there are some C2 to merge */
+		if (rnd == 0 && TPM_CLS_C3_RND_MAX == eng_hit_cnt.c3 &&
+		    (new_fl_rls->eng_cnt.c2 || cur_fl_rls->eng_cnt.c2)) {
+			goto c2_ins;
+		}
+
+		/* max C3 hits validation */
+		if (TPM_CLS_C3_RND_MAX * TPM_CLS_FLOW_RND_MAX < eng_hit_cnt.c3) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "max C3 entries, failed to add\n");
+			return TPM_NO_RESOURCE;
+		}
+
+		/* max engine hits validation */
+		if (TPM_CLS_FL_RND_SIZE * TPM_CLS_FLOW_RND_MAX < (eng_hit_cnt.c3 + eng_hit_cnt.c2)) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "max CLS entries, failed to add\n");
+			return TPM_NO_RESOURCE;
+		}
+
+		/* max allocated flow length validation */
+		if (mrg_fl_rls->fl_len == lkp_dcod_db.flow_alloc_len) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "flow alloc length reached alloc_len=%d merge_fl_len=%d\n",
+					lkp_dcod_db.flow_alloc_len, mrg_fl_rls->fl_len);
+			return TPM_NO_RESOURCE;
+		}
+
+		/* validation done, update engine counters */
+		if (true == merge_new) {
+			rc = tpm_cls_rl_hit_cnt_upd(&new_fl_rls->fl[new_rl],
+						    mrg_fl_rls,
+						    &eng_hit_cnt);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		} else {
+			rc = tpm_cls_rl_hit_cnt_upd(&cur_fl_rls->fl[cur_rl],
+						    mrg_fl_rls,
+						    &eng_hit_cnt);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		}
+
+		/* merge the new rule */
+		if (true == merge_new) {
+			new_fl_rls->fl[new_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(new_rl, new_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge new C3 rule offset=%d fl_log_id=%d",
+					rl_off, new_fl_rls->fl_log_id)
+
+			/* update new rule count */
+			new_rl_cnt--;
+		} else {
+			cur_fl_rls->fl[cur_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(cur_rl, cur_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge cur C3 rule offset=%d fl_log_id=%d",
+					rl_off, cur_fl_rls->fl_log_id)
+
+			/* update current rule count */
+			cur_rl_cnt--;
+		}
+
+		rl_off++;
+		continue;
+
+c2_ins:
+		/* no C2 in both flow list, skip */
+		if (0 == new_fl_rls->eng_cnt.c2 &&
+		    0 == cur_fl_rls->eng_cnt.c2)
+			continue;
+
+		cur_rl = TPM_CLS_FLOW_RULE_MAX;
+		new_rl = TPM_CLS_FLOW_RULE_MAX;
+
+		/* get first C2 rule from cur and new flows  */
+		if (new_fl_rls->eng_cnt.c2) {
+			for (rl = 0; rl < new_fl_rls->fl_len; rl++) {
+				if (!new_fl_rls->fl[rl].skip &&
+				    new_fl_rls->fl[rl].engine == TPM_ENGINE_C2) {
+					break;
+				}
+			}
+			if (rl == new_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD, "eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, new_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a new c2 rule, save index */
+			new_rl = rl;
+		}
+
+		/* get first C2 rule */
+		if (cur_fl_rls->eng_cnt.c2) {
+			for (rl = 0; rl < cur_fl_rls->fl_len; rl++) {
+				if (!cur_fl_rls->fl[rl].skip &&
+				    (cur_fl_rls->fl[rl].engine == TPM_ENGINE_C2)) {
+					break;
+				}
+			}
+			if (rl == cur_fl_rls->fl_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD, "eng count inconsistent new_rl=%d fl_len=%d\n",
+					rl, cur_fl_rls->fl_len);
+				return TPM_FAIL;
+			}
+			/* found a current c2 rule, save index */
+			cur_rl = rl;
+		}
+
+		if (cur_rl == TPM_CLS_FLOW_RULE_MAX &&
+		    new_rl == TPM_CLS_FLOW_RULE_MAX)
+			continue;
+
+		/* decide which rule to merge according to rule priority */
+		if (cur_rl != TPM_CLS_FLOW_RULE_MAX &&
+		    new_rl != TPM_CLS_FLOW_RULE_MAX){
+			if (cur_fl_rls->fl[cur_rl].prio > new_fl_rls->fl[new_rl].prio)
+				merge_new = true;
+			else
+				merge_new = false;
+#if SAME_PRIO_ENABLED
+			else if (cur_fl_rls->fl[cur_rl].prio < new_fl_rls->fl[new_rl].prio)
+				merge_new = false;
+			else{
+				TPM_OS_ERROR(TPM_CLS_MOD, "add same prio rule prio=%d fl_log_id=%d rule #=%d\n",
+					cur_fl_rls->fl[cur_rl].prio,
+					cur_fl_rls->fl[cur_rl].rl_log_id,
+					cur_rl);
+				return TPM_FAIL;
+			}
+#endif
+		} else if (cur_rl != TPM_CLS_FLOW_RULE_MAX) {
+			merge_new = false;
+		} else if (new_rl != TPM_CLS_FLOW_RULE_MAX) {
+			merge_new = true;
+		}
+
+		/* perform merge validation */
+
+		/* update round number */
+		if (rnd == 0 && TPM_CLS_C2_RND_MAX == eng_hit_cnt.c2)
+			rnd = 1;
+
+		/* max C2 hits validation */
+		if (TPM_CLS_C2_RND_MAX * TPM_CLS_FLOW_RND_MAX < eng_hit_cnt.c2) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "max C2 entries, failed to add\n");
+			return TPM_NO_RESOURCE;
+		}
+
+		/* max engine hits validation */
+		if (TPM_CLS_FL_RND_SIZE * TPM_CLS_FLOW_RND_MAX < (eng_hit_cnt.c2 + eng_hit_cnt.c3)) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "max CLS entries, failed to add\n");
+			return TPM_NO_RESOURCE;
+		}
+
+		/* max allocated flow length validation */
+		if (mrg_fl_rls->fl_len == lkp_dcod_db.flow_alloc_len) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "flow alloc length reached alloc_len=%d merge_fl_len=%d\n",
+					lkp_dcod_db.flow_alloc_len, mrg_fl_rls->fl_len);
+			return TPM_NO_RESOURCE;
+		}
+
+		/* validation done, update engine counters */
+		if (true == merge_new) {
+			rc = tpm_cls_rl_hit_cnt_upd(&new_fl_rls->fl[new_rl],
+						    mrg_fl_rls,
+						    &eng_hit_cnt);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		} else {
+			rc = tpm_cls_rl_hit_cnt_upd(&cur_fl_rls->fl[cur_rl],
+						    mrg_fl_rls,
+						    &eng_hit_cnt);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		}
+
+		/* merge the new rule */
+		if (true == merge_new) {
+			new_fl_rls->fl[new_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(new_rl, new_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge new C2 rule offset=%d fl_log_id=%d",
+					rl_off, new_fl_rls->fl_log_id)
+
+			/* update new rule count */
+			new_rl_cnt--;
+		} else {
+			cur_fl_rls->fl[cur_rl].rl_off = rl_off;
+			rc = tpm_cls_new_fl_rl_merge(cur_rl, cur_fl_rls,
+						mrg_fl_rls);
+
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to merge cur C2 rule offset=%d fl_log_id=%d",
+					rl_off, cur_fl_rls->fl_log_id)
+
+			/* update current rule count */
+			cur_rl_cnt--;
+		}
+		rl_off++;
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rl_db_set
+*
+* DESCRIPTION: The routine writes a flow rule to DB
+*
+* INPUTS:
+*	rl - the rule to enable information structure
+*	fl_log_id - flow logical ID for the rule
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rl_db_set(struct tpm_cls_rl_entry_t	*rl,
+				unsigned short			fl_log_id)
+{
+	struct tpm_db_cls_fl_rule_t	rl_db;
+	int				rc;
+	unsigned short			cur_rl_off;
+	int loop;
+
+	IF_NULL(TPM_CLS_MOD, rl)
+
+	memset(&rl_db, 0, sizeof(rl_db));
+
+	/* different handling for rule states */
+	switch (rl->state) {
+	case TPM_MRG_NEW:
+		/* new rule, assign logical rule id */
+		rc = tpm_db_cls_rl_off_free_set(rl->rl_off, &rl->rl_log_id);
+		IF_ERROR_STR(TPM_CLS_MOD, rc, "got error for rule offset %d", rl->rl_off)
+
+		/* save the new logical rule ID in DB */
+		rl_db.rl_log_id = rl->rl_log_id;
+		break;
+
+	case TPM_MRG_NEW_EXISTS:
+	case TPM_MRG_NOT_NEW:
+		/* this new entry exists */
+		rc = tpm_db_cls_rl_off_get(&cur_rl_off, rl->rl_log_id);
+		IF_ERROR_STR(TPM_CLS_MOD, rc, "could not get rl_log_id %d offset", rl->rl_log_id)
+
+		/* if logical rule offset changed, update new offset */
+		if (cur_rl_off != rl->rl_off) {
+			rc = tpm_db_cls_rl_off_set(rl->rl_off, rl->rl_log_id);
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "could not set rule offset %d for rl_log_id %d",
+				rl->rl_off, rl->rl_log_id)
+		}
+
+		/* this rule is not new, use the current ref_count */
+#ifndef CONFIG_MV_ETH_PP2_1
+		rl_db.ref_cnt = rl->ref_cnt;
+#else
+		memcpy(&rl_db.ref_cnt[0], &rl->ref_cnt[0], TPM_MAX_NUM_GMACS * sizeof(unsigned short));
+#endif
+		/* same rule logical id */
+		rl_db.rl_log_id = rl->rl_log_id;
+		break;
+
+	default:
+		 TPM_OS_ERROR(TPM_CLS_MOD, "Invalid rule state [rl->state=%d]\n", rl->state);
+		 return TPM_BAD_PARAM;
+	}
+
+	memcpy(rl_db.field_id, rl->field_id, sizeof(rl->field_id));
+
+	if (rl->state != TPM_MRG_NOT_NEW) {
+		/* update ref_count for new entries only */
+#ifndef CONFIG_MV_ETH_PP2_1
+		rl_db.ref_cnt = (rl->enabled) ? rl->ref_cnt + 1 : 0;
+#else
+		for (loop = 0; loop < TPM_MAX_NUM_GMACS; loop++) {
+			if ((1 << loop) & rl->port_bm)
+				rl_db.ref_cnt[loop] = (rl->enabled) ? rl->ref_cnt[loop] + 1 : 0;
+		}
+#endif
+	}
+
+	rl_db.enabled		= rl->enabled;
+	rl_db.engine		= rl->engine;
+	rl_db.field_id_cnt	= rl->field_id_cnt;
+	rl_db.lu_type		= rl->lu_type;
+	rl_db.port_bm		= rl->port_bm;
+	rl_db.port_type		= rl->port_type;
+	rl_db.prio		= rl->prio;
+
+	rc = tpm_db_cls_fl_rule_set(rl->rl_off, &rl_db);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rl_hw_set
+*
+* DESCRIPTION: The routine writes a flow rule to HW
+*
+* INPUTS:
+*	rl - the rule to enable information structure
+*	is_last - a flag indicating if he rule is last in flow
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rl_hw_set(struct tpm_cls_rl_entry_t	*rl,
+				bool				is_last)
+{
+	MV_PP2_CLS_FLOW_ENTRY	fe;
+	int			rc;
+	unsigned short		fid;
+
+	IF_NULL(TPM_CLS_MOD, rl)
+
+	mvPp2ClsSwFlowClear(&fe);
+
+	rc = mvPp2ClsSwFlowEngineSet(&fe, rl->engine, is_last);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* set the port_type and port_bm according to enable configuration */
+	if (rl->enabled)
+		rc = mvPp2ClsSwFlowPortSet(&fe, rl->port_type, rl->port_bm);
+	else
+		rc = mvPp2ClsSwFlowPortSet(&fe, 0, 0);
+
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsSwFlowExtraSet(&fe, rl->lu_type, rl->prio);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsSwFlowHekNumSet(&fe, rl->field_id_cnt);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Set Port ID Select, selects the value of the Port ID forwareded to the C2, C3 engines*/
+	rc = mvPp2ClsSwPortIdSelect(&fe, TPM_CLS_PORT_ID_FROM_PKT);
+	IF_ERROR(TPM_CLS_MOD, rc)
+#endif
+
+	for (fid = 0; fid < rl->field_id_cnt; fid++) {
+		rc = mvPp2ClsSwFlowHekSet(&fe, fid, rl->field_id[fid]);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+	rc = mvPp2ClsHwFlowWrite(rl->rl_off, &fe);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rl_hw_ena
+*
+* DESCRIPTION: The routine enables a flow rule in HW according to rule port_type
+*		and port_bm
+*
+* INPUTS:
+*	rl_en - the rule to enable information structure
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rl_hw_ena(struct tpm_cls_fl_rule_entry_t	*rl_en)
+{
+	MV_PP2_CLS_FLOW_ENTRY	fe;
+	int			rc;
+	unsigned short		off;
+
+	IF_NULL(TPM_CLS_MOD, rl_en)
+
+	/* get the rule offset according to rule logical ID */
+	rc = tpm_db_cls_rl_off_get(&off, rl_en->rl_log_id);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsHwFlowRead(off, &fe);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* enable the rule according to DB settings */
+	rc = mvPp2ClsSwFlowPortSet(&fe, rl_en->port_type, rl_en->port_bm);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsHwFlowWrite(off, &fe);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rl_hw_dis
+*
+* DESCRIPTION: The routine disables a flow rule in HW, sets the port_type and
+*		port_bm to zero
+*
+* INPUTS:
+*	off - the offset of the rule
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rl_hw_dis(unsigned short		off)
+{
+	MV_PP2_CLS_FLOW_ENTRY	fe;
+	int			rc;
+
+	rc = mvPp2ClsHwFlowRead(off, &fe);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsSwFlowPortSet(&fe, 0, 0);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	rc = mvPp2ClsHwFlowWrite(off, &fe);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rls_set
+*
+* DESCRIPTION: The routine sets the merged flow to HW and updated DBs
+*
+* INPUTS:
+*	fl_rls - a list of merged rules of a single logical flow ID to set
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rls_set(struct tpm_cls_fl_t	*fl_rls)
+{
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod_db;
+	int				rc, free_db_cnt;
+	unsigned short			rl_idx;
+	bool				is_last;
+	unsigned short			new_rl_cnt = 0;
+	struct tpm_cls_rl_entry_t	*rl;
+
+	IF_NULL(TPM_CLS_MOD, fl_rls)
+
+	/* get the lookup DB for this logical flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(fl_rls->fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl_rls->fl_log_id)
+
+	/* count all new rules */
+	for (rl_idx = 0; rl_idx < fl_rls->fl_len; rl_idx++) {
+		rl = &fl_rls->fl[rl_idx];
+		if (TPM_CLS_UNDF_FL_LOG_ID == rl->rl_log_id)
+			new_rl_cnt++;
+	}
+
+	/* validate enough DB entries for new rules */
+	if (new_rl_cnt) {
+		rc = tpm_db_cls_rl_off_free_nr(&free_db_cnt);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		if (free_db_cnt < new_rl_cnt) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "not enough free rule DB[free_db_cnt=%d new_rl_cnt=%d]\n",
+				free_db_cnt, new_rl_cnt);
+			return TPM_NO_RESOURCE;
+		}
+	}
+
+	/* set the flow rules */
+	for (rl_idx = 0; rl_idx < fl_rls->fl_len; rl_idx++) {
+		rl = &fl_rls->fl[rl_idx];
+		is_last = (rl_idx == fl_rls->fl_len-1) ? true : false;
+
+		/* write rule to HW */
+		rc = tpm_cls_fl_rl_hw_set(rl, is_last);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+
+	/* set the lookup decode table */
+	rc = tpm_cls_lkp_dcod_hw_set(fl_rls);
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+	/* update DB for rules and lookup decode */
+	for (rl_idx = 0; rl_idx < fl_rls->fl_len; rl_idx++) {
+		rl = &fl_rls->fl[rl_idx];
+
+		/* write rule to DB */
+		rc = tpm_cls_fl_rl_db_set(rl, fl_rls->fl_log_id);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+
+	/* update flow actual length */
+	lkp_dcod_db.flow_len = fl_rls->fl_len;
+	rc = tpm_db_cls_lkp_dcod_set(fl_rls->fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to set lookup decode info for fl_log_id %d", fl_rls->fl_log_id)
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_cur_get
+*
+* DESCRIPTION: The routine returns the current flow rules for the flow logical ID
+*
+* INPUTS:
+*	fl_log_id - the flow logical ID
+*	cur_fl	  - flow structure that holds all flows and additional information
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_cur_get(unsigned short		fl_log_id,
+				struct tpm_cls_fl_t	*cur_fl)
+{
+	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
+	int					rc;
+	unsigned short				i;
+
+	IF_NULL(TPM_CLS_MOD, cur_fl)
+
+	/* get the lookup DB for this logical flow ID */
+	rc = tpm_db_cls_lkp_dcod_get(fl_log_id, &lkp_dcod_db);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl_log_id)
+
+#ifdef TPM_CLS_DEBUG
+	debug_dump_lkp_dcod_db("tpm_cls_fl_cur_get", &lkp_dcod_db);
+#endif
+
+	memset(cur_fl, 0, sizeof(struct tpm_cls_fl_t));
+	memset(&fl_rl_db, 0, sizeof(fl_rl_db));
+
+	/* update DB flow length */
+	fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+	cur_fl->fl_log_id = fl_log_id;
+
+	if (lkp_dcod_db.flow_len == 0)
+		return TPM_OK;
+
+	rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+				fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+
+	/* set the current flow additional configurations */
+	cur_fl->fl_len = fl_rl_db.flow_len;
+
+	for (i = 0; i < fl_rl_db.flow_len; i++) {
+		cur_fl->fl[i].enabled	= fl_rl_db.flow[i].enabled;
+		cur_fl->fl[i].engine	= fl_rl_db.flow[i].engine;
+		cur_fl->fl[i].field_id_cnt = fl_rl_db.flow[i].field_id_cnt;
+
+		memcpy(cur_fl->fl[i].field_id,
+			fl_rl_db.flow[i].field_id,
+			sizeof(cur_fl->fl[i].field_id));
+
+		cur_fl->fl[i].rl_off	= lkp_dcod_db.flow_off + i;
+		cur_fl->fl[i].lu_type	= fl_rl_db.flow[i].lu_type;
+		cur_fl->fl[i].port_bm	= fl_rl_db.flow[i].port_bm;
+		cur_fl->fl[i].port_type = fl_rl_db.flow[i].port_type;
+		cur_fl->fl[i].prio	= fl_rl_db.flow[i].prio;
+#ifndef CONFIG_MV_ETH_PP2_1
+		cur_fl->fl[i].ref_cnt	= fl_rl_db.flow[i].ref_cnt;
+#else
+		memcpy(&cur_fl->fl[i].ref_cnt[0],
+			&fl_rl_db.flow[i].ref_cnt[0],
+			TPM_MAX_NUM_GMACS * sizeof(unsigned short));
+#endif
+		cur_fl->fl[i].rl_log_id = fl_rl_db.flow[i].rl_log_id;
+		cur_fl->fl[i].state	= TPM_MRG_NOT_NEW;
+		cur_fl->fl[i].skip	= 0;
+
+		rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC, fl_rl_db.flow[i].engine, &cur_fl->eng_cnt);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rls_log_rl_id_upd
+*
+* DESCRIPTION: The routine update the rl_log_id in the added rule list from
+*		the merged logical flow rules
+*
+* INPUTS:
+*	add_rls - the added rule list
+*	mrg_rls - the merged flow rules
+*
+* OUTPUTS:
+*	fl_rls->fl[].rl_log_id - allocated rule logical ID
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+static int tpm_cls_fl_rls_log_rl_id_upd(struct tpm_cls_fl_rule_list_t	*add_rls,
+					struct tpm_cls_fl_t		*mrg_rls)
+{
+	unsigned short		i, j;
+
+	IF_NULL(TPM_CLS_MOD, add_rls)
+	IF_NULL(TPM_CLS_MOD, mrg_rls)
+
+	for (i = 0; i < add_rls->fl_len; i++) {
+		if (add_rls->fl[i].fl_log_id != mrg_rls->fl_log_id)
+			continue;
+
+		for (j = 0; j < mrg_rls->fl_len; j++) {
+			if (add_rls->fl[i].engine	== mrg_rls->fl[j].engine	&&
+			    add_rls->fl[i].field_id_cnt == mrg_rls->fl[j].field_id_cnt	&&
+			    add_rls->fl[i].lu_type	== mrg_rls->fl[j].lu_type	&&
+			    add_rls->fl[i].port_bm	== mrg_rls->fl[j].port_bm	&&
+			    add_rls->fl[i].port_type	== mrg_rls->fl[j].port_type	&&
+			    add_rls->fl[i].prio	== mrg_rls->fl[j].prio		&&
+			    !memcmp(add_rls->fl[i].field_id, mrg_rls->fl[j].field_id,
+					   sizeof(add_rls->fl[i].field_id))) {
+				/* found the added rule, update logial rule ID */
+				add_rls->fl[i].rl_log_id = mrg_rls->fl[j].rl_log_id;
+				break;
+			}
+		}
+		if (j == mrg_rls->fl_len) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "new rule #%d not found in merged flow\n", i);
+			return TPM_BAD_PARAM;
+		}
+	}
+
+	return TPM_OK;
+}
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* tpm_cls_rx_qh_init()
+*
+* DESCRIPTION: The routine init the RX queue high to CPU.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Only valid in PP21
+*******************************************************************************/
+static int tpm_cls_rx_qh_init(void)
+{
+	int rc;
+
+	/* Set queue high of different port, GMAC0, GMAC1, and PON */
+	rc = mvPp2ClsHwRxQueueHighSet(TPM_ENUM_GMAC_0, TPM_RX_QH_FROM_REG, TPM_GMAC0_RX_QH);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "Fail to set queue high for GMAC0");
+
+	rc = mvPp2ClsHwRxQueueHighSet(TPM_ENUM_GMAC_1, TPM_RX_QH_FROM_REG, TPM_GMAC1_RX_QH);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "Fail to set queue high for GMAC1");
+
+	rc = mvPp2ClsHwRxQueueHighSet(TPM_ENUM_PMAC, TPM_RX_QH_FROM_REG, TPM_PMAC_RX_QH);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "Fail to set queue high for PMAC");
+
+	return TPM_OK;
+}
+#endif
+
+/*******************************************************************************
+* tpm_cls_fl_rule_add
+*
+* DESCRIPTION: The API adds all rules according to flow rule array
+*
+* INPUTS:
+*	fl_rls - a list of rules to enable
+*
+* OUTPUTS:
+*	fl_rls->fl[].rl_log_id - allocated rule logical ID
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	The routine is NON REENTRANT since it has static variables, to fix this
+*	need to add a memory allocation mechanisem
+*******************************************************************************/
+int tpm_cls_fl_rule_add(struct tpm_cls_fl_rule_list_t *fl_rls)
+{
+	unsigned short			i;
+	int				rc;
+	static struct tpm_cls_fl_t	new_fl;
+	static struct tpm_cls_fl_t	merge_fl;
+	static struct tpm_cls_fl_t	cur_fl;
+	bool				rule_found;
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod_db;
+	unsigned short			fl_log_id;
+	struct tpm_cls_fl_rule_entry_t	*fl_rl;
+	struct tpm_cls_rl_entry_t	*fl;
+
+	IF_NULL(TPM_CLS_MOD, fl_rls)
+
+	/* populate all current flows from DB for flow_log_id */
+	for (fl_log_id = 0; fl_log_id < TPM_MNG_FLOW_ID_MAX; fl_log_id++) {
+		memset(&cur_fl, 0, sizeof(cur_fl));
+
+		/* get current flow_log_id rules */
+		rc = tpm_cls_fl_cur_get(fl_log_id, &cur_fl);
+		if (rc != TPM_OK) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "tpm_db_cls_lkp_dcod_get returned error\n");
+			return TPM_FAIL;
+		}
+
+		memset(&new_fl, 0, sizeof(new_fl));
+
+		new_fl.fl_log_id = fl_log_id;
+		new_fl.fl_len = 0;
+
+		/* inset all new flow rules to logical flow based table */
+		for (i = 0; i < fl_rls->fl_len; i++) {
+			rule_found = false;
+			fl_rl = &fl_rls->fl[i];
+
+			/* handle only the current logical flow ID */
+			if (fl_log_id != fl_rl->fl_log_id)
+				continue;
+
+			/* get the lookup DB for this logical flow ID */
+			rc = tpm_db_cls_lkp_dcod_get(fl_log_id, &lkp_dcod_db);
+			IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d", fl_log_id)
+
+			/* logical flow not initialized */
+			if (0 == lkp_dcod_db.flow_alloc_len) {
+				TPM_OS_ERROR(TPM_CLS_MOD, "fl_log_id %d new rule #%d was not initialized\n",
+					fl_log_id, i);
+				return TPM_FAIL;
+			}
+
+			fl = &new_fl.fl[new_fl.fl_len];
+
+			if (false == fl_rl->enabled) {
+				fl_rl->port_type = TPM_PORT_TYPE_INV;
+				fl_rl->port_bm = TPM_PORT_BM_INV;
+			}
+
+			/* copy the data to new entry */
+			fl->enabled	= fl_rl->enabled;
+			fl->engine	= fl_rl->engine;
+			fl->field_id_cnt = fl_rl->field_id_cnt;
+			fl->lu_type	= fl_rl->lu_type;
+			fl->port_bm	= fl_rl->port_bm;
+			fl->port_type	= fl_rl->port_type;
+			fl->prio	= fl_rl->prio;
+#ifndef CONFIG_MV_ETH_PP2_1
+			fl->ref_cnt	= 0;
+#else
+			TPM_MEMSET_ZERO(fl->ref_cnt);
+#endif
+			fl->rl_log_id	= TPM_CLS_UNDF_FL_LOG_ID;
+			fl->rl_off	= lkp_dcod_db.flow_off + i;
+			fl->skip	= 0;
+			fl->state	= TPM_MRG_NEW;
+			memcpy(fl->field_id,
+				fl_rl->field_id,
+				sizeof(fl_rl->field_id));
+#if SAME_PRIO_ENABLED
+			/* code snippet is disabled since currently rules addition does
+			   does not include valid port_type and port_bm and there is no
+			   way to differentiate two rules with same priority		*/
+
+			/* search for the rule within the current flow rules */
+			for (j = 0; j < cur_fl.fl_len; j++) {
+				if (cur_fl.fl[j].engine	== fl_rl->engine	&&
+				    cur_fl.fl[j].field_id_cnt	== fl_rl->field_id_cnt	&&
+				    cur_fl.fl[j].lu_type	== fl_rl->lu_type	&&
+				    cur_fl.fl[j].prio		== fl_rl->prio		&&
+				    !memcmp(cur_fl.fl[j].field_id,
+					    fl_rl->field_id,
+					    sizeof(fl_rl->field_id))) {
+					/* identical rule found */
+					rule_found = true;
+
+					/* update the logical rule id */
+					fl_rl->rl_log_id = cur_fl.fl[j].rl_log_id;
+
+					cur_fl.fl[j].state = TPM_MRG_NEW_EXISTS;
+					break;
+				}
+			}
+
+			/* rule already exist in the current flow */
+			if (rule_found)
+				continue;
+#endif
+			/* increment the engine count per flow log id */
+			rc = tpm_cls_fl_rl_eng_cnt_upd(TPM_CNT_INC, fl_rl->engine,
+							&new_fl.eng_cnt);
+			IF_ERROR(TPM_CLS_MOD, rc)
+
+			new_fl.fl_len++;
+		}
+
+		/* did we find new rules for the logical flow ID? */
+		if (new_fl.fl_len == 0)
+			continue;
+
+		/* merge the current and new flow rules together */
+
+		/* sort the new flow according to prio */
+		if (new_fl.fl_len > 1)
+			sort(new_fl.fl, new_fl.fl_len,
+				sizeof(struct tpm_cls_rl_entry_t), cmp_prio, NULL);
+
+		/* merge the two flows (new & curr) */
+		rc = tpm_cls_fl_rls_merge(fl_log_id, &cur_fl, &new_fl, &merge_fl);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* set the rules in DB and HW */
+		rc = tpm_cls_fl_rls_set(&merge_fl);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* update logical rule ID in caller structure */
+		rc = tpm_cls_fl_rls_log_rl_id_upd(fl_rls, &merge_fl);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rule_enable
+*
+* DESCRIPTION: The API enables all rules according to flow rule array
+*
+* INPUTS:
+*	fl_rls - a list of rules to enable
+*
+* OUTPUTS:
+*	fl_rls->fl[].rl_log_id - rule logical ID according to matching rule in DB
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_cls_fl_rule_enable(struct tpm_cls_fl_rule_list_t *fl_rls)
+{
+	unsigned short				rl_off, i;
+	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
+	struct tpm_db_cls_fl_rule_list_t	fl_rl_db;
+	struct tpm_cls_fl_rule_entry_t		*rl_en;
+	struct tpm_db_cls_fl_rule_t		*rl_db = NULL;
+	int					rc;
+	int loop;
+	unsigned short port_bm = 0;
+
+	IF_NULL(TPM_CLS_MOD, fl_rls)
+
+	/* iterate over all rule list */
+	for (i = 0; i < fl_rls->fl_len; i++) {
+		/* get the lookup DB for this logical flow ID */
+		rc = tpm_db_cls_lkp_dcod_get(fl_rls->fl[i].fl_log_id, &lkp_dcod_db);
+		IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get lookup decode info for fl_log_id %d",
+				fl_rls->fl[i].fl_log_id)
+
+		/* get all rules for this logical flow ID */
+		rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, &fl_rl_db.flow[0]);
+		IF_ERROR_STR(TPM_CLS_MOD, rc, "failed to get flow rule list fl_log_id=%d flow_off=%d flow_len=%d",
+				fl_rls->fl[i].fl_log_id, lkp_dcod_db.flow_off, lkp_dcod_db.flow_len)
+
+		/* set the flow length in the DB entry */
+		fl_rl_db.flow_len = lkp_dcod_db.flow_len;
+
+		rl_en = &fl_rls->fl[i];
+
+		/* search for enabled rule (valid port_type and port_bm) to enable */
+		for (rl_off = 0; rl_off < fl_rl_db.flow_len; rl_off++) {
+			rl_db = &fl_rl_db.flow[rl_off];
+
+			if (rl_en->engine		== rl_db->engine	&&
+				rl_en->field_id_cnt	== rl_db->field_id_cnt  &&
+				rl_en->lu_type		== rl_db->lu_type	&&
+				rl_en->port_type	== rl_db->port_type	&&
+				rl_en->prio		== rl_db->prio		&&
+				!memcmp(rl_en->field_id, rl_db->field_id,
+					rl_en->field_id_cnt * sizeof(rl_en->field_id[0]))) {
+				/* for virt port, port_id does not matter */
+				if (rl_en->port_type == TPM_CLASS_VIRT_PORT)
+					break;
+#ifndef CONFIG_MV_ETH_PP2_1
+				else if (rl_en->port_bm	== rl_db->port_bm)
+					break;
+#else
+				else {
+					rl_db->port_bm |= rl_en->port_bm;
+					port_bm = rl_en->port_bm;
+					if (true == rl_db->enabled) {
+						rl_en->port_bm = rl_db->port_bm;
+						/* Update Port BM */
+						rl_en->rl_log_id = rl_db->rl_log_id;
+						rc = tpm_cls_fl_rl_hw_ena(rl_en);
+						IF_ERROR(TPM_CLS_MOD, rc)
+					}
+					break;
+				}
+#endif
+			}
+		}
+
+		if (rl_off == fl_rl_db.flow_len) {
+			/* did not find identical rule, search for first rule with
+			   invalid port_type and port_bm				*/
+			for (rl_off = 0; rl_off < fl_rl_db.flow_len; rl_off++) {
+				rl_db = &fl_rl_db.flow[rl_off];
+				if (rl_en->engine	== rl_db->engine	&&
+				    rl_en->field_id_cnt == rl_db->field_id_cnt	&&
+				    rl_en->lu_type	== rl_db->lu_type	&&
+				    TPM_PORT_BM_INV	== rl_db->port_bm	&&
+				    TPM_PORT_TYPE_INV	== rl_db->port_type	&&
+				    rl_en->prio	== rl_db->prio		&&
+				    !memcmp(rl_en->field_id, rl_db->field_id, rl_en->field_id_cnt * sizeof(char))) {
+					/* found a vacant rule entry that was invalid, update
+					   port_type and port_bm				*/
+					rl_db->port_bm = rl_en->port_bm;
+					rl_db->port_type = rl_en->port_type;
+					port_bm = rl_en->port_bm;
+					break;
+				}
+			}
+		}
+
+		/* verify that we found a rule */
+		if (rl_off == fl_rl_db.flow_len) {
+			TPM_OS_ERROR(TPM_CLS_MOD, "failed to find flow rule #%d to enable\n", i);
+			TPM_OS_ERROR(TPM_CLS_MOD, "fl_id(%d),port_type(%d),port_bm(%d),",
+				fl_rls->fl[i].fl_log_id, fl_rls->fl[i].port_type, fl_rls->fl[i].port_bm);
+			TPM_OS_ERROR(TPM_CLS_MOD, "prio(%d),lu_type(%d),engine(%d),field_id_cnt(%d)",
+				fl_rls->fl[i].prio, fl_rls->fl[i].lu_type, fl_rls->fl[i].engine,
+				fl_rls->fl[i].field_id_cnt);
+			TPM_OS_ERROR(TPM_CLS_MOD, "field_id_0(%x), field_id_1(%x),field_id_2(%x),field_id_3(%x)\n",
+				fl_rls->fl[i].field_id[0], fl_rls->fl[i].field_id[1], fl_rls->fl[i].field_id[2],
+				fl_rls->fl[i].field_id[3]);
+			return TPM_FAIL;
+		}
+
+		/* update the logical rule id */
+		rl_en->rl_log_id = rl_db->rl_log_id;
+
+		/* found the rule we searched for */
+		if (false == rl_db->enabled) {
+#ifndef CONFIG_MV_ETH_PP2_1
+			rl_db->ref_cnt = 0;
+#else
+			TPM_MEMSET_ZERO(rl_db->ref_cnt);
+#endif
+			rl_db->enabled = true;
+
+			/* rule disabled, enable the HW */
+			rc = tpm_cls_fl_rl_hw_ena(rl_en);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		}
+
+		/* increment the reference counter */
+#ifndef CONFIG_MV_ETH_PP2_1
+		rl_db->ref_cnt++;
+#else
+		for (loop = 0; loop < TPM_MAX_NUM_GMACS; loop++) {
+			if (1 << loop & port_bm)
+				rl_db->ref_cnt[loop]++;
+		}
+#endif
+
+		TPM_OS_DEBUG(TPM_CLS_MOD, "enable: fl_log_id[%d] rl_log_id[%d] rl_off[%d] port_type[%d] port_bm[%d]",
+				fl_rls->fl[i].fl_log_id, rl_en->rl_log_id, rl_off,
+				fl_rls->fl[i].port_type, fl_rls->fl[i].port_bm);
+		TPM_OS_DEBUG(TPM_CLS_MOD, " prio[%d] lu_type[%d] engine[%d] field_id_cnt[%d]\n",
+				fl_rls->fl[i].prio, fl_rls->fl[i].lu_type, fl_rls->fl[i].engine,
+				fl_rls->fl[i].field_id_cnt);
+
+		/* update the DB */
+		rc = tpm_db_cls_fl_rule_set(lkp_dcod_db.flow_off + rl_off, rl_db);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+
+	 return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_fl_rule_disable
+*
+* DESCRIPTION: The API disables all rules according to logical rule ID array
+*
+* INPUTS:
+*	rl_log_id - a list of the logical rule id
+*	rl_log_id_len - rl_log_id length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_cls_fl_rule_disable(unsigned short		*rl_log_id,
+				unsigned short		rl_log_id_len,
+				struct tpm_class_port_t	*src_port)
+{
+	unsigned short			rl_off, i;
+	struct tpm_db_cls_fl_rule_t	rl_db;
+	int				rc;
+	unsigned short			ref_sum = 0;
+	int				loop;
+	struct tpm_cls_fl_rule_entry_t	rl_en;
+	unsigned int port_id = 0;
+
+	IF_NULL(TPM_CLS_MOD, rl_log_id)
+	IF_NULL(TPM_CLS_MOD, src_port)
+	TPM_MEMSET_ZERO(rl_en);
+
+	/* iterate all logical rule IDs */
+	for (i = 0; i < rl_log_id_len; i++) {
+		/* get the offset for the rl_log_id */
+		rc = tpm_db_cls_rl_off_get(&rl_off, rl_log_id[i]);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* get the rule DB entry for the offset */
+		rc = tpm_db_cls_fl_rule_get(rl_off, &rl_db);
+		IF_ERROR(TPM_CLS_MOD, rc)
+
+		/* rule already disabled, skip */
+		if (false == rl_db.enabled)
+			TPM_OS_WARN(TPM_CLS_MOD, "rl_log_id=%d already disabled\n", rl_log_id[i]);
+
+		/* last reference count, need to disable in HW */
+#ifndef CONFIG_MV_ETH_PP2_1
+		if (1 == rl_db.ref_cnt) {
+			rc = tpm_cls_fl_rl_hw_dis(rl_off);
+			IF_ERROR(TPM_CLS_MOD, rc)
+
+			rl_db.enabled = false;
+			rl_db.port_type = TPM_PORT_TYPE_INV;
+			rl_db.port_bm = TPM_PORT_BM_INV;
+		}
+
+		/* update reference count */
+		rl_db.ref_cnt--;
+#else
+		ref_sum = 0;
+		for (loop = 0; loop < TPM_MAX_NUM_GMACS; loop++)
+			ref_sum += rl_db.ref_cnt[loop];
+		if (1 == ref_sum) {
+			rc = tpm_cls_fl_rl_hw_dis(rl_off);
+			IF_ERROR(TPM_CLS_MOD, rc)
+
+			rl_db.enabled = false;
+			rl_db.port_type = TPM_PORT_TYPE_INV;
+			rl_db.port_bm = TPM_PORT_BM_INV;
+		}
+
+		/* update port_bm */
+		for (loop = 0; loop < TPM_MAX_NUM_GMACS; loop++) {
+			if ((1 << loop) & src_port->class_port) {
+				port_id = loop;
+				break;
+			}
+		}
+
+		if (ref_sum > 1 && rl_db.ref_cnt[port_id] == 1) {
+			rl_db.port_bm &= ~(1 << port_id);
+			rl_en.enabled = rl_db.enabled;
+			rl_en.engine = rl_db.engine;
+			memcpy(rl_en.field_id, rl_db.field_id, TPM_FLOW_FIELD_COUNT_MAX * sizeof(unsigned char));
+			rl_en.field_id_cnt = rl_db.field_id_cnt;
+			rl_en.lu_type = rl_db.lu_type;
+			rl_en.port_bm = rl_db.port_bm;
+			rl_en.port_type = rl_db.port_type;
+			rl_en.prio = rl_db.prio;
+			rl_en.rl_log_id = rl_db.rl_log_id;
+			rc = tpm_cls_fl_rl_hw_ena(&rl_en);
+			IF_ERROR(TPM_CLS_MOD, rc)
+		}
+		rl_db.ref_cnt[port_id]--;
+#endif
+		TPM_OS_DEBUG(TPM_CLS_MOD, "disable: rl_off[%d] rl_log_id[%d] port_type[%d] port_bm[%d] prio[%d]",
+				rl_off, rl_db.rl_log_id, rl_db.port_type, rl_db.port_bm, rl_db.prio);
+		TPM_OS_DEBUG(TPM_CLS_MOD, " lu_type[%d] engine[%d] field_id_cnt[%d]\n",
+				rl_db.lu_type, rl_db.engine, rl_db.field_id_cnt);
+
+		/* update rule entry in DB */
+		rc = tpm_db_cls_fl_rule_set(rl_off, &rl_db);
+		IF_ERROR(TPM_CLS_MOD, rc)
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_cls_pon_port_default_dcod_init
+*
+* DESCRIPTION: Create decode table entry for default luid of PON port
+*	WAY value of PON is 1, but in LSP code, default luid of PON port is configured
+*	with way value 0, which makes packets of default luid that ingress from PON port
+*	goes to CPU from eth0 interface.
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURN:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_cls_pon_port_default_dcod_init(void)
+{
+	int	rc;
+	MV_PP2_CLS_LKP_ENTRY  decode_entry;
+
+	/* get the decode table entry for default luid of PON port from HW,
+	  * and rewrite it with the right WAY value.
+	  */
+	rc = mvPp2ClsHwLkpRead(FLOWID_DEF(TPM_ENUM_PMAC), TPM_WAY_NON_PON, &decode_entry);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "get decode table entry of PON port default luid failed\n");
+
+	rc = mvPp2ClsHwLkpWrite(FLOWID_DEF(TPM_ENUM_PMAC), TPM_WAY_PON, &decode_entry);
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "set decode table entry of PON port default luid failed\n");
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_cls_init
+*
+* DESCRIPTION: The API will clean all the HW entries in CLS flow and lookup decode tables
+*		and also initialize the CLS DB to default
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURN:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+int tpm_cls_init(void)
+{
+	int	rc;
+
+	rc = tpm_cls_lkp_dcod_hw_clear_all();
+	IF_ERROR(TPM_CLS_MOD, rc)
+
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Init Port Rx queue high */
+	rc = tpm_cls_rx_qh_init();
+	IF_ERROR(TPM_CLS_MOD, rc)
+#endif
+
+	mvPp2ClsHwFlowClearAll();
+
+	/* Create decode table entry for default luid of PON port */
+	rc = tpm_cls_pon_port_default_dcod_init();
+	IF_ERROR_STR(TPM_CLS_MOD, rc, "Create decode table entry for default luid of PON port failed\n");
+
+	tpm_db_cls_init();
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_common.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_common.c
new file mode 100644
index 0000000..b575da5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_common.c
@@ -0,0 +1,472 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_common.c						     **
+**									     **
+**  DESCRIPTION : This file contains routines shared by tpm sub-modukles     **
+**  DEPENDCY : None							     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* Field size array */
+static unsigned int tpm_field_size_array[CLS_FIELD_MAX] = {
+	MH_FIELD_SIZE,
+	GEM_PORT_ID_FIELD_SIZE,
+	MH_UNTAGGED_PRI_FIELD_SIZE,
+	MAC_DA_FIELD_SIZE,
+	MAC_SA_FIELD_SIZE,
+	OUT_VLAN_PRI_FIELD_SIZE,
+	OUT_VLAN_ID_FIELD_SIZE,
+	IN_VLAN_ID_FIELD_SIZE,
+	ETH_TYPE_FIELD_SIZE,
+	PPPOE_FIELD_SIZE,
+	IP_VER_FIELD_SIZE,
+	IPV4_DSCP_FIELD_SIZE,
+	IPV4_ECN_FIELD_SIZE,
+	IPV4_LEN_FIELD_SIZE,
+	IPV4_TTL_FIELD_SIZE,/*IPV6_HL_FIELD_SIZE*/
+	IPV4_PROTO_FIELD_SIZE,/*IPV6_PROTO_FIELD_SIZE*/
+	IPV4_SA_FIELD_SIZE,
+	IPV4_DA_FIELD_SIZE,
+	IPV6_DSCP_FIELD_SIZE,
+	IPV6_ECN_FIELD_SIZE,
+	IPV6_FLOW_LBL_FIELD_SIZE,
+	IPV6_PAYLOAD_LEN_FIELD_SIZE,
+	IPV6_NH_FIELD_SIZE,
+	IPV6_SA_FIELD_SIZE,
+	IPV6_SA_PREF_FIELD_SIZE,
+	IPV6_SA_SUFF_FIELD_SIZE,
+	IPV6_DA_FIELD_SIZE,
+	IPV6_DA_PREF_FIELD_SIZE,
+	IPV6_DA_SUFF_FIELD_SIZE,
+	L4_SRC_FIELD_SIZE,
+	L4_DST_FIELD_SIZE,
+	TCP_FLAGS_FIELD_SIZE,
+	ARP_IPV4_DA_FIELD_SIZE
+};
+
+/*******************************************************************************
+* tpm_field_bm_to_field_id
+*
+* DESCRIPTION: The routine will transfer field bitmap and pkt key to field info
+*
+* INPUTS:
+*	field_bm    - match fiels bit map
+*	tpm_pkt_key - matched field value
+*	field_max   - the max count of field checked
+*	l4_info     - whether count on l4_info
+*
+* OUTPUTS:
+*	field_info  - corresponding field info array
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None.
+*******************************************************************************/
+int tpm_field_bm_to_field_info(unsigned int			field_bm,
+			       struct tpm_mng_pkt_key_t		*tpm_pkt_key,
+			       unsigned int			field_max,
+			       bool				l4_info,
+			       struct tpm_field_match_info	field_info[])
+{
+	int i = 0, j = 0;
+	int field_cnt, field_size = 0;
+	struct tpm_field_match_info temp;
+	bool is_ipv4 = true;
+
+	/* Para check */
+	IF_NULL(TPM_COMMON_MOD, tpm_pkt_key);
+	IF_NULL(TPM_COMMON_MOD, field_info);
+
+	if (field_bm & (TPM_MATCH_IPV6_PKT | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_SUFF))
+		is_ipv4 = false;
+
+	TPM_OS_DEBUG(TPM_COMMON_MOD, "field_bm 0x%x is_ipv4 %d\n", field_bm, is_ipv4)
+
+	if (field_bm & TPM_MATCH_ETH_DST && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = MAC_DA_FIELD_ID;
+		memcpy(&field_info[i].filed_value.mac_addr.parsed_mac_addr[0],
+		       &tpm_pkt_key->pkt_key->eth_dst.eth_add[0],
+		       MAC_ADDR_SIZE);
+		memcpy(&field_info[i].filed_value.mac_addr.parsed_mac_addr_mask[0],
+		       &tpm_pkt_key->pkt_key->eth_dst.eth_add_mask[0],
+		       MAC_ADDR_SIZE);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_ETH_SRC && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = MAC_SA_FIELD_ID;
+		memcpy(&field_info[i].filed_value.mac_addr.parsed_mac_addr[0],
+		       &tpm_pkt_key->pkt_key->eth_src.eth_add[0],
+		       MAC_ADDR_SIZE);
+		memcpy(&field_info[i].filed_value.mac_addr.parsed_mac_addr_mask[0],
+		       &tpm_pkt_key->pkt_key->eth_src.eth_add_mask[0],
+		       MAC_ADDR_SIZE);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_VID_OUTER && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = OUT_VLAN_ID_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->out_vid;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_PBITS_OUTER && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = OUT_VLAN_PRI_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->out_pbit;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_VID_INNER && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = IN_VLAN_ID_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->inn_vid;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+#if 0
+	if (field_bm & TPM_MATCH_PBITS_INNER && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = OUT_VLAN_PRI_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->inn_pbit;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		i++;/*need confirm*/
+	}
+#endif
+	if (field_bm & TPM_MATCH_ETH_TYPE && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = ETH_TYPE_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ether_type;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+#if 0
+	if (field_bm & TPM_MATCH_PPPOE_PROTO && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = PPPOE_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ppp_info.ppp_proto;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_valMask = common_mask_gen(field_size);
+		i++;/* Need confirm */
+	}
+#endif
+	if (field_bm & TPM_MATCH_PPPOE_SES && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = PPPOE_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ppp_info.ppp_session;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if ((field_bm & (TPM_MATCH_IP_VERSION)) && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = IP_VER_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.ip_ver;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_IP_SRC && i < field_max) {
+		if (is_ipv4) {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV4_SA_FIELD_ID;
+			memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr[0],
+			       &tpm_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv4[0],
+			       IPV4_ADDR_SIZE);
+			memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr_mask[0],
+			       &tpm_pkt_key->pkt_key->ipvx_add.ip_src.ip_add_mask.ipv4[0],
+			       IPV4_ADDR_SIZE);
+			i++;
+		} else {
+			if (field_bm & TPM_MATCH_IPV6_PREF) {
+				field_info[i].field_id = IPV6_SA_PREF_FIELD_ID;
+			} else if (field_bm & TPM_MATCH_IPV6_SUFF) {
+				field_info[i].field_id = IPV6_SA_SUFF_FIELD_ID;
+			} else if (field_bm & TPM_MATCH_IPV6_PKT) {
+				field_info[i].field_id = IPV6_SA_FIELD_ID;
+			} else {
+				IF_ERROR_STR(TPM_COMMON_MOD, TPM_BAD_PARAM,
+					"field_bm %s must include %s or %s\n",
+					tpm_utils_field_match_str_get(TPM_MATCH_IPV6_PREF),
+					tpm_utils_field_match_str_get(TPM_MATCH_IP_SRC),
+					tpm_utils_field_match_str_get(TPM_MATCH_IP_DST));
+			}
+			field_info[i].valid = TPM_FIELD_VALID;
+			memcpy(&field_info[i].filed_value.ipv6_addr.parsed_ipv6_addr[0],
+				&tpm_pkt_key->pkt_key->ipvx_add.ip_src.ip_add.ipv6[0],
+				IPV6_ADDR_SIZE);
+			memcpy(&field_info[i].filed_value.ipv6_addr.parsed_ipv6_addr_mask[0],
+				&tpm_pkt_key->pkt_key->ipvx_add.ip_src.ip_add_mask.ipv6[0],
+				IPV6_ADDR_SIZE);
+			i++;
+		}
+	}
+	if (field_bm & TPM_MATCH_IP_DST && i < field_max) {
+		if (is_ipv4) {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV4_DA_FIELD_ID;
+			memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr[0],
+			       &tpm_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv4[0],
+			       IPV4_ADDR_SIZE);
+			memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr_mask[0],
+			       &tpm_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv4[0],
+			       IPV4_ADDR_SIZE);
+			i++;
+		} else {
+			if (field_bm & TPM_MATCH_IPV6_PREF) {
+				field_info[i].field_id = IPV6_DA_PREF_FIELD_ID;
+			} else if (field_bm & TPM_MATCH_IPV6_SUFF) {
+				field_info[i].field_id = IPV6_DA_SUFF_FIELD_ID;
+			} else if (field_bm & TPM_MATCH_IPV6_PKT) {
+				field_info[i].field_id = IPV6_DA_FIELD_ID;
+			} else {
+				IF_ERROR_STR(TPM_COMMON_MOD, TPM_BAD_PARAM,
+					"field_bm %s must include %s or %s\n",
+					tpm_utils_field_match_str_get(TPM_MATCH_IPV6_PREF),
+					tpm_utils_field_match_str_get(TPM_MATCH_IP_SRC),
+					tpm_utils_field_match_str_get(TPM_MATCH_IP_DST));
+			}
+			field_info[i].valid = TPM_FIELD_VALID;
+			memcpy(&field_info[i].filed_value.ipv6_addr.parsed_ipv6_addr[0],
+				&tpm_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add.ipv6[0],
+				IPV6_ADDR_SIZE);
+			memcpy(&field_info[i].filed_value.ipv6_addr.parsed_ipv6_addr_mask[0],
+				&tpm_pkt_key->pkt_key->ipvx_add.ip_dst.ip_add_mask.ipv6[0],
+				IPV6_ADDR_SIZE);
+			i++;
+		}
+	}
+	if (field_bm & TPM_MATCH_IP_DSCP && i < field_max) {
+		if (is_ipv4) {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV4_DSCP_FIELD_ID;
+			field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.dscp;
+			field_info[i].filed_value.int_data.parsed_int_val_mask =
+				tpm_pkt_key->pkt_key->ipvx_add.dscp_mask;
+		} else {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV6_DSCP_FIELD_ID;
+			field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.dscp;
+			field_info[i].filed_value.int_data.parsed_int_val_mask =
+				tpm_pkt_key->pkt_key->ipvx_add.dscp_mask;
+		}
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_IPV6_FLBL && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = IPV6_FLOW_LBL_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.flow_label;
+		field_info[i].filed_value.int_data.parsed_int_val_mask = tpm_pkt_key->pkt_key->ipvx_add.flow_label_mask;
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (l4_info == true && field_bm & TPM_MATCH_IP_PROTO && i < field_max) {
+		if (is_ipv4) {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV4_PROTO_FIELD_ID;
+			field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.ip_proto;
+			field_size = tpm_field_size_array[field_info[i].field_id];
+			field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		} else {
+			field_info[i].valid = TPM_FIELD_VALID;
+			field_info[i].field_id = IPV6_NH_FIELD_ID;
+			field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->ipvx_add.ip_proto;
+			field_size = tpm_field_size_array[field_info[i].field_id];
+			field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		}
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_L4_SRC && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = L4_SRC_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->l4_src;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_L4_DST && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = L4_DST_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->pkt_key->l4_dst;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if (field_bm & TPM_MATCH_TTL && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = IPV4_TTL_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->ttl;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = common_mask_gen(field_size);
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+	if ((field_bm & TPM_MATCH_TCP_FLAG_RF ||
+	    field_bm & TPM_MATCH_TCP_FLAG_S) &&
+	    i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = TCP_FLAGS_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->tcp_flag;
+		field_info[i].filed_value.int_data.parsed_int_val_mask = tpm_pkt_key->tcp_flag_mask;
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+
+	if (field_bm & TPM_MATCH_ARP_TRGT_IP_ADDR && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = ARP_IPV4_DA_FIELD_ID;
+		memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr[0],
+		       &tpm_pkt_key->pkt_key->arp_ip_dst.ip_add.ipv4[0],
+		       IPV4_ADDR_SIZE);
+		memcpy(&field_info[i].filed_value.ipv4_addr.parsed_ipv4_addr_mask[0],
+		       &tpm_pkt_key->pkt_key->arp_ip_dst.ip_add_mask.ipv4[0],
+		       IPV4_ADDR_SIZE);
+		i++;
+	}
+
+	if (field_bm & TPM_MATCH_MH && i < field_max) {
+		field_info[i].valid = TPM_FIELD_VALID;
+		field_info[i].field_id = MH_FIELD_ID;
+		field_info[i].filed_value.int_data.parsed_int_val = tpm_pkt_key->mh;
+		field_size = tpm_field_size_array[field_info[i].field_id];
+		field_info[i].filed_value.int_data.parsed_int_val_mask = tpm_pkt_key->mh_mask;
+		TPM_OS_DEBUG(TPM_COMMON_MOD, "field_info[%d] %s val 0x%x mask 0x%x\n",
+			i, tpm_utils_field_id_str_get(field_info[i].field_id),
+			field_info[i].filed_value.int_data.parsed_int_val,
+			field_info[i].filed_value.int_data.parsed_int_val_mask);
+		i++;
+	}
+
+	field_cnt = i;
+
+	/* bubble sort field_id */
+	if (field_cnt > 1) {
+		for (i = 0; i < field_cnt - 1; i++) {
+			for (j = i + 1 ; j < field_cnt; j++) {
+				if (field_info[i].field_id > field_info[j].field_id) {
+					memcpy(&temp, &field_info[i], sizeof(struct tpm_field_match_info));
+					memcpy(&field_info[i], &field_info[j], sizeof(struct tpm_field_match_info));
+					memcpy(&field_info[j], &temp, sizeof(struct tpm_field_match_info));
+				}
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_field_size_get
+*
+* DESCRIPTION: The routine will get the size(unit: bit) of expected field
+*
+* INPUTS:
+*           field_id    - field ID
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+*           The size of the packet field.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+unsigned int tpm_field_size_get(unsigned int field_id)
+{
+	if (field_id == ARP_IPV4_DA_FIELD_ID)
+		return ARP_IPV4_DA_FIELD_SIZE;
+
+	if (field_id >= CLS_FIELD_MAX)
+		return 0;
+
+	return tpm_field_size_array[field_id];
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
new file mode 100644
index 0000000..4a15e36
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mc.c
@@ -0,0 +1,1337 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/*******************************************************************************
+* tpm_mc_free_list_add()
+*
+* DESCRIPTION: This routine will add one MCT entry to free list
+*
+* INPUTS:
+*          mct_hw_idx   - the free MCT entry
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_mc_free_list_add(unsigned int mct_hw_idx)
+{
+	struct list_head *free_list_head;
+	struct tpm_mc_index_t *mct_index_node, *temp_node;
+	unsigned int index;
+	bool bigger_found = false;
+
+	/* Get list head */
+	free_list_head = tpm_db_mc_free_list_head_get();
+
+	/* Check hw index already exist or not */
+	list_for_each_entry(temp_node, free_list_head, list_node) {
+		if (temp_node->mct_hw_idx == mct_hw_idx) {
+			TPM_OS_DEBUG(TPM_MC_MOD, "Entry %d already in free list\n", mct_hw_idx);
+			return TPM_OK;
+		}
+	}
+
+	/* Get the invalid index node */
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		mct_index_node = tpm_db_mc_index_node_get(index);
+		if (mct_index_node == NULL)
+			return TPM_NO_SUCH;
+		if (mct_index_node->valid == TPM_MC_ENTRY_INVALID)
+			break;
+	}
+	if (index == MV_PP2_MC_TBL_SIZE)
+		return TPM_NO_SUCH;
+
+	mct_index_node->mct_hw_idx = mct_hw_idx;
+
+	/* Check free list empty */
+	if (list_empty(free_list_head)) {
+		list_add(&mct_index_node->list_node, free_list_head);
+	} else {
+		/* Add to free list */
+		list_for_each_entry(temp_node, free_list_head, list_node) {
+			if (temp_node->mct_hw_idx > mct_hw_idx) {
+				bigger_found = true;
+				list_add_tail(&mct_index_node->list_node, &temp_node->list_node);
+				break;
+			}
+		}
+		if (bigger_found == false)
+			list_add_tail(&mct_index_node->list_node, free_list_head);
+	}
+
+	/* Change Valid status to valid */
+	mct_index_node->valid = TPM_MC_ENTRY_VALID;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mc_data_entry_db_add()
+*
+* DESCRIPTION: Add HW MCT entry data in data DB.
+*
+* INPUTS:
+*          mct_entry   - MCT entry data to record
+*
+* OUTPUTS:
+*          mct_db_idx  - the data db entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None.
+*******************************************************************************/
+static int tpm_mc_data_entry_db_add(struct tpm_mc_tbl_entry_t *mct_entry,
+				    unsigned int *mct_db_idx)
+{
+	int ret_code;
+	struct tpm_mc_data_t mct_entry_db;
+	unsigned int index;
+
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, mct_db_idx);
+
+	/* Get available db entry for mct entry */
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		ret_code = tpm_db_mc_data_get(index, &mct_entry_db);
+		IF_ERROR(TPM_MC_MOD, ret_code);
+		if (mct_entry_db.valid == TPM_MC_ENTRY_INVALID)
+			break;
+	}
+	if (index == MV_PP2_MC_TBL_SIZE) {
+		TPM_OS_ERROR(TPM_MC_MOD, "No free space in DB\n");
+		return TPM_NO_RESOURCE;
+	}
+
+	/* record MCT entry to DB */
+	memcpy(&mct_entry_db.mct_mod, &mct_entry->mct_mod, sizeof(struct tpm_mc_mod_t));
+	memcpy(&mct_entry_db.action, &mct_entry->action, sizeof(struct tpm_mc_action_t));
+
+	mct_entry_db.valid = TPM_MC_ENTRY_VALID;
+
+	/* Write to db */
+	ret_code = tpm_db_mc_data_set(index, &mct_entry_db);
+	IF_ERROR(TPM_MC_MOD, ret_code);
+
+	/* Return db index */
+	*mct_db_idx = index;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_data_entry_db_del()
+*
+* DESCRIPTION: Delete HW MCT entry data record in data DB.
+*
+* INPUTS:
+*          mct_db_idx  - the data db entry index
+*
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_mc_data_entry_db_del(unsigned int mct_db_idx)
+{
+	int ret_code;
+	struct tpm_mc_data_t mct_db_data;
+
+	TPM_MEMSET_ZERO(mct_db_data);
+	ret_code = tpm_db_mc_data_set(mct_db_idx, &mct_db_data);
+	IF_ERROR(TPM_MC_MOD, ret_code);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mc_dup_list_add()
+*
+* DESCRIPTION: Add the new index node to duplication list
+*
+* INPUTS:
+*          flowid       - flow ID of the dup list
+*          mct_hw_idx   - new entry HW index
+*          mct_db_idx   - DB index store new entry data
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_mc_dup_list_add(unsigned char flowid,
+			       unsigned int mct_hw_idx,
+			       unsigned int mct_db_idx)
+{
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node;
+	unsigned int index;
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flowid);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+
+	/* Get the invalid index node */
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		mct_index_node = tpm_db_mc_index_node_get(index);
+		if (mct_index_node == NULL)
+			return TPM_NO_SUCH;
+		if (mct_index_node->valid == TPM_MC_ENTRY_INVALID)
+			break;
+	}
+	if (index == MV_PP2_MC_TBL_SIZE)
+		return TPM_NO_SUCH;
+
+	mct_index_node->mct_hw_idx = mct_hw_idx;
+	mct_index_node->mct_data_db_idx = mct_db_idx;
+
+	/* Check lkp list is empty or not */
+	if (list_empty(dup_list_head)) {
+		/* If empty, flowid must equal hw_idx */
+		if (flowid != mct_hw_idx)
+			return TPM_BAD_PARAM;
+		/* Just add the new node */
+		list_add(&mct_index_node->list_node, dup_list_head);
+		/* Change Valid status to valid */
+		mct_index_node->valid = TPM_MC_ENTRY_VALID;
+		return TPM_OK;
+	}
+
+	/* Add the new node to end */
+	list_add_tail(&mct_index_node->list_node, dup_list_head);
+	mct_index_node->valid = TPM_MC_ENTRY_VALID;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_head_update()
+*
+* DESCRIPTION: update the flow id of an existed dup list with a member.
+*
+* INPUTS:
+*          old_flowid       - original flow ID of the dup list
+*          new_flowid       - new flow ID of the dup list
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*          None
+*******************************************************************************/
+static int tpm_mc_dup_list_head_update(unsigned char old_flowid, unsigned int new_flowid)
+{
+	int ret_code;
+	struct list_head *old_list_head, *new_list_head;
+	struct tpm_mc_index_t *mct_index_node;
+	bool node_found = false;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, old_flowid, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, new_flowid, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	/* If equal, return OK */
+	if (old_flowid == new_flowid)
+		return TPM_OK;
+
+	/* Get list head */
+	old_list_head = tpm_db_mc_dup_list_head_get(old_flowid);
+	IF_NULL(TPM_MC_MOD, old_list_head);
+	new_list_head = tpm_db_mc_dup_list_head_get(new_flowid);
+	IF_NULL(TPM_MC_MOD, new_list_head);
+
+	/* Check empty */
+	if (list_empty(old_list_head) || (!(list_empty(new_list_head))))
+		return TPM_BAD_PARAM;
+
+	/* Check new flow_id node in original list or not */
+	list_for_each_entry(mct_index_node, old_list_head, list_node) {
+		if (mct_index_node->mct_hw_idx == new_flowid) {
+			node_found = true;
+			break;
+		}
+	}
+	if (node_found == false) {
+		ret_code = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "The new flow id not found in original dup list\n");
+	}
+
+	list_cut_position(new_list_head, old_list_head, mct_index_node->list_node.prev);
+	list_splice(old_list_head, new_list_head);
+	old_list_head->next = old_list_head;
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_mc_free_entry_cnt_get
+*
+* DESCRIPTION: The API will to get the free entry count.
+* INPUTS:
+*           None.
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+*         Free entry count.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+unsigned int tpm_mc_free_entry_cnt_get(void)
+{
+	struct list_head *list;
+	unsigned int free_cnt = 0;
+
+	/* Traverse free list */
+	list_for_each(list, tpm_db_mc_free_list_head_get()) {
+		free_cnt++;
+	}
+
+	return free_cnt;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_entry_cnt_get
+*
+* DESCRIPTION: The API will to get the dup list entry count.
+* INPUTS:
+*           flow_id - flow id of the dup list.
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+*         Dup list entry count.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+unsigned int tpm_mc_dup_list_entry_cnt_get(unsigned int flow_id)
+{
+	struct list_head *list;
+	unsigned int node_cnt = 0;
+
+	/* Traverse free list */
+	list_for_each(list, tpm_db_mc_dup_list_head_get(flow_id)) {
+		node_cnt++;
+	}
+
+	return node_cnt;
+}
+
+/*******************************************************************************
+* tpm_mc_entry_set
+*
+* DESCRIPTION: The API will to write a MCT entry to HW.
+* INPUTS:
+*           mct_entry - MCT entry data
+*           hw_idx    - HW index
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mc_entry_set(struct tpm_mc_tbl_entry_t *mct_entry,
+			    unsigned int hw_idx)
+{
+	int ret_code;
+	MV_PP2_MC_ENTRY mc_entry;
+
+	/* Check parameter */
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, hw_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+
+	/* Clear Zero */
+	TPM_MEMSET_ZERO(mc_entry);
+
+	/* Set mod */
+	ret_code = mvPp2McSwModSet(&mc_entry,
+				   (int)mct_entry->mct_mod.pkt_mod.mod_data_idx,
+				   (int)mct_entry->mct_mod.pkt_mod.mod_cmd_idx);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwModSet fail\n");
+	}
+	ret_code = mvPp2McSwGpidSet(&mc_entry,
+				    (int)mct_entry->mct_mod.gem,
+				    (int)mct_entry->mct_mod.gem_mod_en);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwGpidSet fail\n");
+	}
+	ret_code = mvPp2McSwPrioSet(&mc_entry,
+				    (int)mct_entry->mct_mod.pri,
+				    (int)mct_entry->mct_mod.pri_mod_en);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwPrioSet fail\n");
+	}
+	ret_code = mvPp2McSwDscpSet(&mc_entry,
+				    (int)mct_entry->mct_mod.dscp,
+				    (int)mct_entry->mct_mod.dscp_mod_en);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwDscpSet fail\n");
+	}
+
+	/* Set action */
+	ret_code = mvPp2McSwQueueSet(&mc_entry,
+				     (int)mct_entry->action.queue);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwQueueSet fail\n");
+	}
+	ret_code = mvPp2McSwForwardEn(&mc_entry,
+				      (int)mct_entry->action.frwd);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwForwardEn fail\n");
+	}
+	ret_code = mvPp2McSwNext(&mc_entry,
+				 (int)mct_entry->action.next_mcti);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McSwNext fail\n");
+	}
+
+	/* Write to HW */
+	ret_code = mvPp2McHwWrite(&mc_entry, hw_idx);
+	if (ret_code) {
+		ret_code = TPM_HW_ERROR;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "mvPp2McHwWrite fail\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_entry_clear
+*
+* DESCRIPTION: The API will to clear one entry from HW.
+* INPUTS:
+*           hw_idx    - HW index
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mc_entry_clear(unsigned int hw_idx)
+{
+	MV_PP2_MC_ENTRY mc_entry;
+
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, hw_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+
+	/* Clear Zero */
+	TPM_MEMSET_ZERO(mc_entry);
+
+	if (mvPp2McHwWrite(&mc_entry, hw_idx)) {
+		TPM_OS_ERROR(TPM_MC_MOD, "mvPp2McHwWrite fail\n");
+		return TPM_HW_ERROR;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_node_del
+*
+* DESCRIPTION: The function will delete one HW entry from duplist.
+* INPUTS:
+*           mc_log_idx   - logical rule index from MNG module
+*           flow_id      - pointer to flow id
+*           hw_idx       - HW index to delete
+*           dup_info_set - function pointer of API to set dup info of C2/3 rule
+*
+* OUTPUTS:
+*           flow_id      - New flow id after del.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mc_dup_list_node_del(unsigned int mc_log_idx,
+				    unsigned int *flow_id,
+				    unsigned int hw_idx,
+				    int (*dup_info_set)(unsigned int rule_idx,
+							unsigned int dup_cnt,
+							unsigned int flowid))
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node, *last_index_node;
+	struct tpm_mc_data_t mct_entry_db;
+	struct tpm_mc_tbl_entry_t mct_entry;
+	unsigned int node_cnt = 0;
+	bool found = false;
+
+	/* Parameter check */
+	IF_NULL(TPM_MC_MOD, flow_id);
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, *flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, hw_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_MC_MOD, dup_info_set);
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(*flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+
+	/* List empty return error */
+	if (list_empty(dup_list_head))
+		return TPM_BAD_PARAM;
+	/* Get node count */
+	node_cnt = tpm_mc_dup_list_entry_cnt_get(*flow_id);
+
+	if (node_cnt == 1 && (*flow_id) == hw_idx) {
+		/* Decrease C2/3 dup cnt by 1 */
+		ret_code = dup_info_set(mc_log_idx, 0, 0);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup cnt update fail\n");
+		/* Release dup list */
+		ret_code = tpm_mc_dup_list_release(*flow_id);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup list release fail\n");
+		return TPM_OK;
+	}
+	/* Find the node to delete */
+	list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+		if (mct_index_node->mct_hw_idx == hw_idx) {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the dup list\n", hw_idx);
+		return TPM_NOT_FOUND;
+	}
+	/* Get DB data */
+	ret_code = tpm_db_mc_data_get(mct_index_node->mct_hw_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "DB get fail\n");
+	/* Adjust dup list flow id */
+	ret_code = tpm_mc_dup_list_head_update(*flow_id, mct_entry_db.action.next_mcti);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "dup list flow id update fail\n");
+	/* Update Dup count and Flow ID in C2/3 */
+	ret_code = dup_info_set(mc_log_idx,
+				node_cnt - 1,
+				mct_entry_db.action.next_mcti);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup info update fail\n");
+	/* Return new flow_id */
+	*flow_id = mct_entry_db.action.next_mcti;
+
+	/* Update last node next index to flow_id */
+	last_index_node = list_entry(mct_index_node->list_node.prev, struct tpm_mc_index_t, list_node);
+	/* Get last node DB data */
+	ret_code = tpm_db_mc_data_get(last_index_node->mct_data_db_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "DB get fail\n");
+	TPM_MEMSET_ZERO(mct_entry);
+	mct_entry_db.action.next_mcti = *flow_id;
+	memcpy(&mct_entry.action, &mct_entry_db.action, sizeof(struct tpm_mc_action_t));
+	memcpy(&mct_entry.mct_mod, &mct_entry_db.mct_mod, sizeof(struct tpm_mc_mod_t));
+	/* Set HW entry */
+	ret_code = tpm_mc_entry_set(&mct_entry, last_index_node->mct_hw_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT entry set fail\n");
+	/* Update DB */
+	ret_code = tpm_db_mc_data_set(last_index_node->mct_data_db_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB read fail\n");
+
+	/* Release the node */
+	ret_code = tpm_mc_entry_clear(mct_index_node->mct_hw_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT entry clear fail\n");
+	/* Delete node from list */
+	list_del(&mct_index_node->list_node);
+	/* Change to node valid status to invalid */
+	mct_index_node->valid = TPM_MC_ENTRY_INVALID;
+	/* Add to free list */
+	ret_code = tpm_mc_free_list_add(mct_index_node->mct_hw_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT free list add fail\n");
+	/* Delete DB entry */
+	ret_code = tpm_mc_data_entry_db_del(mct_index_node->mct_data_db_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB entry delete fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_node_add
+*
+* DESCRIPTION: The API will delete one node from dup list.
+* INPUTS:
+*           mc_log_idx   - logical rule index from MNG module
+*           flow_id      - flow ID of list(First MC table entry index).
+*           mct_entry    - the HW entry need to add.
+*           dup_info_set - function pointer of API to set dup info of C2/3 rule
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mc_dup_list_node_add(unsigned int mc_log_idx,
+				    unsigned int flow_id,
+				    struct tpm_mc_tbl_entry_t *mct_entry,
+				    int (*dup_info_set)(unsigned int rule_idx,
+							unsigned int dup_cnt,
+							unsigned int flowid))
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *new_index_node, *last_index_node;
+	struct tpm_mc_data_t mct_entry_db;
+	struct tpm_mc_tbl_entry_t temp_entry;
+	unsigned int node_cnt;
+	unsigned int db_idx;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, dup_info_set);
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+
+	/* List empty return error */
+	if (list_empty(dup_list_head))
+		return TPM_BAD_PARAM;
+	/* Check Free list empty or not */
+	if (list_empty(tpm_db_mc_free_list_head_get())) {
+		ret_code = TPM_NO_RESOURCE;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "The free list is empty\n");
+	}
+
+	/* Check current node count */
+	node_cnt = tpm_mc_dup_list_entry_cnt_get(flow_id);
+	if (node_cnt >= TPM_MC_DUP_MAX) {
+		ret_code = TPM_FULL;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "The dup list is full\n");
+	}
+
+	/* Get the last node of dup list */
+	last_index_node = list_entry(dup_list_head->prev, struct tpm_mc_index_t, list_node);
+
+	/* Allocate free HW entry */
+	/* Get first element from the free list */
+	new_index_node = list_first_entry(tpm_db_mc_free_list_head_get(),
+					  struct tpm_mc_index_t,
+					  list_node);
+	/* delete it from free list */
+	list_del(&new_index_node->list_node);
+	/* Change to node valid status to invalid */
+	new_index_node->valid = TPM_MC_ENTRY_INVALID;
+
+	/* Write entry to HW */
+	mct_entry->action.next_mcti = flow_id;
+	ret_code = tpm_mc_entry_set(mct_entry, new_index_node->mct_hw_idx);
+	if (ret_code) {
+		if (tpm_mc_free_list_add(new_index_node->mct_hw_idx))
+			IF_ERROR_STR(TPM_MC_MOD, TPM_FAIL, "Free list add fail\n");
+	}
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT entry set fail\n");
+
+	/* Add to DB */
+	ret_code = tpm_mc_data_entry_db_add(mct_entry, &db_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB add fail\n");
+	/* Update dup list */
+	ret_code = tpm_mc_dup_list_add(flow_id, new_index_node->mct_hw_idx, db_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup list add fail, flow id(%d)\n", flow_id);
+
+	/* Update last node of original dup list for next index */
+	ret_code = tpm_db_mc_data_get(last_index_node->mct_data_db_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB read fail\n");
+	mct_entry_db.action.next_mcti = new_index_node->mct_hw_idx;
+	memcpy(&temp_entry.mct_mod, &mct_entry_db.mct_mod, sizeof(struct tpm_mc_mod_t));
+	memcpy(&temp_entry.action, &mct_entry_db.action, sizeof(struct tpm_mc_action_t));
+	/* Set original last node */
+	ret_code = tpm_mc_entry_set(&temp_entry, last_index_node->mct_hw_idx);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT entry set fail\n");
+	/* Update DB */
+	ret_code = tpm_db_mc_data_set(last_index_node->mct_data_db_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB read fail\n");
+
+	/* Get new node count */
+	node_cnt = tpm_mc_dup_list_entry_cnt_get(flow_id);
+
+	/* Update Dup info of C2/3 */
+	ret_code = dup_info_set(mc_log_idx,
+				node_cnt,
+				flow_id);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup info update fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_node_update
+*
+* DESCRIPTION: The API will update an existed node in dup list.
+* INPUTS:
+*           mc_log_idx   - logical rule index from MNG module
+*           flow_id      - flow ID of list(First MC table entry index).
+*           hw_idx       - the HW index of entry to update
+*           mct_entry    - the HW entry need to add.
+*           dup_info_get - function pointer of API to get dup info of C2/3 rule
+* OUTPUTS:
+*           flow_id      - New flow id after update.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           First delete original node and then add a new one.
+*******************************************************************************/
+static int tpm_mc_dup_list_node_update(unsigned int mc_log_idx,
+				       unsigned int *flow_id,
+				       unsigned int hw_idx,
+				       struct tpm_mc_tbl_entry_t *mct_entry,
+				       int (*dup_info_set)(unsigned int rule_idx,
+							   unsigned int dup_cnt,
+							   unsigned int flowid))
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	unsigned int temp_flow_id;
+
+	/* Parameter check */
+	IF_NULL(TPM_MC_MOD, flow_id);
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, *flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, hw_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, dup_info_set);
+
+	temp_flow_id = *flow_id;
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(temp_flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+	/* List empty return error */
+	if (list_empty(dup_list_head))
+		return TPM_BAD_PARAM;
+
+	/* Delete the original node first */
+	ret_code = tpm_mc_dup_list_node_del(mc_log_idx,
+					    &temp_flow_id,
+					    hw_idx,
+					    dup_info_set);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup node delete fail\n");
+	/* Update flow_id */
+	*flow_id = temp_flow_id;
+	/* Add a new node with expected entry */
+	ret_code = tpm_mc_dup_list_node_add(mc_log_idx,
+					    temp_flow_id,
+					    mct_entry,
+					    dup_info_set);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT add new hw entry fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_node_keep
+*
+* DESCRIPTION: The API will update an existed node in dup list.
+* INPUTS:
+*           flow_id      - flow ID of list(First MC table entry index).
+*           hw_idx       - the HW index of entry to keep
+*           mct_entry    - the new HW entry with new dest bitmap.
+*           dest_bm_set  - function pointer of API to update destion bit map
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           Update BM through PME.
+*******************************************************************************/
+static int tpm_mc_dup_list_node_keep(unsigned int flow_id,
+				     unsigned int hw_idx,
+				     struct tpm_mc_tbl_entry_t *mct_entry,
+				     int (*dest_bm_set)(unsigned int entry_idx,
+							unsigned int dst_bm))
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node;
+	struct tpm_mc_data_t mct_entry_db;
+	bool found = false;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, hw_idx, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, dest_bm_set);
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+
+	/* List empty return error */
+	if (list_empty(dup_list_head))
+		return TPM_BAD_PARAM;
+
+	/* Find the node to keep */
+	list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+		if (mct_index_node->mct_hw_idx == hw_idx) {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		TPM_OS_ERROR(TPM_MC_MOD, "Entry %d not found in the dup list\n", hw_idx);
+		return TPM_NOT_FOUND;
+	}
+
+	/* Get DB data */
+	ret_code = tpm_db_mc_data_get(mct_index_node->mct_hw_idx, &mct_entry_db);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "DB get fail\n");
+
+	/* Check dest bm, if not equal, update */
+	if (mct_entry_db.action.port_id_bm != mct_entry->action.port_id_bm) {
+		ret_code = dest_bm_set(mct_entry_db.mct_mod.pkt_mod.mod_data_idx,
+				       mct_entry->action.port_id_bm);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dest bm update fail\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_update_info_get
+*
+* DESCRIPTION: The API will get the full updated info.
+* INPUTS:
+*           flow_id      - flow ID of list(First MC table entry index).
+*           dup_cnt      - New duplication count
+*           mct_entry    - New MCT entry array
+*
+* OUTPUTS:
+*           update       - MCT update information
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+static int tpm_mc_update_info_get(unsigned int flow_id,
+				  unsigned int dup_cnt,
+				  struct tpm_mc_tbl_entry_t mct_entry[],
+				  struct tpm_mc_update_t *update)
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node;
+	struct tpm_mc_data_t mct_entry_db;
+	int i, j, k = 0;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, dup_cnt, 0, TPM_MC_DUP_MAX);
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, update);
+
+	memset(update, 0, sizeof(struct tpm_mc_update_t));
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+
+	/* Get the node need to keep */
+	list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+		ret_code = tpm_db_mc_data_get(mct_index_node->mct_data_db_idx, &mct_entry_db);
+		IF_ERROR(TPM_MC_MOD, ret_code);
+		/* Check the node need update or not */
+		for (i = 0; i < dup_cnt; i++) {
+			for (j = 0; j < dup_cnt; j++) {
+				if ((update->info[j].valid == TPM_MC_UPDATE_VALID) &&
+				    (update->info[j].new_entry_idx == i))
+					break;
+			}
+			if (j != dup_cnt)
+				continue;
+			/* Check MCT entry action except Next Index */
+			if ((!memcmp(&mct_entry_db.mct_mod,
+				     &mct_entry[i].mct_mod,
+				     sizeof(struct tpm_mc_mod_t))) &&
+			    (mct_entry_db.action.frwd == mct_entry[i].action.frwd) &&
+			    (mct_entry_db.action.queue == mct_entry[i].action.queue)) {
+				/* get update info to record it */
+				for (k = 0; k < TPM_MC_DUP_MAX; k++) {
+					if (update->info[k].valid == TPM_MC_UPDATE_INVALID) {
+						update->info[k].old_hw_idx = mct_index_node->mct_hw_idx;
+						update->info[k].new_entry_idx = i;
+						update->info[k].state = TPM_MC_ENTRY_KEEP;
+						memcpy(&update->info[k].new_entry,
+						       &mct_entry[i],
+						       sizeof(struct tpm_mc_tbl_entry_t));
+						update->info[k].valid = TPM_MC_UPDATE_VALID;
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	/* Check original node take new entry or add node to take new entry  */
+	for (i = 0; i < dup_cnt; i++) {
+		for (j = 0; j < TPM_MC_DUP_MAX; j++) {
+			if ((update->info[j].valid == TPM_MC_UPDATE_VALID) &&
+			    (update->info[j].new_entry_idx == i))
+				break;
+		}
+		if (j != TPM_MC_DUP_MAX)
+			continue;
+		/* Find existed node to take new entry */
+		list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+			for (k = 0; k < TPM_MC_DUP_MAX; k++) {
+				if ((update->info[k].valid == TPM_MC_UPDATE_VALID) &&
+				    (update->info[k].old_hw_idx == mct_index_node->mct_hw_idx))
+					break;
+			}
+			if (k == TPM_MC_DUP_MAX)
+				break;
+		}
+		if (k == TPM_MC_DUP_MAX) {/* Find the available existed node to take new entry */
+			/* get update info to record it */
+			for (k = 0; k < TPM_MC_DUP_MAX; k++) {
+				if (update->info[k].valid == TPM_MC_UPDATE_INVALID) {
+					update->info[k].old_hw_idx = mct_index_node->mct_hw_idx;
+					update->info[k].state = TPM_MC_ENTRY_UPDATE;
+					update->info[k].new_entry_idx = i;
+					memcpy(&update->info[k].new_entry,
+					       &mct_entry[i],
+					       sizeof(struct tpm_mc_tbl_entry_t));
+					update->info[k].valid = TPM_MC_UPDATE_VALID;
+					break;
+				}
+			}
+		} else {/* add new node to take new entry */
+			/* get update info to record it */
+			for (k = 0; k < TPM_MC_DUP_MAX; k++) {
+				if (update->info[k].valid == TPM_MC_UPDATE_INVALID) {
+					update->info[k].state = TPM_MC_ENTRY_ADD;
+					update->info[k].new_entry_idx = i;
+					memcpy(&update->info[k].new_entry,
+					       &mct_entry[i],
+					       sizeof(struct tpm_mc_tbl_entry_t));
+					update->info[k].valid = TPM_MC_UPDATE_VALID;
+					break;
+				}
+			}
+		}
+	}
+
+	/* Need delete original entry */
+	list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+		for (k = 0; k < TPM_MC_DUP_MAX; k++) {
+			if ((update->info[k].valid == TPM_MC_UPDATE_VALID) &&
+			    (update->info[k].old_hw_idx == mct_index_node->mct_hw_idx))
+				break;
+		}
+		if (k != TPM_MC_DUP_MAX)
+			continue;
+		/* get update info to record it */
+		for (j = 0; j < TPM_MC_DUP_MAX; j++) {
+			if (update->info[j].valid == TPM_MC_UPDATE_INVALID) {
+				update->info[j].old_hw_idx = mct_index_node->mct_hw_idx;
+				update->info[j].state = TPM_MC_ENTRY_DEL;
+				update->info[j].valid = TPM_MC_UPDATE_VALID;
+				break;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_create
+*
+* DESCRIPTION: The API will to create a duplication list.
+* INPUTS:
+*           dup_cnt      - duplication count
+*           mct_entry    - MCT entry array
+*
+* OUTPUTS:
+*           flow_id      - flow ID of list(First MC table entry index).
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_mc_dup_list_create(unsigned int dup_cnt,
+			   struct tpm_mc_tbl_entry_t mct_entry[],
+			   unsigned int *flow_id)
+{
+	int ret_code;
+	struct tpm_mc_index_t *mct_index_node;
+	int i;
+	unsigned int free_hw_idx[TPM_MC_DUP_MAX], db_idx[TPM_MC_DUP_MAX];
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, dup_cnt, 0, TPM_MC_DUP_MAX);
+	IF_NULL(TPM_MC_MOD, mct_entry);
+	IF_NULL(TPM_MC_MOD, flow_id);
+
+	/* Dup 0, return directly */
+	if (dup_cnt == 0)
+		return TPM_OK;
+	/* Check there is enough free MCT entry or not */
+	if (dup_cnt > tpm_mc_free_entry_cnt_get()) {
+		ret_code = TPM_NO_RESOURCE;
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "No enough MCT entries available\n");
+	}
+
+	/* Traverse free list */
+	for (i = 0; i < dup_cnt; i++) {
+		/* Get first element from the free list */
+		mct_index_node = list_first_entry(tpm_db_mc_free_list_head_get(),
+						  struct tpm_mc_index_t,
+						  list_node);
+		/* delete it from free list */
+		list_del(&mct_index_node->list_node);
+		/* Change to node valid status to invalid */
+		mct_index_node->valid = TPM_MC_ENTRY_INVALID;
+		free_hw_idx[i] = mct_index_node->mct_hw_idx;
+	}
+
+	*flow_id = free_hw_idx[0];
+
+	/* Write entry to HW */
+	for (i = 0; i < dup_cnt; i++) {
+		/* Update Next Index */
+		if ((i + 1) < dup_cnt)
+			mct_entry[i].action.next_mcti = free_hw_idx[i + 1];
+		else
+			mct_entry[i].action.next_mcti = *flow_id;/* The next index of end entry is head node */
+		ret_code = tpm_mc_entry_set(&mct_entry[i], free_hw_idx[i]);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MC table entry set fail\n");
+		/* Update to DB */
+		ret_code = tpm_mc_data_entry_db_add(&mct_entry[i], &db_idx[i]);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB update fail\n");
+		/* Update dup list */
+		ret_code = tpm_mc_dup_list_add(*flow_id, free_hw_idx[i], db_idx[i]);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup list update fail, flow id(%d)\n", *flow_id);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_update
+*
+* DESCRIPTION: The API will update an existed duplication list.
+* INPUTS:
+*           rule_index       - logical rule index from MNG module
+*           flow_id          - flow ID of list(First MC table entry index).
+*           new_dup_cnt      - New duplication count
+*           new_mct_entry    - New MCT entry array
+*           dup_info_set     - function pointer of API to set dup info of C2/3 rule
+*           dest_bm_set      - function pointer of API to update destion bit map
+* OUTPUTS:
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_mc_dup_list_update(unsigned int rule_index,
+			   unsigned int flow_id,
+			   unsigned int new_dup_cnt,
+			   struct tpm_mc_tbl_entry_t new_mct_entry[],
+			   int (*dup_info_set)(unsigned int rule_idx,
+					       unsigned int dup_cnt,
+					       unsigned int flowid),
+			   int (*dest_bm_set)(unsigned int entry_idx,
+					      unsigned int dst_bm))
+{
+	int ret_code;
+	unsigned int tpm_flow_id = 0;
+	struct list_head *dup_list_head;
+	struct tpm_mc_update_t mct_update;
+	unsigned int old_cnt = 0;
+	int i;
+
+	/* Parameter check */
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, new_dup_cnt, 0, TPM_MC_DUP_MAX);
+	IF_NULL(TPM_MC_MOD, new_mct_entry);
+	IF_NULL(TPM_MC_MOD, dup_info_set);
+	IF_NULL(TPM_MC_MOD, dest_bm_set);
+
+	/* if dup_cnt is 0, release the list directly */
+	if (new_dup_cnt == 0) {
+		/* Set C2/3 dup count to 0 first */
+		ret_code = dup_info_set(rule_index, 0, 0);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup info set fail\n");
+		/* Release list */
+		ret_code = tpm_mc_dup_list_release(flow_id);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "Dup list release fail\n");
+		/* Return */
+		return TPM_OK;
+	}
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+	/* List empty return error */
+	if (list_empty(dup_list_head))
+		return TPM_BAD_PARAM;
+
+	/* Get original list node cnt */
+	old_cnt = tpm_mc_dup_list_entry_cnt_get(flow_id);
+
+	/* Check HW resource is enough or not */
+	if (new_dup_cnt > old_cnt) {
+		if ((new_dup_cnt - old_cnt) > tpm_mc_free_entry_cnt_get()) {
+			ret_code = TPM_NO_RESOURCE;
+			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT update HW resource NOT enough\n");
+		}
+	}
+
+	/* Get full update info */
+	ret_code = tpm_mc_update_info_get(flow_id,
+					  new_dup_cnt,
+					  new_mct_entry,
+					  &mct_update);
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT update info get fail\n");
+	/* Debug Info */
+	if ((TPM_MC_MOD & GLOB_TRACE) && (TPM_DEBUG_MASK & GLOB_TRACE)) {
+		for (i = 0; i < TPM_MC_DUP_MAX; i++) {
+			if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID) {
+				TPM_OS_DEBUG(TPM_MC_MOD, "update state %d, old_hw_idx %d\n",
+						mct_update.info[i].state, mct_update.info[i].old_hw_idx);
+			}
+		}
+	}
+
+	tpm_flow_id = flow_id;
+
+	/* Handle dup list update */
+	for (i = 0; i < TPM_MC_DUP_MAX; i++) {
+		/* Handle existed node keep, maybe need to update dest UNI bitmap */
+		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update.info[i].state == TPM_MC_ENTRY_KEEP) {
+			ret_code = tpm_mc_dup_list_node_keep(tpm_flow_id,
+							     mct_update.info[i].old_hw_idx,
+							     &mct_update.info[i].new_entry,
+							     dest_bm_set);
+			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT keep handle fail\n");
+		}
+
+		/* Handle existed node update */
+		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update.info[i].state == TPM_MC_ENTRY_UPDATE) {
+			ret_code = tpm_mc_dup_list_node_update(rule_index,
+							       &tpm_flow_id,
+							       mct_update.info[i].old_hw_idx,
+							       &mct_update.info[i].new_entry,
+							       dup_info_set);
+			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT update hw entry fail\n");
+		}
+
+		/* Handle add new node */
+		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update.info[i].state == TPM_MC_ENTRY_ADD) {
+			ret_code = tpm_mc_dup_list_node_add(rule_index,
+							    tpm_flow_id,
+							    &mct_update.info[i].new_entry,
+							    dup_info_set);
+			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT add new hw entry fail\n");
+		}
+
+		/* Handle del existed node */
+		if (mct_update.info[i].valid == TPM_MC_UPDATE_VALID &&
+		    mct_update.info[i].state == TPM_MC_ENTRY_DEL) {
+			ret_code = tpm_mc_dup_list_node_del(rule_index,
+							    &tpm_flow_id,
+							    mct_update.info[i].old_hw_idx,
+							    dup_info_set);
+			IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT del existed hw entry fail\n");
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_dup_list_release
+*
+* DESCRIPTION: The API will to release a duplication list.
+* INPUTS:
+*           flow_id      - flow ID of list(First MC table entry index).
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_mc_dup_list_release(unsigned int flow_id)
+{
+	int ret_code;
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node, *tmp_node;
+
+	TPM_DECIMAL_RANGE_VALIDATE(TPM_MC_MOD, flow_id, 0, (MV_PP2_MC_TBL_SIZE - 1));
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	IF_NULL(TPM_MC_MOD, dup_list_head);
+	/* Check list empty or not */
+	if (list_empty(dup_list_head))
+		return TPM_OK;
+	/* delete the node */
+	list_for_each_entry_safe(mct_index_node, tmp_node, dup_list_head, list_node) {
+		/* delete from HW */
+		ret_code = tpm_mc_entry_clear(mct_index_node->mct_hw_idx);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT HW entry delete fail\n");
+		/* delete it from list */
+		list_del(&mct_index_node->list_node);
+		/* Change to node valid status to invalid */
+		mct_index_node->valid = TPM_MC_ENTRY_INVALID;
+		/* Add to free list */
+		ret_code = tpm_mc_free_list_add(mct_index_node->mct_hw_idx);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT free list add fail\n");
+		/* Delete DB entry */
+		ret_code = tpm_mc_data_entry_db_del(mct_index_node->mct_data_db_idx);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT DB entry delete fail\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_reset
+*
+* DESCRIPTION: The API will reset MCT module.
+* INPUTS:
+*           None.
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_mc_reset(void)
+{
+	int ret_code;
+	int i;
+
+	for (i = 0; i < MV_PP2_MC_TBL_SIZE; i++) {
+		ret_code = tpm_mc_dup_list_release(i);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MC reset fail\n");
+		ret_code = tpm_mc_entry_clear(i);
+		IF_ERROR_STR(TPM_MC_MOD, ret_code, "MC HW entry clear fail\n");
+	}
+
+	/* DB init */
+	ret_code = tpm_db_mc_init();
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MC DB init fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_mc_start
+*
+* DESCRIPTION: The API will start MCT module.
+* INPUTS:
+*           None.
+*
+* OUTPUTS:
+*           None.
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_mc_start(void)
+{
+	int ret_code;
+
+	ret_code = tpm_mc_reset();
+	IF_ERROR_STR(TPM_MC_MOD, ret_code, "MCT start fail\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mempool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mempool.c
new file mode 100644
index 0000000..bb36282
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_mempool.c
@@ -0,0 +1,311 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/******************************************************************************
+**  FILE        : tpm_mempool.c                                              **
+**                                                                           **
+**  DESCRIPTION : This file tpm memory pool manager                          **
+******************************************************************************/
+#include "tpm_header.h"
+
+/*******************************************************************************
+* tpm_common_mempool_check_internal
+*
+* DESCRIPTION: The function will check tpm mempool internal parameter.
+*
+* INPUTS:
+*	    *pool -  tpm mempool
+*           *ptr  -  buffer pointer allocated
+*           *hdr  -  header pointer
+*           *ftr  -  pointer
+*
+* OUTPUTS:
+*	    None
+* RETURN:
+* If check pass, return true, or return false.
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+static bool tpm_common_mempool_check_internal(struct tpm_common_mempool_t *pool,
+					      void *ptr,
+					      struct tpm_common_mpool_hdr_t *hdr,
+					      struct tpm_common_mpool_ftr_t *ftr)
+{
+	if (!ptr) {
+		printk(KERN_ERR "illegal ptr NULL");
+		return false;
+	}
+
+	if (!TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)) {
+		printk(KERN_ERR "ptr not aligned %p", ptr);
+		return false;
+	}
+
+	if (hdr->magic != TPM_COMMON_MPOOL_HDR_MAGIC) {
+		printk(KERN_ERR "illegal hdr magic %x for ptr %p", hdr->magic, ptr);
+		return false;
+	}
+
+	if (ftr->magic != TPM_COMMON_MPOOL_FTR_MAGIC) {
+		printk(KERN_ERR "illegal ftr magic %x for ptr %p", ftr->magic, ptr);
+		return false;
+	}
+
+	if (hdr->pool != pool || ftr->pool != pool) {
+		printk(KERN_ERR "inconsistent size hdr->pool: %p ftr->pool: %p for ptr %p", hdr->pool, ftr->pool, ptr);
+		return false;
+	}
+
+	if (!(hdr->flags & TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED)) {
+		printk(KERN_ERR "ptr %p was not allocated", ptr);
+		return false;
+	}
+
+	return true;
+}
+
+/*******************************************************************************
+* tpm_common_mempool_alloc
+*
+* DESCRIPTION: The function will allocate buffer according to buffer type.
+*
+* INPUTS:
+*	    *pool -  tpm mempool on which to allocate buffer
+*
+* OUTPUTS:
+*	    None
+* RETURN:
+* If successful, return pointer of buffer.
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+void *tpm_common_mempool_alloc(struct tpm_common_mempool_t *pool)
+{
+	struct tpm_common_mpool_hdr_t *hdr;
+
+	if (!pool || !pool->head || pool->number_of_free_entries == 0)
+		return NULL;
+
+	spin_lock_bh(&pool->lock);
+	hdr = pool->head;
+	pool->head = pool->head->next;
+
+	if (!pool->head)
+		pool->tail = NULL;
+
+	hdr->flags = TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED;
+	pool->number_of_free_entries--;
+	spin_unlock_bh(&pool->lock);
+	return (unsigned char *) hdr + sizeof(struct tpm_common_mpool_hdr_t);
+}
+
+/*******************************************************************************
+* tpm_common_mempool_free
+*
+* DESCRIPTION: The function will release buffer allocated according to buffer type.
+*
+* INPUTS:
+*	    *pool -  tpm mempool on which to allocate buffer
+*           *ptr  -  the buffter pointer to release
+*
+* OUTPUTS:
+*	    None
+* RETURN:
+*           None.
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+void tpm_common_mempool_free(struct tpm_common_mempool_t *pool, void *ptr)
+{
+	struct tpm_common_mpool_hdr_t *hdr;
+	struct tpm_common_mpool_ftr_t *ftr;
+
+	if (!pool || !ptr)
+		return;
+
+	if (!TPM_COMMON_MPOOL_CHECK_ALIGNED4(ptr)) {
+		printk(KERN_ERR "ptr not aligned %p", ptr);
+		return;
+	}
+	spin_lock_bh(&pool->lock);
+	hdr = (struct tpm_common_mpool_hdr_t *) ((unsigned char *) ptr - sizeof(struct tpm_common_mpool_hdr_t));
+	ftr = (struct tpm_common_mpool_ftr_t *) ((unsigned char *) ptr + pool->data_size);
+
+	if (!tpm_common_mempool_check_internal(pool, ptr, hdr, ftr)) {
+		printk(KERN_ERR "invalid ptr %p", ptr);
+		spin_unlock_bh(&pool->lock);
+		return;
+	}
+
+	hdr->flags ^= TPM_COMMON_MPOOL_HDR_FLAGS_ALLOCATED;
+	hdr->next = NULL;
+
+	if (!pool->head)
+		pool->head = pool->tail = hdr;
+	else {
+		pool->tail->next = hdr;
+		pool->tail = hdr;
+	}
+
+	pool->number_of_free_entries++;
+	spin_unlock_bh(&pool->lock);
+}
+
+/*******************************************************************************
+* tpm_common_mempool_create
+*
+* DESCRIPTION: The function will create tpm memory pool
+*
+* INPUTS:
+*	    number_of_entries -  buffer entry number contained in the pool.
+*           entry_size        -  the size of each entry
+*           priority          - priority of the buffer allocated
+*
+* OUTPUTS:
+*	    None
+* RETURN:
+*           memory pool pointer.
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+struct tpm_common_mempool_t *tpm_common_mempool_create(unsigned int number_of_entries,
+						       unsigned int entry_size,
+						       int priority)
+{
+	unsigned int i;
+	unsigned int aligned_entry_size;
+	unsigned int pool_entry_size;
+	struct tpm_common_mpool_hdr_t *hdr;
+	struct tpm_common_mpool_hdr_t *next_hdr;
+	struct tpm_common_mpool_ftr_t *ftr;
+	struct tpm_common_mempool_t *pool;
+
+	aligned_entry_size = TPM_COMMON_MPOOL_ALIGN4(entry_size);
+	pool_entry_size =
+	    TPM_COMMON_MPOOL_ALIGN4(sizeof(struct tpm_common_mpool_hdr_t) + aligned_entry_size +
+				    sizeof(struct tpm_common_mpool_ftr_t));
+	pool = kmalloc((sizeof(struct tpm_common_mempool_t) + pool_entry_size * number_of_entries), priority);
+
+	if (!pool)
+		return NULL;
+
+	pool->entry_size = entry_size;
+	pool->number_of_entries = number_of_entries;
+	pool->data_size = aligned_entry_size;
+	pool->pool_entry_size = pool_entry_size;
+	pool->number_of_free_entries = number_of_entries;
+	pool->mem = (unsigned char *) (pool + 1);
+	pool->head = (struct tpm_common_mpool_hdr_t *) pool->mem;
+	spin_lock_init(&pool->lock);
+
+	for (i = 0; i < number_of_entries; i++) {
+		hdr = (struct tpm_common_mpool_hdr_t *) &pool->mem[pool_entry_size * i];
+		ftr =
+		    (struct tpm_common_mpool_ftr_t *) ((unsigned char *) hdr + sizeof(struct tpm_common_mpool_hdr_t) +
+							aligned_entry_size);
+		hdr->magic = TPM_COMMON_MPOOL_HDR_MAGIC;
+		hdr->pool = pool;
+		hdr->flags = 0;
+		ftr->magic = TPM_COMMON_MPOOL_FTR_MAGIC;
+		ftr->pool = pool;
+
+		if (i < (number_of_entries - 1))
+			next_hdr = (struct tpm_common_mpool_hdr_t *) &pool->mem[pool_entry_size * (i + 1)];
+		else {
+			pool->tail = hdr;
+			next_hdr = NULL;
+		}
+
+		hdr->next = next_hdr;
+	}
+	return pool;
+}
+
+/*******************************************************************************
+* tpm_common_mempool_destroy
+*
+* DESCRIPTION: The function will release the memory pool
+*
+* INPUTS:
+*	    *pool -  pool to release
+*
+* OUTPUTS:
+*	    None
+* RETURN:
+*           None
+*
+* COMMENTS:
+*	    None.
+*******************************************************************************/
+void tpm_common_mempool_destroy(struct tpm_common_mempool_t *pool)
+{
+	if (!pool)
+		return;
+
+	kfree(pool);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_parser.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_parser.c
new file mode 100644
index 0000000..9ac09b9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_parser.c
@@ -0,0 +1,1847 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_parser.c						     **
+**									     **
+**  DESCRIPTION : This file contains parser sub-module init routine and APIs **
+**  DEPENDCY : None		                             **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* Parser pre configuration */
+static struct tpm_db_prs_t tpm_prs_preconfig = {
+			/***********#IPV6 NH#******************#TCAM Index#********/
+	.ipv6_special_nh = {{TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX},
+			    {TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX},
+			    {TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX},
+			    {TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX},
+			    {TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX},
+			    {TPM_PRS_INV_SPEC_IPV6_NH,	TPM_PRS_INV_TCAM_IDX} },
+	.prs_lu_id = {
+		/**#Valid#***********************#Traffic Type#*****************#Result Info#******************#TCAM Index#************#Lookup_ID#**********/
+		{TPM_PRS_LU_ID_ENTRY_VALID,	LSP_GMAC0_DEFAULT,		{TPM_PRS_RI_NONE,
+										 TPM_PRS_RI_NONE_MASK},		TPM_PRS_INV_TCAM_IDX,	LSP_GMAC0_DEFAULT_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	LSP_LPK_GMAC_DEFAULT,		{TPM_PRS_RI_NONE,
+										 TPM_PRS_RI_NONE_MASK},		TPM_PRS_INV_TCAM_IDX,	LSP_LPK_GMAC_DEFAULT_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	LSP_PON_DEFAULT,		{TPM_PRS_RI_NONE,
+										 TPM_PRS_RI_NONE_MASK},		TPM_PRS_INV_TCAM_IDX,	LSP_PON_DEFAULT_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_NPPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_NPPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_NPPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_NPPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_NPPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_NPPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_NPPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_NPPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_PPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_PPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_PPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_PPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_PPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_PPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_NF_PPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_NF_PPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_NPPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_NPPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_NPPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_NPPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_NPPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_NPPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_NPPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_NPPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_PPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_PPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_PPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_PPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_PPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_PPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_RTR_FRAG_PPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_RTR_FRAG_PPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MTM_UNTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MTM_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MTM_STAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MTM_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MTM_DTAG,		{TPM_PRS_MAC2ME_TRUE |
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MTM_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MTM_TTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MTM_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_RTR_UNTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_RTR_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_L2_UNTAG,		{TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_L2_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MC_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MC_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_RTR_TAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_RTR_TAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_RTR_DTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_RTR_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_L2_TAG,			{TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_L2_TAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MC_TAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MC_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_MC_L2_DTAG,		{TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_MC_L2_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_MC_DTAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_MC_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_RTR_UNTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_RTR_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_L2_UNTAG,		{TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_L2_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_RTR_TAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_RTR_TAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_RTR_DTAG,		{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_RTR_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_L2_TAG,			{TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_L2_TAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_MC_L2_DTAG,		{TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_MC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_MC_L2_DTAG_ID},
+		/* Other L2 MC packet treat as BRG packet */
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_L2_MC_BRG_NF_UNTAG,	{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_L2_MC_BRG_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_L2_MC_BRG_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_L2_MC_BRG_NF_UNTAG,	{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_L2_MC_BRG_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_L2_MC_BRG_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_MC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_BRG_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L2_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L2_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L3_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L3_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_BRG_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L2_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L2_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L3_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L3_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_BRG_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L2_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L2_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_BC_L3_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_BC_L3_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV4_UC_BRG_NF_TTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV4_IHL_E5|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_FRAG_FALSE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_FRAG_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV4_UC_BRG_NF_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_BRG_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L2_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L2_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L3_NF_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L3_NF_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_BRG_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L2_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L2_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L3_NF_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L3_NF_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_BRG_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L2_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L2_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_BC_L3_NF_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_BC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_BC_L3_NF_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_BRG_NF_TTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_BRG_NF_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	PPOE_BRG_UNTAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	PPOE_BRG_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BC_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BC_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BRG_UNTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BRG_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	PPOE_BRG_STAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	PPOE_BRG_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BC_STAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BC_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BRG_STAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BRG_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	PPOE_BRG_DTAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	PPOE_BRG_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	PPOE_BRG_TTAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	PPOE_BRG_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BC_DTAG,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_BC|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BC_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BRG_DTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BRG_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_BRG_TTAG,		{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L3_NA|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_BRG_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG, {TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_NPPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_NPPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_NPPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_NPPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_PPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_PPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_PPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_PPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_SPEC_EX_PPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_SPECIAL_IPV6_NH|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_SPEC_EX_PPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_NPPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_NPPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_NPPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_NPPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_NPPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_NPPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_NPPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_NPPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_NPPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_NPPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_NPPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_NPPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_NPPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_NPPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_NPPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_FALSE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_NPPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_PPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_PPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_PPOE_UNTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_NONE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_PPOE_UNTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_PPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_PPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_PPOE_STAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_SINGLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_PPOE_STAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_PPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_PPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_NOEX_PPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_NO_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_NOEX_PPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_PPOE_DTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_DOUBLE|
+										 TPM_PRS_L2_UC |
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_PPOE_DTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	IPV6_UC_RTR_GEN_EX_PPOE_TTAG,	{TPM_PRS_MAC2ME_TRUE|
+										 TPM_PRS_VLAN_TRIPLE|
+										 TPM_PRS_L2_UC|
+										 TPM_PRS_PPPOE_TRUE|
+										 TPM_PRS_L3_IPV6_EXT|
+										 TPM_PRS_L3_UC|
+										 TPM_PRS_UDF3_PON_CHANNEL_NONE,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_VLAN_MASK|
+										 TPM_PRS_L2_CAST_MASK|
+										 TPM_PRS_PPPOE_MASK|
+										 TPM_PRS_L3_INFO_MASK|
+										 TPM_PRS_L3_CAST_MASK|
+										 TPM_PRS_UDF3_PON_CHANNEL_MASK},		TPM_PRS_INV_TCAM_IDX,	IPV6_UC_RTR_GEN_EX_PPOE_TTAG_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	NON_IP_ARP,			{TPM_PRS_MAC2ME_FALSE|
+										 TPM_PRS_L3_ARP,
+										 TPM_PRS_MAC2ME_MASK|
+										 TPM_PRS_L3_INFO_MASK},		TPM_PRS_INV_TCAM_IDX,	NON_IP_ARP_ID},
+		{TPM_PRS_LU_ID_ENTRY_VALID,	LOOPBACK_PORT_PKT,		{TPM_PRS_RI_NONE,
+										 TPM_PRS_RI_NONE_MASK},		TPM_PRS_INV_TCAM_IDX,	LOOPBACK_PKT_ID},
+		{TPM_PRS_LU_ID_ENTRY_INV,	UNEXPECTED_PKT,			{TPM_PRS_RI_NONE,
+										 TPM_PRS_RI_NONE_MASK},		TPM_PRS_INV_TCAM_IDX,	UNEXPECTED_PKT_ID}
+	}
+};
+
+/*******************************************************************************
+* tpm_prs_db_init
+*
+* DESCRIPTION: The API will set parser preconfig info to TPM DB
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_module_init(), done when TPM module load.
+*******************************************************************************/
+int tpm_prs_db_init(void)
+{
+	int ret_code;
+	ret_code = tpm_db_prs_pre_all_set(&tpm_prs_preconfig);
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPM parser db init with pre config failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_lu_id_init
+*
+* DESCRIPTION: The API will init parser lookup ID from start DB.
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_prs_init.
+*******************************************************************************/
+static int tpm_prs_lu_id_init(void)
+{
+	int ret_code;
+	unsigned int tid, traf_id;
+	struct tpm_prs_lu_id_t lu_id_data;
+	int port_bm = 0;
+
+	for (traf_id = LSP_GMAC0_DEFAULT; traf_id < TPM_TRAFFIC_TYPE_MAX; traf_id++) {
+		/* Get LU_ID info from TPM DB */
+		ret_code = tpm_db_prs_lu_id_get(traf_id, &lu_id_data);
+		IF_ERROR_STR(TPM_PRS_MOD, ret_code, "LU_ID info of Traffic Type(%d) get failed\n", traf_id);
+
+		/* Exclude MAC default LookupID by LSP */
+		if (LUID_IS_LSP_RESERVED(lu_id_data.lu_id))
+			continue;
+
+		/* Add Parser rule */
+		if (lu_id_data.valid == TPM_PRS_LU_ID_ENTRY_VALID) {
+			/* Check the rule exist in TCAM or not */
+			if (lu_id_data.prs_idx != TPM_PRS_INV_TCAM_IDX)
+				continue;
+			/* Get first, free entry,  Go through the all entires from first to last */
+			tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+			if (tid > MV_PP2_PRS_TCAM_SIZE - 1) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "No free TCAM entry for traffic(%d)\n", traf_id);
+				return TPM_NO_RESOURCE;
+			}
+			/* port bit map */
+			if (lu_id_data.lu_id == LOOPBACK_PKT_ID)
+				port_bm = 1 << ENUM_GMAC_LPK;
+			else
+				port_bm = (1 << ENUM_GMAC_0) | (1 << ENUM_GMAC_1) | (1 << ENUM_PMAC);
+			/* Generate lookup id */
+			ret_code = mvPrsFlowIdGen(tid,
+						  lu_id_data.lu_id,
+						  lu_id_data.prs_result.prs_ri,
+						  lu_id_data.prs_result.prs_ri_mask,
+						  port_bm);
+			IF_ERROR_STR(TPM_PRS_MOD, ret_code, "Parser rule add fail for traffic(%d)\n", traf_id);
+
+			/* Update Parser TCAM index in TPM_DB */
+			lu_id_data.prs_idx = tid;
+			ret_code = tpm_db_prs_lu_id_set(traf_id, &lu_id_data);
+			IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TCAM inx update fail\n");
+		}
+
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_lu_id_reset
+*
+* DESCRIPTION: The API will reset parser lookup ID according to start DB.
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_mib_reset.
+*******************************************************************************/
+static int tpm_prs_lu_id_reset(void)
+{
+	int ret_code;
+	unsigned int traf_id;
+	struct tpm_prs_lu_id_t lu_id_data;
+
+	for (traf_id = LSP_GMAC0_DEFAULT; traf_id < TPM_TRAFFIC_TYPE_MAX; traf_id++) {
+		/* Get LU_ID info from TPM DB */
+		ret_code = tpm_db_prs_lu_id_get(traf_id, &lu_id_data);
+		IF_ERROR_STR(TPM_PRS_MOD, ret_code, "LU_ID info of Traffic Type(%d) get failed\n", traf_id);
+
+		/* Exclude MAC default LookupID by LSP */
+		if (LUID_IS_LSP_RESERVED(lu_id_data.lu_id))
+			continue;
+		/* delete rule */
+		if (lu_id_data.valid == TPM_PRS_LU_ID_ENTRY_VALID &&
+		    lu_id_data.prs_idx != TPM_PRS_INV_TCAM_IDX) {
+			if (mvPp2PrsHwInv(lu_id_data.prs_idx)) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "Parser rule(%d) delete failed\n", lu_id_data.prs_idx);
+				return TPM_HW_ERROR;
+			}
+			/* upate tpm_db */
+			lu_id_data.prs_idx = TPM_PRS_INV_TCAM_IDX;
+			/* update valid state only for unexpected traffic */
+			if (traf_id == UNEXPECTED_PKT)
+				lu_id_data.valid = TPM_PRS_LU_ID_ENTRY_INV;
+			ret_code = tpm_db_prs_lu_id_set(traf_id, &lu_id_data);
+			IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TCAM inx update fail\n");
+
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_spec_ipv6nh_init
+*
+* DESCRIPTION: The API will init parser with special IPV6 NH from tpm_start_db
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_prs_init.
+*******************************************************************************/
+static int tpm_prs_spec_ipv6nh_init(void)
+{
+#if 0
+	int ret_code;
+	unsigned int ipv6_enable = TPM_IPV6_NOT_SUPPORTED;
+
+	/* Check IPV6 supported */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "get ipv6 enable failed\n");
+
+	/* If IPV6 supported, add IP6 NH parser rules */
+	if (TPM_IPV6_SUPPORTED == ipv6_enable) {
+		ret_code = mvPrsIp6NhSet();
+		IF_ERROR_STR(TPM_PRS_MOD, ret_code, "IP6 NH Parser rule add fail\n");
+	}
+#endif
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_spec_ipv6nh_reset
+*
+* DESCRIPTION: The API will reset parser with special IPV6 NH from tpm_start_db
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_mib_reset.
+*******************************************************************************/
+static int tpm_prs_spec_ipv6nh_reset(void)
+{
+	/* TBD, wait for LSP API */
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_tpid_comb_init()
+*
+* DESCRIPTION: The API will init parser with VLAN TPID supported from tpm_start_db
+*
+* INPUTS:   None
+*
+* OUTPUTS:
+*           None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_prs_init.
+*******************************************************************************/
+static int tpm_prs_tpid_comb_init(void)
+{
+	int ret_code;
+	int i;
+	struct tpm_tpid_combo_t tpid_comb;
+
+	/* Clear Original tpid comb from LSP */
+	/* del double VLAN: 0x8100, 0x88A8 */
+	if (mvPp2PrsDoubleVlan(MV_VLAN_TYPE, MV_VLAN_1_TYPE, PORT_MASK, TPM_PRS_TPID_COMB_DEL)) {
+		TPM_OS_WARN(TPM_PRS_MOD, "No original double VLAN(TPID:0x%x, 0x%x) entry to delete\n",
+			    MV_VLAN_TYPE,
+			    MV_VLAN_1_TYPE);
+	}
+
+	/* del double VLAN: 0x8100, 0x8100 */
+	if (mvPp2PrsDoubleVlan(MV_VLAN_TYPE, MV_VLAN_TYPE, PORT_MASK, TPM_PRS_TPID_COMB_DEL)) {
+		TPM_OS_WARN(TPM_PRS_MOD, "No original double VLAN(TPID:0x%x, 0x%x) entry to delete\n",
+			    MV_VLAN_TYPE,
+			    MV_VLAN_TYPE);
+	}
+
+	/* del single VLAN: 0x88a8 */
+	if (mvPp2PrsSingleVlan(MV_VLAN_1_TYPE, PORT_MASK, TPM_PRS_TPID_COMB_DEL))
+		TPM_OS_WARN(TPM_PRS_MOD, "No original Single VLAN(TPID:0x%x) entry to delete\n", MV_VLAN_1_TYPE);
+
+	/* del single VLAN: 0x8100 */
+	if (mvPp2PrsSingleVlan(MV_VLAN_TYPE, PORT_MASK, TPM_PRS_TPID_COMB_DEL))
+		TPM_OS_WARN(TPM_PRS_MOD, "No original Single VLAN(TPID:0x%x) entry to delete\n", MV_VLAN_TYPE);
+
+	/* Add TPID comb according to user init */
+	/* Double VLAN add */
+	for (i = 0; i < TPM_NUM_MAX_TPID_COMBO; i++) {
+		ret_code = tpm_db_init_tpid_combo_get(i, &tpid_comb);
+		if (ret_code != TPM_OK) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "TPID Comb Info get fail\n");
+			return TPM_GET_ERROR;
+		}
+		if (tpid_comb.valid == true &&
+		    tpid_comb.tpid2 != TPM_INVALID_TPID) {
+			ret_code = mvPp2PrsDoubleVlan(tpid_comb.tpid1,
+						      tpid_comb.tpid2,
+						      PORT_MASK,
+						      TPM_PRS_TPID_COMB_ADD);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "Double VLAN(TPID:0x%x, 0x%x) add failed\n",
+					     tpid_comb.tpid1,
+					     tpid_comb.tpid2);
+				return TPM_HW_ERROR;
+			}
+		}
+	}
+
+	/* Single VLAN */
+	for (i = 0; i < TPM_NUM_MAX_TPID_COMBO; i++) {
+		ret_code = tpm_db_init_tpid_combo_get(i, &tpid_comb);
+		if (ret_code != TPM_OK) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "TPID Comb Info get fail\n");
+			return TPM_GET_ERROR;
+		}
+		if (tpid_comb.valid == true &&
+		    tpid_comb.tpid2 == TPM_INVALID_TPID) {
+			ret_code = mvPp2PrsSingleVlan(tpid_comb.tpid1,
+						      PORT_MASK,
+						      TPM_PRS_TPID_COMB_ADD);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "Single VLAN(TPID:0x%x) add failed\n",
+					     tpid_comb.tpid1);
+				return TPM_HW_ERROR;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_tpid_comb_reset()
+*
+* DESCRIPTION: The API will reset parser with VLAN TPID supported from tpm_start_db
+*
+* INPUTS:   None
+*
+* OUTPUTS:
+*           None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_mib_reset.
+*******************************************************************************/
+static int tpm_prs_tpid_comb_reset(void)
+{
+	int ret_code;
+	int i;
+	struct tpm_tpid_combo_t tpid_comb;
+
+	/* Double VLAN del */
+	for (i = 0; i < TPM_NUM_MAX_TPID_COMBO; i++) {
+		ret_code = tpm_db_init_tpid_combo_get(i, &tpid_comb);
+		if (ret_code != TPM_OK) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "TPID Comb Info get fail\n");
+			return TPM_GET_ERROR;
+		}
+		if (tpid_comb.valid == true &&
+		    tpid_comb.tpid2 != TPM_INVALID_TPID) {
+			ret_code = mvPp2PrsDoubleVlan(tpid_comb.tpid1,
+						      tpid_comb.tpid2,
+						      PORT_MASK,
+						      TPM_PRS_TPID_COMB_DEL);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "Double VLAN(TPID:0x%x, 0x%x) del failed\n",
+					     tpid_comb.tpid1,
+					     tpid_comb.tpid2);
+				return TPM_HW_ERROR;
+			}
+		}
+	}
+
+	/* Single VLAN del */
+	for (i = 0; i < TPM_NUM_MAX_TPID_COMBO; i++) {
+		ret_code = tpm_db_init_tpid_combo_get(i, &tpid_comb);
+		if (ret_code != TPM_OK) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "TPID Comb Info get fail\n");
+			return TPM_GET_ERROR;
+		}
+		if (tpid_comb.valid == true &&
+		    tpid_comb.tpid2 == TPM_INVALID_TPID) {
+			ret_code = mvPp2PrsSingleVlan(tpid_comb.tpid1,
+						      PORT_MASK,
+						      TPM_PRS_TPID_COMB_DEL);
+			if (ret_code) {
+				TPM_OS_ERROR(TPM_PRS_MOD, "Single VLAN(TPID:0x%x) del failed\n", tpid_comb.tpid1);
+				return TPM_HW_ERROR;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_unexp_lu_id_op
+*
+* DESCRIPTION: The API will add/del unexpected packet lookup ID rule in parser.
+*
+* INPUTS:
+*           unexp_en    - enable(add) or diable(delete) the rule
+*                       1: enable;
+*                       0: disable
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is a debug way, used in running phase.
+*******************************************************************************/
+int tpm_prs_unexp_lu_id_op(int unexp_en)
+{
+	int ret_code;
+	int tcam_idx = 0;
+	struct tpm_prs_lu_id_t lu_id_data;
+
+	/* Para check */
+	if (TPM_PRS_UNEXPECTED_DIS != unexp_en &&
+	    TPM_PRS_UNEXPECTED_EN != unexp_en) {
+		TPM_OS_ERROR(TPM_PRS_MOD, "Invalid Unexpected packet operation(%d)\n", unexp_en);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Get LU_ID info from TPM DB */
+	ret_code = tpm_db_prs_lu_id_get(UNEXPECTED_PKT, &lu_id_data);
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "LU_ID info of Traffic Type(%d) get failed\n", UNEXPECTED_PKT);
+
+	/* delete rule */
+	if (unexp_en == TPM_PRS_UNEXPECTED_DIS) {
+		if (lu_id_data.valid == TPM_PRS_LU_ID_ENTRY_INV) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "Unexpected rule is not added\n");
+			return TPM_BAD_PARAM;
+		}
+		if (mvPp2PrsHwInv(lu_id_data.prs_idx)) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "Parser rule delete failed\n");
+			return TPM_HW_ERROR;
+		}
+	} else if (unexp_en == TPM_PRS_UNEXPECTED_EN) {
+		if (lu_id_data.valid == TPM_PRS_LU_ID_ENTRY_VALID) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "Unexpected rule is already exist\n");
+			return TPM_ALREADY_EXIST;
+		}
+		/* Get first, free entry,  Go through the all entires from first to last */
+		tcam_idx = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+		if (tcam_idx > MV_PP2_PRS_TCAM_SIZE - 1) {
+			TPM_OS_ERROR(TPM_PRS_MOD, "No free TCAM entry for traffic(%d)\n", UNEXPECTED_PKT);
+			return TPM_NO_RESOURCE;
+		}
+		ret_code = mvPrsFlowIdGen(tcam_idx,
+					  lu_id_data.lu_id,
+					  lu_id_data.prs_result.prs_ri,
+					  lu_id_data.prs_result.prs_ri_mask,
+					  PORT_MASK);
+		IF_ERROR_STR(TPM_PRS_MOD, ret_code, "Parser rule add fail for traffic(%d)\n", UNEXPECTED_PKT);
+	}
+	/* Update tpm_db */
+	lu_id_data.valid = (unexp_en ? TPM_PRS_LU_ID_ENTRY_VALID : TPM_PRS_LU_ID_ENTRY_INV);
+	lu_id_data.prs_idx = (unexp_en ? tcam_idx : TPM_PRS_INV_TCAM_IDX);
+	ret_code = tpm_db_prs_lu_id_set(UNEXPECTED_PKT, &lu_id_data);
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPM db update fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_reset()
+*
+* DESCRIPTION: The API will reset parser
+*
+* INPUTS:   None
+*
+* OUTPUTS:
+*           None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_mib_reset.
+*******************************************************************************/
+int tpm_prs_reset(void)
+{
+	int ret_code;
+
+	/* reset lu_id */
+	ret_code = tpm_prs_lu_id_reset();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPM parser lu_id reset failed\n");
+
+	/* reset special ipv6 nh */
+	ret_code = tpm_prs_spec_ipv6nh_reset();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPM parser special IPV6 NH reset failed\n");
+
+	/* reset tpid comb */
+	ret_code = tpm_prs_tpid_comb_reset();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPM TPID Comb reset failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_prs_init
+*
+* DESCRIPTION: The API will config parser with info from tpm_start_db.
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+*           Void
+*
+* COMMENTS:
+*           It is called by tpm_start, after tpm_start_db is configured.
+*******************************************************************************/
+int tpm_prs_init(void)
+{
+	int ret_code;
+
+	/* Add TPID comb parser rule */
+	ret_code = tpm_prs_tpid_comb_init();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "TPID comb parse rule init failed\n");
+
+	/* Add IPV6 Special NH parser rule */
+	ret_code = tpm_prs_spec_ipv6nh_init();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "Special IPV6 NH parse rule init failed\n");
+
+	/* Add Classifier Lookup ID generation parser rules */
+	ret_code = tpm_prs_lu_id_init();
+	IF_ERROR_STR(TPM_PRS_MOD, ret_code, "Classifier lookup ID Generation rule init failed\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
new file mode 100644
index 0000000..cc8925e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_pme.c
@@ -0,0 +1,3282 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+static int tpm_pme_hw_entry_write(unsigned int hw_idx, struct tpm_pme_entry_t *pme_entry);
+
+/* ============================== Usecase Instruction Template Section=================== */
+
+/* 1) Usecase: NO_USER_MOD
+*/
+
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_no_mod[] = {
+	/* NONE_T1_MOD, NONE_T5_MOD */
+	{
+		      /*    <opcode>                 <mod_data><last><ip4updt><L4updt><CmdType>               */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,            0x0,        1,     0,      0,      1 },/* MH Operation  */
+		      },
+	.ext_mod_bm = 0x0,
+	.int_mod_bm = TPM_MH_T1_MOD,
+	.qos_permu = 2,/* Qos, Type1 and Type5 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* NONE_DS_GMAC1_MOD */
+	{
+		      /*    <opcode>                 <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,        0x1,        1,     0,      0,      0 },/* Delete MH */
+		      },
+	.ext_mod_bm = 0x0,
+	.int_mod_bm = TPM_MH_DEL,
+	.qos_permu = 1,/* No care Qos*/
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+#endif
+
+};
+
+/* 2) Usecase: L2_Switching
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_l2_switch[] = {
+	/* L2_IPV4_DSCP_T1_MOD, L2_IPV4_DSCP_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP       */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_SKIP,            0x8,        0,     0,      0,      0 },/* To IPV4 Checksum  */
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD | TPM_IP_DSCP_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+	/* L2_IPV6_DSCP_T1_MOD, L2_IPV6_DSCP_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        1,     0,      0,      1 },/* Replace DSCP      */
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD | TPM_IP_DSCP_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+	/* L2_VLAN_T1_MOD, L2_VLAN_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x0,        1,     0,      0,      0 },/* End, make no sense*/
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD,
+	.int_mod_bm = TPM_MH_T1_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type4 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* L2_DS_IPV4_DSCP_T1_GMAC1_MOD, L2_DS_IPV4_DSCP_T5_GMAC1_MOD	*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* Replace MH        */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_SKIP,            0x8,        0,     0,      0,      0 },/* To IPV4 Checksum  */
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD | TPM_IP_DSCP_SET,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+	/* L2_DS_IPV6_DSCP_T1_GMAC1_MOD, L2_DS_IPV6_DSCP_T5_GMAC1_MOD	*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        1,     0,      0,      1 },/* Replace DSCP      */
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD | TPM_IP_DSCP_SET,
+	.int_mod_bm = TPM_MH_DEL | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+	/* L2_DS_VLAN_GMAC1_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to VLAN      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x0,        1,     0,      0,      0 },/* End               */
+		      },
+	.ext_mod_bm = TPM_VLAN_MOD,
+	.int_mod_bm = TPM_MH_DEL,
+	.qos_permu = 1,
+	.ppoe_num = 1/* No make sense, just compatiable with IPV4 NAPT */
+	},
+#endif
+};
+
+/* 3) Usecase: IPV4_NAPT
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_ipv4_napt[] = {
+	/* IPV4_US_NAPT_T1_MOD,  IPV4_US_NAPT_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SIP */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to SRC_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace SRC_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xE,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	.ip_rep_info = 0x308
+	},
+	/* IPV4_US_NAPT_PPOEx_T1_MOD,  IPV4_US_NAPT_PPOEx_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_PPPOE,           0x0,        0,     0,      0,      0 },/* AddPPPoE,ID update late*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SIP */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to SRC_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace SRC_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xE,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5, MH and DSCP */
+	.ppoe_num = TPM_PPOE_SESS_ALLOWED_MAX,/* Support 5 PPPoE connection */
+	.mac_rep_info = 0x2010202,
+	.ip_rep_info = 0x308
+	},
+	/* IPV4_DS_NAPT_T1_MOD,  IPV4_DS_NAPT_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x3F,      0,     0,      0,      0 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to DIP       */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DIP */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DST_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace DST_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010302,
+	.ip_rep_info = 0x3090000
+	},
+	/* IPV4_DS_NAPT_RM_PPOE_T1_MOD,  IPV4_DS_NAPT_RM_PPOE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x3F,      0,     0,      0,      0 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to DIP       */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DIP */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DST_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace DST_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010302,
+	.ip_rep_info = 0x30A0000
+	},
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* IPV4_DS_NAPT_T1_GMAC1_MOD,  IPV4_DS_NAPT_T5_GMAC1_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to DIP       */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DIP */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DST_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace DST_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010302,
+	.ip_rep_info = 0x3090000
+	},
+	/* IPV4_ DS_NAPT_PPOE_T1_GMAC1_MOD,  IPV4_ DS_NAPT_PPOE_T5_GMAC1_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        0,     0,      0,      0 },/* Update IPV4 Checksum */
+		       {TPM_PME_CMD_SKIP,            0x4,        0,     0,      0,      0 },/* Skip to DIP       */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DIP */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DST_PORT  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0,        0,     0,      1,      1 },/* Replace DST_PORT  */
+		       {TPM_PME_CMD_SKIP,            0xC,        0,     0,      0,      0 },/* Skip to L4 Checksum*/
+		       {TPM_PME_CMD_L4_CSUM,         0x0,        1,     1,      1,      0 },/* Update L4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL |
+		      TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD | TPM_L4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010302,
+	.ip_rep_info = 0x30A0000
+	},
+#endif
+};
+
+/* 4) Usecase: IPV4_UNI_ROUTE
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_ipv4_route[] = {
+	/* IPV4_ROUTE_T1_MOD,  IPV4_ROUTE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+	/* IPV4_US_ROUTE_PPOE_T1_MOD,  IPV4_US_ROUTE_PPOE_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_PPPOE,           0x1,        0,     0,      0,      0 },/* AddPPPoE,sessID private*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_ADD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5, MH and DSCP */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+	/* IPV4_DS_ROUTE_PPOE_T1_MOD,  IPV4_DS_ROUTE_PPOE_T4_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,            0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* IPV4_DS_ROUTE_T1_GMAC1_MOD,  IPV4_DS_ROUTE_T5_GMAC1_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+	/* IPV4_DS_ROUTE_PPOE_T1_GMAC1_MOD,  IPV4_DS_ROUTE_PPOE_T5_GMAC1_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type4 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+#endif
+};
+
+/* 5) Usecase: IPV6_UNI_ROUTE
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_ipv6_route[] = {
+	/* IPV6_ROUTE_T1_MOD and IPV6_ROUTE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec HOP, first skip 2*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+	/* IPV6_US_ROUTE_PPOE_T1_MOD,  IPV6_US_ROUTE_PPOE_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_PPPOE_2,         0x1,        0,     0,      0,      0 },/* AddPPPoE,sessID private*/
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec HOP, first skip 3*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_ADD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5, MH and DSCP */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+	/* IPV6_DS_ROUTE_PPOE_T1_MOD,  IPV6_DS_ROUTE_PPOE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x86dd,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec TTL, first skip 3*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* IPV6_DS_ROUTE_T1_GMAC1_MOD,  IPV6_DS_ROUTE_T5_GMAC1_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec HOP, first skip 2*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+
+	/* IPV6_DS_ROUTE_PPOE_T1_GMAC1_MOD,  IPV6_DS_ROUTE_PPOE_T5_GMAC1_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x86dd,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec TTL, first skip 3*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x2010202,
+	},
+#endif
+};
+
+/* 6) Usecase: IPV4_MULTICAST
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_ipv4_mc[] = {
+	/* IPV4_MC_ROUTE_T1_MOD,  IPV4_MC_ROUTE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0x6,        0,     0,      0,      0 },/* Skip to SA        */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x202,
+	},
+	/* IPV4_MC_ROUTE_PPOE_T1_MOD, IPV4_MC_ROUTE_PPOE_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x1010202,
+	},
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* IPV4_MC_ROUTE_T1_GMAC1_MOD,  IPV4_MC_ROUTE_T5_GMAC1_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Delete         */
+		       {TPM_PME_CMD_SKIP,            0x6,        0,     0,      0,      0 },/* Skip to SA        */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x202,
+	},
+	/* IPV4_MC_ROUTE_PPOE_T1_GMAC1_MOD,  IPV4_MC_ROUTE_PPOE_T5_GMAC1_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x0800,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_LSB,     0x0,        0,     1,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_MSB,         0x300,      0,     1,      0,      0 },/* Dec TTL, first skip 3*/
+		       {TPM_PME_CMD_IPV4_CSUM,       0x0,        1,     0,      0,      0 },/* Update IPV4 Checksum */
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_IPV4_CHECK_MOD,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x1010202,
+	},
+#endif
+};
+
+/* 7) Usecase: IPV6_MULTICAST
+*/
+static struct tpm_pme_templ_pattern_t g_tpm_pme_templ_ipv6_mc[] = {
+	/* IPV6_MC_ROUTE_T1_MOD and IPV6_MC_ROUTE_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_SKIP,            0x6,        0,     0,      0,      0 },/* Skip to SA        */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec HOP, first skip 2*/
+		      },
+	.ext_mod_bm = TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x202,
+	},
+	/* IPV6_MC_ROUTE_PPOE_T1_MOD,  IPV6_MC_ROUTE_PPOE_T5_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_MH_OP,           0x0,        0,     0,      0,      1 },/* MH Operation      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x86dd,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec TTL, first skip 3*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_T1_MOD | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x1010202,
+	},
+#ifndef CONFIG_MV_ETH_PP2_1
+	/* IPV6_MC_ROUTE_T1_MOD and IPV6_MC_ROUTE_T5_MOD */
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Delete         */
+		       {TPM_PME_CMD_SKIP,            0x6,        0,     0,      0,      0 },/* Skip to SA        */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_SKIP,            0x2,        0,     0,      0,      0 },/* Skip to DSCP      */
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec HOP, first skip 2*/
+		      },
+	.ext_mod_bm = TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x202,
+	},
+	/* IPV6_MC_ROUTE_PPOE_T1_GMAC1_MOD, IPV6_MC_ROUTE_PPOE_T1_GMAC1_MOD*/
+	{
+		      /*    <opcode>                <mod_data><last><ip4updt><L4updt><CmdType>           */
+	.pme_entry = {{TPM_PME_CMD_DEL_BYTES,       0x1,        0,     0,      0,      0 },/* MH Delete      */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, DA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      0 },/* Jmp rep_addr subr, SA */
+		       {TPM_PME_CMD_JUMP_SUB,        0x0,        0,     0,      0,      1 },/* Jmp to VLAN Subr  */
+		       {TPM_PME_CMD_REPLACE_2B,      0x86dd,     0,     0,      0,      0 },/* Replace ether type  */
+		       {TPM_PME_CMD_DEL_BYTES,       0x04,       0,     0,      0,      0 },/* Delete PPoE 8 Bytes*/
+		       {TPM_PME_CMD_REPLACE_MID,     0x0,        0,     0,      0,      1 },/* Replace DSCP      */
+		       {TPM_PME_CMD_DEC_LSB,         0x200,      1,     0,      0,      0 },/* Dec TTL, first skip 3*/
+		      },
+	.ext_mod_bm = TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD |
+		      TPM_PPOE_DEL | TPM_IP_DSCP_SET | TPM_TTL_HOPL_DEC,
+	.int_mod_bm = TPM_MH_DEL | TPM_MOD_PKT_IS_IP6,
+	.qos_permu = 2,/* 2 CMD type case considered, Type1 and Type5 */
+	.ppoe_num = 1,/* No make sense, just compatiable with IPV4 NAPT */
+	.mac_rep_info = 0x1010202,
+	},
+#endif
+
+};
+
+
+/* ============================== Sub-routine Template Section=========================== */
+/* MAC/IP address replacement Pattern  */
+static struct tpm_pme_entry_t g_tpm_pme_addr_rep_pattern[REPLACE_ADDR_OP_MAX][TPM_PME_ADDR_REP_ENTRY_MAX] = {
+
+	/* REPLACE_ADDR_MAC_T1             -        Replace MAC, storded in private data       */
+	/*    <opcode>                     <mod_data><last><ip4updt><L4updt><CmdType>          */
+	{{TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      1 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      1 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        1,     0,      0,      1 },
+	},
+	/* REPLACE_ADDR_MAC_T2             -        Replace MAC, storded in share data         */
+	/*    <opcode>                     <mod_data><last><ip4updt><L4updt><CmdType>          */
+	{{TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      2 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      3 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        1,     0,      0,      3 },
+	},
+	/* REPLACE_ADDR_MAC_T3             -        Init by T2 cmd, storded in share data      */
+	/*    <opcode>                     <mod_data><last><ip4updt><L4updt><CmdType>          */
+	{{TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      3 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        0,     0,      0,      3 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        1,     0,      0,      3 },
+	},
+	/* REPLACE_ADDR_IP_T3              -        Init by T2 cmd, storded in share data      */
+	/*    <opcode>                     <mod_data><last><ip4updt><L4updt><CmdType>          */
+	{{TPM_PME_CMD_REPLACE_2B,           0x0,        0,     1,      1,      3 },
+	 {TPM_PME_CMD_REPLACE_2B,           0x0,        1,     1,      1,      3 },
+	}
+};
+
+/* VLAN OPeration Pattern with Skip */
+/* NOTE: When adding VLAN subr, only mod_data and cmd_type need update, others keep no change */
+static struct tpm_pme_vlan_skip_entry_t g_tpm_pme_vlan_pattern = {
+	/* VLAN Operation Array */
+	{
+		/* VLANOP_NOOP                 -        NO VLAN operation performed */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_NONE,           0xFFFF,    0,     0,      0,      0 } },  /* VLAN1 */
+		},
+
+		/* VLANOP_EXT_TAG_MOD          -        Modify external tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } },  /* VLAN1 */
+		},
+
+		/* VLANOP_EXT_TAG_DEL          -        Delete external tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_DEL_BYTES,      0x0002,    0,     0,      0,      0 } },  /* VLAN1 */
+		},
+
+		/* VLANOP_EXT_TAG_INS          -        Insert(prepend) external tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_ADD_VLAN,       0x0000,    0,     0,      0,      1 } },  /* VLAN1 */
+		},
+
+		/* VLANOP_EXT_TAG_MOD_INS      -        Mod exist ex-tag and insert(prepend) new tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_ADD_VLAN,       0x0000,    0,     0,      0,      1 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } }   /* VLAN2 */
+		},
+
+		/* VLANOP_INS_2TAG             -        Insert(prepend) 2 new tags */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_ADD_VLAN,       0x0000,    0,     0,      0,      1 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_ADD_VLAN,       0x0000,    0,     0,      0,      1 } }   /* VLAN2 */
+		},
+
+		/* VLANOP_MOD_2TAG             -        Modify 2 tags */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } }   /* VLAN2 */
+		},
+
+		/* VLANOP_SWAP_TAGS            -        Swap internal and external tags */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      0 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      0 } }   /* VLAN2 */
+		},
+
+		/* VLANOP_DEL_2TAG             -        Delete 2 existing tags */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_DEL_BYTES,      0x0002,    0,     0,      0,      0 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_DEL_BYTES,      0x0002,    0,     0,      0,      0 } },  /* VLAN2 */
+		},
+
+		/* VLANOP_INT_TAG_MOD          -        Modify existing internal tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_SKIP,           0x0004,    0,     0,      0,      0 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } }   /* VLAN2 */
+		},
+
+		/* VLANOP_EXT_TAG_DEL_INT_MOD  -        Delete existing external tag and modify internal tag */
+		/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+		{{{TPM_PME_CMD_DEL_BYTES,      0x0002,    0,     0,      0,      0 } },  /* VLAN1 */
+		 {{TPM_PME_CMD_CFG_VLAN,       0xFFFF,    0,     0,      0,      0 },
+		  {TPM_PME_CMD_REPLACE_VLAN,   0x0000,    0,     0,      0,      1 } }   /* VLAN2 */
+		},
+	},
+	/* Skip to Ether Type */
+	/*    <opcode>              <mod_data><last><ip4updt><L4updt><CmdType>          */
+	{TPM_PME_CMD_SKIP,           0xFFFF,    1,     0,      0,        0 } /* SKIP */
+};
+
+/* VLAN template permutation factors count, for real out VLAN */
+static struct tpm_pme_vlan_skip_permu_t g_vlan_subr_permu[VLANOP_MAX_CNT] = {
+	/*<ppoe><qos><tpid><vid><cfi><pbit><dummy1><dummy2>*/
+	{   2,    1,    1,   1,   1,   1,     0,      0},/* VLANOP_NOOP, 2 */
+	{   2,    2,    3,   2,   1,   2,     0,      0},/* VLANOP_EXT_TAG_MOD, 48 */
+	{   2,    1,    1,   1,   1,   1,     0,      0},/* VLANOP_EXT_TAG_DEL, 2 */
+	{   2,    2,    3,   2,   1,   2,     0,      0},/* VLANOP_EXT_TAG_INS, 48 */
+	{   2,    2,    3,   2,   1,   2,     0,      0},/* VLANOP_EXT_TAG_MOD_INS, 48 */
+	{   2,    2,    3,   2,   1,   2,     0,      0},/* VLANOP_INS_2TAG, 48 */
+	{   2,    2,    1,   2,   1,   2,     0,      0},/* VLANOP_MOD_2TAG, 16 */
+	{   2,    1,    1,   1,   1,   1,     0,      0},/* VLANOP_SWAP_TAGS, 2 */
+	{   2,    1,    1,   1,   1,   1,     0,      0},/* VLANOP_DEL_2TAG, 2 */
+	{   2,    2,    3,   2,   1,   2,     0,      0},/* VLANOP_INT_TAG_MOD, 48 */
+	{   2,    2,    3,   2,   1,   2,     0,      0} /* VLANOP_EXT_TAG_DEL_INT_MOD, 48 */
+};
+
+
+/*******************************************************************************
+* tpm_pme_vlan_pattern_parse()
+*
+* DESCRIPTION: Parse the VLAN OP pattern array according to VLAN Ops
+*
+* INPUTS:
+*          vlan_op          - VLAN Operation Code
+* OUTPUTS:
+*          pme_sw_entry     - Valid PME command entry array
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_vlan_pattern_parse(enum tpm_pme_vlan_oper_t vlan_op,
+				      struct tpm_pme_entry_t pme_sw_entry[])
+{
+	int rc;
+	unsigned int valid_entry_num = 0;
+
+	/* Parameter Check */
+	IF_NULL(TPM_PME_MOD, pme_sw_entry);
+	if (vlan_op >= VLANOP_MAX_CNT) {
+		rc = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Invalid VLAN OP code (%d)\n", vlan_op);
+	}
+
+	if (g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan1[TPM_VLAN_OP_PARA0].opcode == TPM_PME_CMD_NONE) {
+		/* Skip entry */
+		memcpy(&pme_sw_entry[valid_entry_num],
+		       &g_tpm_pme_vlan_pattern.skip,
+		       sizeof(struct tpm_pme_entry_t));
+		valid_entry_num++;
+	} else {
+		/* VLAN1 First entry */
+		memcpy(&pme_sw_entry[valid_entry_num],
+		       &g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan1[TPM_VLAN_OP_PARA0],
+		       sizeof(struct tpm_pme_entry_t));
+		valid_entry_num++;
+		/* VLAN1 Second entry */
+		if (g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan1[TPM_VLAN_OP_PARA1].opcode) {
+			memcpy(&pme_sw_entry[valid_entry_num],
+			       &g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan1[TPM_VLAN_OP_PARA1],
+			       sizeof(struct tpm_pme_entry_t));
+			valid_entry_num++;
+		}
+		/* VLAN2 First entry */
+		if (g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan2[TPM_VLAN_OP_PARA0].opcode) {
+			memcpy(&pme_sw_entry[valid_entry_num],
+			       &g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan2[TPM_VLAN_OP_PARA0],
+			       sizeof(struct tpm_pme_entry_t));
+			valid_entry_num++;
+		}
+		/* VLAN2 Second entry */
+		if (g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan2[TPM_VLAN_OP_PARA1].opcode) {
+			memcpy(&pme_sw_entry[valid_entry_num],
+			       &g_tpm_pme_vlan_pattern.entry_array[vlan_op].vlan2[TPM_VLAN_OP_PARA1],
+			       sizeof(struct tpm_pme_entry_t));
+			valid_entry_num++;
+		}
+		/* Skip entry */
+		memcpy(&pme_sw_entry[valid_entry_num],
+		       &g_tpm_pme_vlan_pattern.skip,
+		       sizeof(struct tpm_pme_entry_t));
+		valid_entry_num++;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_vlan_permu_parse()
+*
+* DESCRIPTION: Parse the VLAN template permutation
+*
+* INPUTS:
+*          vlan_op          - VLAN Operation Code
+*          vlan_permu       - VLAN permutation
+*          pme_sw_entry     - Valid PME command entry array
+* OUTPUTS:
+*          pme_sw_entry     - Valid PME command entry array
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_vlan_permu_parse(enum tpm_pme_vlan_oper_t vlan_op,
+				    struct tpm_pme_vlan_skip_permu_t vlan_permu,
+				    struct tpm_pme_entry_t pme_sw_entry[])
+{
+	int rc;
+	unsigned short vlan_cfg_data = 0x0;
+	int i;
+
+	/* The array contain the length skip to ethertye after VLAN Op,
+	* calculated with format: L3_off-current_off-2(Ethertype)-8(PPPoE)
+	* No need to update except new operation is added, order as following:
+	* VLAN_NOOP
+	* VLANOP_EXT_TAG_MOD
+	* VLANOP_EXT_TAG_DEL
+	* VLANOP_EXT_TAG_INS
+	* VLANOP_EXT_TAG_MOD_INS
+	* VLANOP_INS_2TAG
+	* VLANOP_MOD_2TAG
+	* VLANOP_SWAP_TAGS
+	* VLANOP_DEL_2TAG
+	* VLANOP_INT_TAG_MOD
+	* VLANOP_EXT_TAG_DEL_INT_MOD
+	*/
+	static unsigned short tpm_pme_vlan_skip_ety_len[TPM_PME_PPPOE_PERMU_MAX][VLANOP_MAX_CNT] = {
+		{0x2210, 0x2214, 0x2214, 0x2210, 0x2214, 0x2210, 0x2218, 0x2218, 0x2218, 0x2218, 0x2218},
+		{0x2218, 0x221C, 0x221C, 0x2218, 0x221C, 0x2218, 0x2220, 0x2220, 0x2220, 0x2220, 0x2220}
+	};
+
+	/* Supported VLAN TPID src */
+	static unsigned short tpm_pme_tpid_permu[TPM_VLAN_ETY_LOG_MAX] = {
+		TPM_VLAN_ETY_VLAN1 << TPM_PME_ETY_OFFS,
+		TPM_VLAN_ETY_REG0 << TPM_PME_ETY_OFFS,
+		TPM_VLAN_ETY_REG1 << TPM_PME_ETY_OFFS
+	};
+
+	/* Supported VLAN VID src */
+	static unsigned short tpm_pme_vid_permu[TPM_VLAN_VID_LOG_MAX] = {
+		TPM_VLAN_VID_VLAN1 << TPM_PME_VID_OFFS,
+		TPM_VLAN_VID_NEW << TPM_PME_VID_OFFS
+	};
+
+	/* Supported VLAN Pbit src */
+	static unsigned short tpm_pme_pbit_permu[TPM_VLAN_PBIT_LOG_MAX] = {
+		TPM_VLAN_PBIT_VLAN1 << TPM_PME_PBIT_OFFS,
+		TPM_VLAN_PBIT_NEW << TPM_PME_PBIT_OFFS
+	};
+
+	/* Parameter Check */
+	IF_NULL(TPM_PME_MOD, pme_sw_entry);
+	if (vlan_op >= VLANOP_MAX_CNT) {
+		rc = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Invalid VLAN OP code (%d)\n", vlan_op);
+	}
+
+	/* QOS src, cmd type update */
+	if (g_vlan_subr_permu[vlan_op].qos_src == TPM_PME_QOS_MAX) {/* Need consider QOS source */
+		if (vlan_permu.qos_src == TPM_PME_QOS_DESC) {/* Cmd type5 */
+			if (vlan_op == VLANOP_EXT_TAG_MOD ||
+			    vlan_op == VLANOP_EXT_TAG_INS)
+				pme_sw_entry[1].cmd_type = TPM_PME_CMD_TYPE5;
+
+			if (vlan_op == VLANOP_EXT_TAG_MOD_INS ||
+			    vlan_op == VLANOP_INS_2TAG ||
+			    vlan_op == VLANOP_MOD_2TAG) {
+				pme_sw_entry[1].cmd_type = TPM_PME_CMD_TYPE5;
+				pme_sw_entry[3].cmd_type = TPM_PME_CMD_TYPE5;
+			}
+
+			if (vlan_op == VLANOP_INT_TAG_MOD ||
+			    vlan_op == VLANOP_EXT_TAG_DEL_INT_MOD)
+				pme_sw_entry[2].cmd_type = TPM_PME_CMD_TYPE5;
+		}
+	}
+
+	/* VLAN CFG_VLAN data update, permutation is supposed for OUT VLAN, inner vlan default new */
+	if (vlan_op == VLANOP_EXT_TAG_MOD ||
+	    vlan_op == VLANOP_EXT_TAG_INS ||
+	    vlan_op == VLANOP_EXT_TAG_MOD_INS ||
+	    vlan_op == VLANOP_INS_2TAG ||
+	    vlan_op == VLANOP_MOD_2TAG) {
+		vlan_cfg_data = tpm_pme_tpid_permu[vlan_permu.tpid_sel] |
+				tpm_pme_vid_permu[vlan_permu.vid_sel] |
+				tpm_pme_pbit_permu[vlan_permu.pbit_sel];
+
+		pme_sw_entry[0].data = vlan_cfg_data;
+	}
+
+	/* Set inner VLAN_CFG */
+	if (vlan_op == VLANOP_EXT_TAG_MOD_INS ||
+	    vlan_op == VLANOP_INS_2TAG) {
+		pme_sw_entry[2].data = tpm_pme_tpid_permu[TPM_VLAN_ETY_LOG_REG1] |
+				       tpm_pme_vid_permu[TPM_VLAN_VID_LOG_NEW] |
+				       tpm_pme_pbit_permu[TPM_VLAN_PBIT_LOG_NEW];
+	}
+	if (vlan_op == VLANOP_MOD_2TAG) {
+		pme_sw_entry[2].data = (TPM_VLAN_ETY_VLAN2 << TPM_PME_ETY_OFFS) |/* inner tpid keep*/
+				       tpm_pme_vid_permu[TPM_VLAN_VID_LOG_NEW] |
+				       tpm_pme_pbit_permu[TPM_VLAN_PBIT_LOG_NEW];
+	}
+
+	/* Special Handle VLANOP_SWAP_TAGS */
+	if (vlan_op == VLANOP_SWAP_TAGS) {
+		pme_sw_entry[0].data = (TPM_VLAN_ETY_VLAN2 << TPM_PME_ETY_OFFS) |
+				       (TPM_VLAN_VID_VLAN2 << TPM_PME_VID_OFFS) |
+				       (TPM_VLAN_PBIT_VLAN2 << TPM_PME_PBIT_OFFS);
+
+		pme_sw_entry[2].data = (TPM_VLAN_ETY_VLAN1 << TPM_PME_ETY_OFFS) |
+				       (TPM_VLAN_VID_VLAN1 << TPM_PME_VID_OFFS) |
+				       (TPM_VLAN_PBIT_VLAN1 << TPM_PME_PBIT_OFFS);
+	}
+
+	/* Special Handle VLANOP_INT_TAG_MOD */
+	if (vlan_op == VLANOP_INT_TAG_MOD ||
+	    vlan_op == VLANOP_EXT_TAG_DEL_INT_MOD) {
+		pme_sw_entry[1].data = 0;
+		/* TPID */
+		if (vlan_permu.tpid_sel == TPM_VLAN_ETY_LOG_VLAN12)
+			pme_sw_entry[1].data |= (TPM_VLAN_ETY_VLAN2 << TPM_PME_ETY_OFFS);
+		else
+			pme_sw_entry[1].data |= tpm_pme_tpid_permu[vlan_permu.tpid_sel];
+		/* VID */
+		if (vlan_permu.vid_sel == TPM_VLAN_VID_LOG_VLAN12)
+			pme_sw_entry[1].data |= (TPM_VLAN_VID_VLAN2 << TPM_PME_VID_OFFS);
+		else
+			pme_sw_entry[1].data |= tpm_pme_vid_permu[vlan_permu.vid_sel];
+		/* PBIT */
+		if (vlan_permu.pbit_sel == TPM_VLAN_PBIT_LOG_VLAN12)
+			pme_sw_entry[1].data |= (TPM_VLAN_PBIT_VLAN2 << TPM_PME_PBIT_OFFS);
+		else
+			pme_sw_entry[1].data |= tpm_pme_pbit_permu[vlan_permu.pbit_sel];
+	}
+
+	/* PPPoE, Update Skip data to Ethertype */
+	if (g_vlan_subr_permu[vlan_op].pppoe == TPM_PME_PPPOE_PERMU_MAX) {
+		for (i = 0; i < TPM_VLAN_TEMPL_ENTRY_MAX_NUM; i++) {
+			if (pme_sw_entry[i].opcode == TPM_PME_CMD_SKIP &&
+			    pme_sw_entry[i].last == TPM_PME_CMD_LAST)
+				pme_sw_entry[i].data = tpm_pme_vlan_skip_ety_len[vlan_permu.pppoe][vlan_op];
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_hw_entry_write()
+*
+* DESCRIPTION: Write PME entry to HW
+*
+* INPUTS:
+*          hw_idx    - entry HW index
+*          pme_entry - PME command entry
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_hw_entry_write(unsigned int hw_idx, struct tpm_pme_entry_t *pme_entry)
+{
+	int rc;
+	MV_PP2_PME_ENTRY Entry;
+
+	IF_NULL(TPM_PME_MOD, pme_entry);
+
+	/* Get PME SW entry */
+	TPM_MEMSET_ZERO(Entry);
+	rc = mvPp2PmeSwCmdSet(&Entry, (int)pme_entry->opcode);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "set PME opcode failed\n");
+	rc = mvPp2PmeSwCmdTypeSet(&Entry, (int)pme_entry->cmd_type);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "set PME CMD type failed\n");
+	rc = mvPp2PmeSwCmdFlagsSet(&Entry, (int)pme_entry->last, (int)pme_entry->updt_ipv4, (int)pme_entry->updt_l4);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "set PME flags failed\n");
+	rc = mvPp2PmeSwCmdDataSet(&Entry, pme_entry->data);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "set PME modification data failed\n");
+
+	/* Write it to HW */
+	rc = mvPp2PmeHwWrite(hw_idx, &Entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Write PME Entry failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_one_vlan_templ_create()
+*
+* DESCRIPTION: Create one VLAN Subr template in HW and record it to DB
+*
+* INPUTS:
+*          vlan_op      - VLAn operation.
+*          vlan_permu   - VLAN Operation permutation factor
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_one_vlan_templ_create(enum tpm_pme_vlan_oper_t vlan_op,
+					 struct tpm_pme_vlan_skip_permu_t *vlan_permu)
+{
+	int rc;
+	struct tpm_pme_entry_t pme_entry[TPM_VLAN_TEMPL_ENTRY_MAX_NUM];
+	struct tpm_pme_vlan_subr_t vlan_subr_entry;
+	unsigned int first_free_cmd, vlan_db_idx;
+	int index;
+
+	/* Input parameter check */
+	IF_NULL(TPM_PME_MOD, vlan_permu);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PME_MOD, vlan_op, VLANOP_MAX_CNT - 1, "invalid VLAN Operation");
+
+	/* Clear SW entry array */
+	TPM_MEMSET_ZERO(pme_entry);
+	TPM_MEMSET_ZERO(vlan_subr_entry);
+
+	/* Get one VLAN permutation case */
+	rc = tpm_pme_vlan_pattern_parse(vlan_op, pme_entry);
+	IF_ERROR_STR(TPM_PME_MOD,
+		     rc,
+		     "VLAN Subr(%d) Pattern parse failed\n",
+		     vlan_op);
+	rc = tpm_pme_vlan_permu_parse(vlan_op,
+				      *vlan_permu,
+				      pme_entry);
+	IF_ERROR_STR(TPM_PME_MOD,
+		     rc,
+		     "VLAN Subr(%d) permu failed\n",
+		     vlan_op);
+
+	/* Write SW entry array to HW */
+	rc = tpm_db_pme_cmd_first_free_get(TPM_PME_CMD_AREA_SUBR,
+					   &first_free_cmd);
+	IF_ERROR_STR(TPM_PME_MOD,
+		     rc,
+		     "First free cmd get failed, type(%d)\n",
+		     TPM_PME_CMD_AREA_SUBR);
+
+	/* Record it to DB in following steps */
+	vlan_subr_entry.vlan_op = vlan_op;
+	vlan_subr_entry.start_idx = first_free_cmd;
+	memcpy(&vlan_subr_entry.vlan_permu,
+	       vlan_permu,
+	       sizeof(struct tpm_pme_vlan_skip_permu_t));
+	memcpy(vlan_subr_entry.pme_entry,
+	       pme_entry,
+	       sizeof(pme_entry));
+	vlan_subr_entry.valid = TPM_VLAN_SUBR_VALID;
+
+	/* Write HW */
+	for (index = 0; index < TPM_VLAN_TEMPL_ENTRY_MAX_NUM; index++) {
+		if (pme_entry[index].opcode == TPM_PME_CMD_NONE)
+			break;
+		rc = tpm_pme_hw_entry_write(first_free_cmd,
+					    &pme_entry[index]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Write PME failed\n");
+		first_free_cmd++;
+	}
+
+	/* Update first free cmd index in PME */
+	rc = tpm_db_pme_cmd_first_free_set(TPM_PME_CMD_AREA_SUBR,
+					   first_free_cmd);
+	IF_ERROR_STR(TPM_PME_MOD,
+		     rc,
+		     "First free cmd set failed, type(%d)\n",
+		     TPM_PME_CMD_AREA_SUBR);
+
+	/* Record Subr to DB */
+	rc = tpm_db_pme_vlan_free_idx_get(&vlan_db_idx);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Free VLAN DB Idx get failed\n");
+	if (vlan_db_idx == TPM_PME_INVALID_IDX) {
+		rc = TPM_FULL;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN DB Is Full\n");
+	}
+	rc = tpm_db_pme_vlan_subr_set(vlan_db_idx, &vlan_subr_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN DB Set Failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_each_vlan_templ_create()
+*
+* DESCRIPTION: Create VLAN Subr template in HW and record it to DB
+*
+* INPUTS:
+*          None
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_each_vlan_templ_create(int vlan_op_idx)
+{
+	int rc;
+	struct tpm_pme_vlan_skip_permu_t vlan_permu;
+	unsigned char ppoe_permu, qos_permu, tpid_permu, vid_permu, pbit_permu;
+	unsigned char ppoe_permu_max, qos_permu_max, tpid_permu_max, vid_permu_max, pbit_permu_max;
+
+	/* Get permutation information for each VLAN OP */
+	ppoe_permu_max = g_vlan_subr_permu[vlan_op_idx].pppoe;
+	qos_permu_max = g_vlan_subr_permu[vlan_op_idx].qos_src;
+	tpid_permu_max = g_vlan_subr_permu[vlan_op_idx].tpid_sel;
+	vid_permu_max = g_vlan_subr_permu[vlan_op_idx].vid_sel;
+	pbit_permu_max = g_vlan_subr_permu[vlan_op_idx].pbit_sel;
+	/* Tranverse VLAN permutation */
+	for (ppoe_permu = 0; ppoe_permu < ppoe_permu_max; ppoe_permu++) {
+		for (qos_permu = 0; qos_permu < qos_permu_max; qos_permu++) {
+			for (tpid_permu = 0; tpid_permu < tpid_permu_max; tpid_permu++) {
+				for (vid_permu = 0; vid_permu < vid_permu_max; vid_permu++) {
+					for (pbit_permu = 0; pbit_permu < pbit_permu_max; pbit_permu++) {
+						/* Initialize VLAN permutation */
+						vlan_permu.pppoe = ppoe_permu;
+						vlan_permu.qos_src = qos_permu;
+						vlan_permu.tpid_sel = tpid_permu;
+						vlan_permu.vid_sel = vid_permu;
+						vlan_permu.pbit_sel = pbit_permu;
+						/* Create the VLAN subroutine template */
+						rc = tpm_pme_one_vlan_templ_create(vlan_op_idx, &vlan_permu);
+						IF_ERROR_STR(TPM_PME_MOD,
+							     rc,
+							     "One template of VLAN Subr(%d) create failed\n",
+							     vlan_op_idx);
+					}
+				}
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_vlan_templ_create()
+*
+* DESCRIPTION: Create VLAN Subr template in HW and record it to DB
+*
+* INPUTS:
+*          None
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_vlan_templ_create(void)
+{
+	int rc;
+	int vlan_op_idx;
+
+	for (vlan_op_idx = VLANOP_NOOP; vlan_op_idx < VLANOP_MAX_CNT; vlan_op_idx++) {
+		rc = tpm_pme_each_vlan_templ_create(vlan_op_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "create vlan template failed\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_addr_rep_templ_create()
+*
+* DESCRIPTION: Create Address replacement template in HW and record it to DB
+*
+* INPUTS:
+*          None
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_addr_rep_templ_create(void)
+{
+	int rc;
+	int op_idx, entry_idx;
+	unsigned int first_free_idx, db_idx;
+	struct tpm_pme_addr_rep_subr_t addr_rep_subr;
+
+	for (op_idx = REPLACE_ADDR_MAC_T1; op_idx < REPLACE_ADDR_OP_MAX; op_idx++) {
+		TPM_MEMSET_ZERO(addr_rep_subr);
+		/* Find available entry */
+		rc = tpm_db_pme_cmd_first_free_get(TPM_PME_CMD_AREA_SUBR, &first_free_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "First free cmd get failed\n");
+		/* Record relevant info */
+		addr_rep_subr.addr_rep_op = op_idx;
+		addr_rep_subr.start_idx = first_free_idx;
+		addr_rep_subr.valid = TPM_ADDR_REP_SUBR_VALID;
+
+		for (entry_idx = 0; entry_idx < TPM_PME_ADDR_REP_ENTRY_MAX; entry_idx++) {
+			if (g_tpm_pme_addr_rep_pattern[op_idx][entry_idx].opcode == TPM_PME_CMD_REPLACE_2B) {
+				/* Write to HW */
+				rc = tpm_pme_hw_entry_write(first_free_idx,
+							    &g_tpm_pme_addr_rep_pattern[op_idx][entry_idx]);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Write PME failed\n");
+				first_free_idx++;
+				/* Record PME entry */
+				memcpy(&addr_rep_subr.pme_entry[entry_idx],
+				       &g_tpm_pme_addr_rep_pattern[op_idx][entry_idx],
+				       sizeof(struct tpm_pme_entry_t));
+			}
+		}
+		/* Update first free cmd index in PME */
+		rc = tpm_db_pme_cmd_first_free_set(TPM_PME_CMD_AREA_SUBR, first_free_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "First free cmd set failed, type(%d)\n", TPM_PME_CMD_AREA_SUBR);
+		/* Record to DB */
+		rc = tpm_db_pme_addr_rep_free_idx_get(&db_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Addr rep(%d) DB available entry get failed\n", op_idx);
+		if (db_idx == TPM_PME_INVALID_IDX) {
+			rc = TPM_FULL;
+			IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN DB Is Full\n");
+		}
+		rc = tpm_db_pme_addr_rep_subr_set(db_idx, &addr_rep_subr);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Addr rep(%d) DB set failed\n", op_idx);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_jmp_entry_allocate()
+*
+* DESCRIPTION: Assign one available JUMP area entry for a template
+*
+* INPUTS:
+*          templ_start_idx - the start index (jump to) of the template
+* OUTPUTS:
+*          jmp_idx         - the Jmp index allocated for template
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_jmp_entry_allocate(unsigned int templ_start_idx, unsigned int *jmp_idx)
+{
+	int rc;
+	unsigned int jmp_first_free;
+	struct tpm_pme_entry_t pme_jmp_entry;
+
+	IF_NULL(TPM_PME_MOD, jmp_idx);
+	TPM_MEMSET_ZERO(pme_jmp_entry);
+
+	rc = tpm_db_pme_cmd_first_free_get(TPM_PME_CMD_AREA_JMP, &jmp_first_free);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "First free jmp get failed, type(%d)\n", TPM_PME_CMD_AREA_JMP);
+
+	pme_jmp_entry.opcode = TPM_PME_CMD_JUMP;
+	pme_jmp_entry.last = TPM_PME_CMD_NO_LAST;
+	pme_jmp_entry.cmd_type = TPM_PME_CMD_TYPE0;
+	pme_jmp_entry.data = templ_start_idx;
+
+	/* Write to HW */
+	rc = tpm_pme_hw_entry_write(jmp_first_free, &pme_jmp_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Write to PME HW failed\n");
+	/* Return JMP index */
+	*jmp_idx = jmp_first_free;
+	/* Update JMP first free index */
+	jmp_first_free++;
+	rc = tpm_db_pme_cmd_first_free_set(TPM_PME_CMD_AREA_JMP, jmp_first_free);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "First free jmp get failed, type(%d)\n", TPM_PME_CMD_AREA_JMP);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_one_instr_templ_create()
+*
+* DESCRIPTION: Create only one instruction template according to use cases in HW and record it to DB
+*
+* INPUTS:
+*          instr_templ         - instruction template
+*          qos_src             - the source of QoS
+*          addr_rep_start_idx  - address replacement subr start index in PME table, it is an array
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_one_instr_templ_create(struct tpm_pme_templ_pattern_t *instr_templ,
+					  enum tpm_pme_qos_src_t qos_src,
+					  unsigned int *addr_rep_start_idx)
+{
+	int rc;
+	int entry_idx, i;
+	unsigned int hw_idx_free, jmp_idx, templ_start_idx, db_idx_free;
+	unsigned int ppoe_sess_pme_idx = 0;
+	struct tpm_pme_entry_t pme_entry[TPM_PME_INSTR_TEMPL_ENTRY_MAX];
+	struct tpm_pme_templ_data_t template_entry;
+
+	/* Input parameter check */
+	IF_NULL(TPM_PME_MOD, instr_templ);
+	IF_NULL(TPM_PME_MOD, addr_rep_start_idx);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PME_MOD, qos_src, TPM_PME_QOS_DESC, "invalid QoS src");
+
+	/* Get first available HW entry */
+	rc = tpm_db_pme_cmd_first_free_get(TPM_PME_CMD_AREA_TEMPL, &hw_idx_free);
+	IF_ERROR_STR(TPM_PME_MOD, rc,
+		     "First free cmd get failed, type(%d)\n", TPM_PME_CMD_AREA_TEMPL);
+	/* Record the start index of template */
+	templ_start_idx = hw_idx_free;
+	/* Clear SW pme_entry */
+	TPM_MEMSET_ZERO(pme_entry);
+	for (entry_idx = 0; entry_idx < TPM_PME_INSTR_TEMPL_ENTRY_MAX; entry_idx++) {
+		/* Copy pattern entry */
+		memcpy(&pme_entry[entry_idx],
+		       &instr_templ->pme_entry[entry_idx],
+		       sizeof(struct tpm_pme_entry_t));
+
+		/* Update MH cmd type */
+		if (instr_templ->pme_entry[entry_idx].opcode == TPM_PME_CMD_MH_OP &&
+		    (!entry_idx) &&
+		    qos_src == TPM_PME_QOS_DESC) {
+			if (instr_templ->ext_mod_bm != TPM_PME_NAPT_DS_BM1 &&
+			    instr_templ->ext_mod_bm != TPM_PME_NAPT_DS_BM2 &&
+			    instr_templ->ext_mod_bm != TPM_PME_ROUTE_BM3 &&
+			    instr_templ->ext_mod_bm != TPM_PME_ROUTE_BM4)
+				pme_entry[entry_idx].cmd_type = TPM_PME_CMD_TYPE5;
+		}
+		/* Update DSCP Cmd type according to Qos */
+		if (((instr_templ->pme_entry[entry_idx].opcode ==
+		       TPM_PME_CMD_REPLACE_LSB ||
+		       instr_templ->pme_entry[entry_idx].opcode ==
+		       TPM_PME_CMD_REPLACE_MID) &&
+		      (instr_templ->ext_mod_bm & TPM_IP_DSCP_SET)) &&
+		    qos_src == TPM_PME_QOS_DESC)
+			pme_entry[entry_idx].cmd_type = TPM_PME_CMD_TYPE5;
+
+		/* Update Address replacement subr index if need */
+		/* DMAC replacement */
+		if ((instr_templ->ext_mod_bm & TPM_ETH_DST_SET) &&
+		    (entry_idx ==
+		     ((instr_templ->mac_rep_info >> TPM_ADDR_REP_INFO_DA_IDX_OFF) &
+		      TPM_ADDR_REP_INFO_MASK))) {
+			switch ((instr_templ->mac_rep_info >>
+				TPM_ADDR_REP_INFO_DA_TYPE_OFF) & TPM_ADDR_REP_INFO_MASK) {
+			case TPM_PME_CMD_TYPE1:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T1];
+				break;
+			case TPM_PME_CMD_TYPE2:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T2];
+				break;
+			case TPM_PME_CMD_TYPE3:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T3];
+				break;
+			default:
+				IF_ERROR_STR(TPM_PME_MOD,
+					     TPM_BAD_VALUE, "Invalid replace cmd type\n");
+			}
+		}
+		/* SMAC replacement */
+		if ((instr_templ->ext_mod_bm & TPM_ETH_SRC_SET) &&
+		    (entry_idx ==
+		     (instr_templ->mac_rep_info & TPM_ADDR_REP_INFO_MASK))) {
+			switch ((instr_templ->mac_rep_info >>
+				TPM_ADDR_REP_INFO_SA_TYPE_OFF) & TPM_ADDR_REP_INFO_MASK) {
+			case TPM_PME_CMD_TYPE1:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T1];
+				break;
+			case TPM_PME_CMD_TYPE2:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T2];
+				break;
+			case TPM_PME_CMD_TYPE3:
+				pme_entry[entry_idx].data =
+				addr_rep_start_idx[REPLACE_ADDR_MAC_T3];
+				break;
+			default:
+				IF_ERROR_STR(TPM_PME_MOD,
+					     TPM_BAD_VALUE, "Invalid replace cmd type\n");
+			}
+		}
+		/* SIP replacement */
+		if ((instr_templ->ext_mod_bm & TPM_IP_SRC_SET) &&
+		    (entry_idx ==
+		     (instr_templ->ip_rep_info & TPM_ADDR_REP_INFO_MASK))) {
+			pme_entry[entry_idx].data = addr_rep_start_idx[REPLACE_ADDR_IP_T3];
+		}
+		/* DIP replacement */
+		if ((instr_templ->ext_mod_bm & TPM_IP_DST_SET) &&
+		    (entry_idx == ((instr_templ->ip_rep_info >>
+				TPM_ADDR_REP_INFO_DIP_IDX_OFF) & TPM_ADDR_REP_INFO_MASK))) {
+			pme_entry[entry_idx].data = addr_rep_start_idx[REPLACE_ADDR_IP_T3];
+		}
+		/* Write entry to HW */
+		rc = tpm_pme_hw_entry_write(hw_idx_free, &pme_entry[entry_idx]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "HW Write(Idx=%d) Failed\n", hw_idx_free);
+		/* Record IPV4 NAPT US PPoE session ID entry index */
+		if (instr_templ->pme_entry[entry_idx].opcode == TPM_PME_CMD_PPPOE &&
+		    instr_templ->ppoe_num == TPM_PPOE_SESS_ALLOWED_MAX)
+			ppoe_sess_pme_idx = hw_idx_free;
+		hw_idx_free++;
+		/* If entry is last one, break */
+		if (instr_templ->pme_entry[entry_idx].last == TPM_PME_CMD_LAST)
+			break;
+	}
+	/* Update first free cmd index in PME */
+	rc = tpm_db_pme_cmd_first_free_set(TPM_PME_CMD_AREA_TEMPL, hw_idx_free);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Update first free PME index Failed\n");
+
+	/* Allocate JMP entry for the template */
+	rc = tpm_pme_jmp_entry_allocate(templ_start_idx, &jmp_idx);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Allocate Jmp entry failed\n");
+
+	/* Record the template to TPM DB */
+	rc = tpm_db_pme_instr_templ_free_idx_get(&db_idx_free);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Available template DB entry get failed\n");
+	TPM_MEMSET_ZERO(template_entry);
+	template_entry.jmp_idx = jmp_idx;
+	template_entry.start_idx = templ_start_idx;
+	template_entry.valid = TPM_INSTR_TEMPL_VALID;
+	template_entry.ext_mod_bm = instr_templ->ext_mod_bm;
+	template_entry.int_mod_bm = instr_templ->int_mod_bm;
+	template_entry.mac_rep_info = instr_templ->mac_rep_info;
+	template_entry.ip_rep_info = instr_templ->ip_rep_info;
+	if (instr_templ->ppoe_num == TPM_PPOE_SESS_ALLOWED_MAX)
+		template_entry.ppoe_idx = ppoe_sess_pme_idx;
+	/* Update Template Internal mod_bm */
+	if (qos_src == TPM_PME_QOS_DESC) {
+		template_entry.int_mod_bm |= TPM_QOS_FROM_DESC;
+		if (template_entry.int_mod_bm & TPM_MH_T1_MOD &&
+		    instr_templ->ext_mod_bm != TPM_PME_NAPT_DS_BM1 &&
+		    instr_templ->ext_mod_bm != TPM_PME_NAPT_DS_BM2 &&
+		    instr_templ->ext_mod_bm != TPM_PME_ROUTE_BM3 &&
+		    instr_templ->ext_mod_bm != TPM_PME_ROUTE_BM4) {
+			template_entry.int_mod_bm &= (~TPM_MH_T1_MOD);/* Clear TPM_MH_T1_MOD */
+			template_entry.int_mod_bm |= TPM_MH_T5_MOD;/* Update to TPM_MH_T5_MOD*/
+		}
+	}
+	memcpy(template_entry.pme_entry, pme_entry, sizeof(pme_entry));
+	rc = tpm_db_pme_instr_templ_set(db_idx_free, &template_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "PME template record to DB failed\n");
+
+	/* Add Additional Template for MH modification: Qos from desc & MH mod Type1*/
+	if ((template_entry.ext_mod_bm == TPM_PME_L2_SW_BM2 ||
+	     template_entry.ext_mod_bm == TPM_PME_ROUTE_BM1) &&
+	    (template_entry.int_mod_bm & TPM_QOS_FROM_DESC) &&
+	    (template_entry.int_mod_bm & TPM_MH_T5_MOD)) {
+		pme_entry[0].cmd_type = TPM_PME_CMD_TYPE1;
+		/* Get first available HW entry */
+		rc = tpm_db_pme_cmd_first_free_get(TPM_PME_CMD_AREA_TEMPL, &hw_idx_free);
+		IF_ERROR_STR(TPM_PME_MOD, rc,
+			     "First free cmd get failed, type(%d)\n", TPM_PME_CMD_AREA_TEMPL);
+		template_entry.start_idx = hw_idx_free;
+		/* Write HW */
+		for (i = 0; i < TPM_PME_INSTR_TEMPL_ENTRY_MAX; i++) {
+			rc = tpm_pme_hw_entry_write(hw_idx_free++, &pme_entry[i]);
+			IF_ERROR_STR(TPM_PME_MOD, rc, "HW Write(Idx=%d) Failed\n", hw_idx_free);
+			if (pme_entry[i].last == TPM_PME_CMD_LAST)
+				break;
+		}
+		/* Update first free cmd index in PME */
+		rc = tpm_db_pme_cmd_first_free_set(TPM_PME_CMD_AREA_TEMPL, hw_idx_free);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Update first free PME index Failed\n");
+		/* Allocate JMP entry for the template */
+		rc = tpm_pme_jmp_entry_allocate(template_entry.start_idx, &jmp_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Allocate Jmp entry failed\n");
+		template_entry.jmp_idx = jmp_idx;
+		/* Record the template to TPM DB */
+		/* Update Template Internal mod_bm */
+		template_entry.int_mod_bm &= (~TPM_MH_T5_MOD);/* Clear TPM_MH_T5_MOD */
+		template_entry.int_mod_bm |= TPM_MH_T1_MOD;/* Update to TPM_MH_T1_MOD*/
+		rc = tpm_db_pme_instr_templ_free_idx_get(&db_idx_free);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Available template DB entry get failed\n");
+		rc = tpm_db_pme_instr_templ_set(db_idx_free, &template_entry);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "PME template record to DB failed\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_instr_templ_create()
+*
+* DESCRIPTION: Create instruction template according to use cases in HW and record it to DB
+*
+* INPUTS:
+*          templ_array - template array of one use case
+*          size        - the array size
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_instr_templ_create(struct tpm_pme_templ_pattern_t *templ_array, unsigned int size)
+{
+	int rc;
+	int templ_idx, ppoe_idx, qos_idx;
+	struct tpm_pme_addr_rep_subr_t addr_rep_subr;
+	unsigned int addr_rep_start_idx[REPLACE_ADDR_OP_MAX];
+	int addr_rep_op, i;
+
+	/* Get address replacement subr start index in PME table */
+	for (addr_rep_op = REPLACE_ADDR_MAC_T1; addr_rep_op < REPLACE_ADDR_OP_MAX; addr_rep_op++) {
+		for (i = 0; i < TPM_ADDR_REP_TEMPL_MAX; i++) {
+			rc = tpm_db_pme_addr_rep_subr_get(i, &addr_rep_subr);
+			IF_ERROR_STR(TPM_PME_MOD, rc, "Addr Replace Subr get failed\n");
+			if (addr_rep_subr.addr_rep_op == addr_rep_op)
+				addr_rep_start_idx[addr_rep_op] = addr_rep_subr.start_idx;
+		}
+	}
+
+	for (templ_idx = 0; templ_idx < size; templ_idx++) {
+		for (ppoe_idx = 0; ppoe_idx < templ_array[templ_idx].ppoe_num; ppoe_idx++) {
+			for (qos_idx = 0; qos_idx < templ_array[templ_idx].qos_permu; qos_idx++) {
+				rc = tpm_pme_one_instr_templ_create(&templ_array[templ_idx],
+								    qos_idx,
+								    addr_rep_start_idx);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Fail to create instruction template\n");
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_mod_bm_map_data_rng()
+*
+* DESCRIPTION: Map ext mod bitmap to (private/share) data range
+*
+* INPUTS:
+*          data_tbl - private/share data area
+*          mod_bm   - modification bit map
+* OUTPUTS:
+*          rng_idx[]- corresponding range index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_mod_bm_map_data_rng(unsigned int tbl_idx, unsigned int mod_bm, unsigned int *rng_idx)
+{
+	int rc;
+	unsigned int ext_mod_bm;
+
+	IF_NULL(TPM_PME_MOD, rng_idx);
+	if (tbl_idx >= TPM_PME_TBL_MAX) {
+		rc = TPM_BAD_PARAM;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Invalid input parameter (%d)\n", tbl_idx);
+	}
+
+	ext_mod_bm = mod_bm;
+
+	/* For modification, except no_mod, they are all based on VLAN */
+	if (ext_mod_bm) {
+		ext_mod_bm |= TPM_VLAN_MOD;
+		/* for mod except no_mod and pure VLAN mod, they are all based on DSCP */
+		if (ext_mod_bm & (~TPM_VLAN_MOD))
+			ext_mod_bm |= TPM_IP_DSCP_SET;
+	}
+
+	switch (ext_mod_bm) {
+	/* No Mod */
+	case (TPM_PME_NO_MOD_BM):
+		if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_PRI_RNG_NO_MOD;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_PRI_RNG_MAX;	/* invalid range */
+		} else {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_SHA_RNG_MAC;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_SHA_RNG_MAX;
+		}
+		break;
+	/* L2 Switch */
+	case (TPM_PME_L2_SW_BM1):
+	case (TPM_PME_L2_SW_BM2):
+		if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_PRI_RNG_L2_SW;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_PRI_RNG_MAX;
+		} else {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_SHA_RNG_MAC;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_SHA_RNG_MAX;
+		}
+		break;
+	/* IPV4 US NAPT */
+	case (TPM_PME_NAPT_US_BM1):
+	case (TPM_PME_NAPT_US_BM2):
+		if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_PRI_RNG_US_NAPT;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_PRI_RNG_MAX;
+		} else {/* US IPV4 NAPT occupy 2 ranges */
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_SHA_RNG_MAC;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_SHA_RNG_SA_SIP;
+		}
+		break;
+	/* IPV4 DS NAPT */
+	case (TPM_PME_NAPT_DS_BM1):
+	case (TPM_PME_NAPT_DS_BM2):
+		if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_PRI_RNG_DS_NAPT;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_PRI_RNG_MAX;
+		} else {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_SHA_RNG_DA_SA_DIP;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_SHA_RNG_MAX;
+		}
+		break;
+	/* Route */
+	case (TPM_PME_ROUTE_BM1):
+	case (TPM_PME_ROUTE_BM2):
+	case (TPM_PME_ROUTE_BM3):
+	case (TPM_PME_ROUTE_BM4):
+		if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_PRI_RNG_ROUTE;
+			rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_PRI_RNG_MAX;
+		} else {
+			rng_idx[TPM_PME_DIFF_RNG0] = TPM_PME_SHA_RNG_MAC;
+			if (mod_bm != TPM_PME_ROUTE_BM4)
+				rng_idx[TPM_PME_DIFF_RNG1] = TPM_PME_SHA_RNG_MAC;
+		}
+		break;
+	default:
+		IF_ERROR_STR(TPM_PME_MOD, TPM_BAD_PARAM, "Modification bit map NOT supported (0x%x)\n", mod_bm);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_vlan_templ_sel()
+*
+* DESCRIPTION: Select expected VLAN subr template
+*
+* INPUTS:
+*          vlan_no_op       - bool, VLAN NOOP or not
+*          pme_mod_data     - modification data
+* OUTPUTS:
+*          vlan_subr_start  - VLAN subr template start index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_vlan_templ_sel(bool vlan_no_op,
+				  struct tpm_pme_pkt_mod_t *pme_mod_data,
+				  unsigned short *vlan_subr_start)
+{
+	int rc;
+	struct tpm_pme_vlan_skip_permu_t vlan_permu;
+	struct tpm_pme_vlan_subr_t vlan_subr_db;
+	unsigned short tpid_reg[TPM_NUM_VLAN_ETYPE_REGS] = {0};
+	int i;
+	unsigned int cnm_support;
+
+	IF_NULL(TPM_PME_MOD, pme_mod_data);
+	IF_NULL(TPM_PME_MOD, vlan_subr_start);
+	TPM_MEMSET_ZERO(vlan_permu);
+	/* Check packet is pppoe packet */
+	if (pme_mod_data->mod_data.mod_bm & TPM_PPOE_DEL)
+		vlan_permu.pppoe = TPM_PME_PPPOE_TRUE;
+	/* NO VLAN_OP */
+	if (vlan_no_op == true ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_NOOP) {
+		for (i = 0; i < TPM_VLAN_TEMPL_MAX; i++) {
+			rc = tpm_db_pme_vlan_subr_get(i, &vlan_subr_db);
+			IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN DB(%d) get failed\n", i);
+			if (vlan_subr_db.vlan_op != VLANOP_NOOP)
+				continue;
+			if (vlan_subr_db.vlan_permu.pppoe != vlan_permu.pppoe)
+				continue;
+			*vlan_subr_start = vlan_subr_db.start_idx;
+			break;
+		}
+		/* Not match one */
+		if (i == TPM_VLAN_TEMPL_MAX) {
+			rc = TPM_NO_SUCH;
+			IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN_NOOP no matched\n");
+		}
+
+		TPM_OS_DEBUG(TPM_PME_MOD,
+			     "VLAN Op(%d) Subr selected start idx = %d, PPoE state(%d)\n",
+			     pme_mod_data->mod_data.vlan_op.oper,
+			     *vlan_subr_start,
+			     vlan_permu.pppoe);
+
+		return TPM_OK;
+	}
+
+	/* Check Qos src */
+	if (pme_mod_data->inter_mod_bm & TPM_QOS_FROM_DESC)
+		vlan_permu.qos_src = TPM_PME_QOS_DESC;
+	else
+		vlan_permu.qos_src = TPM_PME_QOS_PRV;
+	/* If CnM is supported, p-bit only from descriptor, temporarily ONLY for CnM */
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_CNM_SUPPORT, &cnm_support);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "get CnM support value failed\n");
+	if (cnm_support == TPM_CNM_SUPPORTED &&
+	    VLANOP_EXT_TAG_DEL != (int)pme_mod_data->mod_data.vlan_op.oper &&
+	    VLANOP_DEL_2TAG != (int)pme_mod_data->mod_data.vlan_op.oper)
+		vlan_permu.qos_src = TPM_PME_QOS_DESC;
+
+	/* Check new VLAN added, all parts should be updated */
+	if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_INS ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INS_2TAG) {
+		if ((!(pme_mod_data->mod_data.vlan_op.out_vlan.tpid & TPM_TPID_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.out_vlan.vid & TPM_VID_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.out_vlan.cfi & TPM_CFI_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE))) {
+			rc = TPM_BAD_PARAM;
+			IF_ERROR_STR(TPM_PME_MOD, rc, "All VLAN parts need update when adding a new VLAN\n");
+		}
+	}
+	if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INS_2TAG) {
+		if ((!(pme_mod_data->mod_data.vlan_op.inn_vlan.tpid & TPM_TPID_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.inn_vlan.vid & TPM_VID_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.inn_vlan.cfi & TPM_CFI_UPDATE)) ||
+		    (!(pme_mod_data->mod_data.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE))) {
+			rc = TPM_BAD_PARAM;
+			IF_ERROR_STR(TPM_PME_MOD, rc, "All VLAN parts need update when adding a new VLAN\n");
+		}
+	}
+
+	/* Get TPID config */
+	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
+		rc = tpm_db_init_mod_tpid_get(i, &tpid_reg[i]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN TPID[%d] config get failed\n", i);
+	}
+
+	/* TPID, VID, PBIT sel, only outer vlan cared */
+	if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_MOD ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_INS ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_MOD_INS ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INS_2TAG ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_MOD_2TAG) {
+		/* TPID */
+		if ((pme_mod_data->mod_data.vlan_op.out_vlan.tpid & TPM_TPID_UPDATE) &&
+		    (int)pme_mod_data->mod_data.vlan_op.oper != VLANOP_MOD_2TAG) {/* Mod 2 tag, no update TPID */
+			if (tpid_reg[TPM_VLAN_ETY_REG0] ==
+			    (pme_mod_data->mod_data.vlan_op.out_vlan.tpid & (~TPM_TPID_UPDATE))) {
+				vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_REG0;
+			} else if (tpid_reg[TPM_VLAN_ETY_REG1] ==
+				   (pme_mod_data->mod_data.vlan_op.out_vlan.tpid & (~TPM_TPID_UPDATE))) {
+				vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_REG1;
+			} else {/* Invalid TPID */
+				rc = TPM_NO_SUCH;
+				IF_ERROR_STR(TPM_PME_MOD, rc,
+					"Invalid VLAN TPID (0x%x)\n",
+					(pme_mod_data->mod_data.vlan_op.out_vlan.tpid & (~TPM_TPID_UPDATE)));
+			}
+		} else {
+			vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_VLAN12;
+		}
+
+		/* VID */
+		if (pme_mod_data->mod_data.vlan_op.out_vlan.vid & TPM_VID_UPDATE)
+			vlan_permu.vid_sel = TPM_VLAN_VID_LOG_NEW;
+		else
+			vlan_permu.vid_sel = TPM_VLAN_VID_LOG_VLAN12;
+
+		/* PBIT */
+		if (pme_mod_data->mod_data.vlan_op.out_vlan.pbit & TPM_PBIT_UPDATE)
+			vlan_permu.pbit_sel = TPM_VLAN_PBIT_LOG_NEW;
+		else
+			vlan_permu.pbit_sel = TPM_VLAN_PBIT_LOG_VLAN12;
+	}
+
+	/* Special handle VLANOP_INT_TAG_MOD and VLANOP_EXT_TAG_DEL_INT_MOD, parameter from vlan2 (inner vlan) */
+	if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INT_TAG_MOD ||
+	    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_DEL_INT_MOD) {
+		/* TPID */
+		if (pme_mod_data->mod_data.vlan_op.inn_vlan.tpid & TPM_TPID_UPDATE) {
+			if (tpid_reg[TPM_VLAN_ETY_REG0] ==
+			    (pme_mod_data->mod_data.vlan_op.inn_vlan.tpid & (~TPM_TPID_UPDATE))) {
+				vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_REG0;
+			} else if (tpid_reg[TPM_VLAN_ETY_REG1] ==
+				   (pme_mod_data->mod_data.vlan_op.inn_vlan.tpid & (~TPM_TPID_UPDATE))) {
+				vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_REG1;
+			} else {/* Invalid TPID */
+				rc = TPM_NO_SUCH;
+				IF_ERROR_STR(TPM_PME_MOD, rc,
+					"Invalid VLAN TPID (0x%x)\n",
+					(pme_mod_data->mod_data.vlan_op.inn_vlan.tpid & (~TPM_TPID_UPDATE)));
+			}
+		} else {
+			vlan_permu.tpid_sel = TPM_VLAN_ETY_LOG_VLAN12;
+		}
+
+		/* VID */
+		if (pme_mod_data->mod_data.vlan_op.inn_vlan.vid & TPM_VID_UPDATE)
+			vlan_permu.vid_sel = TPM_VLAN_VID_LOG_NEW;
+		else
+			vlan_permu.vid_sel = TPM_VLAN_VID_LOG_VLAN12;
+
+		/* PBIT */
+		if (pme_mod_data->mod_data.vlan_op.inn_vlan.pbit & TPM_PBIT_UPDATE)
+			vlan_permu.pbit_sel = TPM_VLAN_PBIT_LOG_NEW;
+		else
+			vlan_permu.pbit_sel = TPM_VLAN_PBIT_LOG_VLAN12;
+	}
+
+	TPM_OS_DEBUG(TPM_PME_MOD, "Target VLAN subr permu: ppoe=%d, qos=%d, tpid_sel=%d, vid_sel=%d, pbit_sel=%d\n",
+		     vlan_permu.pppoe,
+		     vlan_permu.qos_src,
+		     vlan_permu.tpid_sel,
+		     vlan_permu.vid_sel,
+		     vlan_permu.pbit_sel);
+
+	/* Match VLAN template */
+	for (i = 0; i < TPM_VLAN_TEMPL_MAX; i++) {
+		rc = tpm_db_pme_vlan_subr_get(i, &vlan_subr_db);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN DB(%d) get failed\n", i);
+		if ((int)vlan_subr_db.vlan_op != (int)pme_mod_data->mod_data.vlan_op.oper)
+			continue;
+
+		TPM_OS_DEBUG(TPM_PME_MOD,
+			     "Supported VLAN subr permu%d: ppoe=%d, qos=%d, tpid_sel=%d, vid_sel=%d, pbit_sel=%d\n",
+			     i,
+			     vlan_subr_db.vlan_permu.pppoe,
+			     vlan_subr_db.vlan_permu.qos_src,
+			     vlan_subr_db.vlan_permu.tpid_sel,
+			     vlan_subr_db.vlan_permu.vid_sel,
+			     vlan_subr_db.vlan_permu.pbit_sel);
+
+		if (vlan_subr_db.vlan_permu.pppoe != vlan_permu.pppoe)
+			continue;
+		if (vlan_subr_db.vlan_permu.qos_src != vlan_permu.qos_src)
+			continue;
+		if (vlan_subr_db.vlan_permu.tpid_sel != vlan_permu.tpid_sel)
+			continue;
+		if (vlan_subr_db.vlan_permu.vid_sel != vlan_permu.vid_sel)
+			continue;
+		if (vlan_subr_db.vlan_permu.pbit_sel != vlan_permu.pbit_sel)
+			continue;
+		*vlan_subr_start = vlan_subr_db.start_idx;
+		break;
+	}
+	/* No one match  */
+	if (i == TPM_VLAN_TEMPL_MAX) {
+		rc = TPM_NO_SUCH;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "No VLAN matched with op (%d)\n", pme_mod_data->mod_data.vlan_op.oper);
+	}
+
+	TPM_OS_DEBUG(TPM_PME_MOD,
+		     "VLAN Op(%d) Subr selected start idx = %d, PPoE state(%d)\n",
+		     pme_mod_data->mod_data.vlan_op.oper,
+		     *vlan_subr_start,
+		     vlan_permu.pppoe);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_mod_data_build()
+*
+* DESCRIPTION: Build modification data structure, including private and share
+*
+* INPUTS:
+*          pme_mod_data     - modification data
+* OUTPUTS:
+*          data_build       - modification structure
+*          mh_remove       - whether marvell header needs to be removed
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+* NOTE: call it before select instruction template, because most template are based on DSCP
+*******************************************************************************/
+static int tpm_pme_mod_data_build(struct tpm_pme_pkt_mod_t *pme_mod_data,
+				  struct tpm_pme_data_build_t *data_build,
+				  bool mh_remove)
+{
+	int rc;
+	unsigned int private_idx = 0, share_idx = 0, share_unit_idx = 0;
+	unsigned short vlan_subr_start;
+	unsigned int ext_mod_bm;
+	int i;
+
+	/* Parameter check */
+	IF_NULL(TPM_PME_MOD, pme_mod_data);
+	IF_NULL(TPM_PME_MOD, data_build);
+
+	/* Select correct private and share data range */
+	rc = tpm_pme_mod_bm_map_data_rng(TPM_PME_PRIVATE_TBL,
+					 pme_mod_data->mod_data.mod_bm,
+					 data_build->pri_rng);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Modification BM map to private data range failed\n");
+	rc = tpm_pme_mod_bm_map_data_rng(TPM_PME_SHARE_TBL,
+					 pme_mod_data->mod_data.mod_bm,
+					 data_build->sha_rng);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Modification BM map to share data range failed\n");
+	rc = tpm_db_pme_data_rng_unit_size_get(TPM_PME_SHARE_TBL,
+					       data_build->sha_rng[TPM_PME_DATA_UNIT0],
+					       &data_build->rng_unit_size[TPM_PME_DATA_UNIT0]);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Get share data range unit size failed\n");
+	if (data_build->sha_rng[TPM_PME_DATA_UNIT1] != TPM_PME_SHA_RNG_MAX) {
+		rc = tpm_db_pme_data_rng_unit_size_get(TPM_PME_SHARE_TBL,
+						       data_build->sha_rng[TPM_PME_DATA_UNIT1],
+						       &data_build->rng_unit_size[TPM_PME_DATA_UNIT1]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Get share data range unit size failed\n");
+	}
+
+	/* Modification data build */
+	/* For modification, except no_mod, they are all based on VLAN */
+	ext_mod_bm = pme_mod_data->mod_data.mod_bm;
+	if (ext_mod_bm) {
+		ext_mod_bm |= TPM_VLAN_MOD;
+		/* for mod except no_mod and pure VLAN mod, they are all based on DSCP */
+		if (ext_mod_bm & (~TPM_VLAN_MOD))
+			ext_mod_bm |= TPM_IP_DSCP_SET;
+	}
+
+	/* Marvell Header, for IPV4 NAPT DS, MH is fixed to be 0xFFFF, so private data no need */
+	if ((pme_mod_data->inter_mod_bm & (TPM_MH_T1_MOD | TPM_MH_T5_MOD)) &&
+	    ext_mod_bm != TPM_PME_NAPT_DS_BM1 &&
+	    ext_mod_bm != TPM_PME_NAPT_DS_BM2 &&
+	    !mh_remove)
+		data_build->private_data[private_idx++] = pme_mod_data->mh_value;
+
+	/* No Modification, return */
+	if (!pme_mod_data->mod_data.mod_bm) {
+		data_build->private_idx = private_idx;
+		return TPM_OK;
+	}
+
+	/* DMAC */
+	if (pme_mod_data->mod_data.mod_bm & TPM_ETH_DST_SET) {
+		/* Only MC with PPPoE del, DMAC stored in private data */
+		if (TPM_IS_MULTICAST_MAC(pme_mod_data->mod_data.eth_dst) &&
+		    pme_mod_data->mod_data.mod_bm & TPM_PPOE_DEL) {
+			for (i = 0; i < (MAC_ADDR_SIZE / 2); i++) {
+				data_build->private_data[private_idx++] =
+				((unsigned short)pme_mod_data->mod_data.eth_dst[2*i] << 8) |
+				((unsigned short)pme_mod_data->mod_data.eth_dst[2*i + 1]);
+			}
+		} else {
+			if (MAC_ADDR_SIZE > data_build->rng_unit_size[share_unit_idx])
+				IF_ERROR_STR(TPM_PME_MOD, TPM_OUT_OF_RANGE, "Share data size is out of range\n");
+			/* Reserve one private e slot to init share data pointer */
+			if (!share_idx)/* when share_idx = 0, instert it */
+				data_build->private_data[private_idx++] = TPM_PME_SHARE_NEED;
+
+			for (i = 0; i < (MAC_ADDR_SIZE / 2); i++) {
+				data_build->share_data[share_unit_idx][share_idx++] =
+				((unsigned short)pme_mod_data->mod_data.eth_dst[2*i] << 8) |
+				((unsigned short)pme_mod_data->mod_data.eth_dst[2*i + 1]);
+			}
+			if ((2 * share_idx) == data_build->rng_unit_size[share_unit_idx]) {
+				share_unit_idx++;
+				share_idx = 0;
+			}
+		}
+	}
+
+	/* SMAC , all stored in share data */
+	if (pme_mod_data->mod_data.mod_bm & TPM_ETH_SRC_SET) {
+		if (MAC_ADDR_SIZE > (data_build->rng_unit_size[share_unit_idx] - (2 * share_idx)))
+			IF_ERROR_STR(TPM_PME_MOD, TPM_OUT_OF_RANGE, "Share data size is out of range\n");
+		/* Reserve one private e slot to init share data pointer */
+		if (!share_idx)/* when share_idx = 0, instert it */
+			data_build->private_data[private_idx++] = TPM_PME_SHARE_NEED;
+
+		for (i = 0; i < (MAC_ADDR_SIZE / 2); i++) {
+			data_build->share_data[share_unit_idx][share_idx++] =
+			((unsigned short)pme_mod_data->mod_data.eth_src[2*i] << 8) |
+			((unsigned short)pme_mod_data->mod_data.eth_src[2*i + 1]);
+		}
+		if ((2 * share_idx) == data_build->rng_unit_size[share_unit_idx]) {
+			share_unit_idx++;
+			share_idx = 0;
+		}
+	}
+
+	/* VLAN subr */
+	/* select VLAN sube template */
+	rc = tpm_pme_vlan_templ_sel((pme_mod_data->mod_data.mod_bm & TPM_VLAN_MOD) ? false : true,
+				    pme_mod_data,
+				    &vlan_subr_start);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Failed to match VLAN subr template\n");
+	data_build->private_data[private_idx++] = vlan_subr_start;
+	/* If VLAN Op is No_OP, or no VLAN Mod, no private data needed */
+	if ((int)pme_mod_data->mod_data.vlan_op.oper != VLANOP_NOOP &&
+	    pme_mod_data->mod_data.mod_bm & TPM_VLAN_MOD) {
+		/* One Private data needed for out VLAN */
+		if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_MOD ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_INS ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_MOD_INS ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INS_2TAG ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_MOD_2TAG) {
+			data_build->private_data[private_idx++] =
+			(pme_mod_data->mod_data.vlan_op.out_vlan.pbit << VLAN_PBIT_OFF) |
+			 pme_mod_data->mod_data.vlan_op.out_vlan.vid;
+		}
+		/* Add inner VLAN to private data */
+		if ((int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_MOD_INS ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INS_2TAG ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_MOD_2TAG ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_INT_TAG_MOD ||
+		    (int)pme_mod_data->mod_data.vlan_op.oper == VLANOP_EXT_TAG_DEL_INT_MOD) {
+			data_build->private_data[private_idx++] =
+			(pme_mod_data->mod_data.vlan_op.inn_vlan.pbit << VLAN_PBIT_OFF) |
+			 pme_mod_data->mod_data.vlan_op.inn_vlan.vid;
+		}
+	}
+
+	/* Ether Type, TBD */
+
+	/* TPM_PPOE_ADD */
+	if (pme_mod_data->mod_data.mod_bm & TPM_PPOE_ADD) {
+		/* Only route case store session ID in private data */
+		if (data_build->pri_rng[TPM_PME_DIFF_RNG0] == TPM_PME_PRI_RNG_ROUTE)
+			data_build->private_data[private_idx++] = pme_mod_data->mod_data.pppoe_mod.ppp_session;
+	}
+
+	/* TPM_IP_DSCP_SET */
+	if (pme_mod_data->mod_data.mod_bm & TPM_IP_DSCP_SET) {
+		if (pme_mod_data->inter_mod_bm & TPM_MOD_PKT_IS_IP6) {/* IPV6 packet */
+			data_build->private_data[private_idx++] =
+			(pme_mod_data->mod_data.ipvx.dscp << TPM_PME_IP6_DSCP_BIT_OFF) | TPM_PME_IP6_DSCP_UPDATE_MASK;
+		} else {
+			data_build->private_data[private_idx++] =
+			(pme_mod_data->mod_data.ipvx.dscp << TPM_PME_IP4_DSCP_BIT_OFF) | TPM_PME_IP4_DSCP_UPDATE_MASK;
+		}
+
+	} else {/* For non-IP packet, because range unit size, the private entry make no sense, logic is still right */
+		if (pme_mod_data->inter_mod_bm & TPM_MOD_PKT_IS_IP6)/* IPV6 packet */
+			data_build->private_data[private_idx++] = TPM_PME_IP6_DSCP_KEEP_MASK;
+		else
+			data_build->private_data[private_idx++] = TPM_PME_IP4_DSCP_KEEP_MASK;
+	}
+
+	/* TPM_IP_SRC_SET */
+	if (pme_mod_data->mod_data.mod_bm & TPM_IP_SRC_SET) {
+		/* Only for IPV4 */
+		if (!(pme_mod_data->inter_mod_bm & TPM_MOD_PKT_IS_IP6)) {
+			if (IPV4_ADDR_SIZE > (data_build->rng_unit_size[share_unit_idx] - (2 * share_idx)))
+				IF_ERROR_STR(TPM_PME_MOD, TPM_OUT_OF_RANGE, "Share data size is out of range\n");
+			/* Reserve one private e slot to init share data pointer */
+			if (!share_idx)/* when share_idx = 0, instert it */
+				data_build->private_data[private_idx++] = TPM_PME_SHARE_NEED;
+
+			for (i = 0; i < (IPV4_ADDR_SIZE / 2); i++) {
+				data_build->share_data[share_unit_idx][share_idx] =
+				((unsigned short)pme_mod_data->mod_data.ipvx.ip_src.ipv4[2*i] << 8) |
+				((unsigned short)pme_mod_data->mod_data.ipvx.ip_src.ipv4[2*i + 1]);
+				share_idx++;
+			}
+			if ((2 * share_idx) == data_build->rng_unit_size[share_unit_idx]) {
+				share_unit_idx++;
+				share_idx = 0;
+			}
+		}
+	}
+
+	/* TPM_IP_DST_SET */
+	if (pme_mod_data->mod_data.mod_bm & TPM_IP_DST_SET) {
+		/* Only for IPV4 */
+		if (!(pme_mod_data->inter_mod_bm & TPM_MOD_PKT_IS_IP6)) {
+			if (IPV4_ADDR_SIZE > (data_build->rng_unit_size[share_unit_idx] - (2 * share_idx)))
+				IF_ERROR_STR(TPM_PME_MOD, TPM_OUT_OF_RANGE, "Share data size is out of range\n");
+			/* Reserve one private e slot to init share data pointer */
+			if (!share_idx)/* when share_idx = 0, instert it */
+				data_build->private_data[private_idx++] = TPM_PME_SHARE_NEED;
+
+			for (i = 0; i < (IPV4_ADDR_SIZE / 2); i++) {
+				data_build->share_data[share_unit_idx][share_idx] =
+				((unsigned short)pme_mod_data->mod_data.ipvx.ip_dst.ipv4[2*i] << 8) |
+				((unsigned short)pme_mod_data->mod_data.ipvx.ip_dst.ipv4[2*i + 1]);
+				share_idx++;
+			}
+			if ((2 * share_idx) == data_build->rng_unit_size[share_unit_idx]) {
+				share_unit_idx++;
+				share_idx = 0;
+			}
+		}
+	}
+
+	/* TPM_L4_SRC_SET */
+	if (pme_mod_data->mod_data.mod_bm & TPM_L4_SRC_SET)
+		data_build->private_data[private_idx++] = pme_mod_data->mod_data.ipvx.l4_src;
+
+	/* TPM_L4_DST_SET */
+	if (pme_mod_data->mod_data.mod_bm & TPM_L4_DST_SET)
+		data_build->private_data[private_idx++] = pme_mod_data->mod_data.ipvx.l4_dst;
+
+	data_build->private_idx = private_idx;
+	TPM_OS_DEBUG(TPM_PME_MOD, "Private valid entry cnt = %d\n", private_idx);
+	/* Debug */
+	for (i = 0; i < TPM_PME_DATA_ENTRY_MAX; i++)
+		TPM_OS_DEBUG(TPM_PME_MOD, "private_data[%d]=0x%x\n", i, data_build->private_data[i]);
+	for (i = 0; i < TPM_PME_DATA_ENTRY_MAX; i++)
+		TPM_OS_DEBUG(TPM_PME_MOD, "share_data[0][%d]=0x%x\n", i, data_build->share_data[TPM_PME_DIFF_RNG0][i]);
+	for (i = 0; i < TPM_PME_DATA_ENTRY_MAX; i++)
+		TPM_OS_DEBUG(TPM_PME_MOD, "share_data[1][%d]=0x%x\n", i, data_build->share_data[TPM_PME_DIFF_RNG1][i]);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_share_data_exist_check()
+*
+* DESCRIPTION: Check the share data entry already exist in Db or not.
+*
+* INPUTS:
+*          rng_idx        - share table range index
+*          share_data     - share data array
+* OUTPUTS:
+*          reused_data    - reused data entry if can reuse
+*          reused_db_idx  - DB entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_share_data_exist_check(unsigned int rng_idx,
+					  unsigned short *share_data,
+					  struct tpm_pme_data_entry_set_t *reused_data,
+					  unsigned int *reused_db_idx)
+{
+	int rc;
+	unsigned int unit_size;
+	struct tpm_pme_data_entry_set_t mod_data_set;
+	int i;
+
+	/* Parameter check */
+	IF_NULL(TPM_PME_MOD, share_data);
+	IF_NULL(TPM_PME_MOD, reused_data);
+	IF_NULL(TPM_PME_MOD, reused_db_idx);
+	if (rng_idx >= TPM_PME_SHA_RNG_MAX)
+		IF_ERROR_STR(TPM_PME_MOD, TPM_OUT_OF_RANGE, "Share data size is out of range\n");
+
+	/* Get range unit size */
+	rc = tpm_db_pme_data_rng_unit_size_get(TPM_PME_SHARE_TBL,
+					       rng_idx,
+					       &unit_size);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "share Range(%d) unit size get failed\n", rng_idx);
+
+	for (i = 0; i < TPM_PME_SHARE_SET_MAX; i++) {
+		TPM_MEMSET_ZERO(mod_data_set);
+		rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL,
+					 i,
+					 &mod_data_set);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Share range(%d) data DB entry get failed\n", rng_idx);
+		if (mod_data_set.valid == TPM_DATA_INVALID ||
+		    mod_data_set.range != rng_idx)
+			continue;
+		if (!memcmp(share_data, mod_data_set.mod_data, unit_size)) {
+			*reused_db_idx = i;
+			memcpy(reused_data,
+			       &mod_data_set,
+			       sizeof(struct tpm_pme_data_entry_set_t));
+			break;
+		}
+	}
+	if (i == TPM_PME_SHARE_SET_MAX)
+		*reused_db_idx = TPM_PME_INVALID_IDX;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_data_unit_free_get()
+*
+* DESCRIPTION: get the available data unit.
+*
+* INPUTS:
+*          tbl_idx     - data table index
+*          rng_idx     - table range index
+* OUTPUTS:
+*          unit_size           - data unit size(bytes)
+*          data_unit_idx       - unit index in the range
+*          first_hw_idx        - first HW entry index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_data_unit_free_get(unsigned int tbl_idx,
+				      unsigned int rng_idx,
+				      unsigned int *unit_size,
+				      unsigned int *data_unit_idx,
+				      unsigned int *first_hw_idx)
+{
+	int rc;
+	int i, bit_off, unit_idx = 0;
+	struct tpm_pme_tbl_rng_t rng_mng_data;
+	unsigned int state[TPM_PME_STATE_INT_NUM] = {0};
+
+	TPM_MEMSET_ZERO(rng_mng_data);
+	rc = tpm_db_pme_data_rng_info_get(tbl_idx, rng_idx, &rng_mng_data);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) management info get fail\n", tbl_idx, rng_idx);
+	memcpy(state, rng_mng_data.unit_state, sizeof(state));
+	for (i = 0; i < TPM_PME_STATE_INT_NUM; i++) {
+		if (state[i] != TPM_PME_UNIT_ALL_OCCUPIED)
+			break;
+	}
+	if (i == TPM_PME_STATE_INT_NUM)
+		IF_ERROR_STR(TPM_PME_MOD, TPM_FULL, "Table(%d) range(%d) all unit are occupied\n", tbl_idx, rng_idx);
+	for (bit_off = 0; bit_off < (sizeof(unsigned int) * BYTE_BITS); bit_off++) {
+		if (!(state[i] & (1 << bit_off)))
+			break;
+	}
+	/* Calculate unit index */
+	unit_idx = i * (sizeof(unsigned int) * BYTE_BITS) + bit_off;
+	/* According to unit index, calculate first HW index */
+	*first_hw_idx = rng_mng_data.start + (rng_mng_data.unit_size / 2) * unit_idx;
+	*data_unit_idx = unit_idx;
+	*unit_size = rng_mng_data.unit_size;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_data_unit_state_op()
+*
+* DESCRIPTION: Operate data table range unit state array.
+*
+* INPUTS:
+*          tbl_idx             - data table index
+*          rng_idx             - table range index
+*          data_unit_idx       - unit index in the range
+*          op                  - set or clear
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_data_unit_state_op(unsigned int tbl_idx,
+				      unsigned int rng_idx,
+				      unsigned int data_unit_idx,
+				      unsigned int op)
+{
+	int rc;
+	unsigned int state[TPM_PME_STATE_INT_NUM] = {0};
+
+	if (op >= TPM_DATA_STATE_OP_MAX)
+		IF_ERROR_STR(TPM_PME_MOD, TPM_BAD_PARAM, "Invalid input unit state op(%d)\n", op);
+	/* Read unit state */
+	rc = tpm_db_pme_data_rng_unit_state_get(tbl_idx, rng_idx, state);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) unit state get fail\n", tbl_idx, rng_idx);
+	if (op == TPM_DATA_STATE_CLEAR) {
+		state[data_unit_idx / (sizeof(unsigned int) * BYTE_BITS)] &=
+		(~(1 << (data_unit_idx % (sizeof(unsigned int) * BYTE_BITS))));
+	}
+	if (op == TPM_DATA_STATE_SET) {
+		state[data_unit_idx / (sizeof(unsigned int) * BYTE_BITS)] |=
+		(1 << (data_unit_idx % (sizeof(unsigned int) * BYTE_BITS)));
+	}
+	/* Update unit state */
+	rc = tpm_db_pme_data_rng_unit_state_set(tbl_idx, rng_idx, state);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Data Table(%d) range(%d) unit state set fail\n", tbl_idx, rng_idx);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_pme_mod_data_create()
+*
+* DESCRIPTION: Create modification data sequence
+*
+* INPUTS:
+*          pme_mod_data     - modification data
+*          hwfm_iptr        - The template jump index, just stroe into private data DB
+*          mh_remove       - whether marvell header needs to be removed
+* OUTPUTS:
+*          hwfm_dptr        - pointer to first private data index
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_mod_data_create(struct tpm_pme_pkt_mod_t *pme_mod_data,
+				   unsigned int hwfm_iptr,
+				   unsigned int *hwfm_dptr,
+				   bool mh_remove)
+{
+	int rc;
+	struct tpm_pme_data_build_t data_build;
+	struct tpm_pme_data_entry_set_t mod_data_set;
+	unsigned int reused_db_idx = 0, share_unit_idx = 0;
+	unsigned int first_hw_free_idx = 0, db_free_idx = 0, data_unit_idx = 0;
+	/* pri_idx_2_share: the private data array internal offset which conatin share data first index */
+	unsigned int pri_idx_2_share[TPM_PME_DATA_UNIT_MAX] = {TPM_PME_INVALID_IDX, TPM_PME_INVALID_IDX};
+	unsigned int data_unit_size;
+	int i, idx;
+
+	IF_NULL(TPM_PME_MOD, pme_mod_data);
+	IF_NULL(TPM_PME_MOD, hwfm_dptr);
+	if (hwfm_iptr >= (TPM_PME_JMP_START + TPM_PME_JMP_AREA_SIZE))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_BAD_PARAM, "Invalid Template Jump index(%d)\n", hwfm_iptr);
+
+	TPM_MEMSET_ZERO(data_build);
+
+	/* Build modification data */
+	rc = tpm_pme_mod_data_build(pme_mod_data, &data_build, mh_remove);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Modification data build failed\n");
+
+	/* Check modification data empty or not */
+	if (!data_build.private_idx)
+		return TPM_OK;
+
+	/* Allocate Share data table index */
+	share_unit_idx = TPM_PME_DATA_UNIT0;
+	for (i = 0; i < data_build.private_idx; i++) {
+		if (data_build.private_data[i] == TPM_PME_SHARE_NEED) {
+			if (share_unit_idx >= TPM_PME_DATA_UNIT_MAX)
+				IF_ERROR_STR(TPM_PME_MOD, TPM_FAIL, "Private data failed, pls check\n");
+			pri_idx_2_share[share_unit_idx] = i;/* Record the pri index conatin share data index */
+			/* get lock */
+			tpm_db_pme_data_rng_lock(TPM_PME_SHARE_TBL,
+						 data_build.sha_rng[share_unit_idx]);
+			/* Check the data is exist in db, if exist, reuse it */
+			rc = tpm_pme_share_data_exist_check(data_build.sha_rng[share_unit_idx],
+							    data_build.share_data[share_unit_idx],
+							    &mod_data_set,
+							    &reused_db_idx);
+			if (rc) {
+				tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+							   data_build.sha_rng[share_unit_idx]);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Share data exist check failed\n");
+			}
+			/* Find the exist one, reused it if found */
+			if (reused_db_idx != TPM_PME_INVALID_IDX) {
+				/* Set the first HW index in private data */
+				data_build.private_data[i] = mod_data_set.first_idx;
+				/* Increase ref_cnt and update it to DB */
+				mod_data_set.ref_count++;
+				rc = tpm_db_pme_data_set(TPM_PME_SHARE_TBL,
+							 reused_db_idx,
+							 &mod_data_set);
+				/* Unlock, no matter above func fail or success */
+				tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+							   data_build.sha_rng[share_unit_idx]);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Share data Db set failed\n");
+			} else {/* No exist, create it */
+				rc = tpm_pme_data_unit_free_get(TPM_PME_SHARE_TBL,
+								data_build.sha_rng[share_unit_idx],
+								&data_unit_size,
+								&data_unit_idx,
+								&first_hw_free_idx);
+				if (rc) {
+					tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+								   data_build.sha_rng[share_unit_idx]);
+					IF_ERROR_STR(TPM_PME_MOD, rc, "Share data range available unit get fail\n");
+				}
+				TPM_OS_DEBUG(TPM_PME_MOD, "Share Tbl Rng%d, unit_idx=%d, first_hw_idx=%d\n",
+					     data_build.sha_rng[share_unit_idx], data_unit_idx, first_hw_free_idx);
+				/* Write Share data to HW */
+				TPM_MEMSET_ZERO(mod_data_set);
+				mod_data_set.first_idx = first_hw_free_idx;
+				/* Get HW lock */
+				tpm_db_pme_hw_lock();
+				for (idx = 0; idx < (data_build.rng_unit_size[share_unit_idx])/2; idx++) {
+					rc = mvPp2PmeHwDataTblWrite(TPM_PME_SHARE_TBL,
+								    first_hw_free_idx,
+								    data_build.share_data[share_unit_idx][idx]);
+					if (rc) {
+						rc = TPM_HW_ERROR;
+						tpm_db_pme_hw_unlock();
+						tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+									   data_build.sha_rng[share_unit_idx]);
+						IF_ERROR_STR(TPM_PME_MOD, rc, "HW data write failed\n");
+					}
+					mod_data_set.mod_data[idx] = data_build.share_data[share_unit_idx][idx];
+					first_hw_free_idx++;
+				}
+				/* Release HW lock */
+				tpm_db_pme_hw_unlock();
+				/* Update private data of build data */
+				data_build.private_data[i] = mod_data_set.first_idx;
+				/* Update first free index of the range */
+				rc = tpm_pme_data_unit_state_op(TPM_PME_SHARE_TBL,
+								data_build.sha_rng[share_unit_idx],
+								data_unit_idx,
+								TPM_DATA_STATE_SET);
+				if (rc) {
+					tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+								   data_build.sha_rng[share_unit_idx]);
+					IF_ERROR_STR(TPM_PME_MOD, rc, "Share data unit state set fail\n");
+				}
+				/* Record Share data to DB */
+				rc = tpm_db_pme_data_free_db_idx_get(TPM_PME_SHARE_TBL, &db_free_idx);
+				if (rc) {
+					tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+								   data_build.sha_rng[share_unit_idx]);
+					IF_ERROR_STR(TPM_PME_MOD, rc, "Data DB get failed\n");
+				}
+				mod_data_set.tbl = TPM_PME_SHARE_TBL;
+				mod_data_set.range = data_build.sha_rng[share_unit_idx];
+				mod_data_set.real_entry_cnt = data_build.rng_unit_size[share_unit_idx] / 2;
+				mod_data_set.ref_count++;
+				mod_data_set.valid = TPM_DATA_VALID;
+				rc = tpm_db_pme_data_set(TPM_PME_SHARE_TBL,
+							 db_free_idx,
+							 &mod_data_set);
+				/* Unlock, all op finished, no matter above func fail or success */
+				tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL,
+							   data_build.sha_rng[share_unit_idx]);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Data DB set failed\n");
+			}
+			share_unit_idx++;
+		}
+	}
+
+	/* Build_private_data update finished, start handle it */
+	TPM_MEMSET_ZERO(mod_data_set);
+	/* For private data, no reuse, write HW directly */
+	/* Range lock */
+	tpm_db_pme_data_rng_lock(TPM_PME_PRIVATE_TBL,
+				 data_build.pri_rng[TPM_PME_DATA_UNIT0]);/* For private, only one data unit needed */
+	rc = tpm_pme_data_unit_free_get(TPM_PME_PRIVATE_TBL,
+					data_build.pri_rng[TPM_PME_DATA_UNIT0],
+					&data_unit_size,
+					&data_unit_idx,
+					&first_hw_free_idx);
+	if (rc) {
+		tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL,
+					   data_build.pri_rng[TPM_PME_DATA_UNIT0]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Private data range available unit get fail\n");
+	}
+	TPM_OS_DEBUG(TPM_PME_MOD, "Private Tbl Rng%d, unit_idx=%d, first_hw_idx=%d\n",
+		     data_build.pri_rng[TPM_PME_DATA_UNIT0], data_unit_idx, first_hw_free_idx);
+	/* Record first HW idx */
+	mod_data_set.first_idx = first_hw_free_idx;
+	/* Write HW Private Data */
+	/* HW_lock */
+	tpm_db_pme_hw_lock();
+	for (i = 0; i < (data_unit_size / 2); i++) {
+		rc = mvPp2PmeHwDataTblWrite(TPM_PME_PRIVATE_TBL,
+					    first_hw_free_idx,
+					    (unsigned short)data_build.private_data[i]);
+		if (rc) {
+			rc = TPM_HW_ERROR;
+			tpm_db_pme_hw_unlock();
+			tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL,
+						   data_build.pri_rng[TPM_PME_DATA_UNIT0]);
+			IF_ERROR_STR(TPM_PME_MOD, rc, "HW data write failed\n");
+		}
+		mod_data_set.mod_data[i] = (unsigned short)data_build.private_data[i];
+		first_hw_free_idx++;
+	}
+	/* HW_unlock */
+	tpm_db_pme_hw_unlock();
+	/* Update unit state of the range */
+	rc = tpm_pme_data_unit_state_op(TPM_PME_PRIVATE_TBL,
+					data_build.pri_rng[TPM_PME_DATA_UNIT0],
+					data_unit_idx,
+					TPM_DATA_STATE_SET);
+	if (rc) {
+		tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL,
+					   data_build.pri_rng[TPM_PME_DATA_UNIT0]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Private data unit state set fail\n");
+	}
+	/* Record Private data to DB */
+	rc = tpm_db_pme_data_free_db_idx_get(TPM_PME_PRIVATE_TBL, &db_free_idx);
+	if (rc)
+		tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL,
+					   data_build.pri_rng[TPM_PME_DATA_UNIT0]);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Data DB get failed\n");
+	/* Init mod_data_set */
+	mod_data_set.share_idx_ptr[TPM_PME_DATA_UNIT0] = pri_idx_2_share[TPM_PME_DATA_UNIT0];
+	mod_data_set.share_idx_ptr[TPM_PME_DATA_UNIT1] = pri_idx_2_share[TPM_PME_DATA_UNIT1];
+	mod_data_set.tbl = TPM_PME_PRIVATE_TBL;
+	mod_data_set.real_entry_cnt = data_build.private_idx;
+	mod_data_set.range = data_build.pri_rng[TPM_PME_DATA_UNIT0];
+	mod_data_set.ref_count++;
+	mod_data_set.templ_jmp = hwfm_iptr;
+	mod_data_set.valid = TPM_DATA_VALID;
+	rc = tpm_db_pme_data_set(TPM_PME_PRIVATE_TBL,
+				 db_free_idx,
+				 &mod_data_set);
+	/* Unlock, all op finished, no matter above func fail or success */
+	tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL,
+				   data_build.pri_rng[TPM_PME_DATA_UNIT0]);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Data DB set failed\n");
+
+	/* Return first Private data entry index */
+	*hwfm_dptr = mod_data_set.first_idx;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_mod_templ_sel()
+*
+* DESCRIPTION: Select correct instruction template, if IPV4 US PPPoE adding
+* template is selected, update sessionID in instruction data area.
+*
+* INPUTS:
+*          pme_mod_data     - modification data
+* OUTPUTS:
+*          hwfm_iptr        - first instruction pointer, usually jump
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_mod_templ_sel(struct tpm_pme_pkt_mod_t *pme_mod_data,
+				 unsigned int *hwfm_iptr)
+{
+	int rc;
+	int templ_idx;
+	unsigned int ext_mod_bm;
+	unsigned int int_mod_bm;
+	struct tpm_pme_templ_data_t instr_template;
+	MV_PP2_PME_ENTRY PEntry;
+	unsigned short ppoe_sessID = 0;
+
+	IF_NULL(TPM_PME_MOD, pme_mod_data);
+	IF_NULL(TPM_PME_MOD, hwfm_iptr);
+
+	ext_mod_bm = pme_mod_data->mod_data.mod_bm;
+	int_mod_bm = pme_mod_data->inter_mod_bm;
+	/* For no_mod and pure VLAN mod, no necessary to consider IPVx */
+	if (!ext_mod_bm || ext_mod_bm == TPM_VLAN_MOD)
+		int_mod_bm &= (~TPM_MOD_PKT_IS_IP6);
+	/* For modification, except no_mod, they are all based on VLAN */
+	if (ext_mod_bm) {
+		ext_mod_bm |= TPM_VLAN_MOD;
+		/* for mod except no_mod and pure VLAN mod, they are all based on DSCP */
+		if (ext_mod_bm & (~TPM_VLAN_MOD))
+			ext_mod_bm |= TPM_IP_DSCP_SET;
+	}
+	/* Search Template in DB according to external mod_bm and internal mod_bm */
+	/* Lock template */
+	tpm_db_pme_templ_lock();
+	for (templ_idx = 0; templ_idx < TPM_PME_INSTR_TEMPL_MAX; templ_idx++) {
+		rc = tpm_db_pme_instr_templ_get(templ_idx, &instr_template);
+		if (rc) {
+			tpm_db_pme_templ_unlock();
+			IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) get failed\n", templ_idx);
+		}
+		if (instr_template.ext_mod_bm == ext_mod_bm &&
+		    instr_template.int_mod_bm == int_mod_bm) {
+			/* check IPV4 US NAPT PPPoE add */
+			if (ext_mod_bm == TPM_PME_NAPT_US_BM2) {
+				ppoe_sessID = pme_mod_data->mod_data.pppoe_mod.ppp_session;
+				/* HW access lock */
+				tpm_db_pme_hw_lock();
+				/* Read original PME entry first */
+				if (mvPp2PmeHwRead(instr_template.ppoe_idx, &PEntry)) {
+					/* Unlock HW and template DB */
+					tpm_db_pme_hw_unlock();
+					tpm_db_pme_templ_unlock();
+					IF_ERROR_STR(TPM_PME_MOD,
+						     TPM_HW_ERROR,
+						     "PME entry(%d) read failed\n",
+						     instr_template.ppoe_idx);
+				}
+				/* Read success, if (ref_count >0), check original sessID*/
+				if (instr_template.ref_count) {
+					if (MV_PP2_PME_DATA_GET(&PEntry) == ppoe_sessID) {
+						/* Unlock HW */
+						tpm_db_pme_hw_unlock();
+						instr_template.ref_count++;
+						/* Update DB */
+						rc = tpm_db_pme_instr_templ_set(templ_idx, &instr_template);
+						/* Unlock template */
+						tpm_db_pme_templ_unlock();
+						IF_ERROR_STR(TPM_PME_MOD, rc, "Template DB(%d) set fail\n", templ_idx);
+						/* Return template jump index */
+						*hwfm_iptr = instr_template.jmp_idx;
+						break;
+					} else {/* If sessID not equal, search other available entry */
+						/* Unlock HW */
+						tpm_db_pme_hw_unlock();
+						continue;
+					}
+				}
+				/* ref_count=0, update mod_data with sessID */
+				if (mvPp2PmeSwCmdDataSet(&PEntry, ppoe_sessID)) {
+					/* Unlock HW and template DB */
+					tpm_db_pme_hw_unlock();
+					tpm_db_pme_templ_unlock();
+					IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "mvPp2PmeSwCmdDataSet failed\n");
+				}
+				/* Write to HW */
+				if (mvPp2PmeHwWrite(instr_template.ppoe_idx, &PEntry)) {
+					/* Unlock HW and template DB */
+					tpm_db_pme_hw_unlock();
+					tpm_db_pme_templ_unlock();
+					IF_ERROR_STR(TPM_PME_MOD,
+						     TPM_HW_ERROR,
+						     "PME entry(%d) write failed\n",
+						     instr_template.ppoe_idx);
+				}
+				/* Unlock HW */
+				tpm_db_pme_hw_unlock();
+			}
+
+			/* check IPV4/6 DS UNI/MC Route with PPoE del, TPM_PME_ROUTE_BM3 */
+			if (ext_mod_bm == TPM_PME_ROUTE_BM3) {
+				/* Multist, DA stroed into Private data */
+				if (TPM_IS_MULTICAST_MAC(pme_mod_data->mod_data.eth_dst)) {
+					if (((instr_template.mac_rep_info >> TPM_ADDR_REP_INFO_DA_TYPE_OFF) &
+					     TPM_ADDR_REP_INFO_MASK) != TPM_PME_CMD_TYPE1)
+						continue;
+				} else {/* UNI ROUTE, DA stroed into Share data */
+					if (((instr_template.mac_rep_info >> TPM_ADDR_REP_INFO_DA_TYPE_OFF) &
+					     TPM_ADDR_REP_INFO_MASK) != TPM_PME_CMD_TYPE2)
+						continue;
+				}
+			}
+
+			/* Increase ref_count */
+			instr_template.ref_count++;
+			/* Update sessionID */
+			instr_template.pme_entry[instr_template.ppoe_idx - instr_template.start_idx].data = ppoe_sessID;
+			/* Update DB */
+			rc = tpm_db_pme_instr_templ_set(templ_idx, &instr_template);
+			/* Unlock template */
+			tpm_db_pme_templ_unlock();
+			IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) set failed\n", templ_idx);
+			/* Return template jump index */
+			*hwfm_iptr = instr_template.jmp_idx;
+			break;
+		}
+	}
+
+	/* Again search with easy condition only for DS pure VLAN mod, pbit can be from QoS table*/
+	if (templ_idx == TPM_PME_INSTR_TEMPL_MAX) {
+		for (templ_idx = 0; templ_idx < TPM_PME_INSTR_TEMPL_MAX; templ_idx++) {
+			rc = tpm_db_pme_instr_templ_get(templ_idx, &instr_template);
+			if (rc) {
+				tpm_db_pme_templ_unlock();
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) get failed\n", templ_idx);
+			}
+			if (ext_mod_bm == TPM_VLAN_MOD &&
+			    instr_template.ext_mod_bm == ext_mod_bm &&
+			    instr_template.int_mod_bm == TPM_MH_T1_MOD) {
+				/* Increase ref_count */
+				instr_template.ref_count++;
+				/* Update DB */
+				rc = tpm_db_pme_instr_templ_set(templ_idx, &instr_template);
+				/* Unlock template */
+				tpm_db_pme_templ_unlock();
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) set failed\n", templ_idx);
+				/* Return template jump index */
+				*hwfm_iptr = instr_template.jmp_idx;
+				break;
+			}
+		}
+	}
+
+	/* Template no match */
+	if (templ_idx == TPM_PME_INSTR_TEMPL_MAX) {
+		/* Unlock template */
+		tpm_db_pme_templ_unlock();
+		rc = TPM_NOT_FOUND;
+		IF_ERROR_STR(TPM_PME_MOD,
+			     rc,
+			     "Template, ext_mod_bm=0x%x(original ext_mod_bm=0x%x), int_mod_bm=0x%x, NOT Found\n",
+			     ext_mod_bm,
+			     pme_mod_data->mod_data.mod_bm,
+			     int_mod_bm);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_mod_create()
+*
+* DESCRIPTION: Create modification, including data create and instruction select
+*
+* INPUTS:
+*          pme_mod_data     - modification data
+* OUTPUTS:
+*          hwfm_dptr        - first instruction pointer, usually jump
+*          hwfm_dptr        - pointer to first private data index
+*          mh_remove       - whether marvell header needs to be removed
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+int tpm_pme_mod_create(struct tpm_pme_pkt_mod_t *pme_mod_data,
+		       unsigned int *hwfm_iptr,
+		       unsigned int *hwfm_dptr,
+		       bool mh_remove)
+{
+	int rc;
+
+	/* Instruction template select */
+	rc = tpm_pme_mod_templ_sel(pme_mod_data, hwfm_iptr);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Modification instruction template select fail\n");
+
+	/* Mod data create */
+	rc = tpm_pme_mod_data_create(pme_mod_data, (*hwfm_iptr), hwfm_dptr, mh_remove);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Modification data create fail\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_priv_first_data_update()
+*
+* DESCRIPTION: The API to update the fist private data.
+*
+* INPUTS:
+*          index     - index of first private data
+* OUTPUTS:
+*          data      - new data
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*
+* COMMENT:
+*        the API is supplied for user to update UNI bitmap in DS.
+*******************************************************************************/
+int tpm_pme_priv_first_data_update(unsigned int index, unsigned short data)
+{
+	int rc;
+	int data_db_idx, templ_db_idx;
+	struct tpm_pme_data_entry_set_t db_data;
+	struct tpm_pme_templ_data_t instr_templ;
+
+	/* Find corresponding entry in DB */
+	for (data_db_idx = 0; data_db_idx < TPM_PME_PRIVATE_SET_MAX; data_db_idx++) {
+		rc = tpm_db_pme_data_get(TPM_PME_PRIVATE_TBL, data_db_idx, &db_data);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "PME DB get fail\n");
+		if ((db_data.valid == TPM_DATA_VALID) &&
+		    (db_data.tbl == TPM_PME_PRIVATE_TBL) &&
+		    (db_data.first_idx == index))
+			break;
+	}
+	if (data_db_idx == TPM_PME_PRIVATE_SET_MAX) {
+		rc = TPM_NOT_FOUND;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "DB entry not found\n");
+	}
+
+	/* Find Instruction template in DB */
+	for (templ_db_idx = 0; templ_db_idx < TPM_PME_INSTR_TEMPL_MAX; templ_db_idx++) {
+		rc = tpm_db_pme_instr_templ_get(templ_db_idx, &instr_templ);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "PME DB get fail\n");
+		if ((instr_templ.valid == TPM_INSTR_TEMPL_VALID) &&
+		    (instr_templ.jmp_idx == db_data.templ_jmp))
+			break;
+	}
+	if (templ_db_idx == TPM_PME_INSTR_TEMPL_MAX) {
+		rc = TPM_NOT_FOUND;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Templ DB entry not found\n");
+	}
+
+	/* DS NAPT, MH in instruction data, can not modify */
+	if (instr_templ.ext_mod_bm != TPM_PME_NAPT_DS_BM1 &&
+	    instr_templ.ext_mod_bm != TPM_PME_NAPT_DS_BM2) {
+		/* Update HW */
+		rc = mvPp2PmeHwDataTblWrite(TPM_PME_PRIVATE_TBL, index, data);
+		if (rc) {
+			rc = TPM_HW_ERROR;
+			IF_ERROR_STR(TPM_PME_MOD, rc, "mvPp2PmeHwDataTblWrite fail\n");
+		}
+
+		/* Update DB */
+		db_data.mod_data[0] = data;
+		rc = tpm_db_pme_data_set(TPM_PME_PRIVATE_TBL, data_db_idx, &db_data);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "PME DB set fail\n");
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_data_tbl_rng_get()
+*
+* DESCRIPTION: Calculate the range index and internal unit index according
+* data table HW index
+*
+* INPUTS:
+*          tbl_idx     - data table index
+*          hw_idx      - entry HW index
+* OUTPUTS:
+*          rng_idx        - range the HW_idx belong to
+*          unit_idx       - unit index in range
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+*******************************************************************************/
+static int tpm_pme_data_tbl_rng_get(unsigned int tbl_idx,
+				    unsigned int hw_idx,
+				    unsigned int *rng_idx,
+				    unsigned int *unit_idx)
+{
+	int rc;
+	struct tpm_pme_tbl_rng_t rng_mng_data;
+
+	/* Parameter Check */
+	IF_NULL(TPM_PME_MOD, rng_idx);
+	IF_NULL(TPM_PME_MOD, unit_idx);
+	if (tbl_idx >= TPM_PME_TBL_MAX)
+		IF_ERROR_STR(TPM_PME_MOD, TPM_BAD_PARAM, "Invalid input tbl_idx(%d)\n", tbl_idx);
+
+	if (tbl_idx == TPM_PME_PRIVATE_TBL) {
+		if (hw_idx < TPM_PME_PRI_L2_SW_START)
+			*rng_idx = TPM_PME_PRI_RNG_NO_MOD;
+
+		if (hw_idx >= TPM_PME_PRI_L2_SW_START &&
+		    hw_idx < TPM_PME_PRI_ROUTE_START)
+			*rng_idx = TPM_PME_PRI_RNG_L2_SW;
+
+		if (hw_idx >= TPM_PME_PRI_ROUTE_START &&
+		    hw_idx < TPM_PME_PRI_NAPT_US_START)
+			*rng_idx = TPM_PME_PRI_RNG_ROUTE;
+
+		if (hw_idx >= TPM_PME_PRI_NAPT_US_START &&
+		    hw_idx < TPM_PME_PRI_NAPT_DS_START)
+			*rng_idx = TPM_PME_PRI_RNG_US_NAPT;
+
+		if (hw_idx >= TPM_PME_PRI_NAPT_DS_START)
+			*rng_idx = TPM_PME_PRI_RNG_DS_NAPT;
+	} else {
+		if (hw_idx < TPM_PME_SHA_SA_SIP_START)
+			*rng_idx = TPM_PME_SHA_RNG_MAC;
+
+		if (hw_idx >= TPM_PME_SHA_SA_SIP_START &&
+		    hw_idx < TPM_PME_SHA_DA_SA_DIP_START)
+			*rng_idx = TPM_PME_SHA_RNG_SA_SIP;
+
+		if (hw_idx >= TPM_PME_SHA_DA_SA_DIP_START)
+			*rng_idx = TPM_PME_SHA_RNG_DA_SA_DIP;
+	}
+
+	rc = tpm_db_pme_data_rng_info_get(tbl_idx, *rng_idx, &rng_mng_data);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "Range management info get fail\n");
+
+	*unit_idx = (hw_idx - rng_mng_data.start)/(rng_mng_data.unit_size/2);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* tpm_pme_mod_release()
+*
+* DESCRIPTION: Release template and delete privte data unit.
+* 1) delete DB entry
+* 2) release HW resource with state bit
+* 3) decrease share data entry's ref_count
+* 4) decrease instruction template ref_count
+*
+* INPUTS:
+*          hwfm_iptr     - Instruction template jump index
+*          hwfm_dptr     - pointer to first private data index
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+* NOTE: No HW access is needed
+*******************************************************************************/
+int tpm_pme_mod_release(unsigned int hwfm_iptr, unsigned int hwfm_dptr)
+{
+	int rc;
+	int pri_db_idx, sha_db_idx, sha_unit_idx;
+	struct tpm_pme_data_entry_set_t pri_data_db, sha_data_db;
+	struct tpm_pme_templ_data_t instr_template;
+	unsigned int rng_idx, unit_idx, templ_idx;
+
+	/* Get range indx */
+	if (hwfm_dptr) {/* hwfm_dptr 0 is not a valid private index in TPM */
+		rc = tpm_pme_data_tbl_rng_get(TPM_PME_PRIVATE_TBL, hwfm_dptr, &rng_idx, &unit_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Range index get fail\n");
+		/* Delete TPM data DB */
+		/* Lock here not necessary */
+		for (pri_db_idx = 0; pri_db_idx < TPM_PME_PRIVATE_SET_MAX; pri_db_idx++) {
+			rc = tpm_db_pme_data_get(TPM_PME_PRIVATE_TBL, pri_db_idx, &pri_data_db);
+			IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Private data DB entry(%d) get fail\n", pri_db_idx);
+			if (hwfm_dptr == pri_data_db.first_idx &&
+			    pri_data_db.valid == TPM_DATA_VALID)
+				break;
+		}
+		if (pri_db_idx == TPM_PME_PRIVATE_SET_MAX)
+			IF_ERROR_STR(TPM_PME_MOD, TPM_NO_SUCH,
+				"Private DB entry with first_idx(%d) no found\n", hwfm_dptr);
+
+		/* Delete DB by invalid the entry */
+		pri_data_db.valid = TPM_DATA_INVALID;
+		rc = tpm_db_pme_data_set(TPM_PME_PRIVATE_TBL, pri_db_idx, &pri_data_db);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Private data DB entry(%d) set fail\n", pri_db_idx);
+
+		/* Release Private unit by clear state bit */
+		/* Lock the range */
+		tpm_db_pme_data_rng_lock(TPM_PME_PRIVATE_TBL, rng_idx);
+		rc = tpm_pme_data_unit_state_op(TPM_PME_PRIVATE_TBL, rng_idx, unit_idx, TPM_DATA_STATE_CLEAR);
+		tpm_db_pme_data_rng_unlock(TPM_PME_PRIVATE_TBL, rng_idx);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Private data unit state set fail\n");
+
+		/* Decrease share data unit ref_count if have one */
+		for (sha_unit_idx = 0; sha_unit_idx < TPM_PME_DATA_UNIT_MAX; sha_unit_idx++) {
+			if (pri_data_db.share_idx_ptr[sha_unit_idx] != TPM_PME_INVALID_IDX) {
+				/* Get the share data range */
+				rc = tpm_pme_data_tbl_rng_get(TPM_PME_SHARE_TBL,
+						pri_data_db.mod_data[pri_data_db.share_idx_ptr[sha_unit_idx]],
+						&rng_idx,
+						&unit_idx);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "Range index get fail\n");
+				/* Lock the range */
+				tpm_db_pme_data_rng_lock(TPM_PME_SHARE_TBL, rng_idx);
+				for (sha_db_idx = 0; sha_db_idx < TPM_PME_SHARE_SET_MAX; sha_db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, sha_db_idx, &sha_data_db);
+					if (rc)
+						tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL, rng_idx);
+					IF_ERROR_STR(TPM_PME_MOD, rc,
+						"TPM Share data DB entry(%d) get fail\n", sha_db_idx);
+					if ((pri_data_db.mod_data[pri_data_db.share_idx_ptr[sha_unit_idx]] ==
+					     sha_data_db.first_idx) &&
+					    sha_data_db.valid == TPM_DATA_VALID)
+						break;
+				}
+				if (sha_db_idx == TPM_PME_SHARE_SET_MAX) {
+					/* unlock the range */
+					tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL, rng_idx);
+					IF_ERROR_STR(TPM_PME_MOD, TPM_NO_SUCH,
+						     "Share DB entry with first_idx(%d) no found\n",
+						     pri_data_db.share_idx_ptr[TPM_PME_DATA_UNIT0]);
+				}
+				/* Decrease ref_count */
+				sha_data_db.ref_count--;
+				rc = tpm_db_pme_data_set(TPM_PME_SHARE_TBL, sha_db_idx, &sha_data_db);
+				/* Unlock */
+				tpm_db_pme_data_rng_unlock(TPM_PME_SHARE_TBL, rng_idx);
+				IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Share data DB entry(%d) set fail\n", sha_db_idx);
+			}
+		}
+	}
+	/* Decrease ref_count of the template */
+	/* Lock template */
+	tpm_db_pme_templ_lock();
+	for (templ_idx = 0; templ_idx < TPM_PME_INSTR_TEMPL_MAX; templ_idx++) {
+		rc = tpm_db_pme_instr_templ_get(templ_idx, &instr_template);
+		if (rc)
+			tpm_db_pme_templ_unlock();
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) get failed\n", templ_idx);
+		if (instr_template.jmp_idx == hwfm_iptr) {
+			instr_template.ref_count--;
+			rc = tpm_db_pme_instr_templ_set(templ_idx, &instr_template);
+			tpm_db_pme_templ_unlock();
+			IF_ERROR_STR(TPM_PME_MOD, rc, "Instruction template DB(%d) set failed\n", templ_idx);
+			break;
+		}
+	}
+	if (templ_idx == TPM_PME_INSTR_TEMPL_MAX) {
+		/* Unlock template */
+		tpm_db_pme_templ_unlock();
+		rc = TPM_NO_SUCH;
+		IF_ERROR_STR(TPM_PME_MOD, rc, "Instr template with jum(%d) No found\n", hwfm_iptr);
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_hw_init
+*
+* DESCRIPTION: The API will do PME HW config:
+*              Including mod_vlan_tpid, default VLAN, default DSA, PPPoE ethertype,
+*              PPPoE protocol, etc..
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_pme_start.
+*******************************************************************************/
+static int tpm_pme_hw_init(void)
+{
+	int rc;
+	unsigned short tpid;
+	unsigned int i;
+
+	/* VLAN TPID Regs */
+	for (i = 0; i < TPM_NUM_VLAN_ETYPE_REGS; i++) {
+		rc = tpm_db_init_mod_tpid_get(i, &tpid);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "VLAN TPID DB get failed\n");
+		/* Invalid TPID Skip */
+		if (TPM_INVALID_TPID == tpid)
+			continue;
+		if (mvPp2PmeVlanEtherTypeSet(i, tpid))
+			IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "VLAN TPID Init failed\n");
+	}
+	/* Default VLAN Cfg */
+	if (mvPp2PmeVlanDefaultSet((TPM_VLAN_ETY_VLAN1 << TPM_PME_ETY_OFFS) |
+				   (TPM_VLAN_VID_VLAN1 << TPM_PME_VID_OFFS) |
+				   (TPM_VLAN_PBIT_VLAN1 << TPM_PME_PBIT_OFFS)))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "Default VLAN Config Init failed\n");
+	/* Default DSA Cfg, TBD */
+
+	/* PPPoE Ether Type, US add PPPoE, type is 0x8864 */
+	if (mvPp2PmePppoeEtypeSet(ETH_P_PPP_SES))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "PPPoE EtherType Init failed\n");
+
+	/* PPoE Length Config, which is used as input when calculated length, replace modification data
+	*  PPPoE_Len = IP_Len + 2(Length of Point to Point Protocol)
+	*  IP_Len = Pkt_Len - L3_Offset
+	*/
+	if (mvPp2PmePppoeLengthSet(TPM_PME_PPOE_LEN_CFG))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "PPPoE Length Config Set failed\n");
+
+	/* Clear PME tables */
+	if (mvPp2PmeHwInvAll())
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "PME Instruction Invalid All failed\n");
+	if (mvPp2PmeHwDataTblClear(TPM_PME_PRIVATE_TBL))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "PME Table0 Clear failed\n");
+	if (mvPp2PmeHwDataTblClear(TPM_PME_SHARE_TBL))
+		IF_ERROR_STR(TPM_PME_MOD, TPM_HW_ERROR, "PME Table1 Clear failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_lpbk_mh_instr_add
+*
+* DESCRIPTION: The API will do PME HW config for MH modification
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_pme_start.
+*******************************************************************************/
+static int tpm_pme_lpbk_mh_instr_add(void)
+{
+	int rc;
+	struct tpm_pme_entry_t pme_entry;
+
+	TPM_MEMSET_ZERO(pme_entry);
+
+	pme_entry.opcode = TPM_PME_CMD_REPLACE_MSB;
+	pme_entry.last = TPM_PME_CMD_LAST;
+	pme_entry.cmd_type = TPM_PME_CMD_TYPE0;
+
+	/* GMAC0 */
+	pme_entry.data = TPM_PME_LPBK_MH_G0 | TPM_PME_LPBK_MH_MASK;
+	rc = tpm_pme_hw_entry_write(TPM_PME_LPBK_GMAC0_IPTR, &pme_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "tpm_pme_hw_entry_write failed\n");
+
+	/* GMAC1 */
+	pme_entry.data = TPM_PME_LPBK_MH_G1 | TPM_PME_LPBK_MH_MASK;
+	rc = tpm_pme_hw_entry_write(TPM_PME_LPBK_GMAC1_IPTR, &pme_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "tpm_pme_hw_entry_write failed\n");
+
+	/* PON */
+	pme_entry.data = TPM_PME_LPBK_MH_PON | TPM_PME_LPBK_MH_MASK;
+	rc = tpm_pme_hw_entry_write(TPM_PME_LPBK_PON_IPTR, &pme_entry);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "tpm_pme_hw_entry_write failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_start
+*
+* DESCRIPTION: The API will do following operations:
+*              1)PME config, such as mod_vlan_tpid, default VLAN, default DSA, PPPoE ethertype, PPPoE protocol
+*              2)Clear PME instruction table, private data area and share data area
+*              3)Add modification instruction templates and sub routines supported
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           It is called by tpm_start.
+*******************************************************************************/
+int tpm_pme_start(void)
+{
+	int rc;
+	unsigned int i;
+	/* Instruction Template Number */
+	static int tpm_pme_no_mod_templ_num = sizeof(g_tpm_pme_templ_no_mod)/sizeof(g_tpm_pme_templ_no_mod[0]);
+	static int tpm_pme_l2_switch_templ_num = sizeof(g_tpm_pme_templ_l2_switch)/sizeof(g_tpm_pme_templ_l2_switch[0]);
+	static int tpm_pme_ipv4_napt_templ_num = sizeof(g_tpm_pme_templ_ipv4_napt)/sizeof(g_tpm_pme_templ_ipv4_napt[0]);
+	static int tpm_pme_ipv4_route_templ_num =
+					sizeof(g_tpm_pme_templ_ipv4_route)/sizeof(g_tpm_pme_templ_ipv4_route[0]);
+	static int tpm_pme_ipv6_route_templ_num =
+					sizeof(g_tpm_pme_templ_ipv6_route)/sizeof(g_tpm_pme_templ_ipv6_route[0]);
+	static int tpm_pme_ipv4_mc_templ_num = sizeof(g_tpm_pme_templ_ipv4_mc)/sizeof(g_tpm_pme_templ_ipv4_mc[0]);
+	static int tpm_pme_ipv6_mc_templ_num = sizeof(g_tpm_pme_templ_ipv6_mc)/sizeof(g_tpm_pme_templ_ipv6_mc[0]);
+
+	/* Init PME Config */
+	rc = tpm_pme_hw_init();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM PME HW init failed\n");
+
+	/* Add template and subroutines */
+	for (i = 0; i < VLANOP_MAX_CNT; i++) {
+		rc = tpm_db_pme_vlan_permu_stat_set(i, &g_vlan_subr_permu[i]);
+		IF_ERROR_STR(TPM_PME_MOD, rc, "TPM VLAN subroutine permutation statistics set failed\n");
+	}
+	rc = tpm_pme_vlan_templ_create();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM VLAN subroutine create failed\n");
+
+	rc = tpm_pme_addr_rep_templ_create();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Address Replacement subroutine create failed\n");
+
+	/* Add instruction template */
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_no_mod, tpm_pme_no_mod_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of none mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_l2_switch, tpm_pme_l2_switch_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of L2 switch mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_ipv4_napt, tpm_pme_ipv4_napt_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of IPV4 NAPT mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_ipv4_route, tpm_pme_ipv4_route_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of IPV4 route mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_ipv6_route, tpm_pme_ipv6_route_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of IPV6 route mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_ipv4_mc, tpm_pme_ipv4_mc_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of IPV4 MC mod case create failed\n");
+
+	rc = tpm_pme_instr_templ_create(g_tpm_pme_templ_ipv6_mc, tpm_pme_ipv6_mc_templ_num);
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM Template of IPV6 MC mod case create failed\n");
+
+	/* Add MH modification instruction for LPBK to CPU */
+	rc = tpm_pme_lpbk_mh_instr_add();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM add PME instruction for loopback port failed\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_reset
+*
+* DESCRIPTION: The API will reset PME module:
+*              1)Clear DB
+*              2)Clear HW, Add Template.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*           None.
+*******************************************************************************/
+int tpm_pme_reset(void)
+{
+	int rc;
+
+	/* Reset DB */
+	rc = tpm_db_pme_init();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM PME DB reset failed\n");
+
+	/* Clear HW and add templates */
+	rc = tpm_pme_start();
+	IF_ERROR_STR(TPM_PME_MOD, rc, "TPM PME restart failed\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_policer.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_policer.c
new file mode 100644
index 0000000..82bc191
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_policer.c
@@ -0,0 +1,963 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************
+ * Type Definition
+ ******************************************************************************/
+struct tpm_policer_token_type_t g_tpm_pkt_token_type[] = {
+	/*          token type              rate resolution  max rate   burst resolution  max burst */
+	{TPM_TOKEN_RATE_TYPE_1KBPS_1B,		125,		127875,		1,	65535},
+	{TPM_TOKEN_RATE_TYPE_10KBPS_8B,		1250,		1278750,	8,	524280},
+	{TPM_TOKEN_RATE_TYPE_100KBPS_64B,	12500,		12787500,	64,	4194240},
+	{TPM_TOKEN_RATE_TYPE_1MBPS_512B,	125000,		127875000,	512,	33553920},
+	{TPM_TOKEN_RATE_TYPE_10MBPS_4KB,	1250000,	1278750000,	4096,	268431360},
+};
+
+struct tpm_policer_token_type_t g_tpm_byte_token_type[] = {
+	/*          token type              rate resolution  max rate   burst resolution  max burst */
+	{TPM_TOKEN_RATE_TYPE_1KBPS_1B,		1,		1023,		1,	65535},
+	{TPM_TOKEN_RATE_TYPE_10KBPS_8B,		10,		10230,		8,	524280},
+	{TPM_TOKEN_RATE_TYPE_100KBPS_64B,	100,		102300,		64,	4194240},
+	{TPM_TOKEN_RATE_TYPE_1MBPS_512B,	1000,		1023000,	512,	33553920},
+	{TPM_TOKEN_RATE_TYPE_10MBPS_4KB,	10000,		10230000,	4096,	268431360},
+};
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+/*******************************************************************************
+* tpm_plcr_entry_check()
+*
+* DESCRIPTION: This API verifies a policer entry.
+*
+* INPUTS:
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_check(struct tpm_policer_entry_t *policer_entry)
+{
+	IF_NULL(TPM_PLCR_MOD, policer_entry);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_entry->token_unit, TPM_PLCR_TOKEN_UNIT_PACKETS,
+				"invalid token unit");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_entry->color_mode, TPM_PLCR_AWARE_COLOR_MODE,
+				"invalid color mode");
+
+	/* check CIR, CBS/EBS range */
+	if (policer_entry->token_unit == TPM_PLCR_TOKEN_UNIT_PACKETS) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_entry->cir,
+					g_tpm_pkt_token_type[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_rate, "invalid CIR");
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_entry->cir,
+					g_tpm_byte_token_type[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_rate, "invalid CIR");
+		/* cbs should exceed MTU size */
+		if ((policer_entry->cbs !=  TPM_PLCR_DEFAULT_BURST_SIZE) &&
+		    (policer_entry->cbs < TPM_DEFAULT_L2_MTU_SIZE)) {
+			TPM_OS_ERROR(TPM_PLCR_MOD, "cbs(%d) is too small in byte token mode\n", policer_entry->cbs);
+			return TPM_BAD_PARAM;
+		}
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_plcr_hw_entry_add()
+*
+* DESCRIPTION: This API adds a policer entry to hardware.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_hw_entry_add(unsigned char			policer_id,
+			  struct tpm_policer_entry_t	*policer_entry)
+{
+	enum tpm_plcr_token_update_type_t token_type;
+	unsigned int token_value;
+	struct tpm_policer_token_type_t *token_arr;
+	struct tpm_policer_token_type_t *token_entry;
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, policer_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+	IF_NULL(TPM_PLCR_MOD, policer_entry);
+
+	/* convert CIR to token_type and token_value */
+	if (policer_entry->token_unit == TPM_PLCR_TOKEN_UNIT_PACKETS)
+		token_arr = g_tpm_pkt_token_type;
+	else
+		token_arr = g_tpm_byte_token_type;
+
+	if (policer_entry->cir == TPM_PLCR_CIR_NO_LIMIT)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else if (policer_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_1KBPS_1B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_1KBPS_1B;
+	else if (policer_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_10KBPS_8B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_10KBPS_8B;
+	else if (policer_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_100KBPS_64B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_100KBPS_64B;
+	else if (policer_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_1MBPS_512B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_1MBPS_512B;
+	else if (policer_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	token_entry = token_arr + token_type;
+	token_value = policer_entry->cir/token_entry->rate_resl;
+
+	/* set token unit and type */
+	rc = mvPp2PlcrHwTokenConfig(policer_id, policer_entry->token_unit, token_type);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set token unit and type to HW\n");
+
+	/* set token value */
+	rc = mvPp2PlcrHwTokenValue(policer_id, token_value);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set token value to HW\n");
+
+	/* set color mode */
+	rc = mvPp2PlcrHwColorModeSet(policer_id, policer_entry->color_mode);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set color mode to HW\n");
+
+	/* set CBS and EBS */
+	rc = mvPp2PlcrHwBucketSizeSet(policer_id, policer_entry->cbs, policer_entry->ebs);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set CBS and EBS to HW\n");
+
+	/* enable this policer */
+	rc = mvPp2PlcrHwEnable(policer_id, TPM_PLCR_ENTRY_VALID_STATE);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to enable policer to HW\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_entry_convert()
+*
+* DESCRIPTION: This API convert policer entry, especially CIR.
+*
+* INPUTS:
+*	input_entry  - inputted policer entry configuration.
+*
+* OUTPUTS:
+*	output_entry - inputted policer entry configuration.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_convert(struct tpm_policer_entry_t	*input_entry,
+			   struct tpm_policer_entry_t	*output_entry)
+{
+	enum tpm_plcr_token_update_type_t token_type;
+	struct tpm_policer_token_type_t *token_arr;
+	struct tpm_policer_token_type_t *token_entry;
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_PLCR_MOD, input_entry);
+	IF_NULL(TPM_PLCR_MOD, output_entry);
+
+	/* copy the entry */
+	memcpy(output_entry, input_entry, sizeof(struct tpm_policer_entry_t));
+
+	if (output_entry->token_unit == TPM_PLCR_TOKEN_UNIT_PACKETS)
+		token_arr = g_tpm_pkt_token_type;
+	else
+		token_arr = g_tpm_byte_token_type;
+
+	/* convert the CIR if it is not multiple time of the resolution */
+	if (output_entry->cir == TPM_PLCR_CIR_NO_LIMIT)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else if (output_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_1KBPS_1B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_1KBPS_1B;
+	else if (output_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_10KBPS_8B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_10KBPS_8B;
+	else if (output_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_100KBPS_64B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_100KBPS_64B;
+	else if (output_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_1MBPS_512B].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_1MBPS_512B;
+	else if (output_entry->cir <= token_arr[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_rate)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	token_entry = token_arr + token_type;
+	if (output_entry->cir % token_entry->rate_resl) {
+		TPM_OS_WARN(TPM_PLCR_MOD, "CIR(%d) is not multiple times of resolution(%d), will be adjusted to (%d)\n",
+			    output_entry->cir,
+			    token_entry->rate_resl,
+			    (output_entry->cir/token_entry->rate_resl + 1)*token_entry->rate_resl);
+		if (output_entry->cir == TPM_PLCR_CIR_NO_LIMIT)
+			output_entry->cir = token_arr[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_rate;
+		else
+			output_entry->cir = (output_entry->cir/token_entry->rate_resl + 1)*token_entry->rate_resl;
+	}
+
+	/* convert the CBS if it is not multiple time of the resolution */
+	if (output_entry->cbs == TPM_PLCR_DEFAULT_BURST_SIZE)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else if (output_entry->cbs <= token_arr[TPM_TOKEN_RATE_TYPE_1KBPS_1B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_1KBPS_1B;
+	else if (output_entry->cbs <= token_arr[TPM_TOKEN_RATE_TYPE_10KBPS_8B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_10KBPS_8B;
+	else if (output_entry->cbs <= token_arr[TPM_TOKEN_RATE_TYPE_100KBPS_64B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_100KBPS_64B;
+	else if (output_entry->cbs <= token_arr[TPM_TOKEN_RATE_TYPE_1MBPS_512B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_1MBPS_512B;
+	else if (output_entry->cbs <= token_arr[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	token_entry = token_arr + token_type;
+	if (output_entry->cbs % token_entry->burst_size_resl) {
+		TPM_OS_WARN(TPM_PLCR_MOD, "CBS(%d) is not multiple times of resolution(%d), will be adjusted to (%d)\n",
+			    output_entry->cbs,
+			    token_entry->burst_size_resl,
+			    (output_entry->cbs/token_entry->burst_size_resl + 1)*token_entry->burst_size_resl);
+		if (output_entry->cbs == TPM_PLCR_DEFAULT_BURST_SIZE)
+			output_entry->cbs = TPM_PLCR_DEFAULT_CBS;
+		else
+			output_entry->cbs =
+			(output_entry->cbs/token_entry->burst_size_resl + 1)*token_entry->burst_size_resl;
+	}
+
+	/* convert the EBS if it is not multiple time of the resolution */
+	if (output_entry->ebs == TPM_PLCR_DEFAULT_BURST_SIZE)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else if (output_entry->ebs <= token_arr[TPM_TOKEN_RATE_TYPE_1KBPS_1B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_1KBPS_1B;
+	else if (output_entry->ebs <= token_arr[TPM_TOKEN_RATE_TYPE_10KBPS_8B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_10KBPS_8B;
+	else if (output_entry->ebs <= token_arr[TPM_TOKEN_RATE_TYPE_100KBPS_64B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_100KBPS_64B;
+	else if (output_entry->ebs <= token_arr[TPM_TOKEN_RATE_TYPE_1MBPS_512B].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_1MBPS_512B;
+	else if (output_entry->ebs <= token_arr[TPM_TOKEN_RATE_TYPE_10MBPS_4KB].max_busrt_size)
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	else
+		token_type = TPM_TOKEN_RATE_TYPE_10MBPS_4KB;
+	token_entry = token_arr + token_type;
+	if (output_entry->ebs % token_entry->burst_size_resl) {
+		TPM_OS_WARN(TPM_PLCR_MOD, "CBS(%d) is not multiple times of resolution(%d), will be adjusted to (%d)\n",
+			    output_entry->ebs,
+			    token_entry->burst_size_resl,
+			    (output_entry->ebs/token_entry->burst_size_resl + 1)*token_entry->burst_size_resl);
+		if (output_entry->ebs == TPM_PLCR_DEFAULT_BURST_SIZE)
+			output_entry->ebs = TPM_PLCR_DEFAULT_EBS;
+		else
+			output_entry->ebs =
+			(output_entry->ebs/token_entry->burst_size_resl + 1)*token_entry->burst_size_resl;
+	}
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_entry_add()
+*
+* DESCRIPTION: This API adds a policer entry.
+*
+* INPUTS:
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	policer_id    - policer ID.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_add(struct tpm_policer_entry_t	*policer_entry,
+		       unsigned char			*policer_id)
+{
+	unsigned char l_policer_id;
+	struct tpm_db_plcr_entry_t l_plcr_entry;
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_PLCR_MOD, policer_entry);
+	IF_NULL(TPM_PLCR_MOD, policer_id);
+
+	/* get a free policer entry */
+	rc = tpm_db_plcr_free_id_get(&l_policer_id);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "policer table is full, no free policer entry\n");
+
+	/* validate the input policer entry */
+	rc = tpm_plcr_entry_check(policer_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to check policer entry\n");
+
+	/* Convert CIR and other parameters */
+	TPM_MEMSET_ZERO(l_plcr_entry);
+	rc = tpm_plcr_entry_convert(policer_entry, &l_plcr_entry.plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to convert policer entry\n");
+
+	/* Add policer entry to HW */
+	rc = tpm_plcr_hw_entry_add(l_policer_id, &l_plcr_entry.plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to add policer entry to HW\n");
+
+	/* Add policer entry to DB */
+	l_plcr_entry.valid = TPM_PLCR_ENTRY_VALID_STATE;
+	rc = tpm_db_plcr_entry_set(l_policer_id, &l_plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to save policer entry to DB\n");
+	*policer_id = l_policer_id;
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_hw_entry_del()
+*
+* DESCRIPTION: This API deletes a policer entry from HW.
+*
+* INPUTS:
+*	policer_id  - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_hw_entry_del(unsigned char policer_id)
+{
+	int rc = TPM_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_DB_MOD, policer_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+
+	/* disable this policer */
+	rc = mvPp2PlcrHwEnable(policer_id, TPM_PLCR_ENTRY_INVALID_STATE);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to disable policer to HW\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_entry_del()
+*
+* DESCRIPTION: This API deletes a policer entry.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_del(unsigned char policer_id)
+{
+	struct tpm_db_plcr_entry_t l_plcr_entry;
+	int rc = TPM_OK;
+
+	TPM_DECIMAL_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_id, TPM_PLCR_MIN_ENTRY_ID, MV_PP2_PLCR_NUM - 1,
+				"invalid policer ID");
+
+	/* check police status */
+	rc = tpm_db_plcr_entry_get(policer_id, &l_plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to get policer entry from DB\n");
+	if (l_plcr_entry.valid == TPM_PLCR_ENTRY_INVALID_STATE) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "policer_id(%d) is invalid, don't need to delete it\n", policer_id);
+		return TPM_BAD_PARAM;
+	}
+	if (l_plcr_entry.ref_cnt > 0) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "the policer is still used, ref_cnt(%d), could not be deleted\n",
+			l_plcr_entry.ref_cnt);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Delete policer entry from HW */
+	rc = tpm_plcr_hw_entry_del(policer_id);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to delete policer entry from HW\n");
+
+	/* Delete policer entry from DB */
+	TPM_MEMSET_ZERO(l_plcr_entry);
+	l_plcr_entry.valid = TPM_PLCR_ENTRY_INVALID_STATE;
+	rc = tpm_db_plcr_entry_set(policer_id, &l_plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to delete policer entry from DB\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_entry_clear()
+*
+* DESCRIPTION: This API deletes all policer entries.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_clear(void)
+{
+	unsigned int idx = 0;
+	struct tpm_db_plcr_entry_t plcr_entry;
+	int rc = TPM_OK;
+
+	for (idx = TPM_PLCR_MIN_ENTRY_ID; idx < MV_PP2_PLCR_NUM; idx++) {
+		/* get policer from DB */
+		rc = tpm_db_plcr_entry_get(idx, &plcr_entry);
+		IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to get policer entry from DB\n");
+
+		/* delete the policer if it is valid */
+		if (plcr_entry.valid == TPM_PLCR_ENTRY_VALID_STATE) {
+			rc = tpm_plcr_entry_del(idx);
+			IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to delete policer entry\n");
+		}
+	}
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_ref_cnt_update()
+*
+* DESCRIPTION: This API update the reference counter for a policer entry.
+*
+* INPUTS:
+*	policer_id  - policer ID.
+*	cnt_action  - reference counter action
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_ref_cnt_update(unsigned char			policer_id,
+			    enum tpm_plcr_ref_cnt_action_t	cnt_action)
+{
+	int rc = TPM_OK;
+
+	TPM_DECIMAL_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_id, TPM_PLCR_MIN_ENTRY_ID, MV_PP2_PLCR_NUM - 1,
+				"invalid policer ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, cnt_action, TPM_PLCR_REF_CNT_CLEAR_ALL,
+				"invalid reference counter action");
+
+	/* update the policer reference counter in DB */
+	rc = tpm_db_plcr_ref_cnt_update(policer_id, cnt_action);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to update policer reference counter\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_gen_cfg_set()
+*
+* DESCRIPTION: This API sets policer general parameters.
+*
+* INPUTS:
+*	gen_cfg - policer general configuration.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_gen_cfg_set(struct tpm_policer_gen_cfg_t *gen_cfg)
+{
+	int rc;
+
+	/* parameter verification */
+	IF_NULL(TPM_PLCR_MOD, gen_cfg);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, gen_cfg->rate_state, TPM_PLCR_BASE_RATE_ENABLE,
+				"invalid base rate state");
+	if ((gen_cfg->base_period != TPM_TOKEN_PERIOD_400_CORE_CLOCK) &&
+	    (gen_cfg->base_period != TPM_TOKEN_PERIOD_480_CORE_CLOCK) &&
+	    (gen_cfg->base_period != TPM_TOKEN_PERIOD_600_CORE_CLOCK) &&
+	    (gen_cfg->base_period != TPM_TOKEN_PERIOD_800_CORE_CLOCK)) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "invalid token base period(%d)\n", gen_cfg->base_period);
+		return TPM_BAD_PARAM;
+	}
+
+	/* set token base period */
+	rc = mvPp2PlcrHwBasePeriodSet(gen_cfg->base_period);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set token base period to HW\n");
+
+	/* set base rate generation state */
+	rc = mvPp2PlcrHwBaseRateGenEnable(gen_cfg->rate_state);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set token base rate generation to HW\n");
+
+	/* set min packet length */
+	rc = mvPp2PlcrHwMinPktLen(gen_cfg->min_pkt_len);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set min packet length to HW\n");
+
+	/* save the general configuration to DB */
+	rc = tpm_db_plcr_gen_cfg_set(gen_cfg);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set policer general configuration to DB\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_plcr_early_drop_set()
+*
+* DESCRIPTION: This API sets policer early drop parameters.
+*
+* INPUTS:
+*	early_drop - early drop parameters.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_early_drop_set(struct tpm_policer_early_drop_t *early_drop)
+{
+	unsigned int gmac;
+	unsigned int idx;
+	int txq;
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_PLCR_MOD, early_drop);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, early_drop->state, TPM_PLCR_EARLY_DROP_ENABLE,
+				"invalid early drop state");
+
+	if (early_drop->state == TPM_PLCR_EARLY_DROP_ENABLE) {
+		/* set CPU thresholds */
+		for (idx = 0; idx < MV_PP2_V1_PLCR_EDROP_THRESH_NUM; idx++) {
+			rc = mvPp2V1PlcrHwCpuThreshSet(idx, early_drop->cpu_q_thesh[idx]);
+			IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set CPU queue threshold to HW\n");
+		}
+
+		/* set HWF thresholds */
+		for (idx = 0; idx < MV_PP2_V1_PLCR_EDROP_THRESH_NUM; idx++) {
+			rc = mvPp2V1PlcrHwHwfThreshSet(idx, early_drop->hwf_q_thesh[idx]);
+			IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set HWF queue threshold to HW\n");
+		}
+
+		/* set CPU RX queue index */
+		for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++) {
+			if (early_drop->rxq_idx[idx] != TPM_PLCR_INVALID_Q_THESH_IDX) {
+				rc = mvPp2PlcrHwRxqThreshSet(idx, early_drop->rxq_idx[idx]);
+				IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set RX queue threshold index to HW\n");
+			}
+		}
+
+		/* set HWF TX queue index */
+		for (gmac = 0; gmac < TPM_NUM_TX_PORTS; gmac++) {
+			for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++) {
+				if (early_drop->txq_idx[gmac][idx] != TPM_PLCR_INVALID_Q_THESH_IDX) {
+					txq = (gmac << TPM_QUEUE_HIGH_SHIFT) | idx;
+					rc = mvPp2PlcrHwTxqThreshSet(txq, early_drop->txq_idx[gmac][idx]);
+					IF_ERROR_STR(TPM_PLCR_MOD, rc, "fail to set TX queue threshold index to HW\n");
+				}
+			}
+		}
+	}
+
+	/* set early drop state */
+	rc = mvPp2PlcrHwEarlyDropSet(early_drop->state);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set early drop to HW\n");
+
+	/* save the early drop configuration to DB */
+	rc = tpm_db_plcr_early_drop_set(early_drop);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set policer early drop configuration to DB\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_entry_state_get()
+*
+* DESCRIPTION: This API get the status of a policer entry.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_entry_state_get(unsigned char policer_id, enum tpm_plcr_entry_state_t *state)
+{
+	struct tpm_db_plcr_entry_t l_plcr_entry;
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_PLCR_MOD, state);
+
+	if (policer_id == TPM_POLICER_INVALID) {
+		*state = TPM_PLCR_ENTRY_VALID_STATE;
+		return TPM_OK;
+	}
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_PLCR_MOD, policer_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+
+	/* check police status */
+	rc = tpm_db_plcr_entry_get(policer_id, &l_plcr_entry);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to get policer entry from DB\n");
+	*state = l_plcr_entry.valid;
+	if (l_plcr_entry.ref_cnt > 0)
+		TPM_OS_INFO(TPM_PLCR_MOD, "policer_id(%d) will be used by multiple flows, ref_cnt(%d)\n",
+			policer_id, l_plcr_entry.ref_cnt);
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_reset
+*
+* DESCRIPTION: The routine reset and re-satrt TPM policer sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_mib_reset
+*******************************************************************************/
+int tpm_plcr_reset(void)
+{
+	struct tpm_policer_gen_cfg_t gen_cfg;
+	struct tpm_policer_early_drop_t early_drop;
+	int rc = TPM_OK;
+
+	/* init TPM policer DB */
+	rc = tpm_db_plcr_init();
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "fail to init TPM policer DB\n");
+
+	/* set TPM policer default general configuration */
+	TPM_MEMSET_ZERO(gen_cfg);
+	gen_cfg.rate_state  = TPM_PLCR_BASE_RATE_ENABLE;
+	gen_cfg.base_period = TPM_TOKEN_PERIOD_480_CORE_CLOCK;
+	gen_cfg.min_pkt_len = TPM_PLCR_MIN_PKT_LEN;
+	rc = tpm_plcr_gen_cfg_set(&gen_cfg);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "fail to set TPM policer default general configuration\n");
+
+	/* set TPM policer default early drop configuration */
+	TPM_MEMSET_ZERO(early_drop);
+	early_drop.state = TPM_PLCR_EARLY_DROP_ENABLE;
+	/* to do: set default CPU/HWF threshold and queue index later */
+	rc = tpm_plcr_early_drop_set(&early_drop);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "fail to set TPM policer default early drop configuration\n");
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_plcr_start
+*
+* DESCRIPTION: The routine starts TPM policer sub-module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+* COMMENTS:
+*	This routine is called by tpm_start
+*******************************************************************************/
+int tpm_plcr_start(void)
+{
+	if (tpm_plcr_reset() != TPM_OK) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "TPM policer start failed\n");
+		return TPM_INIT_ERROR;
+	}
+
+	return TPM_OK;
+}
+
+/*###############TPM Egress Rate Limit Section########################*/
+
+/*******************************************************************************
+* tpm_sched_egr_queue_mode_set()
+*
+* DESCRIPTION: Set the egress MTU on the port.
+*
+* INPUTS:
+*          gmac_idx    - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont       - valid for GPON PMAC, other set to 0
+*          tx_size_max - MTU, unit: byte
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_err_t.
+* NOTE: MTU_max=65536B, if more than 65536, change it to 65536
+*******************************************************************************/
+int tpm_sched_egr_mtu_set(enum tpm_gmac_idx_t gmac_idx,
+			  unsigned char tcont_id,
+			  unsigned int tx_size_max)
+{
+	int rc;
+
+	/* Parameters check */
+	if (gmac_idx > TPM_MAC_MAX_IDX) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid GMAC index %d\n", gmac_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (tcont_id >= MV_ETH_MAX_TCONT) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid tcont %d\n", tcont_id);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Set MTU */
+	rc = mvPp2TxpMaxTxSizeSet(gmac_idx, tcont_id, tx_size_max);
+	if (rc) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "MTU set fail on tcont%d of port%d, HW error%d\n", tcont_id, gmac_idx, rc);
+		return TPM_HW_ERROR;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sched_egr_queue_mode_set()
+*
+* DESCRIPTION: Set the egress scheduling mode, strict or wrr.
+*
+* INPUTS:
+*          gmac_idx  - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont     - valid for GPON PMAC, other set to 0
+*          queue_id  - queue index, 0-7
+*          mode      - scheduling mode, strict priority or WRR
+*          wrr_weight- 0-255, if mode is WRR
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_err_t.
+* NOTE: In WRR mode, Weight * 256 bytes * 8 bits must be larger then MTU [bits],
+* if input wrr weight is too small, the smallest proper value will replace it and
+* give a warnning.
+*******************************************************************************/
+int tpm_sched_egr_queue_mode_set(enum tpm_gmac_idx_t gmac_idx,
+				 unsigned char tcont_id,
+				 unsigned char queue_id,
+				 enum tpm_egr_sched_mode_t mode,
+				 unsigned short wrr_weight)
+{
+	int rc;
+	unsigned int mtu = 0;
+
+	/* Parameter Check */
+	if (gmac_idx > TPM_MAC_MAX_IDX) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid GMAC index %d\n", gmac_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (tcont_id >= MV_ETH_MAX_TCONT) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid tcont %d\n", tcont_id);
+		return TPM_BAD_PARAM;
+	}
+	if (wrr_weight > TPM_WRR_WEIGHT_MAX) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid WRR weight %d\n", wrr_weight);
+		return TPM_BAD_PARAM;
+	}
+	if (queue_id >= MV_ETH_MAX_TXQ) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid queue %d\n", queue_id);
+		return TPM_BAD_PARAM;
+	}
+	/* Set mode to HW */
+	if (mode == TPM_SCHED_MODE_STRICT) {
+		rc = mvPp2TxqFixPrioSet(gmac_idx, tcont_id, queue_id);
+		if (rc) {
+			TPM_OS_ERROR(TPM_PLCR_MOD, "Fix Priority set failed, HW error%d\n", rc);
+			return TPM_HW_ERROR;
+		}
+	} else if (mode == TPM_SCHED_MODE_WRR) {
+		/* Weight * 256 bytes * 8 bits must be larger then MTU [bits] */
+		mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_MTU_REG);
+		mtu = (mtu / BYTE_BITS) / TPM_WRR_UNIT_BYTE;
+		if (wrr_weight <= mtu) {
+			wrr_weight = mtu + 1;
+			TPM_OS_WARN(TPM_PLCR_MOD,
+				"Input WRR weight too small, reassign with smallest proper value [%d]\n", wrr_weight);
+		}
+		rc = mvPp2TxqWrrPrioSet(gmac_idx, tcont_id, queue_id, wrr_weight);
+		if (rc) {
+			TPM_OS_ERROR(TPM_PLCR_MOD, "WRR set failed, HW error%d\n", rc);
+			return TPM_HW_ERROR;
+		}
+	} else {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Unknown scheduling mode%d\n", mode);
+		return TPM_BAD_PARAM;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sched_egr_queue_rate_lim_set()
+*
+* DESCRIPTION: The API set the egress rate limit on the queue
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+* NOTE:buckt_size can not less than MTU
+*******************************************************************************/
+int tpm_sched_egr_queue_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				     unsigned char tcont_id,
+				     unsigned char queue_id,
+				     unsigned int rate_lim_val,
+				     unsigned int bucket_size)
+{
+	int rc;
+
+	/* Parameter Check */
+	if (gmac_idx > TPM_MAC_MAX_IDX) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid GMAC index %d\n", gmac_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (tcont_id >= MV_ETH_MAX_TCONT) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid tcont %d\n", tcont_id);
+		return TPM_BAD_PARAM;
+	}
+	if (queue_id >= MV_ETH_MAX_TXQ) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid queue %d\n", queue_id);
+		return TPM_BAD_PARAM;
+	}
+	if (bucket_size * BYTE_BITS < TPM_SCHED_BUCKET_SIZE_MIN) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Bucket size %d too small, at least %d\n",
+			     bucket_size, (TPM_SCHED_BUCKET_SIZE_MIN / BYTE_BITS));
+		return TPM_BAD_PARAM;
+	}
+
+	/* Set bucket size, bytes */
+	rc = mvPp2TxqBurstSet(gmac_idx, tcont_id, queue_id, bucket_size);
+	if (rc) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Bucket size set failed on queue%d of tcont%d in port%d, HW error%d\n",
+			     queue_id, tcont_id, gmac_idx, rc);
+
+		return TPM_HW_ERROR;
+	}
+
+	/* Set rate limit */
+	rc = mvPp2TxqRateSet(gmac_idx, tcont_id, queue_id, rate_lim_val);
+	if (rc) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Rate limit set on queue%d of tcont%d in port%d, HW error%d\n",
+			     queue_id, tcont_id, gmac_idx, rc);
+		return TPM_HW_ERROR;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sched_egr_port_rate_lim_set()
+*
+* DESCRIPTION: The API set the egress rate limit on the port
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+* OUTPUTS:
+*          None
+*
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_db_err_t.
+* NOTE:buckt_size can not less than MTU
+*******************************************************************************/
+int tpm_sched_egr_port_rate_lim_set(enum tpm_gmac_idx_t gmac_idx,
+				    unsigned char tcont_id,
+				    unsigned int rate_lim_val,
+				    unsigned int bucket_size)
+{
+	int rc;
+
+	/* Parameter Check */
+	if (gmac_idx > TPM_MAC_MAX_IDX) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid GMAC index %d\n", gmac_idx);
+		return TPM_BAD_PARAM;
+	}
+	if (tcont_id >= MV_ETH_MAX_TCONT) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Invalid tcont %d\n", tcont_id);
+		return TPM_BAD_PARAM;
+	}
+	if (bucket_size * BYTE_BITS < TPM_SCHED_BUCKET_SIZE_MIN) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Bucket size %d too small, at least %d\n",
+			     bucket_size, (TPM_SCHED_BUCKET_SIZE_MIN / BYTE_BITS));
+		return TPM_BAD_PARAM;
+	}
+
+	/* Set bucket size, bytes */
+	rc = mvPp2TxpBurstSet(gmac_idx, tcont_id, bucket_size);
+	if (rc) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Bucket size set failed on port%d, HW error%d\n", gmac_idx, rc);
+		return TPM_HW_ERROR;
+	}
+
+	/* Set rate limit */
+	rc = mvPp2TxpRateSet(gmac_idx, tcont_id, rate_lim_val);
+	if (rc) {
+		TPM_OS_ERROR(TPM_PLCR_MOD, "Rate limit set on tcont%d in port%d, HW error%d\n",
+			     tcont_id, gmac_idx, rc);
+		return TPM_HW_ERROR;
+	}
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_switch.c
new file mode 100644
index 0000000..b03e93d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/core/tpm_switch.c
@@ -0,0 +1,4122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE : tpm_switch.c                                                      **
+**                                                                           **
+**  DESCRIPTION : This file contains switch routine and APIs                 **
+**  DEPENDCY : None                                                          **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************
+ * Type Definition
+ ******************************************************************************/
+struct tpm_enum_str_t g_sw_enum_ingress_mode[] = {
+	{ TPM_SW_INGRESS_ASIS,		"asis"},
+	{ TPM_SW_INGRESS_DISCARD_ALL,	"discard all"},
+	{ TPM_SW_INGRESS_DISCARD_UNTAG,	"discard untag"},
+	{ TPM_SW_INGRESS_DISCARD_TAG,	"discard tag"},
+};
+
+struct tpm_enum_str_t g_sw_enum_egress_mode[] = {
+	{ TPM_SW_VLAN_EGRESS_ASIS,		"asis"},
+	{ TPM_SW_VLAN_EGRESS_NOT_IN_VLAN,	"Not in VLAN"},
+	{ TPM_SW_VLAN_EGRESS_KEEP_VLAN,		"keep VLAN"},
+	{ TPM_SW_VLAN_EGRESS_STRIP_VLAN,	"strip VLAN"},
+};
+
+struct tpm_enum_str_t g_sw_enum_config_state[] = {
+	{ TPM_SW_CONFIG_DISABLE,	"disabled"},
+	{ TPM_SW_CONFIG_ENABLE,		"enabled"},
+};
+
+struct tpm_enum_str_t g_sw_enum_flood_type[] = {
+	{ TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST,		"unknown DA unicast packet"},
+	{ TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST,		"unknown SA unicast packet"},
+	{ TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST,	"unknown IPv4 multicast packet"},
+	{ TPM_SW_FLOOD_PKT_BROADCAST,			"unknown broadcast packet"},
+	{ TPM_SW_FLOOD_PKT_OTHER_PORT_SA,		"SA already learned by other port"},
+	{ TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST,	"unknown IPv6 multicast packet"},
+};
+
+struct tpm_enum_str_t g_sw_enum_speed_mode[] = {
+	{ TPM_SW_SPEED_MODE_10M,	"10M"},
+	{ TPM_SW_SPEED_MODE_100M,	"100M"},
+	{ TPM_SW_SPEED_MODE_1000M,	"1000M"},
+	{ TPM_SW_SPEED_MODE_AUTO,	"auto"},
+};
+
+struct tpm_enum_str_t g_sw_enum_duplex_mode[] = {
+	{ TPM_SW_DUPLEX_MODE_HALF,	"half duplex"},
+	{ TPM_SW_DUPLEX_MODE_FULL,	"full duplex"},
+	{ TPM_SW_DUPLEX_MODE_AUTO,	"auto"},
+};
+
+struct tpm_enum_str_t g_sw_enum_port_state[] = {
+	{ TPM_SW_PORT_STATE_DOWN,	"down"},
+	{ TPM_SW_PORT_STATE_UP,		"up"},
+};
+
+struct tpm_enum_str_t g_sw_enum_port_dir[] = {
+	{ TPM_SW_PORT_DIR_INGRESS,	"ingress"},
+	{ TPM_SW_PORT_DIR_EGRESS,	"egress"},
+	{ TPM_SW_PORT_DIR_BOTH,		"both dir"},
+};
+
+struct tpm_enum_str_t g_sw_enum_rate_limit_mode[] = {
+	{ TPM_SW_RATE_LIMIT_FRAME,	"frame"},
+	{ TPM_SW_RATE_LIMIT_LAYER1,	"layer 1"},
+	{ TPM_SW_RATE_LIMIT_LAYER2,	"layer 2"},
+	{ TPM_SW_RATE_LIMIT_LAYER3,	"layer 3"},
+};
+
+struct tpm_enum_str_t g_sw_enum_mac_type[] = {
+	{ TPM_SW_MAC_ADDR_DYNAMIC,	"dynamic MAC addr"},
+	{ TPM_SW_MAC_ADDR_STATIC,	"static MAC addr"},
+	{ TPM_SW_MAC_ADDR_UNICAST,	"unicast MAC addr"},
+	{ TPM_SW_MAC_ADDR_MULTICAST,	"multicast MAC addr"},
+	{ TPM_SW_MAC_ADDR_ALL,		"all MAC addr"},
+};
+
+struct tpm_enum_str_t g_sw_enum_filter_mode[] = {
+	{ TPM_SW_MAC_NO_FILTER,		"no filter"},
+	{ TPM_SW_MAC_BLACK_FILTER_DMAC,	"black filter DMAC"},
+	{ TPM_SW_MAC_WHITE_FILTER_DMAC,	"white filter DMAC"},
+	{ TPM_SW_MAC_BLACK_FILTER_SMAC,	"black filter SMAC"},
+	{ TPM_SW_MAC_WHITE_FILTER_SMAC,	"white filter SMAC"},
+};
+
+struct tpm_enum_str_t g_sw_enum_qos_mode[] = {
+	{ TPM_SW_QOS_MODE_SP,		"SP"},
+	{ TPM_SW_QOS_MODE_WRR,		"WRR"},
+	{ TPM_SW_QOS_MODE_SP_WRR,	"SP and WRR"},
+};
+
+struct tpm_enum_str_t g_sw_enum_head_mode[] = {
+	{ TPM_SW_HEAD_NONE,		"No header"},
+	{ TPM_SW_HEAD_MH,		"Marvell header"},
+	{ TPM_SW_HEAD_MH_ETYPE_DSA,	"Eth type DSA"},
+	{ TPM_SW_HEAD_DSA,		"DSA"},
+	{ TPM_SW_HEAD_EXT_DSA,		"Ext DSA"},
+};
+
+/******************************************************************************
+ * Function Definition
+ ******************************************************************************/
+/******************************************************************************
+* tpm_sw_lookup_enum_str()
+*
+* DESCRIPTION:
+*	This routine lookups enum string according to enum value
+*
+* INPUTS:
+*	enum_array   - pointer to enum array
+*	enum_value   - the enum value to be matched
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	Enum string
+*******************************************************************************/
+char *tpm_sw_lookup_enum_str(enum tpm_sw_enum_str_t enum_type, int enum_val)
+{
+	switch (enum_type) {
+	case TPM_SW_ENUM_INGRESS_MODE:
+		return lookup_enum_str(g_sw_enum_ingress_mode, TPM_MEMBER_NUM(g_sw_enum_ingress_mode), enum_val);
+	case TPM_SW_ENUM_EGRESS_MODE:
+		return lookup_enum_str(g_sw_enum_egress_mode, TPM_MEMBER_NUM(g_sw_enum_egress_mode), enum_val);
+	case TPM_SW_ENUM_CONFIG_STATE:
+		return lookup_enum_str(g_sw_enum_config_state, TPM_MEMBER_NUM(g_sw_enum_config_state), enum_val);
+	case TPM_SW_ENUM_FLOOD_TYPE:
+		return lookup_enum_str(g_sw_enum_flood_type, TPM_MEMBER_NUM(g_sw_enum_flood_type), enum_val);
+	case TPM_SW_ENUM_SPEED_MODE:
+		return lookup_enum_str(g_sw_enum_speed_mode, TPM_MEMBER_NUM(g_sw_enum_speed_mode), enum_val);
+	case TPM_SW_ENUM_DUPLEX_MODE:
+		return lookup_enum_str(g_sw_enum_duplex_mode, TPM_MEMBER_NUM(g_sw_enum_duplex_mode), enum_val);
+	case TPM_SW_ENUM_PORT_STATE:
+		return lookup_enum_str(g_sw_enum_port_state, TPM_MEMBER_NUM(g_sw_enum_port_state), enum_val);
+	case TPM_SW_ENUM_PORT_DIR:
+		return lookup_enum_str(g_sw_enum_port_dir, TPM_MEMBER_NUM(g_sw_enum_port_dir), enum_val);
+	case TPM_SW_ENUM_RATE_LIMIT_MODE:
+		return lookup_enum_str(g_sw_enum_rate_limit_mode, TPM_MEMBER_NUM(g_sw_enum_rate_limit_mode), enum_val);
+	case TPM_SW_ENUM_MAC_ADDR_TYPE:
+		return lookup_enum_str(g_sw_enum_mac_type, TPM_MEMBER_NUM(g_sw_enum_mac_type), enum_val);
+	case TPM_SW_ENUM_MAC_FILTER_MODE:
+		return lookup_enum_str(g_sw_enum_filter_mode, TPM_MEMBER_NUM(g_sw_enum_filter_mode), enum_val);
+	case TPM_SW_ENUM_QOS_MODE:
+		return lookup_enum_str(g_sw_enum_qos_mode, TPM_MEMBER_NUM(g_sw_enum_qos_mode), enum_val);
+	case TPM_SW_ENUM_HEAD_MODE:
+		return lookup_enum_str(g_sw_enum_head_mode, TPM_MEMBER_NUM(g_sw_enum_head_mode), enum_val);
+	default:
+		return NULL;
+	}
+}
+
+/*******************************************************************************
+* tpm_sw_init_check
+*
+* DESCRIPTION: The routine check whether the switch MAC or PHY port is available
+*
+* INPUTS:
+*	port_type - switch port type, specific switch MAC/PHY port or whole switch
+*	port      - switch port.
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_init_check(unsigned int port_type, unsigned char port)
+{
+	unsigned int switch_init;
+	unsigned int mac_port_num;
+	unsigned int phy_port_num;
+	int rc = TPM_OK;
+
+	/* check port type */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port_type, TPM_SW_ALL_PORT, "illegal switch port type");
+
+	/* check port range */
+	mac_port_num = mv_switch_port_num_get();
+	phy_port_num = TPM_SWITCH_MAX_PHY_NUM; /* hard coded here, should get from eth complex */
+	if (TPM_SW_MAC_PORT == port_type)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port, mac_port_num-1, "illegal switch MAC port")
+	else if (TPM_SW_PHY_PORT == port_type)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port, phy_port_num-1, "illegal switch PHY port")
+
+	/* check switch init state */
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &switch_init);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to get switch init state\n");
+	IF_EQUAL_STR(TPM_SWITCH_MOD, switch_init, TPM_SW_MODE_NOT_INIT,
+		"switch is not initialized, ignore calling tpm switch api\n");
+
+	/* check MAC/PHY available state according to eth complex, to do w/ eth complex feature */
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_ingress_mode_set
+*
+* DESCRIPTION: The routine sets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_vlan_ingress_mode_set(enum tpm_sw_port_t		port,
+				      enum tpm_sw_ingress_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), mode(%d)\n", port, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_INGRESS_DISCARD_TAG, "invalid ingress mode");
+
+	/* set discard untag and discard tag feature of switch port */
+	switch (mode) {
+	case TPM_SW_INGRESS_ASIS:
+		rc = mv_switch_port_discard_untag_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_untag_set()\n");
+		rc = mv_switch_port_discard_tag_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_tag_set()\n");
+		break;
+	case TPM_SW_INGRESS_DISCARD_ALL:
+		rc = mv_switch_port_discard_untag_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_untag_set()\n");
+		rc = mv_switch_port_discard_tag_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_tag_set()\n");
+		break;
+	case TPM_SW_INGRESS_DISCARD_UNTAG:
+		rc = mv_switch_port_discard_untag_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_untag_set()\n");
+		rc = mv_switch_port_discard_tag_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_tag_set()\n");
+		break;
+	case TPM_SW_INGRESS_DISCARD_TAG:
+		rc = mv_switch_port_discard_untag_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_untag_set()\n");
+		rc = mv_switch_port_discard_tag_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_tag_set()\n");
+		break;
+	default:
+		break;
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_ingress_mode_get
+*
+* DESCRIPTION: The routine gets the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_vlan_ingress_mode_get(enum tpm_sw_port_t		port,
+				      enum tpm_sw_ingress_mode_t	*mode)
+{
+	GT_BOOL discard_untag;
+	GT_BOOL discard_tag;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* get port discard tag and discard untag state */
+	rc = mv_switch_port_discard_untag_get(port, &discard_untag);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_untag_get()\n");
+	rc = mv_switch_port_discard_tag_get(port, &discard_tag);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_discard_tag_get()\n");
+
+	/* calculate the ingress mode */
+	if ((GT_TRUE == discard_untag) && (GT_TRUE == discard_tag))
+		*mode = TPM_SW_INGRESS_DISCARD_ALL;
+	else if ((GT_TRUE == discard_untag) && (GT_FALSE == discard_tag))
+		*mode = TPM_SW_INGRESS_DISCARD_UNTAG;
+	else if ((GT_FALSE == discard_untag) && (GT_TRUE == discard_tag))
+		*mode = TPM_SW_INGRESS_DISCARD_TAG;
+	else if ((GT_FALSE == discard_untag) && (GT_FALSE == discard_tag))
+		*mode = TPM_SW_INGRESS_ASIS;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), mode(%d)\n", rc, *mode);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_pvid_set
+*
+* DESCRIPTION: The routine sets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_pvid_set(enum tpm_sw_port_t	port,
+			 unsigned short		vid,
+			 unsigned char		pri)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), vid(%d), pri(%d)\n", port, vid, pri);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vid, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, pri, TPM_MAX_PBITS_VALUE, "invalid P-bits");
+
+	/* set switch default VLAN ID and P-bits */
+	rc = mv_switch_port_def_vid_set(port, vid);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_def_vid_set()\n");
+	rc = mv_switch_port_def_pri_set(port, pri);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_def_pri_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_pvid_get
+*
+* DESCRIPTION: The routine gets switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_pvid_get(enum tpm_sw_port_t	port,
+			 unsigned short		*vid,
+			 unsigned char		*pri)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, vid);
+	IF_NULL(TPM_SWITCH_MOD, pri);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* get switch default VLAN ID and P-bits */
+	rc = mv_switch_port_def_vid_get(port, vid);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_def_vid_get()\n");
+	rc = mv_switch_port_def_pri_get(port, pri);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_def_pri_get()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), vid(%d), pri(%d)\n", rc, *vid, *pri);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_set
+*
+* DESCRIPTION: The routine adds a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*	mode      - VLAN egress mode
+*			TPM_SW_VLAN_EGRESS_ASIS:        AS-IS
+*			TPM_SW_VLAN_EGRESS_NOT_IN_VLAN: not in this vlan
+*			TPM_SW_VLAN_EGRESS_KEEP_VLAN:   egress and do not strip vlan tag
+*			TPM_SW_VLAN_EGRESS_STRIP_VLAN:  egress and strip vlan tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_vlan_set(enum tpm_sw_port_t		port,
+			 unsigned short			min_vlan,
+			 unsigned short			max_vlan,
+			 enum tpm_sw_vlan_egress_mode_t	mode)
+{
+	int vid;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), min_vlan(%d), max_vlan(%d), mode(%d)\n",
+		port, min_vlan, max_vlan, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, min_vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, max_vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_VLAN_EGRESS_KEEP_VLAN, "invalid VLAN egress mode");
+	if (min_vlan > max_vlan) {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal config that min VLAN > max VLAN\n");
+		return TPM_BAD_PARAM;
+	}
+
+	/* set port VLAN and egress mode in loop */
+	for (vid = min_vlan; vid <= max_vlan; vid++) {
+		rc = mv_switch_port_vid_add(port, vid, mode, true);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vid_add()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_del
+*
+* DESCRIPTION: The routine deletes a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_vlan_del(enum tpm_sw_port_t	port,
+			 unsigned short		min_vlan,
+			 unsigned short		max_vlan)
+{
+	int vid;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), min_vlan(%d), max_vlan(%d)\n", port, min_vlan, max_vlan);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, min_vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, max_vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	if (min_vlan > max_vlan) {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal config that min VLAN > max VLAN\n");
+		return TPM_BAD_PARAM;
+	}
+
+	/* delete port VLAN in loop */
+	for (vid = min_vlan; vid <= max_vlan; vid++) {
+		rc = mv_switch_port_vid_del(port, vid);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vid_del()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_get
+*
+* DESCRIPTION: The routine get VLAN information for specific switch port
+*
+* INPUTS:
+*	vlan    - VLAN ID value
+*
+* OUTPUTS:
+*	fwd_bm  - Bitmap of egress forwarding mode
+*		  0:do not forward, 1:forward
+*		  bit0:port 0, bit1:port 1 ...
+*	tag_bm  - Bitmap of egress VLAN tag mode
+*		  0:egress untagged, 1:egress tagged
+*		  bit0:port 0, bit1:port 1 ...
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_vlan_get(unsigned short		vlan,
+			 unsigned int		*fwd_bm,
+			 unsigned int		*tag_bm)
+{
+	GT_VTU_ENTRY vtu_entry;
+	unsigned int index;
+	unsigned int found;
+	unsigned int port_num;
+	int          rc;
+	int          tpm_rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, vlan(%d)\n", vlan);
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	IF_NULL(TPM_SWITCH_MOD, fwd_bm);
+	IF_NULL(TPM_SWITCH_MOD, tag_bm);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* get VLAN information from VTU */
+	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+	rc = mv_switch_vid_get(vlan, &vtu_entry, &found);
+
+	*fwd_bm = 0;
+	*tag_bm = 0;
+	if (rc == GT_OK) {
+		if (found) {
+			port_num = mv_switch_port_num_get();
+			for (index = 0; index < port_num; index++) {
+				switch (vtu_entry.vtuData.memberTagP[index]) {
+				case MEMBER_EGRESS_UNMODIFIED:
+				case MEMBER_EGRESS_TAGGED:
+					*fwd_bm |= (1 << index);
+					*tag_bm |= (1 << index);
+					break;
+				case NOT_A_MEMBER:
+					break;
+				case MEMBER_EGRESS_UNTAGGED:
+					*fwd_bm |= (1 << index);
+					break;
+				default:
+					TPM_OS_ERROR(TPM_SWITCH_MOD, "wrong VLAN member type %d\n",
+						vtu_entry.vtuData.memberTagP[index]);
+					tpm_rc = TPM_BAD_VALUE;
+					break;
+				}
+			}
+		} else {
+			TPM_OS_ERROR(TPM_SWITCH_MOD, "failed to find VID:%d in VTU\n", vlan);
+			tpm_rc = TPM_NO_SUCH;
+		}
+	} else if (rc == GT_NO_SUCH) {
+		TPM_OS_INFO(TPM_SWITCH_MOD, "VTU has no vid(%d)\n", vlan);
+		tpm_rc = TPM_NO_SUCH;
+	} else {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "failed to call mv_switch_vid_get() %d\n", rc);
+		tpm_rc = TPM_FAIL;
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", tpm_rc);
+	return tpm_rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_filter_set
+*
+* DESCRIPTION:
+*	The API sets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*       enable - enable or disable filter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_port_vlan_filter_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d)\n", port, enable);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid port filter mode");
+
+	/* set VLAN filter mode */
+	rc = mv_switch_port_vlan_filter_set(port, enable);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vlan_filter_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_vlan_filter_get
+*
+* DESCRIPTION:
+*	The API gets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*
+* OUTPUTS:
+*       enable - enable or disable filter mode.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_port_vlan_filter_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable)
+{
+	unsigned char l_enable;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* get VLAN filter mode */
+	rc = mv_switch_port_vlan_filter_get(port, &l_enable);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vlan_filter_get()\n");
+	*enable = (enum tpm_sw_config_state_t)l_enable;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), enable(%d)\n", rc, *enable);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_enable_state_set
+*
+* DESCRIPTION: The routine enable or disable switch port
+*
+* INPUTS:
+*	port   - switch port
+*	enable - enable or disable switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_enable_state_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	enable)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d)\n", port, enable);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid port state mode");
+
+	rc = mv_phy_port_power_state_set(port, BIT_2_GT_BOOL(enable));
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_power_state_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_enable_state_get
+*
+* DESCRIPTION: The routine gets switch port PHY state
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	enable - enabled or disabled of switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_enable_state_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	*enable)
+{
+	GT_BOOL state;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+
+	rc = mv_phy_port_power_state_get(port, &state);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_power_state_set()\n");
+	*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(state);
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), enable(%d)\n", rc, *enable);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_flow_control_set
+*
+* DESCRIPTION: The routine configures switch port flow control
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable flow control
+*	interval  - interval time of pause frame
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int tpm_sw_port_flow_control_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	enable,
+				 unsigned int			interval)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d), interval(%d)\n", port, enable, interval);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid flow control state");
+
+	/* set flow control mode, ignore the pause interval since does not support by HW */
+	if (enable)
+		rc = mv_phy_port_pause_mode_set(port, GT_PHY_PAUSE);
+	else
+		rc = mv_phy_port_pause_mode_set(port, GT_PHY_NO_PAUSE);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_pause_mode_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_flow_control_get
+*
+* DESCRIPTION: The routine gets switch port flow control configuration
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enabled or disabled of flow control
+*	interval  - interval time of pause frame
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int tpm_sw_port_flow_control_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_config_state_t	*enable,
+				 unsigned int			*interval)
+{
+	GT_PHY_PAUSE_MODE pause_mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, interval);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+
+	/* get port flow control mode */
+	rc = mv_phy_port_pause_mode_get(port, &pause_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_pause_mode_get()\n");
+	if (GT_PHY_NO_PAUSE == pause_mode)
+		*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_FALSE);
+	else
+		*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_TRUE);
+	/* does not support pause interval */
+	*interval = 0;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), enable(%d), interval(%d)\n", rc, *enable, *interval);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_isolate_mask_set
+*
+* DESCRIPTION: The routine sets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port        - switch port
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_isolate_mask_set(enum tpm_sw_port_t	port,
+				 unsigned int		port_mask)
+{
+	GT_LPORT mem_ports[TPM_SWITCH_PORT_NUM] = {1};
+	int idx;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), port_mask(0x%x)\n", port, port_mask);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port_mask, ((1 << mv_switch_port_num_get()) - 1),
+				"invalid port mask");
+
+	/* init and set member port list */
+	for (idx = 0; idx < TPM_SWITCH_PORT_NUM; idx++)
+		mem_ports[idx] = idx;
+	for (idx = 0; idx < TPM_SWITCH_PORT_NUM; idx++) {
+		if (port_mask & (1 << idx))
+			mem_ports[idx] = 0x80; /* in TPM API, 1 means block, convert it here */
+		else
+			mem_ports[idx] = idx;
+	}
+
+	rc = mv_switch_port_vlan_set(port, mem_ports, TPM_SWITCH_PORT_NUM);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vlan_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_isolate_mask_get
+*
+* DESCRIPTION: The routine gets switch port isolation to other switch ports
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	port_mask - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_isolate_mask_get(enum tpm_sw_port_t	port,
+				 unsigned int		*port_mask)
+{
+	GT_LPORT mem_ports[TPM_SWITCH_PORT_NUM] = {1};
+	unsigned int mem_len = TPM_SWITCH_PORT_NUM;
+	int idx;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, port_mask);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* get switch port member */
+	rc = mv_switch_port_vlan_get(port, mem_ports, &mem_len);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vlan_get()\n");
+
+	*port_mask = (1 << mv_switch_port_num_get()) - 1;
+	for (idx = 0; idx < TPM_SWITCH_PORT_NUM; idx++) {
+		if (mem_ports[idx] == idx)
+			*port_mask &= ~(1 << idx);
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), port_mask(0x%x)\n", rc, *port_mask);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_flood_control_mask_set
+*
+* DESCRIPTION: The routine sets switch port flood control configuration
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: block
+*			1: do not block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int tpm_sw_port_flood_control_mask_set(enum tpm_sw_port_t		port,
+				       enum tpm_sw_flood_packet_type_t	pkt_type,
+				       unsigned int			port_mask)
+{
+	int rc = TPM_OK;
+	int loop_port;
+	int sw_port_num = 0;
+	TPM_SW_FLOOD_SET_FUN mv_switch_flood_set = NULL;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), pkt_type(%d), port_mask(0x%x)\n", port, pkt_type, port_mask);
+	sw_port_num = mv_switch_port_num_get();
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, pkt_type, TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST,
+				"invalid packt type");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port_mask, ((1 << sw_port_num) - 1), "invalid port mask");
+
+	/* configure flood according to setting, do not support per port flood control */
+	switch (pkt_type) {
+	case TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:
+		mv_switch_flood_set = mv_switch_unknown_unicast_flood_set;
+		break;
+	case TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST:
+	case TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST:
+		mv_switch_flood_set = mv_switch_unknown_multicast_flood_set;
+		break;
+	case TPM_SW_FLOOD_PKT_BROADCAST:
+		if (port_mask)
+			rc = mv_switch_broadcast_flood_set(GT_TRUE);
+		else
+			rc = mv_switch_broadcast_flood_set(GT_FALSE);
+
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to set port broadcast flooding\n");
+
+		return TPM_OK;
+	default:
+		TPM_OS_WARN(TPM_SWITCH_MOD, "do not support flooding packet type(%d)\n", pkt_type);
+		return TPM_OK;
+	}
+
+	for (loop_port = TPM_SW_PORT_0; loop_port < sw_port_num; loop_port++) {
+		if (port_mask & (1 << loop_port))
+			rc = mv_switch_flood_set(loop_port, GT_TRUE);
+		else
+			rc = mv_switch_flood_set(loop_port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to set port(%d) flooding(%d)\n", loop_port, pkt_type);
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_flood_control_mask_get
+*
+* DESCRIPTION: The routine gets flood control information
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*
+* OUTPUTS:
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: block
+*			1: do not block
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int tpm_sw_port_flood_control_mask_get(enum tpm_sw_port_t		port,
+				       enum tpm_sw_flood_packet_type_t	pkt_type,
+				       unsigned int			*port_mask)
+{
+	GT_BOOL state = GT_TRUE;
+	int rc = TPM_OK;
+	int loop_port;
+	int sw_port_num = 0;
+	TPM_SW_FLOOD_GET_FUN mv_switch_flood_get = NULL;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), pkt_type(%d)\n", port, pkt_type);
+	sw_port_num = mv_switch_port_num_get();
+
+	IF_NULL(TPM_SWITCH_MOD, port_mask);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, pkt_type, TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST,
+				"invalid packt type");
+
+	/* configure flood according to setting, do not support per port flood control */
+	switch (pkt_type) {
+	case TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:
+		mv_switch_flood_get = mv_switch_unknown_unicast_flood_get;
+		break;
+	case TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST:
+	case TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST:
+		mv_switch_flood_get = mv_switch_unknown_multicast_flood_get;
+		break;
+	case TPM_SW_FLOOD_PKT_BROADCAST:
+		rc = mv_switch_broadcast_flood_get(&state);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to get port broadcast flooding\n");
+
+		/* get flood according to setting */
+		if (GT_FALSE == state)
+			*port_mask = 0;
+		else
+			*port_mask = (1 << sw_port_num) - 1;
+
+		return TPM_OK;
+	default:
+		TPM_OS_WARN(TPM_SWITCH_MOD, "do not support flooding packet type(%d)\n", pkt_type);
+		return TPM_OK;
+	}
+
+	*port_mask = 0;
+
+	for (loop_port = TPM_SW_PORT_0; loop_port < sw_port_num; loop_port++) {
+		rc = mv_switch_flood_get(loop_port, &state);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to get port(%d) flooding(%d)\n", loop_port, pkt_type);
+
+		if (GT_TRUE == state)
+			*port_mask |= (1 << loop_port);
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), port_mask(0x%x)\n", rc, *port_mask);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_all_count_clear
+*
+* DESCRIPTION: The routine clears the counters of all switch ports
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_all_count_clear(void)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	rc = mv_switch_count_clear();
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_count_clear()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_count_clear
+*
+* DESCRIPTION: The routine clears the counters of dedicated switch ports
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_count_clear(enum tpm_sw_port_t port)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_port_count_clear(port);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count_clear()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_link_mode_set
+*
+* DESCRIPTION: The routine sets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_link_mode_set(enum tpm_sw_port_t		port,
+			      enum tpm_sw_config_state_t	auto_en,
+			      enum tpm_sw_speed_mode_t		speed,
+			      enum tpm_sw_duplex_mode_t		duplex)
+{
+	GT_PHY_AUTO_MODE mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In,port(%d), auto_en(%d), speed(%d), duplex(%d)\n", port, auto_en, speed, duplex);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, auto_en, TPM_SW_CONFIG_ENABLE, "invalid auto en mode");
+	if (TPM_SW_CONFIG_DISABLE == auto_en) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, speed, TPM_SW_SPEED_MODE_1000M, "invalid speed mode");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, duplex, TPM_SW_DUPLEX_MODE_FULL, "invalid duplex mode");
+
+		/* force speed */
+		rc = mv_switch_port_force_speed_set(port, GT_TRUE, speed);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_speed_set()\n");
+
+		/* force duplex */
+		rc = mv_switch_port_force_duplex_set(port, GT_TRUE, BIT_2_GT_BOOL(duplex));
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_duplex_set()\n");
+
+		/* PHY speed */
+		rc = mv_phy_port_speed_set(port, speed);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_speed_set()\n");
+
+		/* PHY duplex */
+		rc = mv_phy_port_duplex_set(port, BIT_2_GT_BOOL(duplex));
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_duplex_set()\n");
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, speed, TPM_SW_SPEED_MODE_AUTO, "invalid speed mode");
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, duplex, TPM_SW_DUPLEX_MODE_AUTO, "invalid duplex mode");
+
+		/* force speed */
+		rc = mv_switch_port_force_speed_set(port, GT_FALSE, speed);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_speed_set()\n");
+
+		/* force duplex */
+		rc = mv_switch_port_force_duplex_set(port, GT_FALSE, BIT_2_GT_BOOL(duplex));
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_duplex_set()\n");
+	}
+
+	switch (speed) {
+	case TPM_SW_SPEED_MODE_10M:
+		if (duplex == TPM_SW_DUPLEX_MODE_HALF)
+			mode = SPEED_10_DUPLEX_HALF;
+		if (duplex == TPM_SW_DUPLEX_MODE_FULL)
+			mode = SPEED_10_DUPLEX_FULL;
+		if (duplex == TPM_SW_DUPLEX_MODE_AUTO)
+			mode = SPEED_10_DUPLEX_AUTO;
+		break;
+	case TPM_SW_SPEED_MODE_100M:
+		if (duplex == TPM_SW_DUPLEX_MODE_HALF)
+			mode = SPEED_100_DUPLEX_HALF;
+		if (duplex == TPM_SW_DUPLEX_MODE_FULL)
+			mode = SPEED_100_DUPLEX_FULL;
+		if (duplex == TPM_SW_DUPLEX_MODE_AUTO)
+			mode = SPEED_100_DUPLEX_AUTO;
+		break;
+	case TPM_SW_SPEED_MODE_1000M:
+		if (duplex == TPM_SW_DUPLEX_MODE_HALF)
+			mode = SPEED_1000_DUPLEX_HALF;
+		if (duplex == TPM_SW_DUPLEX_MODE_FULL)
+			mode = SPEED_1000_DUPLEX_FULL;
+		if (duplex == TPM_SW_DUPLEX_MODE_AUTO)
+			mode = SPEED_1000_DUPLEX_AUTO;
+		break;
+	case TPM_SW_SPEED_MODE_AUTO:
+		if (duplex == TPM_SW_DUPLEX_MODE_HALF)
+			mode = SPEED_AUTO_DUPLEX_HALF;
+		if (duplex == TPM_SW_DUPLEX_MODE_FULL)
+			mode = SPEED_AUTO_DUPLEX_FULL;
+		if (duplex == TPM_SW_DUPLEX_MODE_AUTO)
+			mode = SPEED_AUTO_DUPLEX_AUTO;
+		break;
+	default:
+		mode = SPEED_AUTO_DUPLEX_AUTO;
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal speed mode(%d)\n", speed);
+		break;
+	}
+
+	rc = mv_phy_port_autoneg_mode_set(port, BIT_2_GT_BOOL(auto_en), mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_autoneg_mode_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_link_mode_get
+*
+* DESCRIPTION: The routine gets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*
+* OUTPUTS:
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_link_mode_get(enum tpm_sw_port_t		port,
+			      enum tpm_sw_config_state_t	*auto_en,
+			      enum tpm_sw_speed_mode_t		*speed,
+			      enum tpm_sw_duplex_mode_t		*duplex)
+{
+	GT_BOOL autoneg_state;
+	GT_PHY_AUTO_MODE autoneg_mode;
+	GT_BOOL enable;
+	unsigned int mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, auto_en);
+	IF_NULL(TPM_SWITCH_MOD, speed);
+	IF_NULL(TPM_SWITCH_MOD, duplex);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+
+	/* get auto negotiation status */
+	rc = mv_phy_port_autoneg_mode_get(port, &autoneg_state, &autoneg_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_autoneg_mode_get()\n");
+
+	*auto_en = GT_BOOL_2_BIT(autoneg_state);
+
+	if (TPM_SW_CONFIG_DISABLE == *auto_en) {
+		/* force speed */
+		rc = mv_switch_port_force_speed_get(port, &enable, &mode);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_speed_get()\n");
+		if (GT_TRUE == enable)
+			*speed = (enum tpm_sw_speed_mode_t)mode;
+		else
+			*speed = TPM_SW_SPEED_MODE_10M;/* no meaning in case force is disabled */
+
+		/* force duplex */
+		rc = mv_switch_port_force_duplex_get(port, &enable, &mode);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_force_duplex_get()\n");
+		if (GT_TRUE == enable)
+			*duplex = (enum tpm_sw_duplex_mode_t)mode;
+		else
+			*duplex = TPM_SW_DUPLEX_MODE_HALF;/* no meaning in case force is disabled */
+	} else {
+		switch (autoneg_mode) {
+		case SPEED_AUTO_DUPLEX_AUTO:
+			*speed = TPM_SW_SPEED_MODE_AUTO;
+			*duplex = TPM_SW_DUPLEX_MODE_AUTO;
+			break;
+		case SPEED_1000_DUPLEX_AUTO:
+			*speed = TPM_SW_SPEED_MODE_1000M;
+			*duplex = TPM_SW_DUPLEX_MODE_AUTO;
+			break;
+		case SPEED_100_DUPLEX_AUTO:
+			*speed = TPM_SW_SPEED_MODE_100M;
+			*duplex = TPM_SW_DUPLEX_MODE_AUTO;
+			break;
+		case SPEED_10_DUPLEX_AUTO:
+			*speed = TPM_SW_SPEED_MODE_10M;
+			*duplex = TPM_SW_DUPLEX_MODE_AUTO;
+			break;
+		case SPEED_AUTO_DUPLEX_FULL:
+			*speed = TPM_SW_SPEED_MODE_AUTO;
+			*duplex = TPM_SW_DUPLEX_MODE_FULL;
+			break;
+		case SPEED_AUTO_DUPLEX_HALF:
+			*speed = TPM_SW_SPEED_MODE_AUTO;
+			*duplex = TPM_SW_DUPLEX_MODE_HALF;
+			break;
+		case SPEED_1000_DUPLEX_FULL:
+			*speed = TPM_SW_SPEED_MODE_1000M;
+			*duplex = TPM_SW_DUPLEX_MODE_FULL;
+			break;
+		case SPEED_1000_DUPLEX_HALF:
+			*speed = TPM_SW_SPEED_MODE_1000M;
+			*duplex = TPM_SW_DUPLEX_MODE_HALF;
+			break;
+		case SPEED_100_DUPLEX_FULL:
+			*speed = TPM_SW_SPEED_MODE_100M;
+			*duplex = TPM_SW_DUPLEX_MODE_FULL;
+			break;
+		case SPEED_100_DUPLEX_HALF:
+			*speed = TPM_SW_SPEED_MODE_100M;
+			*duplex = TPM_SW_DUPLEX_MODE_HALF;
+			break;
+		case SPEED_10_DUPLEX_FULL:
+			*speed = TPM_SW_SPEED_MODE_10M;
+			*duplex = TPM_SW_DUPLEX_MODE_FULL;
+			break;
+		case SPEED_10_DUPLEX_HALF:
+			*speed = TPM_SW_SPEED_MODE_10M;
+			*duplex = TPM_SW_DUPLEX_MODE_HALF;
+			break;
+		default:
+			TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal autoneg_mode(%d)\n", autoneg_mode);
+			break;
+		}
+
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out,rc(%d), auto_en(%d), speed(%d), duplex(%d)\n", rc, *auto_en, *speed, *duplex);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_link_state_get
+*
+* DESCRIPTION: The routine gets switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*
+* OUTPUTS:
+*	link       - link up or down state
+*			TPM_SW_PORT_STATE_DOWN:  link down
+*			TPM_SW_PORT_STATE_UP:    link up
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_link_state_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_state_t		*link,
+			       enum tpm_sw_speed_mode_t		*speed,
+			       enum tpm_sw_duplex_mode_t	*duplex)
+{
+	GT_BOOL link_state;
+	GT_PORT_SPEED_MODE speed_state;
+	GT_BOOL duplex_state;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, link);
+	IF_NULL(TPM_SWITCH_MOD, speed);
+	IF_NULL(TPM_SWITCH_MOD, duplex);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+
+	/* get link, speed, duplex state */
+	rc = mv_switch_link_state_get(port, &link_state);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_link_state_get()\n");
+	rc = mv_switch_speed_state_get(port, &speed_state);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_speed_state_get()\n");
+	rc = mv_switch_duplex_state_get(port, &duplex_state);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_duplex_state_get()\n");
+
+	switch (link_state) {
+	case GT_TRUE:
+		*link = TPM_SW_PORT_STATE_UP;
+		break;
+	case GT_FALSE:
+		*link = TPM_SW_PORT_STATE_DOWN;
+		break;
+	default:
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal link state(%d)\n", link_state);
+		break;
+	}
+
+	switch (speed_state) {
+	case PORT_SPEED_10_MBPS:
+		*speed = TPM_SW_SPEED_MODE_10M;
+		break;
+	case PORT_SPEED_100_MBPS:
+		*speed = TPM_SW_SPEED_MODE_100M;
+		break;
+	case PORT_SPEED_1000_MBPS:
+		*speed = TPM_SW_SPEED_MODE_1000M;
+		break;
+	case PORT_SPEED_UNKNOWN:
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "unkown port speed state(%d)\n", speed_state);
+		break;
+	default:
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal port speed state(%d)\n", speed_state);
+		break;
+	}
+
+	switch (duplex_state) {
+	case GT_TRUE:
+		*duplex = TPM_SW_DUPLEX_MODE_FULL;
+		break;
+	case GT_FALSE:
+		*duplex = TPM_SW_DUPLEX_MODE_HALF;
+		break;
+	default:
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "illegal duplex state(%d)\n", duplex_state);
+		break;
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), link(%d), speed(%d), duplex(%d)\n", rc, *link, *speed, *duplex);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_rate_limit_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_sw_port_rate_limit_set(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	enable,
+			       enum tpm_sw_rate_limit_mode_t	mode,
+			       unsigned int			rate)
+{
+	unsigned int l_rate;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		port, dir, enable, mode, rate);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid rate limit state");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_RATE_LIMIT_LAYER3, "invalid rate limit mode");
+
+	if (TPM_SWITCH_UPLINK_PORT == port)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_UPLINK_PORT_RATE, "invalid rate")
+	else
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_PORT_RATE, "invalid rate")
+
+	/* set ingress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_INGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		if (enable == TPM_SW_CONFIG_ENABLE) {
+			l_rate = rate;
+		} else {
+			TPM_OS_DEBUG(TPM_SWITCH_MOD, "does not support disable UNI ingress rate limit\n");
+			return TPM_OK;
+#if 0
+			if (TPM_SWITCH_UPLINK_PORT == port)
+				l_rate = TPM_SWITCH_MAX_UPLINK_PORT_RATE;
+			else
+				l_rate = TPM_SWITCH_MAX_PORT_RATE;
+#endif
+		}
+
+		/* set ingress policing rate */
+		rc = mv_switch_ingr_police_rate_set(port, (GT_PIRL_ELIMIT_MODE)mode, l_rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_police_rate_set()\n");
+
+		/*save ingress policing rate*/
+		rc = tpm_db_sw_port_ingr_rate_set(port, rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_rate_set()\n");
+	}
+
+	/* set egress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_EGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		if (enable == TPM_SW_CONFIG_ENABLE)
+			l_rate = rate;
+		else
+			l_rate = 0; /* to disable egress rate limit */
+
+		rc = mv_switch_egr_rate_limit_set(port, (GT_PIRL_ELIMIT_MODE)mode, l_rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_egr_rate_limit_set()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_rate_limit_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_rate_limit_get(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	*enable,
+			       enum tpm_sw_rate_limit_mode_t	*mode,
+			       unsigned int			*rate)
+{
+	GT_PIRL2_COUNT_MODE ingr_mode;
+	GT_PIRL_ELIMIT_MODE egr_mode;
+	unsigned int cir;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	IF_NULL(TPM_SWITCH_MOD, rate);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir");
+
+	if (dir == TPM_SW_PORT_DIR_INGRESS) {
+		/* get ingress policing mode */
+		rc = mv_switch_ingr_police_rate_get(port, &ingr_mode, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_police_rate_get()\n");
+		*mode = (enum tpm_sw_rate_limit_mode_t)ingr_mode;
+
+		/* get ingress policing rate */
+		rc = tpm_db_sw_port_ingr_rate_get(port, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_rate_get()\n");
+
+		if (TPM_SWITCH_MAX_PORT_RATE == cir || 0 == cir)
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_FALSE);
+		else
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_TRUE);
+	} else if (dir == TPM_SW_PORT_DIR_EGRESS) {
+		/* get egress policing rate */
+		rc = mv_switch_egr_rate_limit_get(port, &egr_mode, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_egr_rate_limit_get()\n");
+		*mode = (enum tpm_sw_rate_limit_mode_t)egr_mode;
+
+		if (0 == cir)
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_FALSE);
+		else
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_TRUE);
+	}
+
+	*rate = cir;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		rc, dir, *enable, *mode, *rate);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mc_proto_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int tpm_sw_port_mc_proto_rate_set(enum tpm_sw_port_t		port,
+				  enum tpm_sw_port_dir_t	dir,
+				  enum tpm_sw_config_state_t	enable,
+				  enum tpm_sw_rate_limit_mode_t	mode,
+				  unsigned int			rate)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		port, dir, enable, mode, rate);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid rate limit state");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_RATE_LIMIT_LAYER3, "invalid rate limit mode");
+	if (TPM_SWITCH_UPLINK_PORT == port)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_UPLINK_PORT_RATE, "invalid rate")
+	else
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_PORT_RATE, "invalid rate")
+
+	IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "NOT IMPLEMENTED\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mc_proto_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int tpm_sw_port_mc_proto_rate_get(enum tpm_sw_port_t		port,
+				  enum tpm_sw_port_dir_t	dir,
+				  enum tpm_sw_config_state_t	*enable,
+				  enum tpm_sw_rate_limit_mode_t	*mode,
+				  unsigned int			*rate)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	IF_NULL(TPM_SWITCH_MOD, rate);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir");
+
+	IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "NOT IMPLEMENTED\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		rc, dir, *enable, *mode, *rate);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mc_data_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int tpm_sw_port_mc_data_rate_set(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	enable,
+				 enum tpm_sw_rate_limit_mode_t	mode,
+				 unsigned int			rate)
+{
+	unsigned int l_rate;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		port, dir, enable, mode, rate);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid rate limit state");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_RATE_LIMIT_LAYER3, "invalid rate limit mode");
+	if (TPM_SWITCH_UPLINK_PORT == port)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_UPLINK_PORT_RATE, "invalid rate")
+	else
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_PORT_RATE, "invalid rate")
+
+	/* set ingress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_INGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		if (enable == TPM_SW_CONFIG_ENABLE) {
+			l_rate = rate;
+
+		} else {
+			TPM_OS_DEBUG(TPM_SWITCH_MOD, "does not support disable UNI ingress rate limit\n");
+			return TPM_OK;
+#if 0
+			if (TPM_SWITCH_UPLINK_PORT == port)
+				l_rate = TPM_SWITCH_MAX_UPLINK_PORT_RATE;
+			else
+				l_rate = TPM_SWITCH_MAX_PORT_RATE;
+#endif
+		}
+
+		/* set ingress policing rate */
+		rc = mv_switch_ingr_multicast_rate_set(port, (GT_PIRL_ELIMIT_MODE)mode, l_rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_multicast_rate_set()\n");
+
+		/*save ingress multicast policing rate*/
+		rc = tpm_db_sw_port_ingr_mc_rate_set(port, rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_mc_rate_set()\n");
+	}
+
+	/* set egress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_EGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "egress multicastcast rate limit NOT IMPLEMENTED\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mc_data_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int tpm_sw_port_mc_data_rate_get(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	*enable,
+				 enum tpm_sw_rate_limit_mode_t	*mode,
+				 unsigned int			*rate)
+{
+	GT_PIRL2_COUNT_MODE ingr_mode;
+	unsigned int cir;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	IF_NULL(TPM_SWITCH_MOD, rate);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir");
+
+	if (dir == TPM_SW_PORT_DIR_INGRESS) {
+		/* get ingress policing mode */
+		rc = mv_switch_ingr_multicast_rate_get(port, &ingr_mode, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_multicast_rate_get()\n");
+		*mode = (enum tpm_sw_rate_limit_mode_t)ingr_mode;
+
+		/* get ingress policing rate */
+		rc = tpm_db_sw_port_ingr_mc_rate_get(port, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_mc_rate_get()\n");
+
+		if (TPM_SWITCH_MAX_PORT_RATE == cir || 0 == cir)
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_FALSE);
+		else
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_TRUE);
+
+	} else if (dir == TPM_SW_PORT_DIR_EGRESS) {
+		IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "Multicast egress rate limit is NOT IMPLEMENTED\n");
+	}
+
+	*rate = cir;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		rc, dir, *enable, *mode, *rate);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_broadcast_rate_set
+*
+* DESCRIPTION: The routine sets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int tpm_sw_port_broadcast_rate_set(enum tpm_sw_port_t			port,
+				   enum tpm_sw_port_dir_t		dir,
+				   enum tpm_sw_config_state_t		enable,
+				   enum tpm_sw_rate_limit_mode_t	mode,
+				   unsigned int				rate)
+{
+	unsigned int l_rate;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		port, dir, enable, mode, rate);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid rate limit state");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_RATE_LIMIT_LAYER3, "invalid rate limit mode");
+	if (TPM_SWITCH_UPLINK_PORT == port)
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_UPLINK_PORT_RATE, "invalid rate")
+	else
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, rate, TPM_SWITCH_MAX_PORT_RATE, "invalid rate")
+
+	/* set ingress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_INGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		if (enable == TPM_SW_CONFIG_ENABLE) {
+			l_rate = rate;
+
+		} else {
+			TPM_OS_DEBUG(TPM_SWITCH_MOD, "does not support disable UNI ingress rate limit\n");
+			return TPM_OK;
+#if 0
+			if (TPM_SWITCH_UPLINK_PORT == port)
+				l_rate = TPM_SWITCH_MAX_UPLINK_PORT_RATE;
+			else
+				l_rate = TPM_SWITCH_MAX_PORT_RATE;
+#endif
+		}
+
+		/* set ingress policing rate */
+		rc = mv_switch_ingr_broadcast_rate_set(port, (GT_PIRL_ELIMIT_MODE)mode, l_rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_broadcast_rate_set()\n");
+
+		/*save ingress broadcast policing rate*/
+		rc = tpm_db_sw_port_ingr_bc_rate_set(port, rate);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_bc_rate_set()\n");
+	}
+
+	/* set egress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_EGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "egress broadcast rate limit NOT IMPLEMENTED\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_broadcast_rate_get
+*
+* DESCRIPTION: The routine gets rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int tpm_sw_port_broadcast_rate_get(enum tpm_sw_port_t			port,
+				   enum tpm_sw_port_dir_t		dir,
+				   enum tpm_sw_config_state_t		*enable,
+				   enum tpm_sw_rate_limit_mode_t	*mode,
+				   unsigned int				*rate)
+{
+	GT_PIRL2_COUNT_MODE ingr_mode;
+	unsigned int cir;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	IF_NULL(TPM_SWITCH_MOD, rate);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir");
+
+	if (dir == TPM_SW_PORT_DIR_INGRESS) {
+		/* get ingress policing mode */
+		rc = mv_switch_ingr_broadcast_rate_get(port, &ingr_mode, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_ingr_broadcast_rate_get()\n");
+		*mode = (enum tpm_sw_rate_limit_mode_t)ingr_mode;
+
+		/* get ingress policing rate */
+		rc = tpm_db_sw_port_ingr_bc_rate_get(port, &cir);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_db_sw_port_ingr_bc_rate_get()\n");
+
+		if (TPM_SWITCH_MAX_PORT_RATE == cir || 0 == cir)
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_FALSE);
+		else
+			*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(GT_TRUE);
+
+	} else if (dir == TPM_SW_PORT_DIR_EGRESS) {
+		IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL, "Broadcast egress rate limit is NOT IMPLEMENTED\n");
+	}
+
+	*rate = cir;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d), mode(%d), rate(%d)\n",
+		rc, dir, *enable, *mode, *rate);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mirror_set
+*
+* DESCRIPTION: The routine sets port mirror
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mirror_set(enum tpm_sw_port_t		sport,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	enable,
+			   enum tpm_sw_port_t		dport)
+{
+	enum sw_mirror_mode_t mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, sport(%d), enable(%d), dir(%d), dport(%d))\n",
+		     sport, enable, dir, dport);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, sport);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, dport);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid port mirror mode");
+
+	/* set port mirror */
+	if (dir == TPM_SW_PORT_DIR_INGRESS)
+		mode = MV_SWITCH_MIRROR_INGRESS;
+	else if (dir == TPM_SW_PORT_DIR_EGRESS)
+		mode = MV_SWITCH_MIRROR_EGRESS;
+	else if (dir == TPM_SW_PORT_DIR_BOTH)
+		mode = MV_SWITCH_MIRROR_BOTH;
+
+	rc = mv_switch_port_mirror_set(sport, mode, BIT_2_GT_BOOL(enable), dport);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_mirror_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mirror_get
+*
+* DESCRIPTION: The routine gets port mirror configuration
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mirror_get(enum tpm_sw_port_t		sport,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	*enable,
+			   enum tpm_sw_port_t		*dport)
+{
+	GT_BOOL l_enable;
+	unsigned int l_port;
+	enum sw_mirror_mode_t mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, sport(%d)\n", sport);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, dport);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, sport);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir");
+
+	/* get port mirror */
+	if (dir == TPM_SW_PORT_DIR_INGRESS)
+		mode = MV_SWITCH_MIRROR_INGRESS;
+	else if (dir == TPM_SW_PORT_DIR_EGRESS)
+		mode = MV_SWITCH_MIRROR_EGRESS;
+	rc = mv_switch_port_mirror_get(sport, mode, &l_enable, &l_port);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_mirror_get()\n");
+	*enable = GT_BOOL_2_BIT(l_enable);
+	*dport = l_port;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d), dport(%d)\n",
+		    rc, dir, *enable, *dport);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_loopback_set
+*
+* DESCRIPTION: The routine sets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port loopback
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_loopback_set(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_dir_t	dir,
+			     enum tpm_sw_config_state_t	enable)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d), dir(%d)\n", port, enable, dir);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_BOTH, "invalid dir");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid port loopback mode");
+
+	/* set ingress loopback */
+	if ((dir == TPM_SW_PORT_DIR_INGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		rc = mv_phy_port_ingr_loopback_set(port, BIT_2_GT_BOOL(enable));
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_ingr_loopback_set()\n");
+	}
+
+	/* set egress rate limit */
+	if ((dir == TPM_SW_PORT_DIR_EGRESS) ||
+	    (dir == TPM_SW_PORT_DIR_BOTH)) {
+		rc = mv_phy_port_egr_loopback_set(port, BIT_2_GT_BOOL(enable));
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_egr_loopback_set()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_loopback_get
+*
+* DESCRIPTION: The routine gets port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port loopback
+
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_loopback_get(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_dir_t	dir,
+			     enum tpm_sw_config_state_t	*enable)
+{
+	GT_BOOL l_enable;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_PHY_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, dir, TPM_SW_PORT_DIR_EGRESS, "invalid dir for ingress loopback get");
+
+	/* get ingress loopback */
+	if (dir == TPM_SW_PORT_DIR_INGRESS) {
+		rc = mv_phy_port_ingr_loopback_get(port, &l_enable);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_ingr_loopback_set()\n");
+	}
+	/* get egress loopback */
+	else if (dir == TPM_SW_PORT_DIR_EGRESS) {
+		rc = mv_phy_port_egr_loopback_get(port, &l_enable);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_phy_port_egr_loopback_set()\n");
+	}
+
+	*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(l_enable);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), dir(%d), enable(%d)\n", rc, dir, *enable);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mac_aging_time_set
+*
+* DESCRIPTION: The routine sets switch aging time
+*
+* INPUTS:
+*	time  - switch aging time in unit of second
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_mac_aging_time_set(unsigned int time)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, time(%d)\n", time);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, time, TPM_SWITCH_MAX_MAC_AGING_TIME, "invalid MAC aging time");
+
+	if (time%TPM_SWITCH_AGE_FACTOR) {
+		TPM_OS_WARN(TPM_SWITCH_MOD, "inputted aging time is not multiple times of %d, will be adjusted to %d\n",
+			    TPM_SWITCH_AGE_FACTOR, time/TPM_SWITCH_AGE_FACTOR);
+	}
+	rc = mv_switch_age_time_set(time);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_age_time_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mac_aging_time_get
+*
+* DESCRIPTION: The routine gets switch aging time
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	time  - switch aging time in unit of second
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_mac_aging_time_get(unsigned int *time)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	IF_NULL(TPM_SWITCH_MOD, time);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	rc = mv_switch_age_time_get(time);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_age_time_get()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), time(%d)\n", rc, *time);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_learn_limit_set
+*
+* DESCRIPTION: The routine sets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_learn_limit_set(enum tpm_sw_port_t		port,
+				    enum tpm_sw_config_state_t	enable,
+				    unsigned int		limit)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d), limit(%d)\n", port, enable, limit);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, enable, TPM_SW_CONFIG_ENABLE, "invalid MAC learn limit mode");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, limit, TPM_SWITCH_MAX_MAC_LEARN_LIMIT,
+				"invalid MAC learn limit number");
+
+	/* disable MAC learning */
+	if (TPM_SW_CONFIG_DISABLE == enable) {
+		rc = mv_switch_mac_learn_disable_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+	}
+	/* enable MAC learning and set MAC learn limit */
+	else {
+		/* learn2all flag must be enabled for mac limit */
+		rc = mv_switch_learn2all_enable_set(GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_learn2all_enable_set()\n");
+
+		rc = mv_switch_mac_learn_disable_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+		rc = tpm_sw_port_mac_table_clear_dynamic(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+		rc = mv_switch_mac_limit_set(port, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+		rc = mv_switch_mac_learn_disable_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+		rc = mv_switch_mac_learn_disable_set(port, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+		rc = tpm_sw_port_mac_table_clear_dynamic(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+		rc = mv_switch_mac_limit_set(port, limit);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+		rc = mv_switch_mac_learn_disable_set(port, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_learn_limit_get
+*
+* DESCRIPTION: The routine gets the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_learn_limit_get(enum tpm_sw_port_t		port,
+				    enum tpm_sw_config_state_t	*enable,
+				    unsigned int		*limit)
+{
+	GT_BOOL l_enable;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, enable);
+	IF_NULL(TPM_SWITCH_MOD, limit);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* get MAC learn disable status and MAC learn limit */
+	rc = mv_switch_mac_learn_disable_get(port, &l_enable);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_get()\n");
+	if (l_enable == GT_FALSE)
+		*enable = TPM_SW_CONFIG_ENABLE;
+	else
+		*enable = TPM_SW_CONFIG_DISABLE;
+	rc = mv_switch_mac_limit_get(port, limit);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_get()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), enable(%d), limit(%d)\n", rc, *enable, *limit);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_address_add
+*
+* DESCRIPTION: The routine adds MAC address
+*
+* INPUTS:
+*	port_bm - switch port bitmap
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - enable or disable port mirror
+*		TPM_SW_MAC_ADDR_DYNAMIC: dynamic MAC address
+*		TPM_SW_MAC_ADDR_STATIC:  static MAC address
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_address_add(unsigned char			port_bm,
+				unsigned char			*mac,
+				unsigned short			vlan,
+				enum tpm_sw_mac_addr_mode_t	mode)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_SWITCH_MOD, mac);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port_bm(0x%x), mac(%02x:%02x:%02x:%02x:%02x:%02x), vlan(%d), mode(%d)\n",
+		     port_bm, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], vlan, mode);
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, port_bm, ((1<<TPM_SWITCH_PORT_NUM) - 1), "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_ADDR_STATIC, "invalid MAC address mode");
+
+	/* check MAC mode, could not be dynamic mode for multicast and broadcast MAC address */
+	if ((TPM_IS_MULTICAST_MAC(mac) || TPM_IS_BROADCAST_MAC(mac)) &&
+	    (TPM_SW_MAC_ADDR_DYNAMIC == mode)) {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "Multicast or broadcast MAC address could not be dynamic\n");
+		return TPM_BAD_PARAM;
+	}
+
+	/* add mac address */
+	if (mode == TPM_SW_MAC_ADDR_DYNAMIC) {
+		rc = mv_switch_mac_addr_add((unsigned int)port_bm, mac, MV_SWITCH_DYNAMIC_MAC_ADDR);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_addr_add()\n");
+	} else if (mode == TPM_SW_MAC_ADDR_STATIC) {
+		rc = mv_switch_mac_addr_add((unsigned int)port_bm, mac, MV_SWITCH_STATIC_MAC_ADDR);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_addr_add()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_address_del
+*
+* DESCRIPTION: The routine deletes MAC address
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_address_del(enum tpm_sw_port_t	port,
+				unsigned char		*mac,
+				unsigned short		vlan)
+{
+	int rc = TPM_OK;
+
+	IF_NULL(TPM_SWITCH_MOD, mac);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)), mac(%02x:%02x:%02x:%02x:%02x:%02x), vlan(%d)\n",
+		    port, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], vlan);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	/* delete MAC address */
+	rc = mv_switch_mac_addr_del((unsigned int)port, mac);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_addr_del()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+/*******************************************************************************
+* tpm_sw_port_mac_filter_mode_xlate
+*
+* DESCRIPTION: The routine translate MAC filter mode from TPM to MV_SW
+*
+* INPUTS:
+*	tpm_mode
+*
+* OUTPUTS:
+*	mv_sw_mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_filter_mode_xlate(enum tpm_sw_mac_filter_mode_t	tpm_mode,
+					GT_SA_FILTERING *mv_sw_mode)
+{
+	IF_NULL(TPM_SWITCH_MOD, mv_sw_mode);
+
+	if (TPM_SW_MAC_NO_FILTER == tpm_mode)
+		*mv_sw_mode = GT_SA_FILTERING_DISABLE;
+	else if ((TPM_SW_MAC_BLACK_FILTER_DMAC == tpm_mode)
+		  || ((TPM_SW_MAC_WHITE_FILTER_DMAC == tpm_mode))) {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "mac filter on DMAC is NOT supported\n");
+		return TPM_NOT_SUPPORTED;
+	} else if (TPM_SW_MAC_BLACK_FILTER_SMAC == tpm_mode)
+		*mv_sw_mode = GT_SA_DROP_ON_UNLOCK;
+	else if (TPM_SW_MAC_WHITE_FILTER_SMAC == tpm_mode)
+		*mv_sw_mode = GT_SA_DROP_ON_LOCK;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_filter_mode_set
+*
+* DESCRIPTION: The routine sets MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_filter_mode_set(enum tpm_sw_port_t	port,
+				    enum tpm_sw_mac_filter_mode_t	mode)
+
+{
+	int rc = TPM_OK;
+	GT_SA_FILTERING sw_mode = 0;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), mode(%d)\n", port, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_WHITE_FILTER_SMAC, "invalid MAC filter mode");
+
+	rc = tpm_sw_port_mac_filter_mode_xlate(mode, &sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to xlate filter mode(%d)\n", mode);
+
+	rc = mv_switch_port_mac_filter_mode_set(port, sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to set filter port(%d) mode(%d)\n", port, sw_mode);
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_filter_mode_get
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_filter_mode_get(enum tpm_sw_port_t			port,
+				    enum tpm_sw_mac_filter_mode_t	*mode)
+{
+	int rc = TPM_OK;
+	GT_SA_FILTERING sw_mode = 0;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_port_mac_filter_mode_get(port, &sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to get filter port(%d)\n", port);
+
+	switch (sw_mode) {
+	case GT_SA_FILTERING_DISABLE:
+		*mode = TPM_SW_MAC_NO_FILTER;
+		break;
+	case GT_SA_DROP_ON_UNLOCK:
+		*mode = TPM_SW_MAC_BLACK_FILTER_SMAC;
+		break;
+	case GT_SA_DROP_ON_LOCK:
+		*mode = TPM_SW_MAC_WHITE_FILTER_SMAC;
+		break;
+	default:
+		IF_ERROR_STR(TPM_SWITCH_MOD, TPM_FAIL,
+			"switch filter mode of port(%d) is not valid(%d) for TPM\n",
+			port, *mode);
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), mode(%d)\n", rc, *mode);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_filter_entry_add
+*
+* DESCRIPTION: The routine adds MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_filter_entry_add(enum tpm_sw_port_t	port,
+				     unsigned char			*mac,
+				     unsigned short			vlan,
+				     enum tpm_sw_mac_filter_mode_t	mode)
+{
+	int rc = TPM_OK;
+	GT_SA_FILTERING sw_mode = 0;
+
+	IF_NULL(TPM_SWITCH_MOD, mac);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), mac(%02x:%02x:%02x:%02x:%02x:%02x), vlan(%d), mode(%d)\n",
+		    port, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], vlan, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_WHITE_FILTER_SMAC, "invalid MAC filter mode");
+
+	rc = tpm_sw_port_mac_filter_mode_xlate(mode, &sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to xlate filter mode(%d)\n", mode);
+
+	rc = mv_switch_port_mac_filter_entry_add(port, mac, vlan, sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to add mac filter entry port(%d) mode(%d)\n", port, sw_mode);
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_filter_entry_del
+*
+* DESCRIPTION: The routine deletes MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_filter_entry_del(enum tpm_sw_port_t			port,
+				     unsigned char			*mac,
+				     unsigned short			vlan,
+				     enum tpm_sw_mac_filter_mode_t	mode)
+{
+	int rc = TPM_OK;
+	GT_SA_FILTERING sw_mode = 0;
+
+	IF_NULL(TPM_SWITCH_MOD, mac);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), mac(%02x:%02x:%02x:%02x:%02x:%02x), vlan(%d), mode(%d)\n",
+		    port, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], vlan, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vlan, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_WHITE_FILTER_SMAC, "invalid MAC filter mode");
+
+	rc = tpm_sw_port_mac_filter_mode_xlate(mode, &sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to xlate filter mode(%d)\n", mode);
+
+	rc = mv_switch_port_mac_filter_entry_del(port, mac, vlan, sw_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "fail to add mac filter entry port(%d) mode(%d)\n", port, sw_mode);
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mac_address_clear
+*
+* DESCRIPTION: The routine clear all MAC addresses
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_mac_address_clear(void)
+{
+	unsigned int port_num;
+	unsigned int idx;
+	GT_BOOL enable;
+	unsigned int limit;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* clear all MAC addresses */
+	rc = mv_switch_atu_flush(GT_FLUSH_ALL, TPM_SWITCH_DB_NUM);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_atu_flush()\n");
+
+	/* re-config mac number limit */
+	port_num = mv_switch_port_num_get();
+	for (idx = 0; idx < port_num; idx++) {
+		rc = mv_switch_mac_learn_disable_get(idx, &enable);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_get()\n");
+		if (GT_FALSE == enable) {
+			rc = mv_switch_mac_limit_get(idx, &limit);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_get()\n");
+
+			rc = mv_switch_mac_learn_disable_set(idx, GT_TRUE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = tpm_sw_port_mac_table_clear_dynamic(idx);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+			rc = mv_switch_mac_limit_set(idx, 0);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(idx, GT_FALSE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(idx, GT_TRUE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = tpm_sw_port_mac_table_clear_dynamic(idx);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+			rc = mv_switch_mac_limit_set(idx, limit);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(idx, GT_FALSE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+		}
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_table_clear
+*
+* DESCRIPTION: The routine clear MAC address based on port and type
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC clear mode
+*		TPM_SW_MAC_ADDR_DYNAMIC:   clear dynami mac
+*		TPM_SW_MAC_ADDR_STATIC:    clear static mac
+*		TPM_SW_MAC_ADDR_UNICAST:   clear unicast mac
+*		TPM_SW_MAC_ADDR_MULTICAST: clear multicast mac
+*		TPM_SW_MAC_ADDR_ALL:       clear all
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_table_clear(enum tpm_sw_port_t		port,
+				enum tpm_sw_mac_addr_mode_t	mode)
+{
+	GT_ATU_ENTRY			atu_entry;
+	unsigned char			mac_addr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};/* initial MAC address */
+	enum tpm_sw_mac_addr_mode_t	l_mode;
+	bool				is_mc_addr = 0;
+	GT_BOOL				enable;
+	unsigned int			limit;
+	int				rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), mode(%d)\n", port, mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_ADDR_ALL, "invalid MAC address type");
+
+	memcpy(atu_entry.macAddr.arEther, &mac_addr, MAC_ADDR_SIZE);
+	atu_entry.DBNum = TPM_SWITCH_DB_NUM;
+
+	/* retrieve the ATU entries and delete it according by mode */
+	while ((rc = mv_switch_atu_next_entry_get(&atu_entry)) == MV_OK) {
+		if (TPM_IS_MULTICAST_MAC(atu_entry.macAddr.arEther) ||
+		    TPM_IS_BROADCAST_MAC(atu_entry.macAddr.arEther)) {
+			is_mc_addr = true;
+			l_mode = TPM_SW_MAC_ADDR_STATIC;
+		} else {
+			is_mc_addr = false;
+
+			if (atu_entry.entryState.ucEntryState == GT_UC_DYNAMIC)
+				l_mode = TPM_SW_MAC_ADDR_DYNAMIC;
+			else
+				l_mode = TPM_SW_MAC_ADDR_STATIC;
+		}
+
+		if ((TPM_SW_MAC_ADDR_ALL == mode) ||
+		    ((TPM_SW_MAC_ADDR_DYNAMIC == mode) && (TPM_SW_MAC_ADDR_DYNAMIC == l_mode)) ||
+		    ((TPM_SW_MAC_ADDR_STATIC == mode) && (TPM_SW_MAC_ADDR_STATIC == l_mode)) ||
+		    ((TPM_SW_MAC_ADDR_UNICAST == mode) && (false == is_mc_addr)) ||
+		    ((TPM_SW_MAC_ADDR_MULTICAST == mode) && (true == is_mc_addr))) {
+			/* whether the port is in the port vector */
+			if (atu_entry.portVec & (1 << port)) {
+				rc = mv_switch_mac_addr_del(port, atu_entry.macAddr.arEther);
+				IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_addr_del()\n");
+			}
+		}
+	}
+
+	/* re-config */
+	if ((TPM_SW_MAC_ADDR_ALL == mode) ||
+	    (TPM_SW_MAC_ADDR_DYNAMIC == mode) ||
+	    (TPM_SW_MAC_ADDR_UNICAST == mode)) {
+		rc = mv_switch_mac_learn_disable_get(port, &enable);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_get()\n");
+		if (GT_FALSE == enable) {
+			rc = mv_switch_mac_limit_get(port, &limit);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_get()\n");
+
+			rc = mv_switch_mac_learn_disable_set(port, GT_TRUE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = tpm_sw_port_mac_table_clear_dynamic(port);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+			rc = mv_switch_mac_limit_set(port, 0);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(port, GT_FALSE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(port, GT_TRUE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+
+			rc = tpm_sw_port_mac_table_clear_dynamic(port);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_table_clear_dynamic()\n");
+
+			rc = mv_switch_mac_limit_set(port, limit);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_limit_set()\n");
+
+			rc = mv_switch_mac_learn_disable_set(port, GT_FALSE);
+			IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_learn_disable_set()\n");
+		}
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_port_mac_table_clear_dynamic
+*
+* DESCRIPTION: The routine clear dynamic MAC address based on port
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_mac_table_clear_dynamic(enum tpm_sw_port_t port)
+{
+	GT_ATU_ENTRY			atu_entry;
+	unsigned char			mac_addr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};/* initial MAC address */
+	enum tpm_sw_mac_addr_mode_t	l_mode;
+	bool				is_mc_addr = 0;
+	int				rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	memcpy(atu_entry.macAddr.arEther, &mac_addr, MAC_ADDR_SIZE);
+	atu_entry.DBNum = TPM_SWITCH_DB_NUM;
+
+	/* retrieve the ATU entries and delete it according by mode */
+	while ((rc = mv_switch_atu_next_entry_get(&atu_entry)) == MV_OK) {
+		if (TPM_IS_MULTICAST_MAC(atu_entry.macAddr.arEther) ||
+		    TPM_IS_BROADCAST_MAC(atu_entry.macAddr.arEther)) {
+			is_mc_addr = true;
+			l_mode = TPM_SW_MAC_ADDR_STATIC;
+		} else {
+			is_mc_addr = false;
+
+			if (atu_entry.entryState.ucEntryState == GT_UC_DYNAMIC)
+				l_mode = TPM_SW_MAC_ADDR_DYNAMIC;
+			else
+				l_mode = TPM_SW_MAC_ADDR_STATIC;
+		}
+
+		if (TPM_SW_MAC_ADDR_DYNAMIC == l_mode) {
+			/* whether the port is in the port vector */
+			if (atu_entry.portVec & (1 << port)) {
+				rc = mv_switch_mac_addr_del(port, atu_entry.macAddr.arEther);
+				IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mac_addr_del()\n");
+			}
+		}
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_port_qos_set
+*
+* DESCRIPTION: The routine sets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_qos_set(enum tpm_sw_port_t	port,
+			enum tpm_sw_queue_t	queue,
+			enum tpm_sw_qos_mode_t	mode,
+			unsigned char		weight)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), queue(%d), mode(%d), weight(%d)\n",
+		    port, queue, mode, weight);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, queue, TPM_SWITCH_MAX_QUEUE_ID, "invalid queue ID");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_QOS_MODE_SP_WRR, "invalid switch port qos mode");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, weight, TPM_SWITCH_MAX_WRR_VAR, "invalid switch port weight");
+
+	/* set port QoS mode */
+	if (mode == TPM_SW_QOS_MODE_SP) {
+		rc = mv_switch_port_qos_mode_set(port, GT_PORT_SCHED_STRICT_PRI);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_set()\n");
+	} else if (mode == TPM_SW_QOS_MODE_WRR) {
+		rc = mv_switch_port_qos_mode_set(port, GT_PORT_SCHED_WEIGHTED_RRB);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_set()\n");
+
+		rc = mv_switch_queue_weight_set(port, queue, weight);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_queue_weight_set()\n");
+	} else if (mode == TPM_SW_QOS_MODE_SP_WRR) {
+		rc = mv_switch_port_qos_mode_set(port, GT_PORT_SCHED_STRICT_PRI3);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_set()\n");
+
+		rc = mv_switch_queue_weight_set(port, queue, weight);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_queue_weight_set()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_qos_get
+*
+* DESCRIPTION: The routine gets the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*
+* OUTPUTS:
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_qos_get(enum tpm_sw_port_t	port,
+			enum tpm_sw_queue_t	queue,
+			enum tpm_sw_qos_mode_t	*mode,
+			unsigned char		*weight)
+{
+	GT_PORT_SCHED_MODE l_mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), queue(%d)\n", port, queue);
+
+	IF_NULL(TPM_SWITCH_MOD, mode);
+	IF_NULL(TPM_SWITCH_MOD, weight);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, queue, TPM_SWITCH_MAX_QUEUE_ID, "invalid queue ID");
+
+	/* get port QoS mode */
+	*weight = 0;
+	rc = mv_switch_port_qos_mode_get(port, &l_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_get()\n");
+	if (l_mode == GT_PORT_SCHED_WEIGHTED_RRB) {
+		*mode = TPM_SW_QOS_MODE_WRR;
+		rc = mv_switch_queue_weight_get(port, queue, weight);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_get()\n");
+	} else if ((l_mode == GT_PORT_SCHED_STRICT_PRI3) || (l_mode == GT_PORT_SCHED_STRICT_PRI2_3)) {
+		*mode = TPM_SW_QOS_MODE_SP_WRR;
+		rc = mv_switch_queue_weight_get(port, queue, weight);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_qos_mode_get()\n");
+	} else if (l_mode == GT_PORT_SCHED_STRICT_PRI) {
+		*mode = TPM_SW_QOS_MODE_SP;
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), mode(%d), weight(%d)\n", rc, *mode, *weight);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mtu_set
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	mtu  - MTU of switch
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_mtu_set(unsigned int mtu)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", mtu);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* set MTU */
+	rc = mv_switch_mtu_set(mtu);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mtu_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mtu_get
+*
+* DESCRIPTION: The routine sets switch MTU
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	mtu  - MTU of switch
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_mtu_get(unsigned int *mtu)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	IF_NULL(TPM_SWITCH_MOD, mtu);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* get MTU */
+	rc = mv_switch_mtu_get(mtu);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mtu_get()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d), mtu(%d)\n", rc, *mtu);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_stat1_get
+*
+* DESCRIPTION: The routine gets performance counter 1
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 1
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_stat1_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat1_t	*stat)
+{
+	GT_STATS_COUNTER_SET3 set3_count;
+	GT_PORT_STAT2 drop_count;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, stat);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, reset, TPM_SW_COUNT_RESET, "invalid conter reset value");
+
+	/* get counter3 and drop counter */
+	rc = mv_switch_port_count3_get(port, &set3_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count3_get()\n");
+
+	rc = mv_switch_port_drop_count_get(port, &drop_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_drop_count_get()\n");
+
+	stat->inbytes		= ((unsigned long long)set3_count.InGoodOctetsHi << 32) + set3_count.InGoodOctetsLo;
+	stat->inpkts		= (set3_count.InUnicasts + set3_count.InMulticasts + set3_count.InBroadcasts);
+	stat->inunicast		= set3_count.InUnicasts;
+	stat->inmulticast	= set3_count.InMulticasts;
+	stat->inbroadcast	= set3_count.InBroadcasts;
+	stat->inerror		= set3_count.InFCSErr;
+	stat->indiscard		= ((unsigned long long)drop_count.inDiscardHi << 16) + drop_count.inDiscardLo;
+	stat->outbytes		= ((unsigned long long)set3_count.OutOctetsHi << 32) + set3_count.OutOctetsLo;
+	stat->outpkts		= (set3_count.OutUnicasts + set3_count.OutMulticasts + set3_count.OutBroadcasts);
+	stat->outunicast	= set3_count.OutUnicasts;
+	stat->outmulticast	= set3_count.OutMulticasts;
+	stat->outbroadcast	= set3_count.OutBroadcasts;
+	stat->outerror		= set3_count.OutFCSErr;
+	stat->outdiscard	= 0; /* do not have too much meaning for outer discard counter */
+
+	/* reset counter if needed */
+	if (reset == TPM_SW_COUNT_RESET) {
+		rc = mv_switch_port_count_clear(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count_clear()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_stat2_get
+*
+* DESCRIPTION: The routine gets performance counter 2
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 2
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_stat2_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat2_t	*stat)
+{
+	GT_STATS_COUNTER_SET3 set3_count;
+	GT_PORT_STAT2 drop_count;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, stat);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, reset, TPM_SW_COUNT_RESET, "invalid conter reset value");
+
+	/* get counter3 and drop counter */
+	rc = mv_switch_port_count3_get(port, &set3_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count3_get()\n");
+
+	rc = mv_switch_port_drop_count_get(port, &drop_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_drop_count_get()\n");
+
+	stat->inundersize	= set3_count.Undersize;
+	stat->inoversize	= set3_count.Oversize;
+	stat->infragments	= set3_count.Fragments;
+	stat->injabbers		= set3_count.Jabber;
+	stat->outundersize	= 0; /* does not have too much meaning for outer undersize couter */
+	stat->outoversize	= 0; /* does not have too much meaning for outer oversize couter */
+	stat->pppoefiltered	= 0; /* does not support it */
+	stat->statechange	= 0; /* does not support it */
+	stat->outpause		= set3_count.OutPause;
+	stat->dropevents	= ((unsigned long long)drop_count.inDiscardHi << 16) + drop_count.inDiscardLo +
+				  drop_count.inFiltered;
+
+	/* reset counter if needed */
+	if (reset == TPM_SW_COUNT_RESET) {
+		rc = mv_switch_port_count_clear(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count_clear()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_stat3_get
+*
+* DESCRIPTION: The routine gets performance counter 3
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_stat3_get(enum tpm_sw_port_t		port,
+			  enum tpm_sw_count_reset_t	reset,
+			  struct tpm_sw_port_stat3_t	*stat)
+{
+	GT_STATS_COUNTER_SET3 set3_count;
+	GT_PORT_STAT2 drop_count;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, stat);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, reset, TPM_SW_COUNT_RESET, "invalid conter reset value");
+
+	/* get counter3 and drop counter */
+	rc = mv_switch_port_count3_get(port, &set3_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count3_get()\n");
+
+	rc = mv_switch_port_drop_count_get(port, &drop_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_drop_count_get()\n");
+
+	stat->in64		= set3_count.Octets64;
+	stat->in65to127		= set3_count.Octets127;
+	stat->in128to255	= set3_count.Octets255;
+	stat->in256to511	= set3_count.Octets511;
+	stat->in512to1023	= set3_count.Octets1023;
+	stat->in1024tomax	= set3_count.OctetsMax;
+	stat->out64		= set3_count.Octets64;
+	stat->out65to127	= set3_count.Octets127;
+	stat->out128to255	= set3_count.Octets255;
+	stat->out256to511	= set3_count.Octets511;
+	stat->out512to1024	= set3_count.Octets1023;
+	stat->out1024tomax	= set3_count.OctetsMax;
+
+	/* reset counter if needed */
+	if (reset == TPM_SW_COUNT_RESET) {
+		rc = mv_switch_port_count_clear(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count_clear()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_stat_all_get
+*
+* DESCRIPTION: The routine gets all switch performance counters
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - all performance counters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_port_stat_all_get(enum tpm_sw_port_t			port,
+				enum tpm_sw_count_reset_t	reset,
+				struct tpm_sw_port_stat_all_t	*stat)
+{
+	GT_STATS_COUNTER_SET3 set3_count;
+	GT_PORT_STAT2 drop_count;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	IF_NULL(TPM_SWITCH_MOD, stat);
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, reset, TPM_SW_COUNT_RESET, "invalid conter reset value");
+
+	/* get counter3 and drop counter */
+	rc = mv_switch_port_count3_get(port, &set3_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count3_get()\n");
+
+	rc = mv_switch_port_drop_count_get(port, &drop_count);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_drop_count_get()\n");
+
+	stat->inGoodOctetsLo	= set3_count.InGoodOctetsLo;
+	stat->inGoodOctetsHi	= set3_count.InGoodOctetsHi;
+	stat->inBadOctets	= set3_count.InBadOctets;
+	stat->outFCSErr		= set3_count.OutFCSErr;
+	stat->inUnicasts	= set3_count.InUnicasts;
+	stat->deferred		= set3_count.Deferred;
+	stat->inBroadcasts	= set3_count.InBroadcasts;
+	stat->inMulticasts	= set3_count.InMulticasts;
+	stat->octets64		= set3_count.Octets64;
+	stat->octets127		= set3_count.Octets127;
+	stat->octets255		= set3_count.Octets255;
+	stat->octets511		= set3_count.Octets511;
+	stat->octets1023	= set3_count.Octets1023;
+	stat->octetsMax		= set3_count.OctetsMax;
+	stat->outOctetsLo	= set3_count.OutOctetsLo;
+	stat->outOctetsHi	= set3_count.OutOctetsHi;
+	stat->outUnicasts	= set3_count.OutUnicasts;
+	stat->excessive		= set3_count.Excessive;
+	stat->outMulticasts	= set3_count.OutMulticasts;
+	stat->outBroadcasts	= set3_count.OutBroadcasts;
+	stat->single		= set3_count.Single;
+	stat->outPause		= set3_count.OutPause;
+	stat->inPause		= set3_count.InPause;
+	stat->multiple		= set3_count.Multiple;
+	stat->undersize		= set3_count.Undersize;
+	stat->fragments		= set3_count.Fragments;
+	stat->oversize		= set3_count.Oversize;
+	stat->jabber		= set3_count.Jabber;
+	stat->inMACRcvErr	= set3_count.InMACRcvErr;
+	stat->inFCSErr		= set3_count.InFCSErr;
+	stat->collisions	= set3_count.Collisions;
+	stat->late		= set3_count.Late;
+	stat->inDiscard		= ((unsigned int)drop_count.inDiscardHi << 16) + drop_count.inDiscardLo;
+	stat->inFiltered	= drop_count.inFiltered;
+	stat->outFiltered	= drop_count.outFiltered;
+
+	/* reset counter if needed */
+	if (reset == TPM_SW_COUNT_RESET) {
+		rc = mv_switch_port_count_clear(port);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_count_clear()\n");
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+
+/*******************************************************************************
+* tpm_sw_atu_dump
+*
+* DESCRIPTION:
+*	This function prints ATU entries according to MAC address mode.
+*
+* INPUTS:
+*	mode - MAC address mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_atu_dump(enum tpm_sw_mac_addr_mode_t mode)
+{
+	GT_ATU_ENTRY			atu_entry;
+	unsigned char			mac_addr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};/* initial MAC address */
+	enum tpm_sw_mac_addr_mode_t	l_mode;
+	bool				is_mc_addr = 0;
+	unsigned int			idx = 0;
+	unsigned int			entry_num = 0;
+	GT_STATUS			rc = GT_OK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_MAC_ADDR_ALL, "invalid MAC address mode");
+
+	memcpy(atu_entry.macAddr.arEther, &mac_addr, MAC_ADDR_SIZE);
+	atu_entry.DBNum = TPM_SWITCH_DB_NUM;
+
+	/* retrieve the ATU entries */
+	while ((rc = mv_switch_atu_next_entry_get(&atu_entry)) == MV_OK) {
+		if (TPM_IS_MULTICAST_MAC(atu_entry.macAddr.arEther) ||
+		    TPM_IS_BROADCAST_MAC(atu_entry.macAddr.arEther)) {
+			is_mc_addr = true;
+			l_mode = TPM_SW_MAC_ADDR_STATIC;
+		} else {
+			is_mc_addr = false;
+
+			if (atu_entry.entryState.ucEntryState == GT_UC_DYNAMIC)
+				l_mode = TPM_SW_MAC_ADDR_DYNAMIC;
+			else
+				l_mode = TPM_SW_MAC_ADDR_STATIC;
+		}
+
+		if ((TPM_SW_MAC_ADDR_ALL == mode) ||
+		    ((TPM_SW_MAC_ADDR_DYNAMIC == mode) && (TPM_SW_MAC_ADDR_DYNAMIC == l_mode)) ||
+		    ((TPM_SW_MAC_ADDR_STATIC == mode) && (TPM_SW_MAC_ADDR_STATIC == l_mode)) ||
+		    ((TPM_SW_MAC_ADDR_UNICAST == mode) && (false == is_mc_addr)) ||
+		    ((TPM_SW_MAC_ADDR_MULTICAST == mode) && (true == is_mc_addr))) {
+			printk(KERN_INFO
+				"ATU Entry[%d]: MAC[%02x:%02x:%02x:%02x:%02x:%02x], Port Vector[0x%02x], type[%s]\n",
+				idx++,
+				atu_entry.macAddr.arEther[0],
+				atu_entry.macAddr.arEther[1],
+				atu_entry.macAddr.arEther[2],
+				atu_entry.macAddr.arEther[3],
+				atu_entry.macAddr.arEther[4],
+				atu_entry.macAddr.arEther[5],
+				(unsigned int)atu_entry.portVec,
+				(l_mode == TPM_SW_MAC_ADDR_DYNAMIC) ? "dynamic" : "static");
+			entry_num++;
+		}
+	}
+
+	if (!entry_num)
+		printk(KERN_INFO "No valid ATU entry for MAC address mode(%d)\n", mode);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_vtu_dump
+*
+* DESCRIPTION:
+*	The API prints VTU entry according to port VID information.
+*
+* INPUTS:
+*	vid   - VLAN ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_vtu_dump(unsigned int vid)
+{
+	GT_VTU_ENTRY vtu_entry;
+	unsigned int port_index;
+	unsigned int port;
+	unsigned int found;
+	unsigned int port_num;
+	int rc;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, vid, TPM_MAX_VLAN_ID_VALUE, "invalid VLAN ID");
+
+	/* get VLAN information from VTU */
+	memset(&vtu_entry, 0, sizeof(GT_VTU_ENTRY));
+	rc = mv_switch_vid_get(vid, &vtu_entry, &found);
+
+	if (rc == GT_OK) {
+		if (found) {
+			printk(KERN_INFO "DBNum:%i, VID:%i\n", vtu_entry.DBNum, vtu_entry.vid);
+			printk(KERN_INFO "Tag Mode: ");
+			port_num = mv_switch_port_num_get();
+			for (port_index = 0; port_index < port_num; port_index++) {
+				port = port_index;
+				printk(KERN_INFO "port(%d):%d; ", port, vtu_entry.vtuData.memberTagP[port]);
+			}
+			printk(KERN_INFO "\n");
+			printk(KERN_INFO
+				"Mode 0: egress unmodified, 1:port not in VLAN, 2:egress untagged, 3:egress tagged,\n");
+
+			printk(KERN_INFO
+				"vidPriOverride(%d), vidPriority(%d), sid(%d), vidPolicy(%d), useVIDFPri(%d)",
+				vtu_entry.vidPriOverride,
+				vtu_entry.vidPriority,
+				vtu_entry.sid,
+				vtu_entry.vidPolicy,
+				vtu_entry.vidExInfo.useVIDFPri);
+			printk(KERN_INFO
+				", vidFPri(%d), useVIDQPri(%d), vidQPri(%d), vidNRateLimit(%d)\n",
+				vtu_entry.vidExInfo.vidFPri,
+				vtu_entry.vidExInfo.useVIDQPri,
+				vtu_entry.vidExInfo.vidQPri,
+				vtu_entry.vidExInfo.vidNRateLimit);
+		}
+	} else if (rc == GT_NO_SUCH) {
+		printk(KERN_ERR "VTU has no vid(%d)\n", vtu_entry.vid);
+	} else {
+		printk(KERN_ERR "%s(%d) rc(%d) failed to call mv_switch_vid_get()\n",
+		       __func__, __LINE__, rc);
+
+		return TPM_FAIL;
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sw_vtu_shadow_dump
+*
+* DESCRIPTION:
+*	The API prints VTU shadow.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_vtu_shadow_dump(void)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* set MTU */
+	rc = mv_switch_vtu_shadow_dump();
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_vtu_shadow_dump()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mh_mode_set
+*
+* DESCRIPTION:
+*	This routine enables/disables ingress and egress header mode of switch port.
+*
+* INPUTS:
+*	port    - switch port ID.
+*	enable  - enable/disable marvell header.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_mh_mode_set(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), enable(%d)\n", port, enable);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_mh_mode_set(port, BIT_2_GT_BOOL(enable));
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_mh_mode_get
+*
+* DESCRIPTION:
+*	This routine gets ingress and egress header mode of switch port.
+*
+* INPUTS:
+*	port    - switch port ID.
+*
+* OUTPUTS:
+*	enable  - enable/disable marvell header.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_mh_mode_get(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable)
+{
+	GT_BOOL l_enable;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_mh_mode_get(port, &l_enable);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_get()\n");
+	*enable = (enum tpm_sw_config_state_t)GT_BOOL_2_BIT(l_enable);
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d) enable(%d)\n", rc, *enable);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_preamble_set
+*
+* DESCRIPTION:
+*	This routine sets preamble length of a switch port.
+*
+* INPUTS:
+*	port     - logical switch port ID.
+*	preamble - preamble length.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_port_preamble_set(enum tpm_sw_port_t port, unsigned short preamble)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d), preamble(%d)\n", port, preamble);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_port_preamble_set(port, preamble);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_preamble_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_port_preamble_get
+*
+* DESCRIPTION:
+*	This routine gets preamble length of a switch port.
+*
+* INPUTS:
+*	port     - logical switch port ID.
+*
+* OUTPUTS:
+*	preamble - preamble length.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_port_preamble_get(enum tpm_sw_port_t port, unsigned short *preamble)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, port(%d)\n", port);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_MAC_PORT, port);
+
+	rc = mv_switch_port_preamble_get(port, preamble);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_preamble_set()\n");
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d) preamble(%d)\n", rc, *preamble);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_head_mode_set
+*
+* DESCRIPTION:
+*	This routine switch sets head mode.
+*
+* INPUTS:
+*	mode  - switch head mode.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_head_mode_set(enum tpm_sw_head_mode_t mode)
+{
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In, mode(%d)\n", mode);
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SWITCH_MOD, mode, TPM_SW_HEAD_EXT_DSA, "invalid head mode");
+
+	/* set head mode */
+	if (mode == TPM_SW_HEAD_NONE) {
+		rc = mv_switch_mh_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+		rc = mv_switch_frame_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FRAME_MODE_NORMAL);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_set()\n");
+	} else if (mode == TPM_SW_HEAD_MH) {
+		rc = mv_switch_mh_mode_set(TPM_SWITCH_UPLINK_PORT, GT_TRUE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+		rc = mv_switch_frame_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FRAME_MODE_NORMAL);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_set()\n");
+	} else if (mode == TPM_SW_HEAD_MH_ETYPE_DSA) {
+		rc = mv_switch_mh_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+		rc = mv_switch_frame_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FRAME_MODE_ETHER_TYPE_DSA);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_set()\n");
+
+		rc = mv_switch_etype_set(TPM_SWITCH_UPLINK_PORT, TPM_ETHERTYPE_DSA_TAG);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_etype_set()\n");
+
+		/* clear registers */
+		rc = mv_switch_reg_write(0, 2, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+
+		rc = mv_switch_reg_write(0, 3, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+	} else if (mode == TPM_SW_HEAD_DSA) {
+		rc = mv_switch_mh_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+		rc = mv_switch_frame_mode_set(TPM_SWITCH_UPLINK_PORT, TPM_SW_HEAD_DSA);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_set()\n");
+
+		/* clear registers */
+		rc = mv_switch_reg_write(0, 2, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+
+		rc = mv_switch_reg_write(0, 3, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+	} else if (mode == TPM_SW_HEAD_EXT_DSA) {
+		rc = mv_switch_mh_mode_set(TPM_SWITCH_UPLINK_PORT, GT_FALSE);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_set()\n");
+
+		rc = mv_switch_frame_mode_set(TPM_SWITCH_UPLINK_PORT, TPM_SW_HEAD_DSA);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_set()\n");
+
+		/* clear registers */
+		rc = mv_switch_reg_write(0, 2, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+
+		rc = mv_switch_reg_write(0, 3, MV_SWITCH_GLOBAL2_ACCESS, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_reg_write()\n");
+	} else {
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "unsupportted mode(%d)\n", mode);
+	}
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d)\n", rc);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_head_mode_get
+*
+* DESCRIPTION:
+*	This routine switch gets head mode.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	mode  - switch head mode.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_sw_head_mode_get(enum tpm_sw_head_mode_t *mode)
+{
+	GT_BOOL mh_en;
+	GT_FRAME_MODE frame_mode;
+	int rc = TPM_OK;
+
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "In\n");
+
+	TPM_SWITCH_INIT_CHECK(TPM_SWITCH_MOD, TPM_SW_ALL_PORT, 0);
+
+	/* get MH mode */
+	rc = mv_switch_mh_mode_get(TPM_SWITCH_UPLINK_PORT, &mh_en);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_mh_mode_get()\n");
+
+	/* get frame mode */
+	rc = mv_switch_frame_mode_get(TPM_SWITCH_UPLINK_PORT, &frame_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_frame_mode_get()\n");
+
+	/* calculate head mode */
+	if ((frame_mode == GT_FRAME_MODE_NORMAL) && (mh_en == GT_FALSE))
+		*mode = TPM_SW_HEAD_NONE;
+	else if ((frame_mode == GT_FRAME_MODE_NORMAL) && (mh_en == GT_TRUE))
+		*mode = TPM_SW_HEAD_MH;
+	else if ((frame_mode == GT_FRAME_MODE_ETHER_TYPE_DSA) && (mh_en == GT_FALSE))
+		*mode = TPM_SW_HEAD_MH_ETYPE_DSA;
+	else if ((frame_mode == GT_FRAME_MODE_DSA) && (mh_en == GT_FALSE))
+		*mode = TPM_SW_HEAD_DSA;
+	else if ((frame_mode == GT_FRAME_MODE_DSA) && (mh_en == GT_TRUE)) /* to modify later for 2-DSA */
+		*mode = TPM_SW_HEAD_EXT_DSA;
+	else
+		TPM_OS_ERROR(TPM_SWITCH_MOD, "unsupportted combination, frame_mode(%d) mh_en(%d)\n", frame_mode, mh_en);
+	TPM_OS_DEBUG(TPM_SWITCH_MOD, "Out, rc(%d) mode(%d)\n", rc, *mode);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sw_start
+*
+* DESCRIPTION: The routine init switch module
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sw_start(void)
+{
+	int idx;
+	int port_num;
+	unsigned int switch_init;
+	enum tpm_sw_head_mode_t head_mode;
+	unsigned char gq_da[MAC_ADDR_SIZE] = {0x01, 0x00, 0x5e, 0x00, 0x00, 0x01};
+	unsigned char gq_mld_da[MAC_ADDR_SIZE] = {0x33, 0x33, 0x00, 0x00, 0x00, 0x01};
+	int rc = TPM_OK;
+
+	/* get TPM switch init flag */
+	rc = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &switch_init);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "get switch init config failed\n");
+
+	/* do nothing if no init is needed for TPM switch */
+	if (switch_init == TPM_SW_MODE_NOT_INIT) {
+		TPM_OS_WARN(TPM_SWITCH_MOD, "TPM is not allowed to config switch, ignore switch init\n");
+		return TPM_OK;
+	}
+
+	/* get and set switch head mode, need update it with eth complex feature */
+	head_mode = tpm_db_init_switch_mode_get(TPM_ENUM_GMAC_0);
+	rc = tpm_sw_head_mode_set(head_mode);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_mh_mode_set()\n");
+
+	/* set switch port default jumbo mode */
+	rc = tpm_sw_mtu_set(2048);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_mtu_set()\n");
+
+	/* set all ports to VLAN fallback mode */
+	port_num = mv_switch_port_num_get();
+	for (idx = 0; idx < port_num; idx++) {
+		rc = mv_switch_port_vlan_mode_set(idx, GT_FALLBACK);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call mv_switch_port_vlan_mode_set()\n");
+	}
+
+	/* set default PVID of all ports to 0, and add VID 0 to VTU  */
+	for (idx = 0; idx < port_num; idx++) {
+		rc = tpm_sw_port_pvid_set(idx, 0, 0);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_pvid_set()\n");
+		rc = tpm_sw_port_vlan_set(idx, 0, 0, TPM_SW_VLAN_EGRESS_ASIS);
+		IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_vlan_set()\n");
+	}
+
+	/* add multicast MAC address to pass through D/S generic query packet by default */
+	rc = tpm_sw_port_mac_address_add(((1 << port_num) - 1), gq_da, 0/* not care */, TPM_SW_MAC_ADDR_STATIC);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_address_add()\n");
+	rc = tpm_sw_port_mac_address_add(((1 << port_num) - 1), gq_mld_da, 0/* not care */, TPM_SW_MAC_ADDR_STATIC);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_mac_address_add()\n");
+
+	/* do below after eth complex */
+
+	/* enable broadcast flooding by default */
+	rc = tpm_sw_port_flood_control_mask_set(0 /* meaningless for bc */, TPM_SW_FLOOD_PKT_BROADCAST, 1/* enable */);
+	IF_ERROR_STR(TPM_SWITCH_MOD, rc, "failed to call tpm_sw_port_flood_control_mask_set()\n");
+
+	/* disable multicast flooding by default */
+
+	/* add default multicast MAC address */
+
+	/* set port to none-filter mode by default VLAN(0) */
+
+	/* add default VLAN(0) */
+
+	/* init IPG mode */
+
+	return rc;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs.c
new file mode 100644
index 0000000..5f28d96
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs.c
@@ -0,0 +1,422 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE	: tpm_sysfs.c						     **
+**									     **
+**  DESCRIPTION : This file implements TPM sysfs command and ioctrl	     **
+**  DEPENDCY : TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+
+static struct tpm_attr_group_pair_t g_attr_group_pair_ara_debug[TPM_SYSFS_NUM_MAX_ATTR_GROUP];
+static struct tpm_attr_group_pair_t g_attr_group_pair_ara_api[TPM_SYSFS_NUM_MAX_ATTR_GROUP];
+
+
+/******************************************************************************/
+/* ========================================================= */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================= */
+
+/*******************************************************************************
+* tpm_sysfs_register
+*
+* DESCRIPTION: The routine register attribute group to sysfs.
+*
+* INPUTS:
+*	type  - tpm sysfs type
+*       name  - tpm sub-module object name
+*	group - tpm attribute group
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int tpm_sysfs_register(enum tpm_sysfs_type_t type, char *name,
+			struct attribute_group *group)
+{
+	struct tpm_attr_group_pair_t *attr_group_pair;
+	int indx;
+
+	if (TPM_SYSFS_TYPE_API == type) {
+		attr_group_pair = &g_attr_group_pair_ara_api[0];
+	} else if (TPM_SYSFS_TYPE_DEBUG == type) {
+		attr_group_pair = &g_attr_group_pair_ara_debug[0];
+	} else {
+		TPM_OS_ERROR(TPM_SYSFS_MOD,
+			"Illegal tpm sysfs type:%d\n", type);
+		return TPM_BAD_PARAM;
+	}
+
+	/* Save the attribute group */
+	for (indx = 0; indx < TPM_SYSFS_NUM_MAX_ATTR_GROUP; indx++) {
+		if (false == (attr_group_pair + indx)->valid)
+			break;
+	}
+	if (indx == TPM_SYSFS_NUM_MAX_ATTR_GROUP) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD,
+			"tpm sysfs type:%d DB is full\n", type);
+		return TPM_NO_RESOURCE;
+	}
+	(attr_group_pair + indx)->valid = true;
+	(attr_group_pair + indx)->obj_name = name;
+	(attr_group_pair + indx)->attr_group = group;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_debug_sysfs_init
+*
+* DESCRIPTION: The routine will initialize TPM debug group sysfs.
+*
+* INPUTS:
+*	kobj - tpm sysfs object
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_debug_sysfs_init(struct kobject *kobj)
+{
+	struct kobject *debug_kobj;
+	struct kobject *module_kobj;
+	struct tpm_attr_group_pair_t *pair1;
+	struct tpm_attr_group_pair_t *pair2;
+	bool found = false;
+	int indx1 = 0;
+	int indx2 = 0;
+	int err;
+
+
+	/* Create sysfs tpm/debug folder */
+	debug_kobj = kobject_create_and_add("debug", kobj);
+	if (!debug_kobj) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "Cannot create debug kobject\n");
+		return TPM_FAIL;
+	}
+
+	for (indx1 = 0; indx1 < TPM_SYSFS_NUM_MAX_ATTR_GROUP; indx1++) {
+		pair1 = &g_attr_group_pair_ara_debug[indx1];
+		if (true != pair1->valid)
+			continue;
+
+		if (NULL == pair1->obj_name) {
+
+			err = sysfs_create_group(debug_kobj,
+				pair1->attr_group);
+			if (err) {
+				TPM_OS_ERROR(TPM_SYSFS_MOD,
+					"sysfs_create_group failed for"
+					"%s, err = %d\n",
+					pair1->attr_group->name, err);
+				return TPM_FAIL;
+			}
+		} else {
+			/* Check whether the kobject already exists */
+			found = false;
+			for (indx2 = 0; indx2 < indx1; indx2++) {
+				pair2 = &g_attr_group_pair_ara_debug[indx2];
+				if ((true != pair2->valid)
+					|| (NULL == pair2->obj_name))
+					continue;
+
+				if (!strcmp(pair1->obj_name,
+				     pair2->obj_name) &&
+				    (NULL != pair2->kobj)) {
+					found = true;
+					module_kobj = pair2->kobj;
+					break;
+				}
+			}
+
+			/* Create kobject if it does not exist */
+			if (false == found) {
+				module_kobj = kobject_create_and_add(
+					pair1->obj_name,
+					debug_kobj);
+				if (!module_kobj) {
+					TPM_OS_ERROR(TPM_SYSFS_MOD, "Cannot create module kobject\n");
+					return TPM_FAIL;
+				}
+			}
+
+			err = sysfs_create_group(module_kobj,
+						pair1->attr_group);
+			if (err) {
+				TPM_OS_ERROR(TPM_SYSFS_MOD,
+					"sysfs_create_group failed for %s, err = %d\n",
+					pair1->attr_group->name, err);
+				return TPM_FAIL;
+			}
+			pair1->kobj = module_kobj;
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_api_sysfs_init
+*
+* DESCRIPTION: The routine will initialize TPM api group sysfs.
+*
+* INPUTS:
+*	kobj - tpm sysfs object
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_api_sysfs_init(struct kobject *kobj)
+{
+	struct kobject *api_kobj;
+	struct kobject *module_kobj;
+	struct tpm_attr_group_pair_t *pair1;
+	struct tpm_attr_group_pair_t *pair2;
+	bool found = false;
+	int indx1 = 0;
+	int indx2 = 0;
+	int err;
+
+
+	/* Create sysfs tpm/api folder */
+	api_kobj = kobject_create_and_add("api", kobj);
+	if (!api_kobj) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "Cannot create api kobject\n");
+		return TPM_FAIL;
+	}
+
+	for (indx1 = 0; indx1 < TPM_SYSFS_NUM_MAX_ATTR_GROUP; indx1++) {
+		pair1 = &g_attr_group_pair_ara_api[indx1];
+		if (true == pair1->valid) {
+
+			if (NULL == pair1->obj_name) {
+
+				err = sysfs_create_group(api_kobj,
+							pair1->attr_group);
+				if (err) {
+					TPM_OS_ERROR(TPM_SYSFS_MOD,
+						"sysfs_create_group failed for %s, err = %d\n",
+						pair1->attr_group->name, err);
+					return TPM_FAIL;
+				}
+			} else {
+				/* Check whether the kobject already exists */
+				found = false;
+				for (indx2 = 0; indx2 < indx1; indx2++) {
+					pair2 = &g_attr_group_pair_ara_api[indx2];
+					if ((true != pair2->valid)
+					     || (NULL == pair2->obj_name))
+						continue;
+					if (!strcmp(pair1->obj_name,
+						pair2->obj_name) &&
+					    (NULL != pair2->kobj)) {
+						found = true;
+						module_kobj = pair2->kobj;
+						break;
+					}
+
+				}
+
+				/* Create kobject if it does not exist */
+				if (false == found) {
+					module_kobj = kobject_create_and_add(pair1->obj_name, api_kobj);
+					if (!module_kobj) {
+						TPM_OS_ERROR(TPM_SYSFS_MOD,
+							"Cannot create module kobject\n");
+						return TPM_FAIL;
+					}
+				}
+
+				err = sysfs_create_group(module_kobj,
+							pair1->attr_group);
+				if (err) {
+					TPM_OS_ERROR(TPM_SYSFS_MOD, "sysfs_create_group failed for %s, err = %d\n",
+						     pair1->attr_group->name, err);
+					return TPM_FAIL;
+				}
+				pair1->kobj = module_kobj;
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sysfs_init
+*
+* DESCRIPTION: The routine will initialize TPM sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_init(void)
+{
+	int err;
+	struct device *pd;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
+	if (!pd) {
+		platform_device_register_simple("tpm", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "tpm");
+	}
+
+	if (!pd) {
+		TPM_OS_INFO(TPM_SYSFS_MOD, "Cannot find tpm device\n");
+		pd = &platform_bus;
+	}
+
+	/* Initialize init cfg sysfs */
+	err = tpm_sysfs_init_cfg_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM Init cfg sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize parser sysfs */
+	err = tpm_sysfs_prs_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM Parser sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize classifier sysfs */
+	err = tpm_sysfs_cls_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM Classifier sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize c2 sysfs */
+	err = tpm_sysfs_c2_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM C2 sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize c3 sysfs */
+	err = tpm_sysfs_c3_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM C3 sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize c4 sysfs */
+	err = tpm_sysfs_c4_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM C4 sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize packet modification sysfs */
+	err = tpm_sysfs_pme_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM Packet modification sysfs initialize failed\n");
+		return err;
+	}
+
+#ifdef CONFIG_MV_INCLUDE_SWITCH
+	/* Initialize switch sysfs */
+	err = tpm_sysfs_switch_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM switch sysfs initialize failed\n");
+		return err;
+	}
+#endif
+	/* Initialize api sysfs */
+	err = tpm_sysfs_api_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM api sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize management sysfs */
+	err = tpm_sysfs_mng_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM mng sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize policer sysfs */
+	err = tpm_sysfs_plcr_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM plcr sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize multicast sysfs */
+	err = tpm_sysfs_mc_init();
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM MC sysfs initialize failed\n");
+		return err;
+	}
+
+	/* Initialize API sysfs group */
+	err = tpm_api_sysfs_init(&pd->kobj);
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM API sysfs group initialize failed\n");
+		return err;
+	}
+
+	/* Initialize debug sysfs group */
+	err = tpm_debug_sysfs_init(&pd->kobj);
+	if (err) {
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "TPM debug sysfs group initialize failed\n");
+		return err;
+	}
+
+	printk(KERN_INFO "= TPM SYS FS Init Successfully =\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_api.c
new file mode 100644
index 0000000..7b9f99b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_api.c
@@ -0,0 +1,7280 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_api.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+#include "tpm_sysfs_utils.h"
+
+static char *key_empty_name      = "key_empty";
+static char *frwd_empty_name     = "frwd_empty";
+static char *mod_empty_name      = "mod_empty";
+static char *qos_empty_name      = "qos_empty";
+static struct tpm_qos_tbl_act_t	g_qos_tbl[MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE];	/* DSCP table entry array */
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+/*******************************************************************************
+* mv_tpm_exact_match_rule_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*              passes parameters to user space to perform exact match classification to all packets it should process, as
+*              defined in the Init configuration. (Typically all the Routed Unicast packets).
+*              At a minimum packets are matched with their Ethertype (and ppp_proto), and 5-tuple.
+*              There is no partial field classification.
+*              Additional classification fields will be added in AVANTA-LP-Ao.
+*              Packets forwarded to CPU cannot be modified.
+*
+* INPUTS:
+*	exact_match - Contains Match parameters to perform exact match.
+*			5_tuple + IP_version are mandatory, others are optional.
+*	action      - Contains parameters to classify the packet:
+*			Packet destination, modification and packet color for policer and tx_queue thresholds.
+*	policer_id  - Reference to previously created policer (0-15), 0xffff-> no policer
+*
+* OUTPUTS:
+*	rule_id     - Unique handle to this rule. Should be used for deleting the rule. Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_add_bounce(struct tpm_exact_match_t	*exact_match,
+				unsigned short			num_pp_trgt,
+				struct tpm_pkt_action_t		action[],
+				unsigned char			policer_id,
+				unsigned int			*rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule	= &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd				= TPM_IOCTL_ACL_EXACT_ADD;
+	tpm_ioctl_acl_rule->exact_add_para.num_pp_trgt	= num_pp_trgt;
+	tpm_ioctl_acl_rule->exact_add_para.policer_id	= policer_id;
+	memcpy(&(tpm_ioctl_acl_rule->exact_add_para.exact_match),
+		(void *)exact_match,
+		sizeof(tpm_ioctl_acl_rule->exact_add_para.exact_match));
+	memcpy(&(tpm_ioctl_acl_rule->exact_add_para.action),
+		(void *)action,
+		sizeof(tpm_ioctl_acl_rule->exact_add_para.action));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to delete an exact_match_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del_bounce(struct tpm_5t_t *ipvx_five_t, unsigned int rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule	= &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_DEL;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != ipvx_five_t) {
+		memcpy(&(tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t),
+			(void *)ipvx_five_t,
+			sizeof(tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_del_all_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete all exact_match rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_del_all_bounce(void)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_DEL_ALL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_rule_cntr_get_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to get an exact_match_rule's counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	ipvx_five_t	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr		-  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_rule_cntr_get_bounce(
+	struct tpm_5t_t *ipvx_five_t,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule	= &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_CNTR_GET;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != ipvx_five_t) {
+		memcpy(&(tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t),
+			(void *)ipvx_five_t,
+			sizeof(tpm_ioctl_acl_rule->exact_add_para.exact_match.ipvx_five_t));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to handle packets that were compared to the exact_match_rules,
+*                         and created an exception in that ruleset.
+*		I.e. they passed the exact_match rule_set without hitting any rule. Rules in this API are
+*		limited to forwarding packets to CPU or dropping. Consequently, packets cannot be modified.
+*
+* INPUTS:
+*	match_key    - Contains Match parameters to perform packet match according to predefined
+*			capabilities. Initial supported capabilities are l4_ports, l4_proto, and dscp. Keys
+*			matching any of the IPv4/v6/TCP/UDP fields, must match the (TPM_MATCH_IPV4_PKT)attribute.
+*
+*	action       - Contains parameters to classify the packet: Set packet destination (only to CPU or drop),
+*			and set packet color. No packet modification.
+*	policer_id   - See previous definition.
+*	qos          - Parameter can be used in [ext_qos_tbl] mode (configured in Init). This mode implies
+*			that callers of this API can perform direct table lookup on the Packet processor
+*			qos_tables, (See also tpm_qos_table_set API) and use the qos_table_lookup as part of
+*			the main key matching process. NULL pointer implies no qos_table is used.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition.  Here it's the pseudo output.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_add_bounce(struct tpm_pkt_key_t	*match_key,
+				       struct tpm_pkt_action_t	*action,
+				       unsigned char		policer_id,
+				       struct tpm_qos_t		*qos,
+				       unsigned int		*rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_EXCEPT_ADD;
+	tpm_ioctl_acl_rule->rule_add_para.policer_id	= policer_id;
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+		(void *)match_key,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.action),
+		(void *)action,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.action));
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.qos),
+		(void *)qos,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.qos));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to delete an exact_match_except_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del_bounce(struct tpm_pkt_key_t *match_key, unsigned int rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_EXCEPT_DEL;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_del_all_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete all  exact_match_except rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_del_all_bounce(void)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_EXCEPT_DEL_ALL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_exact_match_except_rule_cntr_get_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to get an exact_match_except_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr		-  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_exact_match_except_rule_cntr_get_bounce(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_EXACT_EXCEPT_CNTR_GET;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to processes all packets that are not handled by other API's.(I.e. Typically bridged packets).
+*                         The API allows to use combined field-matching keys and masks (as pre-configured during Init) .
+*
+* INPUTS:
+*	match_key    - See previous definition.
+*	action       - See previous definition. Can set all action fields.
+*	policer_id   - See previous definition.
+*	qos          - See previous definition.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition.  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_add_bounce(struct tpm_pkt_key_t	*match_key,
+			    unsigned short		num_pp_trgt,
+			    struct tpm_pkt_action_t	action[],
+			    unsigned char		policer_id,
+			    struct tpm_qos_t		*qos,
+			    unsigned int		*rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_GEN_CLS_ADD;
+	tpm_ioctl_acl_rule->rule_add_para.num_pp_trgt	= num_pp_trgt;
+	tpm_ioctl_acl_rule->rule_add_para.policer_id	= policer_id;
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+		(void *)match_key,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.action),
+		(void *)action,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.action));
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.qos),
+		(void *)qos,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.qos));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to delete an gen_cls_rule. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del_bounce(struct tpm_pkt_key_t *match_key, unsigned int rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_GEN_CLS_DEL;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_del_all_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete all  generic classification rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_del_all_bounce(void)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_GEN_CLS_DEL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_gen_cls_rule_cntr_get_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*                         passes parameters to user space to get an gen_cls_rule  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr		-  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_gen_cls_rule_cntr_get_bounce(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_GEN_CLS_CNTR_GET;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_mc_flow_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*              passes parameters to user space to handle Multicast packets (Snooping or Proxy Routing) according to HGU/SFU requirements.
+*              The allowed field-matches are statically preconfigured for the most.
+*              Multicast streams that do not have a mc_flow rule, and are not IGMP/MLD, will be be dropped or sent to
+*              CPU (Init configured).
+*
+* INPUTS:
+*	match_key  - See previous definition.
+*			Fields that are allowed in the field-match bitmap:
+*			port, out_vid, ether_type, pppoe_proto
+*			ip_src (must have full host_mask).
+*			ip_dst OR eth_dst (In either case, must have full host_mask)
+*
+*	num_dest   - Number of Destination Action, meaning number of packet replications.
+*	action     - See previous definition. Can set all action fields.
+*
+* OUTPUTS:
+*	rule_id    - See previous definition.  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_add_bounce(struct tpm_pkt_key_t	*match_key,
+		       unsigned short		num_dest,
+		       struct tpm_pkt_action_t	action[],
+		       int			*rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MC_FLOW_ADD;
+	tpm_ioctl_acl_rule->rule_add_para.num_pp_trgt	= num_dest;
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.match_key),
+		(void *)match_key,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.match_key));
+	memcpy(&(tpm_ioctl_acl_rule->rule_add_para.action),
+		(void *)action,
+		sizeof(tpm_ioctl_acl_rule->rule_add_para.action));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete an multicast rule
+*
+* INPUTS:
+*	rule_id     - Rule to delete
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del_bounce(unsigned int	rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MC_FLOW_DEL;
+	tpm_ioctl_acl_rule->rule_id			= rule_id;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_mc_flow_del_all_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete all multicast rules
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mc_flow_del_all_bounce(void)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MC_FLOW_DEL_ALL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+
+/*******************************************************************************
+* mv_tpm_cm_rule_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*	passes parameters to user space to add a CnM rule that sets target queue and optionally p-bit for bridged packets.
+*                         The API allows using combined field-matching keys that do not need to be pre-configured during Init.
+*                         Each CnM rule could have up to 6 fields:
+*                         Three of them :no bigger than 2 bytes, operator could be equal, not equal, greater equal or less equal.
+*                         one of them    : no bigger than 16 bytes, operator could be equal, not equal.
+*                         one of them    : no bigger than 6 bytes, operator could be equal, not equal.
+*
+* INPUTS:
+*	cnm_key      - Contains CnM rule key items.
+*			rule_num: 0 to 7.
+*			field_num: each CnM rule has up to 6 fields.
+*			field_op   : each field operator could be equal, not equal, less or equal, greater or equal.
+*			match_key: contains the field key value, and source port. Only UNI port is allowed as src port.
+*	action           - See previous definition. Only target queue and vlan mod pbit value is relevent.
+*                                in mod, only TPM_VLAN_MOD is supported, and in vlan_op only VLANOP_EXT_TAG_MOD is supported
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_add_bounce(struct tpm_cnm_key_t	*cnm_key,
+			    struct tpm_pkt_action_t	*action)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MC_FLOW_ADD;
+	memcpy(&(tpm_ioctl_acl_rule->cm_add_para.cnm_key),
+		(void *)cnm_key,
+		sizeof(tpm_ioctl_acl_rule->cm_add_para.cnm_key));
+	memcpy(&(tpm_ioctl_acl_rule->cm_add_para.action),
+		(void *)action,
+		sizeof(tpm_ioctl_acl_rule->cm_add_para.action));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete a CnM rule.
+*
+* INPUTS:
+*	rule_num: valid from 0 to 7
+*	port	: src port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del_bounce(
+	struct tpm_class_port_t	*port,
+	unsigned int rule_num)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_CM_DEL;
+	tpm_ioctl_acl_rule->rule_id			= rule_num;
+	memcpy(&(tpm_ioctl_acl_rule->cm_add_para.cnm_key.match_key.port),
+		(void *)port,
+		sizeof(tpm_ioctl_acl_rule->cm_add_para.cnm_key.match_key.port));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_cm_rule_del_all_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to delete all CnM rules of certain ports.
+*
+* INPUTS:
+*	port_bm: bit map of port
+*
+* OUTPUTS:
+*	NONE
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_cm_rule_del_all_bounce(unsigned int port_bm)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd						= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd						= TPM_IOCTL_ACL_CM_DEL_ALL;
+	tpm_ioctl_acl_rule->cm_add_para.cnm_key.match_key.port.class_port	= port_bm;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_qos_table_entry_set_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*              passes parameters to user space to directly configures the packet processor Qos Tables (part of C2 Engine).
+*              The packet processor has 64 p-bit tables and 16 dscp tables, that can be used for mapping pbit/dscp
+*              values to Qos related parameters (GMAC/T-CONT, gemport, rx/tx_queue, packet_color for policer)
+*              Values returned by the mapping table can be used as part of a generic packet classification, as
+*              written in APIs using the qos_tbl.
+*
+* INPUTS:
+*	qos_select - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl        - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	entry          - Table.entry. For pbit-mapping table entry is (0-7),and for dscp (0-63)
+*	qos_cfg        - Qos parameter configuration.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_entry_set_bounce(enum tpm_qos_sel_t	qos_select,
+			       unsigned char		qos_tbl,
+			       unsigned char		entry,
+			       struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_QOS_TBL_ENTRY_SET;
+	tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_select	= qos_select;
+	tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_tbl	= qos_tbl;
+	tpm_ioctl_pp_oper->pp_qos_tbl_set.entry		= entry;
+	memcpy(&(tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_cfg),
+		(void *)qos_cfg,
+		sizeof(tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_cfg));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_qos_table_set_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to configures all entries of a qos_table with value in param.
+*
+* INPUTS:
+*	qos_select  - Select if to configure a pbit mapping talble or a dscp mapping table.
+*	qos_tbl         - There are a 64 pbit tables available (0-63) and 8 dscp tables available (0-7).
+*	qos_cfg         - Qos table parameter configuration array.
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+*******************************************************************************/
+int mv_tpm_qos_table_set_bounce(enum tpm_qos_sel_t		qos_select,
+			 unsigned char			qos_tbl,
+			 struct tpm_qos_tbl_act_t	*qos_cfg)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_QOS_TBL_SET;
+	tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_select	= qos_select;
+	tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_tbl	= qos_tbl;
+	memcpy(&(tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_cfg),
+		(void *)qos_cfg,
+		sizeof(tpm_ioctl_pp_oper->pp_qos_tbl_set.qos_cfg));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+
+/* TBD:
+*  1. mv_tpm_bridge_learning_mac_rule_add();	// Add mac for learning
+*  2. mv_tpm_bridge_learning_vid_add();		// Add vid for bridge learning
+*  3. mv_tpm_dynamic_field_rule_add();		// CnM
+*  4. mv_tpm_filter_rule_add();			// Perform White List filtering
+*  5. mv_tpm_policer_add();			// Add policer
+*  6. mv_tpm_init.				// Init parameters
+*/
+
+/*******************************************************************************
+* mv_tpm_plcr_add()
+*
+* DESCRIPTION: This API adds a policer entry.
+*
+* INPUTS:
+*	policer_entry - policer entry configuration.
+*
+* OUTPUTS:
+*	policer_id    - policer ID.  Here it's the pseudo output.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_add_bounce(struct tpm_policer_entry_t	*policer_entry,
+		    unsigned char		*policer_id)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_PLCR_ADD;
+	memcpy(&(tpm_ioctl_pp_oper->pp_plcr.policer_entry),
+		(void *)policer_entry,
+		sizeof(tpm_ioctl_pp_oper->pp_plcr.policer_entry));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_plcr_del()
+*
+* DESCRIPTION: This API deletes a policer entry.
+*
+* INPUTS:
+*	policer_id    - policer ID.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_del_bounce(unsigned char policer_id)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_PLCR_DEL;
+	tpm_ioctl_pp_oper->pp_plcr.policer_id		= policer_id;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_plcr_clear()
+*
+* DESCRIPTION: This API deletes all policer entries.
+*
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_plcr_clear_bounce(void)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_PLCR_DEL_ALL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_sched_egr_mtu_set()
+*
+* DESCRIPTION: This API set the egress MTU on the port.
+*
+* INPUTS:
+*          gmac_idx    - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont       - valid for GPON PMAC, other set to 0
+*          tx_size_max - MTU, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_mtu_set_bounce(enum tpm_gmac_idx_t gmac_idx,
+			     unsigned char tcont_id,
+			     unsigned int tx_size_max)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd				= TPM_IOCTL_PP_SCHED_EGR_MTU_SET;
+	tpm_ioctl_pp_oper->pp_sched_egr_mtu.gmac_idx	= gmac_idx;
+	tpm_ioctl_pp_oper->pp_sched_egr_mtu.tcont_id	= tcont_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_mtu.tx_size_max	= tx_size_max;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_mode_set_bounce()
+*
+* DESCRIPTION: This API Set the egress scheduling mode, strict or wrr.
+*
+* INPUTS:
+*          gmac_idx  - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont     - valid for GPON PMAC, other set to 0
+*          queue_id  - queue index, 0-7
+*          mode      - scheduling mode, strict priority or WRR
+*          wrr_weight- 0-255, if mode is WRR
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_mode_set_bounce(enum tpm_gmac_idx_t gmac_idx,
+				    unsigned char tcont_id,
+				    unsigned char queue_id,
+				    enum tpm_egr_sched_mode_t mode,
+				    unsigned short wrr_weight)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd				= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd					= TPM_IOCTL_PP_SCHED_EGR_Q_MODE_SET;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_mode.gmac_idx		= gmac_idx;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_mode.tcont_id		= tcont_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_mode.queue_id		= queue_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_mode.mode		= mode;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_mode.wrr_weight	= wrr_weight;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_sched_egr_queue_rate_lim_set_bounce()
+*
+* DESCRIPTION: This API set the egress rate limit on the queue.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_queue_rate_lim_set_bounce(enum tpm_gmac_idx_t gmac_idx,
+					unsigned char tcont_id,
+					unsigned char queue_id,
+					unsigned int rate_lim_val,
+					unsigned int bucket_size)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd				= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd					= TPM_IOCTL_PP_SCHED_EGR_Q_RATE_LIM_SET;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_rate_lim.gmac_idx	= gmac_idx;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_rate_lim.tcont_id	= tcont_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_rate_lim.queue_id	= queue_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_rate_lim.rate_lim_val	= rate_lim_val;
+	tpm_ioctl_pp_oper->pp_sched_egr_q_rate_lim.bucket_size	= bucket_size;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_sched_egr_port_rate_lim_set()
+*
+* DESCRIPTION: This API set the egress rate limit on the port.
+*
+* INPUTS:
+*          gmac_idx      - MAC port index, 0-GMAC0, 1-GMAC1, 3-PMAC
+*          tcont         - valid for GPON PMAC, other set to 0
+*          queue_id      - queue index, 0-7
+*          rate_lim_val  - bandwidth limit set to, unit: kbps
+*          buckt_size    - the max burst size, unit: byte
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sched_egr_port_rate_lim_set_bounce(enum tpm_gmac_idx_t gmac_idx,
+				       unsigned char tcont_id,
+				       unsigned int rate_lim_val,
+				       unsigned int bucket_size)
+{
+	struct tpm_ioctl_pp_oper_t	*tpm_ioctl_pp_oper = &tpm_sfs_2_ioctl_command.tpm_ioctl_pp_oper;
+
+	tpm_sfs_2_ioctl_command.cmd					= MV_TPM_IOCTL_PP_SECTION;
+	tpm_ioctl_pp_oper->cmd						= TPM_IOCTL_PP_SCHED_EGR_PORT_RATE_LIM_SET;
+	tpm_ioctl_pp_oper->pp_sched_egr_port_rate_lim.gmac_idx		= gmac_idx;
+	tpm_ioctl_pp_oper->pp_sched_egr_port_rate_lim.tcont_id		= tcont_id;
+	tpm_ioctl_pp_oper->pp_sched_egr_port_rate_lim.rate_lim_val	= rate_lim_val;
+	tpm_ioctl_pp_oper->pp_sched_egr_port_rate_lim.bucket_size	= bucket_size;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_filter_rule_add()
+*
+* DESCRIPTION: This API adds a filter rule
+*
+* INPUTS:
+*          match_key      - See previous definition.
+*          frwd	     - defines packet forward, to drop or allow.
+*
+* OUTPUTS:
+*	rule_id      - See previous definition.  Here it's the pseudo output.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_add_bounce(
+	struct tpm_pkt_key_t		*match_key,
+	enum tpm_filter_frwd_mode_t	frwd,
+	unsigned int			*rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_FILTER_ADD;
+	tpm_ioctl_acl_rule->filter_add_para.frwd	= frwd;
+	memcpy(&(tpm_ioctl_acl_rule->filter_add_para.match_key),
+		(void *)match_key,
+		sizeof(tpm_ioctl_acl_rule->filter_add_para.match_key));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del_bounce()
+*
+* DESCRIPTION: This API deletes a filter rule
+*
+* INPUTS:
+*	match_key	- Key of the rule to delete.
+*	rule_id	- rule_id of the rule to delete, will be used when Key is NULL.
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del_bounce(
+	struct tpm_pkt_key_t	*match_key,
+	unsigned int		rule_id)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_FILTER_DEL;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->filter_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->filter_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_filter_rule_del_all_bounce()
+*
+* DESCRIPTION: This API deletes all filter rule
+*
+* INPUTS:
+*
+* OUTPUTS:
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_del_all_bounce(void)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_FILTER_DEL_ALL;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+
+/*******************************************************************************
+* mv_tpm_filter_rule_cntr_get_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API,
+*	passes parameters to user space to get an filter  hit counter. there are two ways to identical a API rule,
+*                         key value that were used to create the rule, or the rule_id that returned
+*                         from API adding call.
+*
+* INPUTS:
+*	match_key	- Key of the rule.
+*	rule_id	- rule_id of the rule, will be used when Key is NULL.
+*
+* OUTPUTS:
+*	cntr
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_rule_cntr_get_bounce(
+	struct tpm_pkt_key_t *match_key,
+	unsigned int rule_id,
+	unsigned int *cntr)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_FILTER_CNTR_GET;
+	if (NULL != match_key) {
+		memcpy(&(tpm_ioctl_acl_rule->filter_add_para.match_key),
+			(void *)match_key,
+			sizeof(tpm_ioctl_acl_rule->filter_add_para.match_key));
+	}
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_filter_def_rule_cntr_get_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to gets an filter default rule hit counter.
+*
+* INPUTS:
+*	rule_type		-  rule type value of this filter
+*	field_bm		-  field combination of this filter
+*	vlan_num		-  vlan number as part of the field
+*
+* OUTPUTS:
+*	cntr		-  Here it's the pseudo output.
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_filter_def_rule_cntr_get_bounce(
+	unsigned char			rule_type,
+	enum tpm_field_match_t		field_bm,
+	enum tpm_vlan_num_enum_t	vlan_num,
+	unsigned int			*cntr)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd					= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd					= TPM_IOCTL_ACL_FILTER_DEF_CNTR_GET;
+	tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.rule_type	= rule_type;
+	tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.field_bm	= field_bm;
+	tpm_ioctl_acl_rule->filter_def_rule_cntr_get_para.vlan_num	= vlan_num;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_mtm_add_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to add a MAC to port, to make it Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be added
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_add_bounce(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MTM_ADD;
+	tpm_ioctl_acl_rule->mtm_add_para.port		= port;
+	memcpy(&(tpm_ioctl_acl_rule->mtm_add_para.mac), (void *)mac, sizeof(tpm_ioctl_acl_rule->mtm_add_para.mac));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_mtm_del_bounce()
+*
+* DESCRIPTION: MV_TPM_SFS_2_IOCTL API, passes parameters to user space to removes a MAC from port, to make it not Mac-To-Me.
+*
+* INPUTS:
+*	port		-  PP port
+*	mac		-  mac need to be removed
+*
+* OUTPUTS:
+*	NONE
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_mtm_del_bounce(
+	enum tpm_gmacs_enum_t		port,
+	unsigned char			*mac)
+{
+	struct tpm_ioctl_acl_rule_t	*tpm_ioctl_acl_rule = &tpm_sfs_2_ioctl_command.tpm_ioctl_acl_rule;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_ACL_RULE_SECTION;
+	tpm_ioctl_acl_rule->cmd			= TPM_IOCTL_ACL_MTM_DEL;
+	tpm_ioctl_acl_rule->mtm_add_para.port		= port;
+	memcpy(&(tpm_ioctl_acl_rule->mtm_add_para.mac), (void *)mac, sizeof(tpm_ioctl_acl_rule->mtm_add_para.mac));
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+#endif
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+#define _mv_tpm_exact_match_rule_add		mv_tpm_exact_match_rule_add_bounce
+#define _mv_tpm_exact_match_rule_del		mv_tpm_exact_match_rule_del_bounce
+#define _mv_tpm_exact_match_rule_del_all	mv_tpm_exact_match_rule_del_all_bounce
+#define _mv_tpm_exact_match_rule_cntr_get	mv_tpm_exact_match_rule_cntr_get_bounce
+#define _mv_tpm_exact_match_except_rule_add	mv_tpm_exact_match_except_rule_add_bounce
+#define _mv_tpm_exact_match_except_rule_del	mv_tpm_exact_match_except_rule_del_bounce
+#define _mv_tpm_exact_match_except_rule_del_all	mv_tpm_exact_match_except_rule_del_all_bounce
+#define _mv_tpm_exact_match_except_rule_cntr_get	mv_tpm_exact_match_except_rule_cntr_get_bounce
+#define _mv_tpm_gen_cls_rule_add		mv_tpm_gen_cls_rule_add_bounce
+#define _mv_tpm_gen_cls_rule_del		mv_tpm_gen_cls_rule_del_bounce
+#define _mv_tpm_gen_cls_rule_del_all		mv_tpm_gen_cls_rule_del_all_bounce
+#define _mv_tpm_gen_cls_rule_cntr_get		mv_tpm_gen_cls_rule_cntr_get_bounce
+#define _mv_tpm_mc_flow_add			mv_tpm_mc_flow_add_bounce
+#define _mv_tpm_mc_flow_del			mv_tpm_mc_flow_del_bounce
+#define _mv_tpm_mc_flow_del_all			mv_tpm_mc_flow_del_all_bounce
+#define _mv_tpm_cm_rule_add			mv_tpm_cm_rule_add_bounce
+#define _mv_tpm_cm_rule_del			mv_tpm_cm_rule_del_bounce
+#define _mv_tpm_cm_rule_del_all			mv_tpm_cm_rule_del_all_bounce
+#define _mv_tpm_qos_table_entry_set		mv_tpm_qos_table_entry_set_bounce
+#define _mv_tpm_qos_table_set			mv_tpm_qos_table_set_bounce
+#define _mv_tpm_plcr_add			mv_tpm_plcr_add_bounce
+#define _mv_tpm_plcr_del			mv_tpm_plcr_del_bounce
+#define _mv_tpm_plcr_clear			mv_tpm_plcr_clear_bounce
+#define _mv_tpm_sched_egr_mtu_set		mv_tpm_sched_egr_mtu_set_bounce
+#define _mv_tpm_sched_egr_queue_mode_set	mv_tpm_sched_egr_queue_mode_set_bounce
+#define _mv_tpm_sched_egr_queue_rate_lim_set	mv_tpm_sched_egr_queue_rate_lim_set_bounce
+#define _mv_tpm_sched_egr_port_rate_lim_set	mv_tpm_sched_egr_port_rate_lim_set_bounce
+#define _mv_tpm_filter_rule_add			mv_tpm_filter_rule_add_bounce
+#define _mv_tpm_filter_rule_del			mv_tpm_filter_rule_del_bounce
+#define _mv_tpm_filter_rule_del_all		mv_tpm_filter_rule_del_all_bounce
+#define _mv_tpm_filter_rule_cntr_get		mv_tpm_filter_rule_cntr_get_bounce
+#define _mv_tpm_filter_def_rule_cntr_get	mv_tpm_filter_def_rule_cntr_get_bounce
+#define _mv_tpm_mtm_add				mv_tpm_mtm_add_bounce
+#define _mv_tpm_mtm_del				mv_tpm_mtm_del_bounce
+#else
+#define _mv_tpm_exact_match_rule_add		mv_tpm_exact_match_rule_add
+#define _mv_tpm_exact_match_rule_del		mv_tpm_exact_match_rule_del
+#define _mv_tpm_exact_match_rule_del_all	mv_tpm_exact_match_rule_del_all
+#define _mv_tpm_exact_match_rule_cntr_get	mv_tpm_exact_match_rule_cntr_get
+#define _mv_tpm_exact_match_except_rule_add	mv_tpm_exact_match_except_rule_add
+#define _mv_tpm_exact_match_except_rule_del	mv_tpm_exact_match_except_rule_del
+#define _mv_tpm_exact_match_except_rule_del_all	mv_tpm_exact_match_except_rule_del_all
+#define _mv_tpm_exact_match_except_rule_cntr_get	mv_tpm_exact_match_except_rule_cntr_get
+#define _mv_tpm_gen_cls_rule_add		mv_tpm_gen_cls_rule_add
+#define _mv_tpm_gen_cls_rule_del		mv_tpm_gen_cls_rule_del
+#define _mv_tpm_gen_cls_rule_del_all		mv_tpm_gen_cls_rule_del_all
+#define _mv_tpm_gen_cls_rule_cntr_get		mv_tpm_gen_cls_rule_cntr_get
+#define _mv_tpm_mc_flow_add			mv_tpm_mc_flow_add
+#define _mv_tpm_mc_flow_del			mv_tpm_mc_flow_del
+#define _mv_tpm_mc_flow_del_all			mv_tpm_mc_flow_del_all
+#define _mv_tpm_cm_rule_add			mv_tpm_cm_rule_add
+#define _mv_tpm_cm_rule_del			mv_tpm_cm_rule_del
+#define _mv_tpm_cm_rule_del_all			mv_tpm_cm_rule_del_all
+#define _mv_tpm_qos_table_entry_set		mv_tpm_qos_table_entry_set
+#define _mv_tpm_qos_table_set			mv_tpm_qos_table_set
+#define _mv_tpm_plcr_add			mv_tpm_plcr_add
+#define _mv_tpm_plcr_del			mv_tpm_plcr_del
+#define _mv_tpm_plcr_clear			mv_tpm_plcr_clear
+#define _mv_tpm_sched_egr_mtu_set		mv_tpm_sched_egr_mtu_set
+#define _mv_tpm_sched_egr_queue_mode_set	mv_tpm_sched_egr_queue_mode_set
+#define _mv_tpm_sched_egr_queue_rate_lim_set	mv_tpm_sched_egr_queue_rate_lim_set
+#define _mv_tpm_sched_egr_port_rate_lim_set	mv_tpm_sched_egr_port_rate_lim_set
+#define _mv_tpm_filter_rule_add			mv_tpm_filter_rule_add
+#define _mv_tpm_filter_rule_del			mv_tpm_filter_rule_del
+#define _mv_tpm_filter_rule_del_all		mv_tpm_filter_rule_del_all
+#define _mv_tpm_filter_rule_cntr_get		mv_tpm_filter_rule_cntr_get
+#define _mv_tpm_filter_def_rule_cntr_get	mv_tpm_filter_def_rule_cntr_get
+#define _mv_tpm_mtm_add				mv_tpm_mtm_add
+#define _mv_tpm_mtm_del				mv_tpm_mtm_del
+#endif
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+int tpm_sfs_help_mac_format_print(char *buf, int cur_off)
+{
+	int off = cur_off;
+
+	off += sprintf(buf+off, "\tMAC address      (str) aa:bb:cc:dd:ee:ff  where each part is hexadecimal in range 0..FF\n");
+	return off;
+}
+
+
+int tpm_sfs_help_ipvx_format_print(char *buf, int cur_off)
+{
+	int off = cur_off;
+
+	off += sprintf(buf+off,
+		"\tIPv4 address   (str) w.x.y.z  where each part is decimal value in range 0..255\n");
+	off += sprintf(buf+off,
+		"\tIPv6 address   (str) aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh  each part is hexadecimal (0..FFFF)\n");
+	off += sprintf(buf+off, "\t\tprefix         (str) aaaa:bbbb:cccc:dddd:0000:0000:0000:0000\n");
+	off += sprintf(buf+off, "\t\tsuffix         (str) 0000:0000:0000:0000:eeee:ffff:gggg:hhhh\n");
+	return off;
+}
+
+int tpm_sfs_help_frwd_rule_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off,
+		"echo [rule_name] [frwd_idx] [pp_port] [pon_tx] [queue] [logic_port_flag] [logic_port] > frwd_rule_set");
+	off += sprintf(buf+off, " - set a forwarding rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off,
+		"\tfrwd_idx            (dec)frwd index in frwd array with name rule_name, range 0-%d\n",
+		(TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\tpp_port             (hex) see below\n");
+	off += sprintf(buf+off, "\t\t%.18s%#.4X\n", tpm_utils_pp_port_str_get(TPM_PP_DROP), TPM_PP_DROP);
+	off += sprintf(buf+off, "\t\t%.18s%#.4X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC0), TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\t%.18s%#.4X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC1), TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\t%.18s%#.4X\n", tpm_utils_pp_port_str_get(TPM_PP_PMAC), TPM_PP_PMAC);
+	off += sprintf(buf+off, "\t\t%.18s%#.4X\n", tpm_utils_pp_port_str_get(TPM_PP_CPU), TPM_PP_CPU);
+	off += sprintf(buf+off, "\tpon_tx              (dec)T-CONT number, irrelevant for non-PON port\n");
+	off += sprintf(buf+off, "\tqueue               (dec)Queue number\n");
+	off += sprintf(buf+off, "\tlogic_port_flag     (dec)0: logic port is invalid; 1: logic port is valid.\n");
+	off += sprintf(buf+off, "\tlogic_port          (hex)GEM/UNI port, valid when logic_port_flag is 1.\n");
+
+	return off;
+}
+int tpm_sfs_help_plcr_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [token_unit] [color_mode] [cir] [cbs] [ebs]  > plcr_add    - add a policer\n");
+	off += sprintf(buf+off, "\ttoken_unit          (dec)token unit type, 0: byte, 1:packet number\n");
+	off += sprintf(buf+off, "\tcolor_mode          (dec)color aware mode, 0:blind mode, 1:aware mode\n");
+	off += sprintf(buf+off, "\tcir                 (dec)commit information rate, 0:no limit, uints: ");
+	off += sprintf(buf+off, "kbps for byte token type, pps for packet token type\n");
+	off += sprintf(buf+off, "\tcbs                 (dec)commit burst size, 0: to use default value\n");
+	off += sprintf(buf+off, "\tebs                 (dec)excess burst size, 0: to use default value\n\n");
+	off += sprintf(buf+off, "echo [policer_id]                             > plcr_del    - delete a policer\n");
+	off += sprintf(buf+off,
+		"\tpolicer_id          (dec)policer ID returned while adding policer, ranging from 1 to %d\n\n",
+		MV_PP2_PLCR_NUM - 1);
+	off += sprintf(buf+off, "echo 1                                        > plcr_clear  - clear all policers\n\n");
+
+	return off;
+}
+int tpm_sfs_help_mtm_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [port] [mac]  > mtm_add   - adds a MAC to port, to make it Mac-To-Me\n");
+	off += sprintf(buf+off, "echo [port] [mac]  > mtm_del   - removes a MAC from port, to make it not Mac-To-Me\n");
+	off += sprintf(buf+off, "\tport          (dec)port number\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_gmac_enum_str_get(TPM_ENUM_GMAC_0), TPM_ENUM_GMAC_0);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_gmac_enum_str_get(TPM_ENUM_GMAC_1), TPM_ENUM_GMAC_1);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_gmac_enum_str_get(TPM_ENUM_PMAC), TPM_ENUM_PMAC);
+	off += tpm_sfs_help_mac_format_print(buf, off);
+
+	return off;
+}
+
+/* Rate limit help */
+int tpm_sys_help_tx_sched_cfg(char *buf)
+{
+	int off = 0;
+
+	/* Config Tx port schedule MTU */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [gmac_id] [tcont_id] [mtu] > tx_port_sched_mtu_cfg - Config Tx port sched MTU\n");
+	off += sprintf(buf+off, "\tgmac_id         (dec)GMAC index\n");
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC0_IDX), TPM_GMAC0_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC1_IDX), TPM_GMAC1_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_PMAC_IDX), TPM_PMAC_IDX);
+	off += sprintf(buf+off, "\ttcont_id        (dec)Tcont, range 0 - 15(Only for GPON PMAC, other set 0)\n");
+	off += sprintf(buf+off,
+		"\tmtu             (dec)MTU, unit byte, the minum number of tokens required to allow packet TX\n");
+	off += sprintf(buf+off, "\t\t The maxnum value of MTU is 65536B, if more than 65536, will be set to 65536\n");
+
+	/* Config Tx queue mode */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [gmac_id] [tcont_id] [queue_id] [mode] [wrr_weight] > ");
+	off += sprintf(buf+off, "tx_queue_mode_cfg - Config Tx shceduling queue mode\n");
+	off += sprintf(buf+off, "\tgmac_id         (dec)GMAC index\n");
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC0_IDX), TPM_GMAC0_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC1_IDX), TPM_GMAC1_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_PMAC_IDX), TPM_PMAC_IDX);
+	off += sprintf(buf+off, "\ttcont_id        (dec)Tcont, range 0 - 15(Only for GPON PMAC, other set 0)\n");
+	off += sprintf(buf+off, "\tqueue_id        (dec)Queue, range 0 - 7\n");
+	off += sprintf(buf+off, "\tmode            (dec)Schedule mode, 0 - Strict Priority; 1 - WRR\n");
+	off += sprintf(buf+off, "\twrr_weight      (dec)Queue, weight if mode is WRR, range 0 - 255\n");
+
+	/* Config Tx queue rate limit */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [gmac_id] [tcont_id] [queue_id] [rate] [bukcet_size]      > tx_queue_rate_limit");
+	off += sprintf(buf+off, "      -  Config Tx queue rate limit\n");
+	off += sprintf(buf+off, "\tgmac_id         (dec)GMAC index\n");
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC0_IDX), TPM_GMAC0_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC1_IDX), TPM_GMAC1_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_PMAC_IDX), TPM_PMAC_IDX);
+	off += sprintf(buf+off, "\ttcont_id        (dec)Tcont, range 0 - 15(Only for GPON PMAC, other set 0)\n");
+	off += sprintf(buf+off, "\tqueue_id        (dec)Queue, range 0 - 7\n");
+	off += sprintf(buf+off, "\trate            (dec)rate limit, unit: kbps\n");
+	off += sprintf(buf+off, "\tbukcet_size     (dec)Bucket size, no less than 64B, unit: byte\n");
+
+	/* Config Tx port rate limit */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [gmac_id] [tcont_id] [rate] [bukcet_size]                > tx_port_rate_limit");
+	off += sprintf(buf+off, "      -  Config Tx port rate limit\n");
+	off += sprintf(buf+off, "\tgmac_id         (dec)GMAC index\n");
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC0_IDX), TPM_GMAC0_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_GMAC1_IDX), TPM_GMAC1_IDX);
+	off += sprintf(buf+off, "\t\t%-8s%d\n", tpm_utils_gmac_idx_str_get(TPM_PMAC_IDX), TPM_PMAC_IDX);
+	off += sprintf(buf+off, "\ttcont_id        (dec)Tcont, range 0 - 15(Only for GPON PMAC, other set 0)\n");
+	off += sprintf(buf+off, "\trate            (dec)rate limit, unit: kbps\n");
+	off += sprintf(buf+off, "\tbukcet_size     (dec)Bucket size, no less than 64B, unit: byte\n");
+
+	return off;
+}
+
+int tpm_sfs_help_api_rule_get_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]  > xxx_rule_get       - dump a exact except api rule\n");
+	off += sprintf(buf+off, "echo [rule_idx]  > cls_rule_get                - dump a CLS api rule\n");
+	off += sprintf(buf+off, "echo [rule_idx]  > mc_rule_get                 - dump a CLS api rule\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+
+	return off;
+}
+int tpm_sfs_help_cls_rule_get_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]  > cls_rule_get                - dump a CLS api rule\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+
+	return off;
+}
+int tpm_sfs_help_filter_rule_get_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]  > filter_rule_get                - dump a filter api rule\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+
+	return off;
+}
+int tpm_sfs_help_exact_except_rule_get_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]  > exact_except_rule_get       - dump a exact except api rule\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+
+	return off;
+}
+int tpm_sfs_help_exact_rule_get_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]  > exact_rule_get       - dump a exact match api rule\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_no_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_no_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_idx]            > no_rule_add_cls                - delete CLS rule from hardware\n");
+	off += sprintf(buf+off, "echo [rule_idx]            > no_rule_add_exact_except       - delete exact_except rule from hardware\n");
+	off += sprintf(buf+off, "echo [rule_idx]            > no_rule_add_exact              - delete exact_match rule from hardware\n");
+	off += sprintf(buf+off, "echo [rule_idx]            > no_rule_add_filter             - delete filter rule from hardware\n");
+	off += sprintf(buf+off, "echo                       > no_rule_add_cls_all            - delete all CLS rules from hardware\n");
+	off += sprintf(buf+off, "echo                       > no_rule_add_filter_all         - delete all filter rules from hardware\n");
+	off += sprintf(buf+off, "echo                       > no_rule_add_exact_except_all   - delete all exact_except rules from hardware\n");
+	off += sprintf(buf+off, "echo                       > no_rule_add_exact_all          - delete all exact_match rules from hardware\n");
+	off += sprintf(buf+off, "echo [rule_idx]            > no_rule_add_mc                 - delete multicast rule from hardware\n");
+	off += sprintf(buf+off, "echo 1                     > no_rule_add_mc_all             - delete all multicast rules from hardware\n");
+	off += sprintf(buf+off, "\trule_idx         (dec)Rule Id returned from the create call\n");
+	off += sprintf(buf+off, "echo [uni_port] [rule_num] > no_rule_add_cnm                - delete CnM rule from hardware\n");
+	off += sprintf(buf+off, "echo [uni_port_bm]         > no_rule_add_cnm_all            - delete all CnM rules of UNI port in port_bm from hardware\n");
+	off += sprintf(buf+off, "\tuni_port_bm      (hex)uni port bitmap\n");
+
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [port_type] [port_id] [rule_type] [parse_rule_bm] [key_name] > no_rule_add_cls_key            - delete CLS rule with Key from hardware\n");
+	off += sprintf(buf+off, "echo [port_type] [port_id] [rule_type] [parse_rule_bm] [key_name] > no_rule_add_filter_key         - delete filter rule with Key from hardware\n");
+	off += sprintf(buf+off, "echo [port_type] [port_id] [parse_rule_bm] [key_name]          > no_rule_add_exact_except_key   - delete exact_except rule with Key from hardware\n");
+	off += sprintf(buf+off, "echo [ip_version] [key_name]                                   > no_rule_add_exact_key          - delete exact_match rule with Key from hardware\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  sfs_help_parse_rule_bm_print - prints the parse_rule_bm fields
+**
+*******************************************************************************/
+int tpm_sfs_help_parse_rule_bm_print(char *buf, int cur_off)
+{
+	int off = cur_off;
+
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_ETH_DST), TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_ETH_SRC), TPM_MATCH_ETH_SRC);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_VID_OUTER), TPM_MATCH_VID_OUTER);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_PBITS_OUTER), TPM_MATCH_PBITS_OUTER);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_VID_INNER), TPM_MATCH_VID_INNER);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_PBITS_INNER), TPM_MATCH_PBITS_INNER);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_ETH_TYPE), TPM_MATCH_ETH_TYPE);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_PPPOE_PROTO), TPM_MATCH_PPPOE_PROTO);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_PPPOE_SES), TPM_MATCH_PPPOE_SES);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IPV4_PKT), TPM_MATCH_IPV4_PKT);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IPV6_PKT), TPM_MATCH_IPV6_PKT);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IP_SRC), TPM_MATCH_IP_SRC);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IP_DST), TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IP_DSCP), TPM_MATCH_IP_DSCP);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IPV6_FLBL), TPM_MATCH_IPV6_FLBL);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IP_PROTO), TPM_MATCH_IP_PROTO);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IP_VERSION), TPM_MATCH_IP_VERSION);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_L4_SRC), TPM_MATCH_L4_SRC);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_L4_DST), TPM_MATCH_L4_DST);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_ARP_TRGT_IP_ADDR), TPM_MATCH_ARP_TRGT_IP_ADDR);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IPV6_PREF), TPM_MATCH_IPV6_PREF);
+	off += sprintf(buf+off, "\t\t%-19s%#.6X\n", tpm_utils_field_match_str_get(TPM_MATCH_IPV6_SUFF), TPM_MATCH_IPV6_SUFF);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_mc_rule_bm_print - prints the mc match fields bm
+**
+*******************************************************************************/
+int tpm_sfs_help_mc_match_bm_print(char *buf, int cur_off)
+{
+	int off = cur_off;
+
+	/* MAC based section */
+	off += sprintf(buf+off, "\n\tIPV4 and NON-IP MC MAC Base section:\n");
+	off += sprintf(buf+off, "\t\t[VID+DMAC+SMAC]                 %#.5X\n", TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST | TPM_MATCH_ETH_SRC);
+	off += sprintf(buf+off, "\t\t[VID+DMAC]                      %#.5X\n", TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t[Tag+DMAC]                      %#.5X\n", TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t[Untag+DMAC]                    %#.5X\n", TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\n\tIPV6 MC MAC Base section:\n");
+	off += sprintf(buf+off, "\t\t[IPV6+VID+DMAC+SMAC]            %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST | TPM_MATCH_ETH_SRC);
+	off += sprintf(buf+off, "\t\t[IPV6+VID+DMAC]                 %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Tag+DMAC]                 %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Untag+DMAC]               %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\n\tMC US MAC Base section:\n");
+	off += sprintf(buf+off, "\t\t[VID+DMAC]                      %#.5X\n", TPM_MATCH_VID_OUTER | TPM_MATCH_ETH_DST);
+	off += sprintf(buf+off, "\t\t[DMAC]                          %#.5X\n", TPM_MATCH_ETH_DST);
+
+	/* IP based section */
+	off += sprintf(buf+off, "\n\tMC IP Base section:\n");
+#ifdef CONFIG_MV_ETH_PP2_1 /* Z1 does not support PPPoE proto check */
+	off += sprintf(buf+off, "\t\t[IPV4+VID+PPoE+SIP+DIP]         %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+VID+PPoE+DIP]             %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+Tag+PPoE+DIP]             %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+Untag+PPoE+DIP]           %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+VID+PPoE+SIP+DIP]         %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+VID+PPoE+DIP]             %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Tag+PPoE+DIP]             %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Untag+PPoE+DIP]           %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_PPPOE_PROTO | TPM_MATCH_IP_DST);
+#endif
+	off += sprintf(buf+off, "\t\t[IPV4+VID+SIP+DIP]              %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+VID+DIP]                  %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+Tag+DIP]                  %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV4+Untag+DIP]                %#.5X\n", TPM_MATCH_IPV4_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+VID+SIP+DIP]              %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_SRC | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+VID+DIP]                  %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Tag+DIP]                  %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	off += sprintf(buf+off, "\t\t[IPV6+Untag+DIP]                %#.5X\n", TPM_MATCH_IPV6_PKT | TPM_MATCH_VID_OUTER | TPM_MATCH_IP_DST);
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_cls_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_cls_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [rule_type] [parse_rule_bm] [key_name] [frwd_name] [num_dest] [color] [policer_id] [qos_name] [mod_name] > cls_rule_add\n");
+	off += sprintf(buf+off, "Creates a new CLS processing ACL\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_PP_PORT_BM), TPM_CLASS_PP_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_SWITCH_PORT_BM), TPM_CLASS_SWITCH_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_VIRT_PORT), TPM_CLASS_VIRT_PORT);
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/GEM port ID\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC0), TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC1), TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_PMAC), TPM_PP_PMAC);
+	off += sprintf(buf+off, "\trule_type                  (dec)valid from 0 to 16, rules with smaller rule_type gets higher priority, rule_type and caps in it should be set in TPM INIT\n");
+	off += sprintf(buf+off, "\tparse_rule_bm              (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tkey_name                   (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\tfrwd_name                  (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
+	off += sprintf(buf+off, "\tnum_dest                   (dec)number of forward destination, 1-8\n");
+	off += sprintf(buf+off, "\tcolor                      (dec)0 for Green, 1 for Yellow\n");
+	off += sprintf(buf+off, "\tpolicer_id                 (hex)policer_id, valid from 0 to 15, empty value: 0xff\n");
+	off += sprintf(buf+off, "\tqos_name                   (str)Name of qos\n");
+	off += sprintf(buf+off, "\tmod_name                   (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
+
+	return off;
+}
+
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_filter_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_filter_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [rule_type] [parse_rule_bm] [key_name] [frwd_mode] > filter_rule_add\n");
+	off += sprintf(buf+off, "Creates a new CLS processing ACL\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_PP_PORT_BM), TPM_CLASS_PP_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_SWITCH_PORT_BM), TPM_CLASS_SWITCH_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_VIRT_PORT), TPM_CLASS_VIRT_PORT);
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/GEM port ID\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC0), TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC1), TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_PMAC), TPM_PP_PMAC);
+	off += sprintf(buf+off, "\trule_type                  (dec)valid from 0 to 16, rules with smaller rule_type gets higher priority, rule_type and caps in it should be set in TPM INIT\n");
+	off += sprintf(buf+off, "\tparse_rule_bm              (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tkey_name                   (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\tfrwd_mode                  (dec)filter forward action, 0: drop; 1: no drop\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_exact_except_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sys_help_exact_except_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [parse_rule_bm] [key_name] [frwd_name] [color] [policer_id] [qos_name] > exact_except_rule_add\n");
+	off += sprintf(buf+off, "Creates a new exact match exception ACL\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_PP_PORT_BM), TPM_CLASS_PP_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_SWITCH_PORT_BM), TPM_CLASS_SWITCH_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_VIRT_PORT), TPM_CLASS_VIRT_PORT);
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/GEM port ID\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC0), TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC1), TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_PMAC), TPM_PP_PMAC);
+	off += sprintf(buf+off, "\tparse_rule_bm   (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tkey_name        (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\tfrwd_name       (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
+	off += sprintf(buf+off, "\tcolor           (dec)0 for Green, 1 for Yellow\n");
+	off += sprintf(buf+off, "\tpolicer_id      (hex)policer_id, valid from 0 to 15, empty value: 0xff\n");
+	off += sprintf(buf+off, "\tqos_name        (str)Name of qos, so far, not supported, use %s\n", qos_empty_name);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_exact_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sys_help_exact_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [ip_version] [key_name] [frwd_name] [mod_name] [color] [policer_id] > exact_rule_add\n");
+	off += sprintf(buf+off, "Creates a new exact exception to match IPv4/6 5T\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_PP_PORT_BM), TPM_CLASS_PP_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_SWITCH_PORT_BM), TPM_CLASS_SWITCH_PORT_BM);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_port_class_str_get(TPM_CLASS_VIRT_PORT), TPM_CLASS_VIRT_PORT);
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/GEM port ID\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC0), TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_GMAC1), TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_pp_port_str_get(TPM_PP_PMAC), TPM_PP_PMAC);
+	off += sprintf(buf+off, "\tip_version      (dec)IP version of the packet: 4 for IPv4; 6 for IPv6\n");
+	off += sprintf(buf+off, "\tkey_name        (str)Name of IPvX key data which has been defined by user\n");
+	off += sprintf(buf+off, "\tfrwd_name       (str)Name of pkt forwarding data which has been defined by user\n");
+	off += sprintf(buf+off, "\tmod_name        (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
+	off += sprintf(buf+off, "\tcolor           (dec)0 for Green, 1 for Yellow\n");
+	off += sprintf(buf+off, "\tpolicer_id      (hex)policer_id, valid from 0 to 15, empty value: 0xff\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_cnm_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_cnm_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [uni_port] [rule_num] [field_op_name] [key_name] [queue] [pbit] > cnm_rule_add\n");
+	off += sprintf(buf+off, "Creates a new CnM rule\n");
+
+	off += sprintf(buf+off, "\tuni_port        (dec)UNI port ID\n");
+	off += sprintf(buf+off, "\trule_num        (dec)0-7, CnM rule number in this UNI port\n");
+	off += sprintf(buf+off, "\tkey_name        (str)Name of pkt key data which has been defined by user\n");
+	off += sprintf(buf+off, "\tfield_op_name   (str)Name of CnM field OP data which has been defined by user\n");
+	off += sprintf(buf+off, "\tqueue           (dec)target queue number of rule\n");
+	off += sprintf(buf+off, "\tPbit            (hex)Pbit of this rule, make (0x10 | value) to set value\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_cls_rule_cntr_get - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_cls_rule_cntr_get(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [rule_type] [parse_rule_bm] [key_name] [rule_id] > cls_rule_cntr_get\n");
+	off += sprintf(buf+off, "Gets hit counter of a CLS processing ACL rule\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/VIR port ID\n");
+	off += sprintf(buf+off, "\trule_type                  (dec)valid from 0 to 16, rules with smaller rule_type gets higher priority, rule_type and caps in it should be set in TPM INIT\n");
+	off += sprintf(buf+off, "\tparse_rule_bm              (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += sprintf(buf+off, "\tkey_name                   (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\trule_id                    (dec)rule_id that returned by adding API call, 0 means use key value to identical rule\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_filter_rule_cntr_get - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_filter_rule_cntr_get(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [rule_type] [parse_rule_bm] [key_name] [rule_id] > filter_rule_cntr_get\n");
+	off += sprintf(buf+off, "Gets hit counter of a Filter rule\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/VIR port ID\n");
+	off += sprintf(buf+off, "\trule_type                  (dec)valid from 0 to 16, rules with smaller rule_type gets higher priority, rule_type and caps in it should be set in TPM INIT\n");
+	off += sprintf(buf+off, "\tparse_rule_bm              (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += sprintf(buf+off, "\tkey_name                   (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\trule_id                    (dec)rule_id that returned by adding API call, 0 means use key value to identical rule\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_filter_def_rule_cntr_get - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_filter_def_rule_cntr_get(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_id] > filter_def_rule_cntr_get\n");
+	off += sprintf(buf+off, "Gets hit counter of a Filter default rule\n");
+	off += sprintf(buf+off, "\trule_type(dec): from 0 to 15, filters in smaller rule_type gets higher priority\n");
+	off += sprintf(buf+off, "\tfield_bm(hex): matching field bitmap, see capability help\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tvlan_num(dec):\n");
+	off += sprintf(buf+off, "\t    %d: TPM_NO_VLAN\n",		TPM_NO_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_SINGLE_VLAN\n",		TPM_SINGLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_DOUBLE_VLAN\n",		TPM_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_TRIPLE_VLAN\n",		TPM_TRIPLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_NOT_DOUBLE_VLAN\n",	TPM_NOT_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_ANY_VLAN\n",		TPM_ANY_VLAN);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_mc_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_mc_rule_add(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_port_type] [src_port_id] [match_bm] [key_name] [frwd_name] [num_dest] [color] [mod_name] > mc_rule_add\n");
+	off += sprintf(buf+off, "Creates a new or update an existed IPv4/6 multicast rule\n");
+
+	off += sprintf(buf+off, "\tsrc_port_type              (hex)src port type\n");
+	off += sprintf(buf+off, "\t\tTPM_CLASS_PP_PORT_BM     %#.4X\n", TPM_CLASS_PP_PORT_BM);
+	off += sprintf(buf+off, "\t\tTPM_CLASS_SWITCH_PORT_BM %#.4X\n", TPM_CLASS_SWITCH_PORT_BM);
+	off += sprintf(buf+off, "\t\tTPM_CLASS_GEM_PORT       %#.4X\n", TPM_CLASS_VIRT_PORT);
+	off += sprintf(buf+off, "\tsrc_port_id                (hex)PHY/UNI/GEM port ID\n");
+	off += sprintf(buf+off, "\t\tTPM_PP_GMAC0             %#.4X\n", TPM_PP_GMAC0);
+	off += sprintf(buf+off, "\t\tTPM_PP_GMAC1             %#.4X\n", TPM_PP_GMAC1);
+	off += sprintf(buf+off, "\t\tTPM_PP_PON               %#.4X\n", TPM_PP_PMAC);
+	off += sprintf(buf+off, "\tmatch_bm                   (hex)Bitmap comibination of multicast:");
+	off += tpm_sfs_help_mc_match_bm_print(buf, off);
+	off += sprintf(buf+off, "\tkey_name                   (str)Name of Multicast key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\tfrwd_name                  (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
+	off += sprintf(buf+off, "\tnum_dest                   (dec)number of MC destination, range 1-8\n");
+	off += sprintf(buf+off, "\tcolor                      (dec)0 for Green, 1 for Yellow\n");
+	off += sprintf(buf+off, "\tmod_name                   (str)Name of pkt modification data which has been defined by user [or mod_empty]\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_exact_except_rule_cntr_get - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sys_help_exact_except_rule_cntr_get(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [src_pp_port_bm] [src_port_id] [parse_rule_bm] [key_name] [rule_id] > exact_except_rule_cntr_get\n");
+	off += sprintf(buf+off, "Gets hit counter of a exact match exception ACL\n");
+
+	off += sprintf(buf+off, "\tsrc_pp_port_bm  (hex)physical port bm\n");
+	off += sprintf(buf+off, "\tsrc_port_id     (hex)UNI/VIR port ID, To specify IT, set to 0x1000|value\n");
+	off += sprintf(buf+off, "\tparse_rule_bm   (hex)Bitmap containing the significant flags for parsing fields of the packet:\n");
+	off += sprintf(buf+off, "\tkey_name        (str)Name of packet key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\trule_id         (dec)rule_id that returned by adding API call, 0 means use key value to identical rule\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_exact_rule_cntr_get - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sys_help_exact_rule_cntr_get(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [ip_version] [key_name] [rule_id] > exact_rule_cntr_get\n");
+	off += sprintf(buf+off, "Gets hit counter of a exact exception to match IPv4/6 5T\n");
+
+	off += sprintf(buf+off, "\tip_version      (dec)IP version of the packet: 4 for IPv4; 6 for IPv6\n");
+	off += sprintf(buf+off, "\tkey_name        (str)Name of 5T key data which has been defined by user [or %s]\n", key_empty_name);
+	off += sprintf(buf+off, "\trule_id         (dec)rule_id that returned by adding API call, 0 means use key value to identical rule\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_qos_rule_add - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_qos_tbl_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "there are two ways to configure QOS table:\n");
+	off += sprintf(buf+off, "\t1. set QOS table HW entry directly with qos_tbl_entry_set one by one\n");
+	off += sprintf(buf+off, "\t2. set QOS table with qos_tbl_set\n");
+	off += sprintf(buf+off, "\t\ta. clear QOS table DB with qos_tbl_db_reset\n");
+	off += sprintf(buf+off, "\t\tb. set QOS table DB entry one by one with qos_tbl_entry_db_set\n");
+	off += sprintf(buf+off, "\t\tc. set QOS table HW with qos_tbl_set\n");
+
+	off += sprintf(buf+off, "\necho [qos_table_type] [qos_table_id] [qos_table_entry_id] [frwd_name] [dscp] [pbit] [color] > qos_tbl_entry_set\n");
+	off += sprintf(buf+off, "Creates a QOS table entry\n");
+	off += sprintf(buf+off, "\tqos_table_type        (dec)type of qos table\n");
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_DSCP), TPM_QOS_DSCP);
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_PBIT), TPM_QOS_PBIT);
+	off += sprintf(buf+off, "\tqos_table_id          (dec)64 pbit tables (0-63) and 8 dscp tables (0-7)\n");
+	off += sprintf(buf+off, "\tqos_table_entry_id    (dec)entry number in the qos table, pbit table (0-7), and dscp (0-63)\n");
+	off += sprintf(buf+off, "\tfrwd_name             (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
+	off += sprintf(buf+off, "\tdscp                  (dec)dscp value (0-63)\n");
+	off += sprintf(buf+off, "\tpbit                  (dec)pbit value (0-7)\n");
+	off += sprintf(buf+off, "\tcolor                 (dec)0 for Green, 1 for Yellow\n");
+
+	off += sprintf(buf+off, "\necho 0 > qos_tbl_db_reset\n");
+	off += sprintf(buf+off, "Reset QOS table DB\n");
+
+	off += sprintf(buf+off, "\necho [qos_table_entry_id] [frwd_name] [dscp] [pbit] [color] > qos_tbl_entry_db_set\n");
+	off += sprintf(buf+off, "Set a QOS table DB entry\n");
+	off += sprintf(buf+off, "\tqos_table_entry_id    (dec)entry number in the qos table, pbit table (0-7), and dscp (0-63)\n");
+	off += sprintf(buf+off, "\tfrwd_name             (str)Name of pkt forwarding data which has been defined by user [or frwd_empty]\n");
+	off += sprintf(buf+off, "\tdscp                  (dec)dscp value (0-63)\n");
+	off += sprintf(buf+off, "\tpbit                  (dec)pbit value (0-7)\n");
+	off += sprintf(buf+off, "\tcolor                 (dec)0 for Green, 1 for Yellow\n");
+
+	off += sprintf(buf+off, "\necho [qos_table_type] [qos_table_id] > qos_tbl_set\n");
+	off += sprintf(buf+off, "Creates a QOS table at one time, with the configuration in DB\n");
+	off += sprintf(buf+off, "\tqos_table_type        (dec)type of qos table\n");
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_DSCP), TPM_QOS_DSCP);
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_PBIT), TPM_QOS_PBIT);
+	off += sprintf(buf+off, "\tqos_table_id          (dec)64 pbit tables (0-63) and 8 dscp tables (0-7)\n");
+
+	off += sprintf(buf+off, "\necho [qos_table_type] [qos_table_id] > qos_tbl_get\n");
+	off += sprintf(buf+off, "Get a QOS table from HW\n");
+	off += sprintf(buf+off, "\tqos_table_type        (dec)type of qos table\n");
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_DSCP), TPM_QOS_DSCP);
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_PBIT), TPM_QOS_PBIT);
+	off += sprintf(buf+off, "\tqos_table_id          (dec)64 pbit tables (0-63) and 8 dscp tables (0-7)\n");
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sys_help_qos_key_cfg - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sys_help_qos_key_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\necho [qos_name] [qos_table_type] [qos_table_id] > qos_key_cfg\n");
+	off += sprintf(buf+off, "Creates a QOS key entry\n");
+	off += sprintf(buf+off, "\tqos_name              (str)Name of pkt qos data which has been defined by user\n");
+	off += sprintf(buf+off, "\tqos_table_type        (dec)type of qos table\n");
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_DSCP), TPM_QOS_DSCP);
+	off += sprintf(buf+off, "\t\t%-11s%4d\n", tpm_utils_qos_type_str_get(TPM_QOS_PBIT), TPM_QOS_PBIT);
+	off += sprintf(buf+off, "\tqos_table_id          (dec)64 pbit tables (0-63) and 8 dscp tables (0-7)\n");
+
+	return off;
+}
+
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_l2_key_cfg - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_l2_key_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_name] [ether_type]                     > l2_key_ethertype_rule_set  - set ethertype part of L2 ACL key\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tether_type       (hex)Ethernet type\n");
+	off += sprintf(buf+off, "echo [rule_name]                                  > l2_key_ethertype_rule_get - get ethertype part of L2 ACL key\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [SA] [SA_mask] [DA] [DA_mask]  > l2_key_mac_addr_rule_set - get MAC address part of ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += tpm_sfs_help_mac_format_print(buf, off);
+	off += sprintf(buf+off, "echo [rule_name]                                  > l2_key_mac_addr_rule_get - get MAC address part of ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [vid_out] [pbit_out] [vid_in] [pbit_in] > l2_key_vlan_rule_set - set VLAN part of ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tvid_out          (dec)VID(0-65535), 0x0000->untagged, 0xffff->tagged, 0x1ABC->specific Outer VID=ABC\n");
+	off += sprintf(buf+off, "\tpbit_out         (dec)P-bits(0-7)\n");
+	off += sprintf(buf+off, "\tvid_in           (dec)VID(0-65535), 0x0000->not double-tagged, 0xffff-> double-tagged, 0x1ABC->specific Outer VID=ABC\n");
+	off += sprintf(buf+off, "\tpbit_in          (dec)P-bits(0-7)\n");
+	off += sprintf(buf+off, "echo [rule_name]                                  > l2_key_vlan_rule_get - get VLAN part of ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [session] [protocol_type]      > l2_key_pppoe_rule_set - set PPPoE part of L2 ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tsession          (dec)Session number\n");
+	off += sprintf(buf+off, "\tprotocol_type    (hex)Protocol type\n");
+	off += sprintf(buf+off, "echo [rule_name]                                  > l2_key_pppoe_rule_get - get PPPoE part of L2 ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [array_idx] [field_id] [field_op] > cnm_field_op_set - set field op of CnM rule\n");
+	off += sprintf(buf+off, "\tEach CnM rule could have up to 6 fields:\n");
+	off += sprintf(buf+off, "\tThree of them :no bigger than 2 bytes, operator could be equal, not equal, greater equal or less equal.\n");
+	off += sprintf(buf+off, "\tone of them   :no bigger than 16 bytes, operator could be equal, not equal.\n");
+	off += sprintf(buf+off, "\tone of them   :no bigger than 6 bytes, operator could be equal, not equal.\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tarray_idx        (dec)field index with name rule_name, range 0-%d, must be continuous and starts from 0\n", (TPM_CNM_FIELD_MAX - 1));
+	off += sprintf(buf+off, "\tfield_id         (hex)field, only one field is allowed\n");
+	off += sprintf(buf+off, "\tfield_op         (dex)operation on this field\n");
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_field_op_str_get(TPM_CNM_OP_EQUAL), TPM_CNM_OP_EQUAL);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_field_op_str_get(TPM_CNM_OP_NOT_EQUAL), TPM_CNM_OP_NOT_EQUAL);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_field_op_str_get(TPM_CNM_OP_LESS_EQUAL), TPM_CNM_OP_LESS_EQUAL);
+	off += sprintf(buf+off, "\t\t%-19s%#X\n", tpm_utils_field_op_str_get(TPM_CNM_OP_GREATER_EQUAL), TPM_CNM_OP_GREATER_EQUAL);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_ipvx_key_cfg - see header of sfs_tpm_cfg_index
+**
+*******************************************************************************/
+int tpm_sfs_help_ipvx_key_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_name] [proto]                     > ipvx_key_proto_rule_set - set protocol part of IPVX ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tproto            (dec)Protocol 0-255\n");
+	off += sprintf(buf+off, "echo [rule_name]                             > ipvx_key_proto_rule_get - get protocol part of IPVX ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [dscp] [dscp_mask]        > ipvx_key_dscp_rule_set - set dscp part of IPVX ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tdscp             (dec)DSCP value(0-63)\n");
+	off += sprintf(buf+off, "\tdscp_mask        (hex)DSCP mask(0x0-0xFF)\n");
+	off += sprintf(buf+off, "echo [rule_name]                             > ipvx_key_dscp_rule_get - get dscp part of IPVX ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [flbl] [flbl_mask]        > ipv6_key_flbl_rule_set - set flow label part of IPV6 ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tflbl             (dec)Flow Label value(0-1048575)\n");
+	off += sprintf(buf+off, "\tflbl_mask        (hex)Flow Label mask(0x0-0xFFFFF)\n");
+	off += sprintf(buf+off, "echo [rule_name]                             > ipv6_key_flbl_rule_get - get flow label part of IPV6 ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [src_port] [dst_port]     > ipvx_key_port_rule_set - set IPVX port part of IPVX ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tsrc_port         (dec)Source port\n");
+	off += sprintf(buf+off, "\tdst_port         (dec)Destination port\n");
+	off += sprintf(buf+off, "echo [rule_name]                             > ipvx_key_port_rule_get - get IPVX port part of IPVX ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [ip_version] [src_ip] [src_ip_mask] [dst_ip] [dst_ip_mask] > ipvx_key_addr_rule_set - set IPVX address part of IPVX ACL rule\n");
+	off += sprintf(buf+off, "\trule_name        (max %d chars)Rule name\n", DB_TPMCFG_MAX_NAME);
+	off += sprintf(buf+off, "\tip_version       (dec)4 for IPv4, 6 for IPv6\n");
+	off += sprintf(buf+off, "echo [rule_name]                             > ipvx_key_addr_rule_get - get IPVX address part of IPVX ACL rule\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [version]		      > ipvx_key_ver_rule_set - set version part of IP ACL rule\n");
+	off += tpm_sfs_help_ipvx_format_print(buf, off);
+
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_mod_bitmap_cfg - Modification cfg bit map
+**
+*******************************************************************************/
+int tpm_sfs_help_mod_bitmap_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [mod_bm]                         > mod_bit_map_set - set mod bitmap\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx             (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\tmod_bm              (hex)mod bit map value\n\n");
+
+	off += sprintf(buf+off, "\tFollowing is Mod BM supported:\n");
+
+	/* L2 Switch */
+	off += sprintf(buf+off, "\t\t0x%05x - VLAN\n", TPM_VLAN_MOD);
+	off += sprintf(buf+off, "\t\t0x%05x - IPV4 | VLAN | DSCP\n", TPM_VLAN_MOD | TPM_IP_DSCP_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPV6 | VLAN | DSCP\n", TPM_VLAN_MOD | TPM_IP_DSCP_SET);
+
+	/* IPv4 Napt */
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL | SIP | L4_SRC\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL | DIP | L4_DST\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | TTL | SIP | L4_SRC\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | TTL | DIP | L4_DST\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE ADD | TTL | SIP | L4_SRC\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL | DIP | L4_DST\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE ADD | TTL | SIP | L4_SRC\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC | TPM_IP_SRC_SET | TPM_L4_SRC_SET);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL | DIP | L4_DST\n",
+	    TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC | TPM_IP_DST_SET | TPM_L4_DST_SET);
+
+	/* IPv6 Route */
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE ADD | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE ADD | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+
+	/* IPv4 Route */
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE ADD | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE ADD | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_ADD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+
+	/* (IPv4) Multicast */
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | SA | VLAN | TTL\n", TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | SA | TTL\n", TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | SA | VLAN | TTL\n", TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv4 | DA | SA | VLAN | PPPoE DEL | TTL\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+
+	/* (IPv6) Multicast */
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | SA | VLAN | HOPLIM\n", TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | SA | HOPLIM\n", TPM_ETH_SRC_SET | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | SA | VLAN | HOPLIM\n", TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+	off += sprintf(buf+off, "\t\t0x%05x - IPv6 | DA | SA | VLAN | PPPoE DEL | HOPLIM\n", TPM_ETH_DST_SET | TPM_ETH_SRC_SET | TPM_VLAN_MOD | TPM_PPOE_DEL | TPM_TTL_HOPL_DEC);
+
+	off += sprintf(buf+off, "\nNOTE: For IP Packet, all above cases can update DSCP by (Above_BM | 0x%x)\n\n", TPM_IP_DSCP_SET);
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_mod_rule_cfg - Modification cfg help info
+**
+*******************************************************************************/
+int tpm_sfs_help_mod_rule_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [operation] [vlan_rule_1] [vlan_rule_2] > mod_vlan_rule_set    - set VLAN part of mod rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx             (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\toperation           (str)VLAN operation\n");
+	off += sprintf(buf+off, "\t\tnone      ext_tag_mod  ext_tag_del  ext_tag_ins  ext_tag_mod_ins  ins_2tag\n");
+	off += sprintf(buf+off, "\t\tmod_2tag  swap_tags    del_2tags    int_tag_mod  ext_tag_del_int_mod\n");
+	off += sprintf(buf+off, "\tvlan_rule_1         (str)VLAN rule (Use vlan_empty for absent rule)\n");
+	off += sprintf(buf+off, "\tvlan_rule_2         (str)VLAN rule (Use vlan_empty for absent rule)\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [dscp] [dscpmask]                         > mod_dscp_rule_set      - set dscp part of mod rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx             (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\tdscp                (dec)DSCP value\n");
+	off += sprintf(buf+off, "\tdscp_mask           (hex)DSCP mask\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [session] [protocol_type]                 > mod_pppoe_rule_set     - set PPPoE part of mod rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx             (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\tsession             (dec)Session number\n");
+	off += sprintf(buf+off, "\tprotocol_type       (hex)Protocol type\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [src_port] [dst_port]                     > mod_l4_port_rule_set - set L4 port part of mod rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx             (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += sprintf(buf+off, "\tsrc_port            (dec)Source port\n");
+	off += sprintf(buf+off, "\tdst_port            (dec)Destination port\n");
+
+	off += sprintf(buf+off, "\necho [rule_name] [mod_idx] [srcip] [srcip_mask] [dstip] [dstip_mask] > mod_ipv6_addr_rule_set - set IPV6 address part of mod rule\n");
+	off += sprintf(buf+off, "echo [rule_name] [mod_idx] [srcip] [srcip_mask] [dstip] [dstip_mask] > mod_ipv4_addr_rule_set - set IPV4 address part of mod rule\n");
+	off += sprintf(buf+off, "echo [rule_name] [mod_idx] [SA] [SA_mask] [DA] [DA_mask]             > mod_mac_addr_rule_set  - set MAC address part of mod rule\n");
+	off += sprintf(buf+off, "\trule_name            (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\tmod_idx              (dec)index in mod array with name rule_name, range 0-%d\n", (TPM_ACT_NUM_MAX - 1));
+	off += tpm_sfs_help_mac_format_print(buf, off);
+	off += tpm_sfs_help_ipvx_format_print(buf, off);
+	return off;
+}
+
+/*******************************************************************************
+**
+**  tpm_sfs_help_mod_vlan_key_cfg - Mod valn key set help
+**
+*******************************************************************************/
+int tpm_sfs_help_mod_vlan_key_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "echo [rule_name] [tpid] [tpid_mask] [vid] [vid_mask] [cfi] [cfi_mask] [pbit] [pbit_mask] > mod_vlan_key_set        - set a VLAN rule\n");
+	off += sprintf(buf+off, "\trule_name           (max 16 chars)Rule name\n");
+	off += sprintf(buf+off, "\ttpid                (hex)TPID VLAN Ethertype\n");
+	off += sprintf(buf+off, "\ttpid_mask           (hex)TPID mask\n");
+	off += sprintf(buf+off, "\tvid                 (dec)VID\n");
+	off += sprintf(buf+off, "\tvid_mask            (hex)VID mask\n");
+	off += sprintf(buf+off, "\tcfi                 (dec)CFI\n");
+	off += sprintf(buf+off, "\tcfi_mask            (hex)CFI mask\n");
+	off += sprintf(buf+off, "\tpbit                (dec)P-bits\n");
+	off += sprintf(buf+off, "\tpbit_mask           (hex)P-bits mask\n");
+
+	return off ;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_cfg_frwd_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies forwarding rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+void tpm_sfs_cfg_frwd_rule_set(const char *buf, size_t len)
+{
+	enum frwd_rule_parm_indx_t {
+		frpi_name = 0, frwd_array_idx, frpi_port, frpi_tcont, frpi_que, frpi_gem_flag, frpi_gem, frpi_max
+	};
+	unsigned int			temp_port;
+	unsigned int			temp_tcont;
+	unsigned int			temp_que;
+	unsigned int			temp_gem;
+	unsigned int			temp_gem_flag;
+	char				name[100];
+	unsigned int			frwd_idx;
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_frwd_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != frpi_max) {
+		parm_error_completion(numparms, frpi_max, buf, tpm_sfs_help_frwd_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x %d %d %d %x", name, &frwd_idx, &temp_port,
+				&temp_tcont, &temp_que, &temp_gem_flag, &temp_gem);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_port[0x%x],temp_que[%d],temp_gem[%d]\n",
+	       len, parsedargs, name, temp_port, temp_que, temp_gem);
+*/
+		if (frwd_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid frwd index [%d]\n", frwd_idx);
+			return;
+		}
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_que > 255) {
+			printk(KERN_INFO "Invalid queue [%d]\n", temp_que);
+		} else if (temp_tcont > 15) {
+			printk(KERN_INFO "Invalid tcont [%d]\n", temp_tcont);
+		} else {
+			pentry = find_tpm_pkt_frwd_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_frwd_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Packet Forward DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->frwd[frwd_idx].pp_port  = temp_port;
+				pentry->frwd[frwd_idx].pon_tx = (unsigned char)temp_tcont;
+				pentry->frwd[frwd_idx].pp_queue  = (unsigned char)temp_que;
+				if (temp_gem_flag)
+					pentry->frwd[frwd_idx].port_id  = (unsigned short)(temp_gem | TPM_PORTID_SPEC);
+				else
+					pentry->frwd[frwd_idx].port_id  = 0;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_cnm_field_op_set
+*
+* DESCRIPTION:
+*           This function adds CnM field OP rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+void tpm_sfs_cfg_cnm_field_op_set(const char *buf, size_t len)
+{
+	enum field_op_parm_indx_t {
+		field_name = 0, field_array_idx, field_id, field_op, field_max
+	};
+	unsigned int			temp_field_id;
+	unsigned int			temp_field_op;
+	char				name[100];
+	unsigned int			field_idx;
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_cnm_field_op_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != field_max) {
+		parm_error_completion(numparms, field_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x %d", name, &field_idx, &temp_field_id, &temp_field_op);
+		if (field_idx >= TPM_CNM_FIELD_MAX) {
+			printk(KERN_INFO "Invalid field_idx [%d]\n", field_idx);
+			return;
+		}
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_field_op >= TPM_CNM_FIELD_MAX) {
+			printk(KERN_INFO "Invalid field_op [%d]\n", temp_field_op);
+		} else {
+			pentry = find_tpm_cnm_field_op_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_cnm_field_op_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "cnm_field_op DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->field_op[field_idx].op = temp_field_op;
+				pentry->field_op[field_idx].field = temp_field_id;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+static void tpm_sfs_api_rule_key_dump(struct tpm_db_mng_api_data_t *api_data)
+{
+	int parse_rule_bm = api_data->match_key.field_match_bm;
+
+	if (parse_rule_bm & TPM_MATCH_ETH_DST) {
+		printk(KERN_INFO "dmac:      %pM\n", api_data->match_key.eth_dst.eth_add);
+		printk(KERN_INFO "dmac_mask: %pM\n", api_data->match_key.eth_dst.eth_add_mask);
+	} else {
+		printk(KERN_INFO "dmac:      NULL\n");
+		printk(KERN_INFO "dmac_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_ETH_SRC) {
+		printk(KERN_INFO "smac:      %pM\n", api_data->match_key.eth_src.eth_add);
+		printk(KERN_INFO "smac_mask: %pM\n", api_data->match_key.eth_src.eth_add_mask);
+	} else {
+		printk(KERN_INFO "smac:      NULL\n");
+		printk(KERN_INFO "smac_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_VID_OUTER)
+		printk(KERN_INFO "vid_outer: %d\n", api_data->match_key.out_vid);
+	else
+		printk(KERN_INFO "vid_outer: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_PBITS_OUTER)
+		printk(KERN_INFO "pbit_outer: %d\n", api_data->match_key.out_pbit);
+	else
+		printk(KERN_INFO "pbit_outer: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_VID_INNER)
+		printk(KERN_INFO "vid_inner: %d\n", api_data->match_key.inn_vid);
+	else
+		printk(KERN_INFO "vid_inner: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_PBITS_INNER)
+		printk(KERN_INFO "pbit_inner: %d\n", api_data->match_key.inn_pbit);
+	else
+		printk(KERN_INFO "pbit_inner: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_ETH_TYPE)
+		printk(KERN_INFO "eth_type: %d\n", api_data->match_key.ether_type);
+	else
+		printk(KERN_INFO "eth_type: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_PPPOE_PROTO)
+		printk(KERN_INFO "pppoe_proto: %d\n", api_data->match_key.ppp_info.ppp_proto);
+	else
+		printk(KERN_INFO "pppoe_proto: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_PPPOE_SES)
+		printk(KERN_INFO "pppoe_session: %d\n", api_data->match_key.ppp_info.ppp_session);
+	else
+		printk(KERN_INFO "pppoe_session: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_IP_SRC) {
+		if (parse_rule_bm & TPM_MATCH_IPV4_PKT) {
+			printk(KERN_INFO "sipv4:      %pi4\n", api_data->match_key.ipvx_add.ip_src.ip_add.ipv4);
+			printk(KERN_INFO "sipv4_mask: %pi4\n", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv4);
+		}
+		if (parse_rule_bm & (TPM_MATCH_IPV6_PKT | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_SUFF)) {
+			printk(KERN_INFO "sipv6:      %pI6\n", api_data->match_key.ipvx_add.ip_src.ip_add.ipv6);
+			printk(KERN_INFO "sipv6_mask: %pI6\n", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv6);
+		}
+	} else {
+		printk(KERN_INFO "sip: NULL\n");
+		printk(KERN_INFO "sip_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_IP_DST) {
+		if (parse_rule_bm & TPM_MATCH_IPV4_PKT) {
+			printk(KERN_INFO "dipv4:      %pi4\n", api_data->match_key.ipvx_add.ip_dst.ip_add.ipv4);
+			printk(KERN_INFO "dipv4_mask: %pi4\n", api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv4);
+		}
+		if (parse_rule_bm & (TPM_MATCH_IPV6_PKT | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_SUFF)) {
+			printk(KERN_INFO "dipv6:      %pI6\n", api_data->match_key.ipvx_add.ip_dst.ip_add.ipv6);
+			printk(KERN_INFO "dipv6_mask: %pI6\n", api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv6);
+		}
+	} else {
+		printk(KERN_INFO "dip: NULL\n");
+		printk(KERN_INFO "dip_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_IP_DSCP) {
+		printk(KERN_INFO "dscp:      %d\n", api_data->match_key.ipvx_add.dscp);
+		printk(KERN_INFO "dscp_mask: %d\n", api_data->match_key.ipvx_add.dscp_mask);
+	} else {
+		printk(KERN_INFO "dscp: NULL\n");
+		printk(KERN_INFO "dscp_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_IPV6_FLBL) {
+		printk(KERN_INFO "flow_lable:      %d\n", api_data->match_key.ipvx_add.flow_label);
+		printk(KERN_INFO "flow_lable_mask: %d\n", api_data->match_key.ipvx_add.flow_label_mask);
+	} else {
+		printk(KERN_INFO "flow_lable: NULL\n");
+		printk(KERN_INFO "flow_lable_mask: NULL\n");
+	}
+	if (parse_rule_bm & TPM_MATCH_IP_PROTO)
+		printk(KERN_INFO "ip_proto: %d\n", api_data->match_key.ipvx_add.ip_proto);
+	else
+		printk(KERN_INFO "ip_proto: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_L4_SRC)
+		printk(KERN_INFO "l4_src: %d\n", api_data->match_key.l4_src);
+	else
+		printk(KERN_INFO "l4_src: NULL\n");
+
+	if (parse_rule_bm & TPM_MATCH_L4_DST)
+		printk(KERN_INFO "l4_dst: %d\n", api_data->match_key.l4_dst);
+	else
+		printk(KERN_INFO "l4_dst: NULL\n");
+
+}
+static void tpm_sfs_api_rule_mod_dump(struct tpm_pkt_mod_t *mod)
+{
+	int mod_bm = mod->mod_bm;
+
+	printk(KERN_INFO "mod_bm:  0x%08x\n", mod_bm);
+
+	if (mod_bm & TPM_ETH_DST_SET)
+		printk(KERN_INFO "dmac: %pM\n", mod->eth_dst);
+	else
+		printk(KERN_INFO "dmac: NULL\n");
+
+	if (mod_bm & TPM_ETH_SRC_SET)
+		printk(KERN_INFO "smac:  %pM\n", mod->eth_src);
+	else
+		printk(KERN_INFO "smac: NULL\n");
+
+	if (mod_bm & TPM_PPOE_ADD) {
+		printk(KERN_INFO "pppoe_proto: %d\n", mod->pppoe_mod.ppp_proto);
+		printk(KERN_INFO "pppoe_session: %d\n", mod->pppoe_mod.ppp_session);
+	} else {
+		printk(KERN_INFO "pppoe_proto: NULL\n");
+		printk(KERN_INFO "pppoe_session: NULL\n");
+	}
+	if (mod_bm & TPM_IP_DSCP_SET)
+		printk(KERN_INFO "dscp: %d\n", mod->ipvx.dscp);
+	else
+		printk(KERN_INFO "dscp: NULL\n");
+
+	if (mod_bm & TPM_L4_SRC_SET)
+		printk(KERN_INFO "l4_src: %d\n", mod->ipvx.l4_src);
+	else
+		printk(KERN_INFO "l4_src: NULL\n");
+
+	if (mod_bm & TPM_L4_DST_SET)
+		printk(KERN_INFO "l4_dst: %d\n", mod->ipvx.l4_dst);
+	else
+		printk(KERN_INFO "l4_dst: NULL\n");
+
+	if (mod_bm & TPM_IP_SRC_SET)
+		printk(KERN_INFO "sip: %pI6\n", mod->ipvx.ip_src.ipv6);
+	else
+		printk(KERN_INFO "sip: NULL\n");
+
+	if (mod_bm & TPM_IP_DST_SET)
+		printk(KERN_INFO "dip: %pI6\n", mod->ipvx.ip_dst.ipv6);
+	else
+		printk(KERN_INFO "dip: NULL\n");
+
+	if (mod_bm & TPM_VLAN_MOD) {
+		printk(KERN_INFO "vlan_mod_bm: %s\n", tpm_utils_vlan_op_str_get(mod->vlan_op.oper));
+		printk(KERN_INFO "tpid_outer: %d\n", mod->vlan_op.out_vlan.tpid);
+		printk(KERN_INFO "pbit_outer: %d\n", mod->vlan_op.out_vlan.pbit);
+		printk(KERN_INFO "cfi_outer: %d\n", mod->vlan_op.out_vlan.cfi);
+		printk(KERN_INFO "vid_outer: %d\n", mod->vlan_op.out_vlan.vid);
+		printk(KERN_INFO "tpid_inner: %d\n", mod->vlan_op.inn_vlan.tpid);
+		printk(KERN_INFO "pbit_inner: %d\n", mod->vlan_op.inn_vlan.pbit);
+		printk(KERN_INFO "cfi_inner: %d\n", mod->vlan_op.inn_vlan.cfi);
+		printk(KERN_INFO "vid_inner: %d\n", mod->vlan_op.inn_vlan.vid);
+
+	} else {
+		printk(KERN_INFO "VLAN: NULL\n");
+	}
+	return;
+}
+
+
+int tpm_sfs_api_rule_date_dump(struct tpm_db_mng_api_data_t *api_data)
+{
+	int i;
+
+	printk(KERN_INFO "api_type: %d\n", api_data->cap_api_type);
+	printk(KERN_INFO "match_key: ");
+	if (TPM_API_PUBLIC_CLS == api_data->cap_api_type)
+		printk(KERN_INFO "rule_type %d ", api_data->match_key.rule_type);
+
+	printk(KERN_INFO "port_type 0x%x ", api_data->match_key.port.port_type);
+	printk(KERN_INFO "class_port 0x%x ", api_data->match_key.port.class_port);
+
+	printk(KERN_INFO "field_match_bm 0x%x\n", api_data->match_key.field_match_bm);
+
+	tpm_sfs_api_rule_key_dump(api_data);
+
+	for (i = 0; i < api_data->num_dest; i++) {
+		printk(KERN_INFO "\n\naction %d:\n", i);
+		printk(KERN_INFO "dst_pp_port 0x%x ", api_data->action[i].dest.pp_port);
+		printk(KERN_INFO "pon_tx %d ", api_data->action[i].dest.pon_tx);
+		printk(KERN_INFO "pp_queue %d ", api_data->action[i].dest.pp_queue);
+		printk(KERN_INFO "dst_port_id 0x%x ", api_data->action[i].dest.port_id);
+		printk(KERN_INFO "color %d\n", api_data->action[i].color);
+
+		printk(KERN_INFO "\nmod %d:\n", i);
+		tpm_sfs_api_rule_mod_dump(&api_data->action[i].mod);
+	}
+
+	printk(KERN_INFO "\npolicer_id: 0x%x\n", api_data->policer_id);
+
+	return TPM_OK;
+}
+
+static int tpm_sfs_api_rule_dump(int rule_id, enum tpm_mng_api_type_t api_type)
+{
+	struct tpm_db_mng_api_data_t *api_data = NULL;
+	int tpm_ret;
+
+	/* allocate api data */
+	tpm_ret = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "allocate api_data structure mem failed!\n");
+
+	tpm_ret = tpm_db_mng_api_entry_get(rule_id, api_data);
+	IF_ERROR_STR_REL_API_DATA(TPM_MNG_MOD, tpm_ret, api_data,
+		"find no api entry for rule_id(%d)\n", rule_id);
+
+	/* dump this rule */
+	printk(KERN_INFO "\nrule_index: %d\n", rule_id);
+
+	tpm_sfs_api_rule_date_dump(api_data);
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return TPM_OK;
+}
+/*******************************************************************************
+* sfs_tpm_cfg_api_rule_dump
+*
+* DESCRIPTION:
+*           This function dumps a rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+void sfs_tpm_cfg_api_rule_dump(const char *buf, size_t len, enum tpm_mng_api_type_t api_type)
+{
+	enum frwd_rule_parm_indx_t {
+		rule_dump_index = 0, rule_dump_max
+	};
+	unsigned int			rule_index;
+	int				parsedargs;
+	int				numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != rule_dump_max) {
+		if (TPM_API_PUBLIC_CLS == api_type)
+			parm_error_completion(numparms, rule_dump_max, buf, tpm_sfs_help_cls_rule_get_cfg);
+		else if (TPM_API_PRIVATE_MC_DS == api_type)
+			parm_error_completion(numparms, rule_dump_max, buf, tpm_sfs_help_api_rule_get_cfg);
+		else if (TPM_API_PUBLIC_FLTR == api_type)
+			parm_error_completion(numparms, rule_dump_max, buf, tpm_sfs_help_filter_rule_get_cfg);
+		else
+			parm_error_completion(numparms, rule_dump_max, buf, tpm_sfs_help_exact_except_rule_get_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_index);
+		tpm_sfs_api_rule_dump(rule_index, api_type);
+	}
+}
+
+
+/*******************************************************************************
+* tpm_sfs_cfg_frwd_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies forwarding rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+void tpm_sfs_cfg_frwd_rule_get(const char *buf, size_t len)
+{
+	enum frwd_rule_parm_indx_t {
+		frpi_name = 0, frwd_array_idx, frpi_max
+	};
+	char				name[100];
+	unsigned int                    frwd_idx;
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_frwd_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != frpi_max) {
+		parm_error_completion(numparms, frpi_max, buf, tpm_sfs_help_frwd_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d", name, &frwd_idx);
+		if (frwd_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid frwd index [%d]\n", frwd_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+
+		pentry = find_tpm_pkt_frwd_entry_by_name(name);
+		if (0 == pentry) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "%s[%d]: pp_port=0x%x pon_tx=%d pp_queue=%d port_id=0x%x\n",
+				name, frwd_idx, pentry->frwd[frwd_idx].pp_port, pentry->frwd[frwd_idx].pon_tx,
+				pentry->frwd[frwd_idx].pp_queue, pentry->frwd[frwd_idx].port_id);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mtm_op
+*
+* DESCRIPTION:
+*       This function adds or removes a mac to port.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+int tpm_sfs_cfg_mtm_op(const char *buf, size_t len, enum tpm_mng_mtm_op_t op)
+{
+	enum l2_mac_rule_parm_indx_t {
+		portmacpi_port = 0, portmacpi_mac, portmacpi_max
+	};
+	char				temp_da[30];
+	unsigned int			port;
+	unsigned int			da[6];
+	int				parsedargs;
+	int				numparms;
+	unsigned int			tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != portmacpi_max) {
+		parm_error_completion(numparms, portmacpi_max, buf, tpm_sfs_help_mtm_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %s", &port, temp_da);
+
+		if (parse_mac_address(temp_da, da) == TPM_FALSE) {
+			printk(KERN_INFO "Invalid DA [%s]\n", temp_da);
+		} else {
+
+			temp_da[0] = (unsigned char)da[0];
+			temp_da[1] = (unsigned char)da[1];
+			temp_da[2] = (unsigned char)da[2];
+			temp_da[3] = (unsigned char)da[3];
+			temp_da[4] = (unsigned char)da[4];
+			temp_da[5] = (unsigned char)da[5];
+
+			if (TPM_MNG_MTM_ADD == op)
+				tpm_ret = _mv_tpm_mtm_add((enum tpm_gmacs_enum_t)port, temp_da);
+			else
+				tpm_ret = _mv_tpm_mtm_del((enum tpm_gmacs_enum_t)port, temp_da);
+
+			return tpm_ret;
+		}
+	}
+
+	return TPM_FAIL;
+}
+/*******************************************************************************
+* tpm_sfs_cfg_mtm_add
+*
+* DESCRIPTION:
+*       This function adds a mac to port.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_cfg_mtm_add(const char *buf, size_t len)
+{
+	unsigned int			tpm_ret;
+	tpm_ret = tpm_sfs_cfg_mtm_op(buf, len, TPM_MNG_MTM_ADD);
+	if (tpm_ret != 0)
+		printk(KERN_INFO "add mac on port failed, ret(%d)\n", tpm_ret);
+	else
+		PR_RESULT_OK;
+}
+/*******************************************************************************
+* tpm_sfs_cfg_mtm_del
+*
+* DESCRIPTION:
+*       This function dels a mac from port.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_cfg_mtm_del(const char *buf, size_t len)
+{
+	unsigned int			tpm_ret;
+	tpm_ret = tpm_sfs_cfg_mtm_op(buf, len, TPM_MNG_MTM_DEL);
+	if (tpm_ret != 0)
+		printk(KERN_INFO "delete mac from port failed, ret(%d)\n", tpm_ret);
+	else
+		PR_RESULT_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_plcr_add
+*
+* DESCRIPTION:
+*       This function adds a policer.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_cfg_plcr_add(const char *buf, size_t len)
+{
+	enum plrc_entry_idx {
+		plrc_token_unit = 0,
+		plrc_color_mode,
+		plrc_cir,
+		plrc_cbs,
+		plrc_ebs,
+		plrc_max
+	};
+	unsigned int token_unit;
+	unsigned int color_mode;
+	unsigned int cir;
+	unsigned int cbs;
+	unsigned int ebs;
+	unsigned char plcr_id;
+	struct tpm_policer_entry_t policer_entry;
+	int parsed_args;
+	int param_num;
+	int tpm_ret;
+
+	param_num = count_parameters(buf);
+	if (param_num != plrc_max)
+		parm_error_completion(param_num, plrc_max, buf, tpm_sfs_help_plcr_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d", &token_unit, &color_mode, &cir, &cbs, &ebs);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			policer_entry.token_unit = token_unit;
+			policer_entry.color_mode = color_mode;
+			policer_entry.cir        = cir;
+			policer_entry.cbs        = cbs;
+			policer_entry.ebs        = ebs;
+
+			tpm_ret = _mv_tpm_plcr_add(&policer_entry, &plcr_id);
+			if (TPM_OK == tpm_ret)
+				PR_POLICER_ID(plcr_id)
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_plcr_del
+*
+* DESCRIPTION:
+*       This function deletes a policer.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_cfg_plcr_del(const char *buf, size_t len)
+{
+	enum plrc_id_idx {
+		plrc_id = 0,
+		plrc_id_max
+	};
+	unsigned int plcr;
+	int parsed_args;
+	int param_num;
+	int tpm_ret;
+
+	param_num = count_parameters(buf);
+	if (param_num != plrc_id_max)
+		parm_error_completion(param_num, plrc_id_max, buf, tpm_sfs_help_plcr_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &plcr);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpm_ret = _mv_tpm_plcr_del(plcr);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_plcr_clear
+*
+* DESCRIPTION:
+*       This function clears all policers.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_cfg_plcr_clear(const char *buf, size_t len)
+{
+	enum plrc_id_idx {
+		plrc_id = 0,
+		plrc_id_max
+	};
+	unsigned int plcr;
+	int parsed_args;
+	int param_num;
+	int tpm_ret;
+
+	param_num = count_parameters(buf);
+	if (param_num != plrc_id_max)
+		parm_error_completion(param_num, plrc_id_max, buf, tpm_sfs_help_plcr_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &plcr);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpm_ret = _mv_tpm_plcr_clear();
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/********************************************************************************************/
+/* ========================================================================================*/
+/*             TPM CFG L2 KEY FUNCTIONS                                                   */
+/* ======================================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_ethertype_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies ethertype part part of L2 ACL key
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_ethertype_rule_set(const char *buf, size_t len)
+{
+	enum l2_ety_rule_parm_indx_t {
+		l2etypi_name = 0, l2etypi_ety, l2etypi_max
+	};
+	unsigned int			temp_ety;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2etypi_max) {
+		parm_error_completion(numparms, l2etypi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %x", name, &temp_ety);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_ety[0x%x]\n",
+	       len, parsedargs, name, temp_ety);
+*/
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_ety > 0xFFFF) {
+			printk(KERN_INFO "Invalid ethertype [0x%x]\n", temp_ety);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "L2 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ether_type  = (unsigned short)temp_ety;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_ethertype_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies ethertype part part of L2 ACL key
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_ethertype_rule_get(const char *buf, size_t len)
+{
+	enum l2_ety_rule_parm_indx_t {
+		l2etypi_name = 0, l2etypi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2etypi_max) {
+		parm_error_completion(numparms, l2etypi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0)
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		else
+			printk(KERN_INFO "ether_type=0x%x\n", pentry->key.ether_type);
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_mac_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies MAC address part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_mac_addr_rule_set(const char *buf, size_t len)
+{
+	enum l2_mac_rule_parm_indx_t {
+		l2macpi_name = 0, l2macpi_srcip, l2macpi_srcipmask, l2macpi_dstip, l2macpi_dstipmask, l2macpi_max
+	};
+	char				temp_sa[30];
+	char				temp_sa_mask[30];
+	char				temp_da[30];
+	char				temp_da_mask[30];
+	unsigned int			sa[6];
+	unsigned int			sa_mask[6];
+	unsigned int			da[6];
+	unsigned int			da_mask[6];
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2macpi_max) {
+		parm_error_completion(numparms, l2macpi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %s %s %s %s", name, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (parse_mac_address(temp_sa, sa) == TPM_FALSE) {
+			printk(KERN_INFO "Invalid SA [%s]\n", temp_sa);
+		} else if (parse_mac_address(temp_sa_mask, sa_mask) == TPM_FALSE) {
+			printk(KERN_INFO "Invalid SA mask [%s]\n", temp_sa_mask);
+		} else if (parse_mac_address(temp_da, da) == TPM_FALSE) {
+			printk(KERN_INFO "Invalid DA [%s]\n", temp_da);
+		} else if (parse_mac_address(temp_da_mask, da_mask) == TPM_FALSE) {
+			printk(KERN_INFO "Invalid DA mask [%s]\n", temp_da_mask);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0)
+				printk(KERN_INFO "L2 key DB full\n");
+			else {
+				strcpy(pentry->name, name);
+				pentry->key.eth_src.eth_add[0] = (unsigned char)sa[0];
+				pentry->key.eth_src.eth_add[1] = (unsigned char)sa[1];
+				pentry->key.eth_src.eth_add[2] = (unsigned char)sa[2];
+				pentry->key.eth_src.eth_add[3] = (unsigned char)sa[3];
+				pentry->key.eth_src.eth_add[4] = (unsigned char)sa[4];
+				pentry->key.eth_src.eth_add[5] = (unsigned char)sa[5];
+
+				pentry->key.eth_src.eth_add_mask[0] = (unsigned char)sa_mask[0];
+				pentry->key.eth_src.eth_add_mask[1] = (unsigned char)sa_mask[1];
+				pentry->key.eth_src.eth_add_mask[2] = (unsigned char)sa_mask[2];
+				pentry->key.eth_src.eth_add_mask[3] = (unsigned char)sa_mask[3];
+				pentry->key.eth_src.eth_add_mask[4] = (unsigned char)sa_mask[4];
+				pentry->key.eth_src.eth_add_mask[5] = (unsigned char)sa_mask[5];
+
+				pentry->key.eth_dst.eth_add[0] = (unsigned char)da[0];
+				pentry->key.eth_dst.eth_add[1] = (unsigned char)da[1];
+				pentry->key.eth_dst.eth_add[2] = (unsigned char)da[2];
+				pentry->key.eth_dst.eth_add[3] = (unsigned char)da[3];
+				pentry->key.eth_dst.eth_add[4] = (unsigned char)da[4];
+				pentry->key.eth_dst.eth_add[5] = (unsigned char)da[5];
+
+				pentry->key.eth_dst.eth_add_mask[0] = (unsigned char)da_mask[0];
+				pentry->key.eth_dst.eth_add_mask[1] = (unsigned char)da_mask[1];
+				pentry->key.eth_dst.eth_add_mask[2] = (unsigned char)da_mask[2];
+				pentry->key.eth_dst.eth_add_mask[3] = (unsigned char)da_mask[3];
+				pentry->key.eth_dst.eth_add_mask[4] = (unsigned char)da_mask[4];
+				pentry->key.eth_dst.eth_add_mask[5] = (unsigned char)da_mask[5];
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_mac_addr_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies MAC address part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_mac_addr_rule_get(const char *buf, size_t len)
+{
+	enum l2_mac_rule_parm_indx_t {
+		l2macpi_name = 0, l2macpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2macpi_max) {
+		parm_error_completion(numparms, l2macpi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "SA=%02x:%02x:%02x:%02x:%02x:%02x SA_MASK=%02x:%02x:%02x:%02x:%02x:%02x" \
+			       " DA=%02x:%02x:%02x:%02x:%02x:%02x DA_MASK=%02x:%02x:%02x:%02x:%02x:%02x\n",
+			       pentry->key.eth_src.eth_add[0],
+			       pentry->key.eth_src.eth_add[1],
+			       pentry->key.eth_src.eth_add[2],
+			       pentry->key.eth_src.eth_add[3],
+			       pentry->key.eth_src.eth_add[4],
+			       pentry->key.eth_src.eth_add[5],
+			       pentry->key.eth_src.eth_add_mask[0],
+			       pentry->key.eth_src.eth_add_mask[1],
+			       pentry->key.eth_src.eth_add_mask[2],
+			       pentry->key.eth_src.eth_add_mask[3],
+			       pentry->key.eth_src.eth_add_mask[4],
+			       pentry->key.eth_src.eth_add_mask[5],
+			       pentry->key.eth_dst.eth_add[0],
+			       pentry->key.eth_dst.eth_add[1],
+			       pentry->key.eth_dst.eth_add[2],
+			       pentry->key.eth_dst.eth_add[3],
+			       pentry->key.eth_dst.eth_add[4],
+			       pentry->key.eth_dst.eth_add[5],
+			       pentry->key.eth_dst.eth_add_mask[0],
+			       pentry->key.eth_dst.eth_add_mask[1],
+			       pentry->key.eth_dst.eth_add_mask[2],
+			       pentry->key.eth_dst.eth_add_mask[3],
+			       pentry->key.eth_dst.eth_add_mask[4],
+			       pentry->key.eth_dst.eth_add_mask[5]);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_pppoe_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies PPPoE part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_pppoe_rule_set(const char *buf, size_t len)
+{
+	enum l2_pppoe_rule_parm_indx_t {
+		l2pppoepi_name = 0, l2pppoepi_session, l2pppoepi_prototype, l2pppoepi_max
+	};
+	unsigned int          temp_session;
+	unsigned int          temp_prototype;
+	char                  name[100];
+	int                   parsedargs;
+	int                   numparms;
+	struct tpmcfg_pkt_key_entry_t *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2pppoepi_max) {
+		parm_error_completion(numparms, l2pppoepi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x", name, &temp_session, &temp_prototype);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_session[%d] temp_prototype[0x%x]\n",
+	       len, parsedargs, name, temp_session, temp_prototype);
+*/
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_session > 0xFFFF) {
+			printk(KERN_INFO "Invalid session [%d]\n", temp_session);
+		} else if (temp_prototype > 0xFFFF) {
+			printk(KERN_INFO "Invalid protocol type [0x%x]\n", temp_prototype);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "L2 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ppp_info.ppp_session = (unsigned short)temp_session;
+				pentry->key.ppp_info.ppp_proto   = (unsigned short)temp_prototype;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_pppoe_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies PPPoE part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_pppoe_rule_get(const char *buf, size_t len)
+{
+	enum l2_pppoe_rule_parm_indx_t {
+		l2pppoepi_name = 0, l2pppoepi_max
+	};
+	char                  name[100];
+	int                   parsedargs;
+	int                   numparms;
+	struct tpmcfg_pkt_key_entry_t *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2pppoepi_max) {
+		parm_error_completion(numparms, l2pppoepi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "ppp_session=%d ppp_proto=0x%x\n",
+			       pentry->key.ppp_info.ppp_session,
+			       pentry->key.ppp_info.ppp_proto);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_vlan_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies vlan part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_vlan_rule_set(const char *buf, size_t len)
+{
+	enum l2_vlan_rule_parm_indx_t {
+		l2vrpi_name = 0, l2vrpi_vlan1_vid, l2vrpi_vlan1_pbit, l2vrpi_vlan2_vid, l2vrpi_vlan2_pbit, l2vrpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+	int				vid_out;
+	int				pri_out;
+	int				vid_in;
+	int				pri_in;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2vrpi_max) {
+		parm_error_completion(numparms, l2vrpi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %d %d %d", name, &vid_out, &pri_out, &vid_in, &pri_in);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] vlan1_name[%s] vlan2_name[%s]\n",
+	       len, parsedargs, name, vlan1_name, vlan2_name);
+*/
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "L2 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+
+				pentry->key.inn_vid = vid_in;
+				pentry->key.inn_pbit = pri_in;
+				pentry->key.out_vid = vid_out;
+				pentry->key.out_pbit = pri_out;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_key_vlan_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies vlan part of L2 ACL key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_l2_key_vlan_rule_get(const char *buf, size_t len)
+{
+	enum l2_vlan_rule_parm_indx_t {
+		l2vrpi_name = 0, l2vrpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != l2vrpi_max) {
+		parm_error_completion(numparms, l2vrpi_max, buf, tpm_sfs_help_l2_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "inn_vid=%d inn_pbit=%d out_vid=%d out_pbit=%d\n",
+				pentry->key.inn_vid,
+				pentry->key.inn_pbit,
+				pentry->key.out_vid,
+				pentry->key.out_pbit);
+		}
+	}
+}
+
+/********************************************************************************************/
+/* ========================================================================================*/
+/*             TPM CFG IPV KEY FUNCTIONS                                                    */
+/* ======================================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies address part of IPV4/6 key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_addr_rule_set(const char *buf, size_t len)
+{
+	enum ipvx_add_rule_parm_indx_t {
+		ipvxadd_name = 0, ipvxadd_ver,
+		ipvxadd_srcip, ipvxadd_srcipmask,
+		ipvxadd_dstip, ipvxadd_dstipmask, ipvxadd_max
+	};
+	char				sip_str[60];
+	char				sipm_str[60];
+	char				dip_str[60];
+	char				dipm_str[60];
+	unsigned int			srcip[16];
+	unsigned int			srcip_mask[16];
+	unsigned int			dstip[16];
+	unsigned int			dstip_mask[16];
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	int				ip_ver;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+	unsigned int			num_of_bytes, i;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipvxadd_max) {
+		parm_error_completion(numparms, ipvxadd_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %s %s %s %s",
+					name, &ip_ver, sip_str, sipm_str, dip_str, dipm_str);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] sip_str[%s] sipm_str[%s] dip_str[%s] dipm_str[%s]\n",
+	       len, parsedargs, name, sip_str, sipm_str, dip_str, dipm_str);
+*/
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		} else if (ip_ver != 4 && ip_ver != 6) {
+			printk(KERN_INFO "IP version incorrect [%d]\n", ip_ver);
+			return;
+		} else if (ip_ver == 4) {
+			if (parse_ipv4_address(sip_str, srcip) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid srcip [%s]\n", sip_str);
+				return;
+			} else if (parse_ipv4_address(sipm_str, srcip_mask) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid srcip mask [%s]\n", sipm_str);
+				return;
+			} else if (parse_ipv4_address(dip_str, dstip) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip [%s]\n", dip_str);
+				return;
+			} else if (parse_ipv4_address(dipm_str, dstip_mask) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip mask [%s]\n", dipm_str);
+				return;
+			}
+		} else {
+			if (parse_ipv6_address(sip_str, srcip) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid srcip [%s]\n", sip_str);
+				return;
+			} else if (parse_ipv6_address(sipm_str, srcip_mask) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid srcip mask [%s]\n", sipm_str);
+				return;
+			} else if (parse_ipv6_address(dip_str, dstip) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip [%s]\n", dip_str);
+				return;
+			} else if (parse_ipv6_address(dipm_str, dstip_mask) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip mask [%s]\n", dipm_str);
+				return;
+			}
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0)
+			pentry = find_free_tpm_pkt_key_entry();
+
+		if (pentry == 0) {
+			printk(KERN_INFO "IPV4 key DB full\n");
+			return;
+		}
+
+		strcpy(pentry->name, name);
+
+		num_of_bytes = (ip_ver == 4) ? 4 : 16;
+
+		for (i = 0; i < num_of_bytes; i++) {
+			pentry->key.ipvx_add.ip_src.ip_add.ipv6[i] =	(unsigned char)srcip[i];
+			pentry->key.ipvx_add.ip_src.ip_add_mask.ipv6[i] = (unsigned char)srcip_mask[i];
+			pentry->key.ipvx_add.ip_dst.ip_add.ipv6[i] =	(unsigned char)dstip[i];
+			pentry->key.ipvx_add.ip_dst.ip_add_mask.ipv6[i] = (unsigned char)dstip_mask[i];
+		}
+		pentry->key.ipvx_add.ip_ver = ip_ver;
+		PR_RESULT_OK
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_addr_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies address part of IPV4/6 key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_addr_rule_get(const char *buf, size_t len)
+{
+	enum ipvx_add_rule_parm_indx_t {
+		ipvxaddpi_name = 0, ipvxaddpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipvxaddpi_max) {
+		parm_error_completion(numparms, ipvxaddpi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			if (pentry->key.ipvx_add.ip_ver == 6) {
+				printk(KERN_INFO "SIP=%pI6 SIP_MASK=%pI6\nDIP=%pI6 DIP_MASK=%pI6\n",
+					pentry->key.ipvx_add.ip_src.ip_add.ipv6,
+					pentry->key.ipvx_add.ip_src.ip_add_mask.ipv6,
+					pentry->key.ipvx_add.ip_dst.ip_add.ipv6,
+					pentry->key.ipvx_add.ip_dst.ip_add_mask.ipv6);
+			} else {
+				printk(KERN_INFO "SIP=%pI4 SIP_MASK=%pI4 DIP=%pI4 DIP_MASK=%pI4\n",
+					pentry->key.ipvx_add.ip_src.ip_add.ipv4,
+					pentry->key.ipvx_add.ip_src.ip_add_mask.ipv4,
+					pentry->key.ipvx_add.ip_dst.ip_add.ipv4,
+					pentry->key.ipvx_add.ip_dst.ip_add_mask.ipv4);
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_arp_key_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies address part of arp key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_arp_key_addr_rule_set(const char *buf, size_t len)
+{
+	enum ipvx_add_rule_parm_indx_t {
+		ipvxadd_name = 0, ipvxadd_dstip,
+		ipvxadd_dstipmask, ipvxadd_max
+	};
+	char				dip_str[60];
+	char				dipm_str[60];
+	unsigned int			dstip[16];
+	unsigned int			dstip_mask[16];
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+	unsigned int			i;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipvxadd_max) {
+		parm_error_completion(numparms, ipvxadd_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %s %s",
+					name, dip_str, dipm_str);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] dip_str[%s] dipm_str[%s]\n",
+	       len, parsedargs, name, dip_str, dipm_str);
+*/
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		} else {
+			if (parse_ipv4_address(dip_str, dstip) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip [%s]\n", dip_str);
+				return;
+			} else if (parse_ipv4_address(dipm_str, dstip_mask) == TPM_FALSE) {
+				printk(KERN_INFO "Invalid dstip mask [%s]\n", dipm_str);
+				return;
+			}
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0)
+			pentry = find_free_tpm_pkt_key_entry();
+
+		if (pentry == 0) {
+			printk(KERN_INFO "IPV4 key DB full\n");
+			return;
+		}
+
+		strcpy(pentry->name, name);
+
+		for (i = 0; i < IPV4_ADDR_SIZE; i++) {
+			pentry->key.arp_ip_dst.ip_add.ipv4[i] = (unsigned char)dstip[i];
+			pentry->key.arp_ip_dst.ip_add_mask.ipv4[i] = (unsigned char)dstip_mask[i];
+		}
+		PR_RESULT_OK
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_arp_key_addr_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies address part of arp key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_arp_key_addr_rule_get(const char *buf, size_t len)
+{
+	enum ipvx_add_rule_parm_indx_t {
+		ipvxaddpi_name = 0, ipvxaddpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipvxaddpi_max) {
+		parm_error_completion(numparms, ipvxaddpi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "ARP_DIP=%pI4 ARP_DIP_MASK=%pI4\n",
+				pentry->key.arp_ip_dst.ip_add.ipv4,
+				pentry->key.arp_ip_dst.ip_add_mask.ipv4);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_port_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies port part of IPV4 key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_port_rule_set(const char *buf, size_t len)
+{
+	enum ipv4port_rule_parm_indx_t {
+		ipv4portpi_name = 0, ipv4portpi_srcport, ipv4portpi_dstport, ipv4portpi_max
+	};
+	unsigned int			temp_src_port;
+	unsigned int			temp_dst_port;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4portpi_max) {
+		parm_error_completion(numparms, ipv4portpi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %d", name, &temp_src_port, &temp_dst_port);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_src_port[%d] temp_dst_port[%d]\n",
+	       len, parsedargs, name, temp_src_port, temp_dst_port);
+*/
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_src_port > 0xFFFF) {
+			printk(KERN_INFO "Invalid srcport [%d]\n", temp_src_port);
+		} else if (temp_dst_port > 0xFFFF) {
+			printk(KERN_INFO "Invalid dstport [%d]\n", temp_dst_port);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "IPV4 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.l4_src = (unsigned short)temp_src_port;
+				pentry->key.l4_dst = (unsigned short)temp_dst_port;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_port_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies port part of IPV4 key rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_port_rule_get(const char *buf, size_t len)
+{
+	enum ipv4port_rule_parm_indx_t {
+		ipv4portpi_name = 0, ipv4portpi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4portpi_max) {
+		parm_error_completion(numparms, ipv4portpi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "l4_src=%d l4_dst=%d\n",
+				pentry->key.l4_src,
+				pentry->key.l4_dst);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_protocol_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies protocol part of IPV4 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_protocol_rule_set(const char *buf, size_t len)
+{
+	enum ipv4proto_rule_parm_indx_t {
+		ipv4protopi_name = 0, ipv4protopi_protocol, ipv4protopi_max
+	};
+	unsigned int			temp_protocol;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4protopi_max) {
+		parm_error_completion(numparms, ipv4protopi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d", name, &temp_protocol);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_protocol[0x%x]\n",
+	       len, parsedargs, name, temp_protocol);
+*/
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_protocol > 255) {
+			printk(KERN_INFO "Invalid protocol [%d]\n", temp_protocol);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "IPV4 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ipvx_add.ip_proto = (unsigned char)temp_protocol;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_protocol_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies protocol part of IPV4 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_protocol_rule_get(const char *buf, size_t len)
+{
+	enum ipv4proto_rule_parm_indx_t {
+		ipv4protopi_name = 0, ipv4protopi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4protopi_max) {
+		parm_error_completion(numparms, ipv4protopi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "ip_proto=%d\n",
+				pentry->key.ipvx_add.ip_proto);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_dscp_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies DSCP part of IPV4 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_dscp_rule_set(const char *buf, size_t len)
+{
+	enum ipv4dscp_rule_parm_indx_t {
+		ipv4dscppi_name = 0, ipv4dscppi_dscp, ipv4dscppi_dscpmask, ipv4dscppi_max
+	};
+	unsigned int			temp_dscp;
+	unsigned int			temp_dscp_mask;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4dscppi_max) {
+		parm_error_completion(numparms, ipv4dscppi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x", name, &temp_dscp, &temp_dscp_mask);
+/*        printk(KERN_INFO "len=%d, parsedargs=%d. rulename[%s] temp_dscp[%d] temp_dscp_mask[0x%x]\n",
+	       len, parsedargs, name, temp_dscp, temp_dscp_mask);
+*/
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_dscp > 63) {
+			printk(KERN_INFO "Invalid dscp [%d]\n", temp_dscp);
+		} else if (temp_dscp_mask > 0xFF) {
+			printk(KERN_INFO "Invalid dscp mask [0x%x]\n", temp_dscp_mask);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "IPV4 key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ipvx_add.dscp      = (unsigned char)temp_dscp;
+				pentry->key.ipvx_add.dscp_mask = (unsigned char)temp_dscp_mask;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_dscp_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies DSCP part of IPV4 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_dscp_rule_get(const char *buf, size_t len)
+{
+	enum ipv4dscp_rule_parm_indx_t {
+		ipv4dscppi_name = 0, ipv4dscppi_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv4dscppi_max) {
+		parm_error_completion(numparms, ipv4dscppi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "dscp=%d dscp_mask=0x%X\n",
+				pentry->key.ipvx_add.dscp,
+				pentry->key.ipvx_add.dscp_mask);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipvx_key_ver_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies version part of IP ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipvx_key_ver_rule_set(const char *buf, size_t len)
+{
+	enum ipvxver_rule_parm_indx_t {
+		ipvxverpi_name = 0, ipvxverpi_ver, ipvxverpi_max
+	};
+	unsigned int			temp_ver;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipvxverpi_max) {
+		parm_error_completion(numparms, ipvxverpi_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d", name, &temp_ver);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_ver > 6) {
+			printk(KERN_INFO "Invalid temp_ver [%d]\n", temp_ver);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "IP key DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ipvx_add.ip_ver = (unsigned char)temp_ver;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipv6_key_flbl_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies flow label part of IPV6 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipv6_key_flbl_rule_set(const char *buf, size_t len)
+{
+	enum ipv6flbl_rule_parm_indx_t {
+		ipv6flbl_name = 0, ipv6flbl_val, ipv6flbl_mask, ipv6flbl_max
+	};
+	unsigned int			temp_flbl;
+	unsigned int			temp_flbl_mask;
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv6flbl_max) {
+		parm_error_completion(numparms, ipv6flbl_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x", name, &temp_flbl, &temp_flbl_mask);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_flbl > 0xFFFFF) {
+			printk(KERN_INFO "Invalid flow label [%d]\n", temp_flbl);
+		} else if (temp_flbl_mask > 0xFFFFF) {
+			printk(KERN_INFO "Invalid flow label mask [0x%x]\n", temp_flbl_mask);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->key.ipvx_add.flow_label      = temp_flbl;
+				pentry->key.ipvx_add.flow_label_mask = temp_flbl_mask;
+				PR_RESULT_OK
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_ipv6_key_flbl_rule_get
+*
+* DESCRIPTION:
+*           This function adds/modifies flow label part of IPV6 ACL rule
+*
+* See tpm_sfs_cfg_frwd_rule_set() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_ipv6_key_flbl_rule_get(const char *buf, size_t len)
+{
+	enum ipv6flbl_rule_parm_indx_t {
+		ipv6flbl_name = 0, ipv6flbl_max
+	};
+	char				name[100];
+	int				parsedargs;
+	int				numparms;
+	struct tpmcfg_pkt_key_entry_t	*pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv6flbl_max) {
+		parm_error_completion(numparms, ipv6flbl_max, buf, tpm_sfs_help_ipvx_key_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s", name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+			return;
+		}
+		pentry = find_tpm_pkt_key_entry_by_name(name);
+		if (pentry == 0) {
+			printk(KERN_INFO "entry [%s] not found\n", name);
+		} else {
+			printk(KERN_INFO "flow label=%d flow label mask=0x%X\n",
+				pentry->key.ipvx_add.flow_label,
+				pentry->key.ipvx_add.flow_label_mask);
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_all_set
+*
+* DESCRIPTION:
+*           This function deletes a L3 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_all_set(const char *buf, size_t len)
+{
+	int rc;
+
+	rc = _mv_tpm_exact_match_rule_del_all();
+	if (rc == TPM_OK) {
+		PR_RESULT_OK
+	} else {
+		printk(KERN_INFO "%s: _mv_tpm_exact_match_rule_del_all failed, rc[%d] - %s\n",
+		       __func__, rc, get_tpm_err_str(rc));
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_except_all_set
+*
+* DESCRIPTION:
+*           This function deletes a L2 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_except_all_set(const char *buf, size_t len)
+{
+	int rc;
+
+	rc = _mv_tpm_exact_match_except_rule_del_all();
+	if (rc == TPM_OK) {
+		PR_RESULT_OK
+	} else {
+		printk(KERN_INFO "%s: _mv_tpm_exact_match_except_rule_del_all failed, rc[%d] - %s\n",
+		       __func__, rc, get_tpm_err_str(rc));
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_cls_all_set
+*
+* DESCRIPTION:
+*           This function deletes a L2 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_cls_all_set(const char *buf, size_t len)
+{
+	int rc;
+
+	rc = _mv_tpm_gen_cls_rule_del_all();
+	if (rc == TPM_OK) {
+		PR_RESULT_OK
+	} else {
+		printk(KERN_INFO "%s: _mv_tpm_gen_cls_rule_del_all failed, rc[%d] - %s\n",
+		       __func__, rc, get_tpm_err_str(rc));
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_except_set
+*
+* DESCRIPTION:
+*           This function deletes a L2 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_except_set(const char *buf, size_t len)
+{
+	enum noruleaddl2_parm_indx_t {
+		noruleaddl2_owner = 0, noruleaddl2_max
+	};
+	/* shell line parsing */
+	unsigned int	rule_idx;
+	int		parsedargs;
+	int		numparms;
+	/* Used in API call */
+	int		rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl2_max) {
+		parm_error_completion(numparms, noruleaddl2_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_idx);
+		/*printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+		       len, parsedargs, ownerid, rule_idx);
+	*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_exact_match_except_rule_del(NULL, rule_idx);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_exact_match_except_rule_del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_set
+*
+* DESCRIPTION:
+*           This function deletes a L3 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_set(const char *buf, size_t len)
+{
+	enum noruleaddl3_parm_indx_t {
+		noruleaddl3_owner = 0, noruleaddl3_max
+	};
+	/* shell line parsing */
+	unsigned int	rule_idx;
+	int		parsedargs;
+	int		numparms;
+	/* Used in API call */
+	int		rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl3_max) {
+		parm_error_completion(numparms, noruleaddl3_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_idx);
+		/*printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+		       len, parsedargs, ownerid, rule_idx);
+	*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_exact_match_rule_del(NULL, rule_idx);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_exact_match_rule_del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_cls_set
+*
+* DESCRIPTION:
+*           This function deletes a CLS HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_cls_set(const char *buf, size_t len)
+{
+	enum noruleaddl2_parm_indx_t {
+		noruleaddl2_owner = 0, noruleaddl2_max
+	};
+	/* shell line parsing */
+	unsigned int                 rule_idx;
+	int                      parsedargs;
+	int                      numparms;
+	/* Used in API call */
+	int         rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl2_max) {
+		parm_error_completion(numparms, noruleaddl2_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_idx);
+/*           printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+	       len, parsedargs, ownerid, rule_idx);
+*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_gen_cls_rule_del(NULL, rule_idx);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_gen_cls_rule_del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_cnm_all_set
+*
+* DESCRIPTION:
+*           This function deletes a CnM HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_cnm_all_set(const char *buf, size_t len)
+{
+	enum noruleaddl2_parm_indx_t {
+		noruleaddl2_uni_port = 0, noruleaddl2_max
+	};
+	/* shell line parsing */
+	unsigned int                 uni_port;
+	int                      parsedargs;
+	int                      numparms;
+	/* Used in API call */
+	int         rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl2_max) {
+		parm_error_completion(numparms, noruleaddl2_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%x", &uni_port);
+/*           printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+	       len, parsedargs, ownerid, rule_idx);
+*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_cm_rule_del_all(uni_port);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_cm_rule_del_all failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_cnm_set
+*
+* DESCRIPTION:
+*           This function deletes a CnM HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_cnm_set(const char *buf, size_t len)
+{
+	enum noruleaddl2_parm_indx_t {
+		noruleaddl2_uni_port = 0, noruleaddl2_rule_num, noruleaddl2_max
+	};
+	/* shell line parsing */
+	unsigned int                 rule_num;
+	unsigned int                 uni_port;
+	int                      parsedargs;
+	int                      numparms;
+	/* Used in API call */
+	int         rc;
+	struct tpm_class_port_t	port;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl2_max) {
+		parm_error_completion(numparms, noruleaddl2_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &uni_port, &rule_num);
+/*           printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+	       len, parsedargs, ownerid, rule_idx);
+*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+			port.class_port = (1 << uni_port);
+			rc = _mv_tpm_cm_rule_del(&port, rule_num);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_cm_rule_del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_filter_set
+*
+* DESCRIPTION:
+*           This function deletes a filter HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_filter_set(const char *buf, size_t len)
+{
+	enum noruleaddl2_parm_indx_t {
+		noruleaddl2_owner = 0, noruleaddl2_max
+	};
+	/* shell line parsing */
+	unsigned int                 rule_idx;
+	int                      parsedargs;
+	int                      numparms;
+	/* Used in API call */
+	int         rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddl2_max) {
+		parm_error_completion(numparms, noruleaddl2_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_idx);
+/*           printk(KERN_INFO "len=%d, parsedargs=%d. ownerid[%d], rule_idx[%d]\n",
+	       len, parsedargs, ownerid, rule_idx);
+*/
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_filter_rule_del(NULL, rule_idx);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: _mv_tpm_filter_rule_del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_filter_all_set
+*
+* DESCRIPTION:
+*           This function deletes all filter HW rules
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_filter_all_set(const char *buf, size_t len)
+{
+	int rc;
+
+	rc = _mv_tpm_filter_rule_del_all();
+	if (rc == TPM_OK) {
+		PR_RESULT_OK
+	} else {
+		printk(KERN_INFO "%s: _mv_tpm_filter_rule_del_all failed, rc[%d] - %s\n",
+		       __func__, rc, get_tpm_err_str(rc));
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_key_set
+*
+* DESCRIPTION:
+*           This function deletes a L3 HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_key_set(const char *buf, size_t len)
+{
+	enum l2ruleadd_parm_indx_t {
+		l2ruleadd_parserulebm, l2ruleadd_key, l2ruleadd_max
+	};
+	/* shell line parsing */
+	int	ip_version;
+	char	l2keyname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	/* Used in API call */
+	struct tpm_exact_match_t	match_key;
+	int			rc;
+
+	numparms = count_parameters(buf);
+
+	if (numparms != l2ruleadd_max) {
+		parm_error_completion(numparms, l2ruleadd_max, buf, tpm_sfs_help_no_rule_add);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%d %s", &ip_version, l2keyname);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else {
+
+		match_key.ipvx_five_t.l4_dst = pdbl2keyentry->key.l4_dst;
+		match_key.ipvx_five_t.l4_src = pdbl2keyentry->key.l4_src;
+		match_key.ipvx_five_t.l4_proto = pdbl2keyentry->key.ipvx_add.ip_proto;
+		memcpy(&match_key.ipvx_five_t.ip_dst,
+			&pdbl2keyentry->key.ipvx_add.ip_dst.ip_add,
+			sizeof(match_key.ipvx_five_t.ip_dst));
+		memcpy(&match_key.ipvx_five_t.ip_src,
+			&pdbl2keyentry->key.ipvx_add.ip_src.ip_add,
+			sizeof(match_key.ipvx_five_t.ip_src));
+		match_key.ipvx_five_t.ip_ver = ip_version;
+
+		rc = _mv_tpm_exact_match_rule_del(&match_key.ipvx_five_t, 0);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "%s: _mv_tpm_exact_match_rule_del failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_cls_cpu_exact_rule_add_set
+*
+* DESCRIPTION:
+*           This function del a L2 rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_cls_cpu_rule_add_set(const char *buf, size_t len, enum tpm_mng_api_type_t api_type)
+{
+	enum l2ruleadd_parm_indx_t {
+		l2ruleadd_srcport_bm, l2ruleadd_srcport_vir, l2ruleadd_rule_type, l2ruleadd_parserulebm, l2ruleadd_key,
+		l2ruleadd_max
+	};
+	/* shell line parsing */
+	int	rule_type = 0;
+	int	src_port;
+	int	src_port_vir;
+	int	parserulebm;
+	char	l2keyname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_key_t	match_key;
+	unsigned int		rule_idx = 0;
+	int			rc;
+	int			parsedargs_max = 0;
+
+	numparms = count_parameters(buf);
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+		parsedargs_max = l2ruleadd_max - 1;
+	else
+		parsedargs_max = l2ruleadd_max;
+
+	if (numparms != parsedargs_max) {
+		parm_error_completion(numparms, parsedargs_max, buf, tpm_sfs_help_no_rule_add);
+		return;
+	}
+
+	/* Get parameters */
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+		parsedargs = sscanf(buf, "%x %x %x %s",
+				&src_port, &src_port_vir, &parserulebm, l2keyname);
+	else
+		parsedargs = sscanf(buf, "%x %x %d %x %s",
+				&src_port, &src_port_vir, &rule_type, &parserulebm, l2keyname);
+
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else {
+		memcpy(&match_key, &pdbl2keyentry->key, sizeof(match_key));
+		match_key.rule_type = rule_type;
+		match_key.field_match_bm = parserulebm;
+		match_key.port.port_type = src_port;
+		match_key.port.class_port = src_port_vir;
+		if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+			rc = _mv_tpm_exact_match_except_rule_del(&match_key, rule_idx);
+		else if (api_type == TPM_API_PUBLIC_CLS)
+			rc = _mv_tpm_gen_cls_rule_del(&match_key, rule_idx);
+		else
+			rc = _mv_tpm_filter_rule_del(&match_key, rule_idx);
+
+		if (rc == TPM_OK) {
+			PR_RULE_IDX(rule_idx)
+		} else {
+			printk(KERN_INFO "%s: tpm_del_rule failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_exact_except_key_set
+*
+* DESCRIPTION:
+*           This function deletes a L2 HW rule (PNC)
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_exact_except_key_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_no_cls_cpu_rule_add_set(buf, len, TPM_API_PUBLIC_EXCT_EXCPT);
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_cls_key_set
+*
+* DESCRIPTION:
+*           This function deletes a CLS HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_cls_key_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_no_cls_cpu_rule_add_set(buf, len, TPM_API_PUBLIC_CLS);
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_filter_key_set
+*
+* DESCRIPTION:
+*           This function deletes a filter HW rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_filter_key_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_no_cls_cpu_rule_add_set(buf, len, TPM_API_PUBLIC_FLTR);
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_mc_set
+*
+* DESCRIPTION:
+*           This function deletes a multicast rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_mc_set(const char *buf, size_t len)
+{
+	enum noruleaddmc_parm_indx_t {
+		noruleaddmc_idx = 0, noruleaddmc_max
+	};
+	/* shell line parsing */
+	unsigned int             rule_idx;
+	int                      parsedargs;
+	int                      numparms;
+	/* Used in API call */
+	int         rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != noruleaddmc_max) {
+		parm_error_completion(numparms, noruleaddmc_max, buf, tpm_sfs_help_no_rule_add);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &rule_idx);
+
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		} else {
+			rc = _mv_tpm_mc_flow_del(rule_idx);
+			if (rc == TPM_OK) {
+				PR_RESULT_OK
+			} else {
+				printk(KERN_INFO "%s: multicast rule del failed, rc[%d] - %s\n",
+				       __func__, rc, get_tpm_err_str(rc));
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_no_rule_add_mc_all_set
+*
+* DESCRIPTION:
+*           This function deletes all valid multicast rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_no_rule_add_mc_all_set(const char *buf, size_t len)
+{
+	int rc;
+	rc = _mv_tpm_mc_flow_del_all();
+	if (rc == TPM_OK) {
+		PR_RESULT_OK
+	} else {
+		printk(KERN_INFO "%s: _mv_tpm_mc_flow_del_all failed, rc[%d] - %s\n",
+		       __func__, rc, get_tpm_err_str(rc));
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_cls_cpu_rule_add_set
+*
+* DESCRIPTION:
+*           This function creates a L2 rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_cls_cpu_rule_add_set(const char *buf, size_t len, enum tpm_mng_api_type_t api_type)
+{
+	enum eeruleadd_parm_indx_t {
+		eeruleadd_srcport_bm, eeruleadd_srcport_vir, eeruleadd_parserulebm, eeruleadd_key,
+		eeruleadd_frwd,  eeruleadd_color, eeruleadd_policer, eeruleadd_qos, eeruleadd_max
+	};
+	enum clsruleadd_parm_indx_t {
+		clsruleadd_srcport_bm, clsruleadd_srcport_vir, clsruleadd_rule_type, clsruleadd_parserulebm,
+		clsruleadd_key, clsruleadd_frwd, clsruleadd_dstnum, clsruleadd_color, clsruleadd_policer,
+		clsruleadd_qos, clsruleadd_modname, clsruleadd_max
+	};
+	enum mcruleadd_parm_indx_t {
+		mcruleadd_srcport_bm, mcruleadd_srcport_vir, mcruleadd_parserulebm, mcruleadd_key,
+		mcruleadd_frwd, mcruleadd_dstnum, mcruleadd_color, mcruleadd_modname, mcruleadd_max
+	};
+	/* shell line parsing */
+	char	qosname[20];
+	int	num_dest;/* Used for MC, other API type no used */
+	int	color;
+	int	policer;
+	int	rule_type = 0;
+	int	src_port;
+	int	src_port_vir;
+	int	parserulebm;
+	char	l2keyname[20];
+	char	frwdname[20];
+	char	modname[20];
+	int	parsedargs;
+	int	parsedargs_max;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_frwd_entry_t	*pdbfrwdentry  = 0;
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	struct tpmcfg_mod_entry_t	*pdbmodentry = 0;
+	struct tpmcfg_qos_entry_t	*pdbqosentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_action_t	rule_action[TPM_ACT_NUM_MAX];
+	struct tpm_pkt_key_t	match_key;
+	struct tpm_qos_t	qos;
+	unsigned int		rule_idx;
+	int			i;
+	int			rc;
+
+	numparms = count_parameters(buf);
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+		parsedargs_max = eeruleadd_max;
+	else if (api_type == TPM_API_PRIVATE_MC_DS)
+		parsedargs_max = mcruleadd_max;
+	else
+		parsedargs_max = clsruleadd_max;
+
+	if (numparms != parsedargs_max) {
+		if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+			parm_error_completion(numparms, parsedargs_max, buf, tpm_sys_help_exact_except_rule_add);
+		else if (api_type == TPM_API_PRIVATE_MC_DS)
+			parm_error_completion(numparms, parsedargs_max, buf, tpm_sfs_help_mc_rule_add);
+		else
+			parm_error_completion(numparms, parsedargs_max, buf, tpm_sfs_help_cls_rule_add);
+		return;
+	}
+	/* Get parameters */
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT) {
+		parsedargs = sscanf(buf, "%x %x %x %s %s %d %x %s",
+					&src_port, &src_port_vir, &parserulebm,
+					l2keyname, frwdname, &color, &policer, qosname);
+		strcpy(modname, "mod_empty");
+	} else if (api_type == TPM_API_PRIVATE_MC_DS) {
+		parsedargs = sscanf(buf, "%x %x %x %s %s %d %d %s",
+					&src_port, &src_port_vir, &parserulebm,
+					l2keyname, frwdname, &num_dest, &color, modname);
+		if (num_dest > TPM_ACT_NUM_MAX || num_dest == 0) {
+			printk(KERN_INFO "Invalid dest number(%d)\n", num_dest);
+			return;
+		}
+	} else {
+		parsedargs = sscanf(buf, "%x %x %d %x %s %s %d %d %x %s %s",
+					&src_port, &src_port_vir, &rule_type, &parserulebm,
+					l2keyname, frwdname, &num_dest, &color, &policer, qosname, modname);
+		if (num_dest > TPM_ACT_NUM_MAX || num_dest == 0) {
+			printk(KERN_INFO "Invalid dest number(%d)\n", num_dest);
+			return;
+		}
+	}
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname);
+	pdbmodentry = find_tpm_mod_entry_by_name(modname);
+	pdbqosentry = find_tpm_pkt_qos_entry_by_name(qosname);
+	if ((pdbl2keyentry == 0) && strcmp(l2keyname, key_empty_name) != 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else if ((pdbfrwdentry == 0) &&
+			strcmp(frwdname, frwd_empty_name) != 0) {
+		printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
+	} else if ((pdbmodentry == 0) &&
+			strcmp(modname, mod_empty_name) != 0) {
+		printk(KERN_INFO "mod entry [%s] not found\n", modname);
+	} else if ((pdbqosentry == 0) &&
+			strcmp(qosname, qos_empty_name) != 0 &&
+			api_type != TPM_API_PRIVATE_MC_DS) {
+		printk(KERN_INFO "qos entry [%s] not found\n", qosname);
+	} else {
+		memset(&qos, 0, sizeof(qos));
+
+		if (pdbl2keyentry != 0)
+			memcpy(&match_key, &pdbl2keyentry->key, sizeof(match_key));
+		else
+			memset(&match_key, 0, sizeof(match_key));
+
+		if (pdbfrwdentry != 0) {
+			for (i = 0 ; i < TPM_ACT_NUM_MAX; i++)
+				memcpy(&rule_action[i].dest, &pdbfrwdentry->frwd[i], sizeof(rule_action[i].dest));
+		} else {
+			for (i = 0 ; i < TPM_ACT_NUM_MAX; i++)
+				memset(&rule_action[i].dest, 0, sizeof(rule_action[i].dest));
+		}
+
+		if (pdbmodentry != 0) {
+			for (i = 0 ; i < TPM_ACT_NUM_MAX; i++)
+				memcpy(&rule_action[i].mod, &pdbmodentry->mod[i],     sizeof(rule_action[i].mod));
+		} else {
+			for (i = 0 ; i < TPM_ACT_NUM_MAX; i++)
+				memset(&rule_action[i].mod, 0,                     sizeof(rule_action[i].mod));
+		}
+
+		for (i = 0 ; i < TPM_ACT_NUM_MAX; i++)
+			rule_action[i].color = color;
+		match_key.rule_type = rule_type;
+		match_key.field_match_bm = parserulebm;
+		match_key.port.port_type = src_port;
+		match_key.port.class_port = src_port_vir;
+
+		if (pdbqosentry != 0) {
+			qos.qos_sel = pdbqosentry->tbl_type;
+			qos.qos_tbl = pdbqosentry->tbl_id;
+		}
+
+		if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+			rc = _mv_tpm_exact_match_except_rule_add(
+							&match_key,
+							&rule_action[0],
+							policer,
+							&qos,
+							&rule_idx);
+		else if (api_type == TPM_API_PRIVATE_MC_DS)
+			rc = _mv_tpm_mc_flow_add(&match_key, num_dest, rule_action, &rule_idx);
+		else
+			rc = _mv_tpm_gen_cls_rule_add(
+						&match_key,
+						num_dest,
+						&rule_action[0],
+						policer,
+						&qos,
+						&rule_idx);
+		if (rc == TPM_OK) {
+			PR_RULE_IDX(rule_idx)
+		} else {
+			printk(KERN_INFO "%s: tpm_add_rule failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_cnm_rule_add_set
+*
+* DESCRIPTION:
+*           This function creates a cnm rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_cnm_rule_add_set(const char *buf, size_t len)
+{
+	enum cnmruleadd_parm_indx_t {
+		cnmruleadd_srcport, cnmruleadd_rule_num, cnmruleadd_field_op_name, cnmruleadd_key,
+		cnmruleadd_queue,  cnmruleadd_pbit, cnmruleadd_max
+	};
+	/* shell line parsing */
+	int	src_port;
+	int	rule_num;
+	int	pbit;
+	int	loop;
+	int	queue;
+	char	l2keyname[20];
+	char	fieldopname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	struct tpmcfg_cnm_field_op_entry_t	*pdbfieldopentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_action_t	rule_action;
+	struct tpm_cnm_key_t	cnm_key;
+	int			rc;
+
+	numparms = count_parameters(buf);
+
+	if (numparms != cnmruleadd_max) {
+		parm_error_completion(numparms, cnmruleadd_max, buf, tpm_sfs_help_cnm_rule_add);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%d %d %s %s %d %x",
+				&src_port, &rule_num, l2keyname,
+				fieldopname, &queue, &pbit);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	pdbfieldopentry = find_tpm_cnm_field_op_entry_by_name(fieldopname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else if (pdbfieldopentry == 0) {
+		printk(KERN_INFO "cnm_field_op entry [%s] not found\n", fieldopname);
+	} else {
+		TPM_MEMSET_ZERO(rule_action);
+		TPM_MEMSET_ZERO(cnm_key);
+
+		rule_action.dest.pp_queue = queue;
+		if (pbit & TPM_PBIT_UPDATE) {
+			rule_action.mod.mod_bm = TPM_VLAN_MOD;
+			rule_action.mod.vlan_op.oper = VLANOP_EXT_TAG_MOD;
+			rule_action.mod.vlan_op.out_vlan.pbit = pbit;
+		}
+
+		cnm_key.rule_num = rule_num;
+		memcpy(cnm_key.field_op, pdbfieldopentry->field_op, sizeof(cnm_key.field_op));
+		memcpy(&cnm_key.match_key, &pdbl2keyentry->key,
+			sizeof(cnm_key.match_key));
+		cnm_key.match_key.port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+		cnm_key.match_key.port.class_port = (1 << src_port);
+		/* get field num */
+		for (loop = 0; loop < TPM_CNM_FIELD_MAX; loop++)
+			if (!pdbfieldopentry->field_op[loop].field)
+				break;
+		cnm_key.field_num = loop;
+		rc = _mv_tpm_cm_rule_add(&cnm_key, &rule_action);
+		if (rc == TPM_OK) {
+			PR_RULE_IDX(rule_num)
+		} else {
+			printk(KERN_INFO "%s: _mv_tpm_cm_rule_add failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_exact_rule_add_set
+*
+* DESCRIPTION:
+*           This function creates a L3 rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_exact_rule_add_set(const char *buf, size_t len)
+{
+	enum l2ruleadd_parm_indx_t {
+		l2ruleadd_srcport_bm, l2ruleadd_srcport_vir, l2ruleadd_parserulebm, l2ruleadd_key,
+		l2ruleadd_frwd,  l2ruleadd_color, l2ruleadd_policer, l2ruleadd_modname, l2ruleadd_max
+	};
+	/* shell line parsing */
+	int	color;
+	int	policer;
+	int	src_port;
+	int	src_port_vir;
+	int	ip_version;
+	char	l2keyname[20];
+	char	frwdname[20];
+	char	modname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_frwd_entry_t	*pdbfrwdentry  = 0;
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	struct tpmcfg_mod_entry_t	*pdbmodentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_action_t	rule_action;
+	struct tpm_exact_match_t	match_key;
+	unsigned int		rule_idx;
+	int			rc;
+
+	numparms = count_parameters(buf);
+
+	if (numparms != l2ruleadd_max) {
+		parm_error_completion(numparms, l2ruleadd_max, buf, tpm_sys_help_exact_rule_add);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%x %x %d %s %s %s %d %x",
+				&src_port, &src_port_vir, &ip_version,
+				l2keyname, frwdname, modname, &color, &policer);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname);
+	pdbmodentry = find_tpm_mod_entry_by_name(modname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else if (pdbfrwdentry == 0) {
+		printk(KERN_INFO "frwd entry [%s] not found\n", frwdname);
+	} else if ((pdbmodentry == 0) && strcmp(modname, mod_empty_name) != 0) {
+		printk(KERN_INFO "mod entry [%s] not found\n", modname);
+	} else {
+
+		match_key.ipvx_five_t.l4_dst = pdbl2keyentry->key.l4_dst;
+		match_key.ipvx_five_t.l4_src = pdbl2keyentry->key.l4_src;
+		match_key.ipvx_five_t.l4_proto = pdbl2keyentry->key.ipvx_add.ip_proto;
+		memcpy(&match_key.ipvx_five_t.ip_dst,
+			&pdbl2keyentry->key.ipvx_add.ip_dst.ip_add,
+			sizeof(match_key.ipvx_five_t.ip_dst));
+		memcpy(&match_key.ipvx_five_t.ip_src,
+			&pdbl2keyentry->key.ipvx_add.ip_src.ip_add,
+			sizeof(match_key.ipvx_five_t.ip_src));
+		match_key.ipvx_five_t.ip_ver = ip_version;
+
+		match_key.port.port_type = src_port;
+		match_key.port.class_port = src_port_vir;
+
+		if (pdbmodentry != 0)
+			memcpy(&rule_action.mod, &pdbmodentry->mod,     sizeof(rule_action.mod));
+		else
+			memset(&rule_action.mod, 0,                     sizeof(rule_action.mod));
+
+		if (pdbfrwdentry != 0)
+			memcpy(&rule_action.dest, &pdbfrwdentry->frwd, sizeof(rule_action.dest));
+		else
+			memset(&rule_action.dest, 0, sizeof(rule_action.dest));
+
+		rule_action.color = color;
+
+		rc = _mv_tpm_exact_match_rule_add(
+						&match_key,
+						1, /* Curently only one dst supported */
+						&rule_action,
+						policer,
+						&rule_idx);
+		if (rc == TPM_OK) {
+			PR_RULE_IDX(rule_idx)
+		} else {
+			printk(KERN_INFO "%s: tpm_add_rule failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_l2_rule_add_set
+*
+* DESCRIPTION:
+*           This function creates a L2 rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_exact_except_rule_add_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_add_set(buf, len, TPM_API_PUBLIC_EXCT_EXCPT);
+}
+void tpm_sfs_cfg_cls_rule_add_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_add_set(buf, len, TPM_API_PUBLIC_CLS);
+}
+void tpm_sfs_cfg_filter_rule_add_set(const char *buf, size_t len)
+{
+	enum filter_ruleadd_parm_indx_t {
+		ruleadd_srcport_bm, ruleadd_srcport_vir, ruleadd_rule_type,
+		ruleadd_parserulebm, ruleadd_key, ruleadd_frwd, ruleadd_max
+	};
+	/* shell line parsing */
+	int	rule_type = 0;
+	int	frwd_mode;
+	int	src_port;
+	int	src_port_vir;
+	int	parserulebm;
+	char	l2keyname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_key_t	match_key;
+	unsigned int		rule_idx;
+	int			rc;
+
+	numparms = count_parameters(buf);
+
+	if (numparms != ruleadd_max) {
+		parm_error_completion(numparms, ruleadd_max, buf, tpm_sfs_help_filter_rule_add);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%x %x %d %x %s %d",
+			&src_port, &src_port_vir, &rule_type, &parserulebm,
+			l2keyname, &frwd_mode);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else if (frwd_mode > TPM_FILTER_FRWD_NO_DROP) {
+		printk(KERN_INFO "frwd_mode[%d] is invalid\n", frwd_mode);
+	} else {
+
+		memcpy(&match_key, &pdbl2keyentry->key, sizeof(match_key));
+
+		match_key.rule_type = rule_type;
+		match_key.field_match_bm = parserulebm;
+		match_key.port.port_type = src_port;
+		match_key.port.class_port = src_port_vir;
+
+		rc = _mv_tpm_filter_rule_add(
+					&match_key,
+					frwd_mode,
+					&rule_idx);
+		if (rc == TPM_OK) {
+			PR_RULE_IDX(rule_idx)
+		} else {
+			printk(KERN_INFO "%s: _mv_tpm_filter_rule_add failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+	}
+}
+
+
+void tpm_sfs_cfg_exact_rule_get(const char *buf, size_t len)
+{
+	sfs_tpm_cfg_api_rule_dump(buf, len, TPM_API_PRIVATE_EXCT);
+}
+
+void tpm_sfs_cfg_exact_except_rule_get(const char *buf, size_t len)
+{
+	sfs_tpm_cfg_api_rule_dump(buf, len, TPM_API_PUBLIC_EXCT_EXCPT);
+}
+void tpm_sfs_cfg_cls_rule_get(const char *buf, size_t len)
+{
+	sfs_tpm_cfg_api_rule_dump(buf, len, TPM_API_PUBLIC_CLS);
+}
+void tpm_sfs_cfg_filter_rule_get(const char *buf, size_t len)
+{
+	sfs_tpm_cfg_api_rule_dump(buf, len, TPM_API_PUBLIC_FLTR);
+}
+
+void tpm_sfs_cfg_mc_rule_get(const char *buf, size_t len)
+{
+	sfs_tpm_cfg_api_rule_dump(buf, len, TPM_API_PRIVATE_MC_DS);
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mc_rule_add_set
+*
+* DESCRIPTION:
+*           This function creates a multicast rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mc_rule_add_set(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_add_set(buf, len, TPM_API_PRIVATE_MC_DS);
+}
+
+
+/*******************************************************************************
+* tpm_sfs_cfg_cls_cpu_exact_rule_add_set
+*
+* DESCRIPTION:
+*           This function del a L2 rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_cls_cpu_rule_cntr_get(const char *buf, size_t len, enum tpm_mng_api_type_t api_type)
+{
+	enum l2ruleadd_parm_indx_t {
+		l2ruleadd_srcport_bm, l2ruleadd_srcport_vir, l2ruleadd_rule_type, l2ruleadd_parserulebm, l2ruleadd_key,
+		l2ruleadd_ruleid, l2ruleadd_max
+	};
+	/* shell line parsing */
+	int	rule_type = 0;
+	int	rule_id = 0;
+	int	src_port;
+	int	src_port_vir;
+	int	parserulebm;
+	char	l2keyname[20];
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	/* Used in API call */
+	struct tpm_pkt_key_t	match_key;
+	int			rc;
+	int			cntrs;
+	int			parsedargs_max = 0;
+
+	numparms = count_parameters(buf);
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+		parsedargs_max = l2ruleadd_max - 1;
+	else
+		parsedargs_max = l2ruleadd_max;
+
+	if (numparms != parsedargs_max) {
+		parm_error_completion(numparms, parsedargs_max, buf, tpm_sfs_help_no_rule_add);
+		return;
+	}
+
+	/* Get parameters */
+	if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+		parsedargs = sscanf(buf, "%x %x %x %s %d",
+				&src_port, &src_port_vir, &parserulebm, l2keyname, &rule_id);
+	else
+		parsedargs = sscanf(buf, "%x %x %d %x %s %d",
+				&src_port, &src_port_vir, &rule_type, &parserulebm, l2keyname, &rule_id);
+
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	if (pdbl2keyentry == 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else {
+		if (0 == rule_id) {
+			memcpy(&match_key, &pdbl2keyentry->key, sizeof(match_key));
+			match_key.rule_type = rule_type;
+			match_key.field_match_bm = parserulebm;
+			match_key.port.port_type = src_port;
+			match_key.port.class_port = src_port_vir;
+
+			if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+				rc = _mv_tpm_exact_match_except_rule_cntr_get(&match_key, rule_id, &cntrs);
+			else if (api_type == TPM_API_PUBLIC_CLS)
+				rc = _mv_tpm_gen_cls_rule_cntr_get(&match_key, rule_id, &cntrs);
+			else
+				rc = _mv_tpm_filter_rule_cntr_get(&match_key, rule_id, &cntrs);
+		} else {
+			if (api_type == TPM_API_PUBLIC_EXCT_EXCPT)
+				rc = _mv_tpm_exact_match_except_rule_cntr_get(NULL, rule_id, &cntrs);
+			else if (api_type == TPM_API_PUBLIC_CLS)
+				rc = _mv_tpm_gen_cls_rule_cntr_get(NULL, rule_id, &cntrs);
+			else
+				rc = _mv_tpm_filter_rule_cntr_get(NULL, rule_id, &cntrs);
+		}
+		if (rc == TPM_OK) {
+			PR_HIT_COUNT(cntrs)
+		} else {
+			printk(KERN_INFO "%s: tpm_rule_cntrs_get failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		}
+
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_exact_except_cntr_get
+*
+* DESCRIPTION:
+*           This function gets a exact_except HW rule cntrs
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_exact_except_cntr_get(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_cntr_get(buf, len, TPM_API_PUBLIC_EXCT_EXCPT);
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_cls_cntr_get
+*
+* DESCRIPTION:
+*           This function gets a CLS HW rule cntrs
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_cls_cntr_get(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_cntr_get(buf, len, TPM_API_PUBLIC_CLS);
+}
+/*******************************************************************************
+* tpm_sfs_cfg_filter_cntr_get
+*
+* DESCRIPTION:
+*           This function gets a filter HW rule cntrs
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_filter_cntr_get(const char *buf, size_t len)
+{
+	tpm_sfs_cfg_cls_cpu_rule_cntr_get(buf, len, TPM_API_PUBLIC_FLTR);
+}
+/*******************************************************************************
+* tpm_sfs_cfg_filter_def_cntr_get
+*
+* DESCRIPTION:
+*           This function gets a filter default rule HW rule cntrs
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_filter_def_cntr_get(const char *buf, size_t len)
+{
+	enum tpm_filter_set_para_idx {
+		tpm_filter_set_rule_type = 0,
+		tpm_filter_set_bm,
+		tpm_filter_set_vlan_num,
+		tpm_filter_set_max
+	};
+	unsigned int cntrs;
+	unsigned int rule_type;
+	unsigned int bm;
+	unsigned int vlan_number;
+
+	int parsed_args;
+	int param_num;
+	int rc;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpm_filter_set_max)
+		parm_error_completion(param_num, tpm_filter_set_max, buf, tpm_sfs_help_filter_def_rule_cntr_get);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %x %d", &rule_type, &bm, &vlan_number);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			rc = _mv_tpm_filter_def_rule_cntr_get(rule_type, bm, vlan_number, &cntrs);
+			if (rc == TPM_OK) {
+				PR_HIT_COUNT(cntrs);
+			} else {
+				printk(KERN_INFO "%s: tpm_rule_cntrs_get failed, rc[%d] - %s\n",
+					__func__, rc, get_tpm_err_str(rc));
+			}
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_exact_cntr_get
+*
+* DESCRIPTION:
+*           This function gets a exact HW rule cntrs
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_cfg_exact_cntr_get(const char *buf, size_t len)
+{
+	enum l2ruleadd_parm_indx_t {
+		l2ruleadd_parserulebm, l2ruleadd_key, l2ruleadd_ruleid, l2ruleadd_max
+	};
+	/* shell line parsing */
+	int	ip_version;
+	char	l2keyname[20];
+	int	parsedargs;
+	int	numparms;
+	int	rule_id;
+	/* DB */
+	struct tpmcfg_pkt_key_entry_t	*pdbl2keyentry = 0;
+	/* Used in API call */
+	struct tpm_exact_match_t	match_key;
+	int			rc;
+	unsigned int cntrs;
+
+	numparms = count_parameters(buf);
+
+	if (numparms != l2ruleadd_max) {
+		parm_error_completion(numparms, l2ruleadd_max, buf, tpm_sys_help_exact_rule_cntr_get);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%d %s %d", &ip_version, l2keyname, &rule_id);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbl2keyentry = find_tpm_pkt_key_entry_by_name(l2keyname);
+	if ((pdbl2keyentry == 0) && strcmp(l2keyname, key_empty_name) != 0) {
+		printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+	} else {
+
+		if (0 == rule_id) {
+			if (NULL == pdbl2keyentry) {
+				printk(KERN_INFO "Key entry [%s] not found\n", l2keyname);
+				return;
+			}
+			match_key.ipvx_five_t.l4_dst = pdbl2keyentry->key.l4_dst;
+			match_key.ipvx_five_t.l4_src = pdbl2keyentry->key.l4_src;
+			match_key.ipvx_five_t.l4_proto = pdbl2keyentry->key.ipvx_add.ip_proto;
+			memcpy(&match_key.ipvx_five_t.ip_dst,
+				&pdbl2keyentry->key.ipvx_add.ip_dst.ip_add,
+				sizeof(match_key.ipvx_five_t.ip_dst));
+			memcpy(&match_key.ipvx_five_t.ip_src,
+				&pdbl2keyentry->key.ipvx_add.ip_src.ip_add,
+				sizeof(match_key.ipvx_five_t.ip_src));
+			match_key.ipvx_five_t.ip_ver = ip_version;
+
+			rc = _mv_tpm_exact_match_rule_cntr_get(&match_key.ipvx_five_t, 0, &cntrs);
+		} else
+			rc = _mv_tpm_exact_match_rule_cntr_get(NULL, rule_id, &cntrs);
+
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "%s: tpm_mng_cap_entry_cntr_get failed, rc[%d] - %s\n",
+				__func__, rc, get_tpm_err_str(rc));
+		} else
+			PR_HIT_COUNT(cntrs)
+	}
+}
+
+/*************************Modification Section******************************/
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_bm_set
+*
+* DESCRIPTION:
+*           This function set the mod bitmap for corresponding fields.
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_bm_set(const char *buf, size_t len)
+{
+	enum mod_l4port_rule_parm_indx_t {
+		mod_bm_name = 0,
+		mod_array_idx,
+		mod_bm_val,
+		mod_bm_max
+	};
+	unsigned int        mod_bm;
+	unsigned int        mod_idx;
+	char                name[100];
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != mod_bm_max) {
+		parm_error_completion(numparms, mod_bm_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %x", name, &mod_idx, &mod_bm);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->mod[mod_idx].mod_bm = mod_bm;
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sys_cfg_mod_mac_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies MAC address part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sys_cfg_mod_mac_addr_rule_set(const char *buf, size_t len)
+{
+	enum mod_mac_rule_parm_indx_t {
+		mod_mac_name = 0,
+		mod_array_idx,
+		mod_mac_sa,
+		mod_mac_sa_mask,
+		mod_mac_da,
+		mod_mac_da_mask,
+		mod_mac_max
+	};
+	char                temp_sa[30];
+	char                temp_sa_mask[30];
+	char                temp_da[30];
+	char                temp_da_mask[30];
+	unsigned int        mod_idx;
+	unsigned int        sa[MAC_ADDR_SIZE];
+	unsigned int        sa_mask[MAC_ADDR_SIZE];
+	unsigned int        da[MAC_ADDR_SIZE];
+	unsigned int        da_mask[MAC_ADDR_SIZE];
+	char                name[100];
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+	int                 i;
+
+	numparms = count_parameters(buf);
+	if (numparms != mod_mac_max) {
+		parm_error_completion(numparms, mod_mac_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %s %s %s %s",
+				name, &mod_idx, temp_sa, temp_sa_mask, temp_da, temp_da_mask);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (parse_mac_address(temp_sa, sa) == false) {
+			printk(KERN_INFO "Invalid SA [%s]\n", temp_sa);
+		} else if (parse_mac_address(temp_sa_mask, sa_mask) == false) {
+			printk(KERN_INFO "Invalid SA mask [%s]\n", temp_sa_mask);
+		} else if (parse_mac_address(temp_da, da) == false) {
+			printk(KERN_INFO "Invalid DA [%s]\n", temp_da);
+		} else if (parse_mac_address(temp_da_mask, da_mask) == false) {
+			printk(KERN_INFO "Invalid DA mask [%s]\n", temp_da_mask);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_MAC;
+				for (i = 0; i < MAC_ADDR_SIZE; i++) {
+					/* According to mask to determine which MAC is modified */
+					pentry->mod[mod_idx].eth_src[i] = (unsigned char)sa[i];
+					pentry->mod[mod_idx].eth_dst[i] = (unsigned char)da[i];
+				}
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+
+/*******************************************************************************
+* tpm_sys_cfg_mod_vlan_key_set
+*
+* DESCRIPTION:
+*           This function adds/modifies VLAN key for modification
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sys_cfg_mod_vlan_key_set(const char *buf, size_t len)
+{
+	enum vlan_rule_parm_indx_t {
+		vrpi_name = 0,
+		vrpi_tpid,
+		vrpi_tpid_mask,
+		vrpi_vid,
+		vrpi_vid_mask,
+		vrpi_cfi,
+		vrpi_cfi_mask,
+		vrpi_pbit,
+		vrpi_pbit_mask,
+		vrpi_max
+	};
+	unsigned int        temp_tpid;
+	unsigned int        temp_tpid_mask;
+	unsigned int        temp_vid;
+	unsigned int        temp_vid_mask;
+	unsigned int        temp_cfi;
+	unsigned int        temp_cfi_mask;
+	unsigned int        temp_pbit;
+	unsigned int        temp_pbit_mask;
+	char                name[100];
+	int                 parsedargs;
+	int                 numparms = 0;
+	struct tpmcfg_pkt_key_entry_t *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != vrpi_max) {
+		parm_error_completion(numparms, vrpi_max, buf, tpm_sfs_help_mod_vlan_key_cfg);
+	} else {
+		parsedargs = sscanf(buf, "%s %x %x %d %x %d %x %d %x", name, &temp_tpid, &temp_tpid_mask, &temp_vid,
+					&temp_vid_mask, &temp_cfi, &temp_cfi_mask, &temp_pbit, &temp_pbit_mask);
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_tpid > 0xFFFF) {
+			printk(KERN_INFO "Invalid TPID [0x%x]\n", temp_tpid);
+		} else if (temp_tpid_mask > 0xFFFF) {
+			printk(KERN_INFO "Invalid TPID mask [0x%x]\n", temp_tpid_mask);
+		} else if (temp_vid > 4095) {
+			printk(KERN_INFO "Invalid VID [%d]\n", temp_vid);
+		} else if (temp_vid_mask > 0xFFFF) {
+			printk(KERN_INFO "Invalid VID mask [0x%x]\n", temp_vid_mask);
+		} else if (temp_cfi > 1) {
+			printk(KERN_INFO "Invalid CFI [%d]\n", temp_cfi);
+		} else if (temp_cfi_mask > 0xFF) {
+			printk(KERN_INFO "Invalid CFI mask [0x%x]\n", temp_cfi_mask);
+		} else if (temp_pbit > 7) {
+			printk(KERN_INFO "Invalid pbit [%d]\n", temp_pbit);
+		} else if (temp_pbit_mask > 0xFF) {
+			printk(KERN_INFO "Invalid pbit mask [0x%x]\n", temp_pbit_mask);
+		} else {
+			pentry = find_tpm_pkt_key_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_pkt_key_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "KEY DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->vlan_mod_key.tpid = (unsigned short)temp_tpid;
+				if (temp_tpid_mask == 0xFFFF)
+					pentry->vlan_mod_key.tpid |= TPM_TPID_UPDATE;
+				else
+					pentry->vlan_mod_key.tpid &= (~TPM_TPID_UPDATE);
+				pentry->vlan_mod_key.vid = (unsigned short)temp_vid;
+				if (temp_vid_mask == 0xFFFF)
+					pentry->vlan_mod_key.vid |= TPM_VID_UPDATE;
+				else
+					pentry->vlan_mod_key.vid &= (~TPM_VID_UPDATE);
+				pentry->vlan_mod_key.cfi = (unsigned char)temp_cfi;
+				if (temp_cfi_mask == 0xFF)
+					pentry->vlan_mod_key.cfi |= TPM_CFI_UPDATE;
+				else
+					pentry->vlan_mod_key.cfi &= (~TPM_CFI_UPDATE);
+				pentry->vlan_mod_key.pbit = (unsigned char) temp_pbit;
+				if (temp_pbit_mask == 0xFF)
+					pentry->vlan_mod_key.pbit |= TPM_PBIT_UPDATE;
+				else
+					pentry->vlan_mod_key.pbit &= (~TPM_PBIT_UPDATE);
+
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_vlan_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies vlan part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_vlan_rule_set(const char *buf, size_t len)
+{
+	enum mod_vlan_rule_parm_indx_t {
+		mvrpi_name = 0,
+		mod_array_idx,
+		mvrpi_oper,
+		mvrpi_vlan1,
+		mvrpi_vlan2,
+		mvrpi_max
+	};
+	char                name[100];
+	unsigned int        mod_idx;
+	unsigned int        vlan_op;
+	char                vlan_op_str[30];
+	char                vlan1_name[100];
+	char                vlan2_name[100];
+	int                 parsedargs;
+	int                 numparms;
+	bool		    bRet;
+	struct tpmcfg_mod_entry_t  *pentry;
+	struct tpmcfg_pkt_key_entry_t *pvlan1entry = 0;
+	struct tpmcfg_pkt_key_entry_t *pvlan2entry = 0;
+	const char *vlan_empty_name = "vlan_empty";
+
+	numparms = count_parameters(buf);
+	if (numparms != mvrpi_max) {
+		parm_error_completion(numparms, mvrpi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %s %s %s", name, &mod_idx, vlan_op_str, vlan1_name, vlan2_name);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		bRet = get_vlan_op_value(vlan_op_str, &vlan_op);
+		pvlan1entry = find_tpm_pkt_key_entry_by_name(vlan1_name);
+		pvlan2entry = find_tpm_pkt_key_entry_by_name(vlan2_name);
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (bRet == false) {
+			printk(KERN_INFO "Invalid vlan_op[%s]\n", vlan_op_str);
+		} else if ((pvlan1entry == 0) &&
+			strcmp(vlan1_name, vlan_empty_name) != 0) {
+			printk(KERN_INFO "vlan1 entry [%s] not found\n", vlan1_name);
+		} else if ((pvlan2entry == 0) &&
+			strcmp(vlan2_name, vlan_empty_name) != 0) {
+			printk(KERN_INFO "vlan2 entry [%s] not found\n", vlan2_name);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_VLAN;
+				pentry->mod[mod_idx].vlan_op.oper = vlan_op;
+				if (pvlan1entry != 0) {
+					pentry->mod[mod_idx].vlan_op.out_vlan.tpid = pvlan1entry->vlan_mod_key.tpid;
+					pentry->mod[mod_idx].vlan_op.out_vlan.vid = pvlan1entry->vlan_mod_key.vid;
+					pentry->mod[mod_idx].vlan_op.out_vlan.pbit = pvlan1entry->vlan_mod_key.pbit;
+					pentry->mod[mod_idx].vlan_op.out_vlan.cfi = pvlan1entry->vlan_mod_key.cfi;
+				} else {
+					memset(&pentry->mod[mod_idx].vlan_op.out_vlan,
+						0, sizeof(struct tpm_vlan_mod_t));
+				}
+
+				if (pvlan2entry != 0) {
+					pentry->mod[mod_idx].vlan_op.inn_vlan.tpid = pvlan2entry->vlan_mod_key.tpid;
+					pentry->mod[mod_idx].vlan_op.inn_vlan.vid = pvlan2entry->vlan_mod_key.vid;
+					pentry->mod[mod_idx].vlan_op.inn_vlan.pbit = pvlan2entry->vlan_mod_key.pbit;
+					pentry->mod[mod_idx].vlan_op.inn_vlan.cfi = pvlan2entry->vlan_mod_key.cfi;
+				} else {
+					memset(&pentry->mod[mod_idx].vlan_op.inn_vlan,
+						0, sizeof(struct tpm_vlan_mod_t));
+				}
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_pppoe_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies PPPoE part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_pppoe_rule_set(const char *buf, size_t len)
+{
+	enum mod_pppoe_rule_parm_indx_t {
+		mpppoepi_name = 0,
+		mod_array_idx,
+		mpppoepi_session,
+		mpppoepi_prototype,
+		mpppoepi_max
+	};
+	unsigned int        temp_session;
+	unsigned int        temp_prototype;
+	char                name[100];
+	unsigned int        mod_idx;
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != mpppoepi_max) {
+		parm_error_completion(numparms, mpppoepi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %d %x", name, &mod_idx, &temp_session, &temp_prototype);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_session > 0xFFFF) {
+			printk(KERN_INFO "Invalid session [%d]\n", temp_session);
+		} else if (temp_prototype > 0xFFFF) {
+			printk(KERN_INFO "Invalid protocol type [0x%x]\n", temp_prototype);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_PPPOE;
+				pentry->mod[mod_idx].pppoe_mod.ppp_session = (unsigned short)temp_session;
+				pentry->mod[mod_idx].pppoe_mod.ppp_proto   = (unsigned short)temp_prototype;
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_dscp_rule_set
+*
+* DESCRIPTION:
+*           This function modifies DSCP part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_dscp_rule_set(const char *buf, size_t len)
+{
+	enum mod_dscp_rule_parm_indx_t {
+		mdspi_name = 0,
+		mod_array_idx,
+		mdspi_dscp,
+		mdspi_dscpmask,
+		mdspi_max
+	};
+	unsigned int        temp_dscp;
+	unsigned int        temp_dscp_mask;
+	char                name[100];
+	unsigned int        mod_idx;
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != mdspi_max) {
+		parm_error_completion(numparms, mdspi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %d %x", name, &mod_idx, &temp_dscp, &temp_dscp_mask);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_dscp > 0x3F) {
+			printk(KERN_INFO "Invalid dscp [%d]\n", temp_dscp);
+		} else if (temp_dscp_mask > 0xFF) {
+			printk(KERN_INFO "Invalid dscp mask [0x%x]\n", temp_dscp_mask);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_DSCP;
+				pentry->mod[mod_idx].ipvx.dscp = (unsigned char)temp_dscp;
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_ipv4_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies IPV4 address part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_ipv4_addr_rule_set(const char *buf, size_t len)
+{
+	enum mod_ipv4add_rule_parm_indx_t {
+		mipv4addpi_name = 0,
+		mod_array_idx,
+		mipv4addpi_srcip,
+		mipv4addpi_srcipmask,
+		mipv4addpi_dstip,
+		mipv4addpi_dstipmask,
+		mipv4addpi_max
+	};
+	char                temp_srcip[30];
+	char                temp_srcip_mask[30];
+	char                temp_dstip[30];
+	char                temp_dstip_mask[30];
+	unsigned int        srcip[4];
+	unsigned int        srcip_mask[4];
+	unsigned int        dstip[4];
+	unsigned int        dstip_mask[4];
+	char                name[100];
+	unsigned int        mod_idx;
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+	int i;
+
+	numparms = count_parameters(buf);
+	if (numparms != mipv4addpi_max) {
+		parm_error_completion(numparms, mipv4addpi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %s %s %s %s",
+				    name, &mod_idx, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (parse_ipv4_address(temp_srcip, srcip) == false) {
+			printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
+		} else if (parse_ipv4_address(temp_srcip_mask, srcip_mask) == false) {
+			printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
+		} else if (parse_ipv4_address(temp_dstip, dstip) == false) {
+			printk(KERN_INFO "Invalid dstip [%s]\n", temp_dstip);
+		} else if (parse_ipv4_address(temp_dstip_mask, dstip_mask) == false) {
+			printk(KERN_INFO "Invalid dstip mask [%s]\n", temp_dstip_mask);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else if (pentry->flags[mod_idx] & MOD_ENTRY_FLAG_IPV6) {
+				printk(KERN_INFO "IPV6 already defined for this entry!\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_IPV4;
+				for (i = 0; i < IPV4_ADDR_SIZE; i++) {
+					pentry->mod[mod_idx].ipvx.ip_src.ipv4[i] = (unsigned char)srcip[i];
+					pentry->mod[mod_idx].ipvx.ip_dst.ipv4[i] = (unsigned char)dstip[i];
+				}
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_ipv6_addr_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies IPV6 address part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_ipv6_addr_rule_set(const char *buf, size_t len)
+{
+	enum mod_ipv6add_rule_parm_indx_t {
+		mipv6addpi_name = 0,
+		mod_array_idx,
+		mipv6addpi_srcip,
+		mipv6addpi_srcipmask,
+		mipv6addpi_dstip,
+		mipv6addpi_dstipmask,
+		mipv6addpi_max
+	};
+	char                     temp_srcip[60];
+	char                     temp_srcip_mask[60];
+	char                     temp_dstip[60];
+	char                     temp_dstip_mask[60];
+	unsigned int             srcip[16];
+	unsigned int             srcip_mask[16];
+	unsigned int             dstip[16];
+	unsigned int             dstip_mask[16];
+	char                     name[100];
+	unsigned int             mod_idx;
+	int                      parsedargs;
+	int                      numparms;
+	int                      indx;
+	struct tpmcfg_mod_entry_t  *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != mipv6addpi_max) {
+		parm_error_completion(numparms, mipv6addpi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %s %s %s %s",
+				    name, &mod_idx, temp_srcip, temp_srcip_mask, temp_dstip, temp_dstip_mask);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (parse_ipv6_address(temp_srcip, srcip) == false) {
+			printk(KERN_INFO "Invalid srcip [%s]\n", temp_srcip);
+		} else if (parse_ipv6_address(temp_srcip_mask, srcip_mask) == false) {
+			printk(KERN_INFO "Invalid srcip mask [%s]\n", temp_srcip_mask);
+		} else if (parse_ipv6_address(temp_dstip, dstip) == false) {
+			printk(KERN_INFO "Invalid dstip [%s]\n", temp_dstip);
+		} else if (parse_ipv6_address(temp_dstip_mask, dstip_mask) == false) {
+			printk(KERN_INFO "Invalid dstip mask [%s]\n", temp_dstip_mask);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else if (pentry->flags[mod_idx] & MOD_ENTRY_FLAG_IPV4) {
+				printk(KERN_INFO "IPV4 already defined for this entry!\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_IPV6;
+				for (indx = 0; indx < IPV6_ADDR_SIZE; indx++) {
+					pentry->mod[mod_idx].ipvx.ip_src.ipv6[indx] = (unsigned char)srcip[indx];
+					pentry->mod[mod_idx].ipvx.ip_dst.ipv6[indx] = (unsigned char)dstip[indx];
+				}
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_cfg_mod_L4_port_rule_set
+*
+* DESCRIPTION:
+*           This function adds/modifies L4 port part of modification rule
+*
+* See sfs_tpm_cfg_set_frwd_rule() for INPUTS, OUTPUTS, RETURNS and COMMENTS details
+*
+*******************************************************************************/
+void tpm_sfs_cfg_mod_L4_port_rule_set(const char *buf, size_t len)
+{
+	enum mod_l4port_rule_parm_indx_t {
+		ml4portpi_name = 0,
+		mod_array_idx,
+		ml4portpi_srcport,
+		ml4portpi_dstport,
+		ml4portpi_max
+	};
+	unsigned int        temp_src_port;
+	unsigned int        temp_dst_port;
+	char                name[100];
+	unsigned int        mod_idx;
+	int                 parsedargs;
+	int                 numparms;
+	struct tpmcfg_mod_entry_t  *pentry;
+
+	numparms = count_parameters(buf);
+	if (numparms != ml4portpi_max) {
+		parm_error_completion(numparms, ml4portpi_max, buf, tpm_sfs_help_mod_rule_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%s %d %d %d", name, &mod_idx, &temp_src_port, &temp_dst_port);
+		if (mod_idx >= TPM_ACT_NUM_MAX) {
+			printk(KERN_INFO "Invalid mod array index [%d]\n", mod_idx);
+			return;
+		}
+
+		if (strlen(name) > DB_TPMCFG_MAX_NAME) {
+			printk(KERN_INFO "Name too long [%s]\n", name);
+		} else if (temp_src_port > 0xFFFF) {
+			printk(KERN_INFO "Invalid srcport [%d]\n", temp_src_port);
+		} else if (temp_dst_port > 0xFFFF) {
+			printk(KERN_INFO "Invalid dstport [%d]\n", temp_dst_port);
+		} else {
+			pentry = find_tpm_mod_entry_by_name(name);
+			if (pentry == 0)
+				pentry = find_free_tpm_mod_entry();
+
+			if (pentry == 0) {
+				printk(KERN_INFO "Mod DB full\n");
+			} else {
+				strcpy(pentry->name, name);
+				pentry->flags[mod_idx] |= MOD_ENTRY_FLAG_L4_PORT;
+				pentry->mod[mod_idx].ipvx.l4_src = (unsigned short)temp_src_port;
+				pentry->mod[mod_idx].ipvx.l4_dst = (unsigned short)temp_dst_port;
+				printk(KERN_INFO "OK\n");
+			}
+		}
+	}
+}
+
+/* Tx Rate Limit Related */
+
+/*******************************************************************************
+* tpm_sfs_tx_sched_port_mtu_set
+*
+* DESCRIPTION:
+*           This function will set the tx port MTU of minum number tockens
+*           required to allow packet transmission.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_tx_sched_port_mtu_set(const char *buf, size_t len)
+{
+	enum tx_sched_port_mtu_t {
+		tx_sched_gmac_idx = 0,
+		tx_sched_tcont_id,
+		tx_sched_mtu,
+		tx_sched_max
+	};
+	unsigned int gmac_id, tcont_id, mtu;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != tx_sched_max)
+		parm_error_completion(numparms, tx_sched_max, buf, tpm_sys_help_tx_sched_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d", &gmac_id, &tcont_id, &mtu);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = _mv_tpm_sched_egr_mtu_set(gmac_id, tcont_id, mtu);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_tx_sched_queue_mode_set
+*
+* DESCRIPTION:
+*           This function will set the tx queue schduling mode
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_tx_sched_queue_mode_set(const char *buf, size_t len)
+{
+	enum tx_sched_queue_mode_t {
+		tx_sched_gmac_idx = 0,
+		tx_sched_tcont_id,
+		tx_sched_queue_id,
+		tx_sched_mode,
+		tx_sched_wrr_weight,
+		tx_sched_max
+	};
+	unsigned int gmac_id, tcont_id, queue_id, mode, wrr_weight;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != tx_sched_max)
+		parm_error_completion(numparms, tx_sched_max, buf, tpm_sys_help_tx_sched_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %d %d", &gmac_id, &tcont_id, &queue_id, &mode, &wrr_weight);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = _mv_tpm_sched_egr_queue_mode_set(gmac_id, tcont_id, queue_id, mode, wrr_weight);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_tx_queue_rate_limit_set
+*
+* DESCRIPTION:
+*           This function will set the tx queue rate limit(band width).
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_tx_queue_rate_limit_set(const char *buf, size_t len)
+{
+	enum tx_sched_queue_rate_limit_t {
+		tx_sched_gmac_idx = 0,
+		tx_sched_tcont_id,
+		tx_sched_queue_id,
+		tx_sched_rate_limit,
+		tx_sched_buck_size,
+		tx_sched_max
+	};
+	unsigned int gmac_id, tcont_id, queue_id, rate, bucket_size;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != tx_sched_max)
+		parm_error_completion(numparms, tx_sched_max, buf, tpm_sys_help_tx_sched_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %d %d", &gmac_id, &tcont_id, &queue_id, &rate, &bucket_size);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = _mv_tpm_sched_egr_queue_rate_lim_set(gmac_id, tcont_id, queue_id, rate, bucket_size);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_tx_port_rate_limit_set
+*
+* DESCRIPTION:
+*           This function will set the tx port rate limit(band width).
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_tx_port_rate_limit_set(const char *buf, size_t len)
+{
+	enum tx_sched_port_rate_limit_t {
+		tx_sched_gmac_idx = 0,
+		tx_sched_tcont_id,
+		tx_sched_rate_limit,
+		tx_sched_buck_size,
+		tx_sched_max
+	};
+	unsigned int gmac_id, tcont_id, rate, bucket_size;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != tx_sched_max)
+		parm_error_completion(numparms, tx_sched_max, buf, tpm_sys_help_tx_sched_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %d", &gmac_id, &tcont_id, &rate, &bucket_size);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = _mv_tpm_sched_egr_port_rate_lim_set(gmac_id, tcont_id, rate, bucket_size);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+* tpm_sfs_qos_table_entry_set
+*
+* DESCRIPTION:
+*           This function will set a qos table entry.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_qos_table_entry_set(const char *buf, size_t len)
+{
+	enum qos_tbl_entry_set_t {
+		qos_tbl_entry_set_tbl_type = 0,
+		qos_tbl_entry_set_tbl_id,
+		qos_tbl_entry_set_entry_id,
+		qos_tbl_entry_set_frwd,
+		qos_tbl_entry_set_dscp,
+		qos_tbl_entry_set_pbit,
+		qos_tbl_entry_set_color,
+		qos_tbl_entry_set_max
+	};
+	char	frwdname[20];
+	struct tpmcfg_frwd_entry_t	*pdbfrwdentry  = 0;
+	struct tpm_qos_tbl_act_t	qos_cfg;
+	int tbl_type = 0;
+	int tbl_id = 0;
+	int entry_id = 0;
+	int dscp = 0;
+	int pbit = 0;
+	int color = 0;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != qos_tbl_entry_set_max)
+		parm_error_completion(numparms, qos_tbl_entry_set_max, buf, tpm_sfs_help_qos_tbl_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %s %d %d %d",
+			&tbl_type, &tbl_id, &entry_id, frwdname,
+			&dscp, &pbit, &color);
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+			return;
+		}
+
+		pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname);
+		if (pdbfrwdentry == 0) {
+			printk(KERN_INFO "frwd entry [%s] not found, FAIL\n", frwdname);
+		} else {
+			memcpy(&qos_cfg.pp_port, &pdbfrwdentry->frwd, sizeof(qos_cfg.pp_port));
+			qos_cfg.color = color;
+			qos_cfg.dscp = dscp;
+			qos_cfg.pbit = pbit;
+
+			tpm_ret = _mv_tpm_qos_table_entry_set(tbl_type, tbl_id, entry_id, &qos_cfg);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_qos_table_db_reset
+*
+* DESCRIPTION:
+*           This function will reset qos table db.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_qos_table_db_reset(const char *buf, size_t len)
+{
+	enum qos_tbl_entry_set_t {
+		qos_tbl_db_reset_tbl_type = 0,
+		qos_tbl_db_reset_max
+	};
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != qos_tbl_db_reset_max)
+		parm_error_completion(numparms, qos_tbl_db_reset_max, buf, tpm_sfs_help_qos_tbl_cfg);
+	else {
+		TPM_MEMSET_ZERO(g_qos_tbl);
+		printk(KERN_INFO "OK\n");
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_qos_table_entry_db_set
+*
+* DESCRIPTION:
+*           This function will set a qos table entry db.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_qos_table_entry_db_set(const char *buf, size_t len)
+{
+	enum qos_tbl_entry_db_set_t {
+		qos_tbl_entry_db_set_entry_id,
+		qos_tbl_entry_db_set_frwd,
+		qos_tbl_entry_db_set_dscp,
+		qos_tbl_entry_db_set_pbit,
+		qos_tbl_entry_db_set_color,
+		qos_tbl_entry_db_set_max
+	};
+	char	frwdname[20];
+	struct tpmcfg_frwd_entry_t	*pdbfrwdentry  = 0;
+	int entry_id = 0;
+	int dscp = 0;
+	int pbit = 0;
+	int color = 0;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != qos_tbl_entry_db_set_max)
+		parm_error_completion(numparms, qos_tbl_entry_db_set_max, buf, tpm_sfs_help_qos_tbl_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %s %d %d %d",
+			&entry_id, frwdname, &dscp, &pbit, &color);
+		if (parsedargs != numparms) {
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+			return;
+		}
+
+		pdbfrwdentry = find_tpm_pkt_frwd_entry_by_name(frwdname);
+		if (pdbfrwdentry == 0)
+			printk(KERN_INFO "frwd entry [%s] not found, FAIL\n", frwdname);
+		else if (entry_id > MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE)
+			printk(KERN_INFO "entry_id [%d] is not valid, FAIL\n", entry_id);
+		else {
+			memcpy(&g_qos_tbl[entry_id].pp_port, &pdbfrwdentry->frwd, sizeof(g_qos_tbl[entry_id].pp_port));
+			g_qos_tbl[entry_id].color = color;
+			g_qos_tbl[entry_id].dscp = dscp;
+			g_qos_tbl[entry_id].pbit = pbit;
+			printk(KERN_INFO "OK\n");
+		}
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+* tpm_sfs_qos_table_set
+*
+* DESCRIPTION:
+*           This function will set a qos table.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_qos_table_set(const char *buf, size_t len)
+{
+	enum qos_tbl_set_t {
+		qos_tbl_set_tbl_type = 0,
+		qos_tbl_set_tbl_id,
+		qos_tbl_set_max
+	};
+	int tbl_type = 0;
+	int tbl_id = 0;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != qos_tbl_set_max)
+		parm_error_completion(numparms, qos_tbl_set_max, buf, tpm_sfs_help_qos_tbl_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &tbl_type, &tbl_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = _mv_tpm_qos_table_set(tbl_type, tbl_id, g_qos_tbl);
+			if (TPM_OK == tpm_ret)
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_qos_table_get
+*
+* DESCRIPTION:
+*           This function will get a qos table.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+int tpm_sfs_qos_table_dump(enum tpm_qos_sel_t		qos_select,
+			 unsigned char			qos_tbl)
+{
+	int entry_id = 0;
+	int ret = 0;
+	int qos_tbl_size = 0;
+	struct tpm_db_qos_tbl_entry_t	qos_entry;
+	enum tpm_db_qos_status_t	status;
+	int ref_cnt = 0;
+
+	if (TPM_QOS_DSCP == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM, "invalid qos_tbl");
+		qos_tbl_size = MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE;
+	} else if (TPM_QOS_PBIT == qos_select) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_QOS_MOD, qos_tbl, MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM, "invalid qos_tbl");
+		qos_tbl_size = MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE;
+	} else {
+		TPM_OS_ERROR(TPM_QOS_MOD, "invalid qos table type: (%d)\n", qos_select);
+		return TPM_BAD_PARAM;
+	}
+
+	tpm_db_qos_tbl_status_get(qos_select, qos_tbl, &status, &ref_cnt);
+
+	print_horizontal_line(100, "=");
+	printk(KERN_INFO "=        table_type: %s, table_id: %d, table_inited: %s, ref_count: %d\n",
+		tpm_utils_qos_type_str_get(qos_select), qos_tbl,
+		tpm_utils_valid_str_get(status), ref_cnt);
+	printk(KERN_INFO "=\n");
+	printk(KERN_INFO "=        entry_id  pp_port  pon_tx pp_queue port_id dscp pbit color  inited\n");
+	print_horizontal_line(100, "=");
+
+	for (entry_id = 0; entry_id < qos_tbl_size; entry_id++) {
+		ret = tpm_db_qos_tbl_entry_get(qos_select, qos_tbl, entry_id, &qos_entry);
+		IF_ERROR_STR(TPM_QOS_MOD, ret, "failed to get qos table entry\n");
+
+		printk(KERN_INFO "         %4d  %10s  %4d %7d %7d %7d %4d %5s, %5s\n",
+			entry_id, tpm_utils_pp_port_str_get(qos_entry.qos_entry.pp_port.pp_port),
+			qos_entry.qos_entry.pp_port.pon_tx, qos_entry.qos_entry.pp_port.pp_queue,
+			qos_entry.qos_entry.pp_port.port_id, qos_entry.qos_entry.dscp, qos_entry.qos_entry.pbit,
+			tpm_utils_color_str_get(qos_entry.qos_entry.color),
+			tpm_utils_valid_str_get(qos_entry.entry_stat));
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_qos_table_get
+*
+* DESCRIPTION:
+*           This function will get a qos table.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_qos_table_get(const char *buf, size_t len)
+{
+	enum qos_tbl_set_t {
+		qos_tbl_get_tbl_type = 0,
+		qos_tbl_get_tbl_id,
+		qos_tbl_get_max
+	};
+	int tbl_type = 0;
+	int tbl_id = 0;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != qos_tbl_get_max)
+		parm_error_completion(numparms, qos_tbl_get_max, buf, tpm_sfs_help_qos_tbl_cfg);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &tbl_type, &tbl_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_sfs_qos_table_dump(tbl_type, tbl_id))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_qos_key_set
+*
+* DESCRIPTION:
+*           This function creates a qos key rule
+* INPUTS:
+*       buf	- Shell parameters as char buffer
+*       len - Number of characters in buffer
+*
+*******************************************************************************/
+void tpm_sfs_qos_key_set(const char *buf, size_t len)
+{
+	enum qoskeyset_parm_indx_t {
+		qos_key_set_name, qos_key_set_tbl_type, qos_key_set_tbl_id, qos_key_set_max
+	};
+	/* shell line parsing */
+	char	qosname[20];
+	int	tbl_type = 0;
+	int	tbl_id;
+	int	parsedargs;
+	int	numparms;
+	/* DB */
+	struct tpmcfg_qos_entry_t	*pdbqosentry  = 0;
+	/* Used in API call */
+
+	numparms = count_parameters(buf);
+
+	if (numparms != qos_key_set_max) {
+		parm_error_completion(numparms, qos_key_set_max, buf, tpm_sfs_help_qos_tbl_cfg);
+		return;
+	}
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%s %d %d", qosname, &tbl_type, &tbl_id);
+
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	pdbqosentry = find_tpm_pkt_qos_entry_by_name(qosname);
+	if (pdbqosentry == 0)
+		pdbqosentry = find_free_tpm_pkt_qos_entry();
+
+	if (pdbqosentry == 0) {
+		printk(KERN_INFO "QOS key DB full\n");
+	} else {
+		strcpy(pdbqosentry->name, qosname);
+		pdbqosentry->tbl_id = tbl_id;
+		pdbqosentry->tbl_type = tbl_type;
+	}
+
+	printk(KERN_INFO "OK\n");
+	return;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+;
+
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"frwd_rule_set",                       tpm_sfs_cfg_frwd_rule_set},
+	{"frwd_rule_get",                       tpm_sfs_cfg_frwd_rule_get},
+	{"plcr_add",				tpm_sfs_cfg_plcr_add},
+	{"plcr_del",				tpm_sfs_cfg_plcr_del},
+	{"mtm_add",                             tpm_sfs_cfg_mtm_add},
+	{"mtm_del",                             tpm_sfs_cfg_mtm_del},
+	{"plcr_clear",                          tpm_sfs_cfg_plcr_clear},
+	{"l2_key_ethertype_rule_set",           tpm_sfs_cfg_l2_key_ethertype_rule_set},
+	{"l2_key_ethertype_rule_get",           tpm_sfs_cfg_l2_key_ethertype_rule_get},
+	{"l2_key_mac_addr_rule_set",            tpm_sfs_cfg_l2_key_mac_addr_rule_set},
+	{"l2_key_mac_addr_rule_get",            tpm_sfs_cfg_l2_key_mac_addr_rule_get},
+	{"l2_key_pppoe_rule_set",               tpm_sfs_cfg_l2_key_pppoe_rule_set},
+	{"l2_key_pppoe_rule_get",               tpm_sfs_cfg_l2_key_pppoe_rule_get},
+	{"l2_key_vlan_rule_set",                tpm_sfs_cfg_l2_key_vlan_rule_set},
+	{"l2_key_vlan_rule_get",                tpm_sfs_cfg_l2_key_vlan_rule_get},
+	{"arp_key_addr_rule_set",		tpm_sfs_cfg_arp_key_addr_rule_set},
+	{"arp_key_addr_rule_get",		tpm_sfs_cfg_arp_key_addr_rule_get},
+	{"ipvx_key_addr_rule_set",              tpm_sfs_cfg_ipvx_key_addr_rule_set},
+	{"ipvx_key_addr_rule_get",              tpm_sfs_cfg_ipvx_key_addr_rule_get},
+	{"ipvx_key_port_rule_set",              tpm_sfs_cfg_ipvx_key_port_rule_set},
+	{"ipvx_key_port_rule_get",              tpm_sfs_cfg_ipvx_key_port_rule_get},
+	{"ipvx_key_proto_rule_set",             tpm_sfs_cfg_ipvx_key_protocol_rule_set},
+	{"ipvx_key_proto_rule_get",             tpm_sfs_cfg_ipvx_key_protocol_rule_get},
+	{"ipvx_key_dscp_rule_set",              tpm_sfs_cfg_ipvx_key_dscp_rule_set},
+	{"ipvx_key_dscp_rule_get",              tpm_sfs_cfg_ipvx_key_dscp_rule_get},
+	{"ipv6_key_flbl_rule_set",		tpm_sfs_cfg_ipv6_key_flbl_rule_set},
+	{"ipv6_key_flbl_rule_get",		tpm_sfs_cfg_ipv6_key_flbl_rule_get},
+	{"ipvx_key_ver_rule_set",		tpm_sfs_cfg_ipvx_key_ver_rule_set},
+	{"cnm_field_op_rule_set",		tpm_sfs_cfg_cnm_field_op_set},
+	{"cls_rule_add",                        tpm_sfs_cfg_cls_rule_add_set},
+	{"cnm_rule_add",			tpm_sfs_cfg_cnm_rule_add_set},
+	{"filter_rule_add",			tpm_sfs_cfg_filter_rule_add_set},
+	{"exact_except_rule_add",               tpm_sfs_cfg_exact_except_rule_add_set},
+	{"exact_rule_add",		        tpm_sfs_cfg_exact_rule_add_set},
+	{"mc_rule_add",                         tpm_sfs_cfg_mc_rule_add_set},
+	{"mc_rule_get",				tpm_sfs_cfg_mc_rule_get},
+	{"cls_rule_get",			tpm_sfs_cfg_cls_rule_get},
+	{"exact_rule_get",			tpm_sfs_cfg_exact_rule_get},
+	{"exact_except_rule_get",		tpm_sfs_cfg_exact_except_rule_get},
+	{"no_rule_add_cls_key",			tpm_sfs_cfg_no_rule_add_cls_key_set},
+	{"no_rule_add_filter_key",		tpm_sfs_cfg_no_rule_add_filter_key_set},
+	{"no_rule_add_exact_except_key",	tpm_sfs_cfg_no_rule_add_exact_except_key_set},
+	{"no_rule_add_exact_key",		tpm_sfs_cfg_no_rule_add_exact_key_set},
+	{"cls_rule_cntr_get",			tpm_sfs_cfg_cls_cntr_get},
+	{"filter_rule_cntr_get",		tpm_sfs_cfg_filter_cntr_get},
+	{"filter_def_rule_cntr_get",		tpm_sfs_cfg_filter_def_cntr_get},
+	{"exact_except_rule_cntr_get",		tpm_sfs_cfg_exact_except_cntr_get},
+	{"exact_rule_cntr_get",			tpm_sfs_cfg_exact_cntr_get},
+	{"no_rule_add_cls",                     tpm_sfs_cfg_no_rule_add_cls_set},
+	{"no_rule_add_filter",			tpm_sfs_cfg_no_rule_add_filter_set},
+	{"no_rule_add_exact_except",            tpm_sfs_cfg_no_rule_add_exact_except_set},
+	{"no_rule_add_exact",			tpm_sfs_cfg_no_rule_add_exact_set},
+	{"no_rule_add_cnm",			tpm_sfs_cfg_no_rule_add_cnm_set},
+	{"no_rule_add_cls_all",                 tpm_sfs_cfg_no_rule_add_cls_all_set},
+	{"no_rule_add_filter_all",		tpm_sfs_cfg_no_rule_add_filter_all_set},
+	{"no_rule_add_exact_except_all",        tpm_sfs_cfg_no_rule_add_exact_except_all_set},
+	{"no_rule_add_exact_all",		tpm_sfs_cfg_no_rule_add_exact_all_set},
+	{"no_rule_add_mc",                      tpm_sfs_cfg_no_rule_add_mc_set},
+	{"no_rule_add_mc_all",                  tpm_sfs_cfg_no_rule_add_mc_all_set},
+	{"no_rule_add_cnm_all",			tpm_sfs_cfg_no_rule_add_cnm_all_set},
+	/* Tx rate limit */
+	{"tx_port_sched_mtu_cfg",               tpm_sfs_tx_sched_port_mtu_set},
+	{"tx_queue_mode_cfg",                   tpm_sfs_tx_sched_queue_mode_set},
+	{"tx_queue_rate_limit",                 tpm_sfs_tx_queue_rate_limit_set},
+	{"tx_port_rate_limit",                  tpm_sfs_tx_port_rate_limit_set},
+	/* Mod */
+	{"mod_bit_map_set",                     tpm_sfs_cfg_mod_bm_set},
+	{"mod_mac_addr_rule_set",               tpm_sys_cfg_mod_mac_addr_rule_set},
+	{"mod_vlan_key_set",                    tpm_sys_cfg_mod_vlan_key_set},
+	{"mod_vlan_rule_set",                   tpm_sfs_cfg_mod_vlan_rule_set},
+	{"mod_pppoe_rule_set",                  tpm_sfs_cfg_mod_pppoe_rule_set},
+	{"mod_dscp_rule_set",                   tpm_sfs_cfg_mod_dscp_rule_set},
+	{"mod_ipv4_addr_rule_set",              tpm_sfs_cfg_mod_ipv4_addr_rule_set},
+	{"mod_ipv6_addr_rule_set",              tpm_sfs_cfg_mod_ipv6_addr_rule_set},
+	{"mod_l4_port_rule_set",                tpm_sfs_cfg_mod_L4_port_rule_set},
+
+	/* QOS */
+	{"qos_tbl_entry_set",                   tpm_sfs_qos_table_entry_set},
+	{"qos_tbl_db_reset",			tpm_sfs_qos_table_db_reset},
+	{"qos_tbl_entry_db_set",		tpm_sfs_qos_table_entry_db_set},
+	{"qos_tbl_set",				tpm_sfs_qos_table_set},
+	{"qos_tbl_get",			tpm_sfs_qos_table_get},
+	{"qos_key_cfg",			tpm_sfs_qos_key_set},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help_l2_key_cfg",			tpm_sfs_help_l2_key_cfg},
+	{"help_ipvx_key_cfg",			tpm_sfs_help_ipvx_key_cfg},
+	{"help_mtm_cfg",			tpm_sfs_help_mtm_cfg},
+	{"help_frwd_cfg",			tpm_sfs_help_frwd_rule_cfg},
+	{"help_plcr_cfg",			tpm_sfs_help_plcr_cfg},
+	{"help_tx_sched_cmd",			tpm_sys_help_tx_sched_cfg},
+	{"help_exact_except_rule_add",		tpm_sys_help_exact_except_rule_add},
+	{"help_exact_except_rule_get",		tpm_sfs_help_exact_except_rule_get_cfg},
+	{"help_exact_rule_add",			tpm_sys_help_exact_rule_add},
+	{"help_exact_rule_get",			tpm_sfs_help_exact_rule_get_cfg},
+	{"help_no_rule_add",			tpm_sfs_help_no_rule_add},
+	{"help_cls_rule_get",			tpm_sfs_help_cls_rule_get_cfg},
+	{"help_filter_rule_add",		tpm_sfs_help_filter_rule_add},
+	{"help_cls_rule_add",			tpm_sfs_help_cls_rule_add},
+	{"help_cnm_rule_add",			tpm_sfs_help_cnm_rule_add},
+	{"help_exact_except_rule_cntr_get",	tpm_sys_help_exact_except_rule_cntr_get},
+	{"help_exact_rule_cntr_get",		tpm_sys_help_exact_rule_cntr_get},
+	{"help_cls_rule_cntr_get",		tpm_sfs_help_cls_rule_cntr_get},
+	{"help_filter_rule_cntr_get",		tpm_sfs_help_filter_rule_cntr_get},
+	{"help_filter_def_rule_cntr_get",	tpm_sfs_help_filter_def_rule_cntr_get},
+	{"help_mod_bm_cfg",			tpm_sfs_help_mod_bitmap_cfg},
+	{"help_mod_vlan_key",			tpm_sfs_help_mod_vlan_key_cfg},
+	{"help_mod_rule",			tpm_sfs_help_mod_rule_cfg},
+	{"help_qos_tbl_cfg",			tpm_sfs_help_qos_tbl_cfg},
+	{"help_qos_key_cfg",			tpm_sys_help_qos_key_cfg},
+	{"help_mc_rule_add",			tpm_sfs_help_mc_rule_add},
+	{"help_mc_rule_get",			tpm_sfs_help_api_rule_get_cfg},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help_l2_key_cfg,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_ipvx_key_cfg,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mtm_cfg,                S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_frwd_cfg,               S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_no_rule_add,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_cls_rule_add,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_cnm_rule_add,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_filter_rule_add,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_except_rule_add,  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_rule_add,         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_cls_rule_cntr_get,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_filter_rule_cntr_get,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_filter_def_rule_cntr_get,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_except_rule_cntr_get,  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_rule_cntr_get,         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_cls_rule_get,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_except_rule_get,  S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_exact_rule_get,         S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mc_rule_add,            S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mc_rule_get,           S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+/* Mod Help */
+static DEVICE_ATTR(help_mod_bm_cfg,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mod_vlan_key,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mod_rule,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_plcr_cfg,               S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+/* Rate limit */
+static DEVICE_ATTR(help_tx_sched_cmd,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+/* OOS table */
+static DEVICE_ATTR(help_qos_tbl_cfg,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_qos_key_cfg,		S_IRUSR, tpm_cfg_show, tpm_cfg_store);
+
+/* infra key */
+static DEVICE_ATTR(frwd_rule_set,               S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(frwd_rule_get,		      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mtm_add,                     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mtm_del,                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(plcr_add,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(plcr_del,                    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(plcr_clear,                  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_ethertype_rule_set,   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_ethertype_rule_get,   S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_mac_addr_rule_set,    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_mac_addr_rule_get,    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_pppoe_rule_set,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_pppoe_rule_get,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_vlan_rule_set,        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(l2_key_vlan_rule_get,        S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(arp_key_addr_rule_set,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(arp_key_addr_rule_get,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_proto_rule_set,     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_proto_rule_get,     S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_dscp_rule_set,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_dscp_rule_get,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_key_flbl_rule_set,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_key_flbl_rule_get,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_addr_rule_set,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_addr_rule_get,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_port_rule_set,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_port_rule_get,      S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipvx_key_ver_rule_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_key_cfg,                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cnm_field_op_rule_set,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+/* Rate Limit */
+static DEVICE_ATTR(tx_port_sched_mtu_cfg,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tx_queue_mode_cfg,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tx_queue_rate_limit,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tx_port_rate_limit,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+/* Rule add */
+static DEVICE_ATTR(cnm_rule_add,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cls_rule_add,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(filter_rule_add,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_except_rule_add,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_rule_add,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_filter,             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_cls,             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_cnm,             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact_except,    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact,           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_cls_key,             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_filter_key,             S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact_except_key,    S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact_key,           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_cls_all,         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_cnm_all,         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_filter_all,         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact_all,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_exact_except_all, S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cls_rule_get,                S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_except_rule_get,       S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_rule_get,              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cls_rule_cntr_get,           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(filter_rule_cntr_get,           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(filter_def_rule_cntr_get,           S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_except_rule_cntr_get,  S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(exact_rule_cntr_get,         S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_rule_add,                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_rule_get,                 S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_mc,              S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(no_rule_add_mc_all,          S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+
+/* Mod */
+static DEVICE_ATTR(mod_bit_map_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_mac_addr_rule_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_vlan_key_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_vlan_rule_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_pppoe_rule_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_dscp_rule_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_ipv4_addr_rule_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_ipv6_addr_rule_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_l4_port_rule_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+
+/* QOS */
+static DEVICE_ATTR(qos_tbl_entry_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_tbl_db_reset,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_tbl_entry_db_set,	S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_tbl_set,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_tbl_get,		S_IWUSR, tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+/**********api/infra/key*************/
+static struct attribute *g_tpm_api_infra_key_sw_attrs[] = {
+	&dev_attr_help_l2_key_cfg.attr,
+	&dev_attr_help_ipvx_key_cfg.attr,
+	&dev_attr_l2_key_ethertype_rule_set.attr,
+	&dev_attr_l2_key_ethertype_rule_get.attr,
+	&dev_attr_l2_key_mac_addr_rule_set.attr,
+	&dev_attr_l2_key_mac_addr_rule_get.attr,
+	&dev_attr_l2_key_pppoe_rule_set.attr,
+	&dev_attr_l2_key_pppoe_rule_get.attr,
+	&dev_attr_l2_key_vlan_rule_set.attr,
+	&dev_attr_l2_key_vlan_rule_get.attr,
+	&dev_attr_arp_key_addr_rule_set.attr,
+	&dev_attr_arp_key_addr_rule_get.attr,
+	&dev_attr_ipvx_key_proto_rule_set.attr,
+	&dev_attr_ipvx_key_proto_rule_get.attr,
+	&dev_attr_ipvx_key_dscp_rule_set.attr,
+	&dev_attr_ipvx_key_dscp_rule_get.attr,
+	&dev_attr_ipv6_key_flbl_rule_set.attr,
+	&dev_attr_ipv6_key_flbl_rule_get.attr,
+	&dev_attr_ipvx_key_addr_rule_set.attr,
+	&dev_attr_ipvx_key_addr_rule_get.attr,
+	&dev_attr_ipvx_key_port_rule_set.attr,
+	&dev_attr_ipvx_key_port_rule_get.attr,
+	&dev_attr_ipvx_key_ver_rule_set.attr,
+	&dev_attr_cnm_field_op_rule_set.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_infra_key_sw_group = {
+	.name = "key",
+	.attrs = g_tpm_api_infra_key_sw_attrs
+};
+
+/**********api/infra/mod*************/
+static struct attribute *g_tpm_api_infra_mod_sw_attrs[] = {
+	&dev_attr_help_mod_bm_cfg.attr,
+	&dev_attr_help_mod_vlan_key.attr,
+	&dev_attr_help_mod_rule.attr,
+	&dev_attr_mod_bit_map_set.attr,
+	&dev_attr_mod_mac_addr_rule_set.attr,
+	&dev_attr_mod_vlan_key_set.attr,
+	&dev_attr_mod_vlan_rule_set.attr,
+	&dev_attr_mod_pppoe_rule_set.attr,
+	&dev_attr_mod_dscp_rule_set.attr,
+	&dev_attr_mod_ipv4_addr_rule_set.attr,
+	&dev_attr_mod_ipv6_addr_rule_set.attr,
+	&dev_attr_mod_l4_port_rule_set.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_infra_mod_sw_group = {
+	.name = "mod",
+	.attrs = g_tpm_api_infra_mod_sw_attrs
+};
+
+/**********api/infra/qos*************/
+static struct attribute *g_tpm_api_infra_qos_sw_attrs[] = {
+	&dev_attr_help_qos_key_cfg.attr,
+	&dev_attr_qos_key_cfg.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_infra_qos_sw_group = {
+	.name = "qos",
+	.attrs = g_tpm_api_infra_qos_sw_attrs
+};
+
+/**********api/infra/frwd*************/
+static struct attribute *g_tpm_api_infra_frwd_sw_attrs[] = {
+	&dev_attr_help_frwd_cfg.attr,
+	&dev_attr_frwd_rule_set.attr,
+	&dev_attr_frwd_rule_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_infra_frwd_sw_group = {
+	.name = "frwd",
+	.attrs = g_tpm_api_infra_frwd_sw_attrs
+};
+
+/**********api/plcr*************/
+static struct attribute *g_tpm_api_plcr_sw_attrs[] = {
+	&dev_attr_help_plcr_cfg.attr,
+	&dev_attr_plcr_add.attr,
+	&dev_attr_plcr_del.attr,
+	&dev_attr_plcr_clear.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_plcr_sw_group = {
+	.name = "plcr",
+	.attrs = g_tpm_api_plcr_sw_attrs
+};
+
+/**********api/infra/tx_sched*************/
+/* Tx sched, egress rate limit */
+static struct attribute *g_tpm_api_tx_sched_sw_attrs[] = {
+	&dev_attr_help_tx_sched_cmd.attr,
+	&dev_attr_tx_port_sched_mtu_cfg.attr,
+	&dev_attr_tx_queue_mode_cfg.attr,
+	&dev_attr_tx_queue_rate_limit.attr,
+	&dev_attr_tx_port_rate_limit.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_tx_sched_sw_group = {
+	.name = "tx_sched",
+	.attrs = g_tpm_api_tx_sched_sw_attrs
+};
+
+/**********api/qos*************/
+static struct attribute *g_tpm_api_qos_sw_attrs[] = {
+	&dev_attr_help_qos_tbl_cfg.attr,
+	&dev_attr_qos_tbl_entry_set.attr,
+	&dev_attr_qos_tbl_db_reset.attr,
+	&dev_attr_qos_tbl_entry_db_set.attr,
+	&dev_attr_qos_tbl_set.attr,
+	&dev_attr_qos_tbl_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_qos_sw_group = {
+	.name = "qos",
+	.attrs = g_tpm_api_qos_sw_attrs
+};
+
+/**********api/ipvx_flow*************/
+static struct attribute *g_tpm_api_ipvx_flow_sw_attrs[] = {
+	&dev_attr_help_mtm_cfg.attr,
+	&dev_attr_help_exact_rule_add.attr,
+	&dev_attr_help_exact_rule_cntr_get.attr,
+	&dev_attr_help_exact_rule_get.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_mtm_add.attr,
+	&dev_attr_mtm_del.attr,
+	&dev_attr_exact_rule_cntr_get.attr,
+	&dev_attr_exact_rule_add.attr,
+	&dev_attr_exact_rule_get.attr,
+	&dev_attr_no_rule_add_exact.attr,
+	&dev_attr_no_rule_add_exact_key.attr,
+	&dev_attr_no_rule_add_exact_all.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_ipvx_flow_sw_group = {
+	.name = "ipvx_flow",
+	.attrs = g_tpm_api_ipvx_flow_sw_attrs
+};
+
+/**********api/cpu_route*************/
+static struct attribute *g_tpm_api_cpu_route_sw_attrs[] = {
+	&dev_attr_help_exact_except_rule_add.attr,
+	&dev_attr_help_exact_except_rule_get.attr,
+	&dev_attr_help_exact_except_rule_cntr_get.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_exact_except_rule_add.attr,
+	&dev_attr_exact_except_rule_cntr_get.attr,
+	&dev_attr_exact_except_rule_get.attr,
+	&dev_attr_no_rule_add_exact_except.attr,
+	&dev_attr_no_rule_add_exact_except_key.attr,
+	&dev_attr_no_rule_add_exact_except_all.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_cpu_route_sw_group = {
+	.name = "cpu_route",
+	.attrs = g_tpm_api_cpu_route_sw_attrs
+};
+/**********api/cls*************/
+static struct attribute *g_tpm_api_cls_sw_attrs[] = {
+	&dev_attr_help_cls_rule_add.attr,
+	&dev_attr_help_cls_rule_cntr_get.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_help_cls_rule_get.attr,
+	&dev_attr_no_rule_add_cls.attr,
+	&dev_attr_no_rule_add_cls_key.attr,
+	&dev_attr_no_rule_add_cls_all.attr,
+	&dev_attr_cls_rule_add.attr,
+	&dev_attr_cls_rule_cntr_get.attr,
+	&dev_attr_cls_rule_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_cls_sw_group = {
+	.name = "cls",
+	.attrs = g_tpm_api_cls_sw_attrs
+};
+/**********api/cmn*************/
+static struct attribute *g_tpm_api_cnm_sw_attrs[] = {
+	&dev_attr_help_cnm_rule_add.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_no_rule_add_cnm.attr,
+	&dev_attr_no_rule_add_cnm_all.attr,
+	&dev_attr_cnm_rule_add.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_cnm_sw_group = {
+	.name = "cnm",
+	.attrs = g_tpm_api_cnm_sw_attrs
+};
+
+/**********api/filter *************/
+static struct attribute *g_tpm_api_filter_sw_attrs[] = {
+	&dev_attr_help_filter_rule_add.attr,
+	&dev_attr_help_filter_rule_cntr_get.attr,
+	&dev_attr_help_filter_def_rule_cntr_get.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_no_rule_add_filter.attr,
+	&dev_attr_no_rule_add_filter_key.attr,
+	&dev_attr_no_rule_add_filter_all.attr,
+	&dev_attr_filter_rule_add.attr,
+	&dev_attr_filter_rule_cntr_get.attr,
+	&dev_attr_filter_def_rule_cntr_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_filter_sw_group = {
+	.name = "filter",
+	.attrs = g_tpm_api_filter_sw_attrs
+};
+
+/**********api/multicast*************/
+static struct attribute *g_tpm_api_mc_sw_attrs[] = {
+	&dev_attr_help_mc_rule_add.attr,
+	&dev_attr_help_no_rule_add.attr,
+	&dev_attr_help_mc_rule_get.attr,
+	&dev_attr_no_rule_add_mc.attr,
+	&dev_attr_no_rule_add_mc_all.attr,
+	&dev_attr_mc_rule_add.attr,
+	&dev_attr_mc_rule_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_mc_sw_group = {
+	.name = "mc",
+	.attrs = g_tpm_api_mc_sw_attrs
+};
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_api_init
+*
+* DESCRIPTION: The routine will initialize TPM api sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_DB_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_api_init(void)
+{
+	int rc;
+
+	/* Initialize infra api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, "infra", &g_tpm_api_infra_key_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, "infra", &g_tpm_api_infra_mod_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, "infra", &g_tpm_api_infra_frwd_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, "infra", &g_tpm_api_infra_qos_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_plcr_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+	/* Tx rate limit */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_tx_sched_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize ipvx_flow api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_ipvx_flow_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize cpu_route api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_cpu_route_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize cls api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_cls_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize filter api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_filter_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize qos api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_qos_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize multicast api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_mc_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize cnm api sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_cnm_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	tpm_sysfs_rule_db_init();
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c2.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c2.c
new file mode 100644
index 0000000..125876a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c2.c
@@ -0,0 +1,937 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_c2.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM C2 SYSFS PRINT                                             */
+/* ========================================================================== */
+
+/* source port type name string */
+static char *tpm_port_type_str_tbl[3] = {
+	"PHY",
+	"UNI",
+	"VIRT"
+};
+
+/* C2 QOS table name string */
+static char *tpm_qos_table_str_tbl[2] = {
+	"QOS_PBIT",
+	"QOS_DSCP"
+};
+
+/* C2 QOS table name string */
+static char *tpm_qos_src_str_tbl[2] = {
+	"ACTION",
+	"DSCP_PBIT"
+};
+
+/* tpm color action name string */
+static char *tpm_color_action_str[8] = {
+	"No_Updt",
+	"No_Updt_L",
+	"Green",
+	"",
+	"Yellow",
+	"",
+	"Red",
+	"Red_L"
+};
+
+/* tpm common action name string */
+static char *tpm_common_action_str[4] = {
+	"No_Upd",
+	"No_Updt_L",
+	"Update",
+	"Update_L"
+};
+
+/* tpm flowID enable action name string */
+static char *tpm_flowid_action_str[2] = {
+	"Disable",
+	"Enable"
+};
+
+/* tpm forwarding action name string */
+static char *tpm_frwd_action_str[8] = {
+	"No_Updt",
+	"No_Updt_L",
+	"SWF",
+	"SWF_L",
+	"HWF",
+	"HWF_L",
+	"HWF_Lat",
+	"HWF_Lat_L"
+};
+
+/*******************************************************************************
+* tpm_sfs_valid_c2_entry_header_dump
+*
+* DESCRIPTION: print header.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_valid_c2_entry_header_dump(void)
+{
+	print_horizontal_line(179, "=");
+	printk(KERN_INFO "= LKP_Type | Priority | Port_Info |   Field_Name  |      Field_Value     |            QOS_Info            |    Action_Info     |   Mod_Info   | Duplication | Hit_Cnt |   INDX    =\n");
+	print_horizontal_line(179, "=");
+}
+
+/*******************************************************************************
+* tpm_sfs_valid_c2_entry_line_dump
+*
+* DESCRIPTION: Print one line of dump info.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_valid_c2_entry_line_dump(unsigned int	lkp_type,
+				unsigned int		dump_idx,
+				struct tpm_c2_data_t	*c2_entry,
+				struct tpm_c2_index_t	*c2_index_node)
+{
+	char *empty_str = "";
+	char field_name_str[14] = "";
+	char qos_info_str[30] = "";
+	char action_str[18] = "";
+	char mod_str[12] = "";
+	char flow_str[7] = "";
+	char port_info_str[8] = "";
+	char field_value_str[48] = "";
+	char field_value_mask_str[48] = "";
+	char lookup_type_str[8] = "";
+	char internal_pri_str[8] = "";
+	char index_str[8] = "";
+	char hit_cnt_str[8] = "";
+	unsigned int hit_cnt = 0;
+	unsigned int field_id;
+	unsigned int field_match;
+	struct tpm_field_match_info field_match_info;
+	struct tpm_mng_pkt_key_t tpm_pkt_key_t_tmp;
+	struct tpm_pkt_key_t	pkt_key_tmp;
+
+	if (0 == dump_idx) {
+		sprintf(lookup_type_str, "%02d", lkp_type);
+		sprintf(internal_pri_str, "%03d", c2_entry->priority);
+		mvPp2ClsC2HitCntrRead(c2_index_node->c2_hw_idx, &hit_cnt);
+		sprintf(hit_cnt_str, "%03d", hit_cnt);
+	}
+
+	/* port info, including type, value and mask */
+	switch (dump_idx) {
+	case TPM_PORT_DUMP_TYPE:
+		sprintf(port_info_str, "T:%s", tpm_port_type_str_tbl[c2_entry->port.port_type]);
+		break;
+	case TPM_PORT_DUMP_VALUE:
+		sprintf(port_info_str, "V:0x%x", c2_entry->port.port_value);
+		break;
+	case TPM_PORT_DUMP_MASK:
+		sprintf(port_info_str, "M:0x%x", c2_entry->port.port_mask);
+		break;
+	}
+
+	/* Field match parse and set field value */
+	if ((!c2_entry->field_bm) && (!dump_idx)) {
+		sprintf(field_name_str, "%s", "NA");
+		sprintf(field_value_str, "%s", "NA");
+	}
+
+	field_match = c2_entry->field_bm & (1 << dump_idx);
+
+	/* skip IPv6 sub matches, need only one bit to print data */
+	if (c2_entry->field_bm & TPM_MATCH_IPV6_PREF)
+		field_match &= ~TPM_MATCH_IPV6_PREF;
+	else if (c2_entry->field_bm & TPM_MATCH_IPV6_SUFF)
+		field_match &= ~TPM_MATCH_IPV6_SUFF;
+
+
+	if (field_match) {
+		tpm_pkt_key_t_tmp.ttl = c2_entry->mng_pkt_key.ttl;
+		tpm_pkt_key_t_tmp.tcp_flag = c2_entry->mng_pkt_key.tcp_flag;
+		tpm_pkt_key_t_tmp.tcp_flag_mask = c2_entry->mng_pkt_key.tcp_flag_mask;
+		memcpy(&pkt_key_tmp, &c2_entry->mng_pkt_key.pkt_key, sizeof(struct tpm_pkt_key_t));
+		tpm_pkt_key_t_tmp.pkt_key = &pkt_key_tmp;
+		memset(&field_match_info, 0, sizeof(struct tpm_field_match_info));
+
+		/* set IPv6 sub matches cleared to get correct field_info readings */
+		if (c2_entry->field_bm & TPM_MATCH_IPV6_PREF)
+			field_match |= TPM_MATCH_IPV6_PREF;
+		else if (c2_entry->field_bm & TPM_MATCH_IPV6_SUFF)
+			field_match |= TPM_MATCH_IPV6_SUFF;
+
+		if (tpm_field_bm_to_field_info(field_match,
+					       &tpm_pkt_key_t_tmp,
+					       1,
+					       true,
+					       &field_match_info))
+			return;
+		field_id = field_match_info.field_id;
+		sprintf(field_name_str, "%s", tpm_utils_field_id_str_get(field_id));
+
+		switch (field_id) {
+		case MAC_DA_FIELD_ID:
+		case MAC_SA_FIELD_ID:
+			sprintf(field_value_str,
+				"V: %pM", field_match_info.filed_value.mac_addr.parsed_mac_addr);
+			sprintf(field_value_mask_str,
+				"M: %pM", field_match_info.filed_value.mac_addr.parsed_mac_addr_mask);
+			break;
+
+		case IPV4_SA_FIELD_ID:
+		case IPV4_DA_FIELD_ID:
+		case ARP_IPV4_DA_FIELD_ID:
+			sprintf(field_value_str,
+				"V: %pI4", field_match_info.filed_value.ipv4_addr.parsed_ipv4_addr);
+			sprintf(field_value_mask_str,
+				"M: %pI4", field_match_info.filed_value.ipv4_addr.parsed_ipv4_addr_mask);
+			break;
+
+		case IPV6_SA_PREF_FIELD_ID:
+		case IPV6_DA_PREF_FIELD_ID:
+			sprintf(field_value_str,
+				"V: %04x:%04x:%04x:%04x",
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[0]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[2]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[4]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[6]));
+			sprintf(field_value_mask_str,
+				"M: %04x:%04x:%04x:%04x",
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[0]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[2]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[4]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[6]));
+			break;
+
+		case IPV6_DA_SUFF_FIELD_ID:
+		case IPV6_SA_SUFF_FIELD_ID:
+			sprintf(field_value_str,
+				"V: %04x:%04x:%04x:%04x",
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[8]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[10]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[12]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[14]));
+			sprintf(field_value_mask_str,
+				"M: %04x:%04x:%04x:%04x",
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[8]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[10]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[12]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask[14]));
+			break;
+
+		case IPV6_SA_FIELD_ID:
+		case IPV6_DA_FIELD_ID:
+			sprintf(field_value_str,
+				"V: %pI6",
+				field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr);
+			sprintf(field_value_mask_str,
+				"M: %pI6",
+				field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr_mask);
+			break;
+
+		default:
+			sprintf(field_value_str,
+				"V: 0x%x",
+				field_match_info.filed_value.int_data.parsed_int_val);
+			sprintf(field_value_mask_str,
+				"M: 0x%x",
+				field_match_info.filed_value.int_data.parsed_int_val_mask);
+		}
+	}
+
+	/* QOS_Info */
+	switch (dump_idx) {
+	case TPM_QOS_DUMP_DSCP:
+		if (c2_entry->qos_info.pri_dscp_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"DSCP src: %s",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.pri_dscp_src]);
+		else
+			sprintf(qos_info_str,
+				"DSCP src: %s, DSCP=%d",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.pri_dscp_src],
+				c2_entry->qos_value.dscp);
+		break;
+	case TPM_QOS_DUMP_PBIT:
+		if (c2_entry->qos_info.pri_dscp_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"PBIT src: %s",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.pri_dscp_src]);
+		else
+			sprintf(qos_info_str,
+				"PBIT src: %s, PBIT=%d",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.pri_dscp_src],
+				c2_entry->qos_value.pri);
+		break;
+	case TPM_QOS_DUMP_GEMPORT:
+		if (c2_entry->qos_info.gemport_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"GEMP src: %s",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.gemport_src]);
+		else
+			sprintf(qos_info_str,
+				"GEMP src: %s, GEMP=%d",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.gemport_src],
+				c2_entry->qos_value.gemp);
+		break;
+	case TPM_QOS_DUMP_QUEUE_LOW:
+		if (c2_entry->qos_info.gemport_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"Q_L src: %s",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.q_low_src]);
+		else
+			sprintf(qos_info_str,
+				"Q_L src: %s, Q_L=%d",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.q_low_src],
+				c2_entry->qos_value.q_low);
+		break;
+	case TPM_QOS_DUMP_QUEUE_HIGH:
+		if (c2_entry->qos_info.gemport_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"Q_H src: %s",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.q_high_src]);
+		else
+			sprintf(qos_info_str,
+				"Q_H src: %s, Q_H=%d",
+				tpm_qos_src_str_tbl[c2_entry->qos_info.q_high_src],
+				c2_entry->qos_value.q_high);
+		break;
+	case TPM_QOS_DUMP_COLOR:
+		sprintf(qos_info_str,
+			"Color src: %s",
+			tpm_qos_src_str_tbl[c2_entry->qos_info.color_src]);
+		break;
+	case TPM_QOS_DUMP_TABLE:
+		if (c2_entry->qos_info.pri_dscp_src == TPM_QOS_SRC_DSCP_PBIT_TBL ||
+		    c2_entry->qos_info.gemport_src == TPM_QOS_SRC_DSCP_PBIT_TBL ||
+		    c2_entry->qos_info.q_low_src == TPM_QOS_SRC_DSCP_PBIT_TBL ||
+		    c2_entry->qos_info.q_high_src == TPM_QOS_SRC_DSCP_PBIT_TBL ||
+		    c2_entry->qos_info.color_src == TPM_QOS_SRC_DSCP_PBIT_TBL)
+			sprintf(qos_info_str,
+				"QOS tbl: %s, index=%d", tpm_qos_table_str_tbl[c2_entry->qos_info.qos_tbl_type],
+				c2_entry->qos_info.qos_tbl_index);
+		break;
+	case TPM_QOS_DUMP_POLICER:
+		if (c2_entry->qos_info.policer_id != 0xFFFF)
+			sprintf(qos_info_str,
+				"Policer ID = %d",
+				c2_entry->qos_info.policer_id);
+		break;
+	}
+
+	/* Action */
+	switch (dump_idx) {
+	case TPM_ACT_DUMP_DSCP:
+		sprintf(action_str, "DSCP: %s", tpm_common_action_str[c2_entry->action.dscp_act]);
+		break;
+	case TPM_ACT_DUMP_PBIT:
+		sprintf(action_str, "PBIT: %s", tpm_common_action_str[c2_entry->action.pri_act]);
+		break;
+	case TPM_ACT_DUMP_GEMPORT:
+		sprintf(action_str, "GEMP: %s", tpm_common_action_str[c2_entry->action.gemp_act]);
+		break;
+	case TPM_ACT_DUMP_QUEUE_LOW:
+		sprintf(action_str, "Q_LOW: %s", tpm_common_action_str[c2_entry->action.q_low_act]);
+		break;
+	case TPM_ACT_DUMP_QUEUE_HIGH:
+		sprintf(action_str, "Q_HIGH: %s", tpm_common_action_str[c2_entry->action.q_high_act]);
+		break;
+	case TPM_ACT_DUMP_COLOR:
+		sprintf(action_str, "COLOR: %s", tpm_color_action_str[c2_entry->action.color_act]);
+		break;
+	case TPM_ACT_DUMP_POLICER:
+		sprintf(action_str, "POLICER: %s", tpm_common_action_str[c2_entry->action.policer_act]);
+		break;
+	case TPM_ACT_DUMP_FRWD:
+		sprintf(action_str, "FRWD: %s", tpm_frwd_action_str[c2_entry->action.frwd_act]);
+		break;
+	case TPM_ACT_DUMP_FLOWID:
+		sprintf(action_str, "FLOWID: %s", tpm_flowid_action_str[c2_entry->action.flowid_act]);
+		break;
+	}
+
+	/* Mod */
+	switch (dump_idx) {
+	case TPM_MOD_DUMP_IPTR:
+		sprintf(mod_str, "IPTR=%3d", c2_entry->pkt_mod.mod_cmd_idx);
+		break;
+	case TPM_MOD_DUMP_DPTR:
+		sprintf(mod_str, "DPTR=%3d", c2_entry->pkt_mod.mod_data_idx);
+		break;
+	case TPM_MOD_DUMP_L4_CHECKSUM:
+		if (c2_entry->pkt_mod.l4_chksum_update_flag)
+			sprintf(mod_str, "L4_Check EN");
+		else
+			sprintf(mod_str, "L4_Check DIS");
+		break;
+	}
+	/* Flow info */
+	switch (dump_idx) {
+	case TPM_FLOW_DUMP_ID:
+		sprintf(flow_str, "ID=%d", c2_entry->flow_info.flow_id);
+		break;
+	case TPM_FLOW_DUMP_CNT:
+		sprintf(flow_str, "CNT=%d", c2_entry->flow_info.flow_cnt);
+		break;
+	}
+	/* Entry index, including HW index, logical index,and DB index */
+	switch (dump_idx) {
+	case TPM_INDEX_DUMP_TCAM:
+		sprintf(index_str, "HW:%03d", c2_index_node->c2_hw_idx);
+		break;
+	case TPM_INDEX_DUMP_LOGICAL:
+		sprintf(index_str, "LOG:%04d", c2_index_node->c2_logic_idx);
+		break;
+	case TPM_INDEX_DUMP_DB:
+		sprintf(index_str, "DB:%04d", c2_index_node->c2_data_db_idx);
+		break;
+	}
+
+	if (dump_idx == 0 ||
+	    dump_idx <= TPM_PORT_DUMP_MASK ||
+	    field_match ||
+	    dump_idx <= TPM_QOS_DUMP_POLICER ||
+	    dump_idx <= TPM_ACT_DUMP_FRWD ||
+	    dump_idx <= TPM_MOD_DUMP_L4_CHECKSUM ||
+	    dump_idx <= TPM_FLOW_DUMP_CNT ||
+	    dump_idx <= TPM_INDEX_DUMP_DB) {
+		printk(KERN_INFO "+ %8s | %8s | %8s  | %13s | %20s | %30s | %18s | %12s | %11s | %7s | %8s  +\n",
+			lookup_type_str, internal_pri_str, port_info_str, field_name_str, field_value_str,
+			qos_info_str, action_str, mod_str, flow_str, hit_cnt_str, index_str);
+		if (field_match)
+			printk(KERN_INFO "+ %8s | %8s | %8s  | %13s | %20s | %30s | %18s | %12s | %11s | %7s | %9s +\n",
+				empty_str, empty_str, empty_str, empty_str, field_value_mask_str,
+				empty_str, empty_str, empty_str, empty_str, empty_str, empty_str);
+	}
+}
+
+/*******************************************************************************
+* tpm_c2_dump_all
+*
+* DESCRIPTION: The routine will dump the valid C2 entries from C2 sub-module
+*              internal DB.
+* INPUTS:
+*           lookup_type - lookup type entry to dump
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           For debug, if lookup_type equal to 64, means dump all lookup types
+*******************************************************************************/
+static void tpm_c2_dump_all(unsigned char lookup_type)
+{
+	unsigned int lkp_type_idx;
+	struct tpm_c2_data_t c2_db_data;
+	struct tpm_c2_index_t *c2_index_node;
+	unsigned int i;
+
+	/* Print header */
+	tpm_sfs_valid_c2_entry_header_dump();
+
+	for (lkp_type_idx = 0; lkp_type_idx < TPM_C2_LKP_TYPE_MAX; lkp_type_idx++) {
+		if (lkp_type_idx != lookup_type &&
+		    lookup_type != TPM_C2_LKP_TYPE_MAX)
+			continue;
+		if (list_empty(tpm_db_c2_lkp_type_list_head_get(lkp_type_idx)))
+			continue;
+		/* Traverse lookup type list */
+		list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type_idx), list_node) {
+			/* get C2 db entry data */
+			if (TPM_OK != tpm_db_c2_data_get(c2_index_node->c2_data_db_idx, &c2_db_data))
+				continue;
+			/* First line */
+			for (i = 0; i < sizeof(c2_db_data.field_bm) * BYTE_BITS; i++) {
+				tpm_sfs_valid_c2_entry_line_dump(lkp_type_idx,
+								 i,
+								 &c2_db_data,
+								 c2_index_node);
+			}
+			printk(KERN_INFO "+");
+			print_horizontal_line(177, "-");
+			printk(KERN_INFO "+\n");
+		}
+	}
+
+	print_horizontal_line(179, "=");
+}
+
+/*******************************************************************************
+* tpm_print_free_c2_tcam_dump_head
+*
+* DESCRIPTION: print header for free TCAM.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_free_c2_tcam_dump_head(void)
+{
+	print_horizontal_line(67, "=");
+	printk(KERN_INFO "=    TOTAL    |                FREE_TCAM_IDX                      =\n");
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_print_tcam_index_dump_line
+*
+* DESCRIPTION: print one line with TCAM index information.
+* INPUTS:
+*           common_int - tcam count or lkp_type
+*           tcam_idx   - TCAM index array
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_tcam_index_dump_line(unsigned int common_int,
+					   unsigned char *tcam_idx)
+{
+	char common_str[4] = "";
+	char tcam_idx_str[40] = "";
+	int i, j, tcam_cnt, ten_cnt;
+	int line_int_num = 10;
+	bool first_line = true;
+
+	/* Para Check */
+	if (tcam_idx == NULL)
+		return;
+
+	sprintf(common_str, "%03d", common_int);
+	for (i = 0; i < TPM_C2_ENTRY_MAX; i++) {
+		if (tcam_idx[i] == TPM_C2_LAST_ENTRY)
+			break;
+	}
+	tcam_cnt = i;
+	if (tcam_cnt % line_int_num)
+		ten_cnt = tcam_cnt / line_int_num + 1;
+	else
+		ten_cnt = tcam_cnt / line_int_num;
+	/* Handle TCAM count zero */
+	if (tcam_cnt == 0)
+		ten_cnt = 1;
+	for (i = 0; i < ten_cnt; i++) {
+		sprintf(tcam_idx_str, "%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d", tcam_idx[i*line_int_num],
+			tcam_idx[i*line_int_num + 1], tcam_idx[i*line_int_num + 2], tcam_idx[i*line_int_num + 3],
+			tcam_idx[i*line_int_num + 4], tcam_idx[i*line_int_num + 5], tcam_idx[i*line_int_num + 6],
+			tcam_idx[i*line_int_num + 7], tcam_idx[i*line_int_num + 8], tcam_idx[i*line_int_num + 9]);
+		if ((tcam_cnt % line_int_num) && (i == tcam_cnt / line_int_num)) {
+			for (j = ((tcam_cnt % line_int_num) * 4); j < 40; j++)
+				tcam_idx_str[j] = 0;
+			if (first_line) {
+				first_line = false;
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, tcam_idx_str);
+			} else {
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", "", tcam_idx_str);
+			}
+		} else {
+			if (first_line) {
+				first_line = false;
+				if (tcam_cnt)
+					printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, tcam_idx_str);
+				else
+					printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, "NA");
+			} else {
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", "", tcam_idx_str);
+			}
+		}
+	}
+
+}
+
+
+/*******************************************************************************
+* tpm_c2_dump_freelist
+*
+* DESCRIPTION: The routine will dump all the free C2 entry number from C2
+*              sub-module internal DB
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           For debug.
+*******************************************************************************/
+static void tpm_c2_dump_freelist(void)
+{
+	struct tpm_c2_index_t *c2_index_node;
+	unsigned int count = 0;
+	unsigned char tcam_array[TPM_C2_ENTRY_MAX];
+
+	tpm_print_free_c2_tcam_dump_head();
+	/* Traverse free list */
+	TPM_MEMSET_FF(tcam_array);
+	list_for_each_entry(c2_index_node, tpm_db_c2_free_list_head_get(), list_node)
+		tcam_array[count++] = c2_index_node->c2_hw_idx;
+	/* Print Free TCAM info */
+	tpm_print_tcam_index_dump_line(count, tcam_array);
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_print_valid_lkp_type_dump_head
+*
+* DESCRIPTION: print header for lookup type.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_valid_lkp_type_dump_head(void)
+{
+	print_horizontal_line(67, "=");
+	printk(KERN_INFO "=   LKP_Type  |                TCAM_IDX                           =\n");
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_c2_dump_lookup_type_list
+*
+* DESCRIPTION: The routine will dump all the valid lookup_type list from C2
+*              sub-module internal DB
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           For debug.
+*******************************************************************************/
+static void tpm_c2_dump_lookup_type_list(void)
+{
+	unsigned int lkp_type_idx;
+	unsigned char tcam_array[TPM_C2_ENTRY_MAX];
+	int i;
+	struct tpm_c2_index_t *c2_index_node;
+
+	tpm_print_valid_lkp_type_dump_head();
+	for (lkp_type_idx = 0; lkp_type_idx < TPM_C2_LKP_TYPE_MAX; lkp_type_idx++) {
+		if (list_empty(tpm_db_c2_lkp_type_list_head_get(lkp_type_idx)))
+			continue;
+		TPM_MEMSET_FF(tcam_array);
+		i = 0;
+		list_for_each_entry(c2_index_node, tpm_db_c2_lkp_type_list_head_get(lkp_type_idx), list_node)
+			tcam_array[i++] = (unsigned char)(c2_index_node->c2_hw_idx);
+		/* Print LKP_type info */
+		tpm_print_tcam_index_dump_line(lkp_type_idx, tcam_array);
+		printk(KERN_INFO "+-----------------------------------------------------------------+\n");
+	}
+	print_horizontal_line(67, "=");
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* sys_help_tpm_c2_debug_cmd
+*
+* DESCRIPTION:
+*           This function dump help of c2 debug sysfs commands
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static int sys_help_tpm_c2_debug_cmd(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [lkp_type]  > lkp_type_entry_dump -  dump all entries with the lookup type\n");
+	off += sprintf(buf+off, "\tlkp_type        (dec)C2 lookup type, 0...63\n");
+
+	off += sprintf(buf+off, "\n");
+	/* xxx info dump */
+	off += sprintf(buf+off, "cat dump_all               -  dump all valid C2 entries with their information\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat free_tcam_dump         -  dump all free C2 TCAM entry index.\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat valid_lkp_type_dump    -  dump valid C2 lookup type, with its TCAM index.\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+/*******************************************************************************
+* sfs_tpm_c2_lkp_type_entry_dump
+*
+* DESCRIPTION:
+*           This function dump C2 lookup type entry
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static void sfs_tpm_c2_lkp_type_entry_dump(const char *buf, size_t len)
+{
+	enum c2_lkp_type_dump_parm_indx_t {
+		lkp_type = 0,
+		lkp_type_dump_max
+	};
+
+	unsigned int lookup_type;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != lkp_type_dump_max)
+		parm_error_completion(numparms, lkp_type_dump_max, buf, sys_help_tpm_c2_debug_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &lookup_type);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else
+			tpm_c2_dump_all(lookup_type);
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_c2_dump_all
+*
+* DESCRIPTION:
+*           This function dump all valid c2 entries
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_c2_dump_all(char *buf)
+{
+	int off = 0;
+
+	tpm_c2_dump_all(TPM_C2_LKP_TYPE_MAX);
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_c2_free_tcam_dump
+*
+* DESCRIPTION:
+*           This function dump free C2 tcam entry
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_c2_free_tcam_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_c2_dump_freelist();
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_c2_free_tcam_dump
+*
+* DESCRIPTION:
+*           This function dump C2 valid lookup type and its TCAM index
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_c2_valid_lkp_type_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_c2_dump_lookup_type_list();
+
+	return off;
+}
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"lkp_type_entry_dump",		sfs_tpm_c2_lkp_type_entry_dump},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",			sys_help_tpm_c2_debug_cmd},
+	{"dump_all",			sfs_tpm_c2_dump_all},
+	{"free_tcam_dump",		sfs_tpm_c2_free_tcam_dump},
+	{"valid_lkp_type_dump",		sfs_tpm_c2_valid_lkp_type_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Store Attr */
+static DEVICE_ATTR(lkp_type_entry_dump,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Show Attr */
+static DEVICE_ATTR(dump_all,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(free_tcam_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(valid_lkp_type_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+static struct attribute *g_tpm_c2_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_dump_all.attr,
+	&dev_attr_lkp_type_entry_dump.attr,
+	&dev_attr_free_tcam_dump.attr,
+	&dev_attr_valid_lkp_type_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_c2_sw_group = {
+	.name = "c2",
+	.attrs = g_tpm_c2_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_c2_init
+*
+* DESCRIPTION: The routine will initialize TPM c2 sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_c2_init(void)
+{
+	int rc;
+
+	/* Initialize c2 sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_c2_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c3.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c3.c
new file mode 100644
index 0000000..0d1e483
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c3.c
@@ -0,0 +1,1042 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_c3.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include <linux/sched.h>
+#include "tpm_header.h"
+
+/******************************************************************************/
+/*                                 MACROS                                     */
+/******************************************************************************/
+/* When dumping C3 rules, every TPM_C3_DUMP_INTERVAL recorders is printed out, */
+/* the dumping will delay TPM_C3_DUMP_DELAY ms to free CPU to do schedule. */
+#define TPM_C3_DUMP_INTERVAL			(100)	/*C3 rule dumping interval number*/
+#define TPM_C3_DUMP_DELAY			(50)	/*unit ms*/
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+int tpm_sfs_c3_help_debug(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [type] [var]             > entry_dump    -  dump C3 entries according to type and index\n");
+	off += sprintf(buf+off, "\ttype         (dec)C3 dump type, 0: logic index, 1:hash index, 2:lookup type, 3:all\n");
+	off += sprintf(buf+off, "\tvar          (dec)value according to type, type0/1:index, type 2: lookup type, type 3:0\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [all]                    > index_dump    -  dump two index tables\n");
+	off += sprintf(buf+off, "\tall          (dec)all index entry or only valid one, 0: valid, 1:all\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [clear] [lkp_type_en] [lkp_type] [mode] [start] [delay] [threshold]  > scan_param_set   -  set scan mode\n");
+	off += sprintf(buf+off, "\tclear        (dec)clear before scan, 0:not clear, 1:clear\n");
+	off += sprintf(buf+off, "\tlkp_type_en  (dec)scan by lookup type, 0:disable, 1:enable\n");
+	off += sprintf(buf+off, "\tlkp_type     (dec)lookup type value, from 0 to 15\n");
+	off += sprintf(buf+off, "\tmode         (dec)scan mode, 0:below threshold, 1:above threshold\n");
+	off += sprintf(buf+off, "\tdelay        (dec)scan delay time in unit of 256 core clock cycles\n");
+	off += sprintf(buf+off, "\tthreshold    (dec)scan threshold\n");
+	off += sprintf(buf+off, "echo max_entry                > scan_result_get  -  get scan result\n");
+	off += sprintf(buf+off, "\tmax_entry    (dec)max scan entry number\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [logic_idx]              > hit_count_get    -  get hit counter by logical index\n");
+	off += sprintf(buf+off, "\tlogic_idx    (dec)logical index, 0...4095\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [search_depth]           > search_depth_set -  set cuckoo search depth\n");
+	off += sprintf(buf+off, "\tsearch_depth (dec)cuckoo search depth, 1...8\n");
+	off += sprintf(buf+off, "\n");
+
+	/* entry and config dump */
+	off += sprintf(buf+off, "cat config_dump               -  dump all C3 configuration, including scan config and search depth\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+/*******************************************************************************
+* tpm_sfs_c3_entry_line_dump
+*
+* DESCRIPTION: Print one line of C3 entry info.
+* INPUTS:
+*	dump_idx  - index used to dump field value
+*	hash_iex  - multihash index of C3 HW
+*	logic_idx - logical index
+*	hit_count - hit counter
+*	c3_entry  - C3 entry information
+*
+* OUTPUTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_c3_entry_line_dump(unsigned int		dump_idx,
+				unsigned int		hash_idx,
+				unsigned int		logic_idx,
+				unsigned int		hit_count,
+				struct tpm_c3_data_t	*c3_entry)
+{
+	char lookup_type_str[8] = "";
+	char port_info_str[10] = "";
+	char l4_info_str[10] = "";
+	char hek_str[26] = "";
+	char qos_info_str[13] = "";
+	char action_str[20] = "";
+	char mod_str[12] = "";
+	char flow_str[11] = "";
+	char index_str[9] = "";
+	char hit_cnt_str[8] = "";
+	unsigned int len;
+	unsigned int idx;
+
+	/* set lkp_Type, L4_Info, Hit_Count for the first time */
+	if (dump_idx == 0) {
+		sprintf(lookup_type_str, "%d", c3_entry->lkp_type);
+		sprintf(l4_info_str, "%s", tpm_utils_l4_type_str_get(c3_entry->l4_type));
+		sprintf(hit_cnt_str, "%d", hit_count);
+	}
+
+	/* port */
+	switch (dump_idx) {
+	case TPM_C3_PORT_DUMP_TYPE:
+		sprintf(port_info_str, "T:%s", tpm_utils_port_type_str_get(c3_entry->port.port_type));
+		break;
+	case TPM_C3_PORT_DUMP_VALUE:
+		sprintf(port_info_str, "V:0x%x", c3_entry->port.port_value);
+		break;
+	default:
+		break;
+	}
+
+	/* HEK info */
+	switch (dump_idx) {
+	case TPM_C3_HEK_DUMP_LEN:
+		sprintf(hek_str, "Len:%d", c3_entry->hek_len);
+		break;
+	case TPM_C3_HEK_DUMP_KEY1:
+		len = (c3_entry->hek_len > MV_PP2_CLS_C3_HEK_BYTES) ? MV_PP2_CLS_C3_HEK_BYTES : c3_entry->hek_len;
+		for (idx = 0; idx < len; idx++)
+			sprintf(hek_str + 2 * idx, "%02x", c3_entry->hek[idx]);
+
+		break;
+	case TPM_C3_HEK_DUMP_KEY2:
+		if (c3_entry->hek_len > MV_PP2_CLS_C3_HEK_BYTES) {
+			len = ((c3_entry->hek_len - MV_PP2_CLS_C3_HEK_BYTES) > MV_PP2_CLS_C3_HEK_BYTES) ?
+				MV_PP2_CLS_C3_HEK_BYTES : (c3_entry->hek_len - MV_PP2_CLS_C3_HEK_BYTES);
+			for (idx = 0; idx < len; idx++)
+				sprintf(hek_str + 2 * idx, "%02x", c3_entry->hek[idx+MV_PP2_CLS_C3_HEK_BYTES]);
+		}
+		break;
+	case TPM_C3_HEK_DUMP_KEY3:
+		if (c3_entry->hek_len > 2 * MV_PP2_CLS_C3_HEK_BYTES) {
+			len = ((c3_entry->hek_len - 2 * MV_PP2_CLS_C3_HEK_BYTES) > MV_PP2_CLS_C3_HEK_BYTES) ?
+				MV_PP2_CLS_C3_HEK_BYTES : (c3_entry->hek_len - 2 * MV_PP2_CLS_C3_HEK_BYTES);
+			for (idx = 0; idx < len; idx++)
+				sprintf(hek_str + 2 * idx, "%02x", c3_entry->hek[idx + 2 * MV_PP2_CLS_C3_HEK_BYTES]);
+		}
+		break;
+	default:
+		break;
+	}
+
+	/* action */
+	switch (dump_idx) {
+	case TPM_C3_ACT_DUMP_COLOR:
+		sprintf(action_str, "COLOR: %s", tpm_utils_qos_action_str_get(c3_entry->action.color_act));
+		break;
+	case TPM_C3_ACT_DUMP_QUEUE_LOW:
+		sprintf(action_str, "Q_LOW: %s", tpm_utils_common_action_str_get(c3_entry->action.q_low_act));
+		break;
+	case TPM_C3_ACT_DUMP_QUEUE_HIGH:
+		sprintf(action_str, "Q_HIGH: %s", tpm_utils_common_action_str_get(c3_entry->action.q_high_act));
+		break;
+	case TPM_C3_ACT_DUMP_FRWD:
+		sprintf(action_str, "FRWD: %s", tpm_utils_frwd_action_str_get(c3_entry->action.frwd_act));
+		break;
+	case TPM_C3_ACT_DUMP_POLICER:
+		sprintf(action_str, "POLICER: %s", tpm_utils_common_action_str_get(c3_entry->action.policer_act));
+		break;
+	case TPM_C3_ACT_DUMP_FLOWID:
+		sprintf(action_str, "FLOWID: %s", tpm_utils_flow_id_action_str_get(c3_entry->action.flowid_act));
+		break;
+	default:
+		break;
+	}
+
+	/* QoS */
+	switch (dump_idx) {
+	case TPM_C3_QOS_DUMP_QUEUE_LOW:
+		sprintf(qos_info_str, "Q_LOW=%d", c3_entry->qos_value.q_low);
+		break;
+	case TPM_C3_QOS_DUMP_QUEUE_HIGH:
+		sprintf(qos_info_str, "Q_HIGH=%d", c3_entry->qos_value.q_high);
+		break;
+	default:
+		break;
+	}
+
+	/* mod */
+	switch (dump_idx) {
+	case TPM_C3_MOD_DUMP_DPTR:
+		sprintf(mod_str, "DPTR=%3d", c3_entry->pkt_mod.mod_data_idx);
+		break;
+	case TPM_C3_MOD_DUMP_IPTR:
+		sprintf(mod_str, "IPTR=%3d", c3_entry->pkt_mod.mod_cmd_idx);
+		break;
+	case TPM_C3_MOD_DUMP_L4_CHECKSUM:
+		if (c3_entry->pkt_mod.l4_chksum_update_flag)
+			sprintf(mod_str, "L4_Check EN");
+		else
+			sprintf(mod_str, "L4_Check DIS");
+		break;
+	default:
+		break;
+	}
+
+	/* duplication flow info */
+	switch (dump_idx) {
+	case TPM_C3_FLOW_DUMP_ID:
+		sprintf(flow_str, "ID=%d", c3_entry->dup_info.flow_id);
+		break;
+	case TPM_C3_FLOW_DUMP_CNT:
+		sprintf(flow_str, "CNT=%d", c3_entry->dup_info.flow_cnt);
+		break;
+	default:
+		break;
+	}
+
+	/* Entry index, including HW index, logical index */
+	switch (dump_idx) {
+	case TPM_C3_INDEX_DUMP_HASH:
+		sprintf(index_str, "HW:%04d", hash_idx);
+		break;
+	case TPM_C3_INDEX_DUMP_LOGICAL:
+		sprintf(index_str, "LOG:%04d", logic_idx);
+		break;
+	default:
+		break;
+	}
+
+	if (dump_idx <= TPM_QOS_DUMP_POLICER ||
+	    dump_idx <= TPM_C3_HEK_DUMP_KEY3 ||
+	    dump_idx <= TPM_C3_ACT_DUMP_FLOWID ||
+	    dump_idx <= TPM_C3_QOS_DUMP_QUEUE_HIGH ||
+	    dump_idx <= TPM_C3_MOD_DUMP_L4_CHECKSUM ||
+	    dump_idx <= TPM_C3_FLOW_DUMP_CNT ||
+	    dump_idx <= TPM_INDEX_DUMP_LOGICAL) {
+		printk(KERN_INFO "+ %8s | %9s | %9s | %24s | %20s | %13s | %12s | %11s | %9s | %8s +\n",
+		       lookup_type_str, port_info_str, l4_info_str, hek_str,
+		       action_str, qos_info_str, mod_str, flow_str, index_str, hit_cnt_str);
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_entry_convert
+*
+* DESCRIPTION: The routine will convert LSP C3 entry to management C3 entry.
+* INPUTS:
+*	lsp_entry - LSP C3 entry
+*
+* OUTPUTS:
+*	mng_entry - management C3 entry
+*
+*******************************************************************************/
+void tpm_sfs_c3_entry_convert(MV_PP2_CLS_C3_ENTRY *lsp_entry, struct tpm_c3_data_t *mng_entry)
+{
+	int idx;
+	/* clear */
+	memset(mng_entry, 0, sizeof(struct tpm_c3_data_t));
+
+	/* convert key control and value field */
+	mng_entry->port.port_type   = (lsp_entry->key.key_ctrl & KEY_CTRL_PRT_ID_TYPE_MASK) >> KEY_CTRL_PRT_ID_TYPE;
+	mng_entry->port.port_value  = (lsp_entry->key.key_ctrl & KEY_CTRL_PRT_ID_MASK) >> KEY_CTRL_PRT_ID;
+	mng_entry->lkp_type         = (lsp_entry->key.key_ctrl & KEY_CTRL_LKP_TYPE_MASK) >> KEY_CTRL_LKP_TYPE;
+	mng_entry->l4_type          = (lsp_entry->key.key_ctrl & KEY_CTRL_L4_MASK) >> KEY_CTRL_L4;
+	mng_entry->hek_len          = (lsp_entry->key.key_ctrl & KEY_CTRL_HEK_SIZE_MASK) >> KEY_CTRL_HEK_SIZE;
+	for (idx = 0; idx < TPM_C3_MAX_HASH_KEY_SIZE; idx++)
+		mng_entry->hek[TPM_C3_MAX_HASH_KEY_SIZE - 1 - idx] = lsp_entry->key.hek.bytes[idx];
+
+	/* convert action filed */
+	mng_entry->action.color_act   = (lsp_entry->sram.regs.actions & ACT_COLOR_MASK) >> ACT_COLOR;
+	mng_entry->action.q_low_act   = (lsp_entry->sram.regs.actions & ACT_TBL_LOW_Q_MASK) >> ACT_TBL_LOW_Q;
+	mng_entry->action.q_high_act  = (lsp_entry->sram.regs.actions & ACT_TBL_HIGH_Q_MASK) >> ACT_TBL_HIGH_Q;
+	mng_entry->action.policer_act = (lsp_entry->sram.regs.actions & ACT_POLICER_SELECT_MASK) >> ACT_POLICER_SELECT;
+	mng_entry->action.flowid_act  = (lsp_entry->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN;
+	mng_entry->action.frwd_act    = (lsp_entry->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD;
+
+	/* convert queue low, queue high, policer ID */
+	mng_entry->qos_value.q_low    = (lsp_entry->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >> ACT_QOS_ATTR_MDF_LOW_Q;
+	mng_entry->qos_value.q_high   = (lsp_entry->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >> ACT_QOS_ATTR_MDF_HIGH_Q;
+
+	/* convert modification */
+	mng_entry->pkt_mod.mod_data_idx          = (lsp_entry->sram.regs.hwf_attr & ACT_HWF_ATTR_DPTR_MASK) >> ACT_HWF_ATTR_DPTR;
+	mng_entry->pkt_mod.mod_cmd_idx           = (lsp_entry->sram.regs.hwf_attr & ACT_HWF_ATTR_IPTR_MASK) >> ACT_HWF_ATTR_IPTR;
+	mng_entry->pkt_mod.l4_chksum_update_flag = (lsp_entry->sram.regs.hwf_attr & ACT_HWF_ATTR_CHKSM_EN_MASK) >> ACT_HWF_ATTR_CHKSM_EN;
+
+	/* convert duplication */
+	mng_entry->policer_id         = (lsp_entry->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID;
+	mng_entry->dup_info.flow_id   = (lsp_entry->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID;
+	mng_entry->dup_info.flow_cnt  = (lsp_entry->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT;
+
+}
+
+void tpm_sfs_c3_entry_header_dump(void)
+{
+	print_horizontal_line(154, "=");
+	printk(KERN_INFO "= Lkp_Type | Port_Info |   L4_Info |   HEK                    |        Action_Info   |  QOS_Info     |   Mod_Info   | Duplication |    Idx    |  Hit_Cnt =\n");
+	print_horizontal_line(154, "=");
+}
+
+
+/*******************************************************************************
+* tpm_sfs_c3_entry_dump
+*
+* DESCRIPTION: The routine will dump the valid C3 entries from C3 sub-module
+*              internal DB.
+* INPUTS:
+*	type  - dump type
+*	value - value according to type
+*
+* OUTPUTS:
+*	None
+*******************************************************************************/
+static int tpm_sfs_c3_entry_dump(unsigned int type, unsigned int value)
+{
+	MV_PP2_CLS_C3_ENTRY c3;
+	unsigned int idx;
+	unsigned int num = 0;
+	unsigned int dump_idx;
+	unsigned int hash_idx;
+	unsigned int logic_idx;
+	struct tpm_c3_data_t c3_entry;
+	unsigned int hit_count;
+	int rc = TPM_OK;
+
+	/* param verification */
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, type, TPM_C3_ENTRY_DUMP_ALL, "invalid type");
+	if ((type == TPM_C3_ENTRY_DUMP_LOGIC_IDX) ||
+	    (type == TPM_C3_ENTRY_DUMP_HASH_IDX)) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, value, MV_PP2_CLS_C3_HASH_TBL_SIZE, "invalid index");
+	} else if (type == TPM_C3_ENTRY_DUMP_LOGIC_IDX) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, value, KEY_CTRL_LKP_TYPE_MAX, "invalid lookup type");
+	}
+
+
+	if ((type == TPM_C3_ENTRY_DUMP_LOGIC_IDX) ||
+	    (type == TPM_C3_ENTRY_DUMP_HASH_IDX)) {
+		if (type == TPM_C3_ENTRY_DUMP_LOGIC_IDX) {
+			rc = tpm_db_c3_hash_idx_get(value, &hash_idx);
+			/* skip invalid entry */
+			if (rc != TPM_OK) {
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "logical index(%d) is invalid\n", value);
+				return TPM_BAD_VALUE;
+			}
+			logic_idx = value;
+		} else if (type == TPM_C3_ENTRY_DUMP_HASH_IDX) {
+			rc = tpm_db_c3_logic_idx_get(value, &logic_idx);
+			/* skip invalid entry */
+			if (rc != TPM_OK) {
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "hash index(%d) is invalid\n", value);
+				return TPM_BAD_VALUE;
+			}
+			hash_idx = value;
+		}
+
+		/* print header */
+		tpm_sfs_c3_entry_header_dump();
+
+		/* read multihash entry */
+		rc = mvPp2ClsC3HwRead(&c3, hash_idx);
+		IF_ERROR_STR(TPM_SYSFS_MOD, rc, "failed to read C3 entry from HW\n");
+
+		/* convert entry */
+		tpm_sfs_c3_entry_convert(&c3, &c3_entry);
+
+		/* read hit counter */
+		rc = tpm_c3_hit_count_get(logic_idx, &hit_count);
+		IF_ERROR_STR(TPM_SYSFS_MOD, rc, "failed to read hit counter\n");
+
+		/* print C3 entry */
+		for (dump_idx = 0; dump_idx < sizeof(unsigned int) * BYTE_BITS; dump_idx++) {
+			tpm_sfs_c3_entry_line_dump(dump_idx,
+						   c3.index,
+						   logic_idx,
+						   hit_count,
+						   &c3_entry);
+		}
+
+		printk(KERN_INFO "+");
+		print_horizontal_line(152, "-");
+		printk(KERN_INFO "+\n");
+	} else if ((type == TPM_C3_ENTRY_DUMP_LU_TYPE) ||
+		 (type == TPM_C3_ENTRY_DUMP_ALL)) {
+		/* print header */
+		tpm_sfs_c3_entry_header_dump();
+
+		/* read valid C3 entry from HW and dump them by lkp_type */
+		for (idx = 0; idx < MV_PP2_CLS_C3_HASH_TBL_SIZE; idx++) {
+			rc = tpm_db_c3_logic_idx_get(idx, &logic_idx);
+			/* skip invalid entry */
+			if (rc != TPM_OK)
+				continue;
+
+			/* read multihash entry */
+			rc = mvPp2ClsC3HwRead(&c3, idx);
+			IF_ERROR_STR(TPM_SYSFS_MOD, rc, "failed to read C3 entry from HW\n");
+
+			/* convert entry */
+			tpm_sfs_c3_entry_convert(&c3, &c3_entry);
+
+			/* skip C3 entry by lkp_type */
+			if ((value != c3_entry.lkp_type) &&
+			    (type  != TPM_C3_ENTRY_DUMP_ALL))
+				continue;
+
+			/* read hit counter */
+			rc = tpm_c3_hit_count_get(logic_idx, &hit_count);
+			IF_ERROR_STR(TPM_SYSFS_MOD, rc, "failed to read hit counter\n");
+
+			/* print C3 entry */
+			for (dump_idx = 0; dump_idx < sizeof(unsigned int) * BYTE_BITS; dump_idx++) {
+				tpm_sfs_c3_entry_line_dump(dump_idx,
+							   c3.index,
+							   logic_idx,
+							   hit_count,
+							   &c3_entry);
+			}
+
+			if (0 == (idx % TPM_C3_DUMP_INTERVAL))
+				schedule_timeout_uninterruptible(TPM_C3_DUMP_DELAY);
+
+			printk(KERN_INFO "+");
+			print_horizontal_line(152, "-");
+			printk(KERN_INFO "+\n");
+
+			num++;
+		}
+
+		printk(KERN_INFO "Total Number=%d\n", num);
+	}
+
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_type_entry_dump
+*
+* DESCRIPTION:
+*       This function dumps C3 entries according to type
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_type_entry_dump(const char *buf, size_t len)
+{
+	enum c3_entry_type_idx {
+		c3_entry_type = 0,
+		c3_entry_value,
+		c3_entry_max
+	};
+	unsigned int type;
+	unsigned int value;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_entry_max)
+		parm_error_completion(param_num, c3_entry_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &type, &value);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sfs_c3_entry_dump(type, value))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_index_dump
+*
+* DESCRIPTION:
+*       This function dumps C3 index entries entries scan result
+* INPUTS:
+*       max_num - MAX allowed scan number.
+*******************************************************************************/
+static int tpm_sfs_c3_index_dump(unsigned int type)
+{
+	int idx;
+	int num = 0;
+	char index_str[8] = "";
+	char hash_idx_str[8] = "";
+	char logic_idx_str[8] = "";
+	unsigned int hash_idx;
+	unsigned int logic_idx;
+
+	int rc = TPM_OK;
+
+	/* dump multihash index table */
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "=         Multihash Index Table          =\n");
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "= Index  | Logic_Idx | Hash_Idx |  Valid =\n");
+
+	for (idx = 0; idx < MV_PP2_CLS_C3_HASH_TBL_SIZE; idx++) {
+		rc = tpm_db_c3_hash_idx_get(idx, &hash_idx);
+		if (rc == TPM_OK) {
+			sprintf(index_str, "%d", num);
+			sprintf(logic_idx_str, "%d", idx);
+			sprintf(hash_idx_str, "%d", hash_idx);
+			printk(KERN_INFO "= %6s | %9s | %8s |  %4s  =\n",
+				index_str,
+				logic_idx_str,
+				hash_idx_str,
+				"En");
+			num++;
+		} else if (type == TPM_C3_TABLE_DUMP_ALL) {
+			sprintf(index_str, "%d", num);
+			sprintf(logic_idx_str, "%d", idx);
+			sprintf(hash_idx_str, "%d", 0);
+			printk(KERN_INFO "= %6s | %9s | %8s |  %4s  =\n",
+				index_str,
+				logic_idx_str,
+				hash_idx_str,
+				"Dis");
+			num++;
+		}
+
+	}
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "Total number=%d\n", num);
+	printk(KERN_INFO "\n\n");
+
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "=         Logical Index Table            =\n");
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "= Index  | Hash_Idx | Logic_Idx |  Valid =\n");
+	num = 0;
+	for (idx = 0; idx < MV_PP2_CLS_C3_HASH_TBL_SIZE; idx++) {
+		rc = tpm_db_c3_logic_idx_get(idx, &logic_idx);
+		if (rc == TPM_OK) {
+			sprintf(index_str, "%d", num);
+			sprintf(hash_idx_str, "%d", idx);
+			sprintf(logic_idx_str, "%d", logic_idx);
+
+			printk(KERN_INFO "= %6s | %8s | %9s |  %4s  =\n",
+				index_str,
+				hash_idx_str,
+				logic_idx_str,
+				"En");
+			num++;
+		} else if (type == TPM_C3_TABLE_DUMP_ALL) {
+			sprintf(index_str, "%d", num);
+			sprintf(hash_idx_str, "%d", idx);
+			sprintf(logic_idx_str, "%d", 0);
+			printk(KERN_INFO "= %6s | %8s | %9s |  %4s  =\n",
+				index_str,
+				hash_idx_str,
+				logic_idx_str,
+				"Dis");
+			num++;
+		}
+
+	}
+	print_horizontal_line(42, "=");
+	printk(KERN_INFO "Total number=%d\n", num);
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_index_entry_dump
+*
+* DESCRIPTION:
+*       This function dumps C3 index entries according to type
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_index_entry_dump(const char *buf, size_t len)
+{
+	enum c3_index_entry_idx {
+		c3_index_entry = 0,
+		c3_index_entry_max
+	};
+	unsigned int index_entry;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_index_entry_max)
+		parm_error_completion(param_num, c3_index_entry_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &index_entry);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sfs_c3_index_dump(index_entry))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_scan_param_set
+*
+* DESCRIPTION:
+*       This function set C3 scan parameters
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_scan_param_set(const char *buf, size_t len)
+{
+	enum c3_scan_param_idx {
+		c3_scan_clear = 0,
+		c3_scan_lkp_type_en,
+		c3_scan_lkp_type,
+		c3_scan_mode,
+		c3_scan_start,
+		c3_scan_delay,
+		c3_scan_threshold,
+		c3_scan_max,
+
+	};
+	unsigned int clear;
+	unsigned int lkp_type_en;
+	unsigned int lkp_type;
+	unsigned int mode;
+	unsigned int start;
+	unsigned int delay;
+	unsigned int threshold;
+	struct tpm_c3_scan_config_t scan_config;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_scan_max)
+		parm_error_completion(param_num, c3_scan_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d %d %d",
+					&clear, &lkp_type_en, &lkp_type, &mode, &start, &delay, &threshold);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			scan_config.clear_before_scan = clear;
+			scan_config.lkp_type_scan = lkp_type_en;
+			scan_config.lkp_type = lkp_type;
+			scan_config.scan_mode = mode;
+			scan_config.start_entry = start;
+			scan_config.scan_delay = delay;
+			scan_config.scan_threshold = threshold;
+
+			if (!tpm_c3_scan_param_set(&scan_config))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_scan_result_dump
+*
+* DESCRIPTION:
+*       This function dumps C3 entries scan result
+* INPUTS:
+*       max_num - MAX allowed scan number.
+*******************************************************************************/
+static int tpm_sfs_c3_scan_result_dump(unsigned int max_num)
+{
+	int idx;
+	unsigned int entry_num;
+	struct tpm_c3_scan_entry_t result_entry[128];
+	char index_str[8] = "";
+	char hash_idx_str[8] = "";
+	char logic_idx_str[8] = "";
+	char hit_cnt_str[8] = "";
+	int rc = TPM_OK;
+
+	/* trigger and get scan result */
+	rc = tpm_c3_scan_result_get(max_num,
+				    &entry_num,
+				    result_entry);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "fail to get scan result\n");
+
+	/* dump scan result info */
+	print_horizontal_line(100, "=");
+	printk(KERN_INFO "= Index | Hash_Idx | Logic_Idx |   Hit_Cnt  =\n");
+	print_horizontal_line(100, "=");
+
+	for (idx = 0; idx < entry_num; idx++) {
+		sprintf(index_str, "%d", idx);
+		sprintf(hash_idx_str, "%d", result_entry[idx].hash_idx);
+		sprintf(logic_idx_str, "%d", result_entry[idx].logic_idx);
+		sprintf(hit_cnt_str, "%d", result_entry[idx].hit_cnt);
+		printk(KERN_INFO "= %8s | %8s | %8s |  %8s  =\n",
+			index_str,
+			hash_idx_str,
+			logic_idx_str,
+			hit_cnt_str);
+
+	}
+	print_horizontal_line(100, "=");
+	printk(KERN_INFO "Total Number:%d\n", entry_num);
+
+	return rc;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_scan_result_get
+*
+* DESCRIPTION:
+*       This function dumps C3 entries scan result
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_scan_result_get(const char *buf, size_t len)
+{
+	enum c3_scan_result_idx {
+		c3_scan_num = 0,
+		c3_scan_result_max
+	};
+	unsigned int scan_num;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_scan_result_max)
+		parm_error_completion(param_num, c3_scan_result_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &scan_num);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sfs_c3_scan_result_dump(scan_num))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_hit_count_get
+*
+* DESCRIPTION:
+*       This function get C3 entry hit counter w/ specific logic index
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_hit_count_get(const char *buf, size_t len)
+{
+	enum c3_hit_count_idx {
+		c3_logic_idx = 0,
+		c3_hit_count_max
+	};
+	unsigned int logic_idx;
+	unsigned int hit_cnt;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_hit_count_max)
+		parm_error_completion(param_num, c3_hit_count_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &logic_idx);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			/* for C3 test */
+			tpm_c3_test();
+			if (!tpm_c3_hit_count_get(logic_idx, &hit_cnt)) {
+				printk(KERN_INFO "Logical index(%d), hit counter=%d\n",
+					logic_idx, hit_cnt);
+				printk(KERN_INFO "OK\n");
+			} else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_search_depth_set
+*
+* DESCRIPTION:
+*       This function set C3 cuckoo search depth
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_c3_search_depth_set(const char *buf, size_t len)
+{
+	enum c3_search_depth_idx {
+		c3_search_depth_idx = 0,
+		c3_search_depth_max
+	};
+	unsigned int search_depth;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != c3_search_depth_max)
+		parm_error_completion(param_num, c3_search_depth_max, buf, tpm_sfs_c3_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &search_depth);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_db_c3_search_depth_set(search_depth))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_c3_config_dump
+*
+* DESCRIPTION:
+*           This function dump all C3 configuration
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_c3_config_dump(char *buf)
+{
+	struct tpm_c3_scan_config_t scan_config;
+	unsigned int search_depth;
+	int rc = TPM_OK;
+	int off = 0;
+
+	/* get C3 config */
+	rc = tpm_db_c3_scan_param_get(&scan_config);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get C3 config\n");
+
+	rc = tpm_db_c3_search_depth_get(&search_depth);
+	IF_ERROR_STR(TPM_C3_MOD, rc, "failed to get C3 search depth\n");
+
+	/* dump C3 config */
+	print_horizontal_line(100, "=");
+	printk(KERN_INFO "Scan Param\n");
+	printk(KERN_INFO "\tclear_before_scan:%-s\n", scan_config.clear_before_scan ? "enabled" : "disabled");
+	printk(KERN_INFO "\tlkp_type_scan:    %-s\n", scan_config.lkp_type_scan ? "enabled" : "disabled");
+	printk(KERN_INFO "\tlkp_type:         %-d\n", scan_config.lkp_type);
+	printk(KERN_INFO "\tscan_mode:        %-s\n", tpm_utils_scan_mode_str_get(scan_config.scan_mode));
+	printk(KERN_INFO "\tstart_entry:      %-d\n", scan_config.start_entry);
+	printk(KERN_INFO "\tscan_delay:       %-d\n", scan_config.scan_delay);
+	printk(KERN_INFO "\tscan_threshold:   %-d\n", scan_config.scan_threshold);
+
+	printk(KERN_INFO "Max Search Depth:%d\n", search_depth);
+	print_horizontal_line(100, "=");
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"entry_dump",				tpm_sfs_c3_type_entry_dump},
+	{"index_dump",				tpm_sfs_c3_index_entry_dump},
+	{"scan_param_set",			tpm_sfs_c3_scan_param_set},
+	{"scan_result_get",			tpm_sfs_c3_scan_result_get},
+	{"hit_count_get",			tpm_sfs_c3_hit_count_get},
+	{"search_depth_set",			tpm_sfs_c3_search_depth_set},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",				tpm_sfs_c3_help_debug},
+	{"config_dump",				tpm_sfs_c3_config_dump},
+};
+
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Store Attr */
+static DEVICE_ATTR(entry_dump,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(index_dump,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(scan_param_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(scan_result_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(hit_count_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(search_depth_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Show Attr */
+static DEVICE_ATTR(config_dump,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_c3_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_entry_dump.attr,
+	&dev_attr_index_dump.attr,
+	&dev_attr_scan_param_set.attr,
+	&dev_attr_scan_result_get.attr,
+	&dev_attr_hit_count_get.attr,
+	&dev_attr_search_depth_set.attr,
+	&dev_attr_config_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_c3_sw_group = {
+	.name = "c3",
+	.attrs = g_tpm_c3_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_c3_init
+*
+* DESCRIPTION: The routine will initialize TPM C3 sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_c3_init(void)
+{
+	int rc;
+
+	/* Initialize c3 sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_c3_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c4.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c4.c
new file mode 100644
index 0000000..45fb32f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_c4.c
@@ -0,0 +1,493 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_c4.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/* tpm C4 vlan num name string */
+static char *tpm_c4_vlan_str[] = {
+	"FALSE",           /* always False                         */
+	"TRUE",            /* always True                          */
+	"NO_VLAN_TAGS",      /* the packet has no VLAN tags          */
+	"VLAN_TAGS",        /* the packet has at least one VLAN tag */
+	"ONE_VLAN_TAG",      /* the packet has one VLAN tag          */
+	"TWO_VLANT_AGS",     /* the packet has two VLAN tags         */
+	"THREE_VLAN_TAGS",   /* the packet has 3 VLAN tags           */
+};
+/* tpm C4 pppoe name string */
+static char *tpm_c4_pppoe_str[] = {
+	"FALSE",	/* always False		*/
+	"TRUE",		/* always True		*/
+	"NO_PPPOE",      /* the packet has no PPPOE	*/
+	"WITH_PPPOE",   /* the packet has PPPOE	*/
+};
+/* tpm C4 MTM name string */
+static char *tpm_c4_mtm_str[] = {
+	"FALSE",		/* always False		*/
+	"TRUE",			/* always True		*/
+	"NOMAC_TO_ME",	/* the packet is no MAC_TO_ME */
+	"WITH_MAC_TO_ME",	/* the packet is MAC_TO_ME  */
+};
+/* tpm C4 l4_info name string */
+static char *tpm_c4_l4_info_str[] = {
+	"L4_INFO_FALSE",	/* always False		*/
+	"L4_INFO_TRUE",		/* always True		*/
+	"L4_INFO_0",	/* L4_INFO 0 */
+	"L4_INFO_1",		/* L4_INFO 1 */
+	"L4_INFO_2",		/* L4_INFO 2 */
+	"L4_INFO_3",		/* L4_INFO 3 */
+	"L4_INFO_4",		/* L4_INFO 4 */
+	"L4_INFO_5",		/* L4_INFO 5 */
+	"L4_INFO_6",		/* L4_INFO 6 */
+	"L4_INFO_7",		/* L4_INFO 7 */
+};
+/* tpm C4 l3_info name string */
+static char *tpm_c4_l3_info_str[] = {
+	"L3_INFO_FALSE",	/* always False	*/
+	"L3_INFO_TRUE",		/* always True	*/
+	"L3_INFO_IPV4",		/* L3_INFO IPV4 */
+	"L3_INFO_IPV6",		/* L3_INFO IPV6 */
+	"L3_INFO_0",	/* L3_INFO 0 */
+	"L3_INFO_1",		/* L3_INFO 1 */
+	"L3_INFO_2",		/* L3_INFO 2 */
+	"L3_INFO_3",		/* L3_INFO 3 */
+	"L3_INFO_4",		/* L3_INFO 4 */
+	"L3_INFO_5",		/* L3_INFO 5 */
+	"L3_INFO_6",		/* L3_INFO 6 */
+	"L3_INFO_7",		/* L3_INFO 7 */
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+int tpm_sfs_c4_help_debug(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "cat entry_dump    -  dump all C4 entries\n");
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat ruleset_dump  -  dump all ruleSet config\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_c4_entry_header_dump
+*
+* DESCRIPTION: print header.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_c4_entry_header_dump(void)
+{
+	print_horizontal_line(155, "=");
+	printk(KERN_INFO "= ruleSet  | rule_num |           Field_Name            |            Field_Value           |   QOS_Info     |    Action_Info     |         MISC           =\n");
+	print_horizontal_line(155, "=");
+}
+
+/*******************************************************************************
+* tpm_sfs_c4_entry_line_dump
+*
+* DESCRIPTION: Print one line of dump info.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_c4_entry_line_dump(unsigned int		dump_idx,
+				struct tpm_c4_add_entry_t	*rule_entry)
+{
+	char field_name_str[14] = "";
+	char qos_info_str[30] = "";
+	char action_str[18] = "";
+	char misc_str[12] = "";
+	char field_value_str[48] = "";
+	char op_str[15] = "";
+	char ruleSet_str[8] = "";
+	char rule_num_str[8] = "";
+	unsigned int field_id;
+	unsigned int field_match;
+	struct tpm_field_match_info field_match_info;
+	struct tpm_mng_pkt_key_t tpm_pkt_key_t_tmp;
+	struct tpm_pkt_key_t pkt_key_tmp;
+
+	if (0 == dump_idx) {
+		sprintf(ruleSet_str, "%02d", rule_entry->ruleSet);
+		sprintf(rule_num_str, "%03d", rule_entry->rule_num);
+	}
+
+	if (dump_idx >= rule_entry->field_num)
+		field_match = 0;
+	else {
+		field_match = rule_entry->field_op[dump_idx].field;
+		sprintf(op_str, "%s", tpm_utils_field_op_str_get(rule_entry->field_op[dump_idx].op));
+	}
+
+	if (field_match) {
+		memcpy(&pkt_key_tmp, &rule_entry->pkt_key, sizeof(struct tpm_pkt_key_t));
+		tpm_pkt_key_t_tmp.pkt_key = &pkt_key_tmp;
+		TPM_MEMSET_ZERO(field_match_info);
+		if (tpm_field_bm_to_field_info(field_match,
+					       &tpm_pkt_key_t_tmp,
+					       1,
+					       true,
+					       &field_match_info))
+			return;
+		field_id = field_match_info.field_id;
+		sprintf(field_name_str, "%s", tpm_utils_field_id_str_get(field_id));
+		if (field_id == MAC_DA_FIELD_ID ||
+		    field_id == MAC_SA_FIELD_ID) {
+			sprintf(field_value_str, "%pM", field_match_info.filed_value.mac_addr.parsed_mac_addr);
+		} else if (field_id == IPV4_SA_FIELD_ID ||
+			   field_id == IPV4_DA_FIELD_ID) {
+			sprintf(field_value_str, "%pi4", field_match_info.filed_value.ipv4_addr.parsed_ipv4_addr);
+		} else if (field_id == IPV6_SA_PREF_FIELD_ID ||
+		    field_id == IPV6_SA_SUFF_FIELD_ID ||
+		    field_id == IPV6_DA_PREF_FIELD_ID ||
+		    field_id == IPV6_DA_SUFF_FIELD_ID) {
+			sprintf(field_value_str,
+				"%04x:%04x:%04x:%04x",
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[0]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[2]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[4]),
+				*(unsigned short *)(&field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr[6]));
+		} else if (field_id == IPV6_SA_FIELD_ID ||
+			   field_id == IPV6_DA_FIELD_ID) {
+			sprintf(field_value_str, "%pi6", field_match_info.filed_value.ipv6_addr.parsed_ipv6_addr);
+		} else {
+			sprintf(field_value_str,
+				"V: 0x%x",
+				field_match_info.filed_value.int_data.parsed_int_val);
+		}
+	}
+
+	/* QOS_Info */
+	switch (dump_idx) {
+	case TPM_QOS_DUMP_DSCP:
+		sprintf(qos_info_str,
+			"DSCP=%d", rule_entry->qos_value.dscp);
+		break;
+	case TPM_QOS_DUMP_PBIT:
+		sprintf(qos_info_str,
+			"PBIT=%d", rule_entry->qos_value.pri);
+		break;
+	case TPM_QOS_DUMP_GEMPORT:
+		sprintf(qos_info_str,
+			"GEMP=%d", rule_entry->qos_value.gemp);
+		break;
+	case TPM_QOS_DUMP_QUEUE_LOW:
+		sprintf(qos_info_str,
+			"Q_L=%d", rule_entry->qos_value.q_low);
+		break;
+	case TPM_QOS_DUMP_QUEUE_HIGH:
+		sprintf(qos_info_str,
+			"Q_H=%d", rule_entry->qos_value.q_high);
+		break;
+	case TPM_QOS_DUMP_POLICER:
+		if (rule_entry->policer_id != 0xFFFF)
+			sprintf(qos_info_str,
+				"Policer ID = %d",
+				rule_entry->policer_id);
+		break;
+	}
+
+	/* Action */
+	switch (dump_idx) {
+	case TPM_ACT_DUMP_DSCP:
+		sprintf(action_str, "DSCP: %s", tpm_utils_common_action_str_get(rule_entry->action.dscp_act));
+		break;
+	case TPM_ACT_DUMP_PBIT:
+		sprintf(action_str, "PBIT: %s", tpm_utils_common_action_str_get(rule_entry->action.pri_act));
+		break;
+	case TPM_ACT_DUMP_GEMPORT:
+		sprintf(action_str, "GEMP: %s", tpm_utils_common_action_str_get(rule_entry->action.gemp_act));
+		break;
+	case TPM_ACT_DUMP_QUEUE_LOW:
+		sprintf(action_str, "Q_LOW: %s", tpm_utils_common_action_str_get(rule_entry->action.q_low_act));
+		break;
+	case TPM_ACT_DUMP_QUEUE_HIGH:
+		sprintf(action_str, "Q_HIGH: %s", tpm_utils_common_action_str_get(rule_entry->action.q_high_act));
+		break;
+	case TPM_ACT_DUMP_COLOR:
+		sprintf(action_str, "COLOR: %s", tpm_utils_color_str_get(rule_entry->action.color_act));
+		break;
+	case TPM_ACT_DUMP_POLICER:
+		sprintf(action_str, "POLICER: %s", tpm_utils_common_action_str_get(rule_entry->action.policer_act));
+		break;
+	case TPM_ACT_DUMP_FRWD:
+		sprintf(action_str, "FRWD: %s", tpm_utils_frwd_action_str_get(rule_entry->action.frwd_act));
+		break;
+	case TPM_ACT_DUMP_FLOWID:
+		sprintf(action_str, "FLOWID: %s", tpm_utils_flow_id_action_str_get(rule_entry->action.flowid_act));
+		break;
+	}
+
+	/* MISC */
+	switch (dump_idx) {
+	case TPM_C4_MISC_DUMP_VLAN:
+		sprintf(misc_str, "VLAN: %s", tpm_c4_vlan_str[rule_entry->vlan_num]);
+		break;
+	case TPM_C4_MISC_DUMP_PPPOE:
+		sprintf(misc_str, "PPPOE: %s", tpm_c4_pppoe_str[rule_entry->pppoe]);
+		break;
+	case TPM_C4_MISC_DUMP_MTM:
+		sprintf(misc_str, "MTM: %s", tpm_c4_mtm_str[rule_entry->mac_to_me]);
+		break;
+	case TPM_C4_MISC_DUMP_L4_INFO:
+		sprintf(misc_str, "L4_INFO: %s", tpm_c4_l4_info_str[rule_entry->l4_info]);
+		break;
+	case TPM_C4_MISC_DUMP_L3_INFO:
+		sprintf(misc_str, "L3_INFO: %s", tpm_c4_l3_info_str[rule_entry->l3_info]);
+		break;
+	}
+
+	if (dump_idx == 0 ||
+	    field_match ||
+	    dump_idx <= TPM_QOS_DUMP_POLICER ||
+	    dump_idx <= TPM_C4_MISC_DUMP_L3_INFO ||
+	    dump_idx <= TPM_ACT_DUMP_FLOWID) {
+		printk(KERN_INFO "+ %8s | %8s | %13s  %15s  | %32s | %14s | %18s | %22s +\n",
+			ruleSet_str, rule_num_str, field_name_str, op_str,
+			field_value_str, qos_info_str, action_str, misc_str);
+	}
+}
+
+void tpm_sfs_c4_entry_dump(struct tpm_c4_add_entry_t	*rule_entry)
+{
+	unsigned int i;
+
+	/* Print header */
+	tpm_sfs_c4_entry_header_dump();
+
+	/* First line */
+	for (i = 0; i < sizeof(unsigned int) * BYTE_BITS; i++)
+		tpm_sfs_c4_entry_line_dump(i, rule_entry);
+
+	printk(KERN_INFO "+");
+	print_horizontal_line(155, "-");
+	printk(KERN_INFO "+\n");
+
+	print_horizontal_line(155, "=");
+}
+
+static int tpm_sfs_c4_all_entry_dump(char *buf)
+{
+	int			tpm_ret = 0;
+	int			ruleSet = 0;
+	int			rule_num = 0;
+	struct tpm_db_c4_rule_t db_c4_rule;
+
+	for (ruleSet = 0; ruleSet < MV_PP2_CLS_C4_GRPS_NUM; ruleSet++) {
+		for (rule_num = 0; rule_num < MV_PP2_CLS_C4_GRP_SIZE; rule_num++) {
+			/* get from DB */
+			tpm_ret = tpm_db_c4_rule_get(ruleSet, rule_num, &db_c4_rule);
+			IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get rule of ruleSet(%d) rule_num(%d) DB failed\n",
+				ruleSet, rule_num);
+
+			if (!db_c4_rule.valid)
+				continue;
+			tpm_sfs_c4_entry_dump(&db_c4_rule.rule_entry);
+		}
+	}
+
+	return TPM_OK;
+}
+static int tpm_sfs_c4_ruleset_dump(char *buf)
+{
+	int			tpm_ret = 0;
+	int			uni_port;
+	int			ruleSet = 0;
+	int			rule_num_max = 0;
+	struct tpm_class_port_t	src_port;
+
+	src_port.port_type = TPM_CLASS_SWITCH_PORT_BM;
+	printk(KERN_INFO "\n    UNI     ruleSet    rule_num_max\n");
+	for (uni_port = 0; uni_port < TPM_NUM_MAX_UNI_PORTS; uni_port++) {
+		src_port.class_port = uni_port;
+		/* get from DB */
+		tpm_ret = tpm_db_c4_port_to_ruleset_get(&src_port, &ruleSet, &rule_num_max);
+		IF_ERROR_STR(TPM_MNG_MOD, tpm_ret, "get ruleSet of UNI(%d) DB failed\n", uni_port);
+		printk(KERN_INFO "    %d     %d        %d\n", uni_port, ruleSet, rule_num_max);
+	}
+
+	return TPM_OK;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",				tpm_sfs_c4_help_debug},
+	{"entry_dump",				tpm_sfs_c4_all_entry_dump},
+	{"ruleset_dump",			tpm_sfs_c4_ruleset_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Show Attr */
+static DEVICE_ATTR(entry_dump,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ruleset_dump,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_c4_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_entry_dump.attr,
+	&dev_attr_ruleset_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_c4_sw_group = {
+	.name = "c4",
+	.attrs = g_tpm_c4_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_c4_init
+*
+* DESCRIPTION: The routine will initialize TPM c4 sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_c4_init(void)
+{
+	int rc;
+
+	/* Initialize c4 sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_c4_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_cls.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_cls.c
new file mode 100644
index 0000000..f16bbf1
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_cls.c
@@ -0,0 +1,1020 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_cls.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+static int tpm_sfs_help_cls_lkp_dcod_cmd(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [flow_log_id] [flow_len] [way] [cpu_q] > lkp_dcod_entry_set\n");
+	off += sprintf(buf+off, "echo [luid] [first_pri]                     > lkp_dcod_luid_set\n");
+	off += sprintf(buf+off, "echo                                        > lkp_dcod_add\n");
+	off += sprintf(buf+off, "echo [flow_log_id]                          > lkp_dcod_ena\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += sprintf(buf+off, "cat lkp_dcod_hits_dump   -  dump cls decode table hit entry\n");
+#endif
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+static int tpm_sfs_help_cls_fl_rl_cmd(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo                                                   > fl_rule_init\n");
+	off += sprintf(buf+off, "echo [fl_log_id] [port_type] [port_bm] [lu_type]\n");
+	off += sprintf(buf+off, "echo [enabled] [prio] [engine [field_id_cnt]\n");
+	off += sprintf(buf+off, "echo [field_id0] [field_id1] [field_id2] [field_id3]   > fl_rule_set\n");
+	off += sprintf(buf+off, "echo                                                   > fl_rule_add\n");
+	off += sprintf(buf+off, "echo                                                   > fl_rule_ena\n");
+	off += sprintf(buf+off, "echo                                                   > fl_rule_dis\n");
+	off += sprintf(buf+off, "cat fl_rule_hits_dump   -  dump flow table hit entry (only for ALP A0 version)\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+static struct tpm_cls_lkp_dcod_entry_t	g_lkp_dcod_entry;
+static struct tpm_cls_fl_rule_list_t	g_fl_rls;
+
+/*******************************************************************************
+* tpm_sfs_lkp_dcod_entry_set
+*
+* DESCRIPTION: The routine sets the lookup ID structure in the global lookup decode table
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_lkp_dcod_entry_set(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_flow_log_id = 0,
+		param_flow_len,
+		param_way,
+		param_cpu_q,
+		max_params
+	};
+
+	int				flow_log_id;
+	int				way;
+	int				cpu_q;
+	int				flow_len;
+	int				parsedargs;
+	int				numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params)
+		parm_error_completion(numparms, max_params, buf, tpm_sfs_help_cls_lkp_dcod_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %d", &flow_log_id, &flow_len, &way, &cpu_q);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			g_lkp_dcod_entry.cpu_q = cpu_q;
+			g_lkp_dcod_entry.flow_len = flow_len;
+			g_lkp_dcod_entry.flow_log_id = flow_log_id;
+			g_lkp_dcod_entry.luid_num = 0;
+			g_lkp_dcod_entry.way = way;
+			printk(KERN_INFO "OK\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_lkp_dcod_luid_set
+*
+* DESCRIPTION: The routine sets the lookup ID information in the global lookup decode table
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_lkp_dcod_luid_set(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_luid = 0,
+		param_first_pri,
+		max_params
+	};
+
+	int	luid;
+	int	first_pri;
+	int	parsedargs;
+	int	numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params)
+		parm_error_completion(numparms, max_params, buf, tpm_sfs_help_cls_lkp_dcod_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &luid, &first_pri);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			g_lkp_dcod_entry.luid_list[g_lkp_dcod_entry.luid_num].luid = luid;
+			g_lkp_dcod_entry.luid_list[g_lkp_dcod_entry.luid_num].first_pri = first_pri;
+			g_lkp_dcod_entry.luid_num++;
+			printk(KERN_INFO "OK\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_lkp_dcod_add
+*
+* DESCRIPTION: The routine add the entry in the global lookup decode table
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_lkp_dcod_add(const char *buf, size_t len)
+{
+	if (TPM_OK == tpm_cls_lkp_dcod_set(&g_lkp_dcod_entry))
+		printk(KERN_INFO "OK\n");
+	else
+		printk(KERN_INFO "FAIL\n");
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_lkp_dcod_ena
+*
+* DESCRIPTION: The routine enables a single lookup ID in the lookup decode table
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_lkp_dcod_ena(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_flow_log_id = 0,
+		max_params
+	};
+
+	int	flow_log_id;
+	int	parsedargs;
+	int	numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params)
+		parm_error_completion(numparms, max_params, buf, tpm_sfs_help_cls_lkp_dcod_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &flow_log_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (TPM_OK == tpm_cls_lkp_dcod_enable(flow_log_id))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_fl_rule_init
+*
+* DESCRIPTION: The routine initializes the global flow rules to default
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_fl_rule_init(const char *buf, size_t len)
+{
+	memset(&g_fl_rls, 0, sizeof(g_fl_rls));
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_cls_rl_print
+*
+* DESCRIPTION:
+*	This function prints the CLS rule entry information
+* INPUTS:
+*	offset - CLS HW offset
+*	fl_rule - rule information structure
+*	hw_dump - LSP dump flag
+*******************************************************************************/
+void tpm_sfs_cls_rl_print(unsigned int			offset,
+			struct tpm_db_cls_fl_rule_t	*fl_rule,
+			bool				hw_dump)
+{
+	unsigned int	k;
+	unsigned short ref_sum = 0;
+
+	IF_NULL_NO_RET(TPM_SYSFS_MOD, fl_rule);
+
+#ifndef CONFIG_MV_ETH_PP2_1
+	ref_sum = fl_rule->ref_cnt;
+#else
+	for (k = 0; k < TPM_MAX_NUM_GMACS; k++)
+		ref_sum += fl_rule->ref_cnt[k];
+#endif
+	print_horizontal_line(40, "=");
+
+	printk(KERN_INFO "CLS_INFO: IDX(HW[%d] log[%d]) lkp_type[%d] port(bm[%x] type[%d]) prio[%d] ref_cnt[%d] eng[%s] fld_id_cnt[%d]",
+		offset,
+		fl_rule->rl_log_id,
+		fl_rule->lu_type,
+		fl_rule->port_bm,
+		fl_rule->port_type,
+		fl_rule->prio,
+		ref_sum,
+		tpm_utils_eng_no_str_get((int)fl_rule->engine),
+		fl_rule->field_id_cnt);
+
+	if (fl_rule->field_id_cnt) {
+		printk(KERN_INFO " fld_id[");
+		for (k = 0; k < fl_rule->field_id_cnt; k++)
+			if (k+1 == fl_rule->field_id_cnt)
+				printk(KERN_INFO "%s]\n", tpm_utils_field_id_str_get(fl_rule->field_id[k]));
+			else
+				printk(KERN_INFO "%s, ", tpm_utils_field_id_str_get(fl_rule->field_id[k]));
+	} else
+		printk(KERN_INFO "\n");
+
+	if (hw_dump) {
+		MV_PP2_CLS_FLOW_ENTRY	fe;
+
+		print_horizontal_line(20, "=");
+		mvPp2ClsSwFlowClear(&fe);
+		mvPp2ClsHwFlowRead(offset, &fe);
+		mvPp2ClsSwFlowDump(&fe);
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_fl_rule_set
+*
+* DESCRIPTION: The routine sets a single flow rule in the global flow rules
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_fl_rule_set(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_fl_log_id = 0,
+		param_port_type,
+		param_port_bm,
+		param_lu_type,
+		param_enabled,
+		param_prio,
+		param_engine,
+		param_field_id_cnt,
+		param_field_id1,
+		param_field_id2,
+		param_field_id3,
+		param_field_id4,
+		max_params
+	};
+
+	int		fl_log_id;
+	int		port_type;
+	int		port_bm;
+	int		lu_type;
+	int		enabled;
+	int		prio;
+	int		engine;
+	int		field_id_cnt;
+	unsigned char	field_id[TPM_FLOW_FIELD_COUNT_MAX];
+	int		parsedargs;
+	int		numparms;
+
+	if (g_fl_rls.fl_len == TPM_CLS_FLOW_RULE_MAX - 1) {
+		printk(KERN_INFO "flow is full of rules: %d\n", g_fl_rls.fl_len);
+		return;
+	}
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params)
+		parm_error_completion(numparms, max_params, buf, tpm_sfs_help_cls_fl_rl_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d %d %d %d %d %d %d %d %d %d ", &fl_log_id, &port_type,
+					&port_bm, &lu_type, &enabled, &prio, &engine,
+					&field_id_cnt, (int *)&field_id[0], (int *)&field_id[1], (int *)&field_id[2],
+					(int *)&field_id[3]);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			g_fl_rls.fl[g_fl_rls.fl_len].fl_log_id	= fl_log_id;
+			g_fl_rls.fl[g_fl_rls.fl_len].port_type	= port_type;
+			g_fl_rls.fl[g_fl_rls.fl_len].port_bm	= port_bm;
+			g_fl_rls.fl[g_fl_rls.fl_len].lu_type	= lu_type;
+			g_fl_rls.fl[g_fl_rls.fl_len].enabled	= enabled;
+			g_fl_rls.fl[g_fl_rls.fl_len].prio		= prio;
+			g_fl_rls.fl[g_fl_rls.fl_len].engine		= engine;
+			g_fl_rls.fl[g_fl_rls.fl_len].field_id_cnt	= field_id_cnt;
+			memcpy(g_fl_rls.fl[g_fl_rls.fl_len].field_id, field_id, sizeof(field_id));
+			g_fl_rls.fl_len++;
+			printk(KERN_INFO "OK\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_fl_rule_add
+*
+* DESCRIPTION: The routine adds the current global flow rules
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_fl_rule_add(const char *buf, size_t len)
+{
+	int	rc;
+
+	rc = tpm_cls_fl_rule_add(&g_fl_rls);
+
+	if (TPM_OK == rc)
+		printk(KERN_INFO "%d rules added\n", g_fl_rls.fl_len);
+
+	if (TPM_OK == rc)
+		printk(KERN_INFO "OK\n");
+	else
+		printk(KERN_INFO "FAIL\n");
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_fl_rule_ena
+*
+* DESCRIPTION: The routine enables the current global flow rules
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_fl_rule_ena(const char *buf, size_t len)
+{
+	int rc, i;
+
+	rc = tpm_cls_fl_rule_enable(&g_fl_rls);
+
+	if (TPM_OK == rc)
+		for (i = 0; i < g_fl_rls.fl_len; i++)
+			printk(KERN_INFO "rule:%d assigned logical rule ID:%d\n", i, g_fl_rls.fl[i].rl_log_id);
+
+	if (TPM_OK == rc)
+		printk(KERN_INFO "OK\n");
+	else
+		printk(KERN_INFO "FAIL\n");
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_fl_rule_dis
+*
+* DESCRIPTION: The routine disables a logical rule according to input array
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*	len - the buf length
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+void tpm_sfs_fl_rule_dis(const char *buf, size_t len)
+{
+	int		i;
+	unsigned short	rl_log_id[TPM_CLS_FLOW_RULE_MAX];
+	unsigned short	rl_log_id_len;
+	int loop = 0;
+	struct tpm_class_port_t	src_port;
+
+	for (i = 0; i < g_fl_rls.fl_len; i++)
+		rl_log_id[i] = g_fl_rls.fl[i].fl_log_id;
+
+	rl_log_id_len = g_fl_rls.fl_len;
+	src_port.port_type = (enum tpm_class_port_type_t)g_fl_rls.fl[0].port_type;
+
+	for (loop = 0; loop < TPM_MAX_NUM_GMACS; loop++) {
+		if ((1 << loop) & g_fl_rls.fl[0].port_bm) {
+			src_port.class_port = (1 << loop);
+			if (TPM_OK == tpm_cls_fl_rule_disable(rl_log_id, rl_log_id_len, &src_port))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_cls_lkp_dcod_dump
+*
+* DESCRIPTION: The routine dump all logical decode DB information.
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	returns 0 in any event
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sfs_cls_lkp_dcod_dump(char *buf)
+{
+	unsigned int			i, j;
+	struct tpm_db_cls_lkp_dcod_t	lkp_dcod_db;
+	int				rc;
+
+	print_horizontal_line(80, "=");
+	printk(KERN_INFO "log_id enabled  cpu  way alloc len off luid_no = luid_list (luid/first-prio)\n");
+	for (i = 0; i < TPM_MNG_FLOW_ID_MAX; i++) {
+		rc = tpm_db_cls_lkp_dcod_get(i, &lkp_dcod_db);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "tpm_db_cls_lkp_dcod_get returned error %d\n", rc);
+			printk(KERN_INFO "FAIL\n");
+			return 0;
+		}
+		printk(KERN_INFO "%6d %-7s  0x%02X %-3d %5d %3d %3d %7d = ",
+			i, tpm_utils_valid_str_get((int)lkp_dcod_db.enabled),
+			(int)lkp_dcod_db.cpu_q, (int)lkp_dcod_db.way, (int)lkp_dcod_db.flow_alloc_len,
+			(int)lkp_dcod_db.flow_len, lkp_dcod_db.flow_off, lkp_dcod_db.luid_num);
+		for (j = 0; j < lkp_dcod_db.luid_num; j++)
+			printk(KERN_INFO "%2d/%2d ", lkp_dcod_db.luid_list[j].luid, lkp_dcod_db.luid_list[j].first_pri);
+		printk(KERN_INFO "\n");
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* tpm_sfs_cls_lkp_hits_dump
+*
+* DESCRIPTION: The routine dump all hit decode entry and its DB information. Only
+*              valid for ALP A0 version.
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	returns 0 in any event
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sfs_cls_lkp_hits_dump(char *buf)
+{
+	int rc = TPM_OK;
+	unsigned int fl_log_id = 0, lkpid = 0, way = 0, hit_cnt = 0;
+	unsigned int i;
+	struct tpm_db_cls_lkp_dcod_t lkp_dcod_db;
+
+	print_horizontal_line(30, "=");
+	printk(KERN_INFO "log_id  lkp_id  way  hit_cnt\n");
+	/* Get the lookupID and WAY */
+	for (lkpid = 0; lkpid < MV_PP2_CLS_LKP_TBL_SIZE ; lkpid++) {
+		for (way = TPM_WAY_NON_PON; way <= TPM_WAY_PON; way++) {
+			rc = mvPp2V1ClsHwLkpHitGet(lkpid, way, &hit_cnt);
+			if (rc != TPM_OK) {
+				printk(KERN_INFO "lookup ID%d,way%d hit cnt read fail\n", lkpid, way);
+				printk(KERN_INFO "FAIL\n");
+				return 0;
+			}
+			if (!hit_cnt)
+				continue;
+
+			/* Get logical ID */
+			for (fl_log_id = 0; fl_log_id < TPM_MNG_FLOW_ID_MAX; fl_log_id++) {
+				rc = tpm_db_cls_lkp_dcod_get(fl_log_id, &lkp_dcod_db);
+				if (rc != TPM_OK) {
+					printk(KERN_INFO "tpm_db_cls_lkp_dcod_get returned error %d\n", rc);
+					printk(KERN_INFO "FAIL\n");
+					return 0;
+				}
+				if (lkp_dcod_db.luid_num == 0)
+					continue;
+				for (i = 0; i < lkp_dcod_db.luid_num; i++) {
+					if (lkp_dcod_db.luid_list[i].luid == lkpid &&
+					    lkp_dcod_db.way == way) {
+						printk(KERN_INFO "%3d      %3d   %3d    %3d\n",
+							fl_log_id, lkpid, way, hit_cnt);
+						break;
+					}
+				}
+				if (i < lkp_dcod_db.luid_num)
+					break;
+			}
+			if (fl_log_id == TPM_MNG_FLOW_ID_MAX) {
+				printk(KERN_INFO "logical id not found for lkpid%d way%d\n", lkpid, way);
+				printk(KERN_INFO "FAIL\n");
+				return 0;
+			}
+			hit_cnt = 0;
+		}
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+* tpm_sfs_cls_fl_hits_dump
+*
+* DESCRIPTION: The routine dump all hit flow table entry. Only valid in A0 version.
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	returns 0 in any event
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sfs_cls_fl_hits_dump(char *buf)
+{
+	int rc = TPM_OK;
+
+	rc = mvPp2V1ClsHwFlowHitsDump();
+	if (rc) {
+		printk(KERN_INFO "flow table hits dump error\n");
+		printk(KERN_INFO "FAIL\n");
+		return 0;
+	}
+
+	return 0;
+}
+#endif
+
+/*******************************************************************************
+* tpm_sfs_cls_fl_rls_dump
+*
+* DESCRIPTION: The routine dump all logical flow ID rules.
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	returns 0 in any event
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sfs_cls_fl_rls_dump(char *buf)
+{
+	unsigned int				i, j, k;
+	struct tpm_db_cls_fl_rule_list_t	fl_rl_list_db;
+	struct tpm_db_cls_lkp_dcod_t		lkp_dcod_db;
+	int					rc;
+	unsigned short ref_sum = 0;
+
+	print_horizontal_line(80, "=");
+	printk(KERN_INFO "log_flow_id enabled offset engine logID lut portBm portType pri refCnt fid# = field_Ids\n");
+
+	for (i = 0; i < TPM_MNG_FLOW_ID_MAX; i++) {
+		rc = tpm_db_cls_lkp_dcod_get(i, &lkp_dcod_db);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "tpm_db_cls_lkp_dcod_get returned error %d\n", rc);
+			printk(KERN_INFO "FAIL\n");
+			return 0;
+		}
+		if (lkp_dcod_db.flow_len == 0)
+			continue;
+
+		printk(KERN_INFO "%-11d ", i);
+
+		rc = tpm_db_cls_fl_rule_list_get(lkp_dcod_db.flow_off, lkp_dcod_db.flow_len, fl_rl_list_db.flow);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "tpm_db_cls_fl_rule_list_get returned error %d\n", rc);
+			printk(KERN_INFO "FAIL\n");
+			return 0;
+		}
+
+		for (j = 0; j < lkp_dcod_db.flow_len; j++) {
+			if (j != 0)
+				printk(KERN_INFO "\t    ");
+
+			printk(KERN_INFO "%-6s  %6d %-6s",
+				tpm_utils_valid_str_get((int)fl_rl_list_db.flow[j].enabled),
+				lkp_dcod_db.flow_off + j,
+				tpm_utils_eng_no_str_get((int)fl_rl_list_db.flow[j].engine));
+#ifndef CONFIG_MV_ETH_PP2_1
+				ref_sum = fl_rl_list_db.flow[j].ref_cnt;
+#else
+				for (k = 0; k < TPM_MAX_NUM_GMACS; k++)
+					ref_sum += fl_rl_list_db.flow[j].ref_cnt[k];
+#endif
+
+			printk(KERN_INFO " %5d %3d %6d %8d %3d %6d %4d = ",
+				fl_rl_list_db.flow[j].rl_log_id,
+				fl_rl_list_db.flow[j].lu_type,
+				fl_rl_list_db.flow[j].port_bm,
+				fl_rl_list_db.flow[j].port_type,
+				fl_rl_list_db.flow[j].prio,
+				ref_sum,
+				fl_rl_list_db.flow[j].field_id_cnt);
+
+			for (k = 0; k < fl_rl_list_db.flow[j].field_id_cnt; k++)
+				printk(KERN_INFO "%2d ", fl_rl_list_db.flow[j].field_id[k]);
+			printk(KERN_INFO "\n");
+		}
+		if (lkp_dcod_db.flow_len)
+			printk(KERN_INFO "\n");
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+* tpm_sfs_cls_fl_log_rls_dump
+*
+* DESCRIPTION: The routine dump all logical flow ID and rule offset.
+*
+* INPUTS:
+*	buf - pointer to sysfs buffer
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	returns 0 in any event
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sfs_cls_fl_log_rls_dump(char *buf)
+{
+	unsigned int			i;
+	int				rc;
+	unsigned short			off;
+
+	print_horizontal_line(80, "=");
+
+	rc = tpm_db_cls_rl_off_get(&off, 0);
+	if (rc != TPM_OK) {
+		printk(KERN_INFO "tpm_db_cls_rl_off_get returned error %d\n", rc);
+		printk(KERN_INFO "FAIL\n");
+		return 0;
+	}
+
+	printk(KERN_INFO "number of rules=%d\n", off-TPM_CLS_LOG2OFF_START);
+
+	if (off-TPM_CLS_LOG2OFF_START > 0) {
+		printk(KERN_INFO "log_rule_ID = flow_table_offset\n");
+
+		for (i = 1; i < TPM_CLS_LOG2OFF_TBL_SIZE; i++) {
+			rc = tpm_db_cls_rl_off_get(&off, i);
+			if (TPM_NO_RESOURCE == rc) {
+				return 0;
+			} else if (rc != TPM_OK) {
+				printk(KERN_INFO "tpm_db_cls_rl_off_get returned error %d\n", rc);
+				printk(KERN_INFO "FAIL\n");
+				return 0;
+			}
+
+			if (off != TPM_CLS_FREE_FL_LOG) {
+				printk(KERN_INFO "%11d = %17d", i, off);
+				printk(KERN_INFO "\n");
+			}
+		}
+	}
+
+	return 0;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE CLS                               */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"lkp_dcod_entry_set",		tpm_sfs_lkp_dcod_entry_set},
+	{"lkp_dcod_luid_set",		tpm_sfs_lkp_dcod_luid_set},
+	{"lkp_dcod_add",		tpm_sfs_lkp_dcod_add},
+	{"lkp_dcod_ena",		tpm_sfs_lkp_dcod_ena},
+	{"fl_rule_init",		tpm_sfs_fl_rule_init},
+	{"fl_rule_set",			tpm_sfs_fl_rule_set},
+	{"fl_rule_add",			tpm_sfs_fl_rule_add},
+	{"fl_rule_ena",			tpm_sfs_fl_rule_ena},
+	{"fl_rule_dis",			tpm_sfs_fl_rule_dis}
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+/* ========================================================================== */
+/*              TPM CFG SYS FS SHOW ROUTINE CLS                               */
+/* ========================================================================== */
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help_lkp_dcod_cmd",		tpm_sfs_help_cls_lkp_dcod_cmd},
+	{"help_fl_rl_cmd",		tpm_sfs_help_cls_fl_rl_cmd},
+	{"lkp_dcod_dump",		tpm_sfs_cls_lkp_dcod_dump},
+#ifdef CONFIG_MV_ETH_PP2_1
+	{"lkp_dcod_hits_dump",		tpm_sfs_cls_lkp_hits_dump},
+	{"fl_rule_hits_dump",		tpm_sfs_cls_fl_hits_dump},
+#endif
+	{"fl_rls_dump",			tpm_sfs_cls_fl_rls_dump},
+	{"fl_log_rls_dump",		tpm_sfs_cls_fl_log_rls_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cls_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cls_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+
+static DEVICE_ATTR(help_lkp_dcod_cmd,		S_IRUSR,	tpm_cls_show, NULL);
+static DEVICE_ATTR(help_fl_rl_cmd,		S_IRUSR,	tpm_cls_show, NULL);
+
+static DEVICE_ATTR(lkp_dcod_entry_set,		S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(lkp_dcod_luid_set,		S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(lkp_dcod_add,		S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(lkp_dcod_ena,		S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(fl_rule_init,		S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(fl_rule_set,			S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(fl_rule_add,			S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(fl_rule_ena,			S_IWUSR,	NULL, tpm_cls_store);
+static DEVICE_ATTR(fl_rule_dis,			S_IWUSR,	NULL, tpm_cls_store);
+
+static DEVICE_ATTR(lkp_dcod_dump,		S_IRUSR,	tpm_cls_show, NULL);
+#ifdef CONFIG_MV_ETH_PP2_1
+static DEVICE_ATTR(lkp_dcod_hits_dump,		S_IRUSR,	tpm_cls_show, NULL);
+static DEVICE_ATTR(fl_rule_hits_dump,		S_IRUSR,	tpm_cls_show, NULL);
+#endif
+static DEVICE_ATTR(fl_rls_dump,			S_IRUSR,	tpm_cls_show, NULL);
+static DEVICE_ATTR(fl_log_rls_dump,		S_IRUSR,	tpm_cls_show, NULL);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_cls_sw_attrs[] = {
+	&dev_attr_help_lkp_dcod_cmd.attr,
+	&dev_attr_help_fl_rl_cmd.attr,
+
+	&dev_attr_lkp_dcod_entry_set.attr,
+	&dev_attr_lkp_dcod_luid_set.attr,
+	&dev_attr_lkp_dcod_add.attr,
+	&dev_attr_lkp_dcod_ena.attr,
+
+	&dev_attr_fl_rule_init.attr,
+	&dev_attr_fl_rule_set.attr,
+	&dev_attr_fl_rule_add.attr,
+	&dev_attr_fl_rule_ena.attr,
+	&dev_attr_fl_rule_dis.attr,
+
+	&dev_attr_lkp_dcod_dump.attr,
+#ifdef CONFIG_MV_ETH_PP2_1
+	&dev_attr_lkp_dcod_hits_dump.attr,
+	&dev_attr_fl_rule_hits_dump.attr,
+#endif
+	&dev_attr_fl_rls_dump.attr,
+	&dev_attr_fl_log_rls_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_cls_sw_group = {
+	.name = "cls",
+	.attrs = g_tpm_cls_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_cls_init
+*
+* DESCRIPTION: The routine will initialize TPM cls sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_cls_init(void)
+{
+	int rc;
+
+	/* Initialize cls sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_cls_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_init.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_init.c
new file mode 100644
index 0000000..8507f46
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_init.c
@@ -0,0 +1,1838 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_init.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* sys_help_tpm_init_cfg
+*
+* DESCRIPTION: This function dump tpm init config help information
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sys_help_tpm_init_cfg(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [gmac] [mode]                   > switch_mode_set        - set switch head mode for ETH type GMAC port\n");
+	off += sprintf(buf+off, "\tgmac(dec): GMAC number, 0:GMAC0, 1:GMAC1; mode(dec): head mode, 0:None, 1:MH, 2:MH_ETYPE_DSA, 3:DSA, 4:EXT_DSA\n\n");
+	off += sprintf(buf+off, "echo [gmac] [mh]                     > gmac_def_mh_set        - set default TX MH for ETH type GMAC port\n");
+	off += sprintf(buf+off, "\tgmac(dec): GMAC number, 0:GMAC0, 1:GMAC1; mh(hex): Marvell header\n\n");
+	off += sprintf(buf+off, "echo [init]                          > switch_init_set        - set switch init flag to enable or disable switch\n");
+	off += sprintf(buf+off, "\tinit(dec): whether init switch, 0:do not init switch, 1:init switch\n\n");
+	off += sprintf(buf+off, "echo [handler]                       > mc_data_handler_set    - set multicast data handler, UC or MC\n");
+	off += sprintf(buf+off, "\thandler(dec): handler mode, 0:general classifier, 1:exact match, 2:multicast\n\n");
+	off += sprintf(buf+off, "echo [layer] [action]                > mc_flow_default_set    - set default action for multicast flow\n");
+	off += sprintf(buf+off, "\tlayer(dec): MC flow layer, 0:L2, 1:L3\n\n");
+	off += sprintf(buf+off, "\taction(dec): default action, 0:drop, 1:to CPU\n\n");
+	off += sprintf(buf+off, "echo [pp_bm] [handler]               > mc_proto_handler_set   - set multicast protocol handler per pp port\n");
+	off += sprintf(buf+off, "\tpp_bm(hex): PP port bitmap, 0x01:GMAC0, 0x02:GMAC1, 0x04:PON MAC; handler(dec): handler mode, 0:general classifier, 1:exact match, 2:multicast\n\n");
+	off += sprintf(buf+off, "echo [handler]                       > mc_sw_handler_set    - set multicast switch handler, done by MC API or user\n");
+	off += sprintf(buf+off, "\thandler(dec): handler mode, 0:swicth is set by user, 1:swicth is set by MC API\n\n");
+	off += sprintf(buf+off, "echo [uni_num]                       > uni_port_num_set       - set uni port number\n");
+	off += sprintf(buf+off, "\tuni_num(dec): MAX UNI ports\n\n");
+	off += sprintf(buf+off, "echo [support]                       > ipv6_support_set       - set IPv6 support\n");
+	off += sprintf(buf+off, "\tsupport(dec): 0: do not support, 1:support\n\n");
+	off += sprintf(buf+off, "echo [queue]                         > cpu_trap_queue_set     - set CPU trap queue\n");
+	off += sprintf(buf+off, "\tqueue(dec): CPU trap RX queue\n\n");
+	off += sprintf(buf+off, "echo [action]                        > ttl_illegal_action_set - set action for illegal zero TTL\n");
+	off += sprintf(buf+off, "\taction(dec): 0:not care,1:drop, 2:to CPU\n\n");
+	off += sprintf(buf+off, "echo [action]                        > bad_chksum_action_set - set action for bad L3/4 checksum packet\n");
+	off += sprintf(buf+off, "\taction(dec): 0:not care,1:drop\n\n");
+	off += sprintf(buf+off, "echo [tpid]                          > mod_vlan_tpid_set      - set tpid for VLAN modification\n");
+	off += sprintf(buf+off, "\ttpid(hex): TPID for VLAN modification\n\n");
+	off += sprintf(buf+off, "echo [tpid1] [tpid2]                 > tpid_combo_set         - add VLAN TPID combination\n");
+	off += sprintf(buf+off, "echo [tpid1] [tpid2]                 > tpid_combo_del         - delete VLAN TPID combination\n");
+	off += sprintf(buf+off, "\ttpid1,tpid2(hex): TPIDs, 0xFFFF: Do not care.\n");
+	off += sprintf(buf+off, "\tFor 2-tag, tpid1: outer TPID, tpid2: inner TPID; For 1-tag, tpid1: TPID, tpid2:must be 0xFFFF\n\n");
+	off += sprintf(buf+off, "echo [mode]                          > tcp_flag_check_set     - set the ability whether check TCP flag\n");
+	off += sprintf(buf+off, "\tmode(dec):0:do not check,1:check\n\n");
+	off += sprintf(buf+off, "echo [mode]                          > qos_tbl_ext_set        - set the QoS table usage mode\n");
+	off += sprintf(buf+off, "\tmode(dec):0:do not use,1:owned by TPM, 2:owned by customer\n\n");
+	off += sprintf(buf+off, "echo [support]                       > cnm_support_set       - set CTC CnM support\n");
+	off += sprintf(buf+off, "\tsupport(dec): 0: do not support, 1:support\n\n");
+	off += sprintf(buf+off, "echo [flag(hex)]                     > trace_debug_flag_set   - set TPM default trace and debug flag\n");
+	off += sprintf(buf+off, "\t0x%04x:TPM_PRS_MOD, 0x%04x:TPM_PME_MOD,    0x%04x:TPM_MNG_MOD,    0x%08x:TPM_DEBUG_MASK\n",
+				TPM_PRS_MOD, TPM_PME_MOD, TPM_MNG_MOD, TPM_DEBUG_MASK);
+	off += sprintf(buf+off, "\t0x%04x:TPM_CLS_MOD, 0x%04x:TPM_QOS_MOD,    0x%04x:TPM_DB_MOD,     0x%08x:TPM_INFO_MASK\n",
+				TPM_CLS_MOD, TPM_QOS_MOD, TPM_DB_MOD, TPM_INFO_MASK);
+	off += sprintf(buf+off, "\t0x%04x:TPM_C2_MOD,  0x%04x:TPM_SWITCH_MOD, 0x%04x:TPM_SYSFS_MOD,  0x%08x:TPM_WARN_MASK\n",
+				TPM_C2_MOD, TPM_SWITCH_MOD, TPM_SYSFS_MOD, TPM_WARN_MASK);
+	off += sprintf(buf+off, "\t0x%04x:TPM_C3_MOD,  0x%04x:TPM_API_MOD,    0x%04x:TPM_COMMON_MOD, 0x%08x:TPM_ERROR_MASK\n",
+				TPM_C3_MOD, TPM_API_MOD, TPM_COMMON_MOD, TPM_ERROR_MASK);
+	off += sprintf(buf+off, "\t0x%04x:TPM_C4_MOD,  0x%04x:TPM_INIT_MOD,   0x%04x:TPM_IOCTL_MOD,  0x%08x:TPM_FATAL_MASK\n",
+				TPM_C4_MOD, TPM_INIT_MOD, TPM_IOCTL_MOD, TPM_FATAL_MASK);
+	/* tpm cfg setup */
+	off += sprintf(buf+off, "echo 1                               > module_start       - Start TPM module while applying init configuration\n\n");
+	off += sprintf(buf+off, "-----------------------------------------------------------------------------------------------------------\n");
+	off += sprintf(buf+off, "cat                                    init_cfg_dump          - Dump init module configuration\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/*******************************************************************************
+* sys_help_tpm_init_cap
+*
+* DESCRIPTION: This function dump tpm capability config help information
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sys_help_tpm_init_cap(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [type] [rule_type] [field_bm] [vlan_num] [pre] [hits]  > capability_set         - add capability\n");
+	off += sprintf(buf+off, "echo [type] [rule_type] [field_bm] [vlan_num]               > capability_del         - delete capability\n");
+	off += sprintf(buf+off, "\ttype(dec): capability type, 0:exact match and exception handling, 1:general classification\n");
+	off += sprintf(buf+off, "\trule_type(dec): only valid for CLS caps, from 0 to 15, caps in smaller rule_type gets higher priority\n");
+	off += sprintf(buf+off, "\tfield_bm(hex): matching field bitmap\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tvlan_num(dec):\n");
+	off += sprintf(buf+off, "\t    %d: TPM_NO_VLAN\n",		TPM_NO_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_SINGLE_VLAN\n",		TPM_SINGLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_DOUBLE_VLAN\n",		TPM_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_TRIPLE_VLAN\n",		TPM_TRIPLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_NOT_DOUBLE_VLAN\n",	TPM_NOT_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_ANY_VLAN\n",		TPM_ANY_VLAN);
+	off += sprintf(buf+off, "\tpre(dec): precedence, ranges from 0 to 63\n");
+	off += sprintf(buf+off, "\thits(dec): max port hits, 1 or 2\n");
+	off += sprintf(buf+off, "-----------------------------------------------------------------------------------\n");
+	off += sprintf(buf+off, "cat                                    capability_dump        - Dump all capability\n");
+
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/*******************************************************************************
+* sys_help_tpm_init_filter
+*
+* DESCRIPTION: This function dump tpm filter config help information
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sys_help_tpm_init_filter(char *buf)
+{
+	int off = 0;
+
+	/* filter */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [rule_type] [pre] [field_bm] [vlan_num] > filter_set	  - add filter type\n");
+	off += sprintf(buf+off, "\trule_type(dec): from 0 to 15, filter in smaller rule_type gets higher priority\n");
+	off += sprintf(buf+off, "\tpre(dec): precedence, ranges from 0 to 63\n");
+	off += sprintf(buf+off, "\tfield_bm(hex): matching field bitmap, see capability help\n");
+	off += tpm_sfs_help_parse_rule_bm_print(buf, off);
+	off += sprintf(buf+off, "\tvlan_num(dec):\n");
+	off += sprintf(buf+off, "\t    %d: TPM_NO_VLAN\n",		TPM_NO_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_SINGLE_VLAN\n",		TPM_SINGLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_DOUBLE_VLAN\n",		TPM_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_TRIPLE_VLAN\n",		TPM_TRIPLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_NOT_DOUBLE_VLAN\n",	TPM_NOT_DOUBLE_VLAN);
+	off += sprintf(buf+off, "\t    %d: TPM_ANY_VLAN\n",		TPM_ANY_VLAN);
+	off += sprintf(buf+off, "----------------------------------------------------------------------------------\n");
+	off += sprintf(buf+off, "cat     filter_dump        - Dump all filters\n");
+
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/*******************************************************************************
+* sys_help_tpm_mib_reset
+*
+* DESCRIPTION: This function dump tpm MIB reset help information
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sys_help_tpm_mib_reset(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [reset_level] > mib_reset -  Do TPM MIB reset with reset level\n");
+	off += sprintf(buf+off, "\treset_level(hex), reset level\n");
+	off += sprintf(buf+off, "\t   0:high level, reset all TPM configuration and reset TPM to none started state\n");
+	off += sprintf(buf+off, "\t   1: medium level, reset all TPM configuration including parser config\n");
+	off += sprintf(buf+off, "\t   2: low level, reset TPM configuration except parser config\n");
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* sfs_tpm_module_start
+*
+* DESCRIPTION: This function initializes tpm module
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+*	len - Number of characters in buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+void sfs_tpm_module_start(const char *buf, size_t len)
+{
+	enum setup_parm_indx_t {
+		setup_flag = 0,
+		setup_max
+	};
+	int cfg_flag;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != setup_max) {
+		parm_error_completion(numparms, setup_max, buf, sys_help_tpm_init_cfg);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &cfg_flag);
+
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_module_start())
+				printk(KERN_INFO "\nTPM Start OK\n");
+			else
+				printk(KERN_INFO "\nTPM Start FAIL\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* sfs_tpm_mib_reset
+*
+* DESCRIPTION: This function does tpm MIB reset
+*
+* INPUTS:
+*	buf - Shell parameters as char buffer
+*	len - Number of characters in buffer
+* OUTPUTS:
+*         None.
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_mib_reset(const char *buf, size_t len)
+{
+	enum tpm_mib_reset_parm_indx_t {
+		tpm_reset_level = 0,
+		tpm_mib_reset_max
+	};
+
+	unsigned int reset_level;
+	int parsedargs;
+	int numparms;
+	int tpm_ret;
+
+	numparms = count_parameters(buf);
+	if (numparms != tpm_mib_reset_max)
+		parm_error_completion(numparms, tpm_mib_reset_max, buf, sys_help_tpm_mib_reset);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &reset_level);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_ret = tpm_mib_reset(reset_level);
+			if (TPM_OK == tpm_ret)
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_switch_mode_set
+*
+* DESCRIPTION: This function sets GMAC switch head mode.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_switch_mode_set(const char *buf, size_t len)
+{
+	enum switch_mode_para_idx {
+		switch_mode_port = 0,
+		switch_mode_head_mode,
+		switch_mode_max
+	};
+	unsigned int port;
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+	int tpm_ret;
+
+	param_num = count_parameters(buf);
+	if (param_num != switch_mode_max)
+		parm_error_completion(param_num, switch_mode_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpm_ret = tpm_init_switch_mode_set((enum tpm_gmacs_enum_t)port, (enum tpm_sw_head_mode_t)mode);
+			if (TPM_OK == tpm_ret)
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_gmac_def_mh_set
+*
+* DESCRIPTION: This function sets default TX MH for GMAC.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_gmac_def_mh_set(const char *buf, size_t len)
+{
+	enum def_mh_para_idx {
+		def_mh_port = 0,
+		def_mh,
+		def_mh_max
+	};
+	unsigned int port;
+	unsigned int mh;
+	int parsed_args;
+	int param_num;
+	int tpm_ret;
+
+	param_num = count_parameters(buf);
+	if (param_num != def_mh_max)
+		parm_error_completion(param_num, def_mh_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %x", &port, &mh);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpm_ret = tpm_init_gmac_def_mh_set((enum tpm_gmacs_enum_t)port, (unsigned short)mh);
+			if (TPM_OK == tpm_ret)
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_switch_init_set
+*
+* DESCRIPTION: This function sets the flag whether init switch.
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_switch_init_set(const char *buf, size_t len)
+{
+	enum switch_init_para_idx {
+		switch_init = 0,
+		switch_init_max
+	};
+	unsigned int init;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != switch_init_max)
+		parm_error_completion(param_num, switch_init_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &init);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_switch_init_set((enum tpm_sw_init_mode_t)init))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_tpm_filter_set
+*
+* DESCRIPTION: This function sets the filter.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tpm_filter_set(const char *buf, size_t len)
+{
+	enum tpm_filter_set_para_idx {
+		tpm_filter_set_rule_type = 0,
+		tpm_filter_set_priority,
+		tpm_filter_set_bm,
+		tpm_filter_set_vlan_num,
+		tpm_filter_set_max
+	};
+	unsigned int priority;
+	unsigned int rule_type;
+	unsigned int bm;
+	unsigned int vlan_number;
+
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpm_filter_set_max)
+		parm_error_completion(param_num, tpm_filter_set_max, buf, sys_help_tpm_init_filter);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %x %d", &rule_type, &priority, &bm, &vlan_number);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_filter_type_set(rule_type, priority, bm, vlan_number))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+* sfs_tpm_cfg_tpm_capability_set
+*
+* DESCRIPTION: This function sets the capability.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tpm_capability_set(const char *buf, size_t len)
+{
+	enum tpm_capability_set_para_idx {
+		tpm_capability_set_type = 0,
+		tpm_capability_set_rule_type,
+		tpm_capability_set_bm,
+		tpm_capability_set_vlan_num,
+		tpm_capability_set_pre,
+		tpm_capability_set_hits,
+		tpm_capability_set_max
+	};
+	unsigned int type;
+	unsigned int rule_type;
+	unsigned int bm;
+	unsigned int pre;
+	unsigned int hits;
+	unsigned int vlan_number;
+	struct tpm_capability_t cap;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpm_capability_set_max)
+		parm_error_completion(param_num, tpm_capability_set_max, buf, sys_help_tpm_init_cap);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %x %d %d %d", &type, &rule_type, &bm, &vlan_number, &pre, &hits);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			cap.rule_type = rule_type;
+			cap.field_match_bm = bm;
+			cap.tag_num = vlan_number;
+			cap.precedence = (unsigned char)pre;
+			cap.max_port_hits = (unsigned char)hits;
+			if (!tpm_init_capability_set((enum tpm_cap_type_t)type, &cap))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_tpm_capability_del
+*
+* DESCRIPTION: This function deletes the capability.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tpm_capability_del(const char *buf, size_t len)
+{
+	enum tpm_capability_set_para_idx {
+		tpm_capability_set_type = 0,
+		tpm_capability_set_rule_type,
+		tpm_capability_set_bm,
+		tpm_capability_set_pre,
+		tpm_capability_set_hits,
+		tpm_capability_set_max
+	};
+	unsigned int type;
+	unsigned int rule_type;
+	unsigned int bm;
+	unsigned int pre;
+	unsigned int hits;
+	struct tpm_capability_t cap;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpm_capability_set_max)
+		parm_error_completion(param_num, tpm_capability_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %x %d %d", &type, &rule_type, &bm, &pre, &hits);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			cap.field_match_bm = bm;
+			cap.rule_type = rule_type;
+			cap.precedence = (unsigned char)pre;
+			cap.max_port_hits = (unsigned char)hits;
+			if (!tpm_init_capability_del((enum tpm_cap_type_t)type, &cap))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_mc_data_handler_set
+*
+* DESCRIPTION: This function sets the handler of multicast packet.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_mc_data_handler_set(const char *buf, size_t len)
+{
+	enum mc_flow_default_para_idx {
+		mc_data_handle = 0,
+		mc_data_handle_max
+	};
+	unsigned int data_handle;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mc_data_handle_max)
+		parm_error_completion(param_num, mc_data_handle_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &data_handle);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_mc_data_handler_set((enum tpm_traffic_handler_t)data_handle))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_mc_flow_default_set
+*
+* DESCRIPTION: This function sets the default action for multicast flow.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_mc_flow_default_set(const char *buf, size_t len)
+{
+	enum mc_flow_default_para_idx {
+		mc_flow_layer = 0,
+		mc_flow_default,
+		mc_flow_default_max
+	};
+	unsigned int mc_layer, mc_default;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mc_flow_default_max)
+		parm_error_completion(param_num, mc_flow_default_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &mc_layer, &mc_default);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_mc_flow_default_set(mc_layer, (enum tpm_mc_flow_def_action_t)mc_default))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_mc_proto_handler_set
+*
+* DESCRIPTION: This function sets the default multicast protocol handler per PP port.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_mc_proto_handler_set(const char *buf, size_t len)
+{
+	enum mc_proto_handler_para_idx {
+		mc_proto_handler_port = 0,
+		mc_proto_handler_handler,
+		mc_proto_handler_max
+	};
+	unsigned int port;
+	unsigned int handler;
+	struct tpm_port_mc_proto_handler_t mc_handler;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mc_proto_handler_max)
+		parm_error_completion(param_num, mc_proto_handler_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x %d", &port, &handler);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			mc_handler.port = (enum tpm_pp_port_t)port;
+			mc_handler.mc_proto_handler = (enum tpm_traffic_handler_t)handler;
+			if (!tpm_init_mc_proto_handler_set(&mc_handler))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_mc_data_handler_set
+*
+* DESCRIPTION: This function sets the handler of multicast packet.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_mc_sw_handler_set(const char *buf, size_t len)
+{
+	enum mc_sw_handle_para_idx {
+		mc_sw_handle = 0,
+		mc_sw_handle_max
+	};
+	unsigned int sw_handle;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mc_sw_handle_max)
+		parm_error_completion(param_num, mc_sw_handle_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &sw_handle);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_mc_sw_handler_set((enum tpm_mc_switch_handler_t)sw_handle))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_uni_port_num_set
+*
+* DESCRIPTION: This function sets supported maximum UNI ports.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_uni_port_num_set(const char *buf, size_t len)
+{
+	enum uni_port_num_para_idx {
+		uni_port_num = 0,
+		uni_port_num_max
+	};
+	unsigned int num;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != uni_port_num_max)
+		parm_error_completion(param_num, uni_port_num_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &num);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_uni_port_num_set(num))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_ipv6_support_set
+*
+* DESCRIPTION: This function sets the flag that whether support IPv6.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_ipv6_support_set(const char *buf, size_t len)
+{
+	enum ipv6_support_set_para_idx {
+		ipv6_support_set = 0,
+		ipv6_support_set_max
+	};
+	unsigned int ipv6_support;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != ipv6_support_set_max)
+		parm_error_completion(param_num, ipv6_support_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &ipv6_support);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_ipv6_support_set((enum tpm_ipv6_support_t)ipv6_support))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_cpu_trap_queue_set
+*
+* DESCRIPTION: This function sets the CPU trap RX queue.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_cpu_trap_queue_set(const char *buf, size_t len)
+{
+	enum cpu_trap_queue_set_para_idx {
+		cpu_trap_queue_set = 0,
+		cpu_trap_queue_set_max
+	};
+	unsigned int queue;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != cpu_trap_queue_set_max)
+		parm_error_completion(param_num, cpu_trap_queue_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &queue);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_cpu_trap_queue_set(queue))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_ttl_illegal_action_set
+*
+* DESCRIPTION: This function sets the action for illegal zero TTL.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_ttl_illegal_action_set(const char *buf, size_t len)
+{
+	enum ttl_illegal_action_set_para_idx {
+		ttl_illegal_action_set = 0,
+		ttl_illegal_action_set_max
+	};
+	unsigned int action;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != ttl_illegal_action_set_max)
+		parm_error_completion(param_num, ttl_illegal_action_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &action);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_ttl_illegal_action_set((enum tpm_ttl_illegal_action_t)action))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_bad_chksum_action_set
+*
+* DESCRIPTION: This function sets the action for bad checksum packet.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_bad_chksum_action_set(const char *buf, size_t len)
+{
+	enum bad_chksum_action_set_para_idx {
+		bad_chksum_action_set = 0,
+		bad_chksum_action_set_max
+	};
+	unsigned int action;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != bad_chksum_action_set_max)
+		parm_error_completion(param_num, bad_chksum_action_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &action);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_bad_chksum_action_set((enum tpm_bad_chksum_action_t)action))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+* sfs_tpm_cfg_mod_vlan_tpid_set
+*
+* DESCRIPTION: This function sets supported TPID for VLAN modification
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_mod_vlan_tpid_set(const char *buf, size_t len)
+{
+	enum mod_vlan_tpid_set_para_idx {
+		mod_vlan_tpid_set = 0,
+		mod_vlan_tpid_set_max
+	};
+	unsigned int tpid;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mod_vlan_tpid_set_max)
+		parm_error_completion(param_num, mod_vlan_tpid_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x", &tpid);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_mod_vlan_tpid_set((unsigned short)tpid))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_tpid_combo_set
+*
+* DESCRIPTION: This function sets supported TPID for VLAN modification.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tpid_combo_set(const char *buf, size_t len)
+{
+	enum tpid_combo_para_idx {
+		tpid_combo_tpid1 = 0,
+		tpid_combo_tpid2,
+		tpid_combo_max
+	};
+	unsigned int tpid1;
+	unsigned int tpid2;
+	struct tpm_tpid_combo_t tpid_combo;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpid_combo_max)
+		parm_error_completion(param_num, tpid_combo_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x %x", &tpid1, &tpid2);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpid_combo.tpid1 = (unsigned short)tpid1;
+			tpid_combo.tpid2 = (unsigned short)tpid2;
+			tpid_combo.valid = true;
+			if (!tpm_init_tpid_combo_set(&tpid_combo))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_tpid_combo_del
+*
+* DESCRIPTION: This function deletes supported TPID for VLAN modification.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tpid_combo_del(const char *buf, size_t len)
+{
+	enum tpid_combo_para_idx {
+		tpid_combo_tpid1 = 0,
+		tpid_combo_tpid2,
+		tpid_combo_max
+	};
+	unsigned int tpid1;
+	unsigned int tpid2;
+	struct tpm_tpid_combo_t tpid_combo;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tpid_combo_max)
+		parm_error_completion(param_num, tpid_combo_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x %x", &tpid1, &tpid2);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			tpid_combo.tpid1 = (unsigned short)tpid1;
+			tpid_combo.tpid2 = (unsigned short)tpid2;
+			tpid_combo.valid = true;
+			if (!tpm_init_tpid_combo_del(&tpid_combo))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_tcp_flag_check_set
+*
+* DESCRIPTION: This function sets the flag that whether need to check TCP flag
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_tcp_flag_check_set(const char *buf, size_t len)
+{
+	enum tcp_flag_check_set_para_idx {
+		tcp_flag_check_set = 0,
+		tcp_flag_check_set_max
+	};
+	unsigned int flag_check;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != tcp_flag_check_set_max)
+		parm_error_completion(param_num, tcp_flag_check_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &flag_check);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_tcp_flag_check_set((enum tpm_tcp_flag_check_t)flag_check))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_trace_debug_flag_set
+*
+* DESCRIPTION: This function sets TPM module trace and debug flag.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_trace_debug_flag_set(const char *buf, size_t len)
+{
+	enum trace_debug_flag_set_para_idx {
+		trace_debug_flag_set = 0,
+		trace_debug_flag_set_max
+	};
+	unsigned int trace_debug_flag;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != trace_debug_flag_set_max)
+		parm_error_completion(param_num, trace_debug_flag_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x", &trace_debug_flag);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_trace_debug_flag_set(trace_debug_flag))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_qos_tbl_ext_set
+*
+* DESCRIPTION: This function sets QoS table owner.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_qos_tbl_ext_set(const char *buf, size_t len)
+{
+	enum qos_tbl_ext_set_para_idx {
+		qos_tbl_ext_set = 0,
+		qos_tbl_ext_set_max
+	};
+	unsigned int qos_tbl_ext;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != qos_tbl_ext_set_max)
+		parm_error_completion(param_num, qos_tbl_ext_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x", &qos_tbl_ext);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_qos_tbl_ext_set((enum tpm_qos_tbl_owner_t)qos_tbl_ext))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_cnm_support_set
+*
+* DESCRIPTION: This function sets the flag that whether support CTC CnM.
+*
+* INPUTS:
+*	buf     - Shell parameters as character buffer
+*	len     - Number of characters in buffer
+* OUTPUTS:
+*	None
+* COMMENT:
+*        The routine will be called during TPM start, so different macros is used,
+* for OK print it is not necessary to appear during normal start; for FAIL print,
+* it should always appear if routine return error code.
+*******************************************************************************/
+void sfs_tpm_cfg_cnm_support_set(const char *buf, size_t len)
+{
+	enum cnm_support_set_para_idx {
+		cnm_support_set = 0,
+		cnm_support_set_max
+	};
+	unsigned int cnm_support;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != cnm_support_set_max)
+		parm_error_completion(param_num, cnm_support_set_max, buf, sys_help_tpm_init_cfg);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &cnm_support);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_init_cnm_support_set((enum tpm_init_cnm_mode_t)cnm_support))
+				TPM_OS_INFO(TPM_SYSFS_MOD, "OK\n")
+			else
+				TPM_OS_ERROR(TPM_SYSFS_MOD, "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sysfs_capbility_field_get()
+*
+* DESCRIPTION: get capability field bitmap string
+*
+* INPUTS:
+*	field_match_bm  - filed match bitmap of capability
+*
+* OUTPUTS:
+*	None
+* RETURNS:
+*	capability field bitmap string
+*
+*******************************************************************************/
+char *tpm_sysfs_capbility_field_get(unsigned int field_match_bm)
+{
+	static char str[256];
+	int index = 0;
+	int offset = 0;
+	int num = 0;
+
+	memset(str, 0, sizeof(str));
+	for (index = 0; index < 32; index++) {
+		if (((1 << index) & field_match_bm) &&
+		    ((1 << index) & TPM_MATCH_FIELD_ALL)) {
+			if (!num)
+				offset += sprintf(str+offset, "%s",
+						tpm_init_lookup_enum_str(TPM_INIT_ENUM_CAPABILITY_FIELD, (1 << index)));
+			else
+				offset += sprintf(str+offset, ", %s",
+						tpm_init_lookup_enum_str(TPM_INIT_ENUM_CAPABILITY_FIELD, (1 << index)));
+
+			num++;
+		}
+	}
+
+	offset += sprintf(str+offset, "\n");
+
+	return str;
+}
+
+/*******************************************************************************
+* sfs_tpm_capability_dump
+*
+* DESCRIPTION: This function dump the capability.
+*
+* INPUTS:
+*	buf     - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sfs_tpm_capability_dump(char *buf)
+{
+	int off = 0;
+	int index;
+	struct tpm_init_cap_conf_t cap;
+	int ret_code = TPM_OK;
+
+	/* Dump Exact match and exception handling capability */
+	printk(KERN_INFO "Exact match and exception handling capability\n");
+	printk(KERN_INFO "-------------------------------------------------------------------\n");
+	printk(KERN_INFO "Capability   rule_type  field_bm   vlan_num  precedence max_port_hits   field_bm_str\n");
+	for (index = 0; index < TPM_NUM_MAX_CAPABILITIES; index++) {
+		ret_code = tpm_db_init_capability_get(TPM_CAP_TYPE_EXACT_EXCEPT, index, &cap);
+		IF_ERROR_STR(TPM_SYSFS_MOD, ret_code, "failed to get capability\n");
+
+		if (cap.valid == TPM_TRUE)
+			printk(KERN_INFO "%5d     %7d       0x%08x    %1.1d         %2.2d            %1.1d          %s",
+			       index, cap.rule_type, cap.field_match_bm, cap.tag_num, cap.precedence, cap.max_port_hits,
+			       tpm_sysfs_capbility_field_get(cap.field_match_bm));
+		else
+			continue;
+	}
+
+	/* Dump generic classifier capability */
+	printk(KERN_INFO "\nGeneric classifier capability\n");
+	printk(KERN_INFO "-------------------------------------------------------------------\n");
+	printk(KERN_INFO "Capability   rule_type  field_bm   vlan_num  precedence   max_port_hits   field_bm_str\n");
+	for (index = 0; index < TPM_NUM_MAX_CAPABILITIES; index++) {
+		ret_code = tpm_db_init_capability_get(TPM_CAP_TYPE_CLS, index, &cap);
+		IF_ERROR_STR(TPM_SYSFS_MOD, ret_code, "failed to get capability\n");
+
+		if (cap.valid == TPM_TRUE)
+			printk(KERN_INFO "%5d     %7d       0x%08x    %1.1d         %2.2d            %1.1d          %s",
+			       index, cap.rule_type, cap.field_match_bm, cap.tag_num, cap.precedence, cap.max_port_hits,
+			       tpm_sysfs_capbility_field_get(cap.field_match_bm));
+		else
+			continue;
+	}
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_filter_dump
+*
+* DESCRIPTION: This function dump the filter.
+*
+* INPUTS:
+*	buf     - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sfs_tpm_filter_dump(char *buf)
+{
+	int off = 0;
+	int index;
+	struct tpm_init_filter_t filter;
+	int ret_code = TPM_OK;
+
+	/* Dump Exact match and exception handling filter */
+	printk(KERN_INFO "filters that have been configured:\n");
+	printk(KERN_INFO "-------------------------------------------------------------------\n");
+	printk(KERN_INFO "Index   rule_type  field_bm   vlan_num  precedence   field_bm_str\n");
+	for (index = 0; index < TPM_NUM_MAX_FILTER_TYPE; index++) {
+		ret_code = tpm_db_init_filter_type_get(index, &filter);
+		IF_ERROR_STR(TPM_SYSFS_MOD, ret_code, "failed to get filter\n");
+
+		if (filter.valid == TPM_TRUE)
+			printk(KERN_INFO "%3d     %6d     0x%08x     %1.1d         %2.2d        %s",
+			       index, filter.rule_type, filter.field_match_bm, filter.tag_num,
+			       filter.precedence, tpm_sysfs_capbility_field_get(filter.field_match_bm));
+		else
+			continue;
+	}
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_init_cfg_dump
+*
+* DESCRIPTION: This function dump TPM init config.
+*
+* INPUTS:
+*	buf     - Shell parameters as char buffer
+* OUTPUTS:
+*	None
+*******************************************************************************/
+int sfs_tpm_init_cfg_dump(char *buf)
+{
+	int off = 0;
+	int index;
+	enum tpm_sw_head_mode_t sw_head_mode;
+	unsigned short mh;
+	unsigned short tpid;
+	unsigned int value;
+	struct tpm_port_mc_proto_handler_t mc_handler;
+	struct tpm_tpid_combo_t tpid_combo;
+	int ret_code = TPM_OK;
+
+	printk(KERN_INFO "TPM init module configuration\n");
+	printk(KERN_INFO "----------------------------------------------------\n\n");
+	printk(KERN_INFO "TPM module state: %s\n\n",
+		tpm_init_lookup_enum_str(TPM_INIT_ENUM_MODULE_STATE, tpm_db_module_state_get()));
+
+	/* Dump GMAC switch mode */
+	printk(KERN_INFO "GMAC switch mode:\n");
+	printk(KERN_INFO "------------------------\n");
+	for (index = 0; index < TPM_NUM_ETH_GMACS; index++) {
+		sw_head_mode = tpm_db_init_switch_mode_get(index);
+		printk(KERN_INFO "GMAC%d: %s\n",
+			index, tpm_init_lookup_enum_str(TPM_INIT_ENUM_SWITCH_MODE, sw_head_mode));
+	}
+	printk(KERN_INFO "\n");
+
+	/* Dump GMAC default TX MH */
+	printk(KERN_INFO "GMAC  default TX MH:\n");
+	printk(KERN_INFO "------------------------\n");
+	for (index = 0; index < TPM_NUM_ETH_GMACS; index++) {
+		mh = tpm_db_init_gmac_def_mh_get(index);
+		printk(KERN_INFO "GMAC%d: 0x%x\n", index, mh);
+	}
+	printk(KERN_INFO "\n");
+
+	/* Dump switch init mode */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_SWITCH_INIT, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "switch init mode: %s\n", tpm_init_lookup_enum_str(TPM_INIT_ENUM_SWITCH_INIT, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump L2 multicast flow default action */
+	ret_code = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L2, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "L2 multicast flow default action: %s\n",
+		tpm_init_lookup_enum_str(TPM_INIT_ENUM_MC_DEF_ACTION, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump L3 multicast flow default action */
+	ret_code = tpm_db_init_mc_flow_def_get(TPM_MC_TRAFFIC_L3, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "L3 multicast flow default action: %s\n",
+		tpm_init_lookup_enum_str(TPM_INIT_ENUM_MC_DEF_ACTION, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump multicast protocol handler */
+	printk(KERN_INFO "multicast protocol handler:\n");
+	printk(KERN_INFO "------------------------\n");
+	for (index = 0; index < TPM_NUM_MAX_GMAC_PORTS; index++) {
+		ret_code = tpm_db_init_mc_proto_handler_get(index, &mc_handler);
+		IF_ERROR(TPM_SYSFS_MOD, ret_code);
+		printk(KERN_INFO "PP port(0x%x): %s\n", mc_handler.port,
+			tpm_init_lookup_enum_str(TPM_INIT_ENUM_MC_HANDLER, mc_handler.mc_proto_handler));
+	}
+	printk(KERN_INFO "\n");
+
+	/* Dump multicast swicth cfg handler */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_MC_SW_HANDLE, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "MC swicth cfg handler: %s\n", tpm_init_lookup_enum_str(TPM_INIT_ENUM_SW_HANDLER, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump UNI ports */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_MAX_UNI_NUM, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "UNI ports number: %d\n", value);
+	printk(KERN_INFO "\n");
+
+	/* Dump IPv6 support */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "IPv6 support: %s\n", tpm_init_lookup_enum_str(TPM_INIT_ENUM_IPV6_SUPPORT, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump CPU trap RX queue */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_CPU_RX_QUEUE, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "CPU trap RX queue: %d\n", value);
+	printk(KERN_INFO "\n");
+
+	/* Dump TTL zero illegal action */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_TTL_ILLEGAL_ACTION, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "TTL zero illegal action : %s\n",
+		tpm_init_lookup_enum_str(TPM_INIT_ENUM_TTL_ILLEGAL_ACTION, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump bad checksum action */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_BAD_CHKSUM_ACTION, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "Bad checksum action : %s\n",
+		tpm_init_lookup_enum_str(TPM_INIT_ENUM_TTL_ILLEGAL_ACTION, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump MOD TPID */
+	printk(KERN_INFO "MOD TPID:\n");
+	printk(KERN_INFO "------------------------\n");
+	for (index = 0; index < TPM_NUM_MAX_GMAC_PORTS; index++) {
+		ret_code = tpm_db_init_mod_tpid_get(index, &tpid);
+		IF_ERROR(TPM_SYSFS_MOD, ret_code);
+		printk(KERN_INFO "TPID %d: 0x%0x\n", index, tpid);
+	}
+	printk(KERN_INFO "\n");
+
+	/* Dump TPID combo */
+	printk(KERN_INFO "TPID combo:\n");
+	printk(KERN_INFO "------------------------\n");
+	printk(KERN_INFO "combo index: tpid1   tpid2\n");
+	for (index = 0; index < TPM_NUM_MAX_TPID_COMBO; index++) {
+		ret_code = tpm_db_init_tpid_combo_get(index, &tpid_combo);
+		IF_ERROR(TPM_SYSFS_MOD, ret_code);
+		if (true == tpid_combo.valid)
+			printk(KERN_INFO "    %2.2d:       0x%0x  0x%0x\n", index, tpid_combo.tpid1, tpid_combo.tpid2);
+		else
+			continue;
+	}
+	printk(KERN_INFO "\n");
+
+	/* Dump TCP flag check */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_TCP_FLAG_CHECK, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "TCP flag check: %s\n", tpm_init_lookup_enum_str(TPM_INIT_ENUM_TCP_FLAG_CHECK, value));
+	printk(KERN_INFO "\n");
+
+	/* Dump trace and debug flag */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_TRACE_DEBUG_FLAG, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "trace and debug flag: 0x%0x\n", value);
+	printk(KERN_INFO "\n");
+
+	/* Dump QoS table ext */
+	ret_code = tpm_db_generic_param_get(TPM_DB_PARAM_QOS_TABLE_EXT, &value);
+	IF_ERROR(TPM_SYSFS_MOD, ret_code);
+	printk(KERN_INFO "QoS table ext: %s\n", tpm_init_lookup_enum_str(TPM_INIT_ENUM_QOS_TABLE_OWNER, value));
+	printk(KERN_INFO "\n");
+
+	return off;
+}
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"switch_mode_set",		sfs_tpm_cfg_switch_mode_set},
+	{"gmac_def_mh_set",		sfs_tpm_cfg_gmac_def_mh_set},
+	{"switch_init_set",		sfs_tpm_cfg_switch_init_set},
+	{"capability_set",		sfs_tpm_cfg_tpm_capability_set},
+	{"filter_set",			sfs_tpm_cfg_tpm_filter_set},
+	{"capability_del",		sfs_tpm_cfg_tpm_capability_del},
+	{"mc_data_handler_set",		sfs_tpm_cfg_mc_data_handler_set},
+	{"mc_flow_default_set",		sfs_tpm_cfg_mc_flow_default_set},
+	{"mc_proto_handler_set",	sfs_tpm_cfg_mc_proto_handler_set},
+	{"mc_sw_handler_set",		sfs_tpm_cfg_mc_sw_handler_set},
+	{"uni_port_num_set",		sfs_tpm_cfg_uni_port_num_set},
+	{"ipv6_support_set",		sfs_tpm_cfg_ipv6_support_set},
+	{"cpu_trap_queue_set",		sfs_tpm_cfg_cpu_trap_queue_set},
+	{"ttl_illegal_action_set",	sfs_tpm_cfg_ttl_illegal_action_set},
+	{"bad_chksum_action_set",	sfs_tpm_cfg_bad_chksum_action_set},
+	{"mod_vlan_tpid_set",		sfs_tpm_cfg_mod_vlan_tpid_set},
+	{"tpid_combo_set",		sfs_tpm_cfg_tpid_combo_set},
+	{"tpid_combo_del",		sfs_tpm_cfg_tpid_combo_del},
+	{"tcp_flag_check_set",		sfs_tpm_cfg_tcp_flag_check_set},
+	{"trace_debug_flag_set",	sfs_tpm_cfg_trace_debug_flag_set},
+	{"qos_tbl_ext_set",		sfs_tpm_cfg_qos_tbl_ext_set},
+	{"cnm_support_set",		sfs_tpm_cfg_cnm_support_set},
+	{"module_start",		sfs_tpm_module_start},
+	{"mib_reset",			sfs_tpm_mib_reset},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help_init_cfg",		sys_help_tpm_init_cfg},
+	{"help_init_cap",		sys_help_tpm_init_cap},
+	{"help_init_filter",		sys_help_tpm_init_filter},
+	{"help_mib_reset",		sys_help_tpm_mib_reset},
+	{"capability_dump",		sfs_tpm_capability_dump},
+	{"filter_dump",			sfs_tpm_filter_dump},
+	{"init_cfg_dump",		sfs_tpm_init_cfg_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help_init_cfg,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_init_cap,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_init_filter,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mib_reset,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Store Attr */
+static DEVICE_ATTR(module_start,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mib_reset,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(switch_mode_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(gmac_def_mh_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(switch_init_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(capability_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(filter_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(capability_del,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_data_handler_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_flow_default_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_proto_handler_set,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_sw_handler_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(uni_port_num_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_support_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cpu_trap_queue_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ttl_illegal_action_set,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(bad_chksum_action_set,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mod_vlan_tpid_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tpid_combo_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tpid_combo_del,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(tcp_flag_check_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(trace_debug_flag_set,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(qos_tbl_ext_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(cnm_support_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+
+
+/* Show Attr */
+static DEVICE_ATTR(capability_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(filter_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(init_cfg_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_api_init_sw_attrs[] = {
+	&dev_attr_help_init_cfg.attr,
+	&dev_attr_help_init_cap.attr,
+	&dev_attr_help_init_filter.attr,
+	&dev_attr_help_mib_reset.attr,
+	&dev_attr_switch_mode_set.attr,
+	&dev_attr_gmac_def_mh_set.attr,
+	&dev_attr_switch_init_set.attr,
+	&dev_attr_capability_set.attr,
+	&dev_attr_filter_set.attr,
+	&dev_attr_capability_del.attr,
+	&dev_attr_mc_data_handler_set.attr,
+	&dev_attr_mc_flow_default_set.attr,
+	&dev_attr_mc_proto_handler_set.attr,
+	&dev_attr_mc_sw_handler_set.attr,
+	&dev_attr_uni_port_num_set.attr,
+	&dev_attr_ipv6_support_set.attr,
+	&dev_attr_cpu_trap_queue_set.attr,
+	&dev_attr_ttl_illegal_action_set.attr,
+	&dev_attr_bad_chksum_action_set.attr,
+	&dev_attr_mod_vlan_tpid_set.attr,
+	&dev_attr_tpid_combo_set.attr,
+	&dev_attr_tpid_combo_del.attr,
+	&dev_attr_tcp_flag_check_set.attr,
+	&dev_attr_trace_debug_flag_set.attr,
+	&dev_attr_qos_tbl_ext_set.attr,
+	&dev_attr_cnm_support_set.attr,
+	&dev_attr_module_start.attr,
+	&dev_attr_mib_reset.attr,
+	&dev_attr_capability_dump.attr,
+	&dev_attr_filter_dump.attr,
+	&dev_attr_init_cfg_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_init_sw_group = {
+	.name = "init_cfg",
+	.attrs = g_tpm_api_init_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_init_cfg_init
+*
+* DESCRIPTION: The routine will initialize TPM init sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_init_cfg_init(void)
+{
+	int rc;
+
+	/* Initialize init sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_init_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mc.c
new file mode 100644
index 0000000..92d453e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mc.c
@@ -0,0 +1,605 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_mc.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* sys_help_tpm_mc_debug_cmd
+*
+* DESCRIPTION:
+*           This function dump help of MCT debug sysfs commands
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static int sys_help_tpm_mc_debug_cmd(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [flow_id]  > dup_list_dump -  dump all entries in duplication list\n");
+	off += sprintf(buf+off, "\tflow_id        (dec)dup flow id, 0...255\n");
+
+	off += sprintf(buf+off, "cat free_entry_dump         -  dump all free MCT entry index.\n");
+	off += sprintf(buf+off, "cat flow_id_dump            -  dump valid flow id of dup list.\n");
+
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+/*******************************************************************************
+* tpm_sfs_mct_entry_header_dump
+*
+* DESCRIPTION: print header.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_mc_entry_header_dump(void)
+{
+	print_horizontal_line(54, "=");
+	printk(KERN_INFO "= HW_IDX |       Mod_Info             | Act_Info     =\n");
+	print_horizontal_line(54, "=");
+}
+
+/*******************************************************************************
+* tpm_sfs_valid_mc_entry_line_dump
+*
+* DESCRIPTION: Print one line of dump info.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_valid_mc_entry_line_dump(unsigned int hw_idx)
+{
+	int index;
+	struct tpm_mc_data_t mct_entry;
+	struct tpm_mc_index_t *mct_index_node;
+
+	/* Get the invalid index node */
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		mct_index_node = tpm_db_mc_index_node_get(index);
+		if (mct_index_node == NULL)
+			return;
+		if (mct_index_node->valid == TPM_MC_ENTRY_VALID &&
+		    mct_index_node->mct_hw_idx == hw_idx)
+			break;
+	}
+	if (index == MV_PP2_MC_TBL_SIZE)
+		return;
+
+	if (tpm_db_mc_data_get(mct_index_node->mct_data_db_idx, &mct_entry))
+		return;
+
+	/* Print idx */
+	printk(KERN_INFO "+  %3d   ", hw_idx);
+	/* Print mod pointer */
+	printk(KERN_INFO "| Dptr: %3d, Iptr: %5d     ",
+		mct_entry.mct_mod.pkt_mod.mod_data_idx, mct_entry.mct_mod.pkt_mod.mod_cmd_idx);
+	/* Print Queue */
+	printk(KERN_INFO "| Queue: 0x%2x  ", mct_entry.action.queue);
+
+	printk(KERN_INFO "+\n");
+
+	/* Print Gemport ID mod */
+	printk(KERN_INFO "+        ");
+	printk(KERN_INFO "| GEM_mod: %s, New_GEM: %3d ", tpm_utils_valid_str_get(mct_entry.mct_mod.gem_mod_en),
+					   mct_entry.mct_mod.gem);
+	/* Print frwd */
+	printk(KERN_INFO "| FRWD: %s ", tpm_utils_mc_frwd_str_get(mct_entry.action.frwd));
+
+	printk(KERN_INFO "+\n");
+
+	/* Print Pri mod */
+	printk(KERN_INFO "+        ");
+	printk(KERN_INFO "| PRI_mod: %s, New_PRI: %d   ", tpm_utils_valid_str_get(mct_entry.mct_mod.pri_mod_en),
+					   mct_entry.mct_mod.pri);
+
+	/* Print Next Index */
+	printk(KERN_INFO "| Next: %3d    ", mct_entry.action.next_mcti);
+
+	printk(KERN_INFO "+\n");
+
+	/* Print DSCP mod */
+	printk(KERN_INFO "+        ");
+	printk(KERN_INFO "| DSCP_mod: %s, New_DSCP: %2d", tpm_utils_valid_str_get(mct_entry.mct_mod.dscp_mod_en),
+					      mct_entry.mct_mod.dscp);
+	printk(KERN_INFO "|              +\n");
+
+	print_horizontal_line(54, "-");
+}
+
+/*******************************************************************************
+* tpm_sfs_mc_dup_list_dump
+*
+* DESCRIPTION: Print the duplication list.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+void tpm_sfs_mc_dup_list_dump(unsigned int flow_id)
+{
+	struct list_head *dup_list_head;
+	struct tpm_mc_index_t *mct_index_node;
+	tpm_sfs_mc_entry_header_dump();
+
+	/* Get list head */
+	dup_list_head = tpm_db_mc_dup_list_head_get(flow_id);
+	if (dup_list_head == NULL) {
+		printk(KERN_INFO "Dup list head get fail\n");
+		return;
+	}
+	if (list_empty(dup_list_head)) {
+		printk(KERN_INFO "Dup list empty\n");
+		return;
+	}
+	list_for_each_entry(mct_index_node, dup_list_head, list_node) {
+		tpm_sfs_valid_mc_entry_line_dump(mct_index_node->mct_hw_idx);
+	}
+}
+
+/*******************************************************************************
+* tpm_print_free_mct_entry_dump_head
+*
+* DESCRIPTION: print header for free entry.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_free_mc_entry_dump_head(void)
+{
+	print_horizontal_line(67, "=");
+	printk(KERN_INFO "=    TOTAL    |                FREE_ENTRY_IDX                     =\n");
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_print_mct_flowid_dump_head
+*
+* DESCRIPTION: print header for flow ID.
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_mc_flowid_dump_head(void)
+{
+	print_horizontal_line(67, "=");
+	printk(KERN_INFO "=    TOTAL    |                FLOW_ID_ARRAY                      =\n");
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_print_mc_index_dump_line
+*
+* DESCRIPTION: print one line with MCT index information.
+* INPUTS:
+*           common_int - tcam count or lkp_type
+*           entry_idx  - TCAM index array
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_print_mc_index_dump_line(unsigned int common_int,
+						unsigned char *entry_idx)
+{
+	char common_str[4] = "";
+	char mct_idx_str[40] = "";
+	int i, j, entry_cnt, ten_cnt;
+	int line_int_num = 10;
+	bool first_line = true;
+
+	/* Para Check */
+	if (entry_idx == NULL)
+		return;
+
+	sprintf(common_str, "%03d", common_int);
+
+	entry_cnt = common_int;
+	if (entry_cnt % line_int_num)
+		ten_cnt = entry_cnt / line_int_num + 1;
+	else
+		ten_cnt = entry_cnt / line_int_num;
+	/* Handle TCAM count zero */
+	if (entry_cnt == 0)
+		ten_cnt = 1;
+	for (i = 0; i < ten_cnt; i++) {
+		sprintf(mct_idx_str, "%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d,%3d", entry_idx[i*line_int_num],
+			entry_idx[i*line_int_num + 1], entry_idx[i*line_int_num + 2], entry_idx[i*line_int_num + 3],
+			entry_idx[i*line_int_num + 4], entry_idx[i*line_int_num + 5], entry_idx[i*line_int_num + 6],
+			entry_idx[i*line_int_num + 7], entry_idx[i*line_int_num + 8], entry_idx[i*line_int_num + 9]);
+		if ((entry_cnt % line_int_num) && (i == entry_cnt / line_int_num)) {
+			for (j = ((entry_cnt % line_int_num) * 4); j < 40; j++)
+				mct_idx_str[j] = 0;
+			if (first_line) {
+				first_line = false;
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, mct_idx_str);
+			} else {
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", "", mct_idx_str);
+			}
+		} else {
+			if (first_line) {
+				first_line = false;
+				if (entry_cnt)
+					printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, mct_idx_str);
+				else
+					printk(KERN_INFO "+    %4s     |     %40s      +\n", common_str, "NA");
+			} else {
+				printk(KERN_INFO "+    %4s     |     %40s      +\n", "", mct_idx_str);
+			}
+		}
+	}
+
+}
+
+/*******************************************************************************
+* tpm_mc_dump_valid_flow_id
+*
+* DESCRIPTION: The routine will dump all the valid MCT list flow ID
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           For debug.
+*******************************************************************************/
+static void tpm_mc_dump_valid_flow_id(void)
+{
+	unsigned int i, count = 0;
+	unsigned char mct_array[MV_PP2_MC_TBL_SIZE];
+
+	tpm_print_mc_flowid_dump_head();
+	/* Traverse free list */
+	TPM_MEMSET_FF(mct_array);
+	for (i = 0; i < MV_PP2_MC_TBL_SIZE; i++) {
+		if (!list_empty(tpm_db_mc_dup_list_head_get(i)))
+			mct_array[count++] = i;
+	}
+	/* Print Free entry info */
+	tpm_print_mc_index_dump_line(count, mct_array);
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* tpm_mc_dump_freelist
+*
+* DESCRIPTION: The routine will dump all the free MCT entry number from MCT
+*              sub-module internal DB
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* COMMENTS:
+*           For debug.
+*******************************************************************************/
+static void tpm_mc_dump_freelist(void)
+{
+	struct tpm_mc_index_t *mct_index_node;
+	unsigned int count = 0;
+	unsigned char mct_array[MV_PP2_MC_TBL_SIZE];
+
+	tpm_print_free_mc_entry_dump_head();
+	/* Traverse free list */
+	TPM_MEMSET_FF(mct_array);
+	list_for_each_entry(mct_index_node, tpm_db_mc_free_list_head_get(), list_node)
+		mct_array[count++] = mct_index_node->mct_hw_idx;
+	/* Print Free entry info */
+	tpm_print_mc_index_dump_line(count, mct_array);
+	print_horizontal_line(67, "=");
+}
+
+/*******************************************************************************
+* sfs_tpm_mc_dup_list_dump
+*
+* DESCRIPTION:
+*           This function dump dup list info
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static void sfs_tpm_mc_dup_list_dump(const char *buf, size_t len)
+{
+	enum dup_list_dump_parm_indx_t {
+		dup_flow_id = 0,
+		dup_list_dump_max
+	};
+
+	unsigned int flow_id;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != dup_list_dump_max)
+		parm_error_completion(numparms, dup_list_dump_max, buf, sys_help_tpm_mc_debug_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &flow_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else
+			tpm_sfs_mc_dup_list_dump(flow_id);
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_mc_free_entry_dump
+*
+* DESCRIPTION:
+*           This function dump free MCT entry
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_mc_free_entry_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_mc_dump_freelist();
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_mc_valid_flow_id_dump
+*
+* DESCRIPTION:
+*           This function dump valid flow ID.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_mc_valid_flow_id_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_mc_dump_valid_flow_id();
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_mc_dup_list_del
+*
+* DESCRIPTION:
+*           This function del dup list
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static void sfs_tpm_mc_dup_list_del(const char *buf, size_t len)
+{
+	enum dup_list_dump_parm_indx_t {
+		dup_flow_id = 0,
+		dup_list_dump_max
+	};
+
+	unsigned int flow_id;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != dup_list_dump_max)
+		parm_error_completion(numparms, dup_list_dump_max, buf, sys_help_tpm_mc_debug_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &flow_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			tpm_mc_dup_list_release(flow_id);
+			printk(KERN_INFO "OK.\n");
+		}
+	}
+
+	return;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"dup_list_dump",		sfs_tpm_mc_dup_list_dump},
+	{"dup_list_del",		sfs_tpm_mc_dup_list_del},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",			sys_help_tpm_mc_debug_cmd},
+	{"free_entry_dump",		sfs_tpm_mc_free_entry_dump},
+	{"flow_id_dump",		sfs_tpm_mc_valid_flow_id_dump},
+
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Store Attr */
+static DEVICE_ATTR(dup_list_dump,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Show Attr */
+static DEVICE_ATTR(free_entry_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(flow_id_dump,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_mc_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_dup_list_dump.attr,
+	&dev_attr_free_entry_dump.attr,
+	&dev_attr_flow_id_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_mc_sw_group = {
+	.name = "mc",
+	.attrs = g_tpm_mc_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_mc_init
+*
+* DESCRIPTION: The routine will initialize TPM mc sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_mc_init(void)
+{
+	int rc;
+
+	/* Initialize MC table sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_mc_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mng.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mng.c
new file mode 100644
index 0000000..39c139b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_mng.c
@@ -0,0 +1,1291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_mng.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_cap_dump_all
+*
+* DESCRIPTION:
+*           This function dump all valid c2 entries
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_cap_dump_all(char *buf)
+{
+	int off = 0;
+	struct tpm_db_mng_flow_cap_conf_t cap_arr[TPM_MNG_CAP_PER_FLOW_MAX];
+	enum tpm_mng_flow_log_id_t flow_id;
+	int  ipv6_enable;
+	int tpm_ret;
+	int i;
+	int init_state;
+	int cap_num;
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return TPM_OK;
+	}
+
+	tpm_ret = tpm_db_generic_param_get(TPM_DB_PARAM_IPV6_SUPPORT, &ipv6_enable);
+	IF_ERROR_STR(TPM_INIT_MOD, tpm_ret, "get ipv6 enable failed\n");
+
+
+	printk(KERN_INFO "ID flow_name                    cls_pri engine lu_type cap_type          C2_pri field_bm   C2_field_bm  vlan_num   rule_type\n");
+	/* for all the flow, print cap */
+	for (flow_id = 0; flow_id < TPM_MNG_FLOW_ID_MAX; flow_id++) {
+		if ((flow_id >= TPM_MNG_FLOW_ID_IPV6_START)
+		     && (ipv6_enable != TPM_IPV6_SUPPORTED))
+			continue;
+
+		TPM_MEMSET_ZERO(cap_arr);
+		tpm_ret = tpm_db_mng_cap_in_flow_get(flow_id, cap_arr, &cap_num);
+		IF_ERROR_STR(TPM_INIT_MOD, tpm_ret, "get CAPs failed for flow_id(%d)\n", flow_id);
+
+
+		printk(KERN_INFO "%-2d %-28s ", flow_id, tpm_utils_flow_id_str_get(flow_id));
+		for (i = 0; i < cap_num; i++) {
+			if (i != 0)
+				printk(KERN_INFO "\t\t\t\t");
+
+			TPM_MNG_FLOW_CAP_PRINT(&(cap_arr[i]));
+		}
+		printk(KERN_INFO "\n");
+	}
+	return off;
+}
+
+/*******************************************************************************
+* tpm_sfs_mng_help
+*
+* DESCRIPTION:
+*           This function dump help of mng debug cmd
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_mng_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [api_type]  > api_type_data_dump -  dump all rules of api_type\n");
+	off += sprintf(buf+off, "\tapi_type	   (dec)api_type of all the rules need to dump\n");
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PUBLIC_CLS)        , TPM_API_PUBLIC_CLS);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PUBLIC_EXCT_EXCPT) , TPM_API_PUBLIC_EXCT_EXCPT);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_CNM)        , TPM_API_PRIVATE_CNM);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PUBLIC_FLTR)       , TPM_API_PUBLIC_FLTR);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_CLS)       , TPM_API_PRIVATE_CLS);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_EXCT)      , TPM_API_PRIVATE_EXCT);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_EXCT_DEFAULT), TPM_API_PRIVATE_EXCT_DEFAULT);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_MC_US)     , TPM_API_PRIVATE_MC_US);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_MC_DS)    , TPM_API_PRIVATE_MC_DS);
+	off += sprintf(buf+off, "\t\t%-20s: %d.\n", tpm_utils_cap_type_str_get(TPM_API_PRIVATE_CPU_Q)    , TPM_API_PRIVATE_CPU_Q);
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "cat cap_conf_dump_all	       -  dump all capabilities within each Flow\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "cat virt_pid_dump_all	       -  dump all virt_id gemport information.\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "cat api_data_dump_all	       -  dump all api rules.\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "cat cap_dump_all	       -  dump all capabilities that have been configured\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [delay_sec] [hit_low_thresh] [hw_dump]  > api_live_dump -  dump api rules with HW hits\n");
+	off += sprintf(buf+off, "\tdelay_sec	   (dec)number of seconds to wait for HW hits\n");
+	off += sprintf(buf+off, "\thit_low_thresh  (dec)minimal hit counter that will be printed, zero value will print all rules\n");
+	off += sprintf(buf+off, "\thw_dump         (dec)0: don't dump HW, 1:dump HW\n");
+	off += sprintf(buf+off, "\n");
+
+	off += sprintf(buf+off, "echo [trace_level]  > trace_level_set -  set TPM trace level\n");
+	off += sprintf(buf+off, "\ttrace_level	   (hex)contains module mask in bit 0-15, trace level in bit 16-31\n");
+
+	off += sprintf(buf+off, "\t\t TPM_FATAL_TRACE_LEVEL   : 0x%08x.\n", TPM_FATAL_TRACE_LEVEL);
+	off += sprintf(buf+off, "\t\t TPM_ERROR_TRACE_LEVEL   : 0x%08x.\n", TPM_ERROR_TRACE_LEVEL);
+	off += sprintf(buf+off, "\t\t TPM_WARN_TRACE_LEVEL    : 0x%08x.\n", TPM_WARN_TRACE_LEVEL);
+	off += sprintf(buf+off, "\t\t TPM_INFO_TRACE_LEVEL    : 0x%08x.\n", TPM_INFO_TRACE_LEVEL);
+	off += sprintf(buf+off, "\t\t TPM_DEBUG_TRACE_LEVEL   : 0x%08x.\n", TPM_DEBUG_TRACE_LEVEL);
+	off += sprintf(buf+off, "\t\t TPM_ALL_TRACE_LEVEL     : 0x%08x.\n\n", TPM_ALL_TRACE_LEVEL);
+
+	off += sprintf(buf+off, "\t\t TPM_PRS_MOD	   : 0x%08x.\n", TPM_PRS_MOD);
+	off += sprintf(buf+off, "\t\t TPM_CLS_MOD	   : 0x%08x.\n", TPM_CLS_MOD);
+	off += sprintf(buf+off, "\t\t TPM_C2_MOD	   : 0x%08x.\n", TPM_C2_MOD);
+	off += sprintf(buf+off, "\t\t TPM_C3_MOD	   : 0x%08x.\n", TPM_C3_MOD);
+	off += sprintf(buf+off, "\t\t TPM_C4_MOD	   : 0x%08x.\n", TPM_C4_MOD);
+	off += sprintf(buf+off, "\t\t TPM_PME_MOD	   : 0x%08x.\n", TPM_PME_MOD);
+	off += sprintf(buf+off, "\t\t TPM_QOS_MOD	   : 0x%08x.\n", TPM_QOS_MOD);
+	off += sprintf(buf+off, "\t\t TPM_SWITCH_MOD	   : 0x%08x.\n", TPM_SWITCH_MOD);
+	off += sprintf(buf+off, "\t\t TPM_API_MOD	   : 0x%08x.\n", TPM_API_MOD);
+	off += sprintf(buf+off, "\t\t TPM_INIT_MOD	   : 0x%08x.\n", TPM_INIT_MOD);
+	off += sprintf(buf+off, "\t\t TPM_MNG_MOD	   : 0x%08x.\n", TPM_MNG_MOD);
+	off += sprintf(buf+off, "\t\t TPM_DB_MOD	   : 0x%08x.\n", TPM_DB_MOD);
+	off += sprintf(buf+off, "\t\t TPM_SYSFS_MOD	   : 0x%08x.\n", TPM_SYSFS_MOD);
+	off += sprintf(buf+off, "\t\t TPM_COMMON_MOD	   : 0x%08x.\n", TPM_COMMON_MOD);
+	off += sprintf(buf+off, "\t\t TPM_IOCTL_MOD	   : 0x%08x.\n", TPM_IOCTL_MOD);
+	off += sprintf(buf+off, "\t\t TPM_ALL_MOD	   : 0x%08x.\n", TPM_ALL_MOD);
+
+	return off;
+}
+
+/*******************************************************************************
+* tpm_sfs_api_data_entry_print
+*
+* DESCRIPTION:
+*           This function prints a api data entry information
+* INPUTS:
+*       api_data     - api data structure
+*******************************************************************************/
+static void tpm_sfs_api_data_entry_print(struct tpm_db_mng_api_data_t	*api_data)
+{
+	int	i;
+	int	ip_version = 0;
+
+	printk(KERN_INFO "%-5s %-5d %-5d %-6s %6d ",
+		tpm_utils_valid_str_get(api_data->valid),
+		api_data->api_rule_id,
+		api_data->policer_id,
+		tpm_utils_qos_type_str_get(api_data->qos.qos_sel),
+		api_data->qos.qos_tbl);
+
+	printk(KERN_INFO "c2: ");
+	for (i = 0; i < TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX; i++)
+		printk(KERN_INFO "%-5d ", api_data->c2_rule_id[i]);
+
+	printk(KERN_INFO "c3: ");
+	for (i = 0; i < TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX; i++)
+		printk(KERN_INFO "%-5d ", api_data->c3_rule_id[i]);
+
+	for (i = 0; i < api_data->num_dest; i++) {
+		printk(KERN_INFO "Modification[%d]:\n", i);
+		printk(KERN_INFO "mod_cmd: ");
+		printk(KERN_INFO "%-5d ", api_data->pkt_mod[i].mod_cmd_idx);
+		printk(KERN_INFO "mod_data: ");
+		printk(KERN_INFO "%-5d ", api_data->pkt_mod[i].mod_data_idx);
+		printk(KERN_INFO "mod_l4_cksum: ");
+		printk(KERN_INFO "%-5d ", api_data->pkt_mod[i].l4_chksum_update_flag);
+	}
+
+	printk(KERN_INFO "\n\t");
+
+	for (i = 0; i < TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX; i++)
+		printk(KERN_INFO "%-5d ", api_data->flow_rule_id[i]);
+
+	printk(KERN_INFO "\n\t");
+
+	printk(KERN_INFO "%pM %pM ", api_data->match_key.eth_src.eth_add,
+		api_data->match_key.eth_dst.eth_add);
+	printk(KERN_INFO "0x%08X 0x%04X %6d %06d",
+		api_data->match_key.field_match_bm,
+		api_data->match_key.ether_type,
+		api_data->match_key.inn_pbit,
+		api_data->match_key.inn_vid);
+
+
+	printk(KERN_INFO "\n\t");
+
+	printk(KERN_INFO "%pM %pM ", api_data->match_key.eth_src.eth_add_mask,
+		api_data->match_key.eth_dst.eth_add_mask);
+
+	printk(KERN_INFO "%10d %-7s       %6d %06d",
+		api_data->match_key.port.class_port,
+		tpm_utils_port_class_str_get(api_data->match_key.port.port_type),
+		api_data->match_key.out_pbit,
+		api_data->match_key.out_vid);
+
+
+	printk(KERN_INFO "\n\t");
+
+	if (api_data->match_key.field_match_bm & TPM_MATCH_IPV4_PKT)
+		ip_version = IPV4_VER;
+	else if (api_data->match_key.field_match_bm & (TPM_MATCH_IPV6_PKT | TPM_MATCH_IPV6_PREF | TPM_MATCH_IPV6_PREF))
+		ip_version = IPV6_VER;
+	else
+		ip_version = 0;
+
+	if (ip_version == IPV4_VER) {
+		printk(KERN_INFO "IPv4:%pi4 %pi4", api_data->match_key.ipvx_add.ip_src.ip_add.ipv4,
+			api_data->match_key.ipvx_add.ip_dst.ip_add.ipv4);
+	} else if (ip_version == IPV6_VER) {
+		printk(KERN_INFO "IPv6:%pI6 %pI6", api_data->match_key.ipvx_add.ip_src.ip_add.ipv6,
+			api_data->match_key.ipvx_add.ip_dst.ip_add.ipv6);
+	} else
+		printk(KERN_INFO "NA \t\t\t NA");
+
+	printk(KERN_INFO "\n\t");
+
+	if (ip_version == IPV4_VER) {
+		printk(KERN_INFO "IPv4:%pi4 %pi4 ", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv4,
+			api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv4);
+	} else if (ip_version == IPV6_VER) {
+		printk(KERN_INFO "IPv6:%pI6 %pI6 ", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv6,
+			api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv6);
+	} else
+		printk(KERN_INFO "NA \t\t\t NA");
+
+	printk(KERN_INFO "\n\t");
+	printk(KERN_INFO "%06d %06d %8d  0x%08X %05d",
+		api_data->match_key.ipvx_add.ip_proto,
+		ip_version,
+		api_data->match_key.ipvx_add.dscp,
+		api_data->match_key.ipvx_add.flow_label,
+		api_data->match_key.l4_src);
+
+	printk(KERN_INFO "\n\t");
+	printk(KERN_INFO "%06d %06d %8d  0x%08X %05d",
+		api_data->match_key.ppp_info.ppp_proto,
+		api_data->match_key.ppp_info.ppp_session,
+		api_data->match_key.ipvx_add.dscp_mask,
+		api_data->match_key.ipvx_add.flow_label_mask,
+		api_data->match_key.l4_dst);
+
+	printk(KERN_INFO "\n\t");
+	for (i = 0; i < api_data->num_dest; i++) {
+		printk(KERN_INFO "Action[%d]:\n", i);
+		printk(KERN_INFO "%-5s %5d %06d %-5s %3d\n",
+			tpm_utils_color_str_get((int)api_data->action[i].color),
+			api_data->action[i].dest.pon_tx,
+			api_data->action[i].dest.port_id,
+			tpm_utils_pp_port_str_get((int)api_data->action[i].dest.pp_port),
+			api_data->action[i].dest.pp_queue/*,
+			api_data->action[i].mod.*/);
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_api_info_print
+*
+* DESCRIPTION:
+*           This function prints a api data entry information
+* INPUTS:
+*       api_data     - api data structure
+*******************************************************************************/
+static void tpm_sfs_api_info_print(struct tpm_db_mng_api_data_t	*api_data)
+{
+	int	ip_version = 0;
+	int	i;
+
+	printk(KERN_INFO "API_INFO: rule_id[%d] valid[%s] plcr_id[%d] qos([%s] tbl[%d])",
+		api_data->api_rule_id,
+		tpm_utils_valid_str_get(api_data->valid),
+		api_data->policer_id,
+		tpm_utils_qos_type_str_get(api_data->qos.qos_sel),
+		api_data->qos.qos_tbl);
+
+	printk(KERN_INFO "\n\tsmac_value:%pM", api_data->match_key.eth_src.eth_add);
+	printk(KERN_INFO " dmac_value:%pM", api_data->match_key.eth_dst.eth_add);
+
+	printk(KERN_INFO "\n\tsmac_mask: %pM", api_data->match_key.eth_src.eth_add_mask);
+	printk(KERN_INFO " dmac_mask :%pM", api_data->match_key.eth_dst.eth_add_mask);
+
+	printk(KERN_INFO "\n\tfield_match_bm:0x%X ether_type:0x%X in(pbit:%d vid:%d)",
+		api_data->match_key.field_match_bm,
+		api_data->match_key.ether_type,
+		api_data->match_key.inn_pbit,
+		api_data->match_key.inn_vid);
+
+	printk(KERN_INFO "\n\tclass(port:%d type:%s) out(pbit:%d vid:%d)",
+		api_data->match_key.port.class_port,
+		tpm_utils_port_class_str_get(api_data->match_key.port.port_type),
+		api_data->match_key.out_pbit,
+		api_data->match_key.out_vid);
+
+	if (api_data->match_key.field_match_bm & TPM_MATCH_IPV4_PKT)
+		ip_version = IPV4_VER;
+	else if (api_data->match_key.field_match_bm & TPM_MATCH_IPV6_PKT)
+		ip_version = IPV6_VER;
+	else
+		ip_version = 0;
+
+	if (ip_version == IPV4_VER) {
+		printk(KERN_INFO "\n\tsipv4_value:%pi4 %pi4", api_data->match_key.ipvx_add.ip_src.ip_add.ipv4,
+			api_data->match_key.ipvx_add.ip_dst.ip_add.ipv4);
+	} else if (ip_version == IPV6_VER) {
+		printk(KERN_INFO "\n\tsipv6_value:%pI6 %pI6", api_data->match_key.ipvx_add.ip_src.ip_add.ipv6,
+			api_data->match_key.ipvx_add.ip_dst.ip_add.ipv6);
+	}
+
+	if (ip_version == IPV4_VER) {
+		printk(KERN_INFO "\n\tsipv4_mask :%pi4 %pi4", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv4,
+			api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv4);
+	} else if (ip_version == IPV6_VER) {
+		printk(KERN_INFO "\n\tsipv6_mask :%pI6 %pI6", api_data->match_key.ipvx_add.ip_src.ip_add_mask.ipv6,
+			api_data->match_key.ipvx_add.ip_dst.ip_add_mask.ipv6);
+	}
+
+	printk(KERN_INFO "\n\tip_prot:%d ip_ver:%d dscp:0x%x/0x%x l4_port(src:%d dst:%d)",
+		api_data->match_key.ipvx_add.ip_proto,
+		ip_version,
+		api_data->match_key.ipvx_add.dscp,
+		api_data->match_key.ipvx_add.dscp_mask,
+		api_data->match_key.l4_dst,
+		api_data->match_key.l4_src);
+
+	printk(KERN_INFO "\n\tppp(prot:%d ses%d) flow_lbl:0x%x/0x%x",
+		api_data->match_key.ppp_info.ppp_proto,
+		api_data->match_key.ppp_info.ppp_session,
+		api_data->match_key.ipvx_add.flow_label,
+		api_data->match_key.ipvx_add.flow_label_mask);
+
+	for (i = 0; i < api_data->num_dest; i++) {
+		printk(KERN_INFO "Action[%d]:\n", i);
+		printk(KERN_INFO "\n\tcol:%s pon_tx:%d port_id:%d port_port:%s pp_q:%d",
+			tpm_utils_color_str_get((int)api_data->action[i].color),
+			api_data->action[i].dest.pon_tx,
+			api_data->action[i].dest.port_id,
+			tpm_utils_pp_port_str_get((int)api_data->action[i].dest.pp_port),
+			api_data->action[i].dest.pp_queue/*,
+			api_data->action[i].mod.*/);
+	}
+}
+
+/*******************************************************************************
+* tpm_sfs_api_data_header_dump
+*
+* DESCRIPTION:
+*           This function dump the api data dump description
+* INPUTS:
+*       None
+*******************************************************************************/
+static void tpm_sfs_api_data_header_dump(void)
+{
+	printk(KERN_INFO "index  api_type\n");
+	printk(KERN_INFO "Valid apiId plcId qosType qosTbl c2_c3_mod_IDs\n");
+	printk(KERN_INFO "flow_rule_IDs\n");
+	printk(KERN_INFO "Key     src_mac           dst_mac           fld_mch_bm ethTyp in_pb  in_vid\n");
+	printk(KERN_INFO "\tsrc_mac_mask      dst_mac_mask      class_port  portTyp      out_pb out_vid\n");
+	printk(KERN_INFO "\tsrc_ip                  dst_ip\n");
+	printk(KERN_INFO "\tsrc_ip_mask             dst_ip_mask\n");
+	printk(KERN_INFO "\tipProt ver     dscp     flLbl    l4_src\n");
+	printk(KERN_INFO "\tpppProt pppSes dscpMask flLblMsk l4_dst\n");
+	printk(KERN_INFO "Action  Color ponTx portId ppPort ppQ\n");
+}
+
+/*******************************************************************************
+* tpm_sfs_api_type_data_dump_in
+*
+* DESCRIPTION:
+*           This function dump a single api type api data entries
+* INPUTS:
+*       flow_log_id     - loogical flow ID
+*******************************************************************************/
+static int tpm_sfs_api_type_data_dump_in(int cap_api_type)
+{
+	int				off = 0;
+	int				rc;
+	int				init_state;
+	struct tpm_db_mng_api_data_t	*api_data = NULL;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_MNG_MOD, cap_api_type, TPM_API_TYPE_MAX, "Invalid API type");
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return TPM_OK;
+	}
+
+	/* allocate api data */
+	rc = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "allocate api_data structure mem failed!\n");
+
+	rc = tpm_db_mng_api_entry_type_first_get(cap_api_type, api_data);
+	if (TPM_OK != rc) {
+		printk(KERN_INFO "OK. No API rule so far\n");
+		/* release api data */
+		tpm_db_mng_api_data_release(api_data);
+		return off;
+	}
+
+	tpm_sfs_api_data_header_dump();
+
+	printk(KERN_INFO "%-4d %s\n", cap_api_type, tpm_utils_cap_type_str_get(api_data->cap_api_type));
+
+	tpm_sfs_api_data_entry_print(api_data);
+
+	while (tpm_db_mng_api_entry_type_next_get(api_data) == TPM_OK)
+		tpm_sfs_api_data_entry_print(api_data);
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return off;
+}
+
+
+/*******************************************************************************
+* tpm_sfs_flow_cfg_dump_all
+*
+* DESCRIPTION:
+*           This function dump all valid api data entries
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_api_data_dump_all(char *buf)
+{
+	int				off = 0;
+	int				rc;
+	int				i;
+	int				init_state;
+	struct tpm_db_mng_api_data_t	*api_data = NULL;
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return TPM_OK;
+	}
+
+	tpm_sfs_api_data_header_dump();
+
+	/* allocate api data */
+	rc = tpm_db_mng_api_data_allocate(&api_data);
+	IF_ERROR_STR(TPM_MNG_MOD, rc, "allocate api_data structure mem failed!\n");
+
+	/* iterate over all API types */
+	for (i = TPM_API_PUBLIC_CLS; i <= TPM_API_PRIVATE_CPU_Q; i++) {
+		rc = tpm_db_mng_api_entry_type_first_get(i, api_data);
+		if (TPM_OK != rc)
+			continue;
+
+		printk(KERN_INFO "%-4d %s\n", i, tpm_utils_cap_type_str_get(api_data->cap_api_type));
+
+		tpm_sfs_api_data_entry_print(api_data);
+
+		while (tpm_db_mng_api_entry_type_next_get(api_data) == TPM_OK)
+			tpm_sfs_api_data_entry_print(api_data);
+
+		printk(KERN_INFO "\n");
+	}
+
+	/* release api data */
+	tpm_db_mng_api_data_release(api_data);
+	return off;
+}
+
+/*******************************************************************************
+* tpm_sfs_api_data_print
+*
+* DESCRIPTION:
+*           This function dump all valid api data entries
+* INPUTS:
+*	print_api_type - print API type flag
+*	print_api_info - print API info flag
+*	api_data - the API info structure to print
+* OUTPUTS:
+*	print_api_type - updated print API type flag
+*	print_api_info - updated print API info flag
+*******************************************************************************/
+static void tpm_sfs_api_data_print(bool				*print_api_type,
+				bool				*print_api_info,
+				struct tpm_db_mng_api_data_t	*api_data)
+{
+	IF_NULL_NO_RET(TPM_SYSFS_MOD, print_api_type);
+	IF_NULL_NO_RET(TPM_SYSFS_MOD, print_api_info);
+	IF_NULL_NO_RET(TPM_SYSFS_MOD, api_data);
+
+	if (*print_api_type == false) {
+		print_horizontal_line(80, "=");
+		printk(KERN_INFO "API type:%s\n", tpm_utils_cap_type_str_get(api_data->cap_api_type));
+		print_horizontal_line(80, "=");
+		*print_api_type = true;
+	}
+
+	if (*print_api_info == false) {
+		print_horizontal_line(60, "=");
+		tpm_sfs_api_info_print(api_data);
+		printk(KERN_INFO "\n");
+		*print_api_info = true;
+	}
+}
+
+#ifdef TPM_AUTO_TEST
+/*******************************************************************************
+* tpm_sfs_mng_auto_test
+*
+* DESCRIPTION:
+*           This function perform the MNG module auto test
+* INPUTS:
+*
+* OUTPUTS:
+*
+*******************************************************************************/
+void tpm_sfs_mng_auto_test(const char *buf, size_t len)
+{
+	tpm_mng_cap_merge_auto_test();
+	tpm_mng_cnm_auto_test();
+}
+#endif
+/*******************************************************************************
+* tpm_sfs_api_data_live_dump_c3
+*
+* DESCRIPTION:
+*	This function dump all valid api data entries related to HW hits bigger then threshold
+*	accumulated for user input timeout in seconds
+* INPUTS:
+*
+*
+*******************************************************************************/
+void tpm_sfs_api_data_live_dump_c3(
+	struct tpm_db_mng_api_data_t	*api_data,
+	bool				hw_dump,
+	unsigned short			cls_i,
+	struct tpm_db_cls_fl_rule_t	*flow,
+	unsigned int			c3_cntr_num,
+	struct tpm_hit_cnt_t		c3_cntr_info[])
+
+{
+	bool				found = false;
+	unsigned int			c3_i, c3_hw_i, d;
+	MV_PP2_CLS_C3_ENTRY		c3;
+	struct tpm_c3_data_t		c3_data;
+	int				rc;
+	bool				print_api_info;
+	bool				print_api_type;
+	unsigned int			cnt_i;
+
+	/* search this API C3 rules */
+	for (c3_i = 0; (!found) && (c3_i < TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX); c3_i++) {
+		/* skip invalid entries */
+		if (api_data->c3_rule_id[c3_i] == TPM_DB_MNG_RULE_ID_INVALID)
+			continue;
+
+		/* get C3 offset from logical ID */
+		rc = tpm_db_c3_hash_idx_get(api_data->c3_rule_id[c3_i], &c3_hw_i);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO
+				"tpm_db_c3_hash_idx_get err c3_rule_id[%d]=%d\n",
+				c3_i, api_data->c3_rule_id[c3_i]);
+			return;
+		}
+
+		rc = mvPp2ClsC3HwRead(&c3, c3_hw_i);
+		if (MV_OK != rc) {
+			printk(KERN_INFO "failed to read C3 entry from HW index %d\n", c3_hw_i);
+			return;
+		}
+
+		TPM_MEMSET_ZERO(c3_data);
+		tpm_sfs_c3_entry_convert(&c3, &c3_data);
+
+		/* looking for CLS lookup type */
+		if (c3_data.lkp_type != flow->lu_type)
+			continue;
+
+		/* found the same LU type, seach for hit count */
+		for (cnt_i = 0; (!found) && (cnt_i < c3_cntr_num); cnt_i++) {
+			if (c3_hw_i != c3_cntr_info[cnt_i].phys_idx)
+				continue;
+
+			tpm_sfs_api_data_print(&print_api_type,
+					       &print_api_info,
+						api_data);
+
+			tpm_sfs_cls_rl_print(cls_i, flow, hw_dump);
+
+			print_horizontal_line(40, "=");
+			printk(KERN_INFO "C3_INFO:\n");
+
+			tpm_sfs_c3_entry_header_dump();
+
+			for (d = 0; d <= TPM_QOS_DUMP_POLICER; d++)
+				tpm_sfs_c3_entry_line_dump(d,
+					c3_cntr_info[cnt_i].phys_idx,
+					c3_cntr_info[cnt_i].log_idx,
+					c3_cntr_info[cnt_i].cntr_val,
+					&c3_data);
+
+			print_horizontal_line(154, "=");
+
+			if (hw_dump)
+				mvPp2ClsC3SwDump(&c3);
+
+			tpm_sfs_pme_cmd_trace_dump(c3_data.pkt_mod.mod_cmd_idx,
+					c3_data.pkt_mod.mod_data_idx);
+
+			api_data->c3_rule_id[c3_i] = TPM_DB_MNG_RULE_ID_INVALID;
+			found = true;
+		}
+	}
+	return;
+}
+/*******************************************************************************
+* tpm_sfs_api_data_live_dump_c2
+*
+* DESCRIPTION:
+*	This function dump all valid api data entries related to HW hits bigger then threshold
+*	accumulated for user input timeout in seconds
+* INPUTS:
+*
+*
+*******************************************************************************/
+void tpm_sfs_api_data_live_dump_c2(
+	struct tpm_db_mng_api_data_t	*api_data,
+	bool				hw_dump,
+	unsigned short			cls_i,
+	struct tpm_db_cls_fl_rule_t	*flow,
+	unsigned int			c2_cntr_num,
+	struct tpm_hit_cnt_t		c2_cntr_info[])
+{
+	bool				found = false;
+	unsigned int			c2_i, c2_hw_i, c2_db_i, d;
+	static struct tpm_c2_data_t	c2_data;
+	struct tpm_c2_index_t		*c2_index_node;
+	int				rc;
+	bool				print_api_info;
+	bool				print_api_type;
+	unsigned int			cnt_i;
+
+	/* search this API C2 rules */
+	for (c2_i = 0; (!found) && (c2_i < TPM_DB_MNG_API_RULE_ENG_ENTRY_MAX); c2_i++) {
+		/* skip invalid entries */
+		if (api_data->c2_rule_id[c2_i] == TPM_DB_MNG_RULE_ID_INVALID)
+			continue;
+
+		/* get C2 offset from logical ID */
+		rc = tpm_c2_get_hw_idx_from_logic_idx(api_data->c2_rule_id[c2_i],
+							&c2_hw_i, &c2_db_i);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "tpm_c2_get_hw_idx_from_logic_idx err c2_rule_id[%d]=%d\n",
+				c2_i, api_data->c2_rule_id[c2_i]);
+			return;
+		}
+
+		c2_index_node = tpm_db_c2_index_node_get(c2_db_i);
+
+		TPM_MEMSET_ZERO(c2_data);
+		rc = tpm_db_c2_data_get(c2_db_i, &c2_data);
+		if (rc != TPM_OK) {
+			printk(KERN_INFO "tpm_db_c2_data_get err c2_db_i[%d]\n",
+				c2_db_i);
+			return;
+		}
+
+		/* looking for CLS lookup type */
+		if (c2_data.lkp_type != flow->lu_type)
+			continue;
+
+		/* found the same LU type, seach for hit count */
+		for (cnt_i = 0; (!found) && (cnt_i < c2_cntr_num); cnt_i++) {
+			if (c2_hw_i != c2_cntr_info[cnt_i].phys_idx)
+				continue;
+
+			tpm_sfs_api_data_print(&print_api_type,
+					       &print_api_info,
+						api_data);
+
+			tpm_sfs_cls_rl_print(cls_i, flow, hw_dump);
+
+			print_horizontal_line(40, "=");
+			printk(KERN_INFO "C2_INFO:\n");
+
+			tpm_sfs_valid_c2_entry_header_dump();
+
+			for (d = 0; d < sizeof(c2_data.field_bm) * BYTE_BITS; d++)
+				tpm_sfs_valid_c2_entry_line_dump(c2_data.lkp_type,
+					d, &c2_data, c2_index_node);
+			print_horizontal_line(179, "=");
+
+			if (hw_dump) {
+				MV_PP2_CLS_C2_ENTRY c2;
+
+				mvPp2ClsC2SwClear(&c2);
+				mvPp2ClsC2HwRead(c2_hw_i, &c2);
+				mvPp2ClsC2SwDump(&c2);
+			}
+
+			tpm_sfs_pme_cmd_trace_dump(c2_data.pkt_mod.mod_cmd_idx,
+					c2_data.pkt_mod.mod_data_idx);
+
+			api_data->c2_rule_id[c2_i] = TPM_DB_MNG_RULE_ID_INVALID;
+			found = true;
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_api_data_live_dump_lktype
+*
+* DESCRIPTION:
+*	This function dump all valid api data entries related to HW hits bigger then threshold
+*	accumulated for user input timeout in seconds
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*	len	- the buffer size
+*******************************************************************************/
+static void tpm_sfs_api_data_live_dump_lktype(int api_type, bool hw_dump)
+{
+	int				rc;
+	unsigned int			flow_i;
+	unsigned short			cls_i;
+	unsigned short			fl_rl_cnt;
+	unsigned short			fl_rl_tot_cnt;
+	bool				print_api_info;
+	bool				print_api_type;
+	unsigned int			c2_cntr_num = MV_PP2_CLS_C2_TCAM_SIZE;
+	unsigned int			c3_cntr_num = MV_PP2_CLS_C3_HASH_TBL_SIZE;
+	static struct tpm_hit_cnt_t		c2_cntr_info[MV_PP2_CLS_C2_TCAM_SIZE];
+	static struct tpm_hit_cnt_t		c3_cntr_info[MV_PP2_CLS_C3_HASH_TBL_SIZE];
+	static struct tpm_db_mng_api_data_t	api_data;
+	static struct tpm_db_cls_lkp_dcod_t	lkp_dcod;
+	static struct tpm_db_cls_fl_rule_t	flow[TPM_CLS_FLOW_RULE_MAX];
+
+	print_api_type = false;
+	TPM_MEMSET_ZERO(api_data);
+
+	rc = tpm_db_mng_api_entry_type_first_get(api_type, &api_data);
+	if (TPM_OK != rc)
+		return;
+	do {
+		/* parse all API CLS flows */
+		for (flow_i = 0; flow_i < TPM_DB_MNG_API_RULE_FLOW_ENTRY_MAX; flow_i++) {
+			print_api_info = false;
+			/* skip invalid rule IDs */
+			if (api_data.flow_rule_id[flow_i] == TPM_DB_MNG_RULE_ID_INVALID)
+				continue;
+			/* get physical index from logical */
+			rc = tpm_db_cls_rl_off_get(&cls_i, api_data.flow_rule_id[flow_i]);
+			if (rc != TPM_OK) {
+				printk(KERN_INFO "tpm_db_cls_rl_off_get err for api_data.flow_rule_id[%d]=%d\n",
+					flow_i, api_data.flow_rule_id[flow_i]);
+				return;
+			}
+
+			/* get containing flow information */
+			rc = tpm_db_cls_rl_off_lkp_dcod_get(cls_i, &lkp_dcod);
+			if (rc != TPM_OK) {
+				printk(KERN_INFO "tpm_db_cls_rl_off_lkp_dcod_get err for cls_i[%d]\n",
+					cls_i);
+				return;
+			}
+
+			TPM_MEMSET_ZERO(flow);
+			/* set the flow rule count */
+			fl_rl_tot_cnt = fl_rl_cnt = lkp_dcod.flow_off + lkp_dcod.flow_len - cls_i;
+
+			/* get the CLS flow rules */
+			rc = tpm_db_cls_fl_rule_list_get(cls_i,
+							fl_rl_tot_cnt,
+							flow);
+			if (rc != TPM_OK) {
+				printk(KERN_INFO "tpm_db_cls_fl_rule_list_get err for cls_i[%d]\n",
+					cls_i);
+				return;
+			}
+
+			/* traverse all flow rules */
+			while (fl_rl_cnt) {
+				unsigned int p, low_p = TPM_CLS_FLOW_RULE_MAX;
+				unsigned int low_p_idx = 0;
+
+				/* find lowest priority rule */
+				for (p = 0; p < fl_rl_tot_cnt; p++) {
+					if (flow[p].prio < low_p) {
+						low_p = flow[p].prio;
+						low_p_idx = p;
+					}
+				}
+				p = low_p_idx;
+
+				/* skip disabled rules */
+				if (false == flow[p].enabled
+				    || (flow[p].port_type == 0 && flow[p].port_bm == 0)) {
+					flow[p].prio = TPM_CLS_FLOW_RULE_MAX;
+					fl_rl_cnt--;
+					continue;
+				}
+
+				switch (flow[p].engine) {
+				case TPM_ENGINE_C2:
+					tpm_sfs_api_data_live_dump_c2(
+						&api_data,
+						hw_dump,
+						cls_i,
+						&flow[p],
+						c2_cntr_num,
+						c2_cntr_info);
+					break;
+
+				case TPM_ENGINE_C3_A:
+				case TPM_ENGINE_C3_B:
+					tpm_sfs_api_data_live_dump_c3(
+						&api_data,
+						hw_dump,
+						cls_i,
+						&flow[p],
+						c3_cntr_num,
+						c3_cntr_info);
+					break;
+				case TPM_ENGINE_C4:
+					/* TODO: add support */
+					break;
+				}
+				flow[p].prio = TPM_CLS_FLOW_RULE_MAX;
+				fl_rl_cnt--;
+			}
+		}
+	} while (tpm_db_mng_api_entry_type_next_get(&api_data) == TPM_OK);
+}
+
+
+/*******************************************************************************
+* tpm_sfs_flow_cfg_live_dump
+*
+* DESCRIPTION:
+*	This function dump all valid api data entries related to HW hits bigger then threshold
+*	accumulated for user input timeout in seconds
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*	len	- the buffer size
+*******************************************************************************/
+static void tpm_sfs_api_data_live_dump(const char *buf, size_t len)
+{
+	int				rc;
+	int				i;
+	int				init_state;
+	int				delay_sec;
+	int				hit_low_thresh;
+	int				parsedargs;
+	int				numparms;
+	bool				hw_dump;
+	unsigned int			c2_cntr_num = MV_PP2_CLS_C2_TCAM_SIZE;
+	unsigned int			c3_cntr_num = MV_PP2_CLS_C3_HASH_TBL_SIZE;
+	static struct tpm_hit_cnt_t		c2_cntr_info[MV_PP2_CLS_C2_TCAM_SIZE];
+	static struct tpm_hit_cnt_t		c3_cntr_info[MV_PP2_CLS_C3_HASH_TBL_SIZE];
+
+	enum para_idx {
+		param_timeout = 0,
+		param_low_thresh,
+		param_hw_dump,
+		max_params
+	};
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return;
+	}
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params) {
+		parm_error_completion(numparms, max_params, buf, NULL);
+		return;
+	}
+
+	/* Get parameters */
+	parsedargs = sscanf(buf, "%d %d %d", &delay_sec, &hit_low_thresh, (int *)&hw_dump);
+	if (parsedargs != numparms) {
+		printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		return;
+	}
+
+	rc = tpm_c2_hit_cntr_clear_all();
+	if (TPM_OK != rc) {
+		printk(KERN_INFO "FAIL\n");
+		return;
+	}
+
+	rc = mvPp2ClsC3HitCntrsClearAll();
+	if (MV_OK != rc) {
+		printk(KERN_INFO "FAIL\n");
+		return;
+	}
+
+	/* TODO: implement these counters
+		tpm_prs_hit_cntr_clear_all();
+	*/
+
+	/* wait the defined seconds timeout */
+	mdelay(delay_sec * 1000);
+
+	rc = tpm_c2_hit_cntr_all_get(hit_low_thresh, c2_cntr_info, &c2_cntr_num);
+	if (TPM_OK != rc) {
+		printk(KERN_INFO "failed to get C2 counters\n");
+		return;
+	}
+
+	rc = tpm_c3_hit_cntr_all_get(hit_low_thresh, c3_cntr_info, &c3_cntr_num);
+	if (TPM_OK != rc) {
+		printk(KERN_INFO "failed to get C3 counters\n");
+		return;
+	}
+
+	/* TODO: implement these routines
+		tpm_prs_hit_cntr_all_get();
+	*/
+
+	if (0 == c2_cntr_num && 0 == c3_cntr_num) {
+		printk(KERN_INFO "Got ZERO C2/3 hit counters\n");
+		return;
+	}
+
+	/* iterate over all API types */
+	for (i = TPM_API_PUBLIC_CLS; i <= TPM_API_PRIVATE_CPU_Q; i++)
+		tpm_sfs_api_data_live_dump_lktype(i, hw_dump);
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_api_type_data_dump
+*
+* DESCRIPTION:
+*           This function dump api data entries for a single API type
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*	len	- the buffer size
+*******************************************************************************/
+void tpm_sfs_api_type_data_dump(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_flow_log_id = 0,
+		max_params
+	};
+
+	int	cap_api_type;
+	int	parsedargs;
+	int	numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params)
+		parm_error_completion(numparms, max_params, buf, NULL);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &cap_api_type);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else
+			tpm_sfs_api_type_data_dump_in(cap_api_type);
+	}
+
+	return;
+}
+
+
+/*******************************************************************************
+* tpm_sfs_trace_level_set
+*
+* DESCRIPTION:
+*           This function set tpm_trace_level in run-time
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*	len	- the buffer size
+*******************************************************************************/
+void tpm_sfs_trace_level_set(const char *buf, size_t len)
+{
+	enum para_idx {
+		param_trace_level = 0,
+		max_params
+	};
+
+	int	trace_level;
+	int	parsedargs;
+	int	numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != max_params) {
+		parm_error_completion(numparms, max_params, buf, NULL);
+	} else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%x", &trace_level);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			printk(KERN_INFO "trace_level 0x%x\n", trace_level);
+			tpm_log_trace_level_set(trace_level);
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_virt_pid_dump_all
+*
+* DESCRIPTION:
+*           This function dump all virtual PID entries
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_virt_pid_dump_all(char *buf)
+{
+	int	off = 0;
+	int	rc;
+	int	gem;
+	int	init_state;
+	int	virt_pid;
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return TPM_OK;
+	}
+
+	printk(KERN_INFO "GEM_port virt_port_id\n");
+
+	/* iterate over all API types */
+	for (gem = 0; gem < 4096; gem++) {
+		rc = tpm_db_mng_virt_pid_get(gem, &virt_pid);
+		if (TPM_NO_SUCH == rc)
+			continue;
+
+		printk(KERN_INFO "%8d   %8d\n", gem, virt_pid);
+	}
+
+	return off;
+}
+
+
+
+/*******************************************************************************
+* tpm_sfs_cap_conf_dump_all
+*
+* DESCRIPTION:
+*           This function dump all capability configuration entries
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_sfs_cap_conf_dump_all(char *buf)
+{
+	int					off = 0;
+	int					rc;
+	int					i, bit, word;
+	int					init_state;
+	static struct tpm_db_mng_cap_conf_t	cap_arr[TPM_DB_MNG_CAP_MAX];
+	int					arr_len = TPM_DB_MNG_CAP_MAX;
+
+	init_state = tpm_db_module_state_get();
+	if (!init_state) {
+		printk(KERN_INFO "tpm not ready yet\n");
+		return TPM_OK;
+	}
+
+	rc = tpm_db_mng_pub_cap_get(cap_arr, &arr_len);
+	if (TPM_OK != rc) {
+		printk(KERN_INFO "tpm_db_mng_pub_cap_get returned error %d\n", rc);
+		printk(KERN_INFO "FAIL\n");
+		return off;
+	}
+
+	printk(KERN_INFO "indx cap_name         prec hit_nr vlan_number rule_type  cap_field_bm\n");
+
+	/* iterate over all API types */
+	for (i = 0; i < arr_len; i++) {
+		printk(KERN_INFO "%4d %-17s %2d   %2d %12s %6d       0x%08x = ",
+			i,
+			tpm_utils_cap_type_str_get(cap_arr[i].cap_api_type),
+			cap_arr[i].prec,
+			cap_arr[i].hit_number,
+			tpm_utils_vlan_num_str_get(cap_arr[i].vlan_num),
+			cap_arr[i].rule_type,
+			cap_arr[i].cap_field_bm);
+
+		word = 1;
+		for (bit = 0; bit < 32; bit++, word <<= 1) {
+			if (word & cap_arr[i].cap_field_bm)
+				printk(KERN_INFO "%s ", tpm_utils_field_match_str_get(word));
+		}
+		printk(KERN_INFO "\n");
+	}
+
+	return off;
+}
+
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"api_type_data_dump",				tpm_sfs_api_type_data_dump},
+	{"api_live_dump",				tpm_sfs_api_data_live_dump},
+	{"trace_level_set",				tpm_sfs_trace_level_set},
+#ifdef TPM_AUTO_TEST
+	{"auto_test",					tpm_sfs_mng_auto_test},
+#endif
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"cap_dump_all",				tpm_sfs_cap_dump_all},
+	{"api_data_dump_all",				tpm_sfs_api_data_dump_all},
+	{"virt_pid_dump_all",				tpm_sfs_virt_pid_dump_all},
+	{"cap_conf_dump_all",				tpm_sfs_cap_conf_dump_all},
+	{"help",					tpm_sfs_mng_help},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+			struct device_attribute *attr,
+			char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+
+static DEVICE_ATTR(cap_dump_all,			S_IRUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(api_data_dump_all,			S_IRUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(virt_pid_dump_all,			S_IRUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(cap_conf_dump_all,			S_IRUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(trace_level_set,			S_IWUSR,	tpm_cfg_show,	tpm_cfg_store);
+#ifdef TPM_AUTO_TEST
+static DEVICE_ATTR(auto_test,			S_IWUSR,	tpm_cfg_show,	tpm_cfg_store);
+#endif
+static DEVICE_ATTR(help,				S_IRUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(api_type_data_dump,			S_IWUSR,	tpm_cfg_show,	tpm_cfg_store);
+static DEVICE_ATTR(api_live_dump,			S_IWUSR,	tpm_cfg_show,	tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_mng_sw_attrs[] = {
+	&dev_attr_cap_dump_all.attr,
+	&dev_attr_api_data_dump_all.attr,
+	&dev_attr_api_type_data_dump.attr,
+	&dev_attr_api_live_dump.attr,
+	&dev_attr_virt_pid_dump_all.attr,
+	&dev_attr_cap_conf_dump_all.attr,
+	&dev_attr_trace_level_set.attr,
+#ifdef TPM_AUTO_TEST
+	&dev_attr_auto_test.attr,
+#endif
+	&dev_attr_help.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_mng_sw_group = {
+	.name = "mng",
+	.attrs = g_tpm_mng_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_mng_init
+*
+* DESCRIPTION: The routine will initialize TPM mng sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_mng_init(void)
+{
+	int rc;
+
+	/* Initialize mng sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_mng_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_plcr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_plcr.c
new file mode 100644
index 0000000..46e4322
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_plcr.c
@@ -0,0 +1,910 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_plcr.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+struct tpm_policer_early_drop_t g_tpm_sfs_early_drop;
+
+enum tpm_plcr_entry_dump_t {
+	TPM_PLCR_DUMP_ALL_VALID = 0,	/* dump all valid policers	*/
+	TPM_PLCR_DUMP_ALL,		/* dump all policers		*/
+	TPM_PLCR_DUMP_SPEC,		/* dump specific policer	*/
+};
+
+/* policer valid state string */
+static struct tpm_enum_str_t g_tpm_policer_entry_state[] = {
+	{TPM_PLCR_ENTRY_INVALID_STATE,	"Dis"},
+	{TPM_PLCR_ENTRY_VALID_STATE,	"En"},
+};
+
+/* policer rate generation state string */
+static struct tpm_enum_str_t g_tpm_policer_rate_gen_state[] = {
+	{TPM_PLCR_BASE_RATE_DISABLE,	"Dis"},
+	{TPM_PLCR_BASE_RATE_ENABLE,	"En"},
+};
+
+/* policer early drop state string */
+static struct tpm_enum_str_t g_tpm_policer_early_drop_state[] = {
+	{TPM_PLCR_EARLY_DROP_DISABLE,	"Dis"},
+	{TPM_PLCR_EARLY_DROP_ENABLE,	"En"},
+};
+
+/* policer token unit type */
+static struct tpm_enum_str_t g_tpm_policer_token_type[] = {
+	{TPM_PLCR_TOKEN_UNIT_BYTES,	"Byte"},
+	{TPM_PLCR_TOKEN_UNIT_PACKETS,	"Packet"},
+};
+
+/* policer token color mode */
+static struct tpm_enum_str_t g_tpm_policer_color_mode[] = {
+	{TPM_PLCR_BLIND_COLOR_MODE,	"Blind"},
+	{TPM_PLCR_AWARE_COLOR_MODE,	"Aware"},
+};
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+int tpm_sys_plcr_help_plcr_cmd(char *buf)
+{
+	int off = 0;
+
+	/* update reference counter */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [plcr_id] [action]                  > ref_cnt_update      -  update policer reference counter\n");
+	off += sprintf(buf+off, "\tplcr_id         (dec)policer ID, ranging from 1 to 15\n");
+	off += sprintf(buf+off, "\taction          (dec)actions, 0: increase, 1:decrease, 2:clear, 3:clear all\n\n");
+
+	/* set general config */
+	off += sprintf(buf+off, "echo [rate_en] [base_period] [pkt_len]   > gen_cfg_set         -  set general configuration\n");
+	off += sprintf(buf+off, "\trate_en         (dec)0:disable rate generation, 1: enable rate generation\n");
+	off += sprintf(buf+off, "\tbase_period     (dec)base token update period in units of core clock\n");
+	off += sprintf(buf+off, "\tpkt_len         (dec)minimium packet length allowed by policer\n\n");
+
+	/* early drop configuration */
+	off += sprintf(buf+off, "echo 1                                   > early_drop_init     -  init early drop software config\n");
+	off += sprintf(buf+off, "echo [type] [idx] [thresh]               > thresh_set          -  set threshold\n");
+	off += sprintf(buf+off, "\ttype            (dec)threshold type, 0:cpu queue threshold, 1:HWF queue threshold\n");
+	off += sprintf(buf+off, "\tidx             (dec)index of threshold array, ranging from 0 to %i\n", MV_PP2_V1_PLCR_EDROP_THRESH_NUM - 1);
+	off += sprintf(buf+off, "\tthresh          (dec)threshold, ranging from 0 to %i\n", TPM_MAX_VALUE_BY_BITS(MV_PP2_V1_PLCR_EDROP_TR_BITS));
+	off += sprintf(buf+off, "echo [type] [queue] [idx]                > idx_set             -  set threshold index\n");
+	off += sprintf(buf+off, "\ttype            (dec)queue type, 0:cpu RX queue, 1:HWF TX queue\n");
+	off += sprintf(buf+off, "\tqueue           (hex)queue index, ranging from 0 to %i, HWF TX queue includes queue high\n", TPM_NUM_MAX_QUEUE - 1);
+	off += sprintf(buf+off, "\tthresh          (dec)threshold, ranging from 0 to %i\n", MV_PP2_V1_PLCR_EDROP_THRESH_NUM - 1);
+	off += sprintf(buf+off, "echo [en]                                > early_drop_en       -  enable or disable early drop, triger action\n");
+	off += sprintf(buf+off, "\ten              (dec)early drop state, 0:disable, 1:enable\n\n");
+
+	/* policer info dump */
+	off += sprintf(buf+off, "echo [type] [plcr_id]                    > policer_dump        -  dump policer information\n");
+	off += sprintf(buf+off, "\ttype            (dec)dump type, 0:dump all valid policers, 1: dump all policers, 2:dump specific policer\n");
+	off += sprintf(buf+off, "\tplcr_id         (dec)policer ID, ranging from 0 to 15, fill 0 if not care about it\n\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	/* Packet count generated by policer */
+	off += sprintf(buf+off, "echo [plcr_id]                           > plcr_pkt_cnt_dump   -  dump the number of green/yellow/red packets that were generated by the policer\n");
+	off += sprintf(buf+off, "\tplcr_id         (dec)policer ID, ranging from 0 to 15\n\n");
+#endif
+	/* configuration dump */
+	off += sprintf(buf+off, "cat                                      > cfg_dump            -  dump policer general configuration and early drop configuration\n\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sfs_plcr_ref_cnt_update
+*
+* DESCRIPTION:
+*           This function will update reference counter of policer.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_ref_cnt_update(const char *buf, size_t len)
+{
+	enum ref_cnt_idx {
+		ref_cnt_id = 0,
+		ref_cnt_action,
+		ref_cnt_max
+	};
+	unsigned int plcr_id;
+	unsigned int action;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != ref_cnt_max)
+		parm_error_completion(numparms, ref_cnt_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &plcr_id, &action);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_ref_cnt_update((unsigned char)plcr_id, (enum tpm_plcr_ref_cnt_action_t)action))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_gen_cfg_set
+*
+* DESCRIPTION:
+*           This function will set general configuration.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_gen_cfg_set(const char *buf, size_t len)
+{
+	enum gen_cfg_idx {
+		gen_cfg_rate_en = 0,
+		gen_cfg_base_period,
+		gen_cfg_pkt_len,
+		gen_cfg_max
+	};
+	unsigned int rate_en;
+	unsigned int base_period;
+	unsigned int pkt_len;
+	struct tpm_policer_gen_cfg_t gen_cfg;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != gen_cfg_max)
+		parm_error_completion(numparms, gen_cfg_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d", &rate_en, &base_period, &pkt_len);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			gen_cfg.rate_state  = (enum tpm_plcr_rate_state_t)rate_en;
+			gen_cfg.base_period = (unsigned short)base_period;
+			gen_cfg.min_pkt_len = (unsigned char)pkt_len;
+			if (!tpm_plcr_gen_cfg_set(&gen_cfg))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_plcr_early_drop_init
+*
+* DESCRIPTION:
+*	This function init early drop data base.
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_early_drop_init(void)
+{
+	unsigned int idx = 0;
+	unsigned int gmac = 0;
+
+	/* clear TPM policer early drop DB */
+	TPM_MEMSET_ZERO(g_tpm_sfs_early_drop);
+
+	/* disable early drop and queue threshold index */
+	g_tpm_sfs_early_drop.state = TPM_PLCR_EARLY_DROP_DISABLE;
+	for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+		g_tpm_sfs_early_drop.rxq_idx[idx] = TPM_PLCR_INVALID_Q_THESH_IDX;
+
+	for (gmac = 0; gmac < TPM_NUM_TX_PORTS; gmac++) {
+		for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+			g_tpm_sfs_early_drop.txq_idx[gmac][idx] = TPM_PLCR_INVALID_Q_THESH_IDX;
+
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_plcr_thresh_set
+*
+* DESCRIPTION:
+*           This function set threshold to data base.
+* INPUTS:
+*	queue_type - queue type
+*	idx        - index of threshold
+*	thresh     - threshold value
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_thresh_set(enum tpm_queue_type_t queue_type, unsigned char idx, unsigned short thresh)
+{
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, queue_type, TPM_HWF_TX_QUEUE, "invalid queue type");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, idx, MV_PP2_V1_PLCR_EDROP_THRESH_NUM - 1, "invalid threshold index");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, thresh, TPM_MAX_VALUE_BY_BITS(MV_PP2_V1_PLCR_EDROP_TR_BITS),
+				"invalid threshold value");
+
+	/* save threshold */
+	if (queue_type == TPM_CPU_RX_QUEUE)
+		g_tpm_sfs_early_drop.cpu_q_thesh[idx] = thresh;
+	else
+		g_tpm_sfs_early_drop.hwf_q_thesh[idx] = thresh;
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_plcr_idx_set
+*
+* DESCRIPTION:
+*           This function set the threhold value index for queue.
+* INPUTS:
+*	queue_type - queue type
+*	queue      - queue index
+*	idx        - index of threshold
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_idx_set(enum tpm_queue_type_t queue_type, unsigned char queue, unsigned char idx)
+{
+	unsigned char queue_low = 0;
+	unsigned char queue_high = 0;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, queue_type, TPM_HWF_TX_QUEUE, "invalid queue type");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, idx, MV_PP2_V1_PLCR_EDROP_THRESH_NUM - 1, "invalid threshold index");
+
+	queue_low = queue & TPM_QUEUE_LOW_MASK;
+	queue_high = (queue >> TPM_QUEUE_HIGH_SHIFT) & TPM_QUEUE_HIGH_MASK;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, queue_low, TPM_NUM_MAX_QUEUE - 1, "invalid queue Low");
+
+	/* save threshold */
+	if (queue_type == TPM_CPU_RX_QUEUE) {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, queue_high, TPM_NUM_MAX_GMAC_PORTS,
+			"invalid CPU RX queue High");
+
+		g_tpm_sfs_early_drop.rxq_idx[queue] = idx;
+	} else {
+		TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, queue_high, TPM_NUM_TX_PORTS, "invalid TX queue High");
+
+		g_tpm_sfs_early_drop.txq_idx[queue_high][queue_low] = idx;
+	}
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_plcr_early_drop_en
+*
+* DESCRIPTION:
+*           This function set early drop state and trigger the setting to HW.
+* INPUTS:
+*	state - enable or disable early drop
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_early_drop_en(enum tpm_plcr_early_drop_state_t state)
+{
+	int rc;
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, state, TPM_PLCR_EARLY_DROP_ENABLE, "invalid early drop state");
+
+	/* save and trigger setting to HW */
+	g_tpm_sfs_early_drop.state = state;
+	rc = tpm_plcr_early_drop_set(&g_tpm_sfs_early_drop);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to set early drop\n");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_early_drop_init
+*
+* DESCRIPTION:
+*           This function init software datebase for early drop.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_early_drop_init(const char *buf, size_t len)
+{
+	enum early_drop_idx {
+		early_drop_en = 0,
+		early_drop_max
+	};
+	unsigned int en;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != early_drop_max)
+		parm_error_completion(numparms, early_drop_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &en);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_early_drop_init())
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_thresh_set
+*
+* DESCRIPTION:
+*           This function set early drop threshold to software buffer.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_thresh_set(const char *buf, size_t len)
+{
+	enum plcr_thresh_idx {
+		plcr_thresh_type = 0,
+		plcr_thresh_idx,
+		plcr_thresh_value,
+		plcr_thresh_max
+	};
+	unsigned int type;
+	unsigned int idx;
+	unsigned int value;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != plcr_thresh_max)
+		parm_error_completion(numparms, plcr_thresh_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d %d", &type, &idx, &value);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_thresh_set(type, idx, value))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_idx_set
+*
+* DESCRIPTION:
+*           This function set early drop queue idx to threshold array.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_idx_set(const char *buf, size_t len)
+{
+	enum plcr_idx_idx {
+		plcr_idx_type = 0,
+		plcr_idx_queue,
+		plcr_idx_idx,
+		plcr_idx_max
+	};
+	unsigned int type;
+	unsigned int queue;
+	unsigned int idx;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != plcr_idx_max)
+		parm_error_completion(numparms, plcr_idx_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %x %d", &type, &queue, &idx);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_idx_set((enum tpm_queue_type_t)type, (unsigned char)queue, (unsigned char)idx))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_early_drop_en
+*
+* DESCRIPTION:
+*           This function set the state of early drop and trigger the setting.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_early_drop_en(const char *buf, size_t len)
+{
+	enum early_drop_en_idx {
+		early_drop_state = 0,
+		early_drop_en_max
+	};
+	unsigned int en;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != early_drop_en_max)
+		parm_error_completion(numparms, early_drop_en_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &en);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_early_drop_en((enum tpm_plcr_early_drop_state_t)en))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_plcr_policer_dump
+*
+* DESCRIPTION:
+*           This function dump policer information.
+* INPUTS:
+*	type      - dump type
+*	plcr_id   - policer ID
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_policer_dump(enum tpm_plcr_entry_dump_t type, unsigned char plcr_id)
+{
+	int rc;
+	unsigned int idx = 0;
+	struct tpm_db_plcr_entry_t plcr_entry;
+
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, type, TPM_PLCR_DUMP_SPEC, "invalid dump type");
+	TPM_POS_RANGE_VALIDATE_STR(TPM_SYSFS_MOD, plcr_id, MV_PP2_PLCR_NUM - 1, "invalid policer ID");
+
+	/* dump policer */
+	print_horizontal_line(95, "=");
+	printk(KERN_INFO "=                                     Policer Table                                           =\n");
+	print_horizontal_line(95, "=");
+	printk(KERN_INFO "= Index |   State   | Token_Unit | Color_Mode |     CIR    |    CBS    |    EBS    | Ref_Cnt  =\n");
+
+	for (idx = 0; idx < MV_PP2_PLCR_NUM; idx++) {
+		rc = tpm_db_plcr_entry_get(idx, &plcr_entry);
+		IF_ERROR_STR(TPM_SYSFS_MOD, rc, "failed to get policer entry from DB\n");
+
+		if (((type == TPM_PLCR_DUMP_ALL_VALID) && (plcr_entry.valid == TPM_PLCR_ENTRY_VALID_STATE)) ||
+		     (type == TPM_PLCR_DUMP_ALL) ||
+		    ((type == TPM_PLCR_DUMP_SPEC) && (idx == plcr_id))) {
+			printk(KERN_INFO "= %5d | %9s | %10s |  %9s |  %8d  |  %8d |  %8d | %5d    =\n",
+				idx,
+				lookup_enum_str(g_tpm_policer_entry_state, TPM_MEMBER_NUM(g_tpm_policer_entry_state),
+						plcr_entry.valid),
+				lookup_enum_str(g_tpm_policer_token_type, TPM_MEMBER_NUM(g_tpm_policer_token_type),
+						plcr_entry.plcr_entry.token_unit),
+				lookup_enum_str(g_tpm_policer_color_mode, TPM_MEMBER_NUM(g_tpm_policer_color_mode),
+						plcr_entry.plcr_entry.color_mode),
+				plcr_entry.plcr_entry.cir,
+				plcr_entry.plcr_entry.cbs,
+				plcr_entry.plcr_entry.ebs,
+				plcr_entry.ref_cnt);
+		}
+	}
+	print_horizontal_line(95, "=");
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_policer_dump
+*
+* DESCRIPTION:
+*           This function dump the policer information.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sfs_plcr_policer_dump(const char *buf, size_t len)
+{
+	enum policer_dump_idx {
+		policer_dump_type = 0,
+		policer_dump_id,
+		policer_dump_max
+	};
+	unsigned int type;
+	unsigned int id;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != policer_dump_max)
+		parm_error_completion(numparms, policer_dump_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &type, &id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_plcr_policer_dump(type, id))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_plcr_cfg_dump
+*
+* DESCRIPTION:
+*           This function dump policer general information and early drop config.
+* INPUTS:
+*	None.
+*
+* OUTPUTS:
+*	None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int tpm_plcr_cfg_dump(void)
+{
+	unsigned int idx = 0;
+	unsigned int gmac = 0;
+	struct tpm_policer_gen_cfg_t gen_cfg;
+	struct tpm_policer_early_drop_t early_drop;
+	char buf[1024];
+	int off = 0;
+	int rc;
+
+	/* get general configuration and early drop configuration */
+	rc = tpm_db_plcr_gen_cfg_get(&gen_cfg);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to get policer general config\n");
+	rc = tpm_db_plcr_early_drop_get(&early_drop);
+	IF_ERROR_STR(TPM_PLCR_MOD, rc, "failed to get policer early drop\n");
+
+	/* dump general configuration */
+	TPM_MEMSET_ZERO(buf);
+	off += sprintf(buf+off, "PLCR status: %d policers, rate_en:%4s, base_period:%d, min_pkt_len=%d\n",
+			MV_PP2_PLCR_NUM,
+			lookup_enum_str(g_tpm_policer_rate_gen_state, TPM_MEMBER_NUM(g_tpm_policer_rate_gen_state),
+			gen_cfg.rate_state),
+			gen_cfg.base_period,
+			gen_cfg.min_pkt_len);
+
+	/* dump early drop state */
+	off += sprintf(buf+off, "Early drop status: %s\n",
+		lookup_enum_str(g_tpm_policer_early_drop_state, TPM_MEMBER_NUM(g_tpm_policer_early_drop_state),
+				early_drop.state));
+
+	if (early_drop.state == TPM_PLCR_EARLY_DROP_ENABLE) {
+		/* dump early drop CPU queue thresholds */
+		off += sprintf(buf+off, "CPU queue thresholds: ");
+		for (idx = 0; idx < MV_PP2_V1_PLCR_EDROP_THRESH_NUM; idx++)
+			off += sprintf(buf+off, "%d ", early_drop.cpu_q_thesh[idx]);
+
+		off += sprintf(buf+off, "\n");
+
+		/* dump early drop HWF queue thresholds */
+		off += sprintf(buf+off, "HWF queue thresholds: ");
+		for (idx = 0; idx < MV_PP2_V1_PLCR_EDROP_THRESH_NUM; idx++)
+			off += sprintf(buf+off, "%d ", early_drop.hwf_q_thesh[idx]);
+
+		off += sprintf(buf+off, "\n");
+
+		/* dump early drop CPU queue threshold index */
+		off += sprintf(buf+off, "CPU RX queue index: ");
+		for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+			off += sprintf(buf+off, "%d ", early_drop.rxq_idx[idx]);
+
+		off += sprintf(buf+off, "\n");
+
+		/* dump early drop CPU queue threshold index */
+		off += sprintf(buf+off, "HWF TX queue index:\n");
+		for (gmac = 0; gmac < TPM_NUM_TX_PORTS; gmac++) {
+			off += sprintf(buf+off, "TX_PORT%d: ", gmac);
+			for (idx = 0; idx < TPM_NUM_MAX_QUEUE; idx++)
+				off += sprintf(buf+off, "%d ", early_drop.txq_idx[gmac][idx]);
+
+			off += sprintf(buf+off, "\n");
+		}
+		off += sprintf(buf+off, "note: threshold index(%i) means invalid index\n",
+				TPM_PLCR_INVALID_Q_THESH_IDX);
+	}
+	printk(KERN_INFO "%s", buf);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_sfs_plcr_cfg_dump
+*
+* DESCRIPTION:
+*           This function dump the policer configuration.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+int tpm_sfs_plcr_cfg_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_plcr_cfg_dump();
+
+	return off;
+}
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* tpm_sfs_plcr_cfg_dump
+*
+* DESCRIPTION:
+*           This function dump the counts the number of green/yellow/red packets
+*           that were generated by the policer. Only valid in A0 version.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+void tpm_sfs_plcr_pkt_cnt_dump(const char *buf, size_t len)
+{
+	enum plcr_cnt_idx {
+		plcr_idx = 0,
+		plcr_cnt_max
+	};
+	unsigned int plcr_id;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != plcr_cnt_max)
+		parm_error_completion(numparms, plcr_cnt_max, buf, tpm_sys_plcr_help_plcr_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &plcr_id);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			mvPp2V1PlcrTbCntDump(plcr_id);
+			printk(KERN_INFO "OK\n");
+		}
+	}
+}
+
+#endif
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"ref_cnt_update",		tpm_sfs_plcr_ref_cnt_update},
+	{"gen_cfg_set",			tpm_sfs_plcr_gen_cfg_set},
+	{"early_drop_init",		tpm_sfs_plcr_early_drop_init},
+	{"thresh_set",			tpm_sfs_plcr_thresh_set},
+	{"idx_set",			tpm_sfs_plcr_idx_set},
+	{"early_drop_en",		tpm_sfs_plcr_early_drop_en},
+	{"policer_dump",		tpm_sfs_plcr_policer_dump},
+#ifdef CONFIG_MV_ETH_PP2_1
+	{"plcr_pkt_cnt_dump",		tpm_sfs_plcr_pkt_cnt_dump},
+#endif
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",			tpm_sys_plcr_help_plcr_cmd},
+	{"cfg_dump",			tpm_sfs_plcr_cfg_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/* Store Attr */
+static DEVICE_ATTR(ref_cnt_update,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(gen_cfg_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(early_drop_init,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(thresh_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(idx_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(early_drop_en,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(policer_dump,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+#ifdef CONFIG_MV_ETH_PP2_1
+static DEVICE_ATTR(plcr_pkt_cnt_dump,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+#endif
+
+/* Show Attr */
+static DEVICE_ATTR(cfg_dump,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_plcr_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_ref_cnt_update.attr,
+	&dev_attr_gen_cfg_set.attr,
+	&dev_attr_early_drop_init.attr,
+	&dev_attr_thresh_set.attr,
+	&dev_attr_idx_set.attr,
+	&dev_attr_early_drop_en.attr,
+	&dev_attr_policer_dump.attr,
+#ifdef CONFIG_MV_ETH_PP2_1
+	&dev_attr_plcr_pkt_cnt_dump.attr,
+#endif
+	&dev_attr_cfg_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_plcr_sw_group = {
+	.name = "plcr",
+	.attrs = g_tpm_plcr_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_plcr_init
+*
+* DESCRIPTION: The routine will initialize TPM plcr sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_plcr_init(void)
+{
+	int rc;
+
+	/* Initialize plcr sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_plcr_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_pme.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_pme.c
new file mode 100644
index 0000000..adb96b6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_pme.c
@@ -0,0 +1,1043 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_pme.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM PME SYSFS PRINT                                            */
+/* ========================================================================== */
+
+/* Fieled name string */
+static struct tpm_enum_str_t g_tpm_pme_vlan_subr_str[] = {
+	{VLANOP_NOOP,			"NO_VLAN_OP"},
+	{VLANOP_EXT_TAG_MOD,		"EXT_TAG_MOD"},
+	{VLANOP_EXT_TAG_DEL,		"EXT_TAG_DEL"},
+	{VLANOP_EXT_TAG_INS,		"EXT_TAG_INS"},
+	{VLANOP_EXT_TAG_MOD_INS,	"EXT_TAG_MOD_INS"},
+	{VLANOP_INS_2TAG,		"INS_2TAG"},
+	{VLANOP_MOD_2TAG,		"MOD_2TAG"},
+	{VLANOP_SWAP_TAGS,		"SWAP_TAGS"},
+	{VLANOP_DEL_2TAG,		"DEL_2TAG"},
+	{VLANOP_INT_TAG_MOD,		"INT_TAG_MOD"},
+	{VLANOP_EXT_TAG_DEL_INT_MOD,	"EXT_TAG_DEL_INT_MOD"},
+};
+
+static void tpm_pme_print_vlan_permu_dump_head(void)
+{
+	print_horizontal_line(103, "=");
+	printk(KERN_INFO "=      VLAN_OP       |     QoS_Src     |      Out_TPID_Src     |  Out_VID_Src  |     Out_Pbit_Src     =\n");
+	print_horizontal_line(103, "=");
+}
+
+/*******************************************************************************
+* tpm_pme_print_vlan_permu_stat
+*
+* DESCRIPTION:
+*           This function dump supported VLAN Ops permutation statistics.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_pme_print_vlan_permu_stat(void)
+{
+	int rc;
+	struct tpm_pme_vlan_skip_permu_t permu;
+	unsigned int vlan_op;
+
+	tpm_pme_print_vlan_permu_dump_head();
+	for (vlan_op = VLANOP_NOOP; vlan_op < VLANOP_MAX_CNT; vlan_op++) {
+		rc = tpm_db_pme_vlan_permu_stat_get(vlan_op, &permu);
+		IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME VLAN Op(%d) permutation statistic DB read fail\n", vlan_op);
+
+		printk(KERN_INFO "=");
+		printk(KERN_INFO "%19s", lookup_enum_str(g_tpm_pme_vlan_subr_str,
+					       TPM_MEMBER_NUM(g_tpm_pme_vlan_subr_str),
+					       (int)vlan_op));
+		printk(KERN_INFO " | ");
+
+		if (permu.qos_src != TPM_PME_QOS_MAX)
+			printk(KERN_INFO "%15s", "NO_NEED");
+		else
+			printk(KERN_INFO "%15s", "Desc + Mod_data");
+		printk(KERN_INFO " | ");
+
+		if (permu.tpid_sel != TPM_VLAN_ETY_LOG_MAX)
+			printk(KERN_INFO "%21s", "VLAN1_2");
+		else
+			printk(KERN_INFO "%21s", "VLAN1_2 + REG0 + REG1");
+		printk(KERN_INFO " | ");
+
+		if (permu.vid_sel != TPM_VLAN_VID_LOG_MAX)
+			printk(KERN_INFO "%13s", "VLAN1_2");
+		else
+			printk(KERN_INFO "%13s", "VLAN1_2 + NEW");
+		printk(KERN_INFO " | ");
+
+		if (permu.vid_sel != TPM_VLAN_PBIT_LOG_MAX)
+			printk(KERN_INFO "%13s", "VLAN1_2");
+		else
+			printk(KERN_INFO "%13s", "VLAN1_2 + NEW");
+		print_horizontal_line(103, "-");
+	}
+	print_horizontal_line(103, "=");
+	return TPM_OK;
+}
+
+
+static void tpm_pme_print_templ_dump_head(void)
+{
+	print_horizontal_line(121, "=");
+	printk(KERN_INFO "=   Use_Case  | Jmp_Idx | Ref_Cnt | QoS_Src | MOD_Field(NOTE:()mean field NOT from user; []mean field is NOT mandatory) =\n");
+	print_horizontal_line(121, "=");
+}
+
+/*******************************************************************************
+* tpm_pme_print_instr_templ
+*
+* DESCRIPTION:
+*           This function dump valid instruction templates in system
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_pme_print_instr_templ(void)
+{
+	int rc;
+	int templ_idx;
+	struct tpm_pme_templ_data_t templ_data;
+
+	tpm_pme_print_templ_dump_head();
+
+	for (templ_idx = 0; templ_idx < TPM_PME_INSTR_TEMPL_MAX; templ_idx++) {
+		printk(KERN_INFO "=");
+		rc = tpm_db_pme_instr_templ_get(templ_idx, &templ_data);
+		IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME instruction template DB read fail\n");
+		/* Use case print */
+		if (templ_data.ext_mod_bm == TPM_PME_NO_MOD_BM)
+			printk(KERN_INFO "%13s", "NO_MOD");
+		else if (templ_data.ext_mod_bm == TPM_PME_L2_SW_BM1 ||
+			 templ_data.ext_mod_bm == TPM_PME_L2_SW_BM2)
+			printk(KERN_INFO "%13s", "L2_Switch");
+		else if (templ_data.ext_mod_bm == TPM_PME_ROUTE_BM1 ||
+			 templ_data.ext_mod_bm == TPM_PME_ROUTE_BM2 ||
+			 templ_data.ext_mod_bm == TPM_PME_ROUTE_BM3 ||
+			 templ_data.ext_mod_bm == TPM_PME_ROUTE_BM4)
+			printk(KERN_INFO "%13s", "UNI/MC_ROUTE");
+		else if (templ_data.ext_mod_bm == TPM_PME_NAPT_US_BM1 ||
+			 templ_data.ext_mod_bm == TPM_PME_NAPT_US_BM2)
+			printk(KERN_INFO "%13s", "IPV4_NAPT_US");
+		else if (templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM1 ||
+			 templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM2)
+			printk(KERN_INFO "%13s", "IPV4_NAPT_DS");
+		else
+			printk(KERN_INFO "%13s", "");
+		printk(KERN_INFO "|");
+		/* Jmp index print */
+		printk(KERN_INFO "%9d", templ_data.jmp_idx);
+		printk(KERN_INFO "|");
+		/* Ref_cnt print */
+		printk(KERN_INFO "%9d", templ_data.ref_count);
+		printk(KERN_INFO "|");
+		/* QOS src print */
+		if (templ_data.int_mod_bm & TPM_QOS_FROM_DESC)
+			printk(KERN_INFO "%9s", "TX_DESC");
+		else
+			printk(KERN_INFO "%9s", "PRIVATE");
+		printk(KERN_INFO "|  ");
+		/* Mod fields print */
+		if (templ_data.int_mod_bm & TPM_MH_T1_MOD) {
+			if (templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM1 ||
+			    templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM2)
+				printk(KERN_INFO "(MH_Mod0) + ");
+			else
+				printk(KERN_INFO "(MH_Mod1) + ");
+		}
+		if (templ_data.int_mod_bm & TPM_MH_T5_MOD)
+			printk(KERN_INFO "(MH_Mod5) + ");
+#ifndef CONFIG_MV_ETH_PP2_1
+		if (templ_data.int_mod_bm & TPM_MH_DEL)
+			printk(KERN_INFO "(MH_DEL) + ");
+#endif
+		if (templ_data.ext_mod_bm & TPM_ETH_DST_SET)
+			printk(KERN_INFO "DA + ");
+		if (templ_data.ext_mod_bm & TPM_ETH_SRC_SET)
+			printk(KERN_INFO "SA + ");
+		if (templ_data.ext_mod_bm & TPM_VLAN_MOD) {
+			if (templ_data.ext_mod_bm == TPM_PME_L2_SW_BM1 ||
+			    templ_data.ext_mod_bm == TPM_PME_L2_SW_BM2)
+				printk(KERN_INFO " VLAN  + ");
+			else
+				printk(KERN_INFO "[VLAN] + ");
+		}
+		if (templ_data.ext_mod_bm & TPM_ETH_TYPE_SET)
+			printk(KERN_INFO "ETY + ");
+		if (templ_data.ext_mod_bm & TPM_PPOE_ADD)
+			printk(KERN_INFO "PPOE_ADD + ");
+		if (templ_data.ext_mod_bm & TPM_PPOE_DEL)
+			printk(KERN_INFO "PPOE_DEL + ");
+		if (templ_data.ext_mod_bm & TPM_IP_DSCP_SET) {
+			if (templ_data.ext_mod_bm == TPM_PME_L2_SW_BM1 ||
+			    templ_data.ext_mod_bm == TPM_PME_L2_SW_BM2)
+				printk(KERN_INFO " DSCP  + ");
+			else
+				printk(KERN_INFO "[DSCP] + ");
+		}
+		if (templ_data.ext_mod_bm & TPM_TTL_HOPL_DEC)
+			printk(KERN_INFO "TTL/HOP + ");
+		if (templ_data.ext_mod_bm & TPM_IP_SRC_SET)
+			printk(KERN_INFO "SIP + ");
+		if (templ_data.ext_mod_bm & TPM_IP_DST_SET)
+			printk(KERN_INFO "DIP + ");
+		if (templ_data.ext_mod_bm & TPM_L4_SRC_SET)
+			printk(KERN_INFO "L4_SRC + ");
+		if (templ_data.ext_mod_bm & TPM_L4_DST_SET)
+			printk(KERN_INFO "L4_DST + ");
+		print_horizontal_line(121, "-");
+	}
+	print_horizontal_line(121, "=");
+
+	return TPM_OK;
+}
+
+static void tpm_pme_print_mod_data_combin_templ_head(void)
+{
+	print_horizontal_line(60, "=");
+	printk(KERN_INFO "=  Template |     Private Data      |      Share Data      =\n");
+	print_horizontal_line(60, "=");
+}
+
+/*******************************************************************************
+* tpm_pme_print_mod_data_combin_templ
+*
+* DESCRIPTION:
+*           This function dump modification data and corresponding instruction template
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_pme_print_mod_data_combin_templ(int api_logic_idx)
+{
+	int rc;
+	struct tpm_pme_data_entry_set_t mod_data_set, sha_data_set;
+	struct tpm_pme_templ_data_t templ_data;
+	struct tpm_pme_vlan_subr_t vlan_subr;
+	unsigned int sha_hw_first;
+	unsigned int db_idx, templ_idx;
+	unsigned int private_idx = 0;
+	unsigned int share_unit_size = 0, sha_entry_idx = 0;
+	unsigned char addr_tmp[MAC_ADDR_SIZE];
+	struct tpm_engine_pkt_mod_t pkt_mod, pkt_mod_array[TPM_ACT_NUM_MAX];
+	unsigned int num_dest, hwfm_dptr = 0;
+	int loop, i;
+
+	/* Map API logical index to Private data index */
+	rc = tpm_mng_log_idx_map_pkt_mod(api_logic_idx, &num_dest, pkt_mod_array);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "API Logical Index %d map to Privated data index failed\n", api_logic_idx);
+
+	printk(KERN_INFO "API rule [%d], dest_num[%d], modification info:\n", api_logic_idx, num_dest);
+
+	for (loop = 0; loop < num_dest; loop++) {
+		private_idx = 0;
+		share_unit_size = 0;
+		sha_entry_idx = 0;
+		memcpy(&pkt_mod, &pkt_mod_array[loop], sizeof(struct tpm_engine_pkt_mod_t));
+		hwfm_dptr = pkt_mod.mod_data_idx;
+		printk(KERN_INFO "\nDest[%d], hwfm_iptr=%d, hwfm_dptr = %d, L4_cksum_en=%d\n",
+			loop, pkt_mod.mod_cmd_idx, pkt_mod.mod_data_idx, pkt_mod.l4_chksum_update_flag);
+
+		/* For case without modification info, return for loop */
+		if (pkt_mod.mod_cmd_idx == 0 && pkt_mod.mod_data_idx == 0)
+			continue;
+
+		tpm_pme_print_mod_data_combin_templ_head();
+		/* Search data Db to find entry with first_idx equal to hwfm_dptr */
+		for (db_idx = 0; db_idx < TPM_PME_PRIVATE_SET_MAX; db_idx++) {
+			rc = tpm_db_pme_data_get(TPM_PME_PRIVATE_TBL, db_idx, &mod_data_set);
+			IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Private data DB read failed\n");
+			if (mod_data_set.valid == TPM_DATA_VALID &&
+			    mod_data_set.first_idx == hwfm_dptr)
+				break;
+		}
+		if (pkt_mod.mod_data_idx && db_idx == TPM_PME_PRIVATE_SET_MAX)
+			IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH,
+					"Private data entry with first_idx(%d) No Found\n", hwfm_dptr);
+
+		/* Search template DB */
+		for (templ_idx = 0; templ_idx < TPM_PME_INSTR_TEMPL_MAX; templ_idx++) {
+			rc = tpm_db_pme_instr_templ_get(templ_idx, &templ_data);
+			IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME instruction template DB read fail\n");
+			if (templ_data.valid == TPM_INSTR_TEMPL_VALID &&
+			    templ_data.jmp_idx == pkt_mod.mod_cmd_idx)
+				break;
+		}
+		if (templ_idx == TPM_PME_INSTR_TEMPL_MAX)
+			IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH,
+					"Template with Jump(%d) No Found\n", mod_data_set.templ_jmp);
+
+		if (templ_data.int_mod_bm & (TPM_MH_T1_MOD | TPM_MH_T5_MOD)) {
+			printk(KERN_INFO "=");
+			if (templ_data.int_mod_bm & TPM_MH_T1_MOD) {
+				if (templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM1 ||
+				    templ_data.ext_mod_bm == TPM_PME_NAPT_DS_BM2)
+					printk(KERN_INFO "%10s", "MH_Mod0");
+				else
+					printk(KERN_INFO "%10s", "MH_Mod1");
+			}
+			if (templ_data.int_mod_bm & TPM_MH_T5_MOD)
+				printk(KERN_INFO "%10s", "MH_Mod5");
+			printk(KERN_INFO " | ");
+			if (templ_data.ext_mod_bm != TPM_PME_NAPT_DS_BM1 &&
+			    templ_data.ext_mod_bm != TPM_PME_NAPT_DS_BM2) {
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+			} else {
+				printk(KERN_INFO "%24s", " | ");
+			}
+
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+
+#ifndef CONFIG_MV_ETH_PP2_1
+		if (templ_data.int_mod_bm & TPM_MH_DEL) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "MH_Del");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "%24s", " | ");
+
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+#endif
+		/* No modification, return to for loop */
+		if (!templ_data.ext_mod_bm)
+			continue;
+		/* DA */
+		if (templ_data.ext_mod_bm & TPM_ETH_DST_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "DA_Mod");
+			printk(KERN_INFO " | ");
+			/* Check it is MC or not */
+			if (((mod_data_set.mod_data[private_idx] & IP4_MC_MAC_2BYTE_MASK) == IP4_MC_MAC_2BYTE ||
+			    ((mod_data_set.mod_data[private_idx] & IP6_MC_MAC_2BYTE_MASK) == IP6_MC_MAC_2BYTE)) &&
+			    templ_data.ext_mod_bm & TPM_PPOE_DEL) {
+				for (i = 0; i < MAC_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (mod_data_set.mod_data[private_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = mod_data_set.mod_data[private_idx++] & 0xFF;
+				}
+				for (i = 0; i < MAC_ADDR_SIZE; i++)
+					printk(KERN_INFO "%02x:", addr_tmp[i]);
+				printk(KERN_INFO "    | ");
+			} else {
+				sha_hw_first = mod_data_set.mod_data[private_idx];
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				/* Search Share data DB */
+				for (db_idx = 0; db_idx < TPM_PME_SHARE_SET_MAX; db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, db_idx, &sha_data_set);
+					IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Share data DB read failed\n");
+					if (sha_data_set.valid == TPM_DATA_VALID &&
+					    sha_data_set.first_idx == sha_hw_first)
+						break;
+				}
+				if (db_idx == TPM_PME_SHARE_SET_MAX)
+					IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH, "Share DB entry Not Found\n");
+				share_unit_size = sha_data_set.real_entry_cnt * 2;
+				for (i = 0; i < MAC_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < MAC_ADDR_SIZE; i++)
+					printk(KERN_INFO "%02x:", addr_tmp[i]);
+				share_unit_size -= MAC_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			}
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/* SA */
+		if (templ_data.ext_mod_bm & TPM_ETH_SRC_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "SA_Mod");
+			printk(KERN_INFO " | ");
+			if (share_unit_size != 0) {
+				printk(KERN_INFO "%24s", " | ");
+				for (i = 0; i < MAC_ADDR_SIZE / 2; i++) {
+					addr_tmp[2 * i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2 * i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < MAC_ADDR_SIZE; i++)
+					printk(KERN_INFO "%02x:", addr_tmp[i]);
+				share_unit_size -= MAC_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			} else {
+				sha_hw_first = mod_data_set.mod_data[private_idx];
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				/* Search Share data DB */
+				for (db_idx = 0; db_idx < TPM_PME_SHARE_SET_MAX; db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, db_idx, &sha_data_set);
+					IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Share data DB read failed\n");
+					if (sha_data_set.valid == TPM_DATA_VALID &&
+					    sha_data_set.first_idx == sha_hw_first)
+						break;
+				}
+				if (db_idx == TPM_PME_SHARE_SET_MAX)
+					IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH, "Share DB entry Not Found\n");
+				share_unit_size = sha_data_set.real_entry_cnt * 2;
+				for (i = 0; i < MAC_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < MAC_ADDR_SIZE; i++)
+					printk(KERN_INFO "%02x:", addr_tmp[i]);
+				share_unit_size -= MAC_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			}
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/* VLAN */
+		if (templ_data.ext_mod_bm & TPM_VLAN_MOD) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "VLAN_subr");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx]);
+			printk(KERN_INFO "%18s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+			for (db_idx = 0; db_idx < TPM_VLAN_TEMPL_MAX; db_idx++) {
+				rc = tpm_db_pme_vlan_subr_get(db_idx, &vlan_subr);
+				IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME VLAN subr DB read failed\n");
+				if (vlan_subr.valid == TPM_VLAN_SUBR_VALID &&
+				    mod_data_set.mod_data[private_idx] == vlan_subr.start_idx)
+					break;
+			}
+			if (db_idx == TPM_VLAN_TEMPL_MAX)
+				IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH, "TPM PME VLAN subr Not Found\n");
+
+			private_idx++;
+			if (vlan_subr.vlan_op == VLANOP_EXT_TAG_MOD ||
+			    vlan_subr.vlan_op == VLANOP_EXT_TAG_INS ||
+			    vlan_subr.vlan_op == VLANOP_EXT_TAG_MOD_INS ||
+			    vlan_subr.vlan_op == VLANOP_INS_2TAG ||
+			    vlan_subr.vlan_op == VLANOP_MOD_2TAG ||
+			    vlan_subr.vlan_op == VLANOP_INT_TAG_MOD ||
+			    vlan_subr.vlan_op == VLANOP_EXT_TAG_DEL_INT_MOD) {
+				printk(KERN_INFO "=");
+				printk(KERN_INFO "%10s", "VLAN1");
+				printk(KERN_INFO " | ");
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				printk(KERN_INFO "\n------------------------------------------------------------\n");
+			}
+			if (vlan_subr.vlan_op == VLANOP_EXT_TAG_MOD_INS ||
+			    vlan_subr.vlan_op == VLANOP_INS_2TAG ||
+			    vlan_subr.vlan_op == VLANOP_MOD_2TAG) {
+				printk(KERN_INFO "=");
+				printk(KERN_INFO "%10s", "VLAN2");
+				printk(KERN_INFO " | ");
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				printk(KERN_INFO "\n------------------------------------------------------------\n");
+			}
+		}
+
+		/* TPM_PPOE_ADD */
+		if (templ_data.ext_mod_bm & TPM_PPOE_ADD) {
+			if (templ_data.ext_mod_bm == TPM_PME_ROUTE_BM2) {
+				printk(KERN_INFO "=");
+				printk(KERN_INFO "%10s", "PPoE_Add");
+				printk(KERN_INFO " | ");
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				printk(KERN_INFO "\n------------------------------------------------------------\n");
+			} else if (templ_data.ext_mod_bm == TPM_PME_NAPT_US_BM2) {
+				printk(KERN_INFO "=");
+				printk(KERN_INFO "%10s", "PPoE_Add");
+				printk(KERN_INFO " | ");
+				printk(KERN_INFO "[0x%04x]", templ_data.pme_entry[templ_data.ppoe_idx - templ_data.start_idx].data);
+				printk(KERN_INFO "%16s", " | ");
+				printk(KERN_INFO "\n------------------------------------------------------------\n");
+			}
+		}
+		/* PPPoE Del */
+		if (templ_data.ext_mod_bm & TPM_PPOE_DEL) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "PPoE_Del");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "%24s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+
+		/* DSCP */
+		if (templ_data.ext_mod_bm & TPM_IP_DSCP_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "DSCP");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+			printk(KERN_INFO "%18s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/* TTL */
+		if (templ_data.ext_mod_bm & TPM_TTL_HOPL_DEC) {
+			printk(KERN_INFO "=");
+			if (templ_data.int_mod_bm & TPM_MOD_PKT_IS_IP6)
+				printk(KERN_INFO "%10s", "HOP_DEC");
+			else
+				printk(KERN_INFO "%10s", "TTL_DEC");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "%24s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/*SIP*/
+		if (templ_data.ext_mod_bm & TPM_IP_SRC_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "SIP_Mod");
+			printk(KERN_INFO " | ");
+			if (share_unit_size != 0) {
+				printk(KERN_INFO "%24s", " | ");
+
+				for (i = 0; i < IPV4_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < IPV4_ADDR_SIZE; i++)
+					printk(KERN_INFO "%03d.", addr_tmp[i]);
+				share_unit_size -= IPV4_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			} else {
+				sha_hw_first = mod_data_set.mod_data[private_idx];
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				/* Search Share data DB */
+				for (db_idx = 0; db_idx < TPM_PME_SHARE_SET_MAX; db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, db_idx, &sha_data_set);
+					IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Share data DB read failed\n");
+					if (sha_data_set.valid == TPM_DATA_VALID &&
+					    sha_data_set.first_idx == sha_hw_first)
+						break;
+				}
+				if (db_idx == TPM_PME_SHARE_SET_MAX)
+					IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH, "Share DB entry Not Found\n");
+				share_unit_size = sha_data_set.real_entry_cnt * 2;
+
+				for (i = 0; i < IPV4_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < IPV4_ADDR_SIZE; i++)
+					printk(KERN_INFO "%03d.", addr_tmp[i]);
+				share_unit_size -= IPV4_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			}
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/* DIP */
+		if (templ_data.ext_mod_bm & TPM_IP_DST_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "DIP_Mod");
+			printk(KERN_INFO " | ");
+			if (share_unit_size != 0) {
+				printk(KERN_INFO "%24s", " | ");
+				for (i = 0; i < IPV4_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < IPV4_ADDR_SIZE; i++)
+					printk(KERN_INFO "%03d.", addr_tmp[i]);
+				share_unit_size -= IPV4_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			} else {
+				sha_hw_first = mod_data_set.mod_data[private_idx];
+				printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+				printk(KERN_INFO "%18s", " | ");
+				/* Search Share data DB */
+				for (db_idx = 0; db_idx < TPM_PME_SHARE_SET_MAX; db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, db_idx, &sha_data_set);
+					IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Share data DB read failed\n");
+					if (sha_data_set.valid == TPM_DATA_VALID &&
+					    sha_data_set.first_idx == sha_hw_first)
+						break;
+				}
+				if (db_idx == TPM_PME_SHARE_SET_MAX)
+					IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH, "Share DB entry Not Found\n");
+				share_unit_size = sha_data_set.real_entry_cnt * 2;
+
+				for (i = 0; i < IPV4_ADDR_SIZE/2; i++) {
+					addr_tmp[2*i] = (sha_data_set.mod_data[sha_entry_idx] >> 8) & 0xFF;
+					addr_tmp[2*i + 1] = sha_data_set.mod_data[sha_entry_idx++] & 0xFF;
+				}
+				for (i = 0; i < IPV4_ADDR_SIZE; i++)
+					printk(KERN_INFO "%03d.", addr_tmp[i]);
+				share_unit_size -= IPV4_ADDR_SIZE;
+				if (!share_unit_size)
+					sha_entry_idx = 0;
+			}
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+		/* L4_Src_port */
+		if (templ_data.ext_mod_bm & TPM_L4_SRC_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "L4_Src");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+			printk(KERN_INFO "%18s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+
+		/* L4_Dst_port */
+		if (templ_data.ext_mod_bm & TPM_L4_DST_SET) {
+			printk(KERN_INFO "=");
+			printk(KERN_INFO "%10s", "L4_Dst");
+			printk(KERN_INFO " | ");
+			printk(KERN_INFO "0x%04x", mod_data_set.mod_data[private_idx++]);
+			printk(KERN_INFO "%18s", " | ");
+			printk(KERN_INFO "\n------------------------------------------------------------\n");
+		}
+
+		print_horizontal_line(60, "=");
+	}
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* tpm_pme_print_mod_data
+*
+* DESCRIPTION:
+*           This function dump modification data in data table
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int tpm_pme_print_mod_data(int api_logic_idx)
+{
+	int rc;
+	struct tpm_pme_data_entry_set_t mod_data_set, sha_data_set;
+	unsigned int sha_hw_first;
+	unsigned int db_idx, unit_idx, loop, i;
+	struct tpm_engine_pkt_mod_t pkt_mod[TPM_ACT_NUM_MAX];
+	unsigned int num_dest, hwfm_dptr = 0;
+
+	/* Map API logical index to Private data index */
+	rc = tpm_mng_log_idx_map_pkt_mod(api_logic_idx, &num_dest, pkt_mod);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "API Logical Index %d map to Privated data index failed\n", api_logic_idx);
+
+	printk(KERN_INFO "API rule [%d], dest_num[%d], modification data:\n", api_logic_idx, num_dest);
+
+	for (loop = 0; loop < num_dest; loop++) {
+		hwfm_dptr = pkt_mod[loop].mod_data_idx;
+		printk(KERN_INFO "\nDest[%d], hwfm_iptr=%d, hwfm_dptr = %d, L4_cksum_en=%d\n", loop,
+			pkt_mod[loop].mod_cmd_idx, pkt_mod[loop].mod_data_idx, pkt_mod[loop].l4_chksum_update_flag);
+
+		/* For case without modification info, return for loop */
+		if (pkt_mod[loop].mod_cmd_idx == 0 && pkt_mod[loop].mod_data_idx == 0)
+			continue;
+
+		/* Search Db to find entry with first_idx equal to hwfm_dptr */
+		for (db_idx = 0; db_idx < TPM_PME_PRIVATE_SET_MAX; db_idx++) {
+			rc = tpm_db_pme_data_get(TPM_PME_PRIVATE_TBL, db_idx, &mod_data_set);
+			IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Private data DB read failed\n");
+			if (mod_data_set.valid == TPM_DATA_VALID &&
+			    mod_data_set.first_idx == hwfm_dptr)
+				break;
+		}
+		if (db_idx == TPM_PME_PRIVATE_SET_MAX)
+			IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH,
+					"Private data entry with first_idx(%d) No Found\n", hwfm_dptr);
+
+		/* Print private data */
+		printk(KERN_INFO "Private data unit:\n");
+		for (i = 0; i < mod_data_set.real_entry_cnt; i++)
+			printk(KERN_INFO "\t(%d)--0x%04x\n", i, mod_data_set.mod_data[i]);
+
+		/* Print share data if there is */
+		for (unit_idx = TPM_PME_DATA_UNIT0; unit_idx < TPM_PME_DATA_UNIT_MAX; unit_idx++) {
+			if (mod_data_set.share_idx_ptr[unit_idx] != TPM_PME_INVALID_IDX) {
+				sha_hw_first = mod_data_set.mod_data[mod_data_set.share_idx_ptr[unit_idx]];
+				for (db_idx = 0; db_idx < TPM_PME_SHARE_SET_MAX; db_idx++) {
+					rc = tpm_db_pme_data_get(TPM_PME_SHARE_TBL, db_idx, &sha_data_set);
+					IF_ERROR_STR(TPM_SYSFS_MOD, rc, "TPM PME Share data DB read failed\n");
+					if (sha_data_set.valid == TPM_DATA_VALID &&
+					    sha_data_set.first_idx == sha_hw_first)
+						break;
+				}
+				if (db_idx == TPM_PME_SHARE_SET_MAX)
+					IF_ERROR_STR(TPM_SYSFS_MOD, TPM_NO_SUCH,
+						"Share entry with first_idx(%d) No Found\n",
+						mod_data_set.share_idx_ptr[unit_idx]);
+				if (sha_data_set.real_entry_cnt == TPM_PME_SHA_MAC_UNIT_BYTES / 2)
+					printk(KERN_INFO "Share unit%d MAC:\n", unit_idx);
+				else if (sha_data_set.real_entry_cnt == TPM_PME_SHA_SA_SIP_UNIT_BYTES / 2)
+					printk(KERN_INFO "Share unit%d DA&SIP:\n", unit_idx);
+				else
+					printk(KERN_INFO "Share unit%d DA&SA&DIP:\n", unit_idx);
+				for (i = 0; i < sha_data_set.real_entry_cnt; i++)
+					printk(KERN_INFO "\t(%d)--0x%04x\n", i, sha_data_set.mod_data[i]);
+			}
+		}
+	}
+
+	return TPM_OK;
+}
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+/*******************************************************************************
+* sys_help_tpm_pme_debug_cmd
+*
+* DESCRIPTION:
+*           This function dump help of c2 debug sysfs commands
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static int sys_help_tpm_pme_debug_cmd(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [logic_idx] [mode] > mod_data_dump -  dump mod data with API rule logic index\n");
+	off += sprintf(buf+off, "\tlogic_idx                 (dec)API Rule Logical Index\n");
+	off += sprintf(buf+off, "\tmode                      (dec)mode, 0: dump mod data; 1: dump mod data/template\n");
+
+	off += sprintf(buf+off, "\n");
+	/* xxx info dump */
+	off += sprintf(buf+off, "cat instr_templ_dump      -  dump all valid PME instruction templates\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat vlan_op_info_dump     -  dump VLAN Ops permuatation statistics.\n");
+	off += sprintf(buf+off, "\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+/*******************************************************************************
+* sfs_tpm_pme_mod_data_dump
+*
+* DESCRIPTION:
+*           This function dump modification data according to pointer
+* INPUTS:
+*       buf - Shell parameters as char buffer
+*       len - Number of characters in buffer
+*******************************************************************************/
+static void sfs_tpm_pme_mod_data_dump(const char *buf, size_t len)
+{
+	enum pme_mod_data_dump_parm_indx_t {
+		logic_idx = 0,
+		dump_mode,
+		mod_data_dump_max
+	};
+
+	unsigned int api_logic_idx, mode;
+	int parsedargs;
+	int numparms;
+	int rc;
+
+	numparms = count_parameters(buf);
+	if (numparms != mod_data_dump_max)
+		parm_error_completion(numparms, mod_data_dump_max, buf, sys_help_tpm_pme_debug_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d %d", &api_logic_idx, &mode);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (mode)
+				rc = tpm_pme_print_mod_data_combin_templ(api_logic_idx);
+			else
+				rc = tpm_pme_print_mod_data(api_logic_idx);
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_pme_instr_templ_dump
+*
+* DESCRIPTION:
+*           This function dump all valid instruction template
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_pme_instr_templ_dump(char *buf)
+{
+	int off = 0;
+	int rc;
+
+	rc = tpm_pme_print_instr_templ();
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_pme_vlan_permu_dump
+*
+* DESCRIPTION:
+*           This function dump current VLAN Op permuatation.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+static int sfs_tpm_pme_vlan_permu_dump(char *buf)
+{
+	int off = 0;
+	int rc;
+
+	rc = tpm_pme_print_vlan_permu_stat();
+
+	return off;
+}
+
+
+/*******************************************************************************
+* tpm_sfs_pme_jmp_cmd_trace_dump
+*
+* DESCRIPTION:
+*           This recursive function dumps the PME modification instructions and data
+* INPUTS:
+*	cmd - the first command index to print
+*******************************************************************************/
+static void tpm_sfs_pme_jmp_cmd_trace_dump(unsigned int	cmd)
+{
+	MV_PP2_PME_ENTRY	pme;
+
+	do {
+		/* dump the first command */
+		mvPp2PmeSwClear(&pme);
+		mvPp2PmeHwRead(cmd, &pme);
+		printk(KERN_INFO "[%4d]: ", cmd);
+		mvPp2PmeSwDump(&pme);
+
+		/* recurse for jump commands */
+		switch (MV_PP2_PME_CMD_GET(&pme)) {
+		case MV_PP2_PME_CMD_JUMP:
+			tpm_sfs_pme_jmp_cmd_trace_dump(MV_PP2_PME_DATA_GET(&pme));
+			return;
+
+		case MV_PP2_PME_CMD_JUMP_SKIP:
+		case MV_PP2_PME_CMD_JUMP_SUB:
+			tpm_sfs_pme_jmp_cmd_trace_dump(MV_PP2_PME_DATA_GET(&pme));
+			break;
+		}
+		cmd++;
+		/* continue till reach last command */
+	} while ((pme.word & MV_PP2_PME_LAST_MASK) == 0);
+}
+
+/*******************************************************************************
+* tpm_sfs_pme_cmd_trace_dump
+*
+* DESCRIPTION:
+*       This function dumps the PME modification instructions and first data0
+*	for specified command trace
+* INPUTS:
+*	cmd - the first command index to print
+*	data - the first data index to print
+*******************************************************************************/
+void tpm_sfs_pme_cmd_trace_dump(unsigned int	cmd,
+					unsigned int	dptr)
+{
+	MV_PP2_PME_ENTRY	pme;
+	unsigned short		data;
+
+	print_horizontal_line(40, "=");
+	printk(KERN_INFO "PME_INFO:\n");
+
+	mvPp2PmeHwDataTblRead(0, dptr, &data);
+	printk(KERN_INFO "DPTR0[%d]: 0x%.4x 0x%.4x\n", dptr, 0xffff & (data >> 16), 0xffff & data);
+
+	do {
+		/* dump the first command */
+		mvPp2PmeSwClear(&pme);
+		mvPp2PmeHwRead(cmd, &pme);
+		printk(KERN_INFO "[%4d]: ", cmd);
+		mvPp2PmeSwDump(&pme);
+
+		/* recurse for jump commands */
+		switch (MV_PP2_PME_CMD_GET(&pme)) {
+		case MV_PP2_PME_CMD_JUMP:
+			tpm_sfs_pme_jmp_cmd_trace_dump(MV_PP2_PME_DATA_GET(&pme));
+			return;
+
+		case MV_PP2_PME_CMD_JUMP_SKIP:
+		case MV_PP2_PME_CMD_JUMP_SUB:
+			tpm_sfs_pme_jmp_cmd_trace_dump(MV_PP2_PME_DATA_GET(&pme));
+			break;
+		}
+
+		cmd++;
+		/* continue till reach last command */
+	} while ((pme.word & MV_PP2_PME_LAST_MASK) == 0);
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"mod_data_dump",		sfs_tpm_pme_mod_data_dump},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",			sys_help_tpm_pme_debug_cmd},
+	{"instr_templ_dump",		sfs_tpm_pme_instr_templ_dump},
+	{"vlan_op_info_dump",		sfs_tpm_pme_vlan_permu_dump},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Store Attr */
+static DEVICE_ATTR(mod_data_dump,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+/* Show Attr */
+static DEVICE_ATTR(instr_templ_dump,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_op_info_dump,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_pme_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_instr_templ_dump.attr,
+	&dev_attr_vlan_op_info_dump.attr,
+	&dev_attr_mod_data_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_pme_sw_group = {
+	.name = "pme",
+	.attrs = g_tpm_pme_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_pme_init
+*
+* DESCRIPTION: The routine will initialize TPM pme sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_pme_init(void)
+{
+	int rc;
+
+	/* Initialize pme sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_pme_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_prs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_prs.c
new file mode 100644
index 0000000..f1be4f0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_prs.c
@@ -0,0 +1,751 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_prs.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+
+
+/* ========================================================================== */
+/*             TPM PRS SYSFS PRINT                                            */
+/* ========================================================================== */
+/* Traffic type string */
+static char *tpm_traffic_type_str_tbl[TPM_TRAFFIC_TYPE_MAX] = {
+	"LSP_GMAC0_DEFAULT",
+	"LSP_LPK_GMAC_DEFAULT",
+	"LSP_PON_DEFAULT",
+	"IPV4_UC_RTR_NF_NPPOE_UNTAG",
+	"IPV4_UC_RTR_NF_NPPOE_STAG",
+	"IPV4_UC_RTR_NF_NPPOE_DTAG",
+	"IPV4_UC_RTR_NF_NPPOE_TTAG",
+	"IPV4_UC_RTR_NF_PPOE_UNTAG",
+	"IPV4_UC_RTR_NF_PPOE_STAG",
+	"IPV4_UC_RTR_NF_PPOE_DTAG",
+	"IPV4_UC_RTR_NF_PPOE_TTAG",
+	"IPV4_UC_RTR_FRAG_NPPOE_UNTAG",
+	"IPV4_UC_RTR_FRAG_NPPOE_STAG",
+	"IPV4_UC_RTR_FRAG_NPPOE_DTAG",
+	"IPV4_UC_RTR_FRAG_NPPOE_TTAG",
+	"IPV4_UC_RTR_FRAG_PPOE_UNTAG",
+	"IPV4_UC_RTR_FRAG_PPOE_STAG",
+	"IPV4_UC_RTR_FRAG_PPOE_DTAG",
+	"IPV4_UC_RTR_FRAG_PPOE_TTAG",
+	"NON_IP_MTM_UNTAG",
+	"NON_IP_MTM_STAG",
+	"NON_IP_MTM_DTAG",
+	"NON_IP_MTM_TTAG",
+	"IPV4_MC_RTR_UNTAG",
+	"IPV4_MC_L2_UNTAG",
+	"NON_IP_MC_UNTAG",
+	"IPV4_MC_RTR_TAG",
+	"IPV4_MC_RTR_DTAG",
+	"IPV4_MC_L2_TAG",
+	"NON_IP_MC_STAG",
+	"IPV4_MC_L2_DTAG",
+	"NON_IP_MC_DTAG",
+	"IPV6_MC_RTR_UNTAG",
+	"IPV6_MC_L2_UNTAG",
+	"IPV6_MC_RTR_TAG",
+	"IPV6_MC_RTR_DTAG",
+	"IPV6_MC_L2_TAG",
+	"IPV6_MC_L2_DTAG",
+	"IPV4_L2_MC_BRG_NF_UNTAG",
+	"IPV4_L2_MC_BRG_NF_STAG",
+	"IPV4_L2_MC_BRG_NF_DTAG",
+	"IPV6_L2_MC_BRG_NF_UNTAG",
+	"IPV6_L2_MC_BRG_NF_STAG",
+	"IPV6_L2_MC_BRG_NF_DTAG",
+	"IPV4_UC_BRG_NF_UNTAG",
+	"IPV4_BC_L2_NF_UNTAG",
+	"IPV4_BC_L3_NF_UNTAG",
+	"IPV4_UC_BRG_NF_STAG",
+	"IPV4_BC_L2_NF_STAG",
+	"IPV4_BC_L3_NF_STAG",
+	"IPV4_UC_BRG_NF_DTAG",
+	"IPV4_BC_L2_NF_DTAG",
+	"IPV4_BC_L3_NF_DTAG",
+	"IPV4_UC_BRG_NF_TTAG",
+	"IPV6_UC_BRG_NF_UNTAG",
+	"IPV6_BC_L2_NF_UNTAG",
+	"IPV6_BC_L3_NF_UNTAG",
+	"IPV6_UC_BRG_NF_STAG",
+	"IPV6_BC_L2_NF_STAG",
+	"IPV6_BC_L3_NF_STAG",
+	"IPV6_UC_BRG_NF_DTAG",
+	"IPV6_BC_L2_NF_DTAG",
+	"IPV6_BC_L3_NF_DTAG",
+	"IPV6_UC_BRG_NF_TTAG",
+	"PPOE_BRG_UNTAG",
+	"NON_IP_BC_UNTAG",
+	"NON_IP_BRG_UNTAG",
+	"PPOE_BRG_STAG",
+	"NON_IP_BC_STAG",
+	"NON_IP_BRG_STAG",
+	"PPOE_BRG_DTAG",
+	"PPOE_BRG_TTAG",
+	"NON_IP_BC_DTAG",
+	"NON_IP_BRG_DTAG",
+	"NON_IP_BRG_TTAG",
+	"IPV6_UC_RTR_SPEC_EX_NPPOE_UNTAG",
+	"IPV6_UC_RTR_SPEC_EX_NPPOE_STAG",
+	"IPV6_UC_RTR_SPEC_EX_NPPOE_DTAG",
+	"IPV6_UC_RTR_SPEC_EX_NPPOE_TTAG",
+	"IPV6_UC_RTR_SPEC_EX_PPOE_UNTAG",
+	"IPV6_UC_RTR_SPEC_EX_PPOE_STAG",
+	"IPV6_UC_RTR_SPEC_EX_PPOE_DTAG",
+	"IPV6_UC_RTR_SPEC_EX_PPOE_TTAG",
+	"IPV6_UC_RTR_NOEX_NPPOE_UNTAG",
+	"IPV6_UC_RTR_NOEX_NPPOE_STAG",
+	"IPV6_UC_RTR_NOEX_NPPOE_DTAG",
+	"IPV6_UC_RTR_NOEX_NPPOE_TTAG",
+	"IPV6_UC_RTR_NOEX_PPOE_UNTAG",
+	"IPV6_UC_RTR_NOEX_PPOE_STAG",
+	"IPV6_UC_RTR_NOEX_PPOE_DTAG",
+	"IPV6_UC_RTR_NOEX_PPOE_TTAG",
+	"IPV6_UC_RTR_GEN_EX_NPPOE_UNTAG",
+	"IPV6_UC_RTR_GEN_EX_NPPOE_STAG",
+	"IPV6_UC_RTR_GEN_EX_NPPOE_DTAG",
+	"IPV6_UC_RTR_GEN_EX_NPPOE_TTAG",
+	"IPV6_UC_RTR_GEN_EX_PPOE_UNTAG",
+	"IPV6_UC_RTR_GEN_EX_PPOE_STAG",
+	"IPV6_UC_RTR_GEN_EX_PPOE_DTAG",
+	"IPV6_UC_RTR_GEN_EX_PPOE_TTAG",
+	"NON_IP_ARP",
+	"LOOPBACK_PORT_PKT",
+	"UNEXPECTED_PKT"
+};
+
+/* result info fields map to string */
+static struct tpm_prs_ri_str_map_t tpm_rerult_str_map[] = {
+	{TPM_PRS_MAC2ME_MASK,	{"BRIDGE", "ROUTING"} },
+	{TPM_PRS_EDSA_MASK,	{"NO_EDSA", "EDSA"} },
+	{TPM_PRS_VLAN_MASK,	{"UN_TAG", "SINGLE_TAG", "DOUBLE_TAG", "TRIPLE_TAG"} },
+	{TPM_PRS_CPU_CODE_MASK,	{"NO_DEF", "SPECIAL_PKT"} },
+	{TPM_PRS_L2_VER_MASK,	{"L2_LLC", "LLC+SNAP", "L2_V2", "L2_OTHER"} },
+	{TPM_PRS_L2_CAST_MASK,	{"L2_UC", "L2_MC", "L2_BC", "L2CAST_RESERVE"} },
+	{TPM_PRS_PPPOE_MASK,	{"NO_PPPoE", "PPPoE"} },
+	{TPM_PRS_L3_INFO_MASK,	{"L3INFO_NA", "IPV4_IHE5", "IPV4_IHG5", "IPV4_OTHER", "IPV6_NO_EX",
+				 "IPV6_EX", "ARP", "L3INFO_UDF"} },
+	{TPM_PRS_L3_CAST_MASK,	{"L3_UC", "L3_MC", "L3_AC", "L3_BC"} },
+	{TPM_PRS_FRAG_MASK,	{"NO_FRAG", "FRAG"} },
+	{TPM_PRS_UDF2_IPV6_MASK, {"UDF2_IPV6_NA", "UDF2_IPV6_PRE", "UDF2_IPV4_IN_IPV6", "UDF2_RESERVE"} },
+	{TPM_PRS_UDF3_MASK,	{"UDF3_NA", "UDF3_SPECIAL_IPV6_NH"} },
+	{TPM_PRS_L4_INFO_MASK,	{"L4_INFO_NA", "TCP", "UDP"} },
+	{TPM_PRS_UDF5_MASK,	{"UDF5_NA"} },
+	{TPM_PRS_UDF6_MASK,	{"UDF6_NA"} },
+	{TPM_PRS_UDF7_MASK,	{"UDF7_NA"} },
+	{TPM_PRS_DROP_MASK,	{"NO_DROP", "DROP"} }
+};
+
+/* lu_id info print one line */
+static void tpm_print_luid_info_dump_line(unsigned int first_line,
+					  unsigned int traffic_type,
+					  unsigned int result_info,
+					  unsigned int result_info_mask,
+					  bool         valid_state,
+					  unsigned int lu_id,
+					  unsigned int tcam_idx)
+{
+	char *empty_str = "";
+	char *valid_str = "Valid";
+	char *invalid_str = "Invalid";
+	char *traffic_type_str = empty_str;
+	char *valid_state_str = empty_str;
+	char *result_info_str = empty_str;
+	char lookup_id_str[8] = "";
+	char tcam_idx_str[8] = "";
+	unsigned int ri_array_idx, ri_field_idx = 0;
+
+	if (first_line) {
+		traffic_type_str = tpm_traffic_type_str_tbl[traffic_type];
+		if (valid_state)
+			valid_state_str = valid_str;
+		else
+			valid_state_str = invalid_str;
+		sprintf(lookup_id_str, "%02d", lu_id);
+		sprintf(tcam_idx_str, "%03d", tcam_idx);
+	}
+	for (ri_array_idx = 0; ri_array_idx < TPM_PRS_RI_FIELD_NUM; ri_array_idx++) {
+		if (result_info_mask == tpm_rerult_str_map[ri_array_idx].prs_ri_mask)
+			break;
+	}
+	if (ri_array_idx == TPM_PRS_RI_FIELD_NUM && result_info_mask != TPM_PRS_RI_NONE_MASK)
+		return;
+
+	switch (result_info_mask) {
+	case TPM_PRS_MAC2ME_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_MAC2ME_OFFS;
+		break;
+	case TPM_PRS_EDSA_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_EDSA_OFFS;
+		break;
+	case TPM_PRS_VLAN_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_VLAN_OFFS;
+		break;
+	case TPM_PRS_CPU_CODE_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_CPU_CODE_OFFS;
+		break;
+	case TPM_PRS_L2_VER_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_L2_VER_OFFS;
+		break;
+	case TPM_PRS_L2_CAST_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_L2_CAST_OFFS;
+		break;
+	case TPM_PRS_PPPOE_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_PPPOE_OFFS;
+		break;
+	case TPM_PRS_L3_INFO_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_L3_INFO_OFFS;
+		break;
+	case TPM_PRS_L3_CAST_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_L3_CAST_OFFS;
+		break;
+	case TPM_PRS_FRAG_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_FRAG_OFFS;
+		break;
+	case TPM_PRS_UDF2_IPV6_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_UDF2_IPV6_OFFS;
+		break;
+	case TPM_PRS_UDF3_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_UDF3_OFFS;
+		break;
+	case TPM_PRS_L4_INFO_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_L4_INFO_OFFS;
+		break;
+	case TPM_PRS_UDF5_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_UDF5_OFFS;
+		break;
+	case TPM_PRS_UDF6_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_UDF6_OFFS;
+		break;
+	case TPM_PRS_UDF7_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_UDF7_OFFS;
+		break;
+	case TPM_PRS_DROP_MASK:
+		ri_field_idx = (result_info & result_info_mask) >> TPM_PRS_DROP_OFFS;
+		break;
+	}
+	if (result_info_mask != TPM_PRS_RI_NONE_MASK)
+		result_info_str = tpm_rerult_str_map[ri_array_idx].result_str[ri_field_idx];
+
+	if (first_line || result_info_mask != TPM_PRS_RI_NONE_MASK) {
+		printk(KERN_INFO "+  %31s | %7s | %20s | %8s | %8s  +\n", traffic_type_str,
+							       valid_state_str,
+							       result_info_str,
+							       lookup_id_str,
+							       tcam_idx_str);
+	}
+
+	return;
+}
+
+static void tpm_print_luid_dump_head(void)
+{
+	printk(KERN_INFO "============================================================================================\n");
+	printk(KERN_INFO "=       Traffic_Type                Valid_State    Packet_Result     Lookup_ID   TCAM_IDX  =\n");
+	printk(KERN_INFO "============================================================================================\n");
+}
+
+/*******************************************************************************
+* tpm_prs_luid_info_dump
+*
+* DESCRIPTION: The routine dump the classifier lookup ID information from tpm_db
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+*           Void
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_prs_luid_info_dump(void)
+{
+	struct tpm_prs_lu_id_t lu_id_data;
+	unsigned int i, traffic_type_id;
+	unsigned int first_line;
+
+	tpm_print_luid_dump_head();
+
+	for (traffic_type_id = LSP_GMAC0_DEFAULT; traffic_type_id < TPM_TRAFFIC_TYPE_MAX; traffic_type_id++) {
+		if (tpm_db_prs_lu_id_get(traffic_type_id, &lu_id_data))
+			continue;
+		first_line = 1;
+		if (lu_id_data.prs_result.prs_ri_mask == TPM_PRS_RI_NONE_MASK) {
+			tpm_print_luid_info_dump_line(first_line,
+						      traffic_type_id,
+						      TPM_PRS_RI_NONE,
+						      TPM_PRS_RI_NONE_MASK,
+						      lu_id_data.valid,
+						      lu_id_data.lu_id,
+						      lu_id_data.prs_idx);
+			printk(KERN_INFO "+------------------------------------------------------------------------------------------+\n");
+			continue;
+		}
+		for (i = 0; i < TPM_PRS_RI_FIELD_NUM; i++) {
+			if (lu_id_data.prs_result.prs_ri_mask & tpm_rerult_str_map[i].prs_ri_mask) {
+				tpm_print_luid_info_dump_line(first_line,
+							      traffic_type_id,
+							      lu_id_data.prs_result.prs_ri,
+							      tpm_rerult_str_map[i].prs_ri_mask,
+							      lu_id_data.valid,
+							      lu_id_data.lu_id,
+							      lu_id_data.prs_idx);
+				first_line = 0;
+			}
+		}
+		printk(KERN_INFO "+------------------------------------------------------------------------------------------+\n");
+	}
+	printk(KERN_INFO "============================================================================================\n");
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_prs_ipv6_spec_nh_dump
+*
+* DESCRIPTION: The routine dump the special IPV6 next header list from tpm_db
+*
+* INPUTS:
+*           None
+*
+* OUTPUTS:
+*           None
+*
+* RETURNS:
+*           Void
+*
+* COMMENTS:
+*           None
+*******************************************************************************/
+static void tpm_prs_ipv6_spec_nh_dump(void)
+{
+	struct tpm_prs_ipv6_spec_nh_t ip6_nh[TPM_PRS_IPV6_NH_COUNT];
+
+	if (tpm_db_spec_ipv6nh_get(ip6_nh))
+		return;
+
+	printk(KERN_INFO "IPV6 Next Header need Special Treat:\n");
+	if (ip6_nh[TPM_IPV6_NH_HH_IDX].nh == TPM_IPV6_NH_HH)
+		printk(KERN_INFO "\tHOP by HOP Header\n");
+	if (ip6_nh[TPM_IPV6_NH_DH_IDX].nh == TPM_IPV6_NH_DH)
+		printk(KERN_INFO "\tDestination Header\n");
+	if (ip6_nh[TPM_IPV6_NH_RH_IDX].nh == TPM_IPV6_NH_RH)
+		printk(KERN_INFO "\tRoute Header\n");
+	if (ip6_nh[TPM_IPV6_NH_FH_IDX].nh == TPM_IPV6_NH_FH)
+		printk(KERN_INFO "\tFragment Header\n");
+	if (ip6_nh[TPM_IPV6_NH_EH_IDX].nh == TPM_IPV6_NH_EH)
+		printk(KERN_INFO "\tESP Header\n");
+	if (ip6_nh[TPM_IPV6_NH_AH_IDX].nh == TPM_IPV6_NH_AH)
+		printk(KERN_INFO "\tAuth Header\n");
+
+	return;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+int sys_help_tpm_parser_cmd(char *buf)
+{
+	int off = 0;
+
+	/* IPV6 Special Next header */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [ipv6_nh]  > ipv6_spec_nh_add -  add IPV6 next header need special treat to TPM DB\n");
+	off += sprintf(buf+off, "echo [ipv6_nh]  > ipv6_spec_nh_del -  delete IPV6 next header from TPM DB special treat list\n");
+	off += sprintf(buf+off, "\tipv6_nh        (dec)IPV6 next header value\n");
+	off += sprintf(buf+off, "\t       00       Hop by hop header\n");
+	off += sprintf(buf+off, "\t       43       Routing header\n");
+	off += sprintf(buf+off, "\t       44       Fragment header\n");
+	off += sprintf(buf+off, "\t       51       Authentication header\n");
+	off += sprintf(buf+off, "\t       52       ESP header\n");
+	off += sprintf(buf+off, "\t       60       Destination header\n");
+
+	off += sprintf(buf+off, "\n");
+
+	/* Unexpected pky lu_id gen */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [unexp_en]  > unexp_luid_gen -  add/del parser rule to generate unexpected lookup ID\n");
+	off += sprintf(buf+off, "\tunexp_en        (dec)1: add lu_id rule; 0: delete lu_id rule\n");
+
+	off += sprintf(buf+off, "\n");
+	/* xxx info dump */
+	off += sprintf(buf+off, "cat luid_info_dump    -  dump all lookup ID information from DB\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat ipv6_spec_nh_dump -  dump IPV6 NH need special treat from DB\n");
+	off += sprintf(buf+off, "\n");
+#ifdef CONFIG_MV_ETH_PP2_1
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "cat prs_hit_dump      -  dump parser hit rules (only for ALP A0 version)\n");
+	off += sprintf(buf+off, "\n");
+#endif
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* sfs_tpm_cfg_unexp_luid_gen
+*
+* DESCRIPTION:
+*           This function will add/del parser rule to generate lookup ID.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void sfs_tpm_cfg_unexp_luid_gen(const char *buf, size_t len)
+{
+	enum unexp_pkt_para_idx {
+		unexp_pkt_op = 0,
+		unexp_pkt_max
+	};
+	int unexp_en;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != unexp_pkt_max)
+		parm_error_completion(numparms, unexp_pkt_max, buf, sys_help_tpm_parser_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &unexp_en);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_prs_unexp_lu_id_op(unexp_en))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_ipv6_spec_nh_add
+*
+* DESCRIPTION:
+*           This function add IPV6 special next header.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void sfs_tpm_cfg_ipv6_spec_nh_add(const char *buf, size_t len)
+{
+	enum ipv6_spec_para_idx {
+		ipv6_spec_nh = 0,
+		ipv6_spec_max
+	};
+	unsigned int ipv6_nh_value;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv6_spec_max)
+		parm_error_completion(numparms, ipv6_spec_max, buf, sys_help_tpm_parser_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &ipv6_nh_value);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_init_spec_ipv6nh_add((unsigned char)ipv6_nh_value))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_cfg_ipv6_spec_nh_del
+*
+* DESCRIPTION:
+*           This function del IPV6 next header from special treat list.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void sfs_tpm_cfg_ipv6_spec_nh_del(const char *buf, size_t len)
+{
+	enum ipv6_spec_para_idx {
+		ipv6_spec_nh = 0,
+		ipv6_spec_max
+	};
+	unsigned int ipv6_nh_value;
+	int parsedargs;
+	int numparms;
+
+	numparms = count_parameters(buf);
+	if (numparms != ipv6_spec_max)
+		parm_error_completion(numparms, ipv6_spec_max, buf, sys_help_tpm_parser_cmd);
+	else {
+		/* Get parameters */
+		parsedargs = sscanf(buf, "%d", &ipv6_nh_value);
+		if (parsedargs != numparms)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
+		else {
+			if (!tpm_init_spec_ipv6nh_del((unsigned char)ipv6_nh_value))
+				printk(KERN_INFO "OK\n");
+			else
+				printk(KERN_INFO "FAIL\n");
+
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* sfs_tpm_luid_info_dump
+*
+* DESCRIPTION:
+*           This function dump the information about classifier lookup ID.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+int sfs_tpm_luid_info_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_prs_luid_info_dump();
+
+	return off;
+}
+
+/*******************************************************************************
+* sfs_tpm_ipv6_spec_nh_dump
+*
+* DESCRIPTION:
+*           This function dump the IPV6 next header need special treat.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+int sfs_tpm_ipv6_spec_nh_dump(char *buf)
+{
+	int off = 0;
+
+	tpm_prs_ipv6_spec_nh_dump();
+
+	return off;
+}
+
+#ifdef CONFIG_MV_ETH_PP2_1
+/*******************************************************************************
+* sfs_tpm_prs_hit_dump
+*
+* DESCRIPTION:
+*           This function dump the parser rule hit in lookup process. Only valid
+*           in ALP A0 version.
+* INPUTS:
+*       buf     - Shell parameters as char buffer
+*******************************************************************************/
+int sfs_tpm_prs_hit_dump(char *buf)
+{
+	int off = 0;
+
+	mvPp2V1PrsHwHitsDump();
+
+	return off;
+}
+
+#endif
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"ipv6_spec_nh_add",		sfs_tpm_cfg_ipv6_spec_nh_add},
+	{"ipv6_spec_nh_del",		sfs_tpm_cfg_ipv6_spec_nh_del},
+	{"unexp_luid_gen",		sfs_tpm_cfg_unexp_luid_gen},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help",			sys_help_tpm_parser_cmd},
+	{"luid_info_dump",		sfs_tpm_luid_info_dump},
+	{"ipv6_spec_nh_dump",		sfs_tpm_ipv6_spec_nh_dump},
+#ifdef CONFIG_MV_ETH_PP2_1
+	{"prs_hit_dump",		sfs_tpm_prs_hit_dump},
+#endif
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help,		S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/* Store Attr */
+static DEVICE_ATTR(unexp_luid_gen,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_spec_nh_add,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_spec_nh_del,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/* Show Attr */
+static DEVICE_ATTR(luid_info_dump,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ipv6_spec_nh_dump,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+#ifdef CONFIG_MV_ETH_PP2_1
+static DEVICE_ATTR(prs_hit_dump,	S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+#endif
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_prs_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_ipv6_spec_nh_add.attr,
+	&dev_attr_ipv6_spec_nh_del.attr,
+	&dev_attr_unexp_luid_gen.attr,
+	&dev_attr_luid_info_dump.attr,
+	&dev_attr_ipv6_spec_nh_dump.attr,
+#ifdef CONFIG_MV_ETH_PP2_1
+	&dev_attr_prs_hit_dump.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group g_tpm_prs_sw_group = {
+	.name = "prs",
+	.attrs = g_tpm_prs_sw_attrs
+};
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_prs_init
+*
+* DESCRIPTION: The routine will initialize TPM prs sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_prs_init(void)
+{
+	int rc;
+
+	/* Initialize prs sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_prs_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_switch.c
new file mode 100644
index 0000000..2898e00
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_switch.c
@@ -0,0 +1,5506 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/******************************************************************************
+**  FILE: tpm_sysfs_switch.c						     **
+**									     **
+**  DESCRIPTION: This file implements TPM sysfs command and ioctl	     **
+**  DEPENDCY: TPM related APIs from submodule				     **
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+/*
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+extern struct semaphore			tpm_sfs_2_ioctl_sem;
+extern struct tpm_ioctl_mng_t		tpm_sfs_2_ioctl_command;
+#endif
+*/
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS HELP                                            */
+/* ========================================================================== */
+int tpm_sys_sw_help_phy(char *buf)
+{
+	int off = 0;
+
+	/* TPM switch PHY API */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [port] [enable]                > admin_state_set   -  set port admin state\n");
+	off += sprintf(buf+off, "echo [port]                         > admin_state_get   -  get port admin state\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | enable(dec): 0:disable, 1:enable\n\n");
+	off += sprintf(buf+off, "echo [port] [enable] [interval]     > flow_control_set  -  set flow control\n");
+	off += sprintf(buf+off, "echo [port]                         > flow_control_get  -  get flow control\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | enable(dec): 0:disable, 1:enable | interval(dec): pause frame interval in unit of second\n\n");
+	off += sprintf(buf+off, "echo [port] [en] [speed] [duplex]   > link_mode_set     -  set switch port link mode\n");
+	off += sprintf(buf+off, "echo [port]                         > link_mode_get     -  get switch port link mode\n");
+	off += sprintf(buf+off, "echo [port]                         > link_state_get    -  get switch port dynamic link state\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | en(dec): config auto-negotiation, 0:disable, 1:enable | speed(dec): speed mode, 0:10M, 1:100M, 2:1000M, 3:auto\n");
+	off += sprintf(buf+off, "\tduplex(dec): duplex mode, 0:half duplex, 1:full duplex, 2:auto\n");
+	off += sprintf(buf+off, "\tnote:speed and duplex auto mode is only valid when auto-negotiation is enabled\n\n");
+	off += sprintf(buf+off, "echo [port] [dir] [enable]          > loopback_set      -  set port loopback\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | dir(dec): 0:ingress, 1:egress, 2:both of dir | enable(dec): 0:disable, 1:enable\n\n");
+	off += sprintf(buf+off, "echo [port] [dir]                   > loopback_get      -  get port loopback\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | dir(dec): 0:ingress, 1:egress (both NOT support)\n\n");
+	return off;
+}
+
+int tpm_sys_sw_help_mac(char *buf)
+{
+	int off = 0;
+
+	/* TPM switch MAC API */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [time]                         > mac_age_set         -  set MAC aging time\n");
+	off += sprintf(buf+off, "echo 1                              > mac_age_get         -  get MAC aging time\n");
+	off += sprintf(buf+off, "\ttime(dec): MAC aging time in unit of second\n\n");
+	off += sprintf(buf+off, "echo [port] [enable] [limit]        > mac_num_set         -  set max MAC address number could be learned\n");
+	off += sprintf(buf+off, "echo [port]                         > mac_num_get         -  get max MAC address number could be learned\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | enable(dec): 0:disable, 1:enable | limit(dec): mac MAC address number\n\n");
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [port_bm] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1] [vlan] [mode]  > mac_addr_add   -  add MAC address to ATU\n");
+	off += sprintf(buf+off, "echo [port] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1] [vlan]            > mac_addr_del   -  delete MAC address from ATU\n");
+	off += sprintf(buf+off, "\tport_bm(hex): switch port bitmap | mac[x](hex): byte x of MAC addr | vlan(dec): VLAN ID | mode(dec): 0:dynamic MAC, 1: static MAC\n\n");
+	off += sprintf(buf+off, "echo 1                              > mac_addr_clear      -  clear all MAC address\n");
+	off += sprintf(buf+off, "echo [port] [mode]                  > mac_table_clear     -  clear MAC address according to port and mode\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | mode(dec): 0:dynamic MAC, 1: static MAC, 2:unicast MAC, 3:multicast MAC, 4:all MAC address\n\n");
+	off += sprintf(buf+off, "echo [port] [mode]                  > mac_filter_mode_set -  set switch port MAC filter mode\n");
+	off += sprintf(buf+off, "echo [port]                         > mac_filter_mode_get -  get switch port MAC filter mode\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | mode(dec): 0:no filter, 1: black list on DMAC, 2:white list on DMAC, 3:black list on SMAC, 4:white list on SMAC\n\n");
+	off += sprintf(buf+off, "echo [port] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1] [vlan] [mode]    > mac_filter_entry_add -  add MAC filter entry\n");
+	off += sprintf(buf+off, "echo [port] mac[6] mac[5] mac[4] mac[3] mac[2] mac[1] [vlan] [mode]    > mac_filter_entry_del -  delete MAC filter entry\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | mac[x](hex): byte x of MAC addr | vlan(dec): VLAN ID\n");
+	off += sprintf(buf+off, "\tmode(dec): 0:no filter, 1: black list on DMAC, 2:white list on DMAC, 3:black list on SMAC, 4:white list on SMAC\n\n");
+	off += sprintf(buf+off, "echo [mtu]                          > mtu_set             -  set switch MTU\n");
+	off += sprintf(buf+off, "echo 1                              > mtu_get             -  get switch MTU\n");
+	off += sprintf(buf+off, "\tmtu(dec): MTU size, support three jumbo modes: 1522, 2048, 10240\n\n");
+	off += sprintf(buf+off, "echo [port] [dir] [en] [mode] [rate]> rate_limit_set      -  set rate limit for all data traffic\n");
+	off += sprintf(buf+off, "echo [port] [dir]                   > rate_limit_get      -  get rate limit of all data traffic\n");
+	off += sprintf(buf+off, "echo [port] [dir] [en] [mode] [rate]> mc_proto_rate_set   -  set rate limit for multicast protocol packets\n");
+	off += sprintf(buf+off, "echo [port] [dir]                   > mc_proto_rate_get   -  get rate limit of multicast protocol packets\n");
+	off += sprintf(buf+off, "echo [port] [dir] [en] [mode] [rate]> mc_data_rate_set    -  set rate limit for multicast data traffic packets\n");
+	off += sprintf(buf+off, "echo [port] [dir]                   > mc_data_rate_get    -  get rate limit of for multicast data traffic packets\n");
+	off += sprintf(buf+off, "echo [port] [dir] [en] [mode] [rate]> bc_rate_set         -  set rate limit for broadcast packets\n");
+	off += sprintf(buf+off, "echo [port] [dir]                   > bc_rate_get         -  get rate limit for broadcast packets\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | dir(dec): 0:ingress, 1:egress, 2:both of dir | en(dec): 0:disable, 1:enable | mode(dec): 0:frame, 1:layer 1, 2:layer 2, 3:layer 3\n");
+	off += sprintf(buf+off, "\trate(dec): rate in unit of Kbps or frames\n\n");
+
+	return off;
+}
+
+int tpm_sys_sw_help_gen(char *buf)
+{
+	int off = 0;
+
+	/* TPM switch generic API */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [port] [mode]                  > ingress_mode_set  -  set port VLAN ingress mode\n");
+	off += sprintf(buf+off, "echo [port]                         > ingress_mode_get  -  get port VLAN ingress mode\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | mode(dec): 0:as-is, 1:discard all, 2:discard untagged, 3:discard tagged\n\n");
+	off += sprintf(buf+off, "echo [port] [vid] [pbits]           > pvid_set          -  set port default VLAN ID and P-bits\n");
+	off += sprintf(buf+off, "echo [port]                         > pvid_get          -  get port default VLAN ID and P-bits\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | vid(dec): VLAN ID | pbits(dec): P-bits\n\n");
+	off += sprintf(buf+off, "echo [port] [min] [max] [mode]      > vlan_set          -  set a group of VLAN to port\n");
+	off += sprintf(buf+off, "echo [port] [min] [max]             > vlan_del          -  delete a group of port VLAN\n");
+	off += sprintf(buf+off, "echo [vlan]                         > vlan_get          -  get port VLAN information\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | min(dec): MIN VLAN | max(dec): MAX VLAN | mode(dec): 0:as-is, 1:not in VLAN, 2:strip VLAN, 3:keep VLAN\n\n");
+	off += sprintf(buf+off, "echo [port] [enable]                > vlan_filter_set   -  set port VLAN filter\n");
+	off += sprintf(buf+off, "echo [port]                         > vlan_filter_get   -  get port VLAN filter\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | enable(dec): 0:disable, 1:enable\n\n");
+	off += sprintf(buf+off, "echo [port] [port_mask]             > isolate_mask_set  -  set isolate mask\n");
+	off += sprintf(buf+off, "echo [port]                         > isolate_mask_get  -  get isolate mask\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | port_mask(hex): destination port bitmap for isolation, 0: not isolate, 1:isolate\n\n");
+	off += sprintf(buf+off, "echo [port] [pkt_type] [port_mask]  > flood_mask_set    -  set flooding control for specific packets and destination ports\n");
+	off += sprintf(buf+off, "echo [port] [pkt_type]              > flood_mask_get    -  get flooding control for specific packets and destination ports\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | pkt_type(dec): packet type to be flooded, 0:Unknown DA unicast, 1:Unknown SA unicast, 2:Unknown IPv4 multicast,\n");
+	off += sprintf(buf+off, "\t3:broadcast, 4:SA belong ot other port, 5:Unknown IPv6 multicast | port_mask(hex): port bitmap for flooding control, 1: flood, 0: dont flood\n");
+	off += sprintf(buf+off, "\tNote: need to clear ATU address if want to disable flooding\n\n");
+	off += sprintf(buf+off, "echo 1                              > sw_count_clear    -  clear the counters of all switch ports\n\n");
+	off += sprintf(buf+off, "echo [port]                         > port_count_clear  -  clear the counters of specific port\n");
+	off += sprintf(buf+off, "\tport(dec): switch port\n\n");
+	off += sprintf(buf+off, "echo [sport] [dir] [en] [dport]     > port_mirror_set   -  set port mirror\n");
+	off += sprintf(buf+off, "echo [sport] [dir]                  > port_mirror_get   -  get port mirror\n");
+	off += sprintf(buf+off, "\tsport(dec): source switch port | dir(dec): 0:ingress, 1:egress, 2:both of dir | enable(dec): 0:disable,1:enable | dport(dec): destination port\n\n");
+	off += sprintf(buf+off, "echo [port] [queue] [mode] [weight] > port_qos_set      -  set switch port QoS\n");
+	off += sprintf(buf+off, "echo [port] [queue]                 > port_qos_get      -  get switch port QoS\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | queue(dec): switch queue | mode(dec): 0:SP, 1:WRR, 2:both | weight(dec): weight for WRR, ranging from 0 to 3\n\n");
+	off += sprintf(buf+off, "echo [port] [reset]                 > stat1_get         -  get stat1 counters\n");
+	off += sprintf(buf+off, "echo [port] [reset]                 > stat2_get         -  get stat2 counters\n");
+	off += sprintf(buf+off, "echo [port] [reset]                 > stat3_get         -  get stat3 counters\n");
+	off += sprintf(buf+off, "echo [port] [reset]                 > stat_all_get      -  get stat all counters\n");
+	off += sprintf(buf+off, "\tport(dec): switch port | reset(dec): reset counters, 0: do not reset, 1: reset\n");
+	return off;
+}
+
+int tpm_sys_sw_help_debug(char *buf)
+{
+	int off = 0;
+
+	/* TPM switch debug API */
+	off += sprintf(buf+off, "\n");
+	off += sprintf(buf+off, "echo [mode]                         > head_mode_set     -  set head mode of switch uplink port\n");
+	off += sprintf(buf+off, "echo 1                              > head_mode_get     -  get head mode of switch uplink port\n");
+	off += sprintf(buf+off, "\tmode(dec): 0:No header, 1:Marvell header, 2:Eth type DSA, 3:DSA, 4:Ext DSA\n\n");
+	off += sprintf(buf+off, "echo [mode]                         > atu_dump          -  dump ATU entries according to MAC address mode\n");
+	off += sprintf(buf+off, "\tmode(dec): 0:dynamic MAC addr, 1:static MAC addr, 2:unicast MAC addr, 3:multicast MAC addr, 4:all MAC addr\n\n");
+	off += sprintf(buf+off, "echo [vid]                          > vtu_dump          -  dump VTU entry according to VLAN ID\n");
+	off += sprintf(buf+off, "\tvid(dec): VLAN ID\n\n");
+	off += sprintf(buf+off, "echo 1                              > vtu_shadow_dump   -  dump all VTU software shadow entires\n\n");
+
+	return off;
+}
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS bounce API                                             */
+/* ========================================================================== */
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_set_bounce(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t *tpm_ioctl_switch = &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_INGRESS_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->ingress_mode		= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_ingress_mode_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get the VLAN ingress mode of specific switch port
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	mode - VLAN ingress mode
+*		TPM_SW_INGRESS_ASIS:          do not discard any ingress packets
+*		TPM_SW_INGRESS_DISCARD_ALL:   discard all ingress packets
+*		TPM_SW_INGRESS_DISCARD_UNTAG: discard all ingress untag packets
+*		TPM_SW_INGRESS_DISCARD_TAG:   discard all ingress tagged packets
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_ingress_mode_get_bounce(enum tpm_sw_port_t		port,
+				    enum tpm_sw_ingress_mode_t	*mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_INGRESS_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_set_bounce(enum tpm_sw_port_t	port,
+		       unsigned short		vid,
+		       unsigned char		pri)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PBIT_VID_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->pvid.vid		= vid;
+	tpm_ioctl_switch->pvid.pri		= pri;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_pvid_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port VLAN and P-bits
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	vid  - VLAN ID
+*	pri  - P-bits
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_pvid_get_bounce(enum tpm_sw_port_t	port,
+		       unsigned short		*vid,
+		       unsigned char		*pri)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PBIT_VID_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to add a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*	mode      - VLAN egress mode
+*			TPM_SW_VLAN_EGRESS_ASIS:        AS-IS
+*			TPM_SW_VLAN_EGRESS_NOT_IN_VLAN: not in this vlan
+*			TPM_SW_VLAN_EGRESS_STRIP_VLAN:  egress and strip vlan tag
+*			TPM_SW_VLAN_EGRESS_KEEP_VLAN:   egress and do not strip vlan tag
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_set_bounce(enum tpm_sw_port_t		port,
+		       unsigned short			min_vlan,
+		       unsigned short			max_vlan,
+		       enum tpm_sw_vlan_egress_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= TPM_IOCTL_SWITCH_VLAN_SET;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_INGRESS_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->vlan_grp.min_vlan	= min_vlan;
+	tpm_ioctl_switch->vlan_grp.max_vlan	= max_vlan;
+	tpm_ioctl_switch->vlan_grp.mode		= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_del_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to delete a group of VLAN
+*
+* INPUTS:
+*	port      - switch port
+*	min_vlan  - Minimum VLAN ID
+*	max_vlan  - Maximum VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_del_bounce(enum tpm_sw_port_t	port,
+		       unsigned short		min_vlan,
+		       unsigned short		max_vlan)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_DEL;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->vlan_grp.min_vlan	= min_vlan;
+	tpm_ioctl_switch->vlan_grp.max_vlan	= max_vlan;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get VLAN information for specific switch port
+*
+* INPUTS:
+*	vlan    - VLAN ID value
+*
+* OUTPUTS:
+*	fwd_bm  - Bitmap of egress forwarding mode
+*		  0:do not forward, 1:forward
+*		  bit0:port 0, bit1:port 1 ...
+*	tag_bm  - Bitmap of egress VLAN tag mode
+*		  0:egress untagged, 1:egress tagged
+*		  bit0:port 0, bit1:port 1 ...
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_vlan_get_bounce(unsigned short		vlan,
+		       unsigned int		*fwd_bm,
+		       unsigned int		*tag_bm)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_GET;
+	tpm_ioctl_switch->vlan_grp.vlan		= vlan;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_set_bounce
+*
+* DESCRIPTION:
+*	The API sets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*       enable - enable or disable filter mode.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_set_bounce(enum tpm_sw_port_t port, enum tpm_sw_config_state_t enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_FILTER_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->vlan_filter_mode	= enable;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_vlan_filter_get_bounce
+*
+* DESCRIPTION:
+*	The API gets the filtering mode of a certain port.
+*	If the port is in filtering mode, only the VIDs added by the
+*	tpm_sw_port_vid_add API will be allowed to ingress and egress the port.
+*
+* INPUTS:
+*	port   - switch port ID.
+*
+* OUTPUTS:
+*       enable - enable or disable filter mode.
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*******************************************************************************/
+int mv_tpm_sw_vlan_filter_get_bounce(enum tpm_sw_port_t port, enum tpm_sw_config_state_t *enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_VLAN_FILTER_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to enable or disable switch port
+*
+* INPUTS:
+*	port   - switch port
+*	enable - enable or disable switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_set_bounce(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STATE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->port_enable		= enable;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_enable_state_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port PHY state
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	enable - enabled or disabled of switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_enable_state_get_bounce(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to configure switch port flow control
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable flow control
+*	interval  - interval time of pause frame
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_set_bounce(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	enable,
+			       unsigned int			interval)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd				= TPM_IOCTL_SWITCH_FLOW_CTL_SET;
+	tpm_ioctl_switch->switch_port			= port;
+	tpm_ioctl_switch->flow_ctl.enable		= enable;
+	tpm_ioctl_switch->flow_ctl.pause_interval	= interval;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flow_control_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port flow control configuration
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enabled or disabled of flow control
+*	interval  - interval time of pause frame
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support pause interval setting
+*******************************************************************************/
+int mv_tpm_sw_flow_control_get_bounce(enum tpm_sw_port_t		port,
+			       enum tpm_sw_config_state_t	*enable,
+			       unsigned int			*interval)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FLOW_CTL_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch port isolation to other switch ports
+*
+* INPUTS:
+*	port        - switch port
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_set_bounce(enum tpm_sw_port_t	port,
+			       unsigned int		port_mask)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_ISOLATE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->port_isolate_mask	= port_mask;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_isolate_mask_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port isolation to other switch ports
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	port_mask - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_isolate_mask_get_bounce(enum tpm_sw_port_t	port,
+			       unsigned int		*port_mask)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_ISOLATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch port flood control configuration
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*			bit0:port 0, bit1:port 1 ...
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_set_bounce(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			port_mask)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FLOOD_CTL_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->flood_ctl.pkt_type	= pkt_type;
+	tpm_ioctl_switch->flood_ctl.port_mask	= port_mask;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_flood_control_mask_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get flood control information
+*
+* INPUTS:
+*	port        - switch port
+*	pkt_type    - packet type
+*		TPM_SW_FLOOD_PKT_UNKOWN_DA_UNICAST:     unknown DA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_SA_UNICAST:     unknown SA unicast
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV4_MULTICAST: unknown IPv4 multicast
+*		TPM_SW_FLOOD_PKT_BROADCAST:             broadcast
+*		TPM_SW_FLOOD_PKT_OTHER_PORT_SA:         SA used to belong to other port
+*		TPM_SW_FLOOD_PKT_UNKOWN_IPV6_MULTICAST: unknown IPv6 multicast
+*
+* OUTPUTS:
+*	port_mask   - bitmap mask of dedicated switch port
+*			0: do not block
+*			1: block
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support per port flood control, just enable it if port_mask is non-zero.
+*******************************************************************************/
+int mv_tpm_sw_flood_control_mask_get_bounce(enum tpm_sw_port_t			port,
+				     enum tpm_sw_flood_packet_type_t	pkt_type,
+				     unsigned int			*port_mask)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FLOOD_CTL_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->flood_ctl.pkt_type	= pkt_type;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_all_count_clear_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to clear the counters of all switch ports
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_all_count_clear_bounce(void)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_ONU_CNT_CLEAR;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_port_count_clear_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to clear the counters of dedicated switch ports
+*
+* INPUTS:
+*	port - switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_port_count_clear_bounce(enum tpm_sw_port_t port)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_CNT_CLEAR;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_set_bounce(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	auto_en,
+			    enum tpm_sw_speed_mode_t	speed,
+			    enum tpm_sw_duplex_mode_t	duplex)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_LINK_MODE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->link_mode.auto_en	= auto_en;
+	tpm_ioctl_switch->link_mode.speed	= speed;
+	tpm_ioctl_switch->link_mode.duplex	= duplex;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_mode_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port link mode, including auto negotiation,
+*	speed and dumplex mode.
+*
+* INPUTS:
+*	port       - switch port
+*
+* OUTPUTS:
+*	auto_en    - enable or disable auto negotiation
+*	speed      - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*			TPM_SW_SPEED_MODE_AUTO:  auto
+*	duplex     - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*			TPM_SW_DUPLEX_MODE_AUTO: auto
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_mode_get_bounce(enum tpm_sw_port_t		port,
+			    enum tpm_sw_config_state_t	*auto_en,
+			    enum tpm_sw_speed_mode_t	*speed,
+			    enum tpm_sw_duplex_mode_t	*duplex)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_LINK_MODE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_link_state_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch port dynamic link state, including
+*	whether link up, speed and dumplex mode.
+*
+* INPUTS:
+*	port    - switch port
+*
+* OUTPUTS:
+*	link    - link up or down state
+*			TPM_SW_PORT_STATE_DOWN:  link down
+*			TPM_SW_PORT_STATE_UP:    link up
+*	speed   - switch port speed
+*			TPM_SW_SPEED_MODE_10M:   10Mbps
+*			TPM_SW_SPEED_MODE_100M:  100Mbps
+*			TPM_SW_SPEED_MODE_1000M: 1000Mbps
+*	duplex  - duplex mode
+*			TPM_SW_DUPLEX_MODE_HALF: half duplex
+*			TPM_SW_DUPLEX_MODE_FULL: full duplex
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_link_state_get_bounce(enum tpm_sw_port_t		port,
+			     enum tpm_sw_port_state_t	*link,
+			     enum tpm_sw_speed_mode_t	*speed,
+			     enum tpm_sw_duplex_mode_t	*duplex)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_LINK_STATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_set_bounce(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		enable,
+			     enum tpm_sw_rate_limit_mode_t	mode,
+			     unsigned int			rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_RATE_LIMIT_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+	tpm_ioctl_switch->rate_cfg.enable	= enable;
+	tpm_ioctl_switch->rate_cfg.mode		= mode;
+	tpm_ioctl_switch->rate_cfg.rate		= rate;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_rate_limit_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get rate limit configuration for all data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_rate_limit_get_bounce(enum tpm_sw_port_t			port,
+			     enum tpm_sw_port_dir_t		dir,
+			     enum tpm_sw_config_state_t		*enable,
+			     enum tpm_sw_rate_limit_mode_t	*mode,
+			     unsigned int			*rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_RATE_LIMIT_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_set_bounce(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	enable,
+				enum tpm_sw_rate_limit_mode_t	mode,
+				unsigned int			rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MC_PROTO_RATE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+	tpm_ioctl_switch->rate_cfg.enable	= enable;
+	tpm_ioctl_switch->rate_cfg.mode		= dir;
+	tpm_ioctl_switch->rate_cfg.rate		= rate;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_proto_rate_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get rate limit configuration for multicast protocol packets
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast protocol packets currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_proto_rate_get_bounce(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MC_PROTO_RATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_set_bounce(enum tpm_sw_port_t		port,
+			       enum tpm_sw_port_dir_t		dir,
+			       enum tpm_sw_config_state_t	enable,
+			       enum tpm_sw_rate_limit_mode_t	mode,
+			       unsigned int			rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MC_DATA_RATE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+	tpm_ioctl_switch->rate_cfg.enable	= enable;
+	tpm_ioctl_switch->rate_cfg.mode		= dir;
+	tpm_ioctl_switch->rate_cfg.rate		= rate;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mc_data_rate_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get rate limit configuration for multicast data traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for multicast data traffic currently.
+*******************************************************************************/
+int mv_tpm_sw_mc_data_rate_get_bounce(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MC_DATA_RATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_set_bounce(enum tpm_sw_port_t		port,
+				 enum tpm_sw_port_dir_t		dir,
+				 enum tpm_sw_config_state_t	enable,
+				 enum tpm_sw_rate_limit_mode_t	mode,
+				 unsigned int			rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_BC_RATE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+	tpm_ioctl_switch->rate_cfg.enable	= enable;
+	tpm_ioctl_switch->rate_cfg.mode		= dir;
+	tpm_ioctl_switch->rate_cfg.rate		= rate;
+
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_broadcast_rate_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get rate limit configuration for broadcast traffic
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable rate limit
+*	mode      - rate limit mode
+*			TPM_SW_RATE_LIMIT_FRAME:  count on frame
+*			TPM_SW_RATE_LIMIT_LAYER1: count on layer 1
+*			TPM_SW_RATE_LIMIT_LAYER2: count on layer 2
+*			TPM_SW_RATE_LIMIT_LAYER3: count on layer 3
+*	rate      - rate limit rate in unit of kbps or frames depending on mode
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	Do not support rate limit for broadcast packets currently.
+*******************************************************************************/
+int mv_tpm_sw_broadcast_rate_get_bounce(enum tpm_sw_port_t		port,
+				enum tpm_sw_port_dir_t		dir,
+				enum tpm_sw_config_state_t	*enable,
+				enum tpm_sw_rate_limit_mode_t	*mode,
+				unsigned int			*rate)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_BC_RATE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->rate_cfg.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set port mirror
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_set_bounce(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	enable,
+			 enum tpm_sw_port_t		dport)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MIRROR_SET;
+	tpm_ioctl_switch->switch_port		= sport;
+	tpm_ioctl_switch->mirror.dir		= dir;
+	tpm_ioctl_switch->mirror.enable		= enable;
+	tpm_ioctl_switch->mirror.dport		= dport;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mirror_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get port mirror configuration
+*
+* INPUTS:
+*	sport     - source switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port mirror
+*	dport     - destination switch port
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mirror_get_bounce(enum tpm_sw_port_t		sport,
+			 enum tpm_sw_port_dir_t		dir,
+			 enum tpm_sw_config_state_t	*enable,
+			 enum tpm_sw_port_t		*dport)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MIRROR_GET;
+	tpm_ioctl_switch->switch_port		= sport;
+	tpm_ioctl_switch->mirror.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*			TPM_SW_PORT_DIR_BOTH:    both of ingress and egress direction
+*	enable    - enable or disable port loopback
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_set_bounce(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_LPK_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->loopback.dir		= dir;
+	tpm_ioctl_switch->loopback.enable	= enable;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_loopback_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get port loopback
+*
+* INPUTS:
+*	port      - switch port
+*	dir       - direction
+*			TPM_SW_PORT_DIR_INGRESS: ingress direction
+*			TPM_SW_PORT_DIR_EGRESS:  egress direction
+*
+* OUTPUTS:
+*	enable    - enable or disable port loopback
+
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_loopback_get_bounce(enum tpm_sw_port_t		port,
+			   enum tpm_sw_port_dir_t	dir,
+			   enum tpm_sw_config_state_t	*enable)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_LPK_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->loopback.dir		= dir;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch aging time
+*
+* INPUTS:
+*	time  - switch aging time in unit of second
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_set_bounce(unsigned int time)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_AGING_SET;
+	tpm_ioctl_switch->age_time		= time;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_aging_time_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get switch aging time
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	time  - switch aging time in unit of second
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_aging_time_get_bounce(unsigned int *time)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_AGING_GET;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_set_bounce(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	enable,
+				  unsigned int			limit)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd				= TPM_IOCTL_SWITCH_MAC_LIMIT_SET;
+	tpm_ioctl_switch->switch_port			= port;
+	tpm_ioctl_switch->mac_learn_limit.enable	= enable;
+	tpm_ioctl_switch->mac_learn_limit.limit		= limit;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_learn_limit_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get the maximum MAC learn number
+*
+* INPUTS:
+*	port      - switch port
+*
+* OUTPUTS:
+*	enable    - enable or disable MAC learn limit
+*	limit     - maximum MAC number could be learded
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_learn_limit_get_bounce(enum tpm_sw_port_t		port,
+				  enum tpm_sw_config_state_t	*enable,
+				  unsigned int			*limit)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd			= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd				= TPM_IOCTL_SWITCH_MAC_LIMIT_GET;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_add_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to add MAC address
+*
+* INPUTS:
+*	port_bm - switch port bitmap
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - enable or disable port mirror
+*		TPM_SW_MAC_ADDR_DYNAMIC: dynamic MAC address
+*		TPM_SW_MAC_ADDR_STATIC:  static MAC address
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_add_bounce(unsigned char			port_bm,
+			      unsigned char			*mac,
+			      unsigned short			vlan,
+			      enum tpm_sw_mac_addr_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MAC_ADDR_ADD;
+	tpm_ioctl_switch->mac_addr_op.port_bm	= port_bm;
+	if (NULL != mac)
+		memcpy(&(tpm_ioctl_switch->mac_addr_op.mac), (void *)mac, sizeof(tpm_ioctl_switch->mac_addr_op.mac));
+
+	tpm_ioctl_switch->mac_addr_op.vlan	= vlan;
+	tpm_ioctl_switch->mac_addr_op.mode	= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_del_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to delete MAC address
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_del_bounce(unsigned char	port,
+			      unsigned char	*mac,
+			      unsigned short	vlan)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MAC_ADDR_DEL;
+	tpm_ioctl_switch->switch_port		= port;
+	if (NULL != mac)
+		memcpy(&(tpm_ioctl_switch->mac_addr_op.mac), (void *)mac, sizeof(tpm_ioctl_switch->mac_addr_op.mac));
+
+	tpm_ioctl_switch->mac_addr_op.vlan	= vlan;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_set_bounce(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FILTER_MODE_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->filter_mode		= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_mode_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get MAC filter mode
+*
+* INPUTS:
+*	port   - switch port
+*
+* OUTPUTS:
+*	mode   - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_mode_get_bounce(enum tpm_sw_port_t		port,
+				  enum tpm_sw_mac_filter_mode_t	*mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FILTER_MODE_GET;
+	tpm_ioctl_switch->switch_port		= port;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_add
+*
+* DESCRIPTION: The routine passes parameters to user space to add MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_add_bounce(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FILTER_ENTRY_ADD;
+	tpm_ioctl_switch->switch_port		= port;
+	if (NULL != mac)
+		memcpy(&(tpm_ioctl_switch->mac_addr_op.mac), (void *)mac, sizeof(tpm_ioctl_switch->mac_addr_op.mac));
+
+	tpm_ioctl_switch->mac_addr_op.vlan	= vlan;
+	tpm_ioctl_switch->mac_addr_op.mode	= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_filter_entry_del
+*
+* DESCRIPTION: The routine passes parameters to user space to delete MAC address filter entry
+*
+* INPUTS:
+*	port    - switch port
+*	mac     - MAC address
+*	vlan    - VLAN ID
+*	mode    - MAC filter mode
+*		TPM_SW_MAC_NO_FILTER:         no filter
+*		TPM_SW_MAC_BLACK_FILTER_DMAC: black list on dmac
+*		TPM_SW_MAC_WHITE_FILTER_DMAC: white list on dmac
+*		TPM_SW_MAC_BLACK_FILTER_SMAC: black list on smac
+*		TPM_SW_MAC_WHITE_FILTER_SMAC: white list on smac
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_filter_entry_del_bounce(enum tpm_sw_port_t			port,
+				   unsigned char			*mac,
+				   unsigned short			vlan,
+				   enum tpm_sw_mac_filter_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_FILTER_ENTRY_DEL;
+	tpm_ioctl_switch->switch_port		= port;
+	if (NULL != mac)
+		memcpy(&(tpm_ioctl_switch->mac_addr_op.mac), (void *)mac, sizeof(tpm_ioctl_switch->mac_addr_op.mac));
+
+	tpm_ioctl_switch->mac_addr_op.vlan	= vlan;
+	tpm_ioctl_switch->mac_addr_op.mode	= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_address_clear_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to clear all MAC addresses
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_address_clear_bounce(void)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_ONU_MAC_CLEAR;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mac_table_clear_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to clear MAC address based on port and type
+*
+* INPUTS:
+*	port   - switch port
+*	mode   - MAC clear mode
+*		TPM_SW_MAC_ADDR_DYNAMIC:   clear dynami mac
+*		TPM_SW_MAC_ADDR_STATIC:    clear static mac
+*		TPM_SW_MAC_ADDR_UNICAST:   clear unicast mac
+*		TPM_SW_MAC_ADDR_MULTICAST: clear multicast mac
+*		TPM_SW_MAC_ADDR_ALL:       clear all
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mac_table_clear_bounce(enum tpm_sw_port_t		port,
+			      enum tpm_sw_mac_addr_mode_t	mode)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_MAC_TBL_CLEAR;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->mac_clear_mode	= mode;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_qos_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_set_bounce(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	mode,
+		      unsigned char		weight)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_QOS_SET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->qos.queue		= queue;
+	tpm_ioctl_switch->qos.mode		= mode;
+	tpm_ioctl_switch->qos.weight		= weight;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_qos_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get the QoS
+*
+* INPUTS:
+*	port     - switch port
+*	queue    - switch queue
+*
+* OUTPUTS:
+*	mode     - maximum MAC number could be learded
+*		TPM_SW_QOS_MODE_SP:     SP mode
+*		TPM_SW_QOS_MODE_WRR:    WRR mode
+*		TPM_SW_QOS_MODE_SP_WRR: SP+WRR mode
+*	weight   - weight for WRR, ranging from 0 to 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_qos_get_bounce(enum tpm_sw_port_t	port,
+		      enum tpm_sw_queue_t	queue,
+		      enum tpm_sw_qos_mode_t	*mode,
+		      unsigned char		*weight)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_QOS_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->qos.queue		= queue;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch MTU
+*
+* INPUTS:
+*	mtu  - MTU of switch
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_set_bounce(unsigned int mtu)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MTU_SET;
+	tpm_ioctl_switch->mtu			= mtu;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_mtu_set_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to set switch MTU
+*
+* INPUTS:
+*	None
+*
+* OUTPUTS:
+*	mtu  - MTU of switch
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_mtu_get_bounce(unsigned int *mtu)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_MTU_GET;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat1_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get performance counter 1
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 1
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat1_get_bounce(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat1_t	*stat)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STAT1_GET;
+	tpm_ioctl_switch->count_reset		= reset;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat2_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get performance counter 2
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 2
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat2_get_bounce(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat2_t	*stat)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STAT2_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->count_reset		= reset;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat3_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get performance counter 3
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - performance counter 3
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat3_get_bounce(enum tpm_sw_port_t		port,
+			enum tpm_sw_count_reset_t	reset,
+			struct tpm_sw_port_stat3_t	*stat)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STAT3_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->count_reset		= reset;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+/*******************************************************************************
+* mv_tpm_sw_stat_all_get_bounce
+*
+* DESCRIPTION: The routine passes parameters to user space to get all switch performance counters
+*
+* INPUTS:
+*	port  - switch port
+*	reset - whether reset counters after read operation
+*		TPM_SW_COUNT_NOT_RESET: do not reset counter
+*		TPM_SW_COUNT_RESET:     reset counter
+*
+* OUTPUTS:
+*	stat  - all performance counters
+*
+* RETURNS:
+*	On success, the function returns TPM_OK. On error different types are returned
+*	according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int mv_tpm_sw_stat_all_get_bounce(enum tpm_sw_port_t			port,
+			   enum tpm_sw_count_reset_t		reset,
+			   struct tpm_sw_port_stat_all_t	*stat)
+{
+	struct tpm_ioctl_switch_oper_t	*tpm_ioctl_switch	= &tpm_sfs_2_ioctl_command.tpm_ioctl_switch;
+
+	tpm_sfs_2_ioctl_command.cmd		= MV_TPM_IOCTL_SWITCH_SECTION;
+	tpm_ioctl_switch->cmd			= TPM_IOCTL_SWITCH_PORT_STAT_ALL_GET;
+	tpm_ioctl_switch->switch_port		= port;
+	tpm_ioctl_switch->count_reset		= reset;
+
+	up(&tpm_sfs_2_ioctl_sem);
+
+	return TPM_OK;
+}
+
+#endif
+
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+#define _mv_tpm_sw_vlan_ingress_mode_set	mv_tpm_sw_vlan_ingress_mode_set_bounce
+#define _mv_tpm_sw_vlan_ingress_mode_get	mv_tpm_sw_vlan_ingress_mode_get_bounce
+#define _mv_tpm_sw_pvid_set			mv_tpm_sw_pvid_set_bounce
+#define _mv_tpm_sw_pvid_get			mv_tpm_sw_pvid_get_bounce
+#define _mv_tpm_sw_vlan_set			mv_tpm_sw_vlan_set_bounce
+#define _mv_tpm_sw_vlan_del			mv_tpm_sw_vlan_del_bounce
+#define _mv_tpm_sw_vlan_get			mv_tpm_sw_vlan_get_bounce
+#define _mv_tpm_sw_vlan_filter_set		mv_tpm_sw_vlan_filter_set_bounce
+#define _mv_tpm_sw_vlan_filter_get		mv_tpm_sw_vlan_filter_get_bounce
+#define _mv_tpm_sw_enable_state_set		mv_tpm_sw_enable_state_set_bounce
+#define _mv_tpm_sw_enable_state_get		mv_tpm_sw_enable_state_get_bounce
+#define _mv_tpm_sw_flow_control_set		mv_tpm_sw_flow_control_set_bounce
+#define _mv_tpm_sw_flow_control_get		mv_tpm_sw_flow_control_get_bounce
+#define _mv_tpm_sw_isolate_mask_set		mv_tpm_sw_isolate_mask_set_bounce
+#define _mv_tpm_sw_isolate_mask_get		mv_tpm_sw_isolate_mask_get_bounce
+#define _mv_tpm_sw_flood_control_mask_set	mv_tpm_sw_flood_control_mask_set_bounce
+#define _mv_tpm_sw_flood_control_mask_get	mv_tpm_sw_flood_control_mask_get_bounce
+#define _mv_tpm_sw_all_count_clear		mv_tpm_sw_all_count_clear_bounce
+#define _mv_tpm_sw_port_count_clear		mv_tpm_sw_port_count_clear_bounce
+#define _mv_tpm_sw_link_mode_set		mv_tpm_sw_link_mode_set_bounce
+#define _mv_tpm_sw_link_mode_get		mv_tpm_sw_link_mode_get_bounce
+#define _mv_tpm_sw_link_state_get		mv_tpm_sw_link_state_get_bounce
+#define _mv_tpm_sw_rate_limit_set		mv_tpm_sw_rate_limit_set_bounce
+#define _mv_tpm_sw_rate_limit_get		mv_tpm_sw_rate_limit_get_bounce
+#define _mv_tpm_sw_mc_proto_rate_set		mv_tpm_sw_mc_proto_rate_set_bounce
+#define _mv_tpm_sw_mc_proto_rate_get		mv_tpm_sw_mc_proto_rate_get_bounce
+#define _mv_tpm_sw_mc_data_rate_set		mv_tpm_sw_mc_data_rate_set_bounce
+#define _mv_tpm_sw_mc_data_rate_get		mv_tpm_sw_mc_data_rate_get_bounce
+#define _mv_tpm_sw_broadcast_rate_set		mv_tpm_sw_broadcast_rate_set_bounce
+#define _mv_tpm_sw_broadcast_rate_get		mv_tpm_sw_broadcast_rate_get_bounce
+#define _mv_tpm_sw_mirror_set			mv_tpm_sw_mirror_set_bounce
+#define _mv_tpm_sw_mirror_get			mv_tpm_sw_mirror_get_bounce
+#define _mv_tpm_sw_loopback_set			mv_tpm_sw_loopback_set_bounce
+#define _mv_tpm_sw_loopback_get			mv_tpm_sw_loopback_get_bounce
+#define _mv_tpm_sw_mac_aging_time_set		mv_tpm_sw_mac_aging_time_set_bounce
+#define _mv_tpm_sw_mac_aging_time_get		mv_tpm_sw_mac_aging_time_get_bounce
+#define _mv_tpm_sw_mac_learn_limit_set		mv_tpm_sw_mac_learn_limit_set_bounce
+#define _mv_tpm_sw_mac_learn_limit_get		mv_tpm_sw_mac_learn_limit_get_bounce
+#define _mv_tpm_sw_mac_address_add		mv_tpm_sw_mac_address_add_bounce
+#define _mv_tpm_sw_mac_address_del		mv_tpm_sw_mac_address_del_bounce
+#define _mv_tpm_sw_mac_filter_mode_set		mv_tpm_sw_mac_filter_mode_set_bounce
+#define _mv_tpm_sw_mac_filter_mode_get		mv_tpm_sw_mac_filter_mode_get_bounce
+#define _mv_tpm_sw_mac_filter_entry_add		mv_tpm_sw_mac_filter_entry_add_bounce
+#define _mv_tpm_sw_mac_filter_entry_del		mv_tpm_sw_mac_filter_entry_del_bounce
+#define _mv_tpm_sw_mac_address_clear		mv_tpm_sw_mac_address_clear_bounce
+#define _mv_tpm_sw_mac_table_clear		mv_tpm_sw_mac_table_clear_bounce
+#define _mv_tpm_sw_qos_set			mv_tpm_sw_qos_set_bounce
+#define _mv_tpm_sw_qos_get			mv_tpm_sw_qos_get_bounce
+#define _mv_tpm_sw_mtu_set			mv_tpm_sw_mtu_set_bounce
+#define _mv_tpm_sw_mtu_get			mv_tpm_sw_mtu_get_bounce
+#define _mv_tpm_sw_stat1_get			mv_tpm_sw_stat1_get_bounce
+#define _mv_tpm_sw_stat2_get			mv_tpm_sw_stat2_get_bounce
+#define _mv_tpm_sw_stat3_get			mv_tpm_sw_stat3_get_bounce
+#define _mv_tpm_sw_stat_all_get			mv_tpm_sw_stat_all_get_bounce
+
+#else
+#define _mv_tpm_sw_vlan_ingress_mode_set	mv_tpm_sw_vlan_ingress_mode_set
+#define _mv_tpm_sw_vlan_ingress_mode_get	mv_tpm_sw_vlan_ingress_mode_get
+#define _mv_tpm_sw_pvid_set			mv_tpm_sw_pvid_set
+#define _mv_tpm_sw_pvid_get			mv_tpm_sw_pvid_get
+#define _mv_tpm_sw_vlan_set			mv_tpm_sw_vlan_set
+#define _mv_tpm_sw_vlan_del			mv_tpm_sw_vlan_del
+#define _mv_tpm_sw_vlan_get			mv_tpm_sw_vlan_get
+#define _mv_tpm_sw_vlan_filter_set		mv_tpm_sw_vlan_filter_set
+#define _mv_tpm_sw_vlan_filter_get		mv_tpm_sw_vlan_filter_get
+#define _mv_tpm_sw_enable_state_set		mv_tpm_sw_enable_state_set
+#define _mv_tpm_sw_enable_state_get		mv_tpm_sw_enable_state_get
+#define _mv_tpm_sw_flow_control_set		mv_tpm_sw_flow_control_set
+#define _mv_tpm_sw_flow_control_get		mv_tpm_sw_flow_control_get
+#define _mv_tpm_sw_isolate_mask_set		mv_tpm_sw_isolate_mask_set
+#define _mv_tpm_sw_isolate_mask_get		mv_tpm_sw_isolate_mask_get
+#define _mv_tpm_sw_flood_control_mask_set	mv_tpm_sw_flood_control_mask_set
+#define _mv_tpm_sw_flood_control_mask_get	mv_tpm_sw_flood_control_mask_get
+#define _mv_tpm_sw_all_count_clear		mv_tpm_sw_all_count_clear
+#define _mv_tpm_sw_port_count_clear		mv_tpm_sw_port_count_clear
+#define _mv_tpm_sw_link_mode_set		mv_tpm_sw_link_mode_set
+#define _mv_tpm_sw_link_mode_get		mv_tpm_sw_link_mode_get
+#define _mv_tpm_sw_link_state_get		mv_tpm_sw_link_state_get
+#define _mv_tpm_sw_rate_limit_set		mv_tpm_sw_rate_limit_set
+#define _mv_tpm_sw_rate_limit_get		mv_tpm_sw_rate_limit_get
+#define _mv_tpm_sw_mc_proto_rate_set		mv_tpm_sw_mc_proto_rate_set
+#define _mv_tpm_sw_mc_proto_rate_get		mv_tpm_sw_mc_proto_rate_get
+#define _mv_tpm_sw_mc_data_rate_set		mv_tpm_sw_mc_data_rate_set
+#define _mv_tpm_sw_mc_data_rate_get		mv_tpm_sw_mc_data_rate_get
+#define _mv_tpm_sw_broadcast_rate_set		mv_tpm_sw_broadcast_rate_set
+#define _mv_tpm_sw_broadcast_rate_get		mv_tpm_sw_broadcast_rate_get
+#define _mv_tpm_sw_mirror_set			mv_tpm_sw_mirror_set
+#define _mv_tpm_sw_mirror_get			mv_tpm_sw_mirror_get
+#define _mv_tpm_sw_loopback_set			mv_tpm_sw_loopback_set
+#define _mv_tpm_sw_loopback_get			mv_tpm_sw_loopback_get
+#define _mv_tpm_sw_mac_aging_time_set		mv_tpm_sw_mac_aging_time_set
+#define _mv_tpm_sw_mac_aging_time_get		mv_tpm_sw_mac_aging_time_get
+#define _mv_tpm_sw_mac_learn_limit_set		mv_tpm_sw_mac_learn_limit_set
+#define _mv_tpm_sw_mac_learn_limit_get		mv_tpm_sw_mac_learn_limit_get
+#define _mv_tpm_sw_mac_address_add		mv_tpm_sw_mac_address_add
+#define _mv_tpm_sw_mac_address_del		mv_tpm_sw_mac_address_del
+#define _mv_tpm_sw_mac_filter_mode_set		mv_tpm_sw_mac_filter_mode_set
+#define _mv_tpm_sw_mac_filter_mode_get		mv_tpm_sw_mac_filter_mode_get
+#define _mv_tpm_sw_mac_filter_entry_add		mv_tpm_sw_mac_filter_entry_add
+#define _mv_tpm_sw_mac_filter_entry_del		mv_tpm_sw_mac_filter_entry_del
+#define _mv_tpm_sw_mac_address_clear		mv_tpm_sw_mac_address_clear
+#define _mv_tpm_sw_mac_table_clear		mv_tpm_sw_mac_table_clear
+#define _mv_tpm_sw_qos_set			mv_tpm_sw_qos_set
+#define _mv_tpm_sw_qos_get			mv_tpm_sw_qos_get
+#define _mv_tpm_sw_mtu_set			mv_tpm_sw_mtu_set
+#define _mv_tpm_sw_mtu_get			mv_tpm_sw_mtu_get
+#define _mv_tpm_sw_stat1_get			mv_tpm_sw_stat1_get
+#define _mv_tpm_sw_stat2_get			mv_tpm_sw_stat2_get
+#define _mv_tpm_sw_stat3_get			mv_tpm_sw_stat3_get
+#define _mv_tpm_sw_stat_all_get			mv_tpm_sw_stat_all_get
+
+#endif
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS API                                             */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sys_sw_ingress_mode_set
+*
+* DESCRIPTION:
+*       This function sets switch port VLAN ingress mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_ingress_mode_set(const char *buf, size_t len)
+{
+	enum ingress_mode_para_idx {
+		ingress_mode_port = 0,
+		ingress_mode_mode,
+		ingress_mode_max
+	};
+	unsigned int port;
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != ingress_mode_max)
+		parm_error_completion(param_num, ingress_mode_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_ingress_mode_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_ingress_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_ingress_mode_get
+*
+* DESCRIPTION:
+*       This function gets switch port VLAN ingress mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_ingress_mode_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_ingress_mode_t mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_ingress_mode_get((enum tpm_sw_port_t)port, &mode))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), mode(%s)\n",
+					port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_INGRESS_MODE, mode));
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_pvid_set
+*
+* DESCRIPTION:
+*       This function sets switch port default VLAN and P-bits.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_pvid_set(const char *buf, size_t len)
+{
+	enum pvid_para_idx {
+		pvid_port = 0,
+		pvid_vid,
+		pvid_pbits,
+		pvid_max
+	};
+	unsigned int port;
+	unsigned int vid;
+	unsigned int pbits;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != pvid_max)
+		parm_error_completion(param_num, pvid_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d", &port, &vid, &pbits);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_pvid_set((enum tpm_sw_port_t)port, (unsigned short)vid, (unsigned char)pbits))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_pvid_get
+*
+* DESCRIPTION:
+*       This function gets switch port default VLAN and P-bits.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_pvid_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned short vid;
+	unsigned char pbits;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_pvid_get((enum tpm_sw_port_t)port, &vid, &pbits))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), default vid(%d), p-bits(%d)\n", port, vid, pbits);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vlan_set
+*
+* DESCRIPTION:
+*       This function configures VLAN
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vlan_set(const char *buf, size_t len)
+{
+	enum vlan_para_idx {
+		vlan_port = 0,
+		vlan_min_vid,
+		vlan_max_vid,
+		vlan_mode,
+		vlan_max
+	};
+	unsigned int port;
+	unsigned int min_vid;
+	unsigned int max_vid;
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != vlan_max)
+		parm_error_completion(param_num, vlan_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d", &port, &min_vid, &max_vid, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_set((enum tpm_sw_port_t)port,
+				(unsigned short)min_vid,
+				(unsigned short)max_vid,
+				(enum tpm_sw_vlan_egress_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vlan_del
+*
+* DESCRIPTION:
+*       This function deletes VLAN
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vlan_del(const char *buf, size_t len)
+{
+	enum vlan_para_idx {
+		vlan_port = 0,
+		vlan_min_vid,
+		vlan_max_vid,
+		vlan_max
+	};
+	unsigned int port;
+	unsigned int min_vid;
+	unsigned int max_vid;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != vlan_max)
+		parm_error_completion(param_num, vlan_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d", &port, &min_vid, &max_vid);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_del((enum tpm_sw_port_t)port,
+				(unsigned short)min_vid,
+				(unsigned short)max_vid))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vlan_get
+*
+* DESCRIPTION:
+*       This function gets VLAN information
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vlan_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_vlan = 0,
+		sw_vlan_max
+	};
+	unsigned int vlan;
+	unsigned int fwd_bm;
+	unsigned int tag_bm;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_vlan_max)
+		parm_error_completion(param_num, sw_vlan_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &vlan);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_get((unsigned short)vlan, &fwd_bm, &tag_bm))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, fwd_bm(0x%02x) tag_bm(0x%02x)\n", fwd_bm, tag_bm);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vlan_filter_set
+*
+* DESCRIPTION:
+*       This function sets switch port VLAN filter mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vlan_filter_set(const char *buf, size_t len)
+{
+	enum vlan_filter_para_idx {
+		vlan_filter_port = 0,
+		vlan_filter_enable,
+		vlan_filter_max
+	};
+	unsigned int port;
+	unsigned int enable;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != vlan_filter_max)
+		parm_error_completion(param_num, vlan_filter_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &enable);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_filter_set((enum tpm_sw_port_t)port, (enum tpm_sw_config_state_t)enable))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vlan_filter_get
+*
+* DESCRIPTION:
+*       This function gets switch port VLAN filter mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vlan_filter_get(const char *buf, size_t len)
+{
+	enum vlan_filter_para_idx {
+		vlan_filter_port = 0,
+		vlan_filter_max
+	};
+	unsigned int port;
+	enum tpm_sw_config_state_t enable;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != vlan_filter_max)
+		parm_error_completion(param_num, vlan_filter_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_vlan_filter_get((enum tpm_sw_port_t)port, &enable))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, enable(%d)\n", enable);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_admin_state_set
+*
+* DESCRIPTION:
+*       This function gets switch port admin state.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_admin_state_set(const char *buf, size_t len)
+{
+	enum admin_state_para_idx {
+		admin_state_port = 0,
+		admin_state_enable,
+		admin_state_max
+	};
+	unsigned int port;
+	unsigned int enable;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != admin_state_max)
+		parm_error_completion(param_num, admin_state_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &enable);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_enable_state_set((enum tpm_sw_port_t)port, (enum tpm_sw_config_state_t)enable))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_admin_state_get
+*
+* DESCRIPTION:
+*       This function gets switch port admin state.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_admin_state_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_config_state_t enable;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_enable_state_get((enum tpm_sw_port_t)port, &enable))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), sate(%s)\n",
+					port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable));
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_flow_control_set
+*
+* DESCRIPTION:
+*       This function sets switch port flow control.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_flow_control_set(const char *buf, size_t len)
+{
+	enum flow_control_para_idx {
+		flow_control_port = 0,
+		flow_control_enable,
+		flow_control_pause_interval,
+		flow_control_max
+	};
+	unsigned int port;
+	unsigned int enable;
+	unsigned int pause_interval;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != flow_control_max)
+		parm_error_completion(param_num, flow_control_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d", &port, &enable, &pause_interval);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_flow_control_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_config_state_t)enable,
+				pause_interval))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_flow_control_get
+*
+* DESCRIPTION:
+*       This function gets switch port flow control.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_flow_control_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_config_state_t enable;
+	unsigned int interval;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_flow_control_get((enum tpm_sw_port_t)port, &enable, &interval))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), flow control sate(%s), interval(%d)\n",
+				       port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable), interval);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_isolate_mask_set
+*
+* DESCRIPTION:
+*       This function sets switch port isolation.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_isolate_mask_set(const char *buf, size_t len)
+{
+	enum isolate_mask_para_idx {
+		isolate_mask_port = 0,
+		isolate_mask_mask,
+		isolate_mask_max
+	};
+	unsigned int port;
+	unsigned int mask;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != isolate_mask_max)
+		parm_error_completion(param_num, isolate_mask_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %x", &port, &mask);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_isolate_mask_set((enum tpm_sw_port_t)port, (unsigned int)mask))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_isolate_mask_get
+*
+* DESCRIPTION:
+*       This function gets switch port isolation.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_isolate_mask_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int mask;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_isolate_mask_get((enum tpm_sw_port_t)port, &mask))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), isolate mask(0x%x)\n", port, mask);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_flood_mask_set
+*
+* DESCRIPTION:
+*       This function sets switch port flooding mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_flood_mask_set(const char *buf, size_t len)
+{
+	enum flood_mask_para_idx {
+		flood_mask_port = 0,
+		flood_mask_pkt_type,
+		flood_mask_mask,
+		flood_mask_max
+	};
+	unsigned int port;
+	unsigned int pkt_type;
+	unsigned int mask;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != flood_mask_max)
+		parm_error_completion(param_num, flood_mask_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %x", &port, &pkt_type, &mask);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_flood_control_mask_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_flood_packet_type_t)pkt_type,
+				(unsigned int)mask))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_flood_mask_get
+*
+* DESCRIPTION:
+*       This function gets switch port flooding mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_flood_mask_get(const char *buf, size_t len)
+{
+	enum flood_mask_para_idx {
+		flood_mask_port = 0,
+		flood_mask_pkt_type,
+		flood_mask_max
+	};
+	unsigned int port;
+	unsigned int pkt_type;
+	unsigned int mask;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != flood_mask_max)
+		parm_error_completion(param_num, flood_mask_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &pkt_type);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_flood_control_mask_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_flood_packet_type_t)pkt_type,
+				&mask))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), pkt_type(%s), mask(0x%x)\n",
+				       port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_FLOOD_TYPE, pkt_type), mask);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_sw_count_clear
+*
+* DESCRIPTION:
+*       This function clears counters of all switch ports.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_sw_count_clear(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_all_count_clear())
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_port_count_clear
+*
+* DESCRIPTION:
+*       This function clears counters of dedicated switch ports.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_port_count_clear(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_port_count_clear((enum tpm_sw_port_t)port))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d)\n", port);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_link_mode_set
+*
+* DESCRIPTION:
+*       This function sets switch port link mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_link_mode_set(const char *buf, size_t len)
+{
+	enum link_mode_idx {
+		link_mode_port = 0,
+		link_mode_auto_en,
+		link_mode_speed,
+		link_mode_duplex,
+		link_mode_max
+	};
+	unsigned int port;
+	unsigned int auto_en;
+	unsigned int speed;
+	unsigned int duplex;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != link_mode_max)
+		parm_error_completion(param_num, link_mode_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d", &port, &auto_en, &speed, &duplex);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_link_mode_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_config_state_t)auto_en,
+				(enum tpm_sw_speed_mode_t)speed,
+				(enum tpm_sw_duplex_mode_t)duplex))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_link_mode_get
+*
+* DESCRIPTION:
+*       This function gets switch port link mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_link_mode_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_config_state_t auto_en;
+	enum tpm_sw_speed_mode_t speed;
+	enum tpm_sw_duplex_mode_t duplex;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_link_mode_get((enum tpm_sw_port_t)port, &auto_en, &speed, &duplex))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), auto_en(%s), speed(%s), duplex(%s)\n",
+				       port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, auto_en),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_SPEED_MODE, speed),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_DUPLEX_MODE, duplex));
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_link_state_get
+*
+* DESCRIPTION:
+*       This function gets switch port link state.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_link_state_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_port_state_t link;
+	enum tpm_sw_speed_mode_t speed;
+	enum tpm_sw_duplex_mode_t duplex;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_link_state_get((enum tpm_sw_port_t)port, &link, &speed, &duplex))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), link(%s), speed(%s), duplex(%s)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_STATE, link),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_SPEED_MODE, speed),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_DUPLEX_MODE, duplex));
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_rate_limit_set
+*
+* DESCRIPTION:
+*       This function sets switch port rate limit.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_rate_limit_set(const char *buf, size_t len)
+{
+	enum rate_limit_idx {
+		rate_limit_port = 0,
+		rate_limit_dir,
+		rate_limit_enable,
+		rate_limit_mode,
+		rate_limit_rate,
+		rate_limit_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	unsigned int enable;
+	unsigned int mode;
+	unsigned int rate;
+
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != rate_limit_max)
+		parm_error_completion(param_num, rate_limit_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d", &port, &dir, &enable, &mode, &rate);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_rate_limit_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable,
+				(enum tpm_sw_rate_limit_mode_t)mode,
+				rate))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_rate_limit_get
+*
+* DESCRIPTION:
+*       This function gets switch port rate limit.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_rate_limit_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_rate_limit_mode_t mode;
+	unsigned int rate;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_rate_limit_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				&enable,
+				&mode,
+				&rate))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), dir(%s), enable(%s), mode(%s), rate(%d)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_RATE_LIMIT_MODE, mode),
+				       rate);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mc_proto_rate_set
+*
+* DESCRIPTION:
+*       This function sets switch port rate limit for multicast protocol packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mc_proto_rate_set(const char *buf, size_t len)
+{
+	enum rate_limit_idx {
+		rate_limit_port = 0,
+		rate_limit_dir,
+		rate_limit_enable,
+		rate_limit_mode,
+		rate_limit_rate,
+		rate_limit_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	unsigned int enable;
+	unsigned int mode;
+	unsigned int rate;
+
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != rate_limit_max)
+		parm_error_completion(param_num, rate_limit_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d", &port, &dir, &enable, &mode, &rate);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mc_proto_rate_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable,
+				(enum tpm_sw_rate_limit_mode_t)mode,
+				rate))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mc_proto_rate_get
+*
+* DESCRIPTION:
+*       This function gets switch port rate limit for multicast protocol packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mc_proto_rate_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_rate_limit_mode_t mode;
+	unsigned int rate;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mc_proto_rate_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				&enable,
+				&mode,
+				&rate))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), dir(%s), enable(%s), mode(%s), rate(%d)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_RATE_LIMIT_MODE, mode),
+				       rate);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mc_data_rate_set
+*
+* DESCRIPTION:
+*       This function sets switch port rate limit for multicast data packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mc_data_rate_set(const char *buf, size_t len)
+{
+	enum rate_limit_idx {
+		rate_limit_port = 0,
+		rate_limit_dir,
+		rate_limit_enable,
+		rate_limit_mode,
+		rate_limit_rate,
+		rate_limit_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	unsigned int enable;
+	unsigned int mode;
+	unsigned int rate;
+
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != rate_limit_max)
+		parm_error_completion(param_num, rate_limit_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d", &port, &dir, &enable, &mode, &rate);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mc_data_rate_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable,
+				(enum tpm_sw_rate_limit_mode_t)mode,
+				rate))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mc_data_rate_get
+*
+* DESCRIPTION:
+*       This function gets switch port rate limit for multicast data packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mc_data_rate_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_rate_limit_mode_t mode;
+	unsigned int rate;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mc_data_rate_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				&enable,
+				&mode,
+				&rate))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), dir(%s), enable(%s), mode(%s), rate(%d)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_RATE_LIMIT_MODE, mode),
+				       rate);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_bc_rate_set
+*
+* DESCRIPTION:
+*       This function sets switch port rate limit for broadcast packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_bc_rate_set(const char *buf, size_t len)
+{
+	enum rate_limit_idx {
+		rate_limit_port = 0,
+		rate_limit_dir,
+		rate_limit_enable,
+		rate_limit_mode,
+		rate_limit_rate,
+		rate_limit_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	unsigned int enable;
+	unsigned int mode;
+	unsigned int rate;
+
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != rate_limit_max)
+		parm_error_completion(param_num, rate_limit_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d %d", &port, &dir, &enable, &mode, &rate);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_broadcast_rate_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable,
+				(enum tpm_sw_rate_limit_mode_t)mode, rate))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_bc_rate_get
+*
+* DESCRIPTION:
+*       This function gets switch port rate limit for broadcast packets.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_bc_rate_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_rate_limit_mode_t mode;
+	unsigned int rate;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_broadcast_rate_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				&enable,
+				&mode,
+				&rate))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), dir(%s), enable(%s), mode(%s), rate(%d)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_RATE_LIMIT_MODE, mode),
+				       rate);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_port_mirror_set
+*
+* DESCRIPTION:
+*       This function sets switch port mirror.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_port_mirror_set(const char *buf, size_t len)
+{
+	enum port_mirror_idx {
+		port_mirror_sport = 0,
+		port_mirror_dir,
+		port_mirror_enable,
+		port_mirror_dport,
+		port_mirror_max
+	};
+	unsigned int sport;
+	unsigned int enable;
+	unsigned int dir;
+	unsigned int dport;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != port_mirror_max)
+		parm_error_completion(param_num, port_mirror_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d", &sport, &dir, &enable, &dport);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mirror_set((enum tpm_sw_port_t)sport,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable,
+				(enum tpm_sw_port_t)dport))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_port_mirror_get
+*
+* DESCRIPTION:
+*       This function gets switch port mirror.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_port_mirror_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int sport;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	enum tpm_sw_port_t dport;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &sport, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mirror_get((enum tpm_sw_port_t)sport,
+				(enum tpm_sw_port_dir_t)dir,
+				&enable,
+				&dport))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, sport(%d), dir(%s), enable(%s), dport(%d)\n",
+				       sport,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       dport);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_loopback_set
+*
+* DESCRIPTION:
+*       This function sets switch port loopback.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_loopback_set(const char *buf, size_t len)
+{
+	enum loopback_para_idx {
+		loopback_port = 0,
+		loopback_dir,
+		loopback_enable,
+		loopback_max
+	};
+	unsigned int port;
+	unsigned int enable;
+	unsigned int dir;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != loopback_max)
+		parm_error_completion(param_num, loopback_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d", &port, &dir, &enable);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_loopback_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_port_dir_t)dir,
+				(enum tpm_sw_config_state_t)enable))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_loopback_get
+*
+* DESCRIPTION:
+*       This function gets switch port loopback.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_loopback_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_dir,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int dir;
+	enum tpm_sw_config_state_t enable;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_phy);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &dir);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_loopback_get((enum tpm_sw_port_t)port, (enum tpm_sw_port_dir_t)dir, &enable))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), dir(%s), loopback sate(%s)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_PORT_DIR, dir),
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable));
+#endif
+
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_age_set
+*
+* DESCRIPTION:
+*       This function sets switch MAC aging time.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_age_set(const char *buf, size_t len)
+{
+	enum mac_age_para_idx {
+		mac_age_time = 0,
+		mac_age_max
+	};
+	unsigned int time;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_age_max)
+		parm_error_completion(param_num, mac_age_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &time);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_aging_time_set(time))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_age_get
+*
+* DESCRIPTION:
+*       This function gets switch MAC aging time.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_age_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int time;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_aging_time_get(&time))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, time(%d)\n", time);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_num_set
+*
+* DESCRIPTION:
+*       This function sets switch port MAX MAC address number could be learned.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_num_set(const char *buf, size_t len)
+{
+	enum mac_num_para_idx {
+		mac_num_port = 0,
+		mac_num_enable,
+		mac_num_limit,
+		mac_num_max
+	};
+	unsigned int port;
+	unsigned int enable;
+	unsigned int limit;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_num_max)
+		parm_error_completion(param_num, mac_num_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d", &port, &enable, &limit);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_learn_limit_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_config_state_t)enable,
+				limit))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_num_get
+*
+* DESCRIPTION:
+*       This function gets switch port MAX MAC address number could be learned.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_num_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_config_state_t enable;
+	unsigned int limit;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_learn_limit_get((enum tpm_sw_port_t)port, &enable, &limit))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), enable(%s), limit(%d)\n",
+				       port,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_CONFIG_STATE, enable),
+				       limit);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_addr_add
+*
+* DESCRIPTION:
+*       This function adds MAC address.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_addr_add(const char *buf, size_t len)
+{
+	enum mac_addr_para_idx {
+		mac_addr_port = 0,
+		mac_addr_mac6,
+		mac_addr_mac5,
+		mac_addr_mac4,
+		mac_addr_mac3,
+		mac_addr_mac2,
+		mac_addr_mac1,
+		mac_addr_vlan,
+		mac_addr_mode,
+		mac_addr_max
+	};
+	unsigned int port_bm;
+	unsigned int mac6, mac5, mac4, mac3, mac2, mac1;
+	unsigned int vlan;
+	unsigned int mode;
+	unsigned char mac[6];
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_addr_max)
+		parm_error_completion(param_num, mac_addr_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x %x %x %x %x %x %x %d %d",
+					&port_bm, &mac6, &mac5, &mac4, &mac3, &mac2, &mac1, &vlan, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			mac[0] = (unsigned char)mac6;
+			mac[1] = (unsigned char)mac5;
+			mac[2] = (unsigned char)mac4;
+			mac[3] = (unsigned char)mac3;
+			mac[4] = (unsigned char)mac2;
+			mac[5] = (unsigned char)mac1;
+			if (!_mv_tpm_sw_mac_address_add(port_bm,
+				(unsigned char *)&mac[0],
+				(unsigned short)vlan,
+				(enum tpm_sw_mac_addr_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_addr_del
+*
+* DESCRIPTION:
+*       This function deletes MAC address.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_addr_del(const char *buf, size_t len)
+{
+	enum mac_addr_para_idx {
+		mac_addr_port = 0,
+		mac_addr_mac6,
+		mac_addr_mac5,
+		mac_addr_mac4,
+		mac_addr_mac3,
+		mac_addr_mac2,
+		mac_addr_mac1,
+		mac_addr_vlan,
+		mac_addr_max
+	};
+	unsigned int port;
+	unsigned int mac6, mac5, mac4, mac3, mac2, mac1;
+	unsigned int vlan;
+	unsigned char mac[6];
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_addr_max)
+		parm_error_completion(param_num, mac_addr_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%x %x %x %x %x %x %x %d",
+					&port, &mac6, &mac5, &mac4, &mac3, &mac2, &mac1, &vlan);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			mac[0] = (unsigned char)mac6;
+			mac[1] = (unsigned char)mac5;
+			mac[2] = (unsigned char)mac4;
+			mac[3] = (unsigned char)mac3;
+			mac[4] = (unsigned char)mac2;
+			mac[5] = (unsigned char)mac1;
+			if (!_mv_tpm_sw_mac_address_del(port, (unsigned char *)&mac[0], (unsigned short)vlan))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_filter_mode_set
+*
+* DESCRIPTION:
+*       This function sets switch port MAC filter mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_filter_mode_set(const char *buf, size_t len)
+{
+	enum mac_filter_mode_para_idx {
+		mac_filter_mode_port = 0,
+		mac_filter_mode_mode,
+		mac_filter_mode_max
+	};
+	unsigned int port;
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_filter_mode_max)
+		parm_error_completion(param_num, mac_filter_mode_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_filter_mode_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_mac_filter_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_filter_mode_get
+*
+* DESCRIPTION:
+*       This function gets switch port MAC filter mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_filter_mode_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	enum tpm_sw_mac_filter_mode_t mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_filter_mode_get((enum tpm_sw_port_t)port, &mode))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), mode(%s)\n",
+				       port, tpm_sw_lookup_enum_str(TPM_SW_ENUM_MAC_FILTER_MODE, mode));
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_filter_entry_add
+*
+* DESCRIPTION:
+*       This function adds switch port MAC filter entry.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_filter_entry_add(const char *buf, size_t len)
+{
+	enum mac_addr_para_idx {
+		mac_addr_port = 0,
+		mac_addr_mac6,
+		mac_addr_mac5,
+		mac_addr_mac4,
+		mac_addr_mac3,
+		mac_addr_mac2,
+		mac_addr_mac1,
+		mac_addr_vlan,
+		mac_addr_mode,
+		mac_addr_max
+	};
+	unsigned int port;
+	unsigned int mac6, mac5, mac4, mac3, mac2, mac1;
+	unsigned int vlan;
+	unsigned int mode;
+	unsigned char mac[6];
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_addr_max)
+		parm_error_completion(param_num, mac_addr_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %x %x %x %x %x %x %d %d",
+					&port, &mac6, &mac5, &mac4, &mac3, &mac2, &mac1, &vlan, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			mac[0] = (unsigned char)mac6;
+			mac[1] = (unsigned char)mac5;
+			mac[2] = (unsigned char)mac4;
+			mac[3] = (unsigned char)mac3;
+			mac[4] = (unsigned char)mac2;
+			mac[5] = (unsigned char)mac1;
+			if (!_mv_tpm_sw_mac_filter_entry_add((enum tpm_sw_port_t)port,
+				(unsigned char *)&mac[0],
+				(unsigned short)vlan,
+				(enum tpm_sw_mac_filter_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_filter_entry_del
+*
+* DESCRIPTION:
+*       This function deletes switch port MAC filter entry.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_filter_entry_del(const char *buf, size_t len)
+{
+	enum mac_addr_para_idx {
+		mac_addr_port = 0,
+		mac_addr_mac6,
+		mac_addr_mac5,
+		mac_addr_mac4,
+		mac_addr_mac3,
+		mac_addr_mac2,
+		mac_addr_mac1,
+		mac_addr_vlan,
+		mac_addr_mode,
+		mac_addr_max
+	};
+	unsigned int port;
+	unsigned int mac6, mac5, mac4, mac3, mac2, mac1;
+	unsigned int vlan;
+	unsigned int mode;
+	unsigned char mac[6];
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_addr_max)
+		parm_error_completion(param_num, mac_addr_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %x %x %x %x %x %x %d %d",
+					&port, &mac6, &mac5, &mac4, &mac3, &mac2, &mac1, &vlan, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			mac[0] = (unsigned char)mac6;
+			mac[1] = (unsigned char)mac5;
+			mac[2] = (unsigned char)mac4;
+			mac[3] = (unsigned char)mac3;
+			mac[4] = (unsigned char)mac2;
+			mac[5] = (unsigned char)mac1;
+			if (!_mv_tpm_sw_mac_filter_entry_del((enum tpm_sw_port_t)port,
+				(unsigned char *)&mac[0],
+				(unsigned short)vlan,
+				(enum tpm_sw_mac_filter_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_addr_clear
+*
+* DESCRIPTION:
+*       This function clears all switch MAC addresses.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_addr_clear(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_address_clear())
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mac_table_clear
+*
+* DESCRIPTION:
+*       This function clears switch port MAC address according to type.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mac_table_clear(const char *buf, size_t len)
+{
+	enum mac_clear_para_idx {
+		mac_clear_port = 0,
+		mac_clear_mode,
+		mac_clear_max
+	};
+	unsigned int port;
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mac_clear_max)
+		parm_error_completion(param_num, mac_clear_max, buf, tpm_sys_sw_help_mac);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mac_table_clear((enum tpm_sw_port_t)port, (enum tpm_sw_mac_addr_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_port_qos_set
+*
+* DESCRIPTION:
+*       This function sets switch port QoS.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_port_qos_set(const char *buf, size_t len)
+{
+	enum port_qos_para_idx {
+		port_qos_port = 0,
+		port_qos_queue,
+		port_qos_mode,
+		port_qos_weight,
+		port_qos_max
+	};
+	unsigned int port;
+	unsigned int queue;
+	unsigned int mode;
+	unsigned int weight;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != port_qos_max)
+		parm_error_completion(param_num, port_qos_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d %d %d", &port, &queue, &mode, &weight);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_qos_set((enum tpm_sw_port_t)port,
+				(enum tpm_sw_queue_t)queue,
+				(enum tpm_sw_qos_mode_t)mode, (unsigned char)weight))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_port_qos_get
+*
+* DESCRIPTION:
+*       This function gets switch port QoS.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_port_qos_get(const char *buf, size_t len)
+{
+	enum port_qos_para_idx {
+		port_qos_port = 0,
+		port_qos_queue,
+		port_qos_max
+	};
+	unsigned int port;
+	unsigned int queue;
+	enum tpm_sw_qos_mode_t mode;
+	unsigned char weight;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != port_qos_max)
+		parm_error_completion(param_num, port_qos_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &queue);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_qos_get((enum tpm_sw_port_t)port, (enum tpm_sw_queue_t)queue, &mode, &weight))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, port(%d), queue(%d), mode(%s), weight(%d)\n",
+				       port,
+				       queue,
+				       tpm_sw_lookup_enum_str(TPM_SW_ENUM_QOS_MODE, mode),
+				       weight);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mtu_set
+*
+* DESCRIPTION:
+*       This function sets switch MTU.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mtu_set(const char *buf, size_t len)
+{
+	enum mtu_config_para_idx {
+		mtu_config_mtu = 0,
+		mtu_config_max
+	};
+	unsigned int mtu;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != mtu_config_max)
+		parm_error_completion(param_num, mtu_config_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &mtu);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mtu_set(mtu))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_mtu_get
+*
+* DESCRIPTION:
+*       This function gets switch MTU.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_mtu_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int mtu;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_mtu_get(&mtu))
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				{}
+#else
+				printk(KERN_INFO "OK, mtu(%d)\n", mtu);
+#endif
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_stat1_get
+*
+* DESCRIPTION:
+*       This function gets switch port stat1 counters.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_stat1_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_reset,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int reset;
+	struct tpm_sw_port_stat1_t stat;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &reset);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_stat1_get((enum tpm_sw_port_t)port, (enum tpm_sw_count_reset_t)reset, &stat)) {
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				;
+#else
+				printk(KERN_INFO "OK, port(%d) stat1\n", port);
+				printk(KERN_INFO "-------------------------\n");
+				printk(KERN_INFO "inbytes:       %lld\n", stat.inbytes);
+				printk(KERN_INFO "inpkts:        %lld\n", stat.inpkts);
+				printk(KERN_INFO "inunicast:     %lld\n", stat.inunicast);
+				printk(KERN_INFO "inmulticast:   %lld\n", stat.inmulticast);
+				printk(KERN_INFO "inbroadcast:   %lld\n", stat.inbroadcast);
+				printk(KERN_INFO "indiscard:     %lld\n", stat.indiscard);
+				printk(KERN_INFO "outbytes:      %lld\n", stat.outbytes);
+				printk(KERN_INFO "outpkts:       %lld\n", stat.outpkts);
+				printk(KERN_INFO "outunicast:    %lld\n", stat.outunicast);
+				printk(KERN_INFO "outmulticast:  %lld\n", stat.outmulticast);
+				printk(KERN_INFO "outbroadcast:  %lld\n", stat.outbroadcast);
+				printk(KERN_INFO "outerror:      %lld\n", stat.outerror);
+				printk(KERN_INFO "outdiscard:    %lld\n", stat.outdiscard);
+#endif
+			} else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_stat2_get
+*
+* DESCRIPTION:
+*       This function gets switch port stat2 counters.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_stat2_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_reset,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int reset;
+	struct tpm_sw_port_stat2_t stat;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &reset);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_stat2_get((enum tpm_sw_port_t)port, (enum tpm_sw_count_reset_t)reset, &stat)) {
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				;
+#else
+				printk(KERN_INFO "OK, port(%d) stat2\n", port);
+				printk(KERN_INFO "-------------------------\n");
+				printk(KERN_INFO "inundersize:   %lld\n", stat.inundersize);
+				printk(KERN_INFO "inoversize:    %lld\n", stat.inoversize);
+				printk(KERN_INFO "infragments:   %lld\n", stat.infragments);
+				printk(KERN_INFO "injabbers:     %lld\n", stat.injabbers);
+				printk(KERN_INFO "outundersize:  %lld\n", stat.outundersize);
+				printk(KERN_INFO "outoversize:   %lld\n", stat.outoversize);
+				printk(KERN_INFO "pppoefiltered: %lld\n", stat.pppoefiltered);
+				printk(KERN_INFO "statechange:   %lld\n", stat.statechange);
+				printk(KERN_INFO "outpause:      %lld\n", stat.outpause);
+				printk(KERN_INFO "dropevents:    %lld\n", stat.dropevents);
+#endif
+			} else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_stat3_get
+*
+* DESCRIPTION:
+*       This function gets switch port stat3 counters.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_stat3_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_reset,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int reset;
+	struct tpm_sw_port_stat3_t stat;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &reset);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_stat3_get((enum tpm_sw_port_t)port, (enum tpm_sw_count_reset_t)reset, &stat)) {
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				;
+#else
+				printk(KERN_INFO "OK, port(%d) stat3\n", port);
+				printk(KERN_INFO "-------------------------\n");
+				printk(KERN_INFO "in64:          %lld\n", stat.in64);
+				printk(KERN_INFO "in65to127:     %lld\n", stat.in65to127);
+				printk(KERN_INFO "in128to255:    %lld\n", stat.in128to255);
+				printk(KERN_INFO "in256to511:    %lld\n", stat.in256to511);
+				printk(KERN_INFO "in512to1023:   %lld\n", stat.in512to1023);
+				printk(KERN_INFO "in1024tomax:   %lld\n", stat.in1024tomax);
+				printk(KERN_INFO "out64:         %lld\n", stat.out64);
+				printk(KERN_INFO "out65to127:    %lld\n", stat.out65to127);
+				printk(KERN_INFO "out128to255:   %lld\n", stat.out128to255);
+				printk(KERN_INFO "out256to511:   %lld\n", stat.out256to511);
+				printk(KERN_INFO "out512to1024:  %lld\n", stat.out512to1024);
+				printk(KERN_INFO "out1024tomax:  %lld\n", stat.out1024tomax);
+#endif
+			} else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_stat_all_get
+*
+* DESCRIPTION:
+*       This function gets switch port stat_all counters.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_stat_all_get(const char *buf, size_t len)
+{
+	enum sw_port_idx {
+		sw_port = 0,
+		sw_reset,
+		sw_port_max
+	};
+	unsigned int port;
+	unsigned int reset;
+	struct tpm_sw_port_stat_all_t stat;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_port_max)
+		parm_error_completion(param_num, sw_port_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d %d", &port, &reset);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!_mv_tpm_sw_stat_all_get((enum tpm_sw_port_t)port,
+				(enum tpm_sw_count_reset_t)reset, &stat)) {
+#ifdef CONFIG_MV_TPM_SFS_2_IOCTL
+				;
+#else
+				printk(KERN_INFO "OK, port(%d) stat_all\n", port);
+				printk(KERN_INFO "-------------------------\n");
+				printk(KERN_INFO "InGoodOctetsLo: %8i\n",	stat.inGoodOctetsLo);
+				printk(KERN_INFO "InGoodOctetsHi: %8i\n",	stat.inGoodOctetsHi);
+				printk(KERN_INFO "InBadOctets:    %8i\n",	stat.inBadOctets);
+				printk(KERN_INFO "OutFCSErr:      %8i\n",	stat.outFCSErr);
+				printk(KERN_INFO "InUnicasts:     %8i\n",	stat.inUnicasts);
+				printk(KERN_INFO "Deferred:       %8i\n",	stat.deferred);
+				printk(KERN_INFO "InBroadcasts:   %8i\n",	stat.inBroadcasts);
+				printk(KERN_INFO "InMulticasts:   %8i\n",	stat.inMulticasts);
+				printk(KERN_INFO "64Octets:       %8i\n",	stat.octets64);
+				printk(KERN_INFO "127Octets:      %8i\n",	stat.octets127);
+				printk(KERN_INFO "255Octets:      %8i\n",	stat.octets255);
+				printk(KERN_INFO "511Octets:      %8i\n",	stat.octets511);
+				printk(KERN_INFO "1023Octets:     %8i\n",	stat.octets1023);
+				printk(KERN_INFO "MaxOctets:      %8i\n",	stat.octetsMax);
+				printk(KERN_INFO "OutOctetsLo:    %8i\n",	stat.outOctetsLo);
+				printk(KERN_INFO "OutOctetsHi:    %8i\n",	stat.outOctetsHi);
+				printk(KERN_INFO "OutUnicasts:    %8i\n",	stat.outUnicasts);
+				printk(KERN_INFO "Excessive:      %8i\n",	stat.excessive);
+				printk(KERN_INFO "OutMulticasts:  %8i\n",	stat.outMulticasts);
+				printk(KERN_INFO "OutBroadcasts:  %8i\n",	stat.outBroadcasts);
+				printk(KERN_INFO "Single:         %8i\n",	stat.single);
+				printk(KERN_INFO "OutPause:       %8i\n",	stat.outPause);
+				printk(KERN_INFO "InPause:        %8i\n",	stat.inPause);
+				printk(KERN_INFO "Multiple:       %8i\n",	stat.multiple);
+				printk(KERN_INFO "Undersize:      %8i\n",	stat.undersize);
+				printk(KERN_INFO "Fragments:      %8i\n",	stat.fragments);
+				printk(KERN_INFO "Oversize:       %8i\n",	stat.oversize);
+				printk(KERN_INFO "Jabber:         %8i\n",	stat.jabber);
+				printk(KERN_INFO "InMACRcvErr:    %8i\n",	stat.inMACRcvErr);
+				printk(KERN_INFO "InFCSErr:       %8i\n",	stat.inFCSErr);
+				printk(KERN_INFO "Collisions:     %8i\n",	stat.collisions);
+				printk(KERN_INFO "Late:           %8i\n",	stat.late);
+				printk(KERN_INFO "InDiscard:      %8i\n",	stat.inDiscard);
+				printk(KERN_INFO "InFilter:       %8i\n",	stat.inFiltered);
+				printk(KERN_INFO "OutFilter:      %8i\n",	stat.outFiltered);
+#endif
+			} else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_head_mode_set
+*
+* DESCRIPTION:
+*       This function sets switch port head mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_head_mode_set(const char *buf, size_t len)
+{
+	enum sw_mode_idx {
+		sw_mode = 0,
+		sw_mode_max
+	};
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_mode_max)
+		parm_error_completion(param_num, sw_mode_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sw_head_mode_set((enum tpm_sw_head_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_head_mode_get
+*
+* DESCRIPTION:
+*       This function gets switch port head mode.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_head_mode_get(const char *buf, size_t len)
+{
+	enum sw_mode_idx {
+		sw_mode = 0,
+		sw_mode_max
+	};
+	unsigned int port;
+	enum tpm_sw_head_mode_t mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_mode_max)
+		parm_error_completion(param_num, sw_mode_max, buf, tpm_sys_sw_help_gen);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &port);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sw_head_mode_get(&mode))
+				printk(KERN_INFO "OK, mode(%d:%s)\n",
+					mode, tpm_sw_lookup_enum_str(TPM_SW_ENUM_HEAD_MODE, mode));
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_atu_dump
+*
+* DESCRIPTION:
+*       This function dump FDB entries.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_atu_dump(const char *buf, size_t len)
+{
+	enum sw_mode_idx {
+		sw_mode = 0,
+		sw_mode_max
+	};
+	unsigned int mode;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_mode_max)
+		parm_error_completion(param_num, sw_mode_max, buf, tpm_sys_sw_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &mode);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sw_atu_dump((enum tpm_sw_mac_addr_mode_t)mode))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vtu_dump
+*
+* DESCRIPTION:
+*       This function dump VTU entry according to VID.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vtu_dump(const char *buf, size_t len)
+{
+	enum sw_mode_idx {
+		sw_vid = 0,
+		sw_vid_max
+	};
+	unsigned int vid;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_vid_max)
+		parm_error_completion(param_num, sw_vid_max, buf, tpm_sys_sw_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &vid);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sw_vtu_dump(vid))
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+
+/*******************************************************************************
+* tpm_sys_sw_vtu_shadow_dump
+*
+* DESCRIPTION:
+*       This function dump VTU shadow.
+* INPUTS:
+*       buf     - Shell parameters as character buffer
+*       len     - Number of characters in buffer
+*******************************************************************************/
+void tpm_sys_sw_vtu_shadow_dump(const char *buf, size_t len)
+{
+	enum sw_mode_idx {
+		sw_vid = 0,
+		sw_vid_max
+	};
+	unsigned int vid;
+	int parsed_args;
+	int param_num;
+
+	param_num = count_parameters(buf);
+	if (param_num != sw_vid_max)
+		parm_error_completion(param_num, sw_vid_max, buf, tpm_sys_sw_help_debug);
+	else {
+		/* Get parameters */
+		parsed_args = sscanf(buf, "%d", &vid);
+		if (parsed_args != param_num)
+			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsed_args, param_num);
+		else {
+			if (!tpm_sw_vtu_shadow_dump())
+				PR_RESULT_OK
+			else
+				printk(KERN_INFO "FAIL\n");
+		}
+	}
+
+	return;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS STORE ROUTINE SWITCHER                          */
+/* ========================================================================== */
+static struct store_sysfs_name_func_t store_sysfs_name_func_ara[] = {
+	{"ingress_mode_set",		tpm_sys_sw_ingress_mode_set},
+	{"ingress_mode_get",		tpm_sys_sw_ingress_mode_get},
+	{"pvid_set",			tpm_sys_sw_pvid_set},
+	{"pvid_get",			tpm_sys_sw_pvid_get},
+	{"vlan_set",			tpm_sys_sw_vlan_set},
+	{"vlan_del",			tpm_sys_sw_vlan_del},
+	{"vlan_get",			tpm_sys_sw_vlan_get},
+	{"vlan_filter_set",		tpm_sys_sw_vlan_filter_set},
+	{"vlan_filter_get",		tpm_sys_sw_vlan_filter_get},
+	{"admin_state_set",		tpm_sys_sw_admin_state_set},
+	{"admin_state_get",		tpm_sys_sw_admin_state_get},
+	{"flow_control_set",		tpm_sys_sw_flow_control_set},
+	{"flow_control_get",		tpm_sys_sw_flow_control_get},
+	{"isolate_mask_set",		tpm_sys_sw_isolate_mask_set},
+	{"isolate_mask_get",		tpm_sys_sw_isolate_mask_get},
+	{"flood_mask_set",		tpm_sys_sw_flood_mask_set},
+	{"flood_mask_get",		tpm_sys_sw_flood_mask_get},
+	{"sw_count_clear",		tpm_sys_sw_sw_count_clear},
+	{"port_count_clear",		tpm_sys_sw_port_count_clear},
+	{"link_mode_set",		tpm_sys_sw_link_mode_set},
+	{"link_mode_get",		tpm_sys_sw_link_mode_get},
+	{"link_state_get",		tpm_sys_sw_link_state_get},
+	{"rate_limit_set",		tpm_sys_sw_rate_limit_set},
+	{"rate_limit_get",		tpm_sys_sw_rate_limit_get},
+	{"mc_proto_rate_set",		tpm_sys_sw_mc_proto_rate_set},
+	{"mc_proto_rate_get",		tpm_sys_sw_mc_proto_rate_get},
+	{"mc_data_rate_set",		tpm_sys_sw_mc_data_rate_set},
+	{"mc_data_rate_get",		tpm_sys_sw_mc_data_rate_get},
+	{"bc_rate_set",			tpm_sys_sw_bc_rate_set},
+	{"bc_rate_get",			tpm_sys_sw_bc_rate_get},
+	{"port_mirror_set",		tpm_sys_sw_port_mirror_set},
+	{"port_mirror_get",		tpm_sys_sw_port_mirror_get},
+	{"loopback_set",		tpm_sys_sw_loopback_set},
+	{"loopback_get",		tpm_sys_sw_loopback_get},
+	{"mac_age_set",			tpm_sys_sw_mac_age_set},
+	{"mac_age_get",			tpm_sys_sw_mac_age_get},
+	{"mac_num_set",			tpm_sys_sw_mac_num_set},
+	{"mac_num_get",			tpm_sys_sw_mac_num_get},
+	{"mac_addr_add",		tpm_sys_sw_mac_addr_add},
+	{"mac_addr_del",		tpm_sys_sw_mac_addr_del},
+	{"mac_filter_mode_set",		tpm_sys_sw_mac_filter_mode_set},
+	{"mac_filter_mode_get",		tpm_sys_sw_mac_filter_mode_get},
+	{"mac_filter_entry_add",	tpm_sys_sw_mac_filter_entry_add},
+	{"mac_filter_entry_del",	tpm_sys_sw_mac_filter_entry_del},
+	{"mac_addr_clear",		tpm_sys_sw_mac_addr_clear},
+	{"mac_table_clear",		tpm_sys_sw_mac_table_clear},
+	{"port_qos_set",		tpm_sys_sw_port_qos_set},
+	{"port_qos_get",		tpm_sys_sw_port_qos_get},
+	{"mtu_set",			tpm_sys_sw_mtu_set},
+	{"mtu_get",			tpm_sys_sw_mtu_get},
+	{"stat1_get",			tpm_sys_sw_stat1_get},
+	{"stat2_get",			tpm_sys_sw_stat2_get},
+	{"stat3_get",			tpm_sys_sw_stat3_get},
+	{"stat_all_get",		tpm_sys_sw_stat_all_get},
+	{"head_mode_set",		tpm_sys_sw_head_mode_set},
+	{"head_mode_get",		tpm_sys_sw_head_mode_get},
+	{"atu_dump",			tpm_sys_sw_atu_dump},
+	{"vtu_dump",			tpm_sys_sw_vtu_dump},
+	{"vtu_shadow_dump",		tpm_sys_sw_vtu_shadow_dump},
+};
+static int num_store_name_funcs = sizeof(store_sysfs_name_func_ara)/sizeof(store_sysfs_name_func_ara[0]);
+
+static struct show_sysfs_name_func_t show_sysfs_name_func_ara[] = {
+	{"help_phy",		tpm_sys_sw_help_phy},
+	{"help_mac",		tpm_sys_sw_help_mac},
+	{"help_gen",		tpm_sys_sw_help_gen},
+	{"help",		tpm_sys_sw_help_debug},
+};
+static int num_show_name_funcs = sizeof(show_sysfs_name_func_ara)/sizeof(show_sysfs_name_func_ara[0]);
+
+
+static ssize_t tpm_cfg_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	const char                    *name = attr->attr.name;
+	struct store_sysfs_name_func_t *pnamefunc;
+	int                            indx;
+	bool                           found = false;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_store_name_funcs; indx++) {
+		pnamefunc = &store_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			(pnamefunc->sysfs_func)(buf, len);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return len;
+}
+
+static ssize_t tpm_cfg_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	const char            *name = attr->attr.name;
+	struct show_sysfs_name_func_t *pnamefunc;
+	int                    indx;
+	bool                   found = false;
+	int                    buflen = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	for (indx = 0; indx < num_show_name_funcs; indx++) {
+		pnamefunc = &show_sysfs_name_func_ara[indx];
+		if (!strcmp(name, pnamefunc->sysfs_name)) {
+			found = true;
+			buflen = (pnamefunc->sysfs_func)(buf);
+			break;
+		}
+	}
+
+	if (found == false)
+		TPM_OS_ERROR(TPM_SYSFS_MOD, "operation <%s> not found\n", attr->attr.name);
+
+	return buflen;
+}
+/******************************************************************************/
+/* ========================================================================== */
+/*                            Cfg SW Attributes                               */
+/* ========================================================================== */
+static DEVICE_ATTR(help_phy,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_mac,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help_gen,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(help,			S_IRUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ingress_mode_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(ingress_mode_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(pvid_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(pvid_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_del,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_filter_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vlan_filter_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(admin_state_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(admin_state_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(flow_control_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(flow_control_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(isolate_mask_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(isolate_mask_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(flood_mask_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(flood_mask_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(sw_count_clear,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(port_count_clear,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(link_mode_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(link_mode_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(link_state_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(rate_limit_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(rate_limit_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_proto_rate_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_proto_rate_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_data_rate_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mc_data_rate_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(bc_rate_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(bc_rate_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(port_mirror_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(port_mirror_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(loopback_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(loopback_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_age_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_age_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_num_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_num_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_addr_add,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_addr_del,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_filter_mode_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_filter_mode_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_filter_entry_add,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_filter_entry_del,	S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_addr_clear,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mac_table_clear,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(port_qos_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(port_qos_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mtu_set,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(mtu_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(stat1_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(stat2_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(stat3_get,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(stat_all_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(head_mode_set,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(head_mode_get,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(atu_dump,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vtu_dump,			S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+static DEVICE_ATTR(vtu_shadow_dump,		S_IWUSR,	tpm_cfg_show, tpm_cfg_store);
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM sysfs group                                                */
+/* ========================================================================== */
+
+static struct attribute *g_tpm_api_switch_sw_attrs[] = {
+	&dev_attr_help_phy.attr,
+	&dev_attr_help_mac.attr,
+	&dev_attr_help_gen.attr,
+	&dev_attr_ingress_mode_set.attr,
+	&dev_attr_ingress_mode_get.attr,
+	&dev_attr_pvid_set.attr,
+	&dev_attr_pvid_get.attr,
+	&dev_attr_vlan_set.attr,
+	&dev_attr_vlan_del.attr,
+	&dev_attr_vlan_get.attr,
+	&dev_attr_vlan_filter_set.attr,
+	&dev_attr_vlan_filter_get.attr,
+	&dev_attr_admin_state_set.attr,
+	&dev_attr_admin_state_get.attr,
+	&dev_attr_flow_control_set.attr,
+	&dev_attr_flow_control_get.attr,
+	&dev_attr_isolate_mask_set.attr,
+	&dev_attr_isolate_mask_get.attr,
+	&dev_attr_flood_mask_set.attr,
+	&dev_attr_flood_mask_get.attr,
+	&dev_attr_sw_count_clear.attr,
+	&dev_attr_port_count_clear.attr,
+	&dev_attr_link_mode_set.attr,
+	&dev_attr_link_mode_get.attr,
+	&dev_attr_link_state_get.attr,
+	&dev_attr_rate_limit_set.attr,
+	&dev_attr_rate_limit_get.attr,
+	&dev_attr_mc_proto_rate_set.attr,
+	&dev_attr_mc_proto_rate_get.attr,
+	&dev_attr_mc_data_rate_set.attr,
+	&dev_attr_mc_data_rate_get.attr,
+	&dev_attr_bc_rate_set.attr,
+	&dev_attr_bc_rate_get.attr,
+	&dev_attr_port_mirror_set.attr,
+	&dev_attr_port_mirror_get.attr,
+	&dev_attr_loopback_set.attr,
+	&dev_attr_loopback_get.attr,
+	&dev_attr_mac_age_set.attr,
+	&dev_attr_mac_age_get.attr,
+	&dev_attr_mac_num_set.attr,
+	&dev_attr_mac_num_get.attr,
+	&dev_attr_mac_addr_add.attr,
+	&dev_attr_mac_addr_del.attr,
+	&dev_attr_mac_filter_mode_set.attr,
+	&dev_attr_mac_filter_mode_get.attr,
+	&dev_attr_mac_filter_entry_add.attr,
+	&dev_attr_mac_filter_entry_del.attr,
+	&dev_attr_mac_addr_clear.attr,
+	&dev_attr_mac_table_clear.attr,
+	&dev_attr_port_qos_set.attr,
+	&dev_attr_port_qos_get.attr,
+	&dev_attr_mtu_set.attr,
+	&dev_attr_mtu_get.attr,
+	&dev_attr_stat1_get.attr,
+	&dev_attr_stat2_get.attr,
+	&dev_attr_stat3_get.attr,
+	&dev_attr_stat_all_get.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_api_switch_sw_group = {
+	.name = "switch",
+	.attrs = g_tpm_api_switch_sw_attrs
+};
+
+static struct attribute *g_tpm_debug_switch_sw_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_head_mode_set.attr,
+	&dev_attr_head_mode_get.attr,
+	&dev_attr_atu_dump.attr,
+	&dev_attr_vtu_dump.attr,
+	&dev_attr_vtu_shadow_dump.attr,
+	NULL
+};
+
+static struct attribute_group g_tpm_debug_switch_sw_group = {
+	.name = "switch",
+	.attrs = g_tpm_debug_switch_sw_attrs
+};
+
+
+/******************************************************************************/
+/* ========================================================================== */
+/*             TPM CFG SYS FS INIT                                            */
+/* ========================================================================== */
+
+/*******************************************************************************
+* tpm_sysfs_switch_init
+*
+* DESCRIPTION: The routine will initialize TPM switch sysfs system.
+*
+* INPUTS:
+*	None
+* OUTPUTS:
+*	None
+* RETURNS:
+* On success, the function returns TPM_OK. On error different types are returned
+* according to the case - see tpm_error_code_t.
+*
+* COMMENTS:
+*	None
+*******************************************************************************/
+int tpm_sysfs_switch_init(void)
+{
+	int rc;
+
+	/* Initialize switch API sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_API, NULL, &g_tpm_api_switch_sw_group);
+	IF_ERROR_STR(TPM_INIT_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	/* Initialize switch debug sysfs */
+	rc = tpm_sysfs_register(TPM_SYSFS_TYPE_DEBUG, NULL, &g_tpm_debug_switch_sw_group);
+	IF_ERROR_STR(TPM_SYSFS_MOD, rc, "Fail to call tpm_sysfs_register\n");
+
+	return TPM_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_utils.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_utils.c
new file mode 100644
index 0000000..b64399b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/src/sysfs/tpm_sysfs_utils.c
@@ -0,0 +1,1023 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	* Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	* Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	* Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+/***********************/
+/* c file declarations */
+/***********************/
+#include "tpm_header.h"
+#include "tpm_sysfs_utils.h"
+
+
+/********************************************************************************/
+/*			Miscellaneous						*/
+/********************************************************************************/
+/*******************************************************************************
+* print_horizontal_line
+*
+* DESCRIPTION:
+*	This function prints a horizontal line using the passes sign and places CRLF
+* INPUTS:
+*	char_count  - the horizontal line length
+*	char_val  - the horizontal line character to use
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	int
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+void print_horizontal_line(unsigned int char_count, char *char_val)
+{
+	unsigned int cnt;
+	for (cnt = 0; cnt < char_count; cnt++)
+		printk(KERN_INFO "%s", char_val);
+	printk(KERN_INFO "\n");
+}
+
+
+/*******************************************************************************
+* tpm_sfs_print_ipv6_pref_suff
+*
+* DESCRIPTION:
+*	This function prints the IPv6 address suffix/prefix
+* INPUTS:
+*	ipv6  - the IP address suffix/prefix
+*
+* OUTPUTS:
+*	None
+*
+* RETURNS:
+*	None
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+void tpm_sfs_print_ipv6_pref_suff(unsigned char	ipv6[8])
+{
+	int i;
+
+	for (i = 0; i < 5; i += 2)
+		printk(KERN_INFO "%02x%02x:", ipv6[i], ipv6[i + 1]);
+	printk(KERN_INFO "%02x%02x", ipv6[i], ipv6[i + 1]);
+}
+
+
+/********************************************************************************/
+/*			String-int map lookups				*/
+/********************************************************************************/
+
+
+/*******************************************************************************
+* map_string_to_value
+*
+* DESCRIPTION:
+*	This function maps a string in a given map table to its value
+* INPUTS:
+*	buf	- buffer with parameter string
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	int
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+static bool map_string_to_value(struct string_enum_pair_db_t *db, char *str, unsigned int *value)
+{
+	int		indx;
+	struct string_enum_pair_t *pentry;
+
+	for (indx = 0; indx < db->num_entries; indx++) {
+		pentry = &db->string_enum_pair[indx];
+		if (strcmp(str, pentry->str) == 0) {
+			*value = pentry->value;
+			return TPM_TRUE;
+		}
+	}
+	return TPM_FALSE;
+}
+
+/*******************************************************************************
+* map_value_to_string
+*
+* DESCRIPTION:
+*	This function maps a value to string in a given map table
+* INPUTS:
+*	value	- int enumaeration
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	char *. The matching string or "<unknown>"
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+static char *map_value_to_string(struct string_enum_pair_db_t *db, int value)
+{
+	int		indx;
+	struct string_enum_pair_t *pentry;
+	static char *unknown_str = "<unknown>";
+
+	for (indx = 0; indx < db->num_entries; indx++) {
+		pentry = &db->string_enum_pair[indx];
+		if (value == pentry->value)
+			return pentry->str;
+	}
+	return unknown_str;
+}
+
+/*--------------------------------------------------------------------------*/
+
+static struct string_enum_pair_t bool_string_enum_pair_ara[] = {
+	{TPM_FALSE,  "false"},
+	{TPM_TRUE,   "true" },
+};
+
+static struct string_enum_pair_db_t  bool_string_enum_pair_db = {
+	bool_string_enum_pair_ara,
+	sizeof(bool_string_enum_pair_ara)/sizeof(bool_string_enum_pair_ara[0])
+};
+
+bool get_bool_value(char *str, unsigned int *value)
+{
+	return map_string_to_value(&bool_string_enum_pair_db, str, value);
+}
+
+/*--------------------------------------------------------------------------*/
+
+static struct string_enum_pair_t vlan_op_string_enum_pair_ara[] = {
+	{0,	"none"		},
+	{1,	"ext_tag_mod"	 },
+	{2,	"ext_tag_del"	 },
+	{3,	"ext_tag_ins"	 },
+	{4,	"ext_tag_mod_ins"	 },
+	{5,	"ins_2tag"		},
+	{6,	"mod_2tag"		},
+	{7,	"swap_tags"	},
+	{8,	"del_2tags"	},
+	{9,	"int_tag_mod"	 },
+	{10,   "ext_tag_del_int_mod" },
+};
+
+static struct string_enum_pair_db_t  vlan_op_string_enum_pair_db = {
+	vlan_op_string_enum_pair_ara,
+	sizeof(vlan_op_string_enum_pair_ara)/sizeof(vlan_op_string_enum_pair_ara[0])
+};
+
+bool get_vlan_op_value(char *str, unsigned int *value)
+{
+	return map_string_to_value(&vlan_op_string_enum_pair_db, str, value);
+}
+
+char *tpm_utils_vlan_op_str_get(int value)
+{
+	return map_value_to_string(&vlan_op_string_enum_pair_db, value);
+}
+
+/*--------------------------------------------------------------------------*/
+
+char *get_tpm_err_str(int value)
+{
+	return "error";
+}
+
+static struct tpm_enum_str_t g_enum_flow_name[] = {
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_PON,	"IPV4_UC_RTR_NFRAG_PON"	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_NFRAG_NPON,	"IPV4_UC_RTR_NFRAG_NPON"	},
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_PON,	"IPV4_UC_RTR_FRAG_PON"	 },
+	{TPM_MNG_FLOW_ID_IPV4_UC_RTR_FRAG_NPON,	"IPV4_UC_RTR_FRAG_NPON"	},
+	{TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_PON,	  "NON_IP_MTM_UNTAG_PON"	 },
+	{TPM_MNG_FLOW_ID_NON_IP_MTM_UNTAG_NPON,	 "NON_IP_MTM_UNTAG_NPON"	},
+	{TPM_MNG_FLOW_ID_IPV4_MC_UNTAG_PON,		 "IPV4_MC_UNTAG_PON"		},
+	{TPM_MNG_FLOW_ID_IPV4_MC_TAG_PON,		"IPV4_MC_TAG_PON"		  },
+	{TPM_MNG_FLOW_ID_IPV4_MC_TAG_NPON,		  "IPV4_MC_TAG_NPON"		 },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_PON,   "IPV4_UC_BRG_NFRAG_UNTAG_PON"  },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_PON,	"IPV4_UC_BRG_NFRAG_STAG_PON"   },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_PON,	"IPV4_UC_BRG_NFRAG_DTAG_PON"   },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_UNTAG_NPON,  "IPV4_UC_BRG_NFRAG_UNTAG_NPON" },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_STAG_NPON,   "IPV4_UC_BRG_NFRAG_STAG_NPON"  },
+	{TPM_MNG_FLOW_ID_IPV4_UC_BRG_NFRAG_DTAG_NPON,   "IPV4_UC_BRG_NFRAG_DTAG_NPON"  },
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_PON,	"NT_IP_BRG_UNTAG_PON"	 },
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_PON,		"NOT_IP_BRG_TAG_PON"	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_PON,	"NOT_IP_BRG_DTAG_PON"	  },
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_UNTAG_NPON,	"NOT_IP_BRG_UNTAG_NPON"	},
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_TAG_NPON,	"NOT_IP_BRG_TAG_NPON"	  },
+	{TPM_MNG_FLOW_ID_NOT_IP_BRG_DTAG_NPON,	"NOT_IP_BRG_DTAG_NPON"	 },
+	{TPM_MNG_FLOW_ID_NOT_IP_ARP_PON,		"NOT_IP_ARP_PON"		},
+	{TPM_MNG_FLOW_ID_NOT_IP_ARP_NPON,		"NOT_IP_ARP_NPON"		},
+	{TPM_MNG_FLOW_ID_UNEXPECTED_PKT_PON,		"UNEXPECTED_PKT_PON"	},
+	{TPM_MNG_FLOW_ID_UNEXPECTED_PKT_NPON,	"UNEXPECTED_PKT_NPON"	  },
+	{TPM_MNG_FLOW_ID_LOOPBACK_PORT ,		 "LOOPBACK_PORT"		},
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_PON,	 "IPV6_UC_RTR_NFRAG_NEX_PON"	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_NFRAG_NEX_NPON,	"IPV6_UC_RTR_NFRAG_NEX_NPON"	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_PON,		"IPV6_UC_RTR_FRAG_NEX_PON"	  },
+	{TPM_MNG_FLOW_ID_IPV6_UC_RTR_FRAG_NEX_NPON,	"IPV6_UC_RTR_FRAG_NEX_NPON"	 },
+	{TPM_MNG_FLOW_ID_IPV6_MC_UNTAG_PON,		"IPV6_MC_UNTAG_PON"		 },
+	{TPM_MNG_FLOW_ID_IPV6_MC_TAG_PON,			"IPV6_MC_TAG_PON"		},
+	{TPM_MNG_FLOW_ID_IPV6_MC_TAG_NPON,			"IPV6_MC_TAG_NPON"		  },
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_PON, "IPV6_UC_BRG_NFRAG_UNTAG_PON"   },
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_PON,	"IPV6_UC_BRG_NFRAG_STAG_PON"	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_PON,	"IPV6_UC_BRG_NFRAG_DTAG_PON"	},
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_UNTAG_NPON,	"IPV6_UC_BRG_NFRAG_UNTAG_NPON"  },
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_STAG_NPON,	"IPV6_UC_BRG_NFRAG_STAG_NPON"   },
+	{TPM_MNG_FLOW_ID_IPV6_UC_BRG_NFRAG_DTAG_NPON,	"IPV6_UC_BRG_NFRAG_DTAG_NPON"   },
+	{TPM_MNG_FLOW_ID_MAX,				"MAX"			},
+};
+
+static struct tpm_enum_str_t g_enum_eng_name[] = {
+	{TPM_ENGINE_C2,	"C2"},
+	{TPM_ENGINE_C3_A,	"C3_A"},
+	{TPM_ENGINE_C3_B,	"C3_B"},
+	{TPM_ENGINE_C4,	"C4"},
+};
+
+static struct tpm_enum_str_t g_enum_cap_type_name[] = {
+	{TPM_API_PUBLIC_CLS,		"PUBLIC_CLS"},
+	{TPM_API_PUBLIC_EXCT_EXCPT,	"PUBLIC_EXCT_EXCPT"},
+	{TPM_API_PRIVATE_CNM,		"PRIVATE_CNM"},
+	{TPM_API_PUBLIC_FLTR,		"PUBLIC_FLTR"},
+	{TPM_API_PRIVATE_CLS,		"PRIVATE_CLS"},
+	{TPM_API_PRIVATE_EXCT,		"PRIVATE_EXCT"},
+	{TPM_API_PRIVATE_EXCT_DEFAULT,	"PRIVATE_EXCT_DEFAULT"},
+	{TPM_API_PRIVATE_MC_US,	"PRIVATE_MC_US"},
+	{TPM_API_PRIVATE_MC_DS,	"PRIVATE_MC_DS"},
+	{TPM_API_PRIVATE_CPU_Q,	"PRIVATE_CPU_Q"},
+
+};
+static struct tpm_enum_str_t g_enum_vlan_nmu_name[] = {
+	{TPM_NO_VLAN		, "NO_VLAN"},
+	{TPM_SINGLE_VLAN	, "SINGLE_VLAN"},
+	{TPM_DOUBLE_VLAN	, "DOUBLE_VLAN"},
+	{TPM_TRIPLE_VLAN	, "TRIPLE_VLAN"},
+	{TPM_NOT_DOUBLE_VLAN	, "NOT_DOUBLE_VLAN"},
+	{TPM_ANY_VLAN		, "ANY_VLAN"},
+};
+
+
+static struct tpm_enum_str_t g_enum_valid[] = {
+	{ 0,		"no "},
+	{ 1,		"yes"},
+};
+
+static struct tpm_enum_str_t g_enum_field_op[] = {
+	{ TPM_CNM_OP_EQUAL,		"EQUAL"},
+	{ TPM_CNM_OP_NOT_EQUAL,		"NOT_EQUAL"},
+	{ TPM_CNM_OP_LESS_EQUAL,	"LESS_EQUAL"},
+	{ TPM_CNM_OP_GREATER_EQUAL,	"GREATER_EQUAL"},
+};
+
+static struct tpm_enum_str_t g_enum_port_class[] = {
+	{ TPM_CLASS_PP_PORT_BM,		"PP"},
+	{ TPM_CLASS_SWITCH_PORT_BM,	"SW"},
+	{ TPM_CLASS_VIRT_PORT,		"GEM"},
+};
+
+static struct tpm_enum_str_t g_enum_qos_type[] = {
+	{ TPM_QOS_NONE,		"NONE"},
+	{ TPM_QOS_DSCP,		"DSCP"},
+	{ TPM_QOS_PBIT,		"PBIT"},
+};
+
+static struct tpm_enum_str_t g_enum_pp_port[] = {
+	{ TPM_PP_DROP,		"DROP"},
+	{ TPM_PP_GMAC0,		"GMAC0"},
+	{ TPM_PP_GMAC1,		"GMAC1"},
+	{ TPM_PP_PMAC,		"PMAC"},
+	/*{ TPM_PP_LPBK,	"LPBK"},*/
+	{ TPM_PP_CPU,		"CPU"},
+};
+
+static struct tpm_enum_str_t g_enum_gmac_idx[] = {
+	{ TPM_GMAC0_IDX,	"GMAC0"},
+	{ TPM_GMAC1_IDX,	"GMAC1"},
+	{ TPM_LPK_MAC_IDX,	"LPK_MAC"},
+	{ TPM_PMAC_IDX,		"PMAC"},
+};
+static struct tpm_enum_str_t g_tpm_gmac_enum_idx[] = {
+	{ TPM_ENUM_GMAC_0,	"GMAC0"},
+	{ TPM_ENUM_GMAC_1,	"GMAC1"},
+	{ TPM_ENUM_PMAC,	"PMAC"},
+};
+
+
+static struct tpm_enum_str_t g_enum_color[] = {
+	{ TPM_COL_GREEN,	"GRN"},
+	{ TPM_COL_YELLOW,	"YLW"},
+};
+
+static struct tpm_enum_str_t g_enum_field_match[] = {
+	{ TPM_MATCH_ETH_DST,		"ETH_DST"	},
+	{ TPM_MATCH_ETH_SRC,		"ETH_SRC"	},
+	{ TPM_MATCH_VID_OUTER,		"VID_OUTER"	},
+	{ TPM_MATCH_PBITS_OUTER,	"PBITS_OUTER"	},
+	{ TPM_MATCH_VID_INNER,		"VID_INNER"	},
+	{ TPM_MATCH_PBITS_INNER,	"PBITS_INNER"	},
+	{ TPM_MATCH_ETH_TYPE,		"ETH_TYPE"	},
+	{ TPM_MATCH_PPPOE_PROTO,	"PPPOE_PROTO"	},
+	{ TPM_MATCH_PPPOE_SES,		"PPPOE_SES"	},
+	{ TPM_MATCH_IPV4_PKT,		"IPV4_PKT"	},
+	{ TPM_MATCH_IPV6_PKT,		"IPV6_PKT"	},
+	{ TPM_MATCH_IP_SRC,		"IP_SRC"	},
+	{ TPM_MATCH_IP_DST,		"IP_DST"	},
+	{ TPM_MATCH_IP_DSCP,		"IP_DSCP"	},
+	{ TPM_MATCH_IPV6_FLBL,		"IPV6_FLBL"	},
+	{ TPM_MATCH_IP_PROTO,		"IP_PROTO"	},
+	{ TPM_MATCH_IP_VERSION,		"IP_VERSION"	},
+	{ TPM_MATCH_L4_SRC,		"L4_SRC"	},
+	{ TPM_MATCH_L4_DST,		"L4_DST"	},
+	{ TPM_MATCH_IPV6_PREF,		"IPV6_PREF"	},
+	{ TPM_MATCH_IPV6_SUFF,		"IPV6_SUFF"	},
+	{ TPM_MATCH_ARP_TRGT_IP_ADDR,	"ARP_TRGT_IP_ADDR"},
+};
+
+static struct tpm_enum_str_t g_enum_field_id[] = {
+	{ MH_FIELD_ID,			"MV_HEADER"	},
+	{ GEM_PORT_ID_FIELD_ID,		"GEM_PORT"	},
+	{ MH_UNTAGGED_PRI_FIELD_ID,	"MH_PRI"	},
+	{ MAC_DA_FIELD_ID,		"MAC_DA"	},
+	{ MAC_SA_FIELD_ID,		"MAC_SA"	},
+	{ OUT_VLAN_PRI_FIELD_ID,	"OUT_VLAN_PRI"	},
+	{ OUT_VLAN_ID_FIELD_ID,		"OUT_VLAN_ID"	},
+	{ IN_VLAN_ID_FIELD_ID,		"IN_VLAN_ID"	},
+	{ ETH_TYPE_FIELD_ID,		"ETH_TYPE"	},
+	{ PPPOE_FIELD_ID,		"PPPOE_SESS"	},
+	{ IP_VER_FIELD_ID,		"IP_VER"	},
+	{ IPV4_DSCP_FIELD_ID,		"IPV4_DSCP"	},
+	{ IPV4_ECN_FIELD_ID,		"IPV4_ECN"	},
+	{ IPV4_LEN_FIELD_ID,		"IPV4_LEN"	},
+	{ IPV4_TTL_FIELD_ID,		"IPVx_TTL_HOPL"	},
+	{ IPV4_PROTO_FIELD_ID,		"IPVx_PROTO"	},
+	{ IPV4_SA_FIELD_ID,		"IPV4_SA"	},
+	{ IPV4_DA_FIELD_ID,		"IPV4_DA"	},
+	{ IPV6_DSCP_FIELD_ID,		"IPV6_DSCP"	},
+	{ IPV6_ECN_FIELD_ID,		"IPV6_ECN"	},
+	{ IPV6_FLOW_LBL_FIELD_ID,	"IPV6_FLOW_LBL"	},
+	{ IPV6_PAYLOAD_LEN_FIELD_ID,	"IPV6_PL_LEN"	},
+	{ IPV6_NH_FIELD_ID,		"IPV6_NH"	},
+	{ IPV6_SA_FIELD_ID,		"IPV6_SA"	},
+	{ IPV6_SA_PREF_FIELD_ID,	"IPV6_SA_PREF"	},
+	{ IPV6_SA_SUFF_FIELD_ID,	"IPV6_SA_SUFF"	},
+	{ IPV6_DA_FIELD_ID,		"IPV6_DA"	},
+	{ IPV6_DA_PREF_FIELD_ID,	"IPV6_DA_PREF"	},
+	{ IPV6_DA_SUFF_FIELD_ID,	"IPV6_DA_SUFF"	},
+	{ L4_SRC_FIELD_ID,		"L4_SRC_PORT"	},
+	{ L4_DST_FIELD_ID,		"L4_DST_PORT"	},
+	{ TCP_FLAGS_FIELD_ID,		"TCP_FLAGS"	},
+	{ ARP_IPV4_DA_FIELD_ID,		"ARP_IPV4_DA"	}
+};
+
+/* source port type string */
+static struct tpm_enum_str_t g_tpm_port_type[] = {
+	{TPM_SRC_PORT_TYPE_PHY,	"PHY"},
+	{TPM_SRC_PORT_TYPE_UNI,	"UNI"},
+	{TPM_SRC_PORT_TYPE_VIR,	"VIRT"}
+};
+
+/* layer 4 type string */
+static struct tpm_enum_str_t g_tpm_l4_type[] = {
+	{TPM_L4_TYPE_TCP,	"TCP"},
+	{TPM_L4_TYPE_UDP,	"UDP"},
+};
+
+/* QoS action string */
+static struct tpm_enum_str_t g_tpm_qos_action_type[] = {
+	{TPM_COLOR_ACTION_TYPE_NO_UPDT,		"No_Updt"},
+	{TPM_COLOR_ACTION_TYPE_NO_UPDT_LOCK,	"No_Updt_L"},
+	{TPM_COLOR_ACTION_TYPE_GREEN,		"Green"},
+	{TPM_COLOR_ACTION_TYPE_YELLOW,		"Yellow"},
+	{TPM_COLOR_ACTION_TYPE_RED,		"Red"},
+	{TPM_COLOR_ACTION_TYPE_RED_LOCK,	"Red_L"},
+};
+
+/* common action string */
+static struct tpm_enum_str_t g_tpm_common_action_type[] = {
+	{TPM_ACTION_TYPE_NO_UPDT,	"No_Updt"},
+	{TPM_ACTION_TYPE_NO_UPDT_LOCK,	"No_Updt_L"},
+	{TPM_ACTION_TYPE_UPDT,		"Update"},
+	{TPM_ACTION_TYPE_UPDT_LOCK,	"Update_L"},
+};
+
+/* flow ID action string */
+static struct tpm_enum_str_t g_tpm_flow_id_action_type[] = {
+	{TPM_ACTION_FLOWID_DISABLE,	"Disable"},
+	{TPM_ACTION_FLOWID_ENABLE,	"Enable"},
+};
+
+/* forwarding action string */
+static struct tpm_enum_str_t g_tpm_frwd_action_type[] = {
+	{TPM_FRWD_ACTION_TYPE_NO_UPDT,			"No_Updt"},
+	{TPM_FRWD_ACTION_TYPE_NO_UPDT_LOCK,		"No_Updt_L"},
+	{TPM_FRWD_ACTION_TYPE_SWF,			"SWF"},
+	{TPM_FRWD_ACTION_TYPE_SWF_LOCK,			"SWF_L"},
+	{TPM_FRWD_ACTION_TYPE_HWF,			"HWF"},
+	{TPM_FRWD_ACTION_TYPE_HWF_LOCK,			"HWF_L"},
+	{TPM_FRWD_ACTION_TYPE_HWF_LOW_LATENCY,		"HWF_Lat"},
+	{TPM_FRWD_ACTION_TYPE_HWF_LOW_LATENCY_LOCK,	"HWF_Lat_L"},
+};
+
+/* scan mode */
+static struct tpm_enum_str_t g_tpm_scan_mode[] = {
+	{TPM_SCAN_BELOW_THRESHOLD,	"below threshold"},
+	{TPM_SCAN_ABOVE_THRESHOLD,	"above threshold"},
+};
+
+/* MC Tbl forward */
+static struct tpm_enum_str_t tpm_mct_frwd_mode[] = {
+	{TPM_MC_FRWD_TO_CPU,	"TO_CPU"},
+	{TPM_MC_FRWD_TO_TX,	"TO_TXP"},
+};
+
+char *tpm_utils_port_type_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_port_type, TPM_MEMBER_NUM(g_tpm_port_type), value);
+}
+
+char *tpm_utils_l4_type_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_l4_type, TPM_MEMBER_NUM(g_tpm_l4_type), value);
+}
+
+char *tpm_utils_qos_action_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_qos_action_type, TPM_MEMBER_NUM(g_tpm_qos_action_type), value);
+}
+
+char *tpm_utils_common_action_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_common_action_type, TPM_MEMBER_NUM(g_tpm_common_action_type), value);
+}
+
+char *tpm_utils_flow_id_action_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_flow_id_action_type, TPM_MEMBER_NUM(g_tpm_flow_id_action_type), value);
+}
+
+char *tpm_utils_frwd_action_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_frwd_action_type, TPM_MEMBER_NUM(g_tpm_frwd_action_type), value);
+}
+
+char *tpm_utils_scan_mode_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_scan_mode, TPM_MEMBER_NUM(g_tpm_scan_mode), value);
+}
+
+char *tpm_utils_flow_id_str_get(int value)
+{
+	return lookup_enum_str(g_enum_flow_name, TPM_MEMBER_NUM(g_enum_flow_name), value);
+}
+
+char *tpm_utils_eng_no_str_get(int value)
+{
+	return lookup_enum_str(g_enum_eng_name, TPM_MEMBER_NUM(g_enum_eng_name), value);
+}
+
+char *tpm_utils_cap_type_str_get(int value)
+{
+	return lookup_enum_str(g_enum_cap_type_name, TPM_MEMBER_NUM(g_enum_cap_type_name), value);
+}
+
+char *tpm_utils_vlan_num_str_get(int value)
+{
+	return lookup_enum_str(g_enum_vlan_nmu_name, TPM_MEMBER_NUM(g_enum_vlan_nmu_name), value);
+}
+
+char *tpm_utils_valid_str_get(int value)
+{
+	return lookup_enum_str(g_enum_valid, TPM_MEMBER_NUM(g_enum_valid), value);
+}
+
+char *tpm_utils_port_class_str_get(int value)
+{
+	return lookup_enum_str(g_enum_port_class, TPM_MEMBER_NUM(g_enum_port_class), value);
+}
+char *tpm_utils_field_op_str_get(int value)
+{
+	return lookup_enum_str(g_enum_field_op, TPM_MEMBER_NUM(g_enum_field_op), value);
+}
+
+char *tpm_utils_qos_type_str_get(int value)
+{
+	return lookup_enum_str(g_enum_qos_type, TPM_MEMBER_NUM(g_enum_qos_type), value);
+}
+
+char *tpm_utils_pp_port_str_get(int value)
+{
+	return lookup_enum_str(g_enum_pp_port, TPM_MEMBER_NUM(g_enum_pp_port), value);
+}
+
+char *tpm_utils_gmac_idx_str_get(int value)
+{
+	return lookup_enum_str(g_enum_gmac_idx, TPM_MEMBER_NUM(g_enum_gmac_idx), value);
+}
+
+char *tpm_utils_gmac_enum_str_get(int value)
+{
+	return lookup_enum_str(g_tpm_gmac_enum_idx, TPM_MEMBER_NUM(g_tpm_gmac_enum_idx), value);
+}
+
+char *tpm_utils_color_str_get(int value)
+{
+	return lookup_enum_str(g_enum_color, TPM_MEMBER_NUM(g_enum_color), value);
+}
+
+char *tpm_utils_field_match_str_get(int value)
+{
+	return lookup_enum_str(g_enum_field_match, TPM_MEMBER_NUM(g_enum_field_match), value);
+}
+
+char *tpm_utils_field_id_str_get(int value)
+{
+	return lookup_enum_str(g_enum_field_id, TPM_MEMBER_NUM(g_enum_field_id), value);
+}
+
+char *tpm_utils_mc_frwd_str_get(int value)
+{
+	return lookup_enum_str(tpm_mct_frwd_mode, TPM_MEMBER_NUM(tpm_mct_frwd_mode), value);
+}
+
+/*******************************************************************************
+
+* parse_ipv4_address
+*
+* DESCRIPTION:
+*	This function parses IPV4 address
+* INPUTS:
+*	buf	- buffer with parameter string
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	bool
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+bool parse_ipv4_address(char *buf, unsigned int *ipv4addr_parts)
+{
+	if (4 == sscanf(buf, "%d.%d.%d.%d", &ipv4addr_parts[0], &ipv4addr_parts[1], &ipv4addr_parts[2], &ipv4addr_parts[3])) {
+		if (ipv4addr_parts[0] <= 255 && ipv4addr_parts[1] <= 255 && ipv4addr_parts[2] <= 255 && ipv4addr_parts[3] <= 255)
+			return TPM_TRUE;
+	}
+	return TPM_FALSE;
+}
+
+/*******************************************************************************
+* parse_ipv6_address
+*
+* DESCRIPTION:
+*	This function parses IPV4 address
+* INPUTS:
+*	buf	- buffer with parameter string
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	bool
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+bool parse_ipv6_address(char *buf, unsigned int *ipv6addr_parts)
+{
+	if (8 == sscanf(buf, "%x:%x:%x:%x:%x:%x:%x:%x",
+			&ipv6addr_parts[0], &ipv6addr_parts[2],  &ipv6addr_parts[4],  &ipv6addr_parts[6],
+			&ipv6addr_parts[8], &ipv6addr_parts[10], &ipv6addr_parts[12], &ipv6addr_parts[14])) {
+		if (ipv6addr_parts[0] <= 0xFFFF && ipv6addr_parts[2] <= 0xFFFF  && ipv6addr_parts[4] <= 0xFFFF  &&
+			ipv6addr_parts[6] <= 0xFFFF && ipv6addr_parts[8] <= 0xFFFF &&
+			ipv6addr_parts[10] <= 0xFFFF && ipv6addr_parts[12] <= 0xFFFF &&
+			ipv6addr_parts[14] <= 0xFFFF) {
+			/* Note the order */
+			ipv6addr_parts[1]  = ipv6addr_parts[0]  & 0xFF;   ipv6addr_parts[0]  = ipv6addr_parts[0]  >> 8;
+			ipv6addr_parts[3]  = ipv6addr_parts[2]  & 0xFF;   ipv6addr_parts[2]  = ipv6addr_parts[2]  >> 8;
+			ipv6addr_parts[5]  = ipv6addr_parts[4]  & 0xFF;   ipv6addr_parts[4]  = ipv6addr_parts[4]  >> 8;
+			ipv6addr_parts[7]  = ipv6addr_parts[6]  & 0xFF;   ipv6addr_parts[6]  = ipv6addr_parts[6]  >> 8;
+			ipv6addr_parts[9]  = ipv6addr_parts[8]  & 0xFF;   ipv6addr_parts[8]  = ipv6addr_parts[8]  >> 8;
+			ipv6addr_parts[11] = ipv6addr_parts[10] & 0xFF;   ipv6addr_parts[10] = ipv6addr_parts[10] >> 8;
+			ipv6addr_parts[13] = ipv6addr_parts[12] & 0xFF;   ipv6addr_parts[12] = ipv6addr_parts[12] >> 8;
+			ipv6addr_parts[15] = ipv6addr_parts[14] & 0xFF;   ipv6addr_parts[14] = ipv6addr_parts[14] >> 8;
+
+			return TPM_TRUE;
+		}
+	}
+	return TPM_FALSE;
+}
+
+/*******************************************************************************
+* parse_mac_address
+*
+* DESCRIPTION:
+*	This function parses MAC address
+* INPUTS:
+*	buf	- buffer with parameter string
+*
+* OUTPUTS:
+	NONE.
+*
+* RETURNS:
+*	bool
+*
+* COMMENTS:
+*	None.
+*
+*******************************************************************************/
+bool parse_mac_address(char *buf, unsigned int *macaddr_parts)
+{
+	if (6 == sscanf(buf, "%x:%x:%x:%x:%x:%x", &macaddr_parts[0], &macaddr_parts[1], &macaddr_parts[2],
+			 &macaddr_parts[3], &macaddr_parts[4], &macaddr_parts[5])) {
+		if (macaddr_parts[0] <= 255 && macaddr_parts[1] <= 255 && macaddr_parts[2] <= 255 &&
+			 macaddr_parts[3] <= 255 && macaddr_parts[4] <= 255 && macaddr_parts[5] <= 255) {
+			return TPM_TRUE;
+		}
+	}
+	return TPM_FALSE;
+}
+
+
+/********************************************************************************/
+/*			  Packet Forward rule table and API		*/
+/********************************************************************************/
+
+static struct tpmcfg_frwd_entry_t  tpm_sysfs_frwd_table[DB_TPMCFG_MAX_ENTRIES];
+
+static struct tpm_generic_rule_db_t tpm_frwd_rule_db = {
+	.max_num_entries	= DB_TPMCFG_MAX_ENTRIES,
+	.num_entries	= 0,
+	.size_entry	 = sizeof(struct tpmcfg_frwd_entry_t),
+	.entryAra	= tpm_sysfs_frwd_table
+};
+
+
+
+/********************************************************************************/
+/*			  CnM field op rule table and API		*/
+/********************************************************************************/
+
+static struct tpmcfg_cnm_field_op_entry_t  tpm_sysfs_cnm_field_op_table[DB_TPMCFG_MAX_ENTRIES];
+
+static struct tpm_generic_rule_db_t tpm_cnm_field_op_rule_db = {
+	.max_num_entries	= DB_TPMCFG_MAX_ENTRIES,
+	.num_entries	= 0,
+	.size_entry	 = sizeof(struct tpmcfg_cnm_field_op_entry_t),
+	.entryAra	= tpm_sysfs_cnm_field_op_table
+};
+
+
+/********************************************************************************/
+/*			  QOS key DB													*/
+/********************************************************************************/
+
+static struct tpmcfg_qos_entry_t  tpm_sysfs_qos_table[DB_TPMCFG_MAX_ENTRIES];
+
+static struct tpm_generic_rule_db_t tpm_qos_rule_db = {
+	.max_num_entries	= DB_TPMCFG_MAX_ENTRIES,
+	.num_entries	= 0,
+	.size_entry	 = sizeof(struct tpmcfg_qos_entry_t),
+	.entryAra	= tpm_sysfs_qos_table
+};
+
+
+void init_tpm_pkt_frwd_db(void)
+{
+	struct tpmcfg_frwd_entry_t *pentry = (struct tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++)
+		pentry->name[0] = 0;
+}
+
+
+struct tpmcfg_qos_entry_t *find_tpm_pkt_qos_entry_by_name(char *name)
+{
+	struct tpmcfg_qos_entry_t *pentry = (struct tpmcfg_qos_entry_t *)tpm_qos_rule_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_qos_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+struct tpmcfg_qos_entry_t *find_free_tpm_pkt_qos_entry(void)
+{
+	struct tpmcfg_qos_entry_t *pentry = (struct tpmcfg_qos_entry_t *)tpm_qos_rule_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_qos_rule_db.max_num_entries; indx++, pentry++) {
+		if (pentry->name[0] == 0)
+			return pentry;
+	}
+	return 0;
+}
+struct tpmcfg_frwd_entry_t *find_tpm_pkt_frwd_entry_by_name(char *name)
+{
+	struct tpmcfg_frwd_entry_t *pentry = (struct tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+struct tpmcfg_frwd_entry_t *find_free_tpm_pkt_frwd_entry(void)
+{
+	struct tpmcfg_frwd_entry_t *pentry = (struct tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
+	int		 indx;
+	int		 i;
+
+	for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++) {
+		if (pentry->name[0] == 0) {
+			for (i = 0; i < TPM_ACT_NUM_MAX; i++)
+				memset(&pentry->frwd[i], 0, sizeof(pentry->frwd[i]));
+			return pentry;
+		}
+	}
+	return 0;
+}
+
+bool	del_tpm_pkt_frwd_entry_by_name(char *name)
+{
+	struct tpmcfg_frwd_entry_t *pentry = (struct tpmcfg_frwd_entry_t *)tpm_frwd_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_frwd_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0) {
+			memset(&pentry->frwd, 0, sizeof(pentry->frwd));
+			pentry->name[0] = 0;
+			return TPM_TRUE;
+		};
+	}
+	return TPM_FALSE;
+}
+
+
+void init_tpm_cnm_field_op_db(void)
+{
+	struct tpmcfg_cnm_field_op_entry_t *pentry = (struct tpmcfg_cnm_field_op_entry_t *)tpm_cnm_field_op_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_cnm_field_op_rule_db.max_num_entries; indx++, pentry++)
+		pentry->name[0] = 0;
+}
+
+struct tpmcfg_cnm_field_op_entry_t *find_tpm_cnm_field_op_entry_by_name(char *name)
+{
+	struct tpmcfg_cnm_field_op_entry_t *pentry = (struct tpmcfg_cnm_field_op_entry_t *)tpm_cnm_field_op_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_cnm_field_op_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+struct tpmcfg_cnm_field_op_entry_t *find_free_tpm_cnm_field_op_entry(void)
+{
+	struct tpmcfg_cnm_field_op_entry_t *pentry = (struct tpmcfg_cnm_field_op_entry_t *)tpm_cnm_field_op_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_cnm_field_op_rule_db.max_num_entries; indx++, pentry++) {
+		if (pentry->name[0] == 0) {
+			TPM_MEMSET_ZERO(pentry->field_op);
+			return pentry;
+		}
+	}
+	return 0;
+}
+
+
+/********************************************************************************/
+/*			  Mod (packet modification) rule table and API	*/
+/********************************************************************************/
+
+static struct tpmcfg_mod_entry_t  tpm_sysfs_mod_table[DB_TPMCFG_MAX_ENTRIES+1];
+
+static struct tpm_generic_rule_db_t tpm_mod_rule_db = {
+	.max_num_entries	= DB_TPMCFG_MAX_ENTRIES,
+	.num_entries	= 0,
+	.size_entry	 = sizeof(struct tpmcfg_mod_entry_t),
+	.entryAra	= tpm_sysfs_mod_table
+};
+
+
+static void init_tpm_mod_db(void)
+{
+	struct tpmcfg_mod_entry_t *pentry = (struct tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
+	int		 indx;
+	int		 i;
+
+	for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++) {
+		pentry->name[0] = 0;
+		for (i = 0; i < TPM_ACT_NUM_MAX; i++)
+			pentry->flags[i]   = 0;
+	}
+
+	strcpy(pentry->name, "dbg_entry");
+	for (i = 0; i < TPM_ACT_NUM_MAX; i++)
+		pentry->flags[i] = 0;
+}
+
+struct tpmcfg_mod_entry_t *find_tpm_mod_entry_by_name(char *name)
+{
+	struct tpmcfg_mod_entry_t *pentry = (struct tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
+	int		 indx;
+
+	if (strcmp(name, "dbg_entry") == 0)
+		return &(tpm_sysfs_mod_table[DB_TPMCFG_MAX_ENTRIES]);
+
+	for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+struct tpmcfg_mod_entry_t *find_free_tpm_mod_entry(void)
+{
+	struct tpmcfg_mod_entry_t *pentry = (struct tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
+	int		 indx;
+
+	for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++) {
+		if (pentry->name[0] == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+bool	del_tpm_mod_entry_by_name(char *name)
+{
+	struct tpmcfg_mod_entry_t *pentry = (struct tpmcfg_mod_entry_t *)tpm_mod_rule_db.entryAra;
+	int		 indx;
+	int		 i;
+
+	if (strcmp(name, "dbg_entry") == 0) {
+		for (i = 0; i < TPM_ACT_NUM_MAX; i++) {
+			memset(&pentry->mod[i], 0, sizeof(pentry->mod[i]));
+			pentry->flags[i] = 0;
+		}
+		return TPM_TRUE;
+	}
+
+	for (indx = 0; indx < tpm_mod_rule_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0) {
+			pentry->name[0] = 0;
+			for (i = 0; i < TPM_ACT_NUM_MAX; i++) {
+				memset(&pentry->mod[i], 0, sizeof(pentry->mod[i]));
+				pentry->flags[i] = 0;
+			}
+			return TPM_TRUE;
+		}
+	}
+	return TPM_FALSE;
+}
+
+/********************************************************************************/
+/*			  L2 ACL table and API				*/
+/********************************************************************************/
+
+static struct tpmcfg_pkt_key_entry_t  tpm_sysfs_pkt_key_table[DB_TPMCFG_MAX_ENTRIES];
+
+static struct tpm_generic_rule_db_t tpm_pkt_key_db = {
+	.max_num_entries	= DB_TPMCFG_MAX_ENTRIES,
+	.num_entries	= 0,
+	.size_entry	 = sizeof(struct tpmcfg_pkt_key_entry_t),
+	.entryAra	= tpm_sysfs_pkt_key_table
+};
+
+
+void init_tpm_pkt_key_db(void)
+{
+	struct tpmcfg_pkt_key_entry_t *pentry = (struct tpmcfg_pkt_key_entry_t *)tpm_pkt_key_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_pkt_key_db.max_num_entries; indx++, pentry++)
+		pentry->name[0] = 0;
+}
+
+struct tpmcfg_pkt_key_entry_t *find_tpm_pkt_key_entry_by_name(char *name)
+{
+	struct tpmcfg_pkt_key_entry_t *pentry = (struct tpmcfg_pkt_key_entry_t *)tpm_pkt_key_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_pkt_key_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+struct tpmcfg_pkt_key_entry_t *find_free_tpm_pkt_key_entry(void)
+{
+	struct tpmcfg_pkt_key_entry_t *pentry = (struct tpmcfg_pkt_key_entry_t *)tpm_pkt_key_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_pkt_key_db.max_num_entries; indx++, pentry++) {
+		if (pentry->name[0] == 0)
+			return pentry;
+	}
+	return 0;
+}
+
+bool	del_tpm_pkt_key_entry_by_name(char *name)
+{
+	struct tpmcfg_pkt_key_entry_t *pentry = (struct tpmcfg_pkt_key_entry_t *)tpm_pkt_key_db.entryAra;
+	int		indx;
+
+	for (indx = 0; indx < tpm_pkt_key_db.max_num_entries; indx++, pentry++) {
+		if (strcmp(pentry->name, name) == 0) {
+			pentry->name[0] = 0;
+			memset(&pentry->key, 0, sizeof(pentry->key));
+			return TPM_TRUE;
+		};
+	}
+	return TPM_FALSE;
+}
+
+/* Intialization of database */
+void tpm_sysfs_rule_db_init(void)
+{
+	init_tpm_pkt_key_db();
+	init_tpm_pkt_frwd_db();
+	init_tpm_mod_db();
+	init_tpm_cnm_field_op_db();
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/test.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/test.h
deleted file mode 100644
index c03fe85..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_tpm/test.h
+++ /dev/null
@@ -1 +0,0 @@
-mv_tpm2-test file
-- 
1.7.5.4

