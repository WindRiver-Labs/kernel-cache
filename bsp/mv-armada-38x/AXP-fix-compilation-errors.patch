From 953c82dde7c8314a34957d92ad7e6a326b7b3eca Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 23 Jan 2013 12:06:55 +0200
Subject: [PATCH 0439/1825] AXP: fix compilation errors

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit eb055ca6957c09df35340d4d20e76c3aea1365bb

Change-Id: Id3716fd5a7c1f48e346aebb3edfd2b9fdbb97e5b
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armadaxp/core.c |  128 +++++++++++++++++++++++++++++-----------
 include/linux/serial_core.h   |    2 +-
 2 files changed, 94 insertions(+), 36 deletions(-)

diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 522a237..87a5cc2 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -30,6 +30,7 @@
 #include <asm/setup.h>
 #include <asm/mach-types.h>
 
+#include <linux/memblock.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
 #include <asm/mach/irq.h>
@@ -111,7 +112,7 @@ extern unsigned int irq_int_type[];
 extern void __init axp_map_io(void);
 extern void __init mv_init_irq(void);
 extern struct sys_timer axp_timer;
-extern void axp_timer_resume();
+extern void axp_timer_resume(void);
 extern MV_CPU_DEC_WIN* mv_sys_map(void);
 #if defined(CONFIG_MV_INCLUDE_CESA)
 extern u32 mv_crypto_virt_base_get(u8 chan);
@@ -346,13 +347,13 @@ unsigned long mv_cpu_count = NR_CPUS;
 static int __init mv_cpu_count_setup(char *s)
 {
 	int fail;
-	unsigned int cpu_count;
+	unsigned long cpu_count;
 
 	/* Translate string to integer. If fails return to default*/
 	while (isspace(*s))
 		s++;
 
-	fail = strict_strtoul(s, 10, (unsigned long *)&cpu_count);
+	fail = strict_strtoul(s, 10, &cpu_count);
 	if(fail == 0)
 	{
 		set_core_count(cpu_count);
@@ -436,15 +437,13 @@ __setup("mv_ipc=", mv_ipc_setup);
 
 void __init armadaxp_setup_cpu_mbus(void)
 {
-	void __iomem *addr;
 	int i;
 	int cs;
 	u8	coherency_status = 0;
+	static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
 #if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
 	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
 #endif
-	static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
-
 
 	/*
 	 * Setup MBUS dram target info.
@@ -500,7 +499,7 @@ static struct resource axp_i2c_0_resources[] = {
 	},
 };
 
-
+#ifdef CONFIG_FB_DOVE
 static struct resource axp_i2c_1_resources[] = {
 	{
 		.name   = "i2c base",
@@ -515,6 +514,7 @@ static struct resource axp_i2c_1_resources[] = {
 		.flags  = IORESOURCE_IRQ,
 	},
 };
+#endif
 
 static struct platform_device axp_i2c0 = {
 	.name           = MV64XXX_I2C_CTLR_NAME,
@@ -526,6 +526,7 @@ static struct platform_device axp_i2c0 = {
 	},
 };
 
+#ifdef CONFIG_FB_DOVE
 static struct platform_device axp_i2c1 = {
 	.name           = MV64XXX_I2C_CTLR_NAME,
 	.id             = 1,
@@ -535,6 +536,8 @@ static struct platform_device axp_i2c1 = {
 		.platform_data = &axp_i2c_pdata,
 	},
 };
+#endif
+
 
 void __init armadaxp_i2c0_init(void)
 {
@@ -555,9 +558,16 @@ void __init armadaxp_i2c1_init(void)
  **********/
 static struct plat_serial8250_port aurora_uart0_data[] = {
 	{
-		.iotype		= UPIO_MEM32,
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(0)),
+		.irq		= IRQ_AURORA_UART0,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(0) | 0x7C),
+		.type		= PORT_16550A,
 		.regshift	= 2,
 		.uartclk	= 0,
+	}, {
 	},
 };
 
@@ -574,7 +584,7 @@ static struct resource aurora_uart0_resources[] = {
 };
 
 static struct platform_device aurora_uart0 = {
-	.name			= "dw-apb-uart",
+	.name			= "serial8250",
 	.id			= 0,
 	.dev			= {
 		.platform_data	= aurora_uart0_data,
@@ -586,11 +596,18 @@ static struct platform_device aurora_uart0 = {
 /**********
  * UART-1 *
  **********/
- static struct plat_serial8250_port aurora_uart1_data[] = {
+static struct plat_serial8250_port aurora_uart1_data[] = {
 	{
-		.iotype		= UPIO_MEM32,
+		.mapbase	= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.membase	= (char *)(INTER_REGS_BASE | MV_UART_REGS_OFFSET(1)),
+		.irq		= IRQ_AURORA_UART1,
+		.flags		= UPF_FIXED_TYPE | UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_DWAPB,
+		.private_data	= (void *) (INTER_REGS_BASE | MV_UART_REGS_OFFSET(1) | 0x7C),
+		.type		= PORT_16550A,
 		.regshift	= 2,
 		.uartclk	= 0,
+	}, {
 	},
 };
 
@@ -607,7 +624,7 @@ static struct resource aurora_uart1_resources[] = {
 };
 
 static struct platform_device aurora_uart1 = {
-	.name			= "dw-apb-uart",
+	.name			= "serial8250",
 	.id			= 0,
 	.dev			= {
 		.platform_data	= aurora_uart1_data,
@@ -780,7 +797,7 @@ static struct platform_device mv_gpio = {
 	.num_resources	= 0,
 };
 
-static void __init mv_gpio_init()
+static void __init mv_gpio_init(void)
 {
 	platform_device_register(&mv_gpio);
 }
@@ -1478,6 +1495,9 @@ static int mvAmpInitCpuIf()
 void axp_db_restore(void)
 {
 	int maxPorts, port;
+#ifdef CONFIG_MV_INCLUDE_SDIO
+	static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+#endif
 
 	/* init the Board environment */
 	mvBoardEnvInit();
@@ -1495,8 +1515,6 @@ void axp_db_restore(void)
 	}
 
 #ifdef CONFIG_MV_INCLUDE_SDIO
-	static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
-
 	if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
 		if (MV_OK == mvSdmmcWinInit(addrWinMap)) {
 			printk("Resuming SDIO\n");
@@ -1689,6 +1707,38 @@ void __init axp_tag_fixup_mem32(struct tag *t, char **cmdline, struct meminfo *m
 }
 #endif /* CONFIG_FB_DOVE */
 
+#ifdef CONFIG_SUSPEND
+#define TRAINING_SPACE	(10*1024)
+
+void __init reserve_training_mem(void)
+{
+	int i;
+	MV_UNIT_WIN_INFO addr_win_map[MAX_TARGETS + 1];
+	phys_addr_t base;
+	phys_addr_t size = (phys_addr_t)(TRAINING_SPACE);
+
+	mvCtrlAddrWinMapBuild(addr_win_map, MAX_TARGETS + 1);
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (!MV_TARGET_IS_DRAM(i))
+			continue;
+
+		if (addr_win_map[i].enable == MV_FALSE)
+			continue;
+
+#ifdef CONFIG_PHYS_ADDR_T_64BIT
+		base  = ((phys_addr_t)addr_win_map[i].addrWin.baseHigh) << 32;
+#else
+		base = 0;
+#endif
+		base |=  addr_win_map[i].addrWin.baseLow;
+
+		pr_info("Reserving training memory: base=0x%p size=0x%x\n",
+				(void *)base, size);
+
+		memblock_reserve(base, size);
+	}
+}
+#endif
 
 MACHINE_START(ARMADA_XP_DB, "Marvell Armada XP Development Board")
 	/* MAINTAINER("MARVELL") */
@@ -1701,6 +1751,12 @@ MACHINE_START(ARMADA_XP_DB, "Marvell Armada XP Development Board")
 	/* reserve memory for LCD */
 	.fixup		= axp_tag_fixup_mem32,
 #endif /* CONFIG_FB_DOVE */
+#ifdef CONFIG_SUSPEND
+	.reserve	= reserve_training_mem,
+#endif /* CONFIG_SUSPEND */
+#ifdef CONFIG_MV_AMP_ENABLE
+	.reserve	= axp_reserve_regs_space,
+#endif
 MACHINE_END
 
 /*****************************************************************************
@@ -1732,7 +1788,11 @@ static void __init axp_gp_init(void)
 	armadaxp_setup_cpu_mbus();
 
 	/* Init the CPU windows setting and the access protection windows. */
-	if( mvCpuIfInit(mv_sys_map())) {
+#ifdef CONFIG_MV_AMP_ENABLE
+	if (mvAmpInitCpuIf()) {
+#else
+	if (mvCpuIfInit(mv_sys_map())) {
+#endif
 		printk( "Cpu Interface initialization failed.\n" );
 		return;
 	}
@@ -1743,7 +1803,11 @@ static void __init axp_gp_init(void)
 
 	elf_hwcap &= ~HWCAP_JAVA;
 
+#ifndef CONFIG_MV_UART_PORT
 	serial_initialize(0);
+#else
+	serial_initialize(CONFIG_MV_UART_PORT);
+#endif
 
 	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
 	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
@@ -1758,7 +1822,8 @@ static void __init axp_gp_init(void)
 
 #ifdef CONFIG_MV_INCLUDE_SPI
 	/* SPI */
-	mvSysSpiInit(0, _16M);
+	if (mvUnitMapIsMine(SPI) == MV_TRUE)
+		mvSysSpiInit(0, _16M);
 #endif
 
 	/* ETH-PHY */
@@ -1828,6 +1893,12 @@ MACHINE_START(ARMADA_XP_GP, "Marvell Armada XP GP Board")
 	/* reserve memory for LCD */
 	.fixup		= axp_tag_fixup_mem32,
 #endif /* CONFIG_FB_DOVE */
+#ifdef CONFIG_SUSPEND
+	.reserve	= reserve_training_mem,
+#endif /* CONFIG_SUSPEND */
+#ifdef CONFIG_MV_AMP_ENABLE
+	.reserve	= axp_reserve_regs_space,
+#endif
 MACHINE_END
 
 /*****************************************************************************
@@ -1853,11 +1924,7 @@ static void __init axp_rd_nas_init(void)
 	armadaxp_setup_cpu_mbus();
 
 	/* Init the CPU windows setting and the access protection windows. */
-#ifdef CONFIG_MV_AMP_ENABLE
-	if (mvAmpInitCpuIf()) {
-#else
-	if (mvCpuIfInit(mv_sys_map())) {
-#endif
+	if( mvCpuIfInit(mv_sys_map())) {
 		printk( "Cpu Interface initialization failed.\n" );
 		return;
 	}
@@ -1868,11 +1935,7 @@ static void __init axp_rd_nas_init(void)
 
 	elf_hwcap &= ~HWCAP_JAVA;
 
-#ifndef CONFIG_MV_UART_PORT
 	serial_initialize(0);
-#else
-	serial_initialize(CONFIG_MV_UART_PORT);
-#endif
 
 	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
 	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
@@ -1887,8 +1950,7 @@ static void __init axp_rd_nas_init(void)
 
 #ifdef CONFIG_MV_INCLUDE_SPI
 	/* SPI */
-	if (mvUnitMapIsMine(SPI) == MV_TRUE)
-		mvSysSpiInit(0, _16M);
+	mvSysSpiInit(0, _16M);
 #endif
 
 	/* ETH-PHY */
@@ -1912,17 +1974,13 @@ static void __init axp_rd_nas_init(void)
 	armadaxp_xor1_init();
 
 	/* I2C */
-	platform_device_register(&axp_i2c0);
-
+	armadaxp_i2c0_init();
 
 #ifdef CONFIG_FB_DOVE
-      if ((lcd0_enable == 1) && (lcd_panel == 0 ))
-        platform_device_register(&axp_i2c1);
+	if ((lcd0_enable == 1) && (lcd_panel == 0))
+		armadaxp_i2c1_init();
 #endif
 
-
-
-
 #if defined(CONFIG_MV_INCLUDE_SDIO)
 	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
 		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 91d8441..4b34e84 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -327,7 +327,7 @@ struct uart_port {
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 
-#if defined (CONFIG_ARCH_ARMADA370)
+#if defined(CONFIG_ARCH_ARMADA370) || defined(CONFIG_ARCH_ARMADA_XP)
 #define UPIO_DWAPB		(6)
 #define UPIO_DWAPB32		(7)
 #endif
-- 
1.7.5.4

