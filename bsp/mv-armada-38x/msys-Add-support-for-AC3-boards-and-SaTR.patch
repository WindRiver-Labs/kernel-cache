From 545b59b44cd17253279efa82af40ff0a981cd4ef Mon Sep 17 00:00:00 2001
From: kostap <kostap@marvell.com>
Date: Thu, 15 May 2014 15:41:42 +0300
Subject: [PATCH 1727/1825] msys: Add support for AC3 boards and SaTR

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit fb305beaac7a2069decf68e1d76ec5a56b878665

	Add support for AC3 DB board configuration
	Add support for SaTR read/write functionality on AC3 boards
	Use call to mvCtrlDevFamilyIdGet() for distinguishing
	between AC3 and BC2 families in SaTR access functions

Change-Id: I9b1eb9bbaeceee00fb3dfacc3d7cf0b04fda472f
Signed-off-by: kostap <kostap@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8088
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8580
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.c |  409 ++++++++++++++++----
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.h |    7 +
 .../msys_family/boardEnv/mvBoardEnvSpec.c          |  228 +++++++++++-
 .../msys_family/boardEnv/mvBoardEnvSpec.h          |  116 +++++-
 arch/arm/mach-msys/msys_family/cpu/mvCpu.c         |   36 ++-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   |   15 +-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h  |   79 +++--
 7 files changed, 748 insertions(+), 142 deletions(-)

diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
index 7428501..a78d3d7 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
@@ -199,9 +199,10 @@ MV_U16 mvBoardModelGet(MV_VOID)
 	MV_U8 modelId;
 	if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 0, 0, &modelId)) {
 		mvOsWarning();
-		return INVALID_BAORD_ID;
+		return INVALID_BOARD_ID;
 	}
-        return (MV_U16)modelId;
+
+	return (MV_U16)modelId;
 }
 /*******************************************************************************
 * mbBoardRevlGet - Get Board revision
@@ -454,17 +455,6 @@ MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
 *       32bit clock cycles in Hertz.
 *
 *******************************************************************************/
-MV_U32 freq_tbl[] = {
-	360000000, /* 0 */
-	220000000, /* 1 */
-	200000000, /* 2 */
-	400000000, /* 3 */
-	500000000, /* 4 */
-	520000000, /* 5 */
-	450000000, /* 6 */
-	0xFFFFFFFF /* 7  reserved */
-};
-
 MV_U32 mvBoardTclkGet(MV_VOID)
 {
 	/* Tclock is constant at 200MHz (not sampled @ reset)  */
@@ -489,12 +479,22 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvBoardSysClkGet(MV_VOID)
 {
-	MV_U32 idx;
+	MV_U32		idx;
+	MV_U32		freq_tbl_bc2[] = MV_CORE_CLK_TBL_BC2;
+	MV_U32		freq_tbl_ac3[] = MV_CORE_CLK_TBL_AC3;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	idx = MSAR_CORE_CLK(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)), MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
 
-	idx = MSAR_CORE_CLK(MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(0)),
-			    MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
+	if (idx >= 7)
+		return 0xFFFFFFFF;
 
-	return freq_tbl[idx];
+	if (family == MV_BOBCAT2_DEV_ID)
+		return freq_tbl_bc2[idx] * 1000000;
+	else if (family == MV_ALLEYCAT3_DEV_ID)
+		return freq_tbl_ac3[idx] * 1000000;
+	else
+		return 0xFFFFFFFF;
 }
 
 /*******************************************************************************
@@ -550,8 +550,7 @@ MV_VOID mvBoardReset(MV_VOID)
 	resetPin = mvBoardResetGpioPinGet();
 	if (resetPin != MV_ERROR)
 		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
-	else
-	{
+	else {
 		/* No gpp reset pin was found, try to reset using system reset out */
 		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
 		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
@@ -1093,11 +1092,11 @@ MV_VOID mvBoardSet(MV_U32 boardId)
 		board = marvellAC3BoardInfoTbl[mvBoardIdIndexGet(boardId)];
 		gBoardId = boardId;
 	/* Customer Bobcat2 Boards */
-	} else if (boardId >= BC2_CUTOMER_BOARD_ID_BASE && boardId < BC2_CUSTOMER_MAX_BOARD_ID) { /* Customer Board */
+	} else if (boardId >= BC2_CUSTOMER_BOARD_ID_BASE && boardId < BC2_CUSTOMER_MAX_BOARD_ID) { /* Customer Board */
 		board = customerBC2BoardInfoTbl[mvBoardIdIndexGet(boardId)];
 		gBoardId = boardId;
 	/* Customer AlleyCat3 Boards */
-	} else if (boardId >= AC3_CUTOMER_BOARD_ID_BASE && boardId < AC3_CUSTOMER_MAX_BOARD_ID) { /* Customer Board */
+	} else if (boardId >= AC3_CUSTOMER_BOARD_ID_BASE && boardId < AC3_CUSTOMER_MAX_BOARD_ID) { /* Customer Board */
 		board = customerAC3BoardInfoTbl[mvBoardIdIndexGet(boardId)];
 		gBoardId = boardId;
 	} else {
@@ -1256,7 +1255,7 @@ MV_STATUS mvBoardTwsiWrite(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNu
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
-		DB1(mvOsPrintf("Board: Write S@R fail\n"));
+		DB(mvOsPrintf("Board: Write S@R fail\n"));
 		return MV_ERROR;
 	}
 	DB(mvOsPrintf("Board: Write S@R succeded\n"));
@@ -1313,31 +1312,47 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 *******************************************************************************/
 MV_STATUS mvBoardCoreFreqGet(MV_U8 *value)
 {
-	MV_U8 sar0;
-	MV_STATUS rc1;
+	MV_U8		sar0;
+	MV_STATUS	rc1;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+	MV_U32		fieldOffs = (family == MV_BOBCAT2_DEV_ID) ? 0 : 2;
+
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
 
 	rc1 = mvBoardTwsiSatRGet(1, 0, &sar0);
 	if (MV_ERROR == rc1)
 		return MV_ERROR;
 
-	*value = sar0 & 0x7;
+	*value = (sar0 & (0x7 << fieldOffs)) >> fieldOffs;
+
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal)
 {
-	MV_U8 sar0;
-	MV_STATUS rc1;
+	MV_U8		sar0;
+	MV_STATUS	rc1;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+	MV_U32		fieldOffs = (family == MV_BOBCAT2_DEV_ID) ? 0 : 2;
+
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
 
 	rc1 = mvBoardTwsiSatRGet(1, 0, &sar0);
 	if (MV_ERROR == rc1)
 		return MV_ERROR;
 
-	sar0 &= ~(0x7);
-	sar0 |= (freqVal & 0x7);
+	sar0 &= ~(0x7 << fieldOffs);
+	sar0 |= (freqVal & 0x7) << fieldOffs;
+
 	if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar0)) {
-		DB1(mvOsPrintf("Board: Write core Freq S@R fail\n"));
+		DB(mvOsPrintf("Board: Write core Freq S@R fail\n"));
 		return MV_ERROR;
 	}
 
@@ -1348,43 +1363,81 @@ MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal)
 /*******************************************************************************/
 MV_STATUS mvBoardCpuFreqGet(MV_U8 *value)
 {
-	MV_U8 sar1, sar2;
-	MV_STATUS rc1;
-	MV_STATUS rc2;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family == MV_BOBCAT2_DEV_ID) {
+		MV_U8		sar2;
+
+		/* BC2 */
+		if ((MV_ERROR == mvBoardTwsiSatRGet(1, 0, &sar)) ||
+			(MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar2)))
+			return MV_ERROR;
+
+		*value = ((((sar2 & 0x1)) << 3) | ((sar & 0x18) >> 3));
+
+	} else if (family == MV_ALLEYCAT3_DEV_ID) {
+
+		/* AC3 */
+		if (MV_ERROR == mvBoardTwsiSatRGet(3, 0, &sar))
+			return MV_ERROR;
 
-	rc1 = mvBoardTwsiSatRGet(1, 0, &sar1);
-	rc2 = mvBoardTwsiSatRGet(2, 0, &sar2);
-	if ((MV_ERROR == rc1) || (MV_ERROR == rc2))
+		*value = sar & 0x7;
+
+	} else {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
 		return MV_ERROR;
+	}
 
-	*value = ((((sar2 & 0x1)) << 3) | ((sar1 & 0x18) >> 3));
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
 {
-	MV_U8 sar1, sar2;
-	MV_STATUS rc1;
-	MV_STATUS rc2;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family == MV_BOBCAT2_DEV_ID) {
+		MV_U8		sar2;
+		/* BC2 */
+		if ((MV_ERROR == mvBoardTwsiSatRGet(1, 0, &sar)) ||
+			(MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar2)))
+			return MV_ERROR;
+
+		sar  &= ~0x18;
+		sar2 &= ~0x1;
+		sar  |= ((freqVal & 0x03) << 3);
+		sar2 |= ((freqVal & 0x04) >> 2);
+
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB(mvOsPrintf("Board: Write CpuFreq(1) S@R fail\n"));
+			return MV_ERROR;
+		}
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar2)) {
+			DB(mvOsPrintf("Board: Write CpuFreq(2) S@R fail\n"));
+			return MV_ERROR;
+		}
 
-	rc1 = mvBoardTwsiSatRGet(1, 0, &sar1);
-	rc2 = mvBoardTwsiSatRGet(2, 0, &sar2);
-	if ((MV_ERROR == rc1) || (MV_ERROR == rc2))
-		return MV_ERROR;
+	} else if (family == MV_ALLEYCAT3_DEV_ID) {
 
-	sar1 &= ~0x18;
-	sar2 &= ~0x1;
-	sar1 |= ((freqVal & 0x03) << 3);
-	sar2 |= ((freqVal & 0x04) >> 2);
-	if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar1)) {
-		DB1(mvOsPrintf("Board: Write CpuFreq(1) S@R fail\n"));
-		return MV_ERROR;
-	}
-	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar2)) {
-		DB1(mvOsPrintf("Board: Write CpuFreq(2) S@R fail\n"));
+		/* AC3 */
+		if (MV_ERROR == mvBoardTwsiSatRGet(3, 0, &sar))
+			return MV_ERROR;
+
+		sar  &= ~(0x7 << 2);
+		sar  |= (freqVal & 0x7) << 2;
+
+		if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+			DB(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+
+	} else {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
 		return MV_ERROR;
 	}
+
 	DB(mvOsPrintf("Board: Write CpuFreq S@R succeeded\n"));
 	return MV_OK;
 }
@@ -1392,65 +1445,90 @@ MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
 /*******************************************************************************/
 MV_STATUS mvBoardTmFreqGet(MV_U8 *value)
 {
-	MV_U8 sar2;
-	MV_STATUS rc2;
+	MV_U8		sar2;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_BOBCAT2_DEV_ID) {
+		DB(mvOsPrintf("%s: AC3 controller family is not supported\n", __func__));
+		return MV_ERROR; /* AC3 */
+	}
 
-	rc2 = mvBoardTwsiSatRGet(2, 0, &sar2);
-	if (MV_ERROR == rc2)
+	/* BC2 */
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar2))
 		return MV_ERROR;
 
 	*value = ((sar2 & 0x0E) >> 1);
+
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardTmFreqSet(MV_U8 freqVal)
 {
-	MV_U8 sar2;
-	MV_STATUS rc2;
+	MV_U8		sar2;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
 
-	rc2 = mvBoardTwsiSatRGet(2, 0, &sar2);
-	if (MV_ERROR == rc2)
+	if (family != MV_BOBCAT2_DEV_ID) {
+		DB(mvOsPrintf("%s: AC3 controller family is not supported\n", __func__));
+		return MV_ERROR; /* AC3 */
+	}
+
+	/* BC2 */
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar2))
 		return MV_ERROR;
 
 	sar2 &= ~0xE;
 	sar2 |= ((freqVal & 0x07) << 1);
+
 	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar2)) {
-		DB1(mvOsPrintf("Board: Write TM-Freq S@R fail\n"));
+		DB(mvOsPrintf("Board: Write TM-Freq S@R fail\n"));
 		return MV_ERROR;
 	}
 	DB(mvOsPrintf("Board: Write TM-Freq S@R succeeded\n"));
+
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardBootDevGet(MV_U8 *value)
 {
-	MV_U8 sar;
-	MV_STATUS rc;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+	MV_U8		twsiDevice = (family == MV_BOBCAT2_DEV_ID) ? 3 : 2;
 
-	rc = mvBoardTwsiSatRGet(3, 0, &sar);
-	if (MV_ERROR == rc)
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(twsiDevice, 0, &sar))
 		return MV_ERROR;
 
 	*value = (sar & 0x7);
+
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardBootDevSet(MV_U8 val)
 {
-	MV_U8 sar;
-	MV_STATUS rc;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+	MV_U8		twsiDevice = (family == MV_BOBCAT2_DEV_ID) ? 3 : 2;
+
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
 
-	rc = mvBoardTwsiSatRGet(3, 0, &sar);
-	if (MV_ERROR == rc)
+	if (MV_ERROR == mvBoardTwsiSatRGet(twsiDevice, 0, &sar))
 		return MV_ERROR;
 
 	sar &= ~(0x7);
 	sar |= (val & 0x7);
-	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
-		DB1(mvOsPrintf("Board: Write BootDev S@R fail\n"));
+
+	if (MV_OK != mvBoardTwsiSatRSet(twsiDevice, 0, sar)) {
+		DB(mvOsPrintf("Board: Write BootDev S@R fail\n"));
 		return MV_ERROR;
 	}
 
@@ -1460,37 +1538,204 @@ MV_STATUS mvBoardBootDevSet(MV_U8 val)
 /*******************************************************************************/
 MV_STATUS mvBoardDeviceIdGet(MV_U8 *value)
 {
-	MV_U8 sar;
-	MV_STATUS rc;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
 
-	rc = mvBoardTwsiSatRGet(0, 0, &sar);
-	if (MV_ERROR == rc)
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(0, 0, &sar))
 		return MV_ERROR;
 
 	*value = (sar & 0x1F);
+
+	if (family == MV_ALLEYCAT3_DEV_ID) {
+		/* AC3 - 2 additional bits in device ID */
+		if (MV_ERROR == mvBoardTwsiSatRGet(1, 0, &sar))
+			return MV_ERROR;
+
+		*value |= (sar & 0x3) << 4;
+	}
+
 	return MV_OK;
 }
 
 /*******************************************************************************/
 MV_STATUS mvBoardDeviceIdSet(MV_U8 val)
 {
-	MV_U8 sar;
-	MV_STATUS rc;
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if ((family != MV_ALLEYCAT3_DEV_ID) && (family != MV_BOBCAT2_DEV_ID)) {
+		DB(mvOsPrintf("%s: Controller family (0x%04x) is not supported\n", __func__, family));
+		return MV_ERROR;
+	}
 
-	rc = mvBoardTwsiSatRGet(0, 0, &sar);
-	if (MV_ERROR == rc)
+	if (MV_ERROR == mvBoardTwsiSatRGet(0, 0, &sar))
 		return MV_ERROR;
 
 	sar &= ~(0x1F);
 	sar |= (val & 0x1F);
+
 	if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
-		DB1(mvOsPrintf("Board: Write device-id S@R fail\n"));
+		DB(mvOsPrintf("Board: Write device-id S@R fail\n"));
 		return MV_ERROR;
 	}
 
+	if (family == MV_ALLEYCAT3_DEV_ID) {
+		/* AC3 - 2 additional bits in device ID */
+		if (MV_ERROR == mvBoardTwsiSatRGet(1, 0, &sar))
+			return MV_ERROR;
+
+		sar &= ~(0x3);
+		sar |= (val & (0x3 << 4)) >> 4;
+
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB(mvOsPrintf("Board: Write device-id(MSB) S@R fail\n"));
+			return MV_ERROR;
+		}
+	}
+
 	DB(mvOsPrintf("Board: Write deviceid S@R succeeded\n"));
 	return MV_OK;
 }
+
+/*******************************************************************************/
+MV_STATUS mvBoardPcieModeGet(MV_U8 *val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar))
+		return MV_ERROR;
+
+	*val = (sar & (0x1 << 3)) >> 3;
+
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardPcieModeSet(MV_U8 val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar))
+		return MV_ERROR;
+
+	sar &= ~(0x1 << 3);
+	sar |= (val & 0x1) << 3;
+
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+		DB(mvOsPrintf("Board: Write pcimode S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write pcimode S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardPcieClockGet(MV_U8 *val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar))
+		return MV_ERROR;
+
+	*val = (sar & (0x1 << 4)) >> 4;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardPcieClockSet(MV_U8 val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(2, 0, &sar))
+		return MV_ERROR;
+
+	sar &= ~(0x1 << 4);
+	sar |= (val & 0x1) << 4;
+
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+		DB(mvOsPrintf("Board: Write pciclock S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write pciclock S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardPllClockGet(MV_U8 *val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(3, 0, &sar))
+		return MV_ERROR;
+
+	*val = (sar & (0x1 << 3)) >> 3;
+
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardPllClockSet(MV_U8 val)
+{
+	MV_U8		sar;
+	MV_U16		family = mvCtrlDevFamilyIdGet(0);
+
+	if (family != MV_ALLEYCAT3_DEV_ID) {
+		DB(mvOsPrintf("%s: BC2 controller family is not supported\n", __func__));
+		return MV_ERROR; /* Not supported on BC2 */
+	}
+
+	if (MV_ERROR == mvBoardTwsiSatRGet(3, 0, &sar))
+		return MV_ERROR;
+
+	sar &= ~(0x1 << 3);
+	sar |= (val & 0x1) << 3;
+
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+		DB(mvOsPrintf("Board: Write pllclock S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write pcllclock S@R succeeded\n"));
+	return MV_OK;
+}
+
 /*******************************************************************************
 * End of SatR Configuration functions
 *******************************************************************************/
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
index 43c802c..c76402cc 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
@@ -301,6 +301,13 @@ MV_STATUS mvBoardBootDevGet(MV_U8 *value);
 MV_STATUS mvBoardBootDevSet(MV_U8 val);
 MV_STATUS mvBoardDeviceIdGet(MV_U8 *value);
 MV_STATUS mvBoardDeviceIdSet(MV_U8 val);
+MV_STATUS mvBoardPcieModeGet(MV_U8 *val);
+MV_STATUS mvBoardPcieModeSet(MV_U8 val);
+MV_STATUS mvBoardPcieClockGet(MV_U8 *val);
+MV_STATUS mvBoardPcieClockSet(MV_U8 val);
+MV_STATUS mvBoardPllClockGet(MV_U8 *val);
+MV_STATUS mvBoardPllClockSet(MV_U8 val);
+
 MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
 MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
 MV_STATUS mvBoardConIdSet(MV_U16 conf);
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
index def2857..d51b515 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.c
@@ -178,9 +178,119 @@ MV_BOARD_INFO *customerBC2BoardInfoTbl[] = {
 	&bobcat2_customer_board_0_Info,
 };
 
+
+/*******************************************************************************
+	Alleycat3 board - Based on BOBCAT2-DB-DX
+*******************************************************************************/
+#define ALLEYCAT3_CUSTOMER_0_BOARD_NAND_READ_PARAMS		0x000C0282
+#define ALLEYCAT3_CUSTOMER_0_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define ALLEYCAT3_CUSTOMER_0_BOARD_NAND_CONTROL			0x01c00543
+
+#define ALLEYCAT3_CUSTOMER_0_BOARD_NOR_READ_PARAMS		0x403E07CF
+#define ALLEYCAT3_CUSTOMER_0_BOARD_NOR_WRITE_PARAMS		0x000F0F0F
+
+MV_BOARD_TWSI_INFO	alleycat3_customer_board_0_InfoBoardTwsiDev[] = {
+/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_PLD, 0x30, ADDR7_BIT},		/* Access to control PLD reg file */
+	{BOARD_DEV_TWSI_ZARLINK, 0x18, ADDR7_BIT},		/* Access to Zarlink */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},         /* SatR bios 0		*/
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},         /* SatR bios 1		*/
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},          /* SatR bios 2		*/
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT},          /* SatR bios 3		*/
+	{BOARD_DEV_TWSI_INIT_EPROM, 0x50, ADDR7_BIT},          /* Serial Ini EPROM	*/
+	{BOARD_DEV_TWSI_PCA9555_IO_EXPANDER, 0x20, ADDR7_BIT},          /* Qsgmii/sfp mux control PCA9555 IO expander */
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x70, ADDR7_BIT},          /* PCA9548 I2C mux 0	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x71, ADDR7_BIT},          /* PCA9548 I2C mux 1	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x75, ADDR7_BIT}          /* PCA9548 I2C mux 2	*/
+};
+
+MV_BOARD_MAC_INFO alleycat3_customer_board_0_InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0 },
+	{BOARD_MAC_SPEED_AUTO, 0x1 },
+};
+
+MV_BOARD_MODULE_TYPE_INFO alleycat3_customer_board_0_InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+	}
+};
+
+MV_BOARD_GPP_INFO alleycat3_customer_board_0_InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+	/*{BOARD_GPP_RESET,       47},*/
+};
+
+MV_DEV_CS_INFO alleycat3_customer_board_0_InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO alleycat3_customer_board_0_InfoBoardMppConfigValue[] = {
+	{ {
+	ALLEYCAT3_CUSTOMER_0_MPP0_7,
+	ALLEYCAT3_CUSTOMER_0_MPP8_15,
+	ALLEYCAT3_CUSTOMER_0_MPP16_23,
+	ALLEYCAT3_CUSTOMER_0_MPP24_31,
+	ALLEYCAT3_CUSTOMER_0_MPP32_39,
+	} },
+};
+
+MV_BOARD_INFO alleycat3_customer_board_0_Info = {
+	.boardName			= "ALLEYCAT3-Customer-Board-0",
+	.numBoardMppTypeValue		= ARRSZ(alleycat3_customer_board_0_InfoBoardModTypeInfo),
+	.pBoardModTypeValue			= alleycat3_customer_board_0_InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(alleycat3_customer_board_0_InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= alleycat3_customer_board_0_InfoBoardMppConfigValue,
+	.intsGppMaskLow				= 0,
+	.intsGppMaskMid				= 0,
+	.intsGppMaskHigh			= 0,
+	.numBoardDeviceIf			= ARRSZ(alleycat3_customer_board_0_InfoBoardDeCsInfo),
+	.pDevCsInfo					= alleycat3_customer_board_0_InfoBoardDeCsInfo,
+	.numBoardTwsiDev			= ARRSZ(alleycat3_customer_board_0_InfoBoardTwsiDev),
+	.pBoardTwsiDev				= alleycat3_customer_board_0_InfoBoardTwsiDev,
+	.numBoardMacInfo			= ARRSZ(alleycat3_customer_board_0_InfoBoardMacInfo),
+	.pBoardMacInfo				= alleycat3_customer_board_0_InfoBoardMacInfo,
+	.numBoardGppInfo			= ARRSZ(alleycat3_customer_board_0_InfoBoardGppInfo),
+	.pBoardGppInfo				= alleycat3_customer_board_0_InfoBoardGppInfo,
+	.activeLedsNumber			= 0,
+	.pLedGppPin					= NULL,
+	.ledsPolarity				= 0,
+
+	/* GPP values */
+	.gppOutEnValLow				= ALLEYCAT3_CUSTOMER_0_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid				= ALLEYCAT3_CUSTOMER_0_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh			= 0,
+	.gppOutValLow				= ALLEYCAT3_CUSTOMER_0_GPP_OUT_VAL_LOW,
+	.gppOutValMid				= ALLEYCAT3_CUSTOMER_0_GPP_OUT_VAL_MID,
+	.gppOutValHigh				= 0,
+	.gppPolarityValLow			= ALLEYCAT3_CUSTOMER_0_GPP_POL_LOW,
+	.gppPolarityValMid			= ALLEYCAT3_CUSTOMER_0_GPP_POL_MID,
+	.gppPolarityValHigh			= 0,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+
+	/* NAND init params */
+	.nandFlashReadParams		= ALLEYCAT3_CUSTOMER_0_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= ALLEYCAT3_CUSTOMER_0_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl			= ALLEYCAT3_CUSTOMER_0_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams			= ALLEYCAT3_CUSTOMER_0_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= ALLEYCAT3_CUSTOMER_0_BOARD_NOR_WRITE_PARAMS
+};
+
 MV_BOARD_INFO *customerAC3BoardInfoTbl[] = {
-	&bobcat2_customer_board_0_Info,		/* Place holder for AC3 board, must be replaced */
-	&bobcat2_customer_board_0_Info,		/* Place holder for AC3 board, must be replaced */
+	&alleycat3_customer_board_0_Info,
+	&alleycat3_customer_board_0_Info
 };
 
 /***************************************** Marvell Boards *****************************************/
@@ -292,6 +402,7 @@ MV_BOARD_INFO db_dx_bc2Info = {
 	.norFlashWriteParams		= DB_DX_BC2_BOARD_NOR_WRITE_PARAMS
 };
 
+/**********************************************************************************/
 /***********************/
 /* BOBCAT2-RD-DX BOARD */
 /***********************/
@@ -371,6 +482,7 @@ MV_BOARD_INFO rd_dx_bc2Info = {
 	.nandFlashControl		= RD_DX_BC2_BOARD_NAND_CONTROL
 };
 
+/**********************************************************************************/
 /*****************************/
 /* BobCat2 RD BC2_MTL BOARD */
 /*****************************/
@@ -451,6 +563,116 @@ MV_BOARD_INFO bc2_rd_mtlInfo = {
 };
 
 /*********************************************************************************/
+/***********************/
+/* ALLEYCAT3-DB-DX BOARD */
+/***********************/
+#define DB_DX_AC3_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_DX_AC3_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_DX_AC3_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_DX_AC3_BOARD_NOR_READ_PARAMS		0x403E07CF
+#define DB_DX_AC3_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_TWSI_INFO	db_dx_ac3InfoBoardTwsiDev[] = {
+/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_PLD, 0x30, ADDR7_BIT},			/* Access to control PLD reg file */
+	{BOARD_DEV_TWSI_ZARLINK, 0x18, ADDR7_BIT},		/* Access to Zarlink	*/
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},			/* SatR bios 0		*/
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},			/* SatR bios 1		*/
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},			/* SatR bios 2		*/
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT},			/* SatR bios 3		*/
+	{BOARD_DEV_TWSI_INIT_EPROM, 0x50, ADDR7_BIT},	/* Serial Ini EPROM	*/
+	{BOARD_DEV_TWSI_PCA9555_IO_EXPANDER, 0x20, ADDR7_BIT},	/* Qsgmii/sfp mux control PCA9555 IO expander */
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x70, ADDR7_BIT},		/* PCA9548 I2C mux 0	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x71, ADDR7_BIT},		/* PCA9548 I2C mux 1	*/
+	{BOARD_DEV_TWSI_PCA9548_IO_MUX, 0x75, ADDR7_BIT}		/* PCA9548 I2C mux 2	*/
+};
+
+MV_BOARD_MAC_INFO db_dx_ac3InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0 },
+	{BOARD_MAC_SPEED_AUTO, 0x1 },
+};
+
+MV_BOARD_MODULE_TYPE_INFO db_dx_ac3InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+	}
+};
+
+MV_BOARD_GPP_INFO db_dx_ac3InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+	/*{BOARD_GPP_RESET,       47},*/
+};
+
+MV_DEV_CS_INFO db_dx_ac3InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db_dx_ac3InfoBoardMppConfigValue[] = {
+	{ {
+	DB_DX_AC3_MPP0_7,
+	DB_DX_AC3_MPP8_15,
+	DB_DX_AC3_MPP16_23,
+	DB_DX_AC3_MPP24_31,
+	DB_DX_AC3_MPP32_39,
+	} },
+};
+
+MV_BOARD_INFO db_dx_ac3Info = {
+	.boardName					= "DB-DXAC3-MM",
+	.numBoardMppTypeValue		= ARRSZ(db_dx_ac3InfoBoardModTypeInfo),
+	.pBoardModTypeValue			= db_dx_ac3InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db_dx_ac3InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db_dx_ac3InfoBoardMppConfigValue,
+	.intsGppMaskLow				= 0,
+	.intsGppMaskMid				= 0,
+	.intsGppMaskHigh			= 0,
+	.numBoardDeviceIf			= ARRSZ(db_dx_ac3InfoBoardDeCsInfo),
+	.pDevCsInfo					= db_dx_ac3InfoBoardDeCsInfo,
+	.numBoardTwsiDev			= ARRSZ(db_dx_ac3InfoBoardTwsiDev),
+	.pBoardTwsiDev				= db_dx_ac3InfoBoardTwsiDev,
+	.numBoardMacInfo			= ARRSZ(db_dx_ac3InfoBoardMacInfo),
+	.pBoardMacInfo				= db_dx_ac3InfoBoardMacInfo,
+	.numBoardGppInfo			= ARRSZ(db_dx_ac3InfoBoardGppInfo),
+	.pBoardGppInfo				= db_dx_ac3InfoBoardGppInfo,
+	.activeLedsNumber			= 0,
+	.pLedGppPin					= NULL,
+	.ledsPolarity				= 0,
+
+	/* GPP values */
+	.gppOutEnValLow				= DB_DX_AC3_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid				= DB_DX_AC3_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh			= 0,
+	.gppOutValLow				= DB_DX_AC3_GPP_OUT_VAL_LOW,
+	.gppOutValMid				= DB_DX_AC3_GPP_OUT_VAL_MID,
+	.gppOutValHigh				= 0,
+	.gppPolarityValLow			= DB_DX_AC3_GPP_POL_LOW,
+	.gppPolarityValMid			= DB_DX_AC3_GPP_POL_MID,
+	.gppPolarityValHigh			= 0,
+
+	/* External Switch Configuration */
+	.pSwitchInfo = NULL,
+	.switchInfoNum = 0,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_DX_AC3_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_DX_AC3_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl			= DB_DX_AC3_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams			= DB_DX_AC3_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_DX_AC3_BOARD_NOR_WRITE_PARAMS
+};
+
+/*********************************************************************************/
 
 MV_BOARD_INFO *marvellBC2BoardInfoTbl[] = {
 	&db_dx_bc2Info,
@@ -459,5 +681,5 @@ MV_BOARD_INFO *marvellBC2BoardInfoTbl[] = {
 };
 
 MV_BOARD_INFO *marvellAC3BoardInfoTbl[] = {
-	&db_dx_bc2Info		/* Place holder for AC3 boards, must be replaced */
+	&db_dx_ac3Info
 };
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
index 8eb60bf..b5cc82c 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
@@ -72,35 +72,35 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /* Board specific configuration */
 /* ============================ */
 /* Bobcat2 Customer Boards */
-#define BC2_CUTOMER_BOARD_ID_BASE	0x0
-#define BC2_CUSTOMER_BOARD_ID0		(BC2_CUTOMER_BOARD_ID_BASE + 0)
-#define BC2_CUSTOMER_BOARD_ID1		(BC2_CUTOMER_BOARD_ID_BASE + 1)
-#define BC2_CUSTOMER_MAX_BOARD_ID	(BC2_CUTOMER_BOARD_ID_BASE + 2)
-#define BC2_CUSTOMER_BOARD_NUM		(BC2_CUSTOMER_MAX_BOARD_ID - BC2_CUTOMER_BOARD_ID_BASE)
+#define BC2_CUSTOMER_BOARD_ID_BASE	0x0
+#define BC2_CUSTOMER_BOARD_ID0		(BC2_CUSTOMER_BOARD_ID_BASE + 0)
+#define BC2_CUSTOMER_BOARD_ID1		(BC2_CUSTOMER_BOARD_ID_BASE + 1)
+#define BC2_CUSTOMER_MAX_BOARD_ID	(BC2_CUSTOMER_BOARD_ID_BASE + 2)
+#define BC2_CUSTOMER_BOARD_NUM		(BC2_CUSTOMER_MAX_BOARD_ID - BC2_CUSTOMER_BOARD_ID_BASE)
 
 /* Bobcat2 Marvell boards */
 #define BC2_MARVELL_BOARD_ID_BASE	0x10
-#define DB_DX_BC2_ID			(BC2_MARVELL_BOARD_ID_BASE + 0)
-#define RD_DX_BC2_ID			(BC2_MARVELL_BOARD_ID_BASE + 1)
-#define RD_MTL_BC2			(BC2_MARVELL_BOARD_ID_BASE + 2)
+#define DB_DX_BC2_ID				(BC2_MARVELL_BOARD_ID_BASE + 0)
+#define RD_DX_BC2_ID				(BC2_MARVELL_BOARD_ID_BASE + 1)
+#define RD_MTL_BC2					(BC2_MARVELL_BOARD_ID_BASE + 2)
 #define BC2_MARVELL_MAX_BOARD_ID	(BC2_MARVELL_BOARD_ID_BASE + 3)
 #define BC2_MARVELL_BOARD_NUM		(BC2_MARVELL_MAX_BOARD_ID - BC2_MARVELL_BOARD_ID_BASE)
 
 
 /* AlleyCat3 Customer Boards */
-#define AC3_CUTOMER_BOARD_ID_BASE	0x20
-#define AC3_CUSTOMER_BOARD_ID0		(AC3_CUTOMER_BOARD_ID_BASE + 0)
-#define AC3_CUSTOMER_BOARD_ID1		(AC3_CUTOMER_BOARD_ID_BASE + 1)
-#define AC3_CUSTOMER_MAX_BOARD_ID	(AC3_CUTOMER_BOARD_ID_BASE + 2)
-#define AC3_CUSTOMER_BOARD_NUM		(AC3_CUSTOMER_MAX_BOARD_ID - AC3_CUTOMER_BOARD_ID_BASE)
+#define AC3_CUSTOMER_BOARD_ID_BASE	0x20
+#define AC3_CUSTOMER_BOARD_ID0		(AC3_CUSTOMER_BOARD_ID_BASE + 0)
+#define AC3_CUSTOMER_BOARD_ID1		(AC3_CUSTOMER_BOARD_ID_BASE + 1)
+#define AC3_CUSTOMER_MAX_BOARD_ID	(AC3_CUSTOMER_BOARD_ID_BASE + 2)
+#define AC3_CUSTOMER_BOARD_NUM		(AC3_CUSTOMER_MAX_BOARD_ID - AC3_CUSTOMER_BOARD_ID_BASE)
 
 /* AlleyCat3 Marvell boards */
 #define AC3_MARVELL_BOARD_ID_BASE	0x30
-#define DB_AC3_ID			(AC3_MARVELL_BOARD_ID_BASE + 0)
+#define DB_AC3_ID					(AC3_MARVELL_BOARD_ID_BASE + 0)
 #define AC3_MARVELL_MAX_BOARD_ID	(AC3_MARVELL_BOARD_ID_BASE + 1)
 #define AC3_MARVELL_BOARD_NUM		(AC3_MARVELL_MAX_BOARD_ID - AC3_MARVELL_BOARD_ID_BASE)
 
-#define INVALID_BAORD_ID		0xFFFF
+#define INVALID_BOARD_ID			0xFFFF
 
 #define BOARD_ID_INDEX_MASK		0x10	/* Mask used to return board index via board Id */
 
@@ -125,6 +125,27 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BOBCAT2_CUSTOMER_0_GPP_POL_LOW		0x0
 #define BOBCAT2_CUSTOMER_0_GPP_POL_MID		0x0
 
+/*******************************************************************************
+* Alleycat3 Customer board - Based on DB_DX_BC2
+*******************************************************************************/
+
+#define ALLEYCAT3_CUSTOMER_0_MPP0_7			0x22242222
+#define ALLEYCAT3_CUSTOMER_0_MPP8_15		0x11122222
+#define ALLEYCAT3_CUSTOMER_0_MPP16_23		0x44444044
+#define ALLEYCAT3_CUSTOMER_0_MPP24_31		0x14444444
+#define ALLEYCAT3_CUSTOMER_0_MPP32_39		0x00000001
+
+#define ALLEYCAT3_CUSTOMER_0_GPP_OUT_ENA_LOW	(~(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12\
+						 | BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30))
+#define ALLEYCAT3_CUSTOMER_0_GPP_OUT_ENA_MID	(~(0))
+
+#define ALLEYCAT3_CUSTOMER_0_GPP_OUT_VAL_LOW	(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12\
+						| BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30)
+#define ALLEYCAT3_CUSTOMER_0_GPP_OUT_VAL_MID	0x0
+
+#define ALLEYCAT3_CUSTOMER_0_GPP_POL_LOW		0x0
+#define ALLEYCAT3_CUSTOMER_0_GPP_POL_MID		0x0
+
 
 /******************/
 /*   RD_DX_BC2    */
@@ -268,5 +289,70 @@ MPP#	NAME		IN/OUT
 #define RD_MTL_BC2_GPP_POL_LOW		0x0
 #define RD_MTL_BC2_GPP_POL_MID		0x0
 
+/******************/
+/*   RD_DX_AC3    */
+/******************/
+#define DB_DX_AC3_MPP0_7		0x00142222
+#define DB_DX_AC3_MPP8_15		0x11122000
+#define DB_DX_AC3_MPP16_23		0x44444004
+#define DB_DX_AC3_MPP24_31		0x14444444
+#define DB_DX_AC3_MPP32_39		0x00000001
+
+#define DB_DX_AC3_NOR_MPP0_7	0x44444444
+#define DB_DX_AC3_NOR_MPP8_15	0x11444444
+#define DB_DX_AC3_NOR_MPP16_23	0x44443344
+
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+0	SPI_MOSI		(out)
+1	SPI_MISO		(in)
+2	SPI_SCK			(out)
+3	SPI_CS0n		(out)
+4	NF_CEn			(out) DEV_CSn[0]
+5	PEX_RSTOUTn		(out) DEV_BOOTCSn
+6	GPIO[6]			(in/out)
+7	GPIO[7]			(in/out)
+8	GPIO[8]			(in/out)
+9	GPIO[9]			(in/out)
+10	GPIO[10]		(in/out)
+11	UART1_RXD		(in)
+12	UART1_TXD		(out)
+13	INTERRUPT_OUTn	(out)
+14	I2C_SCL			(in/out)
+15	I2C_SDA			(in/out)
+
+16	DEV_Oen_NF_Ren	(out)
+17	GPIO[17]		(out) DEV_CLK_OUT
+18	GPIO[18]		(in/out) INT_in / SD_WP / VC2_GPP
+19	NF_RBn			(in)
+20	NF_WEn			(out)    DEV_WEn[0]
+21	NF_IO[0]		(in/out) DEV_AD[0]
+22	NF_IO[1]		(in/out) DEV_AD[1]
+23	NF_IO[2]		(in/out) DEV_AD[2]
+24	NF_IO[3]		(in/out) DEV_AD[3]
+25	NF_IO[4]		(in/out) DEV_AD[4]
+26	NF_IO[5]		(in/out) DEV_AD[5]
+27	NF_IO[6]		(in/out) DEV_AD[6]
+28	NF_IO[7]		(in/out) DEV_AD[7]
+29	NF_CLE			(out) DEV_A[0]
+30	NF_ALE			(out) DEV_A[1]
+31	SLV_SMI_MDC		(in)
+32	SLV_SMI_MDIO	(in/out)
+
+*/
+#define DB_DX_AC3_GPP_OUT_ENA_LOW	(~(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 \
+				| BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30))
+#define DB_DX_AC3_GPP_OUT_ENA_MID	(~(0))
+
+#define DB_DX_AC3_GPP_OUT_VAL_LOW	(BIT0 | BIT2 | BIT3 | BIT4 | BIT6 | BIT12 \
+				| BIT13 | BIT16 | BIT17 | BIT20 | BIT29  | BIT30)
+#define DB_DX_AC3_GPP_OUT_VAL_MID	0x0
+
+#define DB_DX_AC3_GPP_POL_LOW		0x0
+#define DB_DX_AC3_GPP_POL_MID		0x0
+
+
 #endif /* __INCmvBoardEnvSpech */
 
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.c b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
index e9bcb06..0a9bcac 100644
--- a/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
@@ -94,13 +94,21 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 MV_U32 mvCpuPclkGet(MV_VOID)
 {
-	MV_U32 idx;
-	MV_U32 freqMhz;
-	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
-	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
+	MV_U32			idx;
+	MV_U32			freqMhz;
+	MV_CPUDDR_MODE	bc2ClockRatioTbl[8] = MV_CPU_DDR_CLK_TBL_BC2;
+	MV_CPUDDR_MODE	ac3ClockRatioTbl[8] = MV_CPU_DDR_CLK_TBL_AC3;
+	MV_U16			family = mvCtrlDevFamilyIdGet(0);
+	MV_U32			sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
 
 	idx = MSAR_CPU_DDR_CLK(0, sar2);
-	freqMhz = clockRatioTbl[idx].cpuFreq * 1000000;
+	if (family == MV_BOBCAT2_DEV_ID)
+		freqMhz = bc2ClockRatioTbl[idx].cpuFreq * 1000000;
+	else if (family == MV_ALLEYCAT3_DEV_ID)
+		freqMhz = ac3ClockRatioTbl[idx].cpuFreq * 1000000;
+	else
+		return 0xFFFFFFFF;
+
 	return freqMhz;
 }
 
@@ -122,13 +130,21 @@ MV_U32 mvCpuPclkGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCpuDdrClkGet(MV_VOID)
 {
-	MV_U32 idx;
-	MV_U32 freqMhz;
-	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
-	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
+	MV_U32			idx;
+	MV_U32			freqMhz;
+	MV_CPUDDR_MODE	bc2ClockRatioTbl[8] = MV_CPU_DDR_CLK_TBL_BC2;
+	MV_CPUDDR_MODE	ac3ClockRatioTbl[8] = MV_CPU_DDR_CLK_TBL_AC3;
+	MV_U16			family = mvCtrlDevFamilyIdGet(0);
+	MV_U32			sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
 
 	idx = MSAR_CPU_DDR_CLK(0, sar2);
-	freqMhz = clockRatioTbl[idx].ddrFreq * 1000000;
+	if (family == MV_BOBCAT2_DEV_ID)
+		freqMhz = bc2ClockRatioTbl[idx].ddrFreq * 1000000;
+	else if (family == MV_ALLEYCAT3_DEV_ID)
+		freqMhz = ac3ClockRatioTbl[idx].ddrFreq * 1000000;
+	else
+		return 0xFFFFFFFF;
+
 	return freqMhz;
 }
 /*******************************************************************************
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
index abcf088..19183d3 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -472,7 +472,9 @@ MV_U32 mvCtrlSdioSupport(MV_VOID)
 *******************************************************************************/
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
-	return MV_BOBCAT2_DEV_ID;
+	/* Currently the controller ID is derived from board according to msys family (BC2/AC3)
+	   It must be updated in case of new flavours of AC3 or BC2 */
+	return mvCtrlDevFamilyIdGet(0);
 }
 
 /*******************************************************************************
@@ -597,7 +599,16 @@ MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
 *******************************************************************************/
 MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
 {
-	return MV_BOBCAT2_DEV_ID;
+	MV_U32	boardId = mvBoardIdGet();
+
+	if ((boardId >= BC2_CUSTOMER_BOARD_ID_BASE) && (boardId < BC2_MARVELL_MAX_BOARD_ID))
+		return MV_BOBCAT2_DEV_ID;
+	else if ((boardId >= AC3_CUSTOMER_BOARD_ID_BASE) && (boardId < AC3_MARVELL_MAX_BOARD_ID))
+		return MV_ALLEYCAT3_DEV_ID;
+	else {
+		DB(mvOsPrintf("%s: ERR. Invalid Board ID (%d) ,Using BC2 as default family\n", __func__, boardId));
+		return MV_BOBCAT2_DEV_ID;
+	}
 }
 
 static const char *cntrlName[] = TARGETS_NAME_ARRAY;
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
index 44da435..627a55a 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -162,10 +162,10 @@ extern "C" {
 #define DFX_DEVICE_SAR_REG(x)			(0xf8200 +(x*4))
 
 #define MSAR_CORE_CLK(sar1, sar2)		(((sar2) >> 21) & 0x7)		/* PLL 0 config */
-#define MSAR_CPU_DDR_CLK(sar1, sar2)		(((sar2) >> 18) & 0x7)		/* PLL 1 config */
+#define MSAR_CPU_DDR_CLK(sar1, sar2)	(((sar2) >> 18) & 0x7)		/* PLL 1 config */
 #define MSAR_TM_CLK(sar1, sar2)			(((sar2) >> 15) & 0x7)		/* PLL 2 config */
 #define MSAR_BOOT_MODE(sar1, sar2)		(((sar1) >> 13) & 0x7)		/* boot from */
-#define MSAR_DEVICE_MODE(sar1, sar2)		(((sar1) >>  0) & 0xFF)		/* DEVICE ID field */
+#define MSAR_DEVICE_MODE(sar1, sar2)	(((sar1) >>  0) & 0xFF)		/* DEVICE ID field */
 
 #define SAR1_BOOT_FROM_NOR			0
 #define SAR1_BOOT_FROM_NAND			1
@@ -300,41 +300,60 @@ typedef enum {
 } MV_PEXIF_INDX;
 
 typedef struct {
-	MV_U32 	cpuFreq;
-	MV_U32 	ddrFreq;
-	MV_STATUS internalFreq;
+	MV_U32		cpuFreq;
+	MV_U32		ddrFreq;
+	MV_STATUS	internalFreq;
 } MV_CPUDDR_MODE;
 
 typedef struct {
-	MV_U32 	tmFreq;
-	MV_U32 	ddr3Freq;
-	MV_STATUS internalFreq;
+	MV_U32		tmFreq;
+	MV_U32		ddr3Freq;
+	MV_STATUS	internalFreq;
 } MV_TM_MODE;
 
-#define MV_CORE_CLK_TBL	{	\
-	360, 220, 		\
-	250, 400,               \
-	500, 520,               \
-	450                     \
+#define MV_CORE_CLK_TBL_BC2	{	\
+		360, 220,			\
+		250, 400,			\
+		500, 520,			\
+		450					\
+	}
+
+#define MV_CORE_CLK_TBL_AC3	{	\
+		290, 250,			\
+		222, 167,			\
+		200, 133,			\
+		360					\
+	}
+
+
+#define MV_CPU_DDR_CLK_TBL_BC2 {	\
+		{ 400, 400, MV_FALSE},	\
+		{ 533, 533, MV_TRUE},	\
+		{ 667, 667, MV_FALSE},	\
+		{ 800, 800, MV_FALSE},	\
+		{1000, 500, MV_TRUE},	\
+		{1200, 600, MV_TRUE},	\
+		{1333, 666, MV_TRUE}	\
 }
 
-#define MV_CPU_DDR_CLK_TBL {	\
-	{ 400, 400, MV_FALSE},  \
-	{ 533, 533, MV_TRUE},   \
-	{ 667, 667, MV_FALSE},  \
-	{ 800, 800, MV_FALSE},  \
-	{1000, 500, MV_TRUE},   \
-	{1200, 600, MV_TRUE},   \
-	{1333, 666, MV_TRUE}    \
+#define MV_CPU_DDR_CLK_TBL_AC3 {	\
+		{ 400, 400, MV_FALSE},	\
+		{ 533, 533, MV_TRUE},	\
+		{ 667, 667, MV_FALSE},	\
+		{ 800, 800, MV_FALSE},	\
+		{   0,   0, MV_TRUE},	\
+		{ 800, 400, MV_FALSE},	\
+		{ 800, 400, MV_TRUE},	\
 }
-#define MV_TM_CLK_TBL	{ 	\
-	{   0,   0, MV_TRUE},   \
-	{ 400, 800, MV_FALSE},  \
-	{ 466, 933, MV_FALSE},  \
-	{ 333, 667, MV_FALSE},  \
-	{   0,   0, MV_TRUE},   \
-	{ -1, 800, MV_TRUE},    \
-	{ -1, 933, MV_TRUE}     \
+
+#define MV_TM_CLK_TBL	{	\
+	{   0,   0, MV_TRUE},	\
+	{ 400, 800, MV_FALSE},	\
+	{ 466, 933, MV_FALSE},	\
+	{ 333, 667, MV_FALSE},	\
+	{   0,   0, MV_TRUE},	\
+	{  -1, 800, MV_TRUE},	\
+	{  -1, 933, MV_TRUE}	\
 }
 
 #endif /* MV_ASMLANGUAGE */
@@ -343,4 +362,4 @@ typedef struct {
 }
 #endif /* __cplusplus */
 
-#endif
+#endif /* __INCmvCtrlEnvRegsh */
-- 
1.7.5.4

