From 96acf6c59f6bc45bb43c25f11207de3d95953909 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Wed, 11 Dec 2013 19:00:59 +0200
Subject: [PATCH 1216/1825] pp3: EMAC add basic support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 662043b39ce567f148821dd8ee21013006667563

	- mv_emac.h and mv_emac.c basic API
	- add emac to makefile

Change-Id: I99a629a7f26ae14f61538c5ea8de567e967582e8
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4714
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Makefile          |    2 +-
 drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h |    1 +
 drivers/net/ethernet/marvell/pp3/emac/mv_emac.c    |  303 +++++++++++++++++++-
 drivers/net/ethernet/marvell/pp3/emac/mv_emac.h    |   68 +++++-
 4 files changed, 370 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/Makefile b/drivers/net/ethernet/marvell/pp3/Makefile
index dcdcfc3..f1a5997 100644
--- a/drivers/net/ethernet/marvell/pp3/Makefile
+++ b/drivers/net/ethernet/marvell/pp3/Makefile
@@ -6,4 +6,4 @@ obj-$(CONFIG_MV_PP3) += mv_pp3.o
 
 ccflags-y       += -Idrivers/net/ethernet/marvell/pp3
 
-mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o
+mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o emac/mv_emac.o
diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
index 1c8fe82..95d7f21 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
@@ -68,6 +68,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/kernel.h>
 #include <linux/io.h>
 
+
 #define INLINE inline
 #define MV_PPV3_BASE_ADDR 0
 
diff --git a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
index 9f73bff..1e732fd 100644
--- a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
+++ b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.c
@@ -67,5 +67,304 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/io.h>
 #include <linux/slab.h>
 #include "common/mv_hw_if.h"
-#include "hmac/mv_emac.h"
-#include "hmac/mv_emac_regs.h"
+#include "emac/mv_emac.h"
+#include "emac/mv_emac_regs.h"
+
+static struct mv_pp3_emac_ctrl pp3_emac[MV_PP3_EMAC_MAX];
+
+/*--------------------------------------------------------------*/
+/*--------------------- EMAC globals ---------------------------*/
+/*--------------------------------------------------------------*/
+
+
+u32 mv_pp3_emac_reg_read(int port, u32 reg)
+{
+	u32 reg_data;
+
+	mv_pp3_hw_read(reg + pp3_emac[port].base, 1, &reg_data);
+
+	if (pp3_emac[port].flags & MV_PP3_EMAC_F_DEBUG)
+		pr_info("read     : 0x%x = 0x%08x\n", reg, reg_data);
+
+	return reg_data;
+}
+
+void mv_pp3_emac_reg_write(int port, u32 reg, u32 data)
+{
+	mv_pp3_hw_write(reg + pp3_emac[port].base, 1, &data);
+
+	if (pp3_emac[port].flags & MV_PP3_EMAC_F_DEBUG) {
+		u32 reg_data;
+		pr_info("write    : 0x%x = 0x%08x\n", reg, data);
+		mv_pp3_hw_read(reg + pp3_emac[port].base, 1, &reg_data);
+		pr_info("read back: 0x%x = 0x%08x\n", reg, reg_data);
+	}
+}
+
+static void mv_pp3_emac_reg_print(int port, char *reg_name, u32 reg)
+{
+	pr_info("  %-32s: 0x%x = 0x%08x\n", reg_name, reg, mv_pp3_emac_reg_read(port, reg));
+}
+
+void mv_pp3_emac_init(int port, u32 base)
+{
+	/* attach to QM */
+	/* TODO config the correct values of qm_q and qm_port */
+	mv_pp3_emac_qm_mapping(port, port, port);
+
+	/* enable MH */
+	mv_pp3_emac_mh_en(port, 1);
+
+	pp3_emac[port].base = base;
+	pp3_emac[port].flags |= MV_PP3_EMAC_F_ATTACH;
+}
+
+/* enable debug flag */
+void mv_pp3_emac_debug(int port, int en)
+{
+	if (en)
+		pp3_emac[port].flags |= MV_PP3_EMAC_F_DEBUG_BIT;
+	else
+		pp3_emac[port].flags &= ~MV_PP3_EMAC_F_DEBUG_BIT;
+}
+
+/* set QM Enq queu and Deq port */
+void mv_pp3_emac_qm_mapping(int port, int qm_port, int qm_q)
+{
+	u32 data;
+
+	data = (qm_q << MV_EMAC_AXI_CFG_AXI4_ENQ_QUEUE_NUM_OFFS) |
+		(qm_port << MV_EMAC_AXI_CFG_AXI4_DEQ_PORT_NUM_OFFS);
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_AXI_CFG_REG, data);
+}
+
+/* add mh in rx and strip in tx - enable/disable */
+void mv_pp3_emac_mh_en(int port, int en)
+{
+	u32 data_rx, data_tx;
+
+	data_rx = mv_pp3_emac_reg_read(port, MV_EMAC_ENQ_CR_REG);
+	data_tx = mv_pp3_emac_reg_read(port, MV_EMAC_DEQ_CR_REG);
+
+	if (en) {
+		data_rx |= MV_EMAC_ENQ_CR_ENQ_CR_ADD_MH_MASK;
+		data_tx |= MV_EMAC_DEQ_CR_DEQ_STRIP_MH_MASK;
+	} else {
+		data_rx &= ~MV_EMAC_ENQ_CR_ENQ_CR_ADD_MH_MASK;
+		data_tx &= ~MV_EMAC_DEQ_CR_DEQ_STRIP_MH_MASK;
+	}
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_ENQ_CR_REG, data_rx);
+	mv_pp3_emac_reg_write(port, MV_EMAC_DEQ_CR_REG, data_tx);
+}
+
+/*
+set source of timestamp
+	from = 0: from RTC
+	from = 1: from descriptor
+*/
+void mv_pp3_emac_ts(int port, int from)
+{
+	u32 data_rx, data_tx;
+
+	data_rx = mv_pp3_emac_reg_read(port, MV_EMAC_ENQ_CR_REG);
+	data_tx = mv_pp3_emac_reg_read(port, MV_EMAC_DEQ_CR_REG);
+
+	if (from) {
+		data_rx |= MV_EMAC_ENQ_CR_ENQ_CR_TIMESTAMP_FROM_DESCRIPTOR_MASK;
+		data_tx |= MV_EMAC_DEQ_CR_DEQ_TX_SOP_DESC_INGRS_TIME_STMP_FROM_CFH_MASK;
+	} else {
+		data_rx &= ~MV_EMAC_ENQ_CR_ENQ_CR_TIMESTAMP_FROM_DESCRIPTOR_MASK;
+		data_tx &= ~MV_EMAC_DEQ_CR_DEQ_TX_SOP_DESC_INGRS_TIME_STMP_FROM_CFH_MASK;
+	}
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_ENQ_CR_REG, data_rx);
+	mv_pp3_emac_reg_write(port, MV_EMAC_DEQ_CR_REG, data_tx);
+}
+
+/* dump emac registers */
+void mv_pp3_emac_regs(int port)
+{
+	mv_pp3_emac_reg_print(port, "CR", MV_EMAC_CR_REG);
+	mv_pp3_emac_reg_print(port, "ENQ", MV_EMAC_ENQ_CR_REG);
+	mv_pp3_emac_reg_print(port, "ENQ_CFH_MH", MV_EMAC_ENQ_CFH_MH_REG);
+	mv_pp3_emac_reg_print(port, "ENQ_DESC_W0", MV_EMAC_ENQ_DESC_W0_REG);
+	mv_pp3_emac_reg_print(port, "ENQ_DESC_W1", MV_EMAC_ENQ_DESC_W1_REG);
+	mv_pp3_emac_reg_print(port, "AXI_CFG", MV_EMAC_AXI_CFG_REG);
+	mv_pp3_emac_reg_print(port, "ENQ_DRP_PKT_CNT", MV_EMAC_ENQ_DRP_PKT_CNT_REG);
+	mv_pp3_emac_reg_print(port, "DEQ_CR", MV_EMAC_DEQ_CR_REG);
+	mv_pp3_emac_reg_print(port, "MIN_PKT_LEN", MV_EMAC_MIN_PKT_LEN_REG);
+	mv_pp3_emac_reg_print(port, "DEQ_RTC_STRM_VAL", MV_EMAC_DEQ_RTC_STRM_VAL_REG);
+	mv_pp3_emac_reg_print(port, "DEQ_RTC_PORT_VAL", MV_EMAC_DEQ_RTC_PORT_VAL_REG);
+
+	pr_info("-------------- debug regs -----------\n");
+
+	mv_pp3_emac_reg_print(port, "DBG_SM_STATUS", MV_EMAC_DBG_SM_STATUS_REG);
+	mv_pp3_emac_reg_print(port, "DBG_FIFO_FILL_LVL1", MV_EMAC_DBG_FIFO_FILL_LVL1_REG);
+	mv_pp3_emac_reg_print(port, "DBG_FIFO_FILL_LVL2", MV_EMAC_DBG_FIFO_FILL_LVL2_REG);
+}
+
+/* enable/disable loopback forom TX to RX */
+void mv_pp3_emac_loopback(int port, int lb)
+{
+	u32 data;
+
+	data = mv_pp3_emac_reg_read(port, MV_EMAC_CR_REG);
+
+	if (lb)
+		data |= MV_EMAC_CR_LOOPBACK_EN_MASK;
+	else
+		data &= ~MV_EMAC_CR_LOOPBACK_EN_MASK;
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_CR_REG, data);
+}
+
+/* enable/disable emac rx */
+void mv_pp3_emac_rx_enable(int port, int en)
+{
+	u32 data;
+
+	data = mv_pp3_emac_reg_read(port, MV_EMAC_CR_REG);
+
+	if (en)
+		data |= MV_EMAC_CR_ENQ_EN_MASK;
+	else
+		data &= ~MV_EMAC_CR_ENQ_EN_MASK;
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_CR_REG, data);
+
+	/*TODO do we need to wait to interrupt bit*/
+}
+
+/*
+set offset to CFH after 16B descriptor
+	bytes: 0-64 in multiples of 8 (0, 8, 16, etc.)
+*/
+int mv_pp3_emac_rx_desc_rsvd(int port, int bytes)
+{
+	u32 data;
+
+	/* TODO: do we need bytes validation here ? */
+	if (bytes % 8)
+		return 1;
+
+	data = mv_pp3_emac_reg_read(port, MV_EMAC_ENQ_CR_REG);
+
+	data &= ~MV_EMAC_ENQ_CR_ENQ_CR_CFH_OFFSET_MASK;
+	data |= ((bytes/8) << MV_EMAC_ENQ_CR_ENQ_CR_CFH_OFFSET_OFFS);
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_ENQ_CR_REG, data);
+
+	return 0;
+}
+
+/* set mh value, relevant only if mh is enable */
+void mv_pp3_emac_rx_mh(int port, short mh)
+{
+	u32 data;
+
+	data = mv_pp3_emac_reg_read(port, MV_EMAC_ENQ_CFH_MH_REG);
+
+	data &= ~MV_EMAC_ENQ_CFH_MH_EMAC_ENQ_CFH_MH_MASK;
+	data |= (mh << MV_EMAC_ENQ_CFH_MH_EMAC_ENQ_CFH_MH_OFFS);
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_ENQ_CFH_MH_REG, data);
+}
+
+/*
+set the minimum packet length that will sent to GOP
+	bytes: length in bytes, valid range [16, 64]
+*/
+void mv_pp3_emac_tx_min_pkt_len(int port, int bytes)
+{
+	u32 data;
+
+	/* TODO: do we need bytes validation here ? */
+
+	data = mv_pp3_emac_reg_read(port, MV_EMAC_MIN_PKT_LEN_REG);
+
+	data &= ~MV_EMAC_MIN_PKT_LEN_DEQ_MIN_PKT_LEN_MASK;
+	data |= (bytes << MV_EMAC_MIN_PKT_LEN_DEQ_MIN_PKT_LEN_OFFS);
+
+	mv_pp3_emac_reg_write(port, MV_EMAC_MIN_PKT_LEN_REG, data);
+}
+
+/*--------------------------------------------------------------*/
+/*------------------------- PFC --------------------------------*/
+/*--------------------------------------------------------------*/
+
+/* dump emac pfc registers */
+void mv_pp3_emac_pfc_regs(int port)
+{
+	int i;
+	/*char buf[64];*/
+
+	mv_pp3_emac_reg_print(port, "ENQ_XOFF_CNT", MV_EMAC_ENQ_XOFF_CNT_REG);
+
+	pr_info("/n");
+
+	for (i = 0; i < MV_EMAC_PFC_PRIO_MAX; i++) {
+		/* TODO: open next line */
+		/* pr_info(buf, "%s[%d]", "PFC_TBL_ADDR", i); */
+		mv_pp3_emac_reg_print(port, "PFC_TBL_ADDR", MV_EMAC_PFC_TBL_ADDR_REG(i));
+	}
+
+	pr_info("/n");
+
+	for (i = 0; i < MV_EMAC_PFC_PRIO_MAX; i++) {
+		/* TODO: open next line */
+		/* mvOsSPrintf(buf, "%s[%d]", "PFC_TBL_PAUSE", i);*/
+		mv_pp3_emac_reg_print(port, "PFC_TBL_PAUSE", MV_EMAC_PFC_TBL_PAUSE_VAL_REG(i));
+	}
+
+	pr_info("/n");
+
+	for (i = 0; i < MV_EMAC_PFC_PRIO_MAX; i++) {
+		/* TODO: open next line */
+		/* mvOsSPrintf(buf, "%s[%d]", "PFC_TBL_RESUME", i);*/
+		mv_pp3_emac_reg_print(port, "PFC_TBL_RESUME", MV_EMAC_PFC_TBL_RESUME_VAL_REG(i));
+	}
+}
+
+/*
+set pfc table address
+	prio: priority 0-7
+	val: address
+*/
+void mv_pp3_emac_pfc_tbl_addr(int port, int prio, u32 val)
+{
+	/* TODO: add parameters validation */
+	mv_pp3_emac_reg_write(port, MV_EMAC_PFC_TBL_ADDR_REG(prio), val);
+}
+/*
+set pfc table address
+	prio: priority 0-7
+	val: pause value
+*/
+void mv_pp3_emac_pfc_tbl_pause(int port, int prio, u32 val)
+{
+	mv_pp3_emac_reg_write(port, MV_EMAC_PFC_TBL_PAUSE_VAL_REG(prio), val);
+}
+/*
+set pfc table address
+	prio: priority 0-7
+	val: resume value
+*/
+void mv_pp3_emac_pfc_tbl_resume(int port, int prio, u32 val)
+{
+	mv_pp3_emac_reg_write(port, MV_EMAC_PFC_TBL_RESUME_VAL_REG(prio), val);
+}
+
+
+
+/*--------------------------------------------------------------*/
+/*------------------------ EMAC WOL ----------------------------*/
+/*--------------------------------------------------------------*/
+
+void mv_pp3_emac_wol_regs(int port)
+{
+	return;
+}
+
+/* TODO */
diff --git a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
index 2623d6e..da3525d 100644
--- a/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
+++ b/drivers/net/ethernet/marvell/pp3/emac/mv_emac.h
@@ -65,5 +65,71 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __mvEmac_h__
 #define __mvEmac_h__
 
+/*--------------------------------------------------------------*/
+/*--------------------- EMAC globals ---------------------------*/
+/*--------------------------------------------------------------*/
 
-#endif /* __mvHmac_h__ */
+/* temporary defenition */
+#define MV_PP3_EMAC_MAX		4
+
+struct mv_pp3_emac_ctrl {
+	u32 base;
+	u32 flags;
+};
+
+/* mv_pp3_emac_ctrl flags */
+
+
+#define MV_PP3_EMAC_F_DEBUG_BIT		0
+#define MV_PP3_EMAC_F_ATTACH_BIT	1
+
+#define MV_PP3_EMAC_F_DEBUG		(1 << MV_PP3_EMAC_F_DEBUG_BIT)
+#define MV_PP3_EMAC_F_ATTACH		(1 << MV_PP3_EMAC_F_ATTACH_BIT)
+
+
+u32  mv_pp3_emac_reg_read(int port, u32 reg);
+
+void mv_pp3_emac_reg_write(int port, u32 reg, u32 data);
+
+void mv_pp3_emac_init(int port, u32 base);
+
+void mv_pp3_emac_qm_mapping(int port, int qm_port, int qm_q);
+
+void mv_pp3_emac_mh_en(int port, int en);
+
+void mv_pp3_emac_ts(int port, int from);
+
+void mv_pp3_emac_loopback(int port, int lb);
+
+void mv_pp3_emac_regs(int port);
+
+void mv_pp3_emac_debug(int port, int en);
+
+void mv_pp3_emac_rx_enable(int port, int en);
+
+int mv_pp3_emac_rx_desc_rsvd(int port, int bytes);
+
+void mv_pp3_emac_rx_mh(int port, short mh);
+
+void mv_pp3_emac_tx_min_pkt_len(int port, int bytes);
+
+/*--------------------------------------------------------------*/
+/*------------------------- PFC --------------------------------*/
+/*--------------------------------------------------------------*/
+
+#define MV_EMAC_PFC_PRIO_MAX	8
+
+void mv_pp3_emac_pfc_tbl_addr(int port, int prio, u32 val);
+void mv_pp3_emac_pfc_tbl_pause(int port, int prio, u32 val);
+void mv_pp3_emac_pfc_tbl_resume(int port, int prio, u32 val);
+void mv_pp3_emac_pfc_regs(int port);
+
+/*--------------------------------------------------------------*/
+/*-------------------------- WOL -------------------------------*/
+/*--------------------------------------------------------------*/
+
+void mv_pp3_emac_wol_regs(int port);
+/* TODO */
+
+
+#endif /* __mvEmac_h__ */
-- 
1.7.5.4

