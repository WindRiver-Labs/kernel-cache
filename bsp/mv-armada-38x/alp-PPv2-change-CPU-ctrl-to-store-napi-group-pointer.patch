From 437be28858210bce1c43b0401efe0b07e251de97 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Mon, 15 Jul 2013 10:50:55 +0300
Subject: [PATCH 0826/1825] alp: PPv2: change CPU ctrl to store napi group
 pointer instead of ID

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9f40137ea7d6679d622877055a8025556f065da4

	To make code look simpler, CPU ctrl will now keep pointer to napi group
	Before, CPU ctrl kept napi group's ID

Change-Id: I884dec756ab4033d6c3475f8e60bf4c0fe595ab8
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2627
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   28 ++++++++++---------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   25 +++++++++--------
 2 files changed, 28 insertions(+), 25 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 6b6c778..11ce592 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -260,6 +260,7 @@ int mv_eth_port_napi_group_create(int port, int group)
 	memset(napi_group->napi, 0, sizeof(struct napi_struct));
 	netif_napi_add(pp->dev, napi_group->napi, mv_eth_poll, pp->weight);
 	pp->napi_group[group] = napi_group;
+	napi_group->id = group;
 
 	return 0;
 }
@@ -333,11 +334,11 @@ int mv_eth_napi_set_cpu_affinity(int port, int group, int cpu_mask)
 
 	mv_eth_interrupts_mask(pp);
 	smp_call_function_many(cpu_online_mask, (smp_call_func_t)mv_eth_interrupts_mask, (void *)pp, 1);
-	/* remove group id from cpus that were belong to this group */
+	/* update group's CPU mask - remove old CPUs using this group */
 	for_each_possible_cpu(cpu) {
-		if (pp->cpu_config[cpu]->napi_group_id == group) {
+		if (pp->cpu_config[cpu]->napi_group == napi_group) {
 			mvPp2GbeCpuInterruptsDisable(port, cpu);
-			pp->cpu_config[cpu]->napi_group_id = -1;
+			pp->cpu_config[cpu]->napi_group = NULL;
 		}
 	}
 	napi_group->cpu_mask = cpu_mask;
@@ -346,7 +347,7 @@ int mv_eth_napi_set_cpu_affinity(int port, int group, int cpu_mask)
 	for_each_possible_cpu(cpu)
 		if ((1 << cpu) & cpu_mask) {
 			mvPp2GbeCpuInterruptsEnable(port, cpu);
-			pp->cpu_config[cpu]->napi_group_id = group;
+			pp->cpu_config[cpu]->napi_group = napi_group;
 		}
 	/* mask rx interrupts for every cpu according to its napi group */
 	mv_eth_interrupts_unmask(pp);
@@ -2700,9 +2701,9 @@ static struct bm_pool *mv_eth_pool_use(int pool, enum mv_eth_bm_type type, int p
 irqreturn_t mv_eth_isr(int irq, void *dev_id)
 {
 	struct eth_port *pp = (struct eth_port *)dev_id;
-	int cpu, group = pp->cpu_config[smp_processor_id()]->napi_group_id;
-	struct napi_group_ctrl *napi_group = pp->napi_group[group];
+	struct napi_group_ctrl *napi_group = pp->cpu_config[smp_processor_id()]->napi_group;
 	struct napi_struct *napi = napi_group->napi;
+	int cpu;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->dbg_flags & MV_ETH_F_DBG_ISR) {
@@ -2826,7 +2827,7 @@ void mv_eth_link_event(struct eth_port *pp, int print)
 /***********************************************************************************************/
 int mv_eth_poll(struct napi_struct *napi, int budget)
 {
-	int rx_done = 0, group_id, cpu;
+	int rx_done = 0, cpu;
 	struct napi_group_ctrl *napi_group;
 	MV_U32 causeRxTx;
 	struct eth_port *pp = MV_ETH_PRIV(napi->dev);
@@ -2876,8 +2877,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		causeRxTx &= ~MV_PP2_CAUSE_MISC_SUM_MASK;
 		mvPp2WrReg(MV_PP2_ISR_RX_TX_CAUSE_REG(MV_PPV2_PORT_PHYS(pp->port)), causeRxTx);
 	}
-	group_id = pp->cpu_config[smp_processor_id()]->napi_group_id;
-	napi_group = pp->napi_group[group_id];
+	napi_group = pp->cpu_config[smp_processor_id()]->napi_group;
 	causeRxTx |= napi_group->cause_rx_tx;
 
 #ifdef CONFIG_MV_ETH_TXDONE_ISR
@@ -2939,6 +2939,7 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		local_irq_restore(flags);
 	}
 	napi_group->cause_rx_tx = causeRxTx;
+
 	return rx_done;
 }
 
@@ -3543,7 +3544,7 @@ static int mv_eth_netdev_connect(struct eth_port *pp)
 
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
-		cpuCtrl->napi_group_id = -1;
+		cpuCtrl->napi_group = NULL;
 		cpuCtrl->tx_done_timer.data = (unsigned long)dev;
 		cpuCtrl->cleanup_timer.data = (unsigned long)dev;
 	}
@@ -4673,14 +4674,15 @@ void mv_eth_port_status_print(unsigned int port)
 		pp->tx_spec.hw_cmd[1], pp->tx_spec.hw_cmd[2]);
 
 	printk(KERN_CONT "\n");
-	printk(KERN_CONT "CPU:   txq_def   napi_group_id\n");
+	printk(KERN_CONT "CPU:   txq_def   napi_group   group_id\n");
 	{
 		int cpu;
 		for_each_possible_cpu(cpu) {
 			cpuCtrl = pp->cpu_config[cpu];
 			if (MV_BIT_CHECK(pp->cpuMask, cpu))
-				printk(KERN_ERR "  %d:      %d      %d\n",
-					cpu, cpuCtrl->txq, cpuCtrl->napi_group_id);
+				printk(KERN_ERR "  %d:   %3d        %p    %3d\n",
+					cpu, cpuCtrl->txq, cpuCtrl->napi_group,
+					(cpuCtrl->napi_group != NULL) ? cpuCtrl->napi_group->id : -1);
 		}
 	}
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index aa80879..2df3283 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -322,21 +322,22 @@ struct dist_stats {
 	int     tx_tso_dist_size;
 };
 
-struct cpu_ctrl {
-	int			napi_group_id;
-	int             	txq;
-	struct timer_list   	tx_done_timer;
-	struct timer_list   	cleanup_timer;
-	unsigned long       	flags;
-};
-
 struct napi_group_ctrl {
+	int			id;
 	MV_U8			cpu_mask;
 	MV_U16			rxq_mask;
 	MV_U32			cause_rx_tx;
 	struct napi_struct	*napi;
 };
 
+struct cpu_ctrl {
+	struct napi_group_ctrl	*napi_group;
+	int			txq;
+	struct timer_list	tx_done_timer;
+	struct timer_list	cleanup_timer;
+	unsigned long		flags;
+};
+
 struct eth_port {
 	int                 port;
 	bool                tagged; /* NONE/MH/DSA/EDSA/VLAN */
@@ -504,14 +505,14 @@ static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_de
 
 static inline void mv_eth_interrupts_unmask(struct eth_port *pp)
 {
-	int cpu = smp_processor_id(), group_id;
+	int cpu = smp_processor_id();
 	struct napi_group_ctrl *napi_group;
 
-	group_id = pp->cpu_config[cpu]->napi_group_id;
-	if (group_id < 0)
+	napi_group = pp->cpu_config[cpu]->napi_group;
+
+	if (napi_group == NULL)
 		return;
 
-	napi_group = pp->napi_group[group_id];
 
 	/* unmask interrupts - for RX unmask only RXQs that are in the same napi group */
 #ifdef CONFIG_MV_ETH_TXDONE_ISR
-- 
1.7.5.4

