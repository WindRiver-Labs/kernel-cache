From 155c53ca57fcee9970ad46306b52e79ec3d79c5e Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Sun, 14 Jul 2013 19:36:19 +0300
Subject: [PATCH 0824/1825] avanta: remove customer and mac learning source
 code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 08197d32ef68016fd1f3885980c0bc08a43eb04d

        Remove any related PON source code from LSP
        compilation and updated config files accordingly

Change-Id: I86162ff4c076aca7f42e12d37bb8febdcf36ba63
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/mv88f6500_defconfig               |    7 -
 arch/arm/mach-feroceon-kw2/Makefile                |   15 -
 arch/arm/mach-feroceon-kw2/config/mvRules.mk       |   28 +-
 arch/arm/plat-feroceon/Kconfig                     |   24 +-
 .../plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig   |   34 -
 .../plat-feroceon/mv_drivers_lsp/mv_cust/Makefile  |   21 -
 .../mv_drivers_lsp/mv_cust/mv_cust_dev.c           |  377 -----
 .../mv_drivers_lsp/mv_cust/mv_cust_dev.h           |   81 --
 .../mv_drivers_lsp/mv_cust/mv_cust_flow_map.c      | 1076 ---------------
 .../mv_drivers_lsp/mv_cust/mv_cust_flow_map.h      |  359 -----
 .../mv_drivers_lsp/mv_cust/mv_cust_mng_if.h        |  111 --
 .../mv_drivers_lsp/mv_cust/mv_cust_mod.c           |   63 -
 .../mv_drivers_lsp/mv_cust/mv_cust_netdev.c        | 1441 --------------------
 .../mv_drivers_lsp/mv_cust/mv_cust_netdev.h        |  112 --
 .../mv_drivers_lsp/mv_cust/mv_cust_sysfs.c         |  525 -------
 .../plat-feroceon/mv_drivers_lsp/mv_ezxml/Makefile |   14 -
 .../plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.c  | 1184 ----------------
 .../plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.h  |  169 ---
 .../mv_drivers_lsp/mv_mac_learn/Kconfig            |    9 -
 .../mv_drivers_lsp/mv_mac_learn/Makefile           |   21 -
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.c |  284 ----
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.h |  158 ---
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.c  |  623 ---------
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.h  |   95 --
 .../mv_mac_learn/mv_mac_learn_header.h             |   44 -
 .../mv_mac_learn/mv_mac_learn_logic.c              |  605 --------
 .../mv_mac_learn/mv_mac_learn_logic.h              |   46 -
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.c |  720 ----------
 .../mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.h |  119 --
 .../mv_mac_learn/mv_mac_learn_netdev.c             |  107 --
 .../mv_mac_learn/mv_mac_learn_netdev.h             |   50 -
 .../mv_mac_learn/mv_mac_learn_sysfs.c              |  790 -----------
 .../mv_mac_learn/mv_mac_learn_sysfs.h              |   64 -
 33 files changed, 9 insertions(+), 9367 deletions(-)
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Makefile
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mng_if.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mod.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_sysfs.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/Makefile
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Kconfig
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Makefile
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_header.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.h
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.c
 delete mode 100644 arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.h

diff --git a/arch/arm/configs/mv88f6500_defconfig b/arch/arm/configs/mv88f6500_defconfig
index 6797544..a6b701d 100644
--- a/arch/arm/configs/mv88f6500_defconfig
+++ b/arch/arm/configs/mv88f6500_defconfig
@@ -62,19 +62,12 @@ CONFIG_MV_ETH_GROUP0_CPU=0x1
 CONFIG_MV_PON=y
 CONFIG_MV_ETH_SWITCH=y
 CONFIG_MV_ETH_SWITCH_NETDEV_NUM=6
-CONFIG_SCSI_MVSATA=y
-CONFIG_MV_SATA_SUPPORT_ATAPI=y
-CONFIG_MV_SATA_ENABLE_1MB_IOS=y
 # CONFIG_MV_UART_POLLING_MODE is not set
 CONFIG_UBOOT_STRUCT=y
 CONFIG_MV_ETH_NETA_KW2=y
 CONFIG_MV_TDM_USE_DCO=y
 # CONFIG_PON_Z1 is not set
 CONFIG_PON_Z2=y
-CONFIG_MV_TPM_INT_LOCK=y
-CONFIG_MV_TPM_SYSFS_HELP=y
-CONFIG_MV_MAC_LEARN=y
-CONFIG_SATA_DEBUG_ON_ERROR_KW2=y
 # CONFIG_CPU_FEROCEON_OLD_ID is not set
 # CONFIG_CACHE_FEROCEON_L2 is not set
 CONFIG_AEABI=y
diff --git a/arch/arm/mach-feroceon-kw2/Makefile b/arch/arm/mach-feroceon-kw2/Makefile
index b4cf850..622dfd8 100644
--- a/arch/arm/mach-feroceon-kw2/Makefile
+++ b/arch/arm/mach-feroceon-kw2/Makefile
@@ -140,25 +140,10 @@ obj-y					+= ../plat-feroceon/mv_drivers_lsp/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
 
-#XML configuration support
-obj-y					+= ../plat-feroceon/mv_drivers_lsp/mv_ezxml/
-
 #PON
 obj-$(CONFIG_MV_GPON_KW2) += ../plat-feroceon/mv_drivers_lsp/mv_pon/
 obj-$(CONFIG_MV_EPON_KW2) += ../plat-feroceon/mv_drivers_lsp/mv_pon/
 
-#TPM
-obj-$(CONFIG_MV_TPM) += ../plat-feroceon/mv_drivers_lsp/mv_tpm/
-
-#CUST
-obj-$(CONFIG_MV_CUST) += ../plat-feroceon/mv_drivers_lsp/mv_cust/
-
-#MAC_LEARN
-obj-$(CONFIG_MV_MAC_LEARN) += ../plat-feroceon/mv_drivers_lsp/mv_mac_learn/
-
-# The rest of the drivers are compiled through the driver dir directly.
-
-
 # LSP part
 feroceon-$(CONFIG_MV_INCLUDE_USB)    	+= $(LSP_DIR)/usb.o
 feroceon-$(CONFIG_PCI)  		+= $(LSP_DIR)/pci.o
diff --git a/arch/arm/mach-feroceon-kw2/config/mvRules.mk b/arch/arm/mach-feroceon-kw2/config/mvRules.mk
index afeb617..9089e4e 100644
--- a/arch/arm/mach-feroceon-kw2/config/mvRules.mk
+++ b/arch/arm/mach-feroceon-kw2/config/mvRules.mk
@@ -48,27 +48,15 @@ HAL_NOR_DIR       = $(HAL_DIR)/norflash
 
 ifeq ($(CONFIG_MV_INCLUDE_PON),y)
 HAL_PON_DIR       = $(HAL_DIR)/pon
-LSP_EPON_CORE_DIR  = $(PLAT_DRIVERS)/mv_pon/core/epon
-LSP_GPON_CORE_DIR  = $(PLAT_DRIVERS)/mv_pon/core/gpon
-LSP_EPON_PERF_DIR  = $(PLAT_DRIVERS)/mv_pon/perf/epon
-LSP_GPON_PERF_DIR  = $(PLAT_DRIVERS)/mv_pon/perf/gpon
-LSP_EPON_PLAT_DIR  = $(PLAT_DRIVERS)/mv_pon/plat/epon
-LSP_GPON_PLAT_DIR  = $(PLAT_DRIVERS)/mv_pon/plat/gpon
-LSP_PON_PLAT_DIR   = $(PLAT_DRIVERS)/mv_pon/plat
+ifeq ($(CONFIG_MV_GPON),m)
+LSP_PON_CORE_DIR  = $(PLAT_DRIVERS)/mv_pon/core/gpon
+else
+LSP_PON_CORE_DIR  = $(PLAT_DRIVERS)/mv_pon/core/epon
 endif
-
-ifeq ($(CONFIG_MV_INCLUDE_TPM),y)
-LSP_TPM_CORE_DIR  = $(PLAT_DRIVERS)/mv_tpm/core
-LSP_TPM_PERF_DIR  = $(PLAT_DRIVERS)/mv_tpm/perf
-LSP_TPM_PLAT_DIR  = $(PLAT_DRIVERS)/mv_tpm/plat
+LSP_PON_PERF_DIR  = $(PLAT_DRIVERS)/mv_pon/perf
+LSP_PON_PLAT_DIR  = $(PLAT_DRIVERS)/mv_pon/plat
 endif
 
-ifeq ($(CONFIG_MV_INCLUDE_CUST),y)
-LSP_CUST_CORE_DIR  = $(PLAT_DRIVERS)/mv_cust
-endif
-
-LSP_EZXML_DIR     = $(PLAT_DRIVERS)/mv_ezxml
-
 ifeq ($(CONFIG_MV_ETH_NETA_KW2),y)
 HAL_ETH_DIR       = $(HAL_DIR)/neta
 HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
@@ -160,9 +148,7 @@ DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWO
 		   -I$(PLAT_PATH_I)/$(LSP_EPON_PERF_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PERF_DIR) \
 		   -I$(PLAT_PATH_I)/$(LSP_EPON_PLAT_DIR) -I$(PLAT_PATH_I)/$(LSP_GPON_PLAT_DIR) \
 		   -I$(PLAT_PATH_I)/$(LSP_PON_PLAT_DIR) -I$(PLAT_PATH_I)/$(LSP_NET_DEV_DIR) \
-		   -I$(PLAT_PATH_I)/$(LSP_TPM_CORE_DIR) -I$(PLAT_PATH_I)/$(LSP_TPM_PLAT_DIR) \
-		   -I$(PLAT_PATH_I)/$(LSP_TPM_PERF_DIR) \
-		   -I$(PLAT_PATH_I)/$(LSP_EZXML_DIR) -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
+		   -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
 
 EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(KW2_FAM_PATH) \
                   $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/plat-feroceon/Kconfig b/arch/arm/plat-feroceon/Kconfig
index fd64074..49219f4 100644
--- a/arch/arm/plat-feroceon/Kconfig
+++ b/arch/arm/plat-feroceon/Kconfig
@@ -70,7 +70,7 @@ config MV_INCLUDE_LEGACY_NAND
 config MV_INCLUDE_INTEG_SATA
 	bool "Integrated SATA Support"
 	depends on MV88F6500 || MV88F6281 || MV78XX0
-	default y
+	default n
         ---help---
         Please don't change this configs unless you know what you are doing.
 
@@ -114,20 +114,6 @@ config MV_INCLUDE_PON
         ---help---
         Please don't change this configs unless you know what you are doing.
 
-config MV_INCLUDE_TPM
-	bool "TPM Support"
-	depends on MV88F6500
-	default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
-
-config MV_INCLUDE_CUST
-	bool "Customer driver Support"
-	depends on MV88F6500
-	default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
-
 config MV_INCLUDE_SWITCH
         bool "Ethernet Switch Support"
         depends on MV88F6500 || MV88F6281 || MV78XX0
@@ -403,18 +389,12 @@ source arch/arm/plat-feroceon/mv_drivers_lsp/mv_phone/Kconfig
 
 source arch/arm/plat-feroceon/mv_drivers_lsp/mv_tsu/Kconfig
 
-source arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig
-
 source arch/arm/plat-feroceon/mv_drivers_lsp/mv_pon/Kconfig
 
-source arch/arm/plat-feroceon/mv_drivers_lsp/mv_tpm/Kconfig
-
-source arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Kconfig
-
-
 config  SCSI_MVSATA
 	tristate "Support for Marvell Sata Adapters"
 	depends on ( MV_INCLUDE_INTEG_SATA && SCSI ) || ( PCI && SCSI )
+	default n
 	---help---
 	  Choosing this option will enable you to use the Marvell Sata
 	  adapters support with emulation as SCSI adapters.
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig
deleted file mode 100644
index 95b0d57..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Kconfig
+++ /dev/null
@@ -1,34 +0,0 @@
-menu "SoC CUST support"
-depends on MV_INCLUDE_CUST
-
-config  MV_CUST
-        bool "Support for Marvell Customer Driver"
-        default y
-        ---help---
-
-config  MV_CUST_IGMP_HANDLE
-        bool "Enable MV_CUST IGMP handling"
-        default y
-        ---help---
-
-config  MV_CUST_MLD_HANDLE
-        bool "Enable MV_CUST MLD handling"
-        default y
-        ---help---
-
-config  MV_CUST_LPBK_DETECT_HANDLE
-        bool "Enable MV_CUST UNI loopback detect handling"
-        default y
-        ---help---
-
-config  MV_CUST_UDP_SAMPLE_HANDLE
-        bool "Enable MV_CUST sample UDP handling"
-        default n
-        ---help---
-
-config  MV_CUST_FLOW_MAP_HANDLE
-        bool "Enable MV_CUST flow mapping handling"
-        default y
-        ---help---
-
-endmenu
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Makefile b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Makefile
deleted file mode 100644
index 7263834..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# Makefile for the Marvell Customer driver
-#
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifdef CONFIG_MV_HAL_RULES_PATH
-include $(srctree)/include/config/auto.conf
-include $(srctree)/$(subst ",,$(CONFIG_MV_HAL_RULES_PATH))
-endif
-
-CUST_OBJS += 	mv_cust_dev.o \
-		mv_cust_mod.o \
-		mv_cust_flow_map.o \
-		mv_cust_netdev.o \
-		mv_cust_sysfs.o
-
-mv_cust-objs := $(CUST_OBJS)
-obj-$(CONFIG_MV_CUST) += mv_cust.o
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.c
deleted file mode 100644
index 137caab..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.c
+++ /dev/null
@@ -1,377 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_dev.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/version.h>
-#include <linux/delay.h>
-#include <linux/wait.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/poll.h>
-#include <linux/clk.h>
-#include <linux/fs.h>
-#include <linux/vmalloc.h>
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-
-#include "mv_cust_dev.h"
-#include "mv_cust_netdev.h"
-#include "mv_cust_flow_map.h"
-#include "mv_cust_mng_if.h"
-
-
-/* Used to prevent multiple access to device */
-static int               mvcust_device_open = 0;
-static struct miscdevice mvcust_misc_dev;
-
-/*******************************************************************************
-**
-**  mvcust_dev_open
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function execute device open actions
-**
-**  PARAMETERS:
-**
-**
-**
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-static int mvcust_dev_open(struct inode *inode, struct file *file)
-{
-	MVCUST_DEBUG_PRINT("Enter");
-
-   // if (mvcust_device_open > 0)
-   //     return -EBUSY;
-
-	mvcust_device_open++;
-
-	return 0;
-}
-
-/*******************************************************************************
-**
-**  mvcust_dev_release
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function execute device release actions
-**
-**  PARAMETERS:
-**
-**
-**
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-static int mvcust_dev_release(struct inode *inode, struct file *file)
-{
-    MVCUST_DEBUG_PRINT("Enter");
-
-   // if (mvcust_device_open > 0)
-   //     mvcust_device_open--;
-
-	return 0;
-}
-
-/*******************************************************************************
-**
-**  mv_cust_dev_ioctl
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION: The function execute IO commands
-**
-**  PARAMETERS:
-**               struct file *filp
-**               unsigned int cmd
-**               unsigned long arg
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-static long mvcust_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-    mv_cust_ioctl_omci_set_t      cust_omci_set;
-    mv_cust_ioctl_llid_set_t      cust_llid_set;
-    mv_cust_ioctl_flow_map_t      cust_flow_map;
-    mv_cust_ioctl_dscp_map_t      cust_dscp_map;
-    mv_cust_ioctl_app_etype_t     cust_app_etype;
-    int                           enable;
-    int                           rc;
-
-    int  ret = -EINVAL;
-
-    MVCUST_DEBUG_PRINT("Enter");
-
-  switch(cmd)
-  {
-      case MV_CUST_IOCTL_OMCI_SET:
-
-          if(copy_from_user(&cust_omci_set, (mv_cust_ioctl_omci_set_t*)arg, sizeof(mv_cust_ioctl_omci_set_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          rc = mv_cust_omci_set(cust_omci_set.tcont, cust_omci_set.txq, cust_omci_set.gemport, cust_omci_set.keep_rx_mh);
-          if (rc != 0) {
-              MVCUST_ERR_PRINT("mv_cust_omci_set failed\n");
-          }
-          ret = 0;
-          break;
-
-      case MV_CUST_IOCTL_OMCI_ENABLE:
-
-          if(copy_from_user(&enable, (int *)arg, sizeof(int)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-          mv_cust_app_flag_set(MV_CUST_APP_TYPE_OMCI, enable);
-          ret = 0;
-          break;
-
-      case MV_CUST_IOCTL_EOAM_ENABLE:
-
-          if(copy_from_user(&enable, (int *)arg, sizeof(int)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-          mv_cust_app_flag_set(MV_CUST_APP_TYPE_OAM, enable);
-          ret = 0;
-          break;
-
-      case MV_CUST_IOCTL_EOAM_LLID_SET:
-          if(copy_from_user(&cust_llid_set, (int *)arg, sizeof(mv_cust_ioctl_llid_set_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          mv_cust_eoam_llid_set(cust_llid_set.llid, &(cust_llid_set.llid_mac[0]), cust_llid_set.txq);
-          ret = 0;
-          break;
-
-      case MV_CUST_IOCTL_MAP_RULE_SET:
-          if(copy_from_user(&cust_flow_map, (mv_cust_ioctl_flow_map_t *)arg, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          ret = mv_cust_map_rule_set(&cust_flow_map);
-          break;
-
-      case MV_CUST_IOCTL_DSCP_MAP_SET:
-          if(copy_from_user(&cust_dscp_map, (mv_cust_ioctl_dscp_map_t *)arg, sizeof(mv_cust_ioctl_dscp_map_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          ret = mv_cust_dscp_map_set(&cust_dscp_map.dscp_map);
-          break;
-
-      case MV_CUST_IOCTL_MAP_RULE_DEL:
-          if(copy_from_user(&cust_flow_map, (mv_cust_ioctl_flow_map_t *)arg, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          ret = mv_cust_map_rule_del((uint16_t)cust_flow_map.vid, (uint8_t)cust_flow_map.pbits, cust_flow_map.dir);
-          break;
-
-      case MV_CUST_IOCTL_DSCP_MAP_DEL:
-
-          ret = mv_cust_dscp_map_del();
-          break;
-
-      case MV_CUST_IOCTL_MAP_RULE_CLEAR:
-
-          ret = mv_cust_map_rule_clear();
-          break;
-
-      case MV_CUST_IOCTL_TAG_MAP_RULE_GET:
-          if(copy_from_user(&cust_flow_map, (mv_cust_ioctl_flow_map_t *)arg, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          ret = mv_cust_tag_map_rule_get(&cust_flow_map);
-
-          if(ret != MV_CUST_OK)
-            goto ioctlErr;
-
-          if(copy_to_user((mv_cust_ioctl_flow_map_t*)arg, &cust_flow_map, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          break;
-
-      case MV_CUST_IOCTL_UNTAG_MAP_RULE_GET:
-          if(copy_from_user(&cust_flow_map, (mv_cust_ioctl_flow_map_t *)arg, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          ret = mv_cust_untag_map_rule_get(&cust_flow_map);
-
-          if(ret != MV_CUST_OK)
-            goto ioctlErr;
-
-          if(copy_to_user((mv_cust_ioctl_flow_map_t*)arg, &cust_flow_map, sizeof(mv_cust_ioctl_flow_map_t)))
-          {
-            printk(KERN_ERR "ERROR: (%s:%d) copy_to_user failed\n", __FUNCTION__, __LINE__);
-            goto ioctlErr;
-          }
-          break;
-
-      case MV_CUST_IOCTL_APP_ETH_TYPE_SET:
-          if(copy_from_user(&cust_app_etype, (mv_cust_ioctl_app_etype_t *)arg, sizeof(mv_cust_ioctl_app_etype_t)))
-          {
-            MVCUST_ERR_PRINT("copy_from_user failed\n");
-            goto ioctlErr;
-          }
-
-          mv_cust_app_etype_set(cust_app_etype.app_type, cust_app_etype.eth_type);\
-          ret = 0;
-          break;
-
-      default:
-          ret = -EINVAL;
-  }
-
-ioctlErr:
-    return(ret);
-}
-
-
-static const struct file_operations mvcust_dev_fops =
-{
-	.open    = mvcust_dev_open,
-	.release = mvcust_dev_release,
-	.unlocked_ioctl   = mvcust_dev_ioctl,
-};
-
-/*******************************************************************************
-**
-**  mvcust_dev_init
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION:
-**
-**  PARAMETERS:
-**
-**
-**
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-int32_t mvcust_dev_init(void)
-{
-    int rc;
-
-    MVCUST_DEBUG_PRINT("Enter");
-
-    mvcust_misc_dev.minor = MISC_DYNAMIC_MINOR;
-    mvcust_misc_dev.name  = MVCUST_DEVICE_NAME;
-    mvcust_misc_dev.fops  = &mvcust_dev_fops;
-
-    rc = misc_register(&mvcust_misc_dev);
-    if (rc != 0)
-    {
-        MVCUST_ERR_PRINT("rc=%d",rc);
-        return rc;
-    }
-
-    rc = mvcust_netdev_init();
-    if (rc != 0)
-    {
-        MVCUST_ERR_PRINT("rc=%d",rc);
-        return rc;
-    }
-
-    rc = mvcust_sysfs_init();
-    if (rc != 0)
-    {
-        MVCUST_ERR_PRINT("rc=%d",rc);
-        return rc;
-    }
-
-    printk("MVCUST: misc device %s registered with minor: %d\n", MVCUST_DEVICE_NAME, mvcust_misc_dev.minor);
-    return 0;
-}
-
-
-/*******************************************************************************
-**
-**  mvcust_dev_shutdown
-**  ___________________________________________________________________________
-**
-**  DESCRIPTION:
-**
-**  PARAMETERS:
-**
-**
-**
-**
-**  OUTPUTS:     None
-**
-**  RETURNS:     (0)
-**
-*******************************************************************************/
-void mvcust_dev_shutdown(void)
-{
-	MVCUST_DEBUG_PRINT("Enter");
-
-    mvcust_sysfs_delete();
-
-    misc_deregister(&mvcust_misc_dev);
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.h
deleted file mode 100644
index e42503c..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_dev.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_dev.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-
-#ifndef __MV_CUST_DEV_H__
-#define __MV_CUST_DEV_H__
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define MV_CUST_VERSION     "V2.6.25"
-#define MVCUST_DEVICE_NAME  "cust"
-#define MV_CUST_IOCTL_MAGIC ('C')
-
-#ifdef MV_CUST_DEBUG
-#define MVCUST_DEBUG_PRINT(format, ...)   printk("%s(%d):  "format,__FUNCTION__,__LINE__, ##__VA_ARGS__)
-#else
-#define MVCUST_DEBUG_PRINT(format, ...)
-#endif
-
-#define MVCUST_ERR_PRINT(format, ...)     printk("%s(%d) ERROR:  "format,__FUNCTION__,__LINE__, ##__VA_ARGS__)
-
-extern struct bus_type platform_bus_type;
-
-/******************************************************
- * Function prototypes --                             *
-*******************************************************/
-int32_t mvcust_dev_init        (void);
-void    mvcust_dev_shutdown    (void);
-
-int     mvcust_netdev_init     (void);
-int     mvcust_sysfs_init      (void);
-void    mvcust_sysfs_delete    (void);
-
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-void    mv_cust_udp_spec_print_all (void);
-#endif
-void    mv_cust_debug_info_set     (int val);
-
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-void mv_cust_flow_map_print(void);
-
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /*__MV_CUST_DEV_H__*/
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.c
deleted file mode 100644
index 27440e9..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.c
+++ /dev/null
@@ -1,1076 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_flow_map.c
-*
-* DESCRIPTION:
-*   Victor  - initial version created.   12/Dec/2011
-*
-*******************************************************************************/
-#include <mvCommon.h>
-
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/if_vlan.h>
-#include <net/ip.h>
-#include <net/ipv6.h>
-
-#include <mvOs.h>
-#include <ctrlEnv/mvCtrlEnvLib.h>
-
-#include "mv_cust_dev.h"
-#include "mv_cust_netdev.h"
-#include "mv_cust_flow_map.h"
-#include "mv_cust_mng_if.h"
-
-/******************************************************************************
-*                           Global Data Definitions
-******************************************************************************/
-static mv_cust_vid_index_t  gs_vid_index_table[MV_CUST_FLOW_DIR_NUM];
-static mv_cust_pbits_map_t  gs_pbits_map_table[MV_CUST_FLOW_DIR_NUM][MV_CUST_MAX_PBITS_MAP_TABLE_SIZE];
-static mv_cust_dscp_pbits_t gs_dscp_map_table;
-
-static uint32_t gs_mv_cust_trace_flag = 0;
-
-/* Defined to support T-CONT state */
-static bool gs_tcont_state[CPH_MAX_TCONT_NUM];
-
-
-/******************************************************************************
-*                           External Declarations
-******************************************************************************/
-
-
-
-/******************************************************************************
-*                           Function Definitions
-******************************************************************************/
-/*******************************************************************************
-**
-**    mv_cust_set_trace_flag
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets mv_cust trace flag.
-**
-**    INPUTS:
-**      enTrace     - Enable or disable mv_cust trace.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_set_trace_flag(uint32_t enTrace)
-{
-    gs_mv_cust_trace_flag = enTrace;
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_valid_pbits_table_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets available P-bits mapping table.
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      Available P-bits mapping table index.
-**
-*******************************************************************************/
-uint32_t mv_cust_valid_pbits_table_get(mv_cust_flow_dir_e dir)
-{
-    uint32_t table_idx = 0;
-
-    /* Table index MV_CUST_MAX_PBITS_MAP_TABLE_SIZE is reserved for tagged default packets */
-    for (table_idx=0; table_idx<MV_CUST_MAX_PBITS_MAP_TABLE_SIZE-1; table_idx++) {
-
-       if (gs_pbits_map_table[dir][table_idx].in_use == 0)
-           return table_idx;
-    }
-
-    return MV_CUST_INVALID_PBITS_TABLE_INDEX;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_pbits_table_status_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets P-bits mapping table status.
-**
-**    INPUTS:
-**      pbits_map   - P-bits mapping table.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      0:No P-bits mapping rule exist in current table, 1: still exists P-bits mapping rule.
-**
-*******************************************************************************/
-uint32_t mv_cust_pbits_table_status_get(mv_cust_pbits_map_t *pbits_map)
-{
-    uint32_t pbits_idx = 0;
-
-    for (pbits_idx=0; pbits_idx<MV_CUST_PBITS_MAP_MAX_ENTRY_NUM; pbits_idx++) {
-
-       if (pbits_map->pkt_fwd[pbits_idx].in_use != 0)
-           return MV_CUST_OK;
-    }
-
-    return MV_CUST_FAIL;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_set
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets GPON flow mapping rules
-**
-**    INPUTS:
-**      cust_flow  - VLAN ID, 802.1p value, pkt_fwd information.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_set(mv_cust_ioctl_flow_map_t *cust_flow)
-{
-    uint8_t              *pVidEntry  = NULL;
-    mv_cust_pbits_map_t  *pPbitsMap  = NULL;
-    uint32_t              pbitsIndex = 0;
-    uint32_t              index      = 0;
-    uint32_t              vid        = 0;
-    uint32_t              pbits      = 0;
-    uint32_t              mod_vid    = 0;
-    uint32_t              mod_pbits  = 0;
-    mv_cust_flow_dir_e    dir        = MV_CUST_FLOW_DIR_US;
-    mv_cust_pkt_frwd_t   *pkt_fwd    = NULL;
-
-    /* Get input information: VID, P-bits... */
-    if (cust_flow == NULL) {
-        MVCUST_ERR_PRINT(KERN_ERR "cust_flow is NULL \n\r");
-        return MV_CUST_FAIL;
-    }
-    vid       =  cust_flow->vid;
-    pbits     =  cust_flow->pbits;
-    mod_vid   =  cust_flow->mod_vid;
-    mod_pbits =  cust_flow->mod_pbits;
-    pkt_fwd   = &cust_flow->pkt_frwd;
-    dir       =  cust_flow->dir;
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==%s: vid[%d], pbits[%d], mod_vid[%d], mod_pbits[%d], T-CONT[%d], SWF queue[%d], HWF queue[%d], GEM port[%d], dir[%d]\n\r",
-                            __FUNCTION__, vid, pbits, mod_vid, mod_pbits,
-                           ((pkt_fwd!= NULL)? pkt_fwd->trg_port:0),
-                           ((pkt_fwd!= NULL)? pkt_fwd->trg_queue:0),
-                           ((pkt_fwd!= NULL)? pkt_fwd->trg_hwf_queue:0),
-                           ((pkt_fwd!= NULL)? pkt_fwd->gem_port:0),
-                           cust_flow->dir);
-    }
-
-    /* Check VID */
-    if (vid > (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1)) {
-        MVCUST_ERR_PRINT(KERN_ERR "vid[%d] exceeds maximum value[%d] \n\r", vid, (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1));
-        return MV_CUST_FAIL;
-    }
-
-    /* Check P-bits */
-    if (pbits > MV_CUST_PBITS_NOT_CARE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "P-bits[%d] exceeds maximum value[%d] \n\r", pbits, MV_CUST_PBITS_NOT_CARE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    /* Check mod VID */
-    if (mod_vid > (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1)) {
-        MVCUST_ERR_PRINT(KERN_ERR "mod_vid[%d] exceeds maximum value[%d] \n\r", mod_vid, (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1));
-        return MV_CUST_FAIL;
-    }
-
-    /* Check mod P-bits */
-    if (mod_pbits > MV_CUST_PBITS_NOT_CARE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "mod_pbits[%d] exceeds maximum value[%d] \n\r", mod_pbits, MV_CUST_PBITS_NOT_CARE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    /* Check dir */
-    if (dir >= MV_CUST_FLOW_DIR_NUM) {
-        MVCUST_ERR_PRINT(KERN_ERR "dir[%d] exceeds maximum value[%d] \n\r", dir, MV_CUST_FLOW_DIR_NUM-1);
-        return MV_CUST_FAIL;
-    }
-
-    /* Check target port/queue/GEM port */
-    if (pkt_fwd->trg_port > MV_CUST_MAX_TRG_PORT_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "trg_port[%d] exceeds maximum value[%d] \n\r", pkt_fwd->trg_port, MV_CUST_MAX_TRG_PORT_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    if (pkt_fwd->trg_queue > MV_CUST_MAX_TRG_QUEUE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "SWF trg_queue[%d] exceeds maximum value[%d] \n\r", pkt_fwd->trg_queue, MV_CUST_MAX_TRG_QUEUE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    if (pkt_fwd->trg_hwf_queue > MV_CUST_MAX_TRG_QUEUE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "HWF trg_queue[%d] exceeds maximum value[%d] \n\r", pkt_fwd->trg_queue, MV_CUST_MAX_TRG_QUEUE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    if (pkt_fwd->gem_port > MV_CUST_MAX_GEM_PORT_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "trg_queue[%d] exceeds maximum value[%d] \n\r", pkt_fwd->gem_port, MV_CUST_MAX_GEM_PORT_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-
-    /* Find VID index entry by VID */
-    pVidEntry = &gs_vid_index_table[dir].pbits_map_index[vid];
-
-    /* Get P-bits mapping table */
-    /* If this VID index entry does not point to any P-bits mapping table,
-       need to search for an available P-bits mapping table             */
-    if (*pVidEntry >= MV_CUST_MAX_PBITS_MAP_TABLE_SIZE) {
-        /* Reserved for default tagged rule */
-        if (vid == MV_CUST_DEFAULT_SINGLE_TAG_RULE)
-            pbitsIndex = MV_CUST_MAX_PBITS_MAP_TABLE_SIZE - 1;
-        else
-            pbitsIndex = mv_cust_valid_pbits_table_get(dir);
-
-        if (pbitsIndex >= MV_CUST_MAX_PBITS_MAP_TABLE_SIZE) {
-            MVCUST_ERR_PRINT(KERN_ERR " %d P-bits mapping table has used out\n\r", MV_CUST_INVALID_PBITS_TABLE_INDEX);
-            return MV_CUST_FAIL;
-        }
-    }
-    /* In case that the VID index already points to a P-bits mapping table,
-       Need to replace the forwarding information of this P-bit mapping table */
-    else {
-        pbitsIndex = *pVidEntry;
-    }
-    pPbitsMap = &gs_pbits_map_table[dir][pbitsIndex];
-
-    /* If legal P-bits is configured */
-    if (pbits < MV_CUST_PBITS_NOT_CARE_VALUE) {
-        /* In case to enable packet forwarding */
-        if (pkt_fwd->in_use != 0) {
-
-            /* Save forwarding information */
-            pPbitsMap->pkt_fwd[pbits].trg_port      = pkt_fwd->trg_port;
-            pPbitsMap->pkt_fwd[pbits].trg_queue     = pkt_fwd->trg_queue;
-            pPbitsMap->pkt_fwd[pbits].trg_hwf_queue = pkt_fwd->trg_hwf_queue;
-            pPbitsMap->pkt_fwd[pbits].gem_port      = pkt_fwd->gem_port;
-
-            /* Save mod_vid mod_pbits */
-            pPbitsMap->mod_vid[pbits]           = mod_vid;
-            pPbitsMap->mod_pbits[pbits]         = mod_pbits;
-
-            /* Enable in_use flag */
-            pPbitsMap->pkt_fwd[pbits].in_use    = 1;
-            pPbitsMap->in_use                   = 1;
-
-            /* Save P-bit mapping table index in VID index table */
-            *pVidEntry = pbitsIndex;
-        }
-        /* In case to disable packet forwarding */
-        else {
-            /* Clear forwarding information */
-            pPbitsMap->pkt_fwd[pbits].trg_port      = 0;
-            pPbitsMap->pkt_fwd[pbits].trg_queue     = 0;
-            pPbitsMap->pkt_fwd[pbits].trg_hwf_queue = 0;
-            pPbitsMap->pkt_fwd[pbits].gem_port      = 0;
-
-            /* Clear mod_vid mod_pbits */
-            pPbitsMap->mod_vid[pbits]           = 0;
-            pPbitsMap->mod_pbits[pbits]         = 0;
-
-            /* Disable in_use flag */
-            pPbitsMap->pkt_fwd[pbits].in_use    = 0;
-            if (mv_cust_pbits_table_status_get(pPbitsMap) != MV_CUST_OK) {
-                pPbitsMap->in_use               = 0;
-                *pVidEntry                      = MV_CUST_INVALID_PBITS_TABLE_INDEX;
-            }
-            else {
-                pPbitsMap->in_use               = 1;
-                *pVidEntry                      = pbitsIndex;
-            }
-        }
-    }
-    /* If does not care for P-bits, each P-bits mapping entry should be set */
-    else if (pbits == MV_CUST_PBITS_NOT_CARE_VALUE) {
-
-        index = MV_CUST_PBITS_NOT_CARE_VALUE;
-
-        /* In case to enable packet forwarding */
-        if (pkt_fwd->in_use != 0) {
-
-            /* Save forwarding information */
-            pPbitsMap->pkt_fwd[index].trg_port      = pkt_fwd->trg_port;
-            pPbitsMap->pkt_fwd[index].trg_queue     = pkt_fwd->trg_queue;
-            pPbitsMap->pkt_fwd[pbits].trg_hwf_queue = pkt_fwd->trg_hwf_queue;
-            pPbitsMap->pkt_fwd[index].gem_port      = pkt_fwd->gem_port;
-            pPbitsMap->pkt_fwd[index].in_use        = 1;
-
-            /* Save mod_vid mod_pbits */
-            pPbitsMap->mod_vid[index]           = mod_vid;
-            pPbitsMap->mod_pbits[index]         = mod_pbits;
-
-            /* Enable in_use flag */
-            pPbitsMap->in_use = 1;
-
-            /* Save P-bit mapping table index in VID index table */
-            *pVidEntry = pbitsIndex;
-        }
-        /* In case to disable packet forwarding */
-        else {
-
-            /* Clear forwarding information */
-            pPbitsMap->pkt_fwd[index].trg_port      = 0;
-            pPbitsMap->pkt_fwd[index].trg_queue     = 0;
-            pPbitsMap->pkt_fwd[pbits].trg_hwf_queue = 0;
-            pPbitsMap->pkt_fwd[index].gem_port      = 0;
-            pPbitsMap->pkt_fwd[index].in_use        = 0;
-            /* clear mod_vid mod_pbits */
-            pPbitsMap->mod_vid[index]           = 0;
-            pPbitsMap->mod_pbits[index]         = 0;
-
-            /* Disable in_use flag */
-            if (mv_cust_pbits_table_status_get(pPbitsMap) != MV_CUST_OK) {
-                pPbitsMap->in_use               = 0;
-                *pVidEntry                      = MV_CUST_INVALID_PBITS_TABLE_INDEX;
-            }
-            else {
-                pPbitsMap->in_use               = 1;
-                *pVidEntry                      = pbitsIndex;
-            }
-        }
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_dscp_map_set
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets GPON DSCP to P-bits mapping rules
-**
-**    INPUTS:
-**      dscp_map     - DSCP to P-bits mapping rules.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_dscp_map_set(mv_cust_dscp_pbits_t *dscp_map)
-{
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==%s: in_use[%d]\n\r", __FUNCTION__,
-                           ((dscp_map!= NULL)? dscp_map->in_use:0));
-    }
-
-    if (dscp_map == NULL) {
-        MVCUST_ERR_PRINT(KERN_ERR "Input dscp_map is NULL\n\r");
-        return MV_CUST_FAIL;
-    }
-
-    /* Case 1: to enable DSCP to P-bits mapping */
-    if (dscp_map->in_use != 0) {
-        memcpy(&gs_dscp_map_table.pbits[0], &dscp_map->pbits[0], sizeof(gs_dscp_map_table.pbits));
-        gs_dscp_map_table.in_use = 1;
-
-    }
-    /* Case 2: to disable DSCP to P-bits mapping */
-    else {
-        memset((uint8_t *)&gs_dscp_map_table, 0, sizeof(gs_dscp_map_table));
-        gs_dscp_map_table.in_use = 0;
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT== %s:\n\r",__FUNCTION__);
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_del
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function deletes GPON flow mapping rules
-**
-**    INPUTS:
-**      vid         - VLAN ID.
-**      pbits      - 802.1p value.
-**
-**    OUTPUTS:
-**      None
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_del(uint16_t vid, uint8_t pbits, mv_cust_flow_dir_e dir)
-{
-    uint8_t              *pVidEntry  = NULL;
-    mv_cust_pbits_map_t  *pPbitsMap  = NULL;
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==: vid[%d],pbits[%d]\n\r", vid, pbits);
-    }
-
-    /* Check VID */
-    if (vid > (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1)) {
-        MVCUST_ERR_PRINT(KERN_ERR "vid[%d] exceeds maximum value[%d] \n\r", vid, (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1));
-        return MV_CUST_FAIL;
-    }
-
-    /* Check P-bits */
-    if (pbits > MV_CUST_PBITS_NOT_CARE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "P-bits[%d] exceeds maximum value[%d] \n\r", pbits, MV_CUST_PBITS_NOT_CARE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    /* Check dir */
-    if (dir >= MV_CUST_FLOW_DIR_NUM) {
-        MVCUST_ERR_PRINT(KERN_ERR "dir[%d] exceeds maximum value[%d] \n\r", dir, MV_CUST_FLOW_DIR_NUM-1);
-        return MV_CUST_FAIL;
-    }
-
-    /* Find VID index entry by VID */
-    pVidEntry = &gs_vid_index_table[dir].pbits_map_index[vid];
-
-    if (*pVidEntry >= MV_CUST_MAX_PBITS_MAP_TABLE_SIZE) {
-         MVCUST_TRACE_PRINT(KERN_INFO,"%s, pVidEntry[%d], does not need to delete \n\r",__FUNCTION__, *pVidEntry);
-        return MV_CUST_OK;
-    }
-
-    /* Find P-bits mapping table */
-    pPbitsMap = &gs_pbits_map_table[dir][*pVidEntry];
-
-    /* Delete P-bits mapping rule */
-    pPbitsMap->pkt_fwd[pbits].trg_port   = 0;
-    pPbitsMap->pkt_fwd[pbits].trg_queue  = 0;
-    pPbitsMap->pkt_fwd[pbits].gem_port   = 0;
-    pPbitsMap->pkt_fwd[pbits].in_use     = 0;
-    pPbitsMap->mod_vid[pbits]            = 0;
-    pPbitsMap->mod_pbits[pbits]          = 0;
-
-    /* Disable in_use flag */
-    if (mv_cust_pbits_table_status_get(pPbitsMap)!= MV_CUST_OK) {
-        pPbitsMap->in_use                = 0;
-        *pVidEntry                       = MV_CUST_INVALID_PBITS_TABLE_INDEX;
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT==:\n\r");
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_dscp_map_del
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function deletes DSCP to P-bits mapping rules
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_dscp_map_del(void)
-{
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==\n\r");
-    }
-
-    /* Clear DSCP to P-bits mapping */
-    else {
-        memset((uint8_t *)&gs_dscp_map_table, 0, sizeof(gs_dscp_map_table));
-        gs_dscp_map_table.in_use = 0;
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT==\n\r");
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_clear
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function clears all GPON flow mapping rules
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_clear(void)
-{
-    uint32_t pbits_index = 0;
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==\n\r");
-    }
-
-    /* Clear VID index table              */
-    memset((uint8_t *)&gs_vid_index_table, MV_CUST_INVALID_PBITS_TABLE_INDEX, sizeof(gs_vid_index_table));
-
-    /* Clear P-bits mapping tables        */
-    for (pbits_index=0; pbits_index<MV_CUST_MAX_PBITS_MAP_TABLE_SIZE; pbits_index++) {
-        memset((uint8_t *)&gs_pbits_map_table[MV_CUST_FLOW_DIR_US][pbits_index], 0, sizeof(mv_cust_pbits_map_t));
-        gs_pbits_map_table[MV_CUST_FLOW_DIR_US][pbits_index].in_use = 0;
-        memset((uint8_t *)&gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][pbits_index], 0, sizeof(mv_cust_pbits_map_t));
-        gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][pbits_index].in_use = 0;
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT==\n\r");
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_tag_map_rule_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets GPON flow mapping rule for tagged frames.
-**
-**  INPUTS:
-**    cust_flow  - parsing vid, pbits, dir
-**
-**  OUTPUTS:
-**    cust_flow  - out packet forwarding information, including GEM port, T-CONT, queue.
-**                 and packet modification for VID, P-bits
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_tag_map_rule_get(mv_cust_ioctl_flow_map_t *cust_flow)
-{
-    uint8_t              *pVidEntry  = NULL;
-    mv_cust_pbits_map_t  *pPbitsMap  = NULL;
-    mv_cust_pkt_frwd_t   *pPktFrwd   = NULL;
-    uint32_t              vid        = 0;
-    uint32_t              pbits      = 0;
-    mv_cust_flow_dir_e    dir        = MV_CUST_FLOW_DIR_US;
-    mv_cust_pkt_frwd_t   *pkt_fwd    = NULL;
-    uint32_t              index      = 0;
-
-    /* Get input parameters */
-    vid     = cust_flow->vid;
-    pbits   = cust_flow->pbits;
-    dir     = cust_flow->dir;
-    pkt_fwd = &cust_flow->pkt_frwd;
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==: vid[%d], pbits[%d], dir[%d]\n\r", vid, pbits, dir);
-    }
-
-    /* Check VID */
-    if (vid > (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1)) {
-        MVCUST_ERR_PRINT(KERN_ERR "vid[%d] exceeds maximum value[%d] \n\r", vid, (MV_CUST_VID_INDEX_TABLE_MAX_SIZE - 1));
-        return MV_CUST_FAIL;
-    }
-
-    /* Check P-bits */
-    if (pbits > MV_CUST_PBITS_NOT_CARE_VALUE) {
-        MVCUST_ERR_PRINT(KERN_ERR "P-bits[%d] exceeds maximum value[%d] \n\r", pbits, MV_CUST_PBITS_NOT_CARE_VALUE);
-        return MV_CUST_FAIL;
-    }
-
-    /* Check dir */
-    if (dir >= MV_CUST_FLOW_DIR_NUM) {
-        MVCUST_ERR_PRINT(KERN_ERR "dir[%d] exceeds maximum value[%d] \n\r", dir, MV_CUST_FLOW_DIR_NUM-1);
-        return MV_CUST_FAIL;
-    }
-
-    /* Set default values */
-    cust_flow->mod_vid   = MV_CUST_VID_NOT_CARE_VALUE;
-    cust_flow->mod_pbits = MV_CUST_PBITS_NOT_CARE_VALUE;
-
-    /* Find VID index entry by VID */
-    pVidEntry = &gs_vid_index_table[dir].pbits_map_index[vid];
-
-    if (*pVidEntry >= MV_CUST_MAX_PBITS_MAP_TABLE_SIZE) {
-         //MVCUST_ERR_PRINT(KERN_ERR "%s, pVidEntry[%d], No matched P-bits mapping table \n\r",__FUNCTION__, *pVidEntry);
-
-        pkt_fwd->in_use = 0;
-        if (gs_mv_cust_trace_flag) {
-            MVCUST_TRACE_PRINT(KERN_INFO,
-                               "==EXIT==\n\r");
-        }
-
-        return MV_CUST_FAIL;
-    }
-
-    /* Find P-bits mapping table */
-    pPbitsMap = &gs_pbits_map_table[dir][*pVidEntry];
-
-    /* Get packet forwarding information */
-    index = pbits;
-
-    pPktFrwd = &pPbitsMap->pkt_fwd[index];
-
-    /* If specific flow mapping rule exists */
-    if (pPktFrwd->in_use != 0) {
-        pkt_fwd->trg_port      = pPktFrwd->trg_port;
-        if (false == mv_cust_get_tcont_state(pPktFrwd->trg_port))
-            pkt_fwd->trg_queue = CPH_INVALID_TRGT_QUEUE;
-         else
-            pkt_fwd->trg_queue = pPktFrwd->trg_queue;
-        pkt_fwd->trg_hwf_queue = pPktFrwd->trg_hwf_queue;
-        pkt_fwd->gem_port      = pPktFrwd->gem_port;
-        cust_flow->mod_vid     = pPbitsMap->mod_vid[index];
-        cust_flow->mod_pbits   = pPbitsMap->mod_pbits[index];
-        pkt_fwd->in_use        = 1;
-
-        if (gs_mv_cust_trace_flag) {
-            MVCUST_TRACE_PRINT(KERN_INFO,
-                               "trg_port(%d), trg_queue(%d) trg_hwf_queue(%d) gem_port(%d), mod_vid(%d), mod_pbits(%d)\n\r",
-                                cust_flow->pkt_frwd.trg_port, cust_flow->pkt_frwd.trg_queue, cust_flow->pkt_frwd.trg_hwf_queue,
-                                cust_flow->pkt_frwd.gem_port, cust_flow->mod_vid, cust_flow->mod_pbits);
-        }
-
-    }
-    /* If specific flow mapping rule does not exist, look for default rule */
-    else {
-        index = MV_CUST_PBITS_NOT_CARE_VALUE;
-        pPktFrwd = &pPbitsMap->pkt_fwd[index];
-
-        /* If default flow mapping rule exists */
-        if (pPktFrwd->in_use != 0) {
-            pkt_fwd->trg_port      = pPktFrwd->trg_port;
-            if (false == mv_cust_get_tcont_state(pPktFrwd->trg_port))
-                pkt_fwd->trg_queue = CPH_INVALID_TRGT_QUEUE;
-             else
-                pkt_fwd->trg_queue = pPktFrwd->trg_queue;
-            pkt_fwd->trg_hwf_queue = pPktFrwd->trg_hwf_queue;
-            pkt_fwd->gem_port      = pPktFrwd->gem_port;
-            cust_flow->mod_vid     = pPbitsMap->mod_vid[index];
-            cust_flow->mod_pbits   = pPbitsMap->mod_pbits[index];
-            pkt_fwd->in_use        = 1;
-
-            if (gs_mv_cust_trace_flag) {
-                MVCUST_TRACE_PRINT(KERN_INFO,
-                                   "trg_port(%d), trg_queue(%d) trg_hwf_queue(%d) gem_port(%d), mod_vid(%d), mod_pbits(%d)\n\r",
-                                    cust_flow->pkt_frwd.trg_port, cust_flow->pkt_frwd.trg_queue, cust_flow->pkt_frwd.trg_hwf_queue,
-                                    cust_flow->pkt_frwd.gem_port, cust_flow->mod_vid, cust_flow->mod_pbits);
-            }
-
-        }
-        else {
-
-            pkt_fwd->in_use      = 0;
-            if (gs_mv_cust_trace_flag) {
-                MVCUST_TRACE_PRINT(KERN_INFO,
-                                   "==EXIT==\n\r");
-            }
-            return MV_CUST_FAIL;
-        }
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT==\n\r");
-    }
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_untag_map_rule_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets GPON flow mapping rule for untagged frames.
-**
-**    INPUTS:
-**      dscp         - DSCP value.
-**
-**    OUTPUTS:
-**      cust_flow    - packet forwarding information, including GEM port, T-CONT, queue.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_untag_map_rule_get(mv_cust_ioctl_flow_map_t *cust_flow)
-{
-    uint8_t              *pVidEntry  = NULL;
-    mv_cust_pbits_map_t  *pPbitsMap  = NULL;
-    mv_cust_pkt_frwd_t   *pPktFrwd   = NULL;
-    uint32_t              pbitsIndex = MV_CUST_PBITS_NOT_CARE_VALUE;
-    mv_cust_flow_dir_e    dir        = MV_CUST_FLOW_DIR_US;
-    uint32_t              dscp       = 0;
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==ENTER==: dscp[%d] \n\r", dscp);
-    }
-
-    /* Check target port/queue/GEM port */
-    if (cust_flow == NULL) {
-        MVCUST_ERR_PRINT(KERN_ERR "cust_flow is NULL \n\r");
-        return MV_CUST_FAIL;
-    }
-
-    /* Set forwarding flag to false at first */
-    cust_flow->pkt_frwd.in_use = 0;
-    cust_flow->mod_vid         = MV_CUST_VID_NOT_CARE_VALUE;
-    cust_flow->mod_pbits       = MV_CUST_PBITS_NOT_CARE_VALUE;
-
-    dir  = cust_flow->dir;
-    dscp = cust_flow->dscp;
-
-    /* Check DSCP */
-    if (dscp < MV_CUST_DSCP_PBITS_TABLE_MAX_SIZE) {
-        if (gs_dscp_map_table.in_use != 0) {
-            pbitsIndex = gs_dscp_map_table.pbits[dscp];
-        }
-    }
-
-    if(pbitsIndex > MV_CUST_PBITS_NOT_CARE_VALUE){
-        //MVCUST_ERR_PRINT(KERN_ERR "pbitsIndex[%d] is illegal \n\r", pbitsIndex);
-        return MV_CUST_FAIL;
-    }
-
-    /* Find P-bits mapping table */
-    pVidEntry = &gs_vid_index_table[dir].pbits_map_index[MV_CUST_DEFAULT_UNTAG_RULE];
-
-    if (*pVidEntry >= MV_CUST_MAX_PBITS_MAP_TABLE_SIZE) {
-        //MVCUST_TRACE_PRINT(KERN_INFO,"%s, pVidEntry[%d], does not exist \n\r",__FUNCTION__, *pVidEntry);
-    }
-    else {
-
-        pPbitsMap = &gs_pbits_map_table[dir][*pVidEntry];
-
-        if (pPbitsMap->in_use != 0) {
-
-            pPktFrwd  = &pPbitsMap->pkt_fwd[pbitsIndex];
-            if (pPktFrwd->in_use != 0) {
-                cust_flow->pkt_frwd.trg_port      = pPktFrwd->trg_port;
-                if (false == mv_cust_get_tcont_state(pPktFrwd->trg_port))
-                    cust_flow->pkt_frwd.trg_queue = CPH_INVALID_TRGT_QUEUE;
-                 else
-                    cust_flow->pkt_frwd.trg_queue = pPktFrwd->trg_queue;
-                cust_flow->pkt_frwd.trg_hwf_queue = pPktFrwd->trg_hwf_queue;
-                cust_flow->pkt_frwd.gem_port      = pPktFrwd->gem_port;
-                cust_flow->mod_vid                = pPbitsMap->mod_vid[pbitsIndex];
-                cust_flow->mod_pbits              = pPbitsMap->mod_pbits[pbitsIndex];
-                cust_flow->pkt_frwd.in_use        = 1;
-
-                if (gs_mv_cust_trace_flag) {
-                    MVCUST_TRACE_PRINT(KERN_INFO,
-                                       "trg_port(%d), trg_queue(%d), trg_hwf_queue(%d), gem_port(%d), mod_vid(%d), mod_pbits(%d)\n\r",
-                                        cust_flow->pkt_frwd.trg_port, cust_flow->pkt_frwd.trg_queue, cust_flow->pkt_frwd.trg_hwf_queue,
-                                        cust_flow->pkt_frwd.gem_port, cust_flow->mod_vid, cust_flow->mod_pbits);
-                    MVCUST_TRACE_PRINT(KERN_INFO,
-                                       "==EXIT==:\n\r");
-                }
-
-                return MV_CUST_OK;
-            }
-        }
-    }
-
-    if (gs_mv_cust_trace_flag) {
-        MVCUST_TRACE_PRINT(KERN_INFO,
-                           "==EXIT==:\n\r");
-    }
-
-    return MV_CUST_FAIL;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_map_table_print
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function displays valid GPON flow mapping tables and DSCP
-**                 to P-bits mapping tablefor untagged frames.
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_table_print(void)
-{
-    uint32_t  index = 0;
-    uint32_t  table_index = 0;
-
-    //MVCUST_TRACE_PRINT(KERN_INFO,"==ENTER==\n\r");
-
-    /* Print Valid VID index entries */
-    printk(KERN_INFO "In Upstream Direction      \n----------------------------------\n");
-    printk(KERN_INFO "MV_CUST VLAN ID Index Table\n----------------------------------\n");
-    printk(KERN_INFO "VID   P-bits_table_index\n");
-    for (index=0; index<MV_CUST_VID_INDEX_TABLE_MAX_SIZE; index++) {
-        if(gs_vid_index_table[MV_CUST_FLOW_DIR_US].pbits_map_index[index] < MV_CUST_MAX_PBITS_MAP_TABLE_SIZE)
-            printk(KERN_INFO "%4.4d   %d\n", index, gs_vid_index_table[MV_CUST_FLOW_DIR_US].pbits_map_index[index]);
-    }
-    printk(KERN_INFO "\n\n");
-
-    /* Print P-bits mapping tables */
-    printk(KERN_INFO "MV_CUST P-bits Flow Mapping Tables\n----------------------------------\n\n");
-    for (table_index=0; table_index<MV_CUST_MAX_PBITS_MAP_TABLE_SIZE; table_index++) {
-        if(gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].in_use != 0) {
-                printk(KERN_INFO "P-bits Flow Mapping Table %d\n----------------------------\n", table_index);
-                printk(KERN_INFO "P-bits  in_use  mod_vid mod_pbits trg_port  trg_queue  trg_hwf_queue  gem_port\n");
-                for (index=0; index<MV_CUST_PBITS_MAP_MAX_ENTRY_NUM; index++)
-                    printk(KERN_INFO "%1.1d       %3.3s     %4.4d    %1.1d          %2.2d        %2.2d         %2.2d            %4.4d\n",
-                                       index,
-                                       (gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].pkt_fwd[index].in_use!=0)? "YES":"",
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].mod_vid[index],
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].mod_pbits[index],
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].pkt_fwd[index].trg_port,
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].pkt_fwd[index].trg_queue,
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].pkt_fwd[index].trg_hwf_queue,
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_US][table_index].pkt_fwd[index].gem_port);
-
-        }
-    }
-    printk(KERN_INFO "\n\n");
-
-    printk(KERN_INFO "In Downstream Direction    \n----------------------------------\n");
-    printk(KERN_INFO "MV_CUST VLAN ID Index Table\n----------------------------------\n");
-    printk(KERN_INFO "VID   P-bits_table_index\n");
-    for (index=0; index<MV_CUST_VID_INDEX_TABLE_MAX_SIZE; index++) {
-        if(gs_vid_index_table[MV_CUST_FLOW_DIR_DS].pbits_map_index[index] < MV_CUST_MAX_PBITS_MAP_TABLE_SIZE)
-            printk(KERN_INFO "%4.4d   %d\n", index, gs_vid_index_table[MV_CUST_FLOW_DIR_DS].pbits_map_index[index]);
-    }
-    printk(KERN_INFO "\n\n");
-
-    /* Print P-bits mapping tables */
-    printk(KERN_INFO "MV_CUST P-bits Flow Mapping Tables\n----------------------------------\n\n");
-    for (table_index=0; table_index<MV_CUST_MAX_PBITS_MAP_TABLE_SIZE; table_index++) {
-        if(gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].in_use != 0) {
-                printk(KERN_INFO "P-bits Flow Mapping Table %d\n----------------------------\n", table_index);
-                printk(KERN_INFO "P-bits  in_use  mod_vid mod_pbits trg_queue  trg_hwf_queue  \n");
-                for (index=0; index<MV_CUST_PBITS_MAP_MAX_ENTRY_NUM; index++)
-                    printk(KERN_INFO "%1.1d       %3.3s     %4.4d    %1.1d        %2.2d         %2.2d              \n",
-                                       index,
-                                       (gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].pkt_fwd[index].in_use!=0)? "YES":"",
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].mod_vid[index],
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].mod_pbits[index],
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].pkt_fwd[index].trg_queue,
-                                       gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][table_index].pkt_fwd[index].trg_hwf_queue);
-
-        }
-    }
-    printk(KERN_INFO "\n\n");
-
-    /* Print DSCP to P-bits mapping table */
-    printk(KERN_INFO "MV_CUST DSCP to P-bits Mapping Table\n----------------------------------\n");
-    if (gs_dscp_map_table.in_use == 0) {
-        printk(KERN_INFO "No DSCP to P-bits mapping\n");
-    }
-    else {
-
-        printk(KERN_INFO "DSCP  Pbits\n");
-        for (index=0; index<MV_CUST_PBITS_MAP_MAX_ENTRY_NUM; index++)
-            printk(KERN_INFO "%2.2d     %1.1d\n",
-                   index, gs_dscp_map_table.pbits[index]);
-    }
-    printk(KERN_INFO "\n\n");
-
-    //MVCUST_TRACE_PRINT(KERN_INFO,"==EXIT==\n\r");
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-**    mv_cust_flow_map_init
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function initializes mv_cust flow mapping data structure.
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_flow_map_init(void)
-{
-    uint32_t index = 0;
-
-    /* Initializes VID index table              */
-    memset((uint8_t *)&gs_vid_index_table, MV_CUST_INVALID_PBITS_TABLE_INDEX, sizeof(gs_vid_index_table));
-
-    /* Initializes P-bits mapping tables        */
-    for (index = 0; index < MV_CUST_MAX_PBITS_MAP_TABLE_SIZE; index++) {
-        memset((uint8_t *)&gs_pbits_map_table[MV_CUST_FLOW_DIR_US][index], 0, sizeof(mv_cust_pbits_map_t));
-        gs_pbits_map_table[MV_CUST_FLOW_DIR_US][index].in_use = 0;
-        memset((uint8_t *)&gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][index], 0, sizeof(mv_cust_pbits_map_t));
-        gs_pbits_map_table[MV_CUST_FLOW_DIR_DS][index].in_use = 0;
-    }
-
-    /* Initializes DSCP to P-bits mapping table */
-    memset((uint8_t *)&gs_dscp_map_table, 0, sizeof(mv_cust_dscp_pbits_t));
-    gs_dscp_map_table.in_use = 0;
-
-    /* Initializes T-CONT state, default value is false */
-    for (index = 0; index < CPH_MAX_TCONT_NUM; index++)
-        gs_tcont_state[index] = false;
-
-    return MV_CUST_OK;
-}
-
-/*******************************************************************************
-**
-** mv_cust_get_tcont_state
-** ___________________________________________________________________________
-**
-** DESCRIPTION: The function get T-CONT state
-**
-** INPUTS:
-**   tcont - T-CONT
-**
-** OUTPUTS:
-**   None.
-**
-** RETURNS:
-**   state - State of T-CONT, enabled or disabled.
-**
-*******************************************************************************/
-bool mv_cust_get_tcont_state(uint32_t tcont)
-{
-    /* Check tcont */
-    if (tcont >= CPH_MAX_TCONT_NUM)
-    {
-        MVCUST_TRACE_PRINT(KERN_ERR,"tcont[%d] is illegal, should be less than [%d]\n", tcont, CPH_MAX_TCONT_NUM);
-        return false;
-    }
-
-    return gs_tcont_state[tcont];
-}
-
-/*******************************************************************************
-**
-** mv_cust_set_tcont_state
-** ___________________________________________________________________________
-**
-** DESCRIPTION: The function sets T-CONT state in mv_cust
-**
-** INPUTS:
-**   tcont - T-CONT
-**   state - State of T-CONT, enabled or disabled.
-**
-** OUTPUTS:
-**   None.
-**
-** RETURNS:
-**  On success, the function returns (MV_OK). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-MV_STATUS mv_cust_set_tcont_state(uint32_t tcont, bool state)
-{
-    /* Check tcont */
-    if (tcont >= CPH_MAX_TCONT_NUM)
-    {
-        MVCUST_TRACE_PRINT(KERN_ERR,"tcont[%d] is illegal, should be less than [%d]\n", tcont, CPH_MAX_TCONT_NUM);
-        return MV_FAIL;
-    }
-
-    /* Apply t-cont state to mv_cust */
-    gs_tcont_state[tcont] = state;
-
-    return MV_OK;
-}
-EXPORT_SYMBOL(mv_cust_set_tcont_state);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.h
deleted file mode 100644
index 916072a..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_flow_map.h
+++ /dev/null
@@ -1,359 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_flow_map.h
-*
-* DESCRIPTION:
-*   Victor  - initial version created.   12/Dec/2011
-*
-*******************************************************************************/
-#ifndef __mv_cust_flow_map_h__
-#define __mv_cust_flow_map_h__
-
-
-/******************************************************************************
- *                        Data Enum and Structure
- ******************************************************************************/
-#define MVCUST_TRACE_PRINT(level, format, ...)   printk(level "%s(%d):"format, __FUNCTION__, __LINE__, ##__VA_ARGS__)
-
-#define MV_CUST_OK                        (0)
-#define MV_CUST_FAIL                      (1)
-
-#define CPH_MAX_TCONT_NUM                 (8)    /* Maximum T-CONT number    */
-#define CPH_INVALID_TRGT_QUEUE            (0xFF) /* Invalid target queue number  */
-
-#define MV_CUST_VID_NOT_CARE_VALUE        (4096) /* Does not care for VID    */
-#define MV_CUST_PBITS_NOT_CARE_VALUE      (8)    /* Does not care for P-bits */
-#define MV_CUST_DSCP_NOT_CARE_VALUE       (64)   /* Does not care for DSCP   */
-
-#define MV_CUST_MAX_TRG_PORT_VALUE        (8-1)  /* Maximum target port value, T-CONT7 */
-#define MV_CUST_MAX_TRG_QUEUE_VALUE       (7)    /* Maximum target queue value         */
-#define MV_CUST_MAX_GEM_PORT_VALUE        (4095) /* Maximum GEM port value             */
-
-#define MV_CUST_INVALID_PBITS_TABLE_INDEX (0xff) /* Invalid Pbits table index value in VID index table*/
-
-#define MV_CUST_DEFAULT_UNTAG_RULE        (4096+1)/* Default untagged  rule        */
-#define MV_CUST_DEFAULT_SINGLE_TAG_RULE   (4096+2)/* Default sinlge tagged  rule   */
-#define MV_CUST_DEFAULT_DOUBLE_UNTAG_RULE (4096+3)/* Default double tagged  rule   */
-
-/* VLAN ID index table definition for flow mapping */
-#define MV_CUST_VID_INDEX_TABLE_MAX_SIZE  (4096+4)
-typedef struct {
-    uint8_t pbits_map_index[MV_CUST_VID_INDEX_TABLE_MAX_SIZE];
-} mv_cust_vid_index_t;
-
-/* P-bits flow mapping table definition */
-typedef uint32_t mv_cust_trg_port_type_t;
-typedef uint32_t mv_cust_gem_port_key_t;
-typedef struct mv_cust_pkt_frwd {
-    uint32_t                in_use;
-    mv_cust_trg_port_type_t trg_port;
-    uint32_t                trg_queue;
-    uint32_t                trg_hwf_queue;
-    mv_cust_gem_port_key_t  gem_port;
-} mv_cust_pkt_frwd_t;
-
-#define MV_CUST_PBITS_MAP_MAX_ENTRY_NUM   (8+1)
-#define MV_CUST_MAX_PBITS_MAP_TABLE_SIZE  (64)
-
-typedef struct {
-    uint32_t           in_use;
-    int                mod_vid[MV_CUST_PBITS_MAP_MAX_ENTRY_NUM];
-    int                mod_pbits[MV_CUST_PBITS_MAP_MAX_ENTRY_NUM];
-    mv_cust_pkt_frwd_t pkt_fwd[MV_CUST_PBITS_MAP_MAX_ENTRY_NUM];
-} mv_cust_pbits_map_t;
-
-/* DSCP to P-bits mapping table definition */
-#define MV_CUST_DSCP_PBITS_TABLE_MAX_SIZE  (64)
-typedef struct {
-    uint32_t in_use;
-    uint8_t  pbits[MV_CUST_DSCP_PBITS_TABLE_MAX_SIZE];
-} mv_cust_dscp_pbits_t;
-
-typedef enum
-{
-    MV_CUST_FLOW_DIR_US   = 0,
-    MV_CUST_FLOW_DIR_DS   = 1,
-    MV_CUST_FLOW_DIR_NUM  = 2
-} mv_cust_flow_dir_e;
-
-typedef struct
-{
-    mv_cust_flow_dir_e dir;
-    int                vid;
-    int                pbits;
-    int                dscp;
-    int                mod_vid;
-    int                mod_pbits;
-    mv_cust_pkt_frwd_t pkt_frwd;
-} mv_cust_ioctl_flow_map_t;
-
-/******************************************************************************
- *                        Function Declaration
- ******************************************************************************/
-/*******************************************************************************
-**
-**    mv_cust_set_trace_flag
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets mv_cust trace flag.
-**
-**    INPUTS:
-**      enTrace     - Enable or disable mv_cust trace.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_set_trace_flag(uint32_t enTrace);
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_set
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets GPON flow mapping rules
-**
-**    INPUTS:
-**      cust_flow  - VLAN ID, 802.1p value, pkt_fwd information.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_set(mv_cust_ioctl_flow_map_t *cust_flow);
-
-/*******************************************************************************
-**
-**    mv_cust_dscp_map_set
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function sets GPON DSCP to P-bits mapping rules
-**
-**  INPUTS:
-**    dscp_map   - DSCP to P-bits mapping rules.
-**
-**  OUTPUTS:
-**    None.
-**
-**    RETURNS:
-**    On success, the function returns (0). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_dscp_map_set(mv_cust_dscp_pbits_t *dscp_map);
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_del
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function deletes GPON flow mapping rules
-**
-**    INPUTS:
-**      vid         - VLAN ID.
-**      pbits      - 802.1p value.
-**
-**    OUTPUTS:
-**      None
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_del(uint16_t vid, uint8_t pbits, mv_cust_flow_dir_e dir);
-
-/*******************************************************************************
-**
-**    mv_cust_dscp_map_del
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function deletes DSCP to P-bits mapping rules
-**
-**  INPUTS:
-**    None.
-**
-**  OUTPUTS:
-**    None.
-**
-**    RETURNS:
-**    On success, the function returns (0). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_dscp_map_del(void);
-
-/*******************************************************************************
-**
-**    mv_cust_map_rule_clear
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function clears all GPON flow mapping rules
-**
-**  INPUTS:
-**    None.
-**
-**  OUTPUTS:
-**    None.
-**
-**    RETURNS:
-**    On success, the function returns (0). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_rule_clear(void);
-
-/*******************************************************************************
-**
-**    mv_cust_tag_map_rule_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets GPON flow mapping rule for tagged frames.
-**
-**  INPUTS:
-**    cust_flow  - parsing vid, pbits, dir
-**
-**  OUTPUTS:
-**    cust_flow  - out packet forwarding information, including GEM port, T-CONT, queue.
-**                 and packet modification for VID, P-bits
-**
-**    RETURNS:
-**    On success, the function returns (0). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_tag_map_rule_get(mv_cust_ioctl_flow_map_t *cust_flow);
-
-/*******************************************************************************
-**
-**    mv_cust_untag_map_rule_get
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function gets GPON flow mapping rule for untagged frames.
-**
-**    INPUTS:
-**      dscp         - DSCP value.
-**
-**    OUTPUTS:
-**      cust_flow    - packet forwarding information, including GEM port, T-CONT, queue.
-**
-**    RETURNS:
-**      On success, the function returns (MV_CUST_OK). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_untag_map_rule_get(mv_cust_ioctl_flow_map_t *cust_flow);
-
-/*******************************************************************************
-**
-**    mv_cust_map_table_print
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function displays valid GPON flow mapping tables and DSCP
-**               to P-bits mapping tablefor untagged frames.
-**
-**  INPUTS:
-**    None.
-**
-**  OUTPUTS:
-**    None.
-**
-**    RETURNS:
-**    On success, the function returns (0). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_map_table_print(void);
-
-/*******************************************************************************
-**
-**    mv_cust_flow_map_init
-**    ___________________________________________________________________________
-**
-**    DESCRIPTION: The function initializes mv_cust flow mapping data structure.
-**
-**    INPUTS:
-**      None.
-**
-**    OUTPUTS:
-**      None.
-**
-**    RETURNS:
-**      On success, the function returns (0). On error different types are
-**    returned according to the case.
-**
-*******************************************************************************/
-int mv_cust_flow_map_init(void);
-
-/*******************************************************************************
-**
-** mv_cust_get_tcont_state
-** ___________________________________________________________________________
-**
-** DESCRIPTION: The function get T-CONT state
-**
-** INPUTS:
-**   tcont - T-CONT
-**
-** OUTPUTS:
-**   None.
-**
-** RETURNS:
-**   state - State of T-CONT, enabled or disabled.
-**
-*******************************************************************************/
-bool mv_cust_get_tcont_state(uint32_t tcont);
-
-/*******************************************************************************
-**
-** mv_cust_set_tcont_state
-** ___________________________________________________________________________
-**
-** DESCRIPTION: The function sets T-CONT state in mv_cust
-**
-** INPUTS:
-**   tcont - T-CONT
-**   state - State of T-CONT, enabled or disabled.
-**
-** OUTPUTS:
-**   None.
-**
-** RETURNS:
-**  On success, the function returns (MV_OK). On error different types are
-**  returned according to the case.
-**
-*******************************************************************************/
-MV_STATUS mv_cust_set_tcont_state(uint32_t tcont, bool state);
-
-#endif /* __mv_cust_flow_map_h__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mng_if.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mng_if.h
deleted file mode 100644
index c6d9c99..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mng_if.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_mng_if.h
-*
-* DESCRIPTION : This file contains ONU MV CUST Management Interface
-********************************************************************************/
-#ifndef _MV_CUST_MNG_IF_H_
-#define _MV_CUST_MNG_IF_H_
-
-/* Include Files
-------------------------------------------------------------------------------*/
-#include <linux/cdev.h>
-
-/* Definitions
-------------------------------------------------------------------------------*/
-#define MV_CUST_IOCTL_OMCI_SET                _IOW(MV_CUST_IOCTL_MAGIC,  1,  unsigned int)
-#define MV_CUST_IOCTL_EOAM_LLID_SET           _IOW(MV_CUST_IOCTL_MAGIC,  2,  unsigned int)
-#define MV_CUST_IOCTL_EOAM_ENABLE             _IOW(MV_CUST_IOCTL_MAGIC,  3,  unsigned int)
-#define MV_CUST_IOCTL_OMCI_ENABLE             _IOW(MV_CUST_IOCTL_MAGIC,  4,  unsigned int)
-#define MV_CUST_IOCTL_MAP_RULE_SET            _IOW(MV_CUST_IOCTL_MAGIC,  5,  unsigned int)
-#define MV_CUST_IOCTL_DSCP_MAP_SET            _IOW(MV_CUST_IOCTL_MAGIC,  6,  unsigned int)
-#define MV_CUST_IOCTL_MAP_RULE_DEL            _IOW(MV_CUST_IOCTL_MAGIC,  7,  unsigned int)
-#define MV_CUST_IOCTL_DSCP_MAP_DEL            _IOW(MV_CUST_IOCTL_MAGIC,  8,  unsigned int)
-#define MV_CUST_IOCTL_MAP_RULE_CLEAR          _IOW(MV_CUST_IOCTL_MAGIC,  9,  unsigned int)
-#define MV_CUST_IOCTL_TAG_MAP_RULE_GET        _IOR(MV_CUST_IOCTL_MAGIC,  10, unsigned int)
-#define MV_CUST_IOCTL_UNTAG_MAP_RULE_GET      _IOR(MV_CUST_IOCTL_MAGIC,  11, unsigned int)
-#define MV_CUST_IOCTL_APP_ETH_TYPE_SET        _IOW(MV_CUST_IOCTL_MAGIC,  12, unsigned int)
-
-/* Enums
-------------------------------------------------------------------------------*/
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-typedef struct
-{
-    int                tcont;
-    int                txq;
-    int                gemport;
-    int                keep_rx_mh;
-} mv_cust_ioctl_omci_set_t;
-
-typedef struct
-{
-    int                llid;
-    int                txq;
-    uint8_t            llid_mac[6];
-} mv_cust_ioctl_llid_set_t;
-
-typedef struct
-{
-    mv_cust_dscp_pbits_t dscp_map;
-} mv_cust_ioctl_dscp_map_t;
-
-typedef struct
-{
-    mv_cust_app_type_e app_type;
-    uint16_t           eth_type;
-} mv_cust_ioctl_app_etype_t;
-
-/* MV_CUST Char Device Structure */
-/* ========================= */
-typedef struct
-{
-  mv_cust_ioctl_omci_set_t      mv_cust_ioctl_omci_set;
-  mv_cust_ioctl_llid_set_t      mv_cust_ioctl_llid_set;
-  mv_cust_ioctl_flow_map_t      mv_cust_ioctl_flow_map;
-  mv_cust_ioctl_dscp_map_t      mv_cust_ioctl_dscp_map;
-  mv_cust_ioctl_app_etype_t     mv_cust_ioctl_app_etype;
-
-  struct cdev  cdev;
-} mv_cust_cdev_t;
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Global variables
-------------------------------------------------------------------------------*/
-
-/* Global functions
-------------------------------------------------------------------------------*/
-
-/* Macros
-------------------------------------------------------------------------------*/
-
-#endif /* _MV_CUST_MNG_IF_H_ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mod.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mod.c
deleted file mode 100644
index 2bfecc2..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_mod.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_mod.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include "mv_cust_dev.h"
-
-
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("GPL");
-#endif
-
-static void __exit mv_cust_mod_exit(void)
-{
-    mvcust_dev_shutdown();
-}
-module_exit(mv_cust_mod_exit);
-
-
-static int __init mv_cust_mod_init(void)
-{
-    if (mvcust_dev_init() != 0)
-    {
-        //mv_cust_mod_exit();
-        printk(KERN_ERR "\nMV_CUST module initialization failed \n\n");
-        return -1;
-    }
-
-    printk(KERN_INFO "\nMV_CUST module inserted - %s\n\n",MV_CUST_VERSION);
-
-    return 0;
-}
-
-//module_init(mv_cust_mod_init);
-device_initcall_sync(mv_cust_mod_init);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.c
deleted file mode 100644
index c6753f2..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.c
+++ /dev/null
@@ -1,1441 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_netdev.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include <mvCommon.h>
-
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/if_vlan.h>
-#include <net/ip.h>
-#include <net/ipv6.h>
-#ifdef CONFIG_MV_CUST_MLD_HANDLE
-#include <linux/icmpv6.h>
-#endif
-
-#include <mvOs.h>
-#include <ctrlEnv/mvCtrlEnvLib.h>
-
-#include "mv_cust_dev.h"
-#include "mv_cust_netdev.h"
-#include "mv_cust_flow_map.h"
-#include "mv_cust_mng_if.h"
-
-/*----------------------------------------------------------------------------*/
-/* External  declaration                                                      */
-/*----------------------------------------------------------------------------*/
-
-/*----------------------------------------------------------------------------*/
-/* Global static definition                                                   */
-/*----------------------------------------------------------------------------*/
-/* YUVAL - update to pnc define */
-#define     MH_GEM_PORT_MASK                (0x0FFF)
-#define     MH_EPON_OAM_TYPE                (0x8809)
-#define     ETY_IPV4                        (0x0800)
-#define     IPV4_PROTO_OFFSET               (9)
-#define     MV_CUST_SWF_TX_QUEUE            (6)
-
-#define     CUST_TBL_NUM_ENTRIES(a)         (sizeof(a)/sizeof(a[0]))
-
-/*Static Declarations */
-static int    mv_eth_ports_num     = 0;
-static int    mv_cust_debug_code   = 0;
-
-static int    mv_cust_omci_gemport = 0;
-static int    mv_cust_omci_rx_gh   = 0;
-static int    mv_cust_oam_rx_gh    = 0;
-
-/* Protocol definitions */
-static struct mv_eth_tx_spec     omci_mgmt_tx_spec = {0, 0, 0, MV_CUST_SWF_TX_QUEUE};
-static struct mv_eoam_llid_spec  epon_mgmt_tx_spec[MV_CUST_NUM_LLID];
-#define EPON_MGMT_ENTRIES   CUST_TBL_NUM_ENTRIES(epon_mgmt_tx_spec)
-
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-static struct mv_port_tx_spec    udp_port_spec_cfg[CONFIG_MV_ETH_PORTS_NUM];
-#define PORT_ENTRIES        CUST_TBL_NUM_ENTRIES(udp_port_spec_cfg)
-#endif
-
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-static int    mv_cust_flow_map = 0;
-#endif
-
-/* Default Application Ethernet type used for socket and skb */
-#define MV_CUST_ETH_TYPE_IGMP      (0xA000)
-#define MV_CUST_ETH_TYPE_MLD       (0xAB00)
-#define MV_CUST_ETH_TYPE_LPBK      (0xFFFA)
-#define MV_CUST_ETH_TYPE_OAM       (0xBABA)
-/* The Ethernet tpye of OAM/OMCI could be same since they will not use at the same time*/
-#define MV_CUST_ETH_TYPE_OMCI      (0xBABA)
-
-/* Global cust configuration*/
-/* Pay attention that the order could be be changed and the entry could not be removed */
-static mv_cust_app_config_t gCustConfig[] =
-{
-    /* Application Type */   /* Enable Flag */   /*Application Eth type*/   /* Application Description*/
-    {MV_CUST_APP_TYPE_IGMP,  MV_CUST_APP_DISABLE, MV_CUST_ETH_TYPE_IGMP,     "IGMP application"},
-    {MV_CUST_APP_TYPE_MLD,   MV_CUST_APP_DISABLE, MV_CUST_ETH_TYPE_MLD,      "MLD application"},
-    {MV_CUST_APP_TYPE_LPBK,  MV_CUST_APP_DISABLE, MV_CUST_ETH_TYPE_LPBK,     "Loopback detection application"},
-    {MV_CUST_APP_TYPE_OAM,   MV_CUST_APP_DISABLE, MV_CUST_ETH_TYPE_OAM,      "eOAM application"},
-    {MV_CUST_APP_TYPE_OMCI,  MV_CUST_APP_DISABLE, MV_CUST_ETH_TYPE_OMCI,     "OMCI application"},
-};
-
-/*----------------------------------------------------------------------------*/
-/* Function implementation                                                    */
-/*----------------------------------------------------------------------------*/
-
-void mv_cust_debug_info_set(int val)
-{
-    mv_cust_debug_code = val;
-    return;
-}
-
-
-void mv_cust_app_flag_set(mv_cust_app_type_e app_type, uint16_t enable)
-{
-    if (mv_cust_debug_code)
-        printk("%s() In, app_type[%d], enable[%d] \n", __func__, app_type, enable);
-
-    if (app_type > (MV_CUST_APP_TYPE_MAX-1))
-    {
-        printk("%s: illegal application type[%d], allowed max type[%d]  \n",
-                __func__, app_type, MV_CUST_APP_TYPE_MAX-1);
-        return;
-    }
-
-    if (app_type == MV_CUST_APP_TYPE_OMCI)
-    {
-        if (enable)
-        {
-            if (gCustConfig[MV_CUST_APP_TYPE_OAM].enable)
-            {
-                MVCUST_ERR_PRINT("EPON is already valid\n");
-                return;
-            }
-            gCustConfig[MV_CUST_APP_TYPE_OMCI].enable = MV_CUST_APP_ENABLE;
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-            mv_cust_flow_map   = 1;
-#endif
-        }
-        else
-        {
-            gCustConfig[MV_CUST_APP_TYPE_OMCI].enable = MV_CUST_APP_DISABLE;
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-            mv_cust_flow_map   = 0;
-#endif
-        }
-    }
-    else if(app_type == MV_CUST_APP_TYPE_OAM)
-    {
-        if (enable)
-        {
-            if (gCustConfig[MV_CUST_APP_TYPE_OMCI].enable)
-            {
-                MVCUST_ERR_PRINT("GPON is already valid\n");
-                return;
-            }
-            gCustConfig[MV_CUST_APP_TYPE_OAM].enable = MV_CUST_APP_ENABLE;
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-            mv_cust_flow_map   = 0;
-#endif
-        }
-        else
-        {
-            gCustConfig[MV_CUST_APP_TYPE_OAM].enable = MV_CUST_APP_DISABLE;
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-            mv_cust_flow_map   = 0;
-#endif
-        }
-
-    }
-    else
-    {
-        if (enable == MV_CUST_APP_ENABLE)
-            gCustConfig[app_type].enable = MV_CUST_APP_ENABLE;
-        else
-            gCustConfig[app_type].enable = MV_CUST_APP_DISABLE;
-    }
-
-    return;
-}
-EXPORT_SYMBOL(mv_cust_app_flag_set);
-
-
-void mv_cust_app_etype_set(mv_cust_app_type_e app_type, uint16_t eth_type)
-{
-    if (mv_cust_debug_code)
-        printk("%s() In, app_type[%d], eth_type[%d] \n", __func__, app_type, eth_type);
-
-    if (app_type > (MV_CUST_APP_TYPE_MAX-1))
-    {
-        printk("%s: illegal application type[%d], allowed max type[%d]  \n",
-                __func__, app_type, MV_CUST_APP_TYPE_MAX-1);
-        return;
-    }
-
-    gCustConfig[app_type].eth_type = eth_type;
-
-    return;
-}
-EXPORT_SYMBOL(mv_cust_app_etype_set);
-
-
-void mv_cust_rec_skb(int port, struct sk_buff *skb)
-{
-    uint32_t rx_status;
-    struct eth_port *pp;
-
-    rx_status = netif_receive_skb(skb);
-    pp = mv_eth_port_by_id(port);
-    STAT_DBG(if (rx_status) (pp->stats.rx_drop_sw++));
-}
-
-void mv_cust_omci_rx_gh_set(int val)
-{
-    mv_cust_omci_rx_gh = val;
-    return;
-}
-
-int mv_cust_omci_tx_set(int tcont, int txq)
-{
-    if (mvNetaTxpCheck(MV_PON_PORT_ID, tcont)) {
-        return -EINVAL;
-    }
-
-    if (txq<0 || txq>CONFIG_MV_ETH_TXQ) {
-        return -EINVAL;
-    }
-
-    omci_mgmt_tx_spec.txp = tcont;
-    omci_mgmt_tx_spec.txq = txq;
-
-    return 0;
-}
-
-void mv_cust_omci_gemport_set(int gemport)
-{
-    mv_cust_omci_gemport = gemport;
-    return;
-}
-
-void mv_cust_omci_hw_cmd_set(uint32_t hw_cmd)
-{
-    omci_mgmt_tx_spec.hw_cmd = hw_cmd;
-}
-
-int mv_cust_omci_set(int tcont, int txq, int gem_port, int keep_rx_mh)
-{
-    int ret, hw_cmd;
-
-    omci_mgmt_tx_spec.tx_func = NULL;
-    omci_mgmt_tx_spec.flags = MV_ETH_F_NO_PAD | MV_ETH_F_MH;
-
-    ret = mv_cust_omci_tx_set(tcont, txq);
-    if (ret) {
-        MVCUST_ERR_PRINT("mv_cust_omci_tx_set - ret(%d)  \n", ret);
-        return ret;
-    }
-
-    mv_cust_omci_gemport_set(gem_port);
-    hw_cmd = ((gem_port << 8) | 0x0010);
-    mv_cust_omci_hw_cmd_set(hw_cmd);
-    mv_cust_omci_rx_gh_set(keep_rx_mh);
-
-    mv_cust_app_flag_set(MV_CUST_APP_TYPE_OMCI, MV_CUST_APP_ENABLE);
-
-    return 0;
-}
-EXPORT_SYMBOL(mv_cust_omci_set);
-
-void mv_cust_omci_print(void)
-{
-    printk("************* OMCI Configuration *****************\n\n");
-    printk("OMCI: valid = %d, gemport = %d, ethtype = 0x%04x, gh_keep = %d\n",
-           gCustConfig[MV_CUST_APP_TYPE_OMCI].enable,
-           mv_cust_omci_gemport,
-           ntohs(gCustConfig[MV_CUST_APP_TYPE_OMCI].eth_type),
-           mv_cust_omci_rx_gh);
-    printk("OMCI: txp   = %d, txq = %d, hw_cmd = 0x%08x, flags = 0x%04x on TX \n",
-           omci_mgmt_tx_spec.txp, omci_mgmt_tx_spec.txq, omci_mgmt_tx_spec.hw_cmd, omci_mgmt_tx_spec.flags);
-    printk("\n");
-}
-
-static int mv_cust_omci_gem_parse(uint8_t *data)
-{
-    uint16_t gh;
-
-    gh = ntohs(*(uint16_t *)data);
-
-    if(mv_cust_debug_code)
-        printk("%s:gh= 0x(%04x) - mv_cust_omci_gemport= 0x(%04x)  \n", __func__, gh, mv_cust_omci_gemport);
-
-    /* Compare GH for omci_gemport */
-    if ( (gh & MH_GEM_PORT_MASK) != mv_cust_omci_gemport ) {
-        if(mv_cust_debug_code)
-            printk("%s: compare GH for OMCI_gemport failed: gh= 0x(%04x) - mv_cust_omci_gemport= 0x(%04x)  \n", __func__, gh, mv_cust_omci_gemport);
-        return(0);
-    }
-
-    return(1);
-}
-
-static int mv_cust_omci_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t rx_bytes;
-
-    if (!mv_cust_omci_gem_parse(skb->data))
-        return 0;
-    if (mv_cust_omci_rx_gh) {
-        rx_bytes = rx_desc->dataSize;
-    }
-    else {
-        skb->data += MV_ETH_MH_SIZE;
-        rx_bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
-    }
-    skb->tail += rx_bytes;
-    skb->len = rx_bytes;
-    skb->protocol = eth_type_trans(skb, dev);
-    skb->protocol = htons(gCustConfig[MV_CUST_APP_TYPE_OMCI].eth_type);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    skb->dev = dev;
-#endif
-    mv_cust_rec_skb(port, skb);
-
-    return 1;
-}
-
-int mv_cust_omci_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                   struct mv_eth_tx_spec *tx_spec_out)
-{
-    if ((skb->protocol == htons(gCustConfig[MV_CUST_APP_TYPE_OMCI].eth_type))
-        && (MV_CUST_APP_ENABLE == gCustConfig[MV_CUST_APP_TYPE_OMCI].enable)
-        && (port == MV_PON_PORT_ID)) {
-        memcpy (tx_spec_out, &omci_mgmt_tx_spec, sizeof(struct mv_eth_tx_spec));
-        if(mv_cust_debug_code)
-            printk("%s", __func__);
-        return 1;
-    }
-    return 0;
-}
-
-
-void mv_cust_oam_rx_gh_set(int val)
-{
-    mv_cust_oam_rx_gh = val;
-    return;
-}
-
-int mv_cust_eoam_llid_set(int llid, uint8_t *llid_mac, int txq)
-{
-
-    if (mvNetaTxpCheck(MV_PON_PORT_ID, llid))
-        return -EINVAL;
-
-    if (txq<0 || txq>CONFIG_MV_ETH_TXQ) {
-            return -EINVAL;
-    }
-    if (!llid_mac) {
-        return -EINVAL;
-    }
-    memcpy((void *) &(epon_mgmt_tx_spec[llid].llid_mac_address), (void *) llid_mac, ETH_ALEN);
-
-    epon_mgmt_tx_spec[llid].tx_spec.txq = txq;
-
-    return 0;
-}
-EXPORT_SYMBOL(mv_cust_eoam_llid_set);
-
-void mv_cust_eoam_init(void)
-{
-    int i;
-
-    for (i=0;i <(EPON_MGMT_ENTRIES);i++) {
-        memset(&epon_mgmt_tx_spec[i],0, sizeof(struct mv_eoam_llid_spec));
-
-        /* Each table entry (i) a-priori corresponds to LLID (i) */
-        epon_mgmt_tx_spec[i].tx_spec.txp = i;
-
-        /* The mv_neta driver will add the default MH. The MH value has no significance in EPON Upstream */
-        epon_mgmt_tx_spec[i].tx_spec.flags = MV_ETH_F_MH;
-    }
-
-    /* In Rx, keep the MH for EOAM */
-    mv_cust_oam_rx_gh_set(1);
-    return ;
-}
-
-void mv_cust_eoam_print(void)
-{
-    int i;
-    printk("************* eOAM Configuration *****************\n\n");
-    printk("EOAM: valid = %d, ethtype = 0x%04x, gh_keep = %d\n",
-           gCustConfig[MV_CUST_APP_TYPE_OAM].enable,
-           ntohs(gCustConfig[MV_CUST_APP_TYPE_OAM].eth_type),
-           mv_cust_oam_rx_gh);
-    for (i=0;i <(EPON_MGMT_ENTRIES);i++) {
-        printk("llid%d: mac=%02x:%02x:%02x:%02x:%02x:%02x, txp=%d, txq=%d, hw_cmd=0x%08x, flags = 0x%04x\n",
-               i,
-               epon_mgmt_tx_spec[i].llid_mac_address[0],epon_mgmt_tx_spec[i].llid_mac_address[1],
-               epon_mgmt_tx_spec[i].llid_mac_address[2],epon_mgmt_tx_spec[i].llid_mac_address[3],
-               epon_mgmt_tx_spec[i].llid_mac_address[4],epon_mgmt_tx_spec[i].llid_mac_address[5],
-               epon_mgmt_tx_spec[i].tx_spec.txp, epon_mgmt_tx_spec[i].tx_spec.txq,
-               epon_mgmt_tx_spec[i].tx_spec.hw_cmd, epon_mgmt_tx_spec[i].tx_spec.flags);
-        printk("\n");
-    }
-}
-
-static int mv_cust_eoam_type_parse(uint8_t *data)
-{
-    uint16_t ety;
-
-    ety = ntohs(*(uint16_t *)(data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN));
-
-    if(mv_cust_debug_code)
-        printk("%s: ety 0x(%04x)\n", __func__, ety);
-
-    /* Compare EPON OAM ether_type */
-    if (ety == MH_EPON_OAM_TYPE)
-        return(1);
-
-    return(0);
-}
-
-static int mv_cust_epon_oam_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t rx_bytes;
-
-    if (!mv_cust_eoam_type_parse(skb->data))
-        return 0;
-
-    if (mv_cust_oam_rx_gh) {
-        rx_bytes = rx_desc->dataSize;
-    }
-    else {
-        skb->data += MV_ETH_MH_SIZE;
-        rx_bytes = rx_desc->dataSize - MV_ETH_MH_SIZE;
-    }
-
-    skb->tail += rx_bytes;
-    skb->len = rx_bytes;
-    skb->protocol = eth_type_trans(skb, dev);
-    skb->protocol = htons(gCustConfig[MV_CUST_APP_TYPE_OAM].eth_type);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    skb->dev = dev;
-#endif
-    mv_cust_rec_skb(port, skb);
-
-    return 1;
-}
-
-int mv_cust_eoam_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                    struct mv_eth_tx_spec *tx_spec_out)
-{
-    int mac_match, i;
-
-    if ((skb->protocol == htons(gCustConfig[MV_CUST_APP_TYPE_OAM].eth_type))
-        && (MV_CUST_APP_ENABLE == gCustConfig[MV_CUST_APP_TYPE_OAM].enable)
-        && port == MV_PON_PORT_ID) {
-        /* Lookup MAC Address */
-        for (i=0; i<(EPON_MGMT_ENTRIES);i++) {
-            mac_match = memcmp((void *) &(epon_mgmt_tx_spec[i].llid_mac_address[0]),
-                               (void *)(skb->data + /*MV_ETH_MH_SIZE +*/ ETH_ALEN),
-                               ETH_ALEN);
-            if (!mac_match) {
-                memcpy (tx_spec_out, &epon_mgmt_tx_spec[i].tx_spec, sizeof(struct mv_eth_tx_spec));
-                if(mv_cust_debug_code)
-                    printk("%s, llid = %d", __func__, i);
-                return 1;
-            }
-        }
-        /* Source MAC Address not found */
-        if(mv_cust_debug_code) {
-            printk("(%s)Input Packet first bytes:\n", __func__);
-            for (i=0;i<24;i++) {
-                if (i%8== 0)
-                    printk("\n");
-                printk ("%02x ", *(skb->data + i));
-            }
-        }
-    }
-    return 0;
-}
-
-
-#ifdef CONFIG_MV_CUST_IGMP_HANDLE
-void mv_cust_igmp_print(void)
-{
-    printk("************* IGMP Configuration *****************\n\n");
-    printk("IGMP valid = %d,  ethtype = 0x%04x \n",
-           gCustConfig[MV_CUST_APP_TYPE_IGMP].enable,
-           gCustConfig[MV_CUST_APP_TYPE_IGMP].eth_type);
-    printk("IGMP default txq = %d\n",MV_CUST_SWF_TX_QUEUE);
-    printk("\n");
-}
-
-static int mv_cust_igmp_parse(uint8_t *data)
-{
-    uint16_t ety;
-    uint8_t  proto;
-    uint8_t *fieldp = data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN;
-
-    /* Loop through VLAN tags */
-    ety = ntohs(*(uint16_t *)fieldp);
-    while (ety == 0x8100 || ety == 0x9100 || ety == 0x88A8) {
-        fieldp+= VLAN_HLEN;
-        ety = ntohs(*(uint16_t *)fieldp);
-    }
-
-    if(mv_cust_debug_code)
-        printk("%s:ety 0x(%04x)\n", __func__, ety);
-
-    if (ety == ETY_IPV4) {
-        fieldp+= 2;
-        fieldp+= IPV4_PROTO_OFFSET;
-        proto = *fieldp;
-        if (mv_cust_debug_code)
-            printk("%s:proto 0x(%02x)\n", __func__, proto);
-
-        if (proto == IPPROTO_IGMP)
-            return(1);
-    }
-
-    return(0);
-}
-
-static int mv_cust_igmp_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t rx_bytes;
-
-    if (!mv_cust_igmp_parse(skb->data))
-        return 0;
-
-    /* To Indicate the source GMAC */
-    skb->data[0] = port;
-
-    rx_bytes = rx_desc->dataSize;
-
-    skb->tail += rx_bytes;
-    skb->len = rx_bytes;
-    skb->protocol = eth_type_trans(skb, dev);
-    skb->protocol = htons(gCustConfig[MV_CUST_APP_TYPE_IGMP].eth_type);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    skb->dev = dev;
-#endif
-    mv_cust_rec_skb(port, skb);
-
-    return 1;
-}
-
-int mv_cust_igmp_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                    struct mv_eth_tx_spec *tx_spec_out)
-{
-    if (gCustConfig[MV_CUST_APP_TYPE_IGMP].enable == MV_CUST_APP_ENABLE) {
-        /* Check application Ethernet type */
-        if (skb->protocol == htons(gCustConfig[MV_CUST_APP_TYPE_IGMP].eth_type)) {
-
-            /* The Mapping and VLAN mod should be support in next phase */
-            if (MV_PON_PORT_ID == port)
-            {
-                tx_spec_out->flags = MV_ETH_F_MH;
-            }
-            else
-            {
-                tx_spec_out->flags = 0;
-            }
-
-            tx_spec_out->txp     = 0;
-            tx_spec_out->txq     = MV_CUST_SWF_TX_QUEUE;
-            tx_spec_out->hw_cmd  = 0;
-#ifdef CONFIG_MV_ETH_TX_SPECIAL
-            tx_spec_out->tx_func = NULL;
-#endif
-            return 1;
-        }
-    }
-    return 0;
-}
-
-#endif
-
-
-#ifdef CONFIG_MV_CUST_MLD_HANDLE
-void mv_cust_mld_print(void)
-{
-    printk("************* MLD Configuration *****************\n\n");
-    printk("MLD valid = %d,  ethtype = 0x%04x \n",
-           gCustConfig[MV_CUST_APP_TYPE_MLD].enable,
-           gCustConfig[MV_CUST_APP_TYPE_MLD].eth_type);
-    printk("MLD default txq = %d\n",MV_CUST_SWF_TX_QUEUE);
-    printk("\n");
-}
-
-static int mv_cust_mld_parse(uint8_t *data)
-{
-    uint16_t ety;
-    uint8_t *fieldp = data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN;
-
-
-    /* Loop through VLAN tags */
-    ety = ntohs(*(uint16_t *)fieldp);
-    while (ety == 0x8100 || ety == 0x9100 ||ety == 0x88A8) {
-        fieldp+= VLAN_HLEN;
-        ety = ntohs(*(uint16_t *)fieldp);
-    }
-
-    if(mv_cust_debug_code)
-        printk("%s:ety 0x(%04x)\n", __func__, ety);
-
-    if (ety == ETH_P_IPV6)
-    {
-        struct ipv6hdr *hdr = (struct ipv6hdr *)(fieldp+2);
-        struct ipv6_hopopt_hdr *hopopthdr ;
-        struct icmp6hdr *pic;
-
-        if (hdr->nexthdr != NEXTHDR_HOP )
-          return 0;
-
-        hopopthdr = (struct ipv6_hopopt_hdr *)((uint8_t *)hdr+ sizeof(struct ipv6hdr));
-
-        if ( hopopthdr->nexthdr != IPPROTO_ICMPV6)
-            return 0;
-
-        pic =  (struct icmp6hdr *)((uint8_t *)hopopthdr+ipv6_optlen(hopopthdr));
-
-        switch (pic->icmp6_type) {
-        case ICMPV6_MGM_QUERY:
-        case ICMPV6_MGM_REPORT:
-        case ICMPV6_MGM_REDUCTION:
-        case ICMPV6_MLD2_REPORT:
-            return 1;
-        default:
-            break;
-        }
-
-    }
-
-    return(0);
-}
-
-static int mv_cust_mld_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t rx_bytes;
-
-    if (!mv_cust_mld_parse(skb->data))
-        return 0;
-
-    /* To Indicate the source GMAC */
-    skb->data[0] = port;
-
-    rx_bytes = rx_desc->dataSize;
-
-    skb->tail += rx_bytes;
-    skb->len = rx_bytes;
-    skb->protocol = eth_type_trans(skb, dev);
-    skb->protocol = htons(gCustConfig[MV_CUST_APP_TYPE_MLD].eth_type);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    skb->dev = dev;
-#endif
-
-    mv_cust_rec_skb(port, skb);
-
-    return 1;
-}
-
-int mv_cust_mld_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                   struct mv_eth_tx_spec *tx_spec_out)
-{
-    if (gCustConfig[MV_CUST_APP_TYPE_MLD].enable == MV_CUST_APP_ENABLE) {
-        /* Check application Ethernet type */
-        if (skb->protocol == htons(gCustConfig[MV_CUST_APP_TYPE_MLD].eth_type)) {
-
-            /* The Mapping and VLAN mod should be support in next phase */
-            if (MV_PON_PORT_ID == port)
-            {
-                tx_spec_out->flags = MV_ETH_F_MH;
-            }
-            else
-            {
-                tx_spec_out->flags = 0;
-            }
-
-            tx_spec_out->txp     = 0;
-            tx_spec_out->txq     = MV_CUST_SWF_TX_QUEUE;
-            tx_spec_out->hw_cmd  = 0;
-#ifdef CONFIG_MV_ETH_TX_SPECIAL
-            tx_spec_out->tx_func = NULL;
-#endif
-            return 1;
-        }
-    }
-    return 0;
-}
-
-#endif
-
-
-#ifdef CONFIG_MV_CUST_LPBK_DETECT_HANDLE
-void mv_cust_loopdet_print(void)
-{
-    printk("************* UNI loopback detection Configuration *****************\n\n");
-    printk("Lpbk detect valid = %d,  ethtype = 0x%04x \n",
-           gCustConfig[MV_CUST_APP_TYPE_LPBK].enable,
-           gCustConfig[MV_CUST_APP_TYPE_LPBK].eth_type);
-    printk("Lpbk detect default txq = %d\n",MV_CUST_SWF_TX_QUEUE);
-    printk("\n");
-}
-
-static int mv_cust_loopdet_parse(uint8_t *data)
-{
-    uint16_t ety;
-    uint8_t *fieldp = data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN;
-
-    /* Loop through VLAN tags */
-    ety = ntohs(*(uint16_t *)fieldp);
-    while (ety == 0x8100 || ety == 0x9100 ||ety == 0x88A8) {
-        fieldp+= VLAN_HLEN;
-        ety = ntohs(*(uint16_t *)fieldp);
-    }
-    if(mv_cust_debug_code)
-        printk("%s: ety 0x(%04x)\n", __func__, ety);
-
-    /* Compare EPON OAM ether_type */
-    if (ety == gCustConfig[MV_CUST_APP_TYPE_LPBK].eth_type)
-        return(1);
-
-    return(0);
-}
-
-static int mv_cust_loopdet_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t rx_bytes;
-
-    if (!mv_cust_loopdet_parse(skb->data))
-        return 0;
-
-    /* To Indicate the source GMAC */
-    skb->data[0] = port;
-
-    rx_bytes = rx_desc->dataSize;
-
-    skb->tail += rx_bytes;
-    skb->len = rx_bytes;
-    skb->protocol = eth_type_trans(skb, dev);
-    skb->protocol = htons(gCustConfig[MV_CUST_APP_TYPE_LPBK].eth_type);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-    skb->dev = dev;
-#endif
-    mv_cust_rec_skb(port, skb);
-
-    return 1;
-}
-
-int mv_cust_loopdet_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                       struct mv_eth_tx_spec *tx_spec_out)
-{
-    if (MV_CUST_APP_ENABLE == gCustConfig[MV_CUST_APP_TYPE_LPBK].enable) {
-        /* Check application Ethernet type */
-        if (skb->protocol == htons(gCustConfig[MV_CUST_APP_TYPE_LPBK].eth_type)) {
-
-            if (MV_PON_PORT_ID == port)
-            {
-                tx_spec_out->flags = MV_ETH_F_MH;
-            }
-            else
-            {
-                tx_spec_out->flags = 0;
-            }
-
-            tx_spec_out->txp     = 0;
-            tx_spec_out->txq     = MV_CUST_SWF_TX_QUEUE;
-            tx_spec_out->hw_cmd  = 0;
-#ifdef CONFIG_MV_ETH_TX_SPECIAL
-            tx_spec_out->tx_func = NULL;
-#endif
-            return 1;
-        }
-    }
-    return 0;
-}
-
-#endif
-
-
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-static inline void mv_cust_copy_tx_spec(struct mv_eth_tx_spec * tx_spec,
-                                        uint8_t txp, uint8_t txq,
-                                        uint16_t flags, uint32_t hw_cmd)
-{
-    tx_spec->txp = txp;
-    tx_spec->txq = txq;
-    tx_spec->hw_cmd = hw_cmd;
-    tx_spec->flags = flags;
-}
-
-int mv_cust_udp_spec_print(int port)
-{
-    int i;
-    struct eth_port *pp = mv_eth_port_by_id(port);
-    struct mv_udp_port_tx_spec *udp_spec;
-
-    if (!pp)
-        return -ENODEV;
-
-    udp_spec = &(udp_port_spec_cfg[port].udp_dst[0]);
-
-    printk("\n**** port #%d - TX UDP Dest Port configuration *****\n", port);
-    printk("----------------------------------------------------\n");
-    printk("ID udp_dst   txp    txq    flags    hw_cmd     func_add\n");
-    for (i = 0; i < sizeof(udp_port_spec_cfg[port].udp_dst)/sizeof(udp_port_spec_cfg[port].udp_dst[0]); i++) {
-        if (udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID)
-            printk("%2d   %04d      %d      %d     0x%04x   0x%08x   0x%p\n",
-                   i, ntohs(udp_spec[i].udp_port),
-                   udp_spec[i].tx_spec.txp, udp_spec[i].tx_spec.txq,
-                   udp_spec[i].tx_spec.flags, udp_spec[i].tx_spec.hw_cmd,
-                   udp_spec[i].tx_spec.tx_func);
-    }
-    printk("-----------------------------------------------------\n");
-
-    udp_spec = &(udp_port_spec_cfg[port].udp_src[0]);
-
-    printk("**** port #%d - TX UDP Source Port configuration *****\n", port);
-    printk("-----------------------------------------------------\n");
-    printk("ID udp_src   txp    txq     flags    hw_cmd     func_add\n");
-    for (i = 0; i < sizeof(udp_port_spec_cfg[port].udp_src)/sizeof(udp_port_spec_cfg[port].udp_src[0]); i++) {
-        if (udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID)
-            printk("%2d   %04d      %d      %d     0x%04x   0x%08x   0x%p\n",
-                   i, ntohs(udp_spec[i].udp_port),
-                   udp_spec[i].tx_spec.txp, udp_spec[i].tx_spec.txq,
-                   udp_spec[i].tx_spec.flags, udp_spec[i].tx_spec.hw_cmd,
-                   udp_spec[i].tx_spec.tx_func);
-    }
-    printk("**************************************************************\n");
-
-    return 0;
-}
-
-
-void mv_cust_udp_spec_print_all(void)
-{
-    int port;
-
-    for (port=0;port < CONFIG_MV_ETH_PORTS_NUM ;port++) {
-        mv_cust_udp_spec_print(port);
-    }
-}
-
-MV_STATUS  mv_cust_udp_int_spec_set(struct mv_udp_port_tx_spec *udp_spec, uint16_t udp_port, int table_size,
-                                    uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd)
-{
-    int i;
-
-    /* Check if already exists */
-    for (i=0; i < table_size;i++) {
-        if (udp_spec[i].udp_port == htons(udp_port) &&
-            udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID) {
-            mv_cust_copy_tx_spec(&(udp_spec[i].tx_spec), txp, txq, flags, hw_cmd);
-            return MV_OK;
-        }
-    }
-    /* Check empty */
-    for (i=0; i < table_size;i++) {
-        if (udp_spec[i].tx_spec.txq == MV_ETH_TXQ_INVALID) {
-            udp_spec[i].udp_port = htons(udp_port);
-            mv_cust_copy_tx_spec(&(udp_spec[i].tx_spec), txp, txq, flags, hw_cmd);
-            return MV_OK;
-        }
-    }
-
-    return(MV_FULL);
-}
-
-
-MV_STATUS  mv_cust_udp_src_spec_set(int tx_port, uint16_t udp_src_port, uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd)
-{
-    struct eth_port *pp = mv_eth_port_by_id(tx_port);
-    struct mv_udp_port_tx_spec *udp_src_spec = udp_port_spec_cfg[tx_port].udp_src;
-    MV_STATUS mv_status;
-
-    if (!pp)
-        return -ENODEV;
-
-    mv_status = mv_cust_udp_int_spec_set(udp_src_spec, udp_src_port,
-                                         sizeof(udp_port_spec_cfg[tx_port].udp_src)/sizeof(udp_port_spec_cfg[tx_port].udp_src[0]),
-                                         txp, txq, flags, hw_cmd);
-
-    if (mv_status != MV_OK)
-        printk("%s: UDP Special Source Port Table is full\n", __func__);
-
-    return(mv_status);
-}
-EXPORT_SYMBOL(mv_cust_udp_src_spec_set);
-
-
-MV_STATUS  mv_cust_udp_dest_spec_set(int tx_port, uint16_t udp_dest_port, uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd)
-{
-    struct eth_port *pp = mv_eth_port_by_id(tx_port);
-    struct mv_udp_port_tx_spec *udp_dst_spec = udp_port_spec_cfg[tx_port].udp_dst;
-    MV_STATUS mv_status;
-
-    if (!pp)
-        return -ENODEV;
-
-    mv_status = mv_cust_udp_int_spec_set(udp_dst_spec, udp_dest_port,
-                                         sizeof(udp_port_spec_cfg[tx_port].udp_dst)/sizeof(udp_port_spec_cfg[tx_port].udp_dst[0]),
-                                         txp, txq, flags, hw_cmd);
-
-    if (mv_status != MV_OK)
-        printk("%s: UDP Special Dest. Port Table is full\n", __func__);
-
-    return(mv_status);
-}
-EXPORT_SYMBOL(mv_cust_udp_dest_spec_set);
-
-
-void  mv_cust_udp_table_del(void)
-{
-    int num_ports = PORT_ENTRIES;
-    int tx_port, i;
-
-    if (num_ports > mv_eth_ports_num)
-        num_ports = mv_eth_ports_num;
-
-
-    for (tx_port=0; tx_port<num_ports;tx_port++) {
-
-        /* Invalidate UDP Dest ports, set txq=invalid  */
-        for (i=0;i<(sizeof(udp_port_spec_cfg[tx_port].udp_dst)/sizeof(udp_port_spec_cfg[tx_port].udp_dst[0]));i++) {
-            memset(&(udp_port_spec_cfg[tx_port].udp_dst[i]), 0, sizeof(struct mv_udp_port_tx_spec));
-            udp_port_spec_cfg[tx_port].udp_dst[i].tx_spec.txq = MV_ETH_TXQ_INVALID;
-        }
-
-        /* Invalidate UDP Source ports, , set txq=invalid */
-        for (i=0;i<(sizeof(udp_port_spec_cfg[tx_port].udp_src)/sizeof(udp_port_spec_cfg[tx_port].udp_src[0]));i++) {
-            memset(&(udp_port_spec_cfg[tx_port].udp_src[i]), 0, sizeof(struct mv_udp_port_tx_spec));
-            udp_port_spec_cfg[tx_port].udp_src[i].tx_spec.txq = MV_ETH_TXQ_INVALID;
-        }
-
-    }
-    return;
-}
-
-int mv_cust_udp_port_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                        struct mv_eth_tx_spec *tx_spec_out)
-{
-    struct iphdr  * iphdrp   = NULL;
-    struct udphdr * udphdrp  = NULL;
-    int i;
-
-    if (port > CONFIG_MV_ETH_PORTS_NUM) {
-        printk("Port Error\n");
-        return(0);
-    }
-
-    if (skb->protocol == ETY_IPV4) {
-        /* Get UDP Port */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-    iphdrp = skb->nh.iph;
-#else
-    iphdrp = ip_hdr(skb);
-#endif
-
-        if ((iphdrp) && (iphdrp->protocol == IPPROTO_UDP)) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-        udphdrp = skb->h.uh;
-#else
-        udphdrp = udp_hdr(skb);
-#endif
-            if (udphdrp) {
-                if (udphdrp == (struct udphdr *)iphdrp) {
-                    udphdrp = (struct udphdr *)((char *)udphdrp + (4*(iphdrp->ihl)));
-                }
-                /* Find configured UDP Source Port*/
-                for (i=0; i < sizeof(udp_port_spec_cfg[port].udp_src)/sizeof(udp_port_spec_cfg[port].udp_src[0]);i++) {
-                    if ((udphdrp->source == udp_port_spec_cfg[port].udp_src[i].udp_port) &&
-                        (udp_port_spec_cfg[port].udp_src[i].tx_spec.txq != MV_ETH_TXQ_INVALID)) {
-                        memcpy (tx_spec_out, &(udp_port_spec_cfg[port].udp_src[i].tx_spec), sizeof(struct mv_eth_tx_spec));
-                        if (mv_cust_debug_code)
-                            printk("%s: found udp_src 0x(%04x)\n", __func__, ntohs(udphdrp->source));
-                        return 1;
-                    }
-                }
-                /* Find configured UDP Dest. Port*/
-                for (i=0; i < sizeof(udp_port_spec_cfg[port].udp_dst)/sizeof(udp_port_spec_cfg[port].udp_dst[0]);i++) {
-                    if ((udphdrp->dest == udp_port_spec_cfg[port].udp_dst[i].udp_port) &&
-                        (udp_port_spec_cfg[port].udp_src[i].tx_spec.txq != MV_ETH_TXQ_INVALID)) {
-                        memcpy (tx_spec_out, &(udp_port_spec_cfg[port].udp_dst[i].tx_spec), sizeof(struct mv_eth_tx_spec));
-                        if (mv_cust_debug_code)
-                            printk("%s: found udp_dst 0x(%04x)\n", __func__, ntohs(udphdrp->dest));
-                        return 1;
-                    }
-                }
-
-        if ( (port == MV_PON_PORT_ID) && mv_cust_debug_code) {
-            printk("%s:DEBUG : Packet UDP, udp source or dest port not found udp_src(%x)x udp_dst(%x)x\n",
-                   __func__,ntohs(udphdrp->source), ntohs(udphdrp->dest));
-        }
-
-            }
-        }
-        else if ( (port == MV_PON_PORT_ID) && mv_cust_debug_code )
-            printk("%s:DEBUG : NOT UDP, ip_proto(%d) \n", __func__, iphdrp->protocol);
-    }
-    else if ( (port == MV_PON_PORT_ID) && mv_cust_debug_code )
-        printk("%s:DEBUG : NOT IP, proto(%d) \n", __func__, skb->protocol);
-
-    return 0;
-
-}
-#endif
-
-
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-void mv_cust_flow_map_print(void)
-{
-    printk("************* Flow Mapping Configuration *****************\n\n");
-    printk("Flow mapping valid = %d\n", mv_cust_flow_map);
-}
-
-static int mv_cust_flow_map_parse(uint8_t *data, uint16_t *vlan, uint8_t *pbits, uint8_t dir)
-{
-    uint16_t ety;
-    uint8_t *fieldp ;
-
-    if (MV_CUST_FLOW_DIR_US == dir)
-        fieldp = data + ETH_ALEN + ETH_ALEN;
-    else
-        fieldp = data + ETH_ALEN + ETH_ALEN + MV_ETH_MH_SIZE;
-
-    /* Loop through VLAN tags */
-    ety = ntohs(*(uint16_t *)fieldp);
-    if (ety == 0x8100 || ety == 0x88A8 || ety == 0x9100) {
-        fieldp += 2;
-        *vlan  = ntohs(*(uint16_t *)fieldp);
-        *pbits = (*vlan >> 13 ) & 0x7;
-        *vlan  = (*vlan) & 0xfff;
-        return(1);
-    }
-    else {
-        return(0);
-    }
-
-    return(0);
-}
-
-static int mv_cust_flow_map_mod(uint8_t *data, uint16_t vid, uint8_t pbits, uint8_t dir)
-{
-    uint16_t ety  = 0;
-    uint16_t vlan = 0;
-    uint8_t *fieldp;
-
-    if (MV_CUST_FLOW_DIR_US == dir)
-        fieldp = data + ETH_ALEN + ETH_ALEN;
-    else
-        fieldp = data + ETH_ALEN + ETH_ALEN + MV_ETH_MH_SIZE;
-
-    /* If not need to modify VID or P-bits */
-    if((vid == MV_CUST_VID_NOT_CARE_VALUE) &&
-       (pbits == MV_CUST_PBITS_NOT_CARE_VALUE))
-        return (1);
-
-    /* Loop through VLAN tags */
-    ety = ntohs(*(uint16_t *)fieldp);
-    if (ety == 0x8100 || ety == 0x88A8 || ety == 0x9100) {
-        fieldp += 2;
-
-        vlan = ntohs(*(uint16_t *)fieldp);
-
-        if (vid < MV_CUST_VID_NOT_CARE_VALUE)
-            vlan = (vlan & 0xf000) | (vid & 0xfff);
-        if (pbits < MV_CUST_PBITS_NOT_CARE_VALUE)
-            vlan = (vlan & 0x0fff) | ((pbits & 0x7) << 13);
-
-        *(uint16_t *)fieldp = htons(vlan);
-        return(1);
-    }
-    else {
-        return(0);
-    }
-
-    return(0);
-}
-
-static int mv_cust_flow_map_rx(int port, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint16_t vlan        = 0;
-    uint8_t  pbits       = 0;
-    int      btag        = 0;
-    int      ret         = 0;
-    mv_cust_ioctl_flow_map_t cust_flow;
-
-    if (MV_PON_PORT_ID != port)
-        return 0;
-
-    if (mv_cust_flow_map) {
-
-        /* Parse packets to check whether it is tagged or untagged, and get vlan and pbits in tagged mode */
-        btag = mv_cust_flow_map_parse(skb->data, &vlan, &pbits, MV_CUST_FLOW_DIR_DS);
-        //printk(KERN_ERR " %s TX packet 1 btag[%d] vlan[%d]  pbits[%d]\n", __func__, btag, vlan, pbits);
-
-        /* The frame is tagged */
-        if (btag == 1) {
-            cust_flow.vid    = vlan;
-            cust_flow.pbits  = pbits;
-            cust_flow.dir    = MV_CUST_FLOW_DIR_DS;
-
-            ret = mv_cust_tag_map_rule_get(&cust_flow);
-            //printk(KERN_ERR " %s TX packet 2 trg_port[%d] trg_queue[%d]  gem_port[%d]\n", __func__, pkt_fwd.trg_port, pkt_fwd.trg_queue, pkt_fwd.gem_port);
-
-            /* Modify VID and P-bits if needed */
-            if (ret == MV_CUST_OK) {
-
-                /* modify VID and P-bits if needed */
-                ret = mv_cust_flow_map_mod(skb->data, cust_flow.mod_vid, cust_flow.mod_pbits, MV_CUST_FLOW_DIR_DS);
-            }
-        }
-    }
-
-    return 1;
-}
-
-int mv_cust_flow_map_tx(int port, struct net_device *dev, struct sk_buff *skb,
-                        struct mv_eth_tx_spec *tx_spec_out)
-{
-    struct iphdr *iphdrp = NULL;
-    uint16_t vlan        = 0;
-    uint8_t  pbits       = 0;
-    int      btag        = 0;
-    int      ret         = 0;
-    mv_cust_ioctl_flow_map_t cust_flow;
-
-    if (MV_PON_PORT_ID != port)
-        return 0;
-
-    if (mv_cust_flow_map) {
-
-        cust_flow.dir  = MV_CUST_FLOW_DIR_US;
-
-        /* Parse packets to check whether it is tagged or untagged, and get vlan and pbits in tagged mode */
-        btag = mv_cust_flow_map_parse(skb->data, &vlan, &pbits, MV_CUST_FLOW_DIR_US);
-
-        /* The frame is tagged */
-        if (btag == 1) {
-            cust_flow.vid    = vlan;
-            cust_flow.pbits  = pbits;
-
-            ret = mv_cust_tag_map_rule_get(&cust_flow);
-            //printk(KERN_ERR " %s TX packet 2 trg_port[%d] trg_queue[%d]  gem_port[%d]\n", __func__, pkt_fwd.trg_port, pkt_fwd.trg_queue, pkt_fwd.gem_port);
-
-            /* Set GEM port, target port and queue */
-            if (ret == MV_CUST_OK) {
-                    tx_spec_out->txp     = (u8)cust_flow.pkt_frwd.trg_port;
-                    tx_spec_out->txq     = (u8)cust_flow.pkt_frwd.trg_queue;
-                    tx_spec_out->hw_cmd  = ((cust_flow.pkt_frwd.gem_port << 8)|0x0010);
-                    tx_spec_out->tx_func = NULL;
-                    tx_spec_out->flags   = MV_ETH_F_MH;
-
-                    /* modify VID and P-bits if needed */
-                    ret = mv_cust_flow_map_mod(skb->data, cust_flow.mod_vid, cust_flow.mod_pbits, MV_CUST_FLOW_DIR_US);
-                    return 1;
-            }
-            else /* Look for rules that does not care VLAN */
-            {
-                cust_flow.vid   = MV_CUST_DEFAULT_SINGLE_TAG_RULE;
-                ret = mv_cust_tag_map_rule_get(&cust_flow);
-
-                /* Set GEM port, target port and queue */
-                if (ret == MV_CUST_OK) {
-                        tx_spec_out->txp     = (u8)cust_flow.pkt_frwd.trg_port;
-                        tx_spec_out->txq     = (u8)cust_flow.pkt_frwd.trg_queue;
-                        tx_spec_out->hw_cmd  = ((cust_flow.pkt_frwd.gem_port << 8)|0x0010);
-                        tx_spec_out->tx_func = NULL;
-                        tx_spec_out->flags   = MV_ETH_F_MH;
-
-                        /* modify VID and P-bits if needed */
-                        ret = mv_cust_flow_map_mod(skb->data, cust_flow.mod_vid, cust_flow.mod_pbits, MV_CUST_FLOW_DIR_US);
-                        return 1;
-                }
-            }
-        }
-        /* The frame is untagged, try to get DSCP value */
-        else {
-            if (skb->protocol == ETY_IPV4) {
-                /* Get UDP Port */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
-                iphdrp = skb->nh.iph;
-#else
-                iphdrp = ip_hdr(skb);
-#endif
-                cust_flow.dscp  = (iphdrp->tos >> 2) & 0x3f;
-                cust_flow.dir   = MV_CUST_FLOW_DIR_US;
-
-                ret = mv_cust_untag_map_rule_get(&cust_flow);
-                /* Set GEM port, target port and queue */
-                if (ret == MV_CUST_OK) {
-                        tx_spec_out->txp     = cust_flow.pkt_frwd.trg_port;
-                        tx_spec_out->txq     = cust_flow.pkt_frwd.trg_queue;
-                        tx_spec_out->hw_cmd  = ((cust_flow.pkt_frwd.gem_port << 8)|0x0010);
-                        tx_spec_out->tx_func = NULL;
-                        tx_spec_out->flags   = MV_ETH_F_MH;;
-
-                        return 1;
-                }
-            }
-            else
-            {
-                cust_flow.dscp  = 0;
-                cust_flow.dir   = MV_CUST_FLOW_DIR_US;
-
-                ret = mv_cust_untag_map_rule_get(&cust_flow);
-                /* Set GEM port, target port and queue */
-                if (ret == MV_CUST_OK) {
-                        tx_spec_out->txp     = cust_flow.pkt_frwd.trg_port;
-                        tx_spec_out->txq     = cust_flow.pkt_frwd.trg_queue;
-                        tx_spec_out->hw_cmd  = ((cust_flow.pkt_frwd.gem_port << 8)|0x0010);
-                        tx_spec_out->tx_func = NULL;
-                        tx_spec_out->flags   = MV_ETH_F_MH;;
-
-                        return 1;
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-#endif
-
-
-
-void mv_cust_print(int type)
-{
-    switch (type)
-    {
-#ifdef CONFIG_MV_CUST_IGMP_HANDLE
-        case MV_CUST_APP_TYPE_IGMP:
-            mv_cust_igmp_print();
-            break;
-#endif
-#ifdef CONFIG_MV_CUST_MLD_HANDLE
-        case MV_CUST_APP_TYPE_MLD:
-            mv_cust_mld_print();
-            break;
-#endif
-#ifdef CONFIG_MV_CUST_LPBK_DETECT_HANDLE
-        case MV_CUST_APP_TYPE_LPBK:
-            mv_cust_loopdet_print();
-            break;
-#endif
-        case MV_CUST_APP_TYPE_OAM:
-            mv_cust_eoam_print();
-            break;
-        case MV_CUST_APP_TYPE_OMCI:
-            mv_cust_omci_print();
-            break;
-        default:
-            break;
-    }
-
-    return;
-}
-EXPORT_SYMBOL(mv_cust_print);
-
-
-void mv_cust_rx_func(int port, int rxq, struct net_device *dev,
-                     struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-    uint32_t i;
-
-    if(mv_cust_debug_code)
-        printk("%s\n", __func__);
-
-    if (dev == NULL || skb == NULL || rx_desc == NULL) {
-        printk("%s: NULL Pointer dev(%p) skb(%p) rx_desc(%p)\n",
-               __func__, dev, skb, rx_desc);
-        return;
-    }
-
-    if (rx_desc->pncInfo & NETA_PNC_RX_SPECIAL)
-    {
-        if (gCustConfig[MV_CUST_APP_TYPE_OMCI].enable == MV_CUST_APP_ENABLE) {
-            if (mv_cust_omci_rx(port, dev, skb, rx_desc)) {
-                if(mv_cust_debug_code)
-                    printk("%s omci_packet\n", __func__);
-                return;
-            }
-        }
-        else{
-            if (gCustConfig[MV_CUST_APP_TYPE_OAM].enable == MV_CUST_APP_ENABLE) {
-                if (mv_cust_epon_oam_rx(port, dev, skb, rx_desc)) {
-                    if (mv_cust_debug_code)
-                        printk("%s eoam_packet\n", __func__);
-                    return;
-                }
-            }
-        }
-
-#ifdef CONFIG_MV_CUST_IGMP_HANDLE
-        if (gCustConfig[MV_CUST_APP_TYPE_IGMP].enable == MV_CUST_APP_ENABLE) {
-            if (mv_cust_igmp_rx(port, dev, skb, rx_desc)) {
-                if(mv_cust_debug_code)
-                    printk("%s igmp_packet\n", __func__);
-                return;
-            }
-        }
-#endif
-
-#ifdef CONFIG_MV_CUST_MLD_HANDLE
-        if (gCustConfig[MV_CUST_APP_TYPE_MLD].enable == MV_CUST_APP_ENABLE) {
-            if (mv_cust_mld_rx(port, dev, skb, rx_desc)) {
-                if(mv_cust_debug_code)
-                    printk("%s mld_packet\n", __func__);
-                return;
-            }
-        }
-#endif
-
-#ifdef CONFIG_MV_CUST_LPBK_DETECT_HANDLE
-        if (gCustConfig[MV_CUST_APP_TYPE_LPBK].enable == MV_CUST_APP_ENABLE) {
-            if (mv_cust_loopdet_rx(port, dev, skb, rx_desc)) {
-                if(mv_cust_debug_code)
-                    printk("%s loop_det_packet\n", __func__);
-                return;
-            }
-        }
-#endif
-
-        //MVCUST_ERR_PRINT("Special pkt arrived from port(%d), was not handled. \n", port);
-        dev_kfree_skb_any(skb);
-        if(mv_cust_debug_code) {
-            printk("Input Packet first bytes:\n");
-            for (i=0;i<24;i++) {
-                if (i%8== 0)
-                    printk("\n");
-                printk ("%02x ", *(skb->data + i));
-            }
-        }
-
-    }
-    else
-    {
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-        if (mv_cust_flow_map) {
-            if (mv_cust_flow_map_rx(port, dev, skb, rx_desc)) {
-                if(mv_cust_debug_code)
-                    printk("%s flow map\n", __func__);
-            }
-        }
-        return;
-#endif
-    }
-
-    return;
-}
-
-
-int mv_cust_tx_func(int port, struct net_device *dev, struct sk_buff *skb,
-                    struct mv_eth_tx_spec *tx_spec_out)
-{
-    if (mv_cust_omci_tx(port, dev, skb, tx_spec_out))
-        return 1;
-
-    if (mv_cust_eoam_tx(port, dev, skb, tx_spec_out))
-        return 1;
-
-#ifdef CONFIG_MV_CUST_IGMP_HANDLE
-    if (mv_cust_igmp_tx(port, dev, skb, tx_spec_out))
-        return 1;
-#endif
-
-#ifdef CONFIG_MV_CUST_MLD_HANDLE
-    if (mv_cust_mld_tx(port, dev, skb, tx_spec_out))
-        return 1;
-#endif
-
-#ifdef CONFIG_MV_CUST_LPBK_DETECT_HANDLE
-    if (mv_cust_loopdet_tx(port, dev, skb, tx_spec_out))
-        return 1;
-#endif
-
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-    if (mv_cust_flow_map_tx(port, dev, skb, tx_spec_out))
-        return 1;
-#endif
-
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-    /* Simple example for UDP Source Port or Dest Port Parsing */
-    /* Per UDP source or dest port configuration */
-    if (mv_cust_udp_port_tx(port, dev, skb, tx_spec_out))
-        return 1;
-#endif
-
-    return 0;
-}
-
-
-int mvcust_netdev_init(void)
-{
-    uint32_t port_i;
-
-    /* Retrieve num_ports, as in mv_eth_init_module*/
-    mv_eth_ports_num = mvCtrlEthMaxPortGet();
-
-    if (mv_eth_ports_num > CONFIG_MV_ETH_PORTS_NUM)
-        mv_eth_ports_num = CONFIG_MV_ETH_PORTS_NUM;
-
-    mv_cust_eoam_init();
-
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-    mv_cust_udp_table_del();
-#endif
-
-/* Initialize flow mapping data structure */
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-    mv_cust_flow_map_init();
-#endif
-
-    /* Register special receive check function */
-#ifdef CONFIG_MV_ETH_RX_SPECIAL
-    for (port_i=0;port_i< mv_eth_ports_num;port_i++) {
-        mv_eth_rx_special_proc_func(port_i, mv_cust_rx_func);
-    }
-#endif /* CONFIG_MV_ETH_RX_SPECIAL */
-
-
-    /* Register special transmit check function */
-#ifdef CONFIG_MV_ETH_TX_SPECIAL
-    for (port_i=0;port_i< mv_eth_ports_num;port_i++) {
-        mv_eth_tx_special_check_func(port_i, mv_cust_tx_func);
-    }
-#endif /* CONFIG_MV_ETH_TX_SPECIAL */
-
-    return 0;
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.h
deleted file mode 100644
index ae26a7c..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_netdev.h
+++ /dev/null
@@ -1,112 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_netdev.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_cust_netdev_h__
-#define __mv_cust_netdev_h__
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/ip.h>
-
-#include <mvCommon.h>
-#include <mvOs.h>
-#include <mv_neta/net_dev/mv_netdev.h>
-
-
-#define MV_CUST_MAS_UDP_SRC_PORT          8
-#define MV_CUST_MAS_UDP_DST_PORT          8
-#define MV_CUST_NUM_LLID                  8
-
-
-struct mv_udp_port_tx_spec {
-    __be16    udp_port;
-    struct mv_eth_tx_spec tx_spec;
-};
-
-struct mv_port_tx_spec {
-    struct mv_udp_port_tx_spec udp_src[MV_CUST_MAS_UDP_SRC_PORT];
-    struct mv_udp_port_tx_spec udp_dst[MV_CUST_MAS_UDP_DST_PORT];
-};
-
-
-struct mv_eoam_llid_spec {
-    uint8_t llid_mac_address[6];
-    struct  mv_eth_tx_spec tx_spec;
-};
-
-typedef enum
-{
-    MV_CUST_APP_TYPE_IGMP = 0, /* For IGMP application               */
-    MV_CUST_APP_TYPE_MLD,      /* For MLD application                */
-    MV_CUST_APP_TYPE_LPBK,     /* For loopback detection application */
-    MV_CUST_APP_TYPE_OAM,      /* For eOAM application               */
-    MV_CUST_APP_TYPE_OMCI,     /* For OMCI application               */
-    MV_CUST_APP_TYPE_MAX       /* Max number of application          */
-} mv_cust_app_type_e;
-
-/*  Enum: enable or disable application*/
-typedef enum
-{
-    MV_CUST_APP_DISABLE  = 0,
-    MV_CUST_APP_ENABLE   = 1,
-} mv_cust_app_flag_e;
-
-typedef struct
-{
-    mv_cust_app_type_e app_type; /* Application type, such as IGMP, MLD                */
-    uint16_t           enable;   /* Flag indicates whether to enable application Rx/Tx */
-    uint16_t           eth_type; /* Application Ethernet type used for socket/skb      */
-    char              *name;     /* The readable name of the application               */
-} mv_cust_app_config_t;
-
-
-/******************************************************
- * Function prototypes --                             *
-*******************************************************/
-void        mv_cust_omci_hw_cmd_set(unsigned int hw_cmd);
-int         mv_cust_omci_tx_set(int tcont, int txq);
-
-#ifdef  CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-MV_STATUS   mv_cust_udp_src_spec_set(int tx_port, uint16_t udp_src_port, uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd);
-MV_STATUS   mv_cust_udp_dest_spec_set(int tx_port, uint16_t udp_dest_port, uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd);
-#endif
-
-void        mv_cust_oam_rx_gh_set(int val);
-int         mv_cust_omci_set(int tcont, int txq, int gemport, int keep_rx_mh);
-int         mv_cust_eoam_llid_set(int llid, uint8_t *llid_mac, int txq);
-
-void        mv_cust_app_flag_set(mv_cust_app_type_e app_type, uint16_t enable);
-void        mv_cust_app_etype_set(mv_cust_app_type_e app_type, uint16_t eth_type);
-void        mv_cust_print(int type);
-
-
-#endif /* __mv_cust_netdev_h__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_sysfs.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_sysfs.c
deleted file mode 100644
index f632b87..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_cust/mv_cust_sysfs.c
+++ /dev/null
@@ -1,525 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_cust_sysfs.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-
-#include <gbe/mvNeta.h>
-#include <pnc/mvPnc.h>
-
-#include "mv_cust_dev.h"
-#include "mv_cust_netdev.h"
-#include "mv_cust_flow_map.h"
-#include "mv_cust_mng_if.h"
-
-static int      eoam_txq = 0;
-static uint8_t  eoam_mac[6] = {0};
-
-
-static ssize_t mv_cust_spec_proc_help(char *buf)
-{
-    int off = 0;
-    off += sprintf(buf+off, "cat  help                              - show this help\n");
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-    off += sprintf(buf+off, "cat  udp_ports                         - show special udp source and dest. port configuration\n");
-#endif
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-    off += sprintf(buf+off, "cat  flow_map                          - show flow mapping configuration\n");
-    off += sprintf(buf+off, "cat  flow_map_show                     - show flow mapping rules \n");
-    off += sprintf(buf+off, "cat  flow_map_clear                    - clear all flow mapping rules\n");
-    off += sprintf(buf+off, "cat  dscp_map_del                      - delete DSCP to P-bits mapping rules\n");
-#endif
-    off += sprintf(buf+off, "cat  tcont_show                        - Show all T-CONT state\n");
-    off += sprintf(buf+off, "echo tcont state        > tcont_set    - Set T-CONT tatus, tcont(0~7), state(1:enable, 0:disable) \n");
-    off += sprintf(buf+off, "echo hex                > debug        - Set Customized module debug information \n");
-    off += sprintf(buf+off, "echo app_type           > app_show     - Show application configuration. 0:igmp, 1:mld, 2:lpbk, 3:eoam, 4:omci\n");
-    off += sprintf(buf+off, "echo app_type enable    > app_flag_set - Enable/disable application. 0:igmp, 1:mld, 2:lpbk, 3:eoam, 4:omci, 1:enable, 0:disable\n");
-    off += sprintf(buf+off, "echo app_type hex       > app_etype_set- Set application Eth type. 0:igmp, 1:mld, 2:lpbk, 3:eoam, 4:omci\n");
-    off += sprintf(buf+off, "echo tc txq gem keep_mh > omci_set     - set udp source port special Tx behavior\n");
-    off += sprintf(buf+off, "echo keep_mh            > eoam_gh_keep - Keep or not keep GH for eOAM packets, 1:keep, 0:do not keep\n");
-    off += sprintf(buf+off, "echo txq                > eoam_txq     - set TX queue into sw_buffer for EOAM llid command\n");
-    off += sprintf(buf+off, "echo mac[0]-mac[5]      > eoam_mac     - set LLID mac into sw_buffer for EOAM llid command\n");
-    off += sprintf(buf+off, "echo llid               > eoam_write   - Write EOAM txq and mac address from sw_buffer into LLID\n");
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-    off += sprintf(buf+off, "echo p udp_src(dec) txp txq flags hw_cmd  > udp_src - set udp source port special Tx behavior\n");
-    off += sprintf(buf+off, "echo p udp_dst(dec) txp txq flags hw_cmd  > udp_dst - set udp dest.  port special Tx behavior\n");
-#endif
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-    off += sprintf(buf+off, "echo hex                                  > flow_map_debug  - Set flow mapping debug flag, 1:enable, 0:disable \n");
-    off += sprintf(buf+off, "echo vid pbits mod_vid mod_pbits trg_port trg_queue trg_hwf_queue gem_port  > flow_map_us_set - set U/S flow mapping rule\n");
-    off += sprintf(buf+off, "echo vid pbits mod_vid mod_pbits          > flow_map_ds_set - set D/S flow mapping rule\n");
-    off += sprintf(buf+off, "echo pbits0 pbits1 ... pbits62 pbits63    > dscp_map_set    - set DSCP to P-bits mapping rules\n");
-    off += sprintf(buf+off, "echo vlan pbits dir(0:U/S, 1:D/S)         > flow_map_del    - delete flow mapping rule\n");
-    off += sprintf(buf+off, "echo vlan pbits dir(0:U/S, 1:D/S)         > tag_flow_get    - get tagged flow mapping rule\n");
-    off += sprintf(buf+off, "echo dscp dir(0:U/S, 1:D/S)               > untag_flow_get  - get untagged flow mapping rule\n");
-#endif
-
-    return off;
-}
-
-
-static ssize_t mv_cust_spec_proc_show(struct device *dev,
-                                      struct device_attribute *attr, char *buf)
-{
-    int off   = 0;
-    int index = 0;
-    bool state;
-    const char* name = attr->attr.name;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    if (!strcmp(name, "help") ) {
-        off = mv_cust_spec_proc_help(buf);
-    }
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-    else if (!strcmp(name, "udp_ports")) {
-        mv_cust_udp_spec_print_all();
-    }
-#endif
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-    else if (!strcmp(name, "flow_map")) {
-        mv_cust_flow_map_print();
-    }
-    else if (!strcmp(name, "flow_map_show")) {
-        mv_cust_map_table_print();
-    }
-    else if (!strcmp(name, "flow_map_clear")) {
-        mv_cust_map_rule_clear();
-    }
-    else if (!strcmp(name, "dscp_map_del")) {
-        mv_cust_dscp_map_del();
-    }
-#endif
-    else if (!strcmp(name, "tcont_show")) {
-        printk(KERN_INFO "MV_CUST T-CONT state table\n");
-        printk(KERN_INFO "Default invalid Txq:%d \n", CPH_INVALID_TRGT_QUEUE);
-        printk(KERN_INFO "--------------------------\n");
-        for (index = 0; index < CPH_MAX_TCONT_NUM; index++)
-        {
-            state = mv_cust_get_tcont_state(index);
-            printk(KERN_INFO "T-CONT%1.1d: %s\n", index, (state==true)?"enabled":"disabled");
-        }
-    }
-    else
-        off = mv_cust_spec_proc_help(buf);
-
-    return off;
-}
-
-
-static ssize_t mv_cust_spec_proc_1_store(struct device *dev,
-                                         struct device_attribute *attr,
-                                         const char *buf, size_t len)
-{
-    const char*     name = attr->attr.name;
-    unsigned int    v;
-    unsigned long   flags;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    v = 0;
-
-    sscanf(buf, "%x", &v);
-
-    raw_local_irq_save(flags);
-
-    if (!strcmp(name, "debug")) {
-        mv_cust_debug_info_set(v);
-    }
-    else if (!strcmp(name, "app_show")) {
-        mv_cust_print(v);
-    }
-    else if (!strcmp(name, "eoam_gh_keep")) {
-        mv_cust_oam_rx_gh_set(v);
-    }
-    else if (!strcmp(name, "eoam_txq")) {
-        eoam_txq = v;
-    }
-    else if (!strcmp(name, "eoam_write")) {
-        mv_cust_eoam_llid_set((int)v, &eoam_mac[0], eoam_txq);
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-
-static ssize_t mv_cust_spec_proc_2_store(struct device *dev,
-                                         struct device_attribute *attr,
-                                         const char *buf, size_t len)
-{
-    const char*     name = attr->attr.name;
-    unsigned int    p, v;
-    unsigned long   flags;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    p = 0;
-    v = 0;
-    sscanf(buf, "%d %x", &p, &v);
-
-    raw_local_irq_save(flags);
-
-    if (!strcmp(name, "app_flag_set")) {
-        mv_cust_app_flag_set(p, v);
-    }
-    else if (!strcmp(name, "app_etype_set")) {
-        mv_cust_app_etype_set(p, v);
-    }
-    else if (!strcmp(name, "tcont_set")) {
-        if (v)
-            mv_cust_set_tcont_state(p, true);
-        else
-            mv_cust_set_tcont_state(p, false);
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-
-static ssize_t mv_cust_spec_proc_6_store(struct device *dev,
-                                         struct device_attribute *attr,
-                                         const char *buf, size_t len)
-{
-    const char*     name = attr->attr.name;
-    unsigned int    p, v1=0, v2=0, v3=0, v4=0, v5=0;
-    unsigned long   flags;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    sscanf(buf, "%d %d %x %x %x %x", &p, &v1, &v2, &v3, &v4, &v5);
-
-    raw_local_irq_save(flags);
-
-    if (!strcmp(name, "udp_src")) {
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-        mv_cust_udp_src_spec_set(p, v1, v2, v3, v4, v5);
-#else
-        printk("mv_cust module was not compiled with UDP SAMPLE Config Support\n");
-#endif
-    }
-    else if (!strcmp(name, "udp_dst")) {
-#ifdef CONFIG_MV_CUST_UDP_SAMPLE_HANDLE
-        mv_cust_udp_dest_spec_set(p, v1, v2, v3, v4, v5);
-#else
-        printk("mv_cust module was not compiled with UDP SAMPLE Config Support\n");
-#endif
-    }
-    else if (!strcmp(name, "omci_set")) {
-        mv_cust_omci_set(p, v1, v2, v3);
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-static ssize_t mv_cust_spec_proc_flow_store(struct device *dev,
-                                            struct device_attribute *attr,
-                                            const char *buf, size_t len)
-{
-    const char*        name = attr->attr.name;
-    unsigned int       v1=0, v2=0, v3=0, v4=0, v5=0, v6=0, v7=0, v8=0;
-    unsigned long      flags;
-    mv_cust_ioctl_flow_map_t cust_flow;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    sscanf(buf, "%d %d %d %d %d %d %d %d", &v1, &v2, &v3, &v4, &v5, &v6, &v7, &v8);
-
-    raw_local_irq_save(flags);
-
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-
-    if (!strcmp(name, "flow_map_debug")) {
-        mv_cust_set_trace_flag((uint32_t)v1);
-    }
-    else if (!strcmp(name, "flow_map_us_set")) {
-        memset(&cust_flow, 0, sizeof(cust_flow));
-        cust_flow.dir       = MV_CUST_FLOW_DIR_US;
-        cust_flow.vid       = v1;
-        cust_flow.pbits     = v2;
-        cust_flow.mod_vid   = v3;
-        cust_flow.mod_pbits = v4;
-
-        cust_flow.pkt_frwd.in_use        = 1;
-        cust_flow.pkt_frwd.trg_port      = (mv_cust_trg_port_type_t)v5;
-        cust_flow.pkt_frwd.trg_queue     = (uint32_t)v6;
-        cust_flow.pkt_frwd.trg_hwf_queue = (uint32_t)v7;
-        cust_flow.pkt_frwd.gem_port      = (mv_cust_gem_port_key_t)v8;
-
-        mv_cust_map_rule_set(&cust_flow);
-    }
-    else if (!strcmp(name, "flow_map_ds_set")) {
-        memset(&cust_flow, 0, sizeof(cust_flow));
-        cust_flow.dir       = MV_CUST_FLOW_DIR_DS;
-        cust_flow.vid       = v1;
-        cust_flow.pbits     = v2;
-        cust_flow.mod_vid   = v3;
-        cust_flow.mod_pbits = v4;
-        cust_flow.pkt_frwd.in_use    = 1;
-
-        mv_cust_map_rule_set(&cust_flow);
-    }
-    else if (!strcmp(name, "flow_map_del")) {
-        mv_cust_map_rule_del((uint16_t)v1, (uint8_t)v2, (mv_cust_flow_dir_e)v3);
-    }
-    else if (!strcmp(name, "tag_flow_get")) {
-        memset(&cust_flow, 0, sizeof(cust_flow));
-        cust_flow.vid   = v1;
-        cust_flow.pbits = v2;
-        cust_flow.dir   = (mv_cust_flow_dir_e)v3;
-        mv_cust_tag_map_rule_get(&cust_flow);
-        printk("in_use[%d], mod_vid[%d] mod_pbits[%d] trg_port[%d], trg_queue[%d], gem_port[%d]\r\n",
-                cust_flow.pkt_frwd.in_use, cust_flow.mod_vid,
-                cust_flow.mod_pbits, cust_flow.pkt_frwd.trg_port,
-                cust_flow.pkt_frwd.trg_queue, cust_flow.pkt_frwd.gem_port);
-    }
-    else if (!strcmp(name, "untag_flow_get")) {
-        memset(&cust_flow, 0, sizeof(cust_flow));
-        cust_flow.dscp  =  v1;
-        cust_flow.dir   = (mv_cust_flow_dir_e)v2;
-        mv_cust_untag_map_rule_get(&cust_flow);
-        printk("in_use[%d], mod_vid[%d] mod_pbits[%d] trg_port[%d], trg_queue[%d], gem_port[%d]\r\n",
-                cust_flow.pkt_frwd.in_use, cust_flow.mod_vid,
-                cust_flow.mod_pbits, cust_flow.pkt_frwd.trg_port,
-                cust_flow.pkt_frwd.trg_queue, cust_flow.pkt_frwd.gem_port);
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-#endif
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-static ssize_t mv_cust_spec_proc_6h_store(struct device *dev,
-                                          struct device_attribute *attr,
-                                          const char *buf, size_t len)
-{
-    const char*     name = attr->attr.name;
-    unsigned int    v1=0, v2=0, v3=0, v4=0, v5=0, v6=0;
-    unsigned long   flags;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    sscanf(buf, "%x %x %x %x %x %x", &v1, &v2, &v3, &v4, &v5, &v6);
-
-    raw_local_irq_save(flags);
-
-    if (!strcmp(name, "eoam_mac")) {
-        eoam_mac[0] = (uint8_t)v1;
-        eoam_mac[1] = (uint8_t)v2;
-        eoam_mac[2] = (uint8_t)v3;
-        eoam_mac[3] = (uint8_t)v4;
-        eoam_mac[4] = (uint8_t)v5;
-        eoam_mac[5] = (uint8_t)v6;
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-static ssize_t mv_cust_spec_proc_64_store(struct device *dev,
-                                          struct device_attribute *attr,
-                                          const char *buf, size_t len)
-{
-    const char*          name = attr->attr.name;
-    unsigned int         v[64];
-    unsigned int         index = 0;
-    unsigned long        flags;
-    mv_cust_dscp_pbits_t dscp_map;
-
-    if (!capable(CAP_NET_ADMIN))
-        return -EPERM;
-
-    /* Read input */
-    for (index=0; index<64; index++) {
-        sscanf(buf, "%d", &v[index]);
-        dscp_map.pbits[index] = (uint8_t)v[index];
-    }
-    dscp_map.in_use = 1;
-
-    raw_local_irq_save(flags);
-
-    if (!strcmp(name, "dscp_map_set")) {
-#ifdef CONFIG_MV_CUST_FLOW_MAP_HANDLE
-        mv_cust_dscp_map_set(&dscp_map);
-#endif
-    }
-    else
-        printk("%s: illegal operation <%s>\n", __FUNCTION__, attr->attr.name);
-
-    raw_local_irq_restore(flags);
-
-    return len;
-}
-
-static DEVICE_ATTR(help,           S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(debug,          S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_1_store);
-
-static DEVICE_ATTR(omci_set,       S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_6_store);
-static DEVICE_ATTR(eoam_gh_keep,   S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_1_store);
-static DEVICE_ATTR(eoam_txq,       S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_1_store);
-static DEVICE_ATTR(eoam_mac,       S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_6h_store);
-static DEVICE_ATTR(eoam_write,     S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_1_store);
-
-static DEVICE_ATTR(tcont_show,     S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(tcont_set,      S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_2_store);
-
-static DEVICE_ATTR(app_show,       S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_1_store);
-static DEVICE_ATTR(app_flag_set,   S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_2_store);
-static DEVICE_ATTR(app_etype_set,  S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_2_store);
-
-static DEVICE_ATTR(udp_ports,      S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(udp_src,        S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_6_store);
-static DEVICE_ATTR(udp_dst,        S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_6_store);
-
-static DEVICE_ATTR(flow_map,       S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(flow_map_show,  S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(flow_map_clear, S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(dscp_map_del,   S_IRUSR, mv_cust_spec_proc_show, NULL);
-static DEVICE_ATTR(flow_map_debug, S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(flow_map_us_set,S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(flow_map_ds_set,S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(flow_map_del,   S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(tag_flow_get,   S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(untag_flow_get, S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_flow_store);
-static DEVICE_ATTR(dscp_map_set,   S_IWUSR, mv_cust_spec_proc_show, mv_cust_spec_proc_64_store);
-
-
-static struct attribute *mv_cust_spec_proc_attrs[] = {
-    &dev_attr_help.attr,
-    &dev_attr_debug.attr,
-    &dev_attr_omci_set.attr,
-    &dev_attr_eoam_gh_keep.attr,
-    &dev_attr_eoam_txq.attr,
-    &dev_attr_eoam_mac.attr,
-    &dev_attr_eoam_write.attr,
-    &dev_attr_tcont_show.attr,
-    &dev_attr_tcont_set.attr,
-    &dev_attr_app_show.attr,
-    &dev_attr_app_flag_set.attr,
-    &dev_attr_app_etype_set.attr,
-    &dev_attr_udp_ports.attr,
-    &dev_attr_udp_src.attr,
-    &dev_attr_udp_dst.attr,
-    &dev_attr_flow_map_debug.attr,
-    &dev_attr_flow_map_us_set.attr,
-    &dev_attr_flow_map_ds_set.attr,
-    &dev_attr_dscp_map_set.attr,
-    &dev_attr_flow_map_del.attr,
-    &dev_attr_tag_flow_get.attr,
-    &dev_attr_untag_flow_get.attr,
-    &dev_attr_flow_map.attr,
-    &dev_attr_flow_map_show.attr,
-    &dev_attr_flow_map_clear.attr,
-    &dev_attr_dscp_map_del.attr,
-
-    NULL
-};
-
-static struct attribute_group mv_cust_spec_proc_group = {
-    .name = "proto",
-    .attrs = mv_cust_spec_proc_attrs,
-};
-
-int mvcust_sysfs_init(void)
-{
-    int err;
-    struct device *pd;
-
-    pd = bus_find_device_by_name(&platform_bus_type, NULL, "cust");
-    if (!pd) {
-        platform_device_register_simple("cust", -1, NULL, 0);
-        pd = bus_find_device_by_name(&platform_bus_type, NULL, "cust");
-    }
-
-    if (!pd) {
-        printk(KERN_ERR"%s: cannot find cust device\n", __FUNCTION__);
-        pd = &platform_bus;
-    }
-
-    err = sysfs_create_group(&pd->kobj, &mv_cust_spec_proc_group);
-    if (err) {
-        printk(KERN_INFO "sysfs group failed %d\n", err);
-        goto out;
-    }
-
-    printk(KERN_INFO "= CUST Module SYS FS Init ended successfully =\n");
-    out:
-    return err;
-}
-
-void mvcust_sysfs_delete(void)
-{
-    struct device *pd;
-
-    pd = bus_find_device_by_name(&platform_bus_type, NULL, "cust");
-    if (!pd)
-    {
-        printk(KERN_ERR"%s: cannot find CUST device\n", __FUNCTION__);
-        return;
-    }
-
-    sysfs_remove_group(&pd->kobj, &mv_cust_spec_proc_group);
-
-    printk(KERN_INFO "= CUST Module SYS FS Remove ended successfully =\n");
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/Makefile b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/Makefile
deleted file mode 100644
index 6f23779..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# Makefile for the Marvell EZXML driver
-#
-
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifdef CONFIG_MV_HAL_RULES_PATH
-include $(srctree)/include/config/auto.conf
-include $(srctree)/$(subst ",,$(CONFIG_MV_HAL_RULES_PATH))
-endif
-
-obj-y += ezxml.o
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.c
deleted file mode 100644
index 86fb7ce..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.c
+++ /dev/null
@@ -1,1184 +0,0 @@
-/* ezxml.c
- *
- * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/*#include <stdlib.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <string.h>
-#include <ctype.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-*/
-#include "../../linux_oss/mvOs.h"
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/version.h>
-#include <linux/string.h>
-#include <linux/time.h>
-#include <linux/ctype.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/byteorder/generic.h>
-#include <asm/unaligned.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include "linux/fs.h"
-#include "asm/uaccess.h"
-
-#include "ezxml.h"
-
-void* ezxml_realloc(void *p, size_t new_size);
-
-#define malloc(SIZE) kmalloc((SIZE), GFP_KERNEL)
-#define realloc(PTR, SIZE) ezxml_realloc((PTR), (SIZE))
-#define free kfree
-#define stat kstat
-
-
-#define EZXML_WS   "\t\r\n "  // whitespace
-#define EZXML_ERRL 128        // maximum error string length
-
-typedef struct ezxml_root *ezxml_root_t;
-struct ezxml_root {       // additional data for the root tag
-    struct ezxml xml;     // is a super-struct built on top of ezxml struct
-    ezxml_t cur;          // current xml tree insertion point
-    char *m;              // original xml string
-    size_t len;           // length of allocated memory for mmap, -1 for malloc
-    char *u;              // UTF-8 conversion of string if original was UTF-16
-    char *s;              // start of work area
-    char *e;              // end of work area
-    char **ent;           // general entities (ampersand sequences)
-    char ***attr;         // default attributes
-    char ***pi;           // processing instructions
-    short standalone;     // non-zero if <?xml standalone="yes"?>
-    char err[EZXML_ERRL]; // error string
-};
-
-char *EZXML_NIL[] = { NULL }; // empty, null terminated array of strings
-
-char *strdup(const char  *pString)
-{
-    char  *pMemory = NULL;
-    size_t size = 0;
-
-    if( !pString )
-        return(NULL);
-
-    size = strlen(pString) + 1;
-
-    if( (pMemory = malloc(size)) )
-    {
-        strcpy(pMemory, pString);
-        return pMemory;
-    }
-
-    return NULL;
-}
-
-// returns the first child tag with the given name or NULL if not found
-ezxml_t ezxml_child(ezxml_t xml, const char *name)
-{
-    xml = (xml) ? xml->child : NULL;
-    while (xml && strcmp(name, xml->name)) xml = xml->sibling;
-    return xml;
-}
-
-// returns the Nth tag with the same name in the same subsection or NULL if not
-// found
-ezxml_t ezxml_idx(ezxml_t xml, int idx)
-{
-    for (; xml && idx; idx--) xml = xml->next;
-    return xml;
-}
-
-// returns the value of the requested tag attribute or NULL if not found
-const char *ezxml_attr(ezxml_t xml, const char *attr)
-{
-    int i = 0, j = 1;
-    ezxml_root_t root = (ezxml_root_t)xml;
-
-    if (! xml || ! xml->attr) return NULL;
-    while (xml->attr[i] && strcmp(attr, xml->attr[i])) i += 2;
-    if (xml->attr[i]) return xml->attr[i + 1]; // found attribute
-
-    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
-    for (i = 0; root->attr[i] && strcmp(xml->name, root->attr[i][0]); i++);
-    if (! root->attr[i]) return NULL; // no matching default attributes
-    while (root->attr[i][j] && strcmp(attr, root->attr[i][j])) j += 3;
-    return (root->attr[i][j]) ? root->attr[i][j + 1] : NULL; // found default
-}
-
-// same as ezxml_get but takes an already initialized va_list
-ezxml_t ezxml_vget(ezxml_t xml, va_list ap)
-{
-    char *name = va_arg(ap, char *);
-    int idx = -1;
-
-    if (name && *name) {
-        idx = va_arg(ap, int);
-        xml = ezxml_child(xml, name);
-    }
-    return (idx < 0)? xml : ezxml_vget(ezxml_idx(xml, idx), ap);
-}
-
-// Traverses the xml tree to retrieve a specific subtag. Takes a variable
-// length list of tag names and indexes. The argument list must be terminated
-// by either an index of -1 or an empty string tag name. Example:
-// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
-// This retrieves the title of the 3rd book on the 1st shelf of library.
-// Returns NULL if not found.
-ezxml_t ezxml_get(ezxml_t xml, ...)
-{
-    va_list ap;
-    ezxml_t r;
-
-
-    va_start(ap, xml);
-    r = ezxml_vget(xml, ap);
-    va_end(ap);
-    return r;
-}
-
-// returns a null terminated array of processing instructions for the given
-// target
-const char **ezxml_pi(ezxml_t xml, const char *target)
-{
-    ezxml_root_t root = (ezxml_root_t)xml;
-    int i = 0;
-
-    if (! root) return (const char **)EZXML_NIL;
-    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
-    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
-    return (const char **)((root->pi[i]) ? root->pi[i] + 1 : EZXML_NIL);
-}
-
-// set an error string and return root
-ezxml_t ezxml_err(ezxml_root_t root, char *s, const char *err, ...)
-{
-    va_list ap;
-    int line = 1;
-    char *t, fmt[EZXML_ERRL];
-
-    for (t = root->s; t < s; t++) if (*t == '\n') line++;
-    snprintf(fmt, EZXML_ERRL, "[error near line %d]: %s", line, err);
-
-    va_start(ap, err);
-    vsnprintf(root->err, EZXML_ERRL, fmt, ap);
-    va_end(ap);
-
-    return &root->xml;
-}
-
-// Recursively decodes entity and character references and normalizes new lines
-// ent is a null terminated array of alternating entity names and values. set t
-// to '&' for general entity decoding, '%' for parameter entity decoding, 'c'
-// for cdata sections, ' ' for attribute normalization, or '*' for non-cdata
-// attribute normalization. Returns s, or if the decoded string is longer than
-// s, returns a malloced string that must be freed.
-char *ezxml_decode(char *s, char **ent, char t)
-{
-    char *e, *r = s, *m = s;
-    long b, c, d, l;
-
-    for (; *s; s++) { // normalize line endings
-        while (*s == '\r') {
-            *(s++) = '\n';
-            if (*s == '\n') memmove(s, (s + 1), strlen(s));
-        }
-    }
-
-    for (s = r; ; ) {
-        while (*s && *s != '&' && (*s != '%' || t != '%') && !isspace(*s)) s++;
-
-        if (! *s) break;
-        else if (t != 'c' && ! strncmp(s, "&#", 2)) { // character reference
-            if (s[2] == 'x') c = strtol(s + 3, &e, 16); // base 16
-            else c = strtol(s + 2, &e, 10); // base 10
-            if (! c || *e != ';') { s++; continue; } // not a character ref
-
-            if (c < 0x80) *(s++) = c; // US-ASCII subset
-            else { // multi-byte UTF-8 sequence
-                for (b = 0, d = c; d; d /= 2) b++; // number of bits in c
-                b = (b - 2) / 5; // number of bytes in payload
-                *(s++) = (0xFF << (7 - b)) | (c >> (6 * b)); // head
-                while (b) *(s++) = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
-            }
-
-            memmove(s, strchr(s, ';') + 1, strlen(strchr(s, ';')));
-        }
-        else if ((*s == '&' && (t == '&' || t == ' ' || t == '*')) ||
-                 (*s == '%' && t == '%')) { // entity reference
-            for (b = 0; ent[b] && strncmp(s + 1, ent[b], strlen(ent[b]));
-                 b += 2); // find entity in entity list
-
-            if (ent[b++]) { // found a match
-                if ((c = strlen(ent[b])) - 1 > (e = strchr(s, ';')) - s) {
-                    l = (d = (s - r)) + c + strlen(e); // new length
-                    r = (r == m) ? strcpy(malloc(l), r) : realloc(r, l);
-                    e = strchr((s = r + d), ';'); // fix up pointers
-                }
-
-                memmove(s + c, e + 1, strlen(e)); // shift rest of string
-                strncpy(s, ent[b], c); // copy in replacement text
-            }
-            else s++; // not a known entity
-        }
-        else if ((t == ' ' || t == '*') && isspace(*s)) *(s++) = ' ';
-        else s++; // no decoding needed
-    }
-
-    if (t == '*') { // normalize spaces for non-cdata attributes
-        for (s = r; *s; s++) {
-            if ((l = strspn(s, " "))) memmove(s, s + l, strlen(s + l) + 1);
-            while (*s && *s != ' ') s++;
-        }
-        if (--s >= r && *s == ' ') *s = '\0'; // trim any trailing space
-    }
-    return r;
-}
-
-// called when parser finds start of new tag
-void ezxml_open_tag(ezxml_root_t root, char *name, char **attr)
-{
-    ezxml_t xml = root->cur;
-
-    if (xml->name) xml = ezxml_add_child(xml, name, strlen(xml->txt));
-    else xml->name = name; // first open tag
-
-    xml->attr = attr;
-    root->cur = xml; // update tag insertion point
-}
-
-// called when parser finds character content between open and closing tag
-void ezxml_char_content(ezxml_root_t root, char *s, size_t len, char t)
-{
-    ezxml_t xml = root->cur;
-    char *m = s;
-    size_t l;
-
-    if (! xml || ! xml->name || ! len) return; // sanity check
-
-    s[len] = '\0'; // null terminate text (calling functions anticipate this)
-    len = strlen(s = ezxml_decode(s, root->ent, t)) + 1;
-
-    if (! *(xml->txt)) xml->txt = s; // initial character content
-    else { // allocate our own memory and make a copy
-        xml->txt = (xml->flags & EZXML_TXTM) // allocate some space
-                   ? realloc(xml->txt, (l = strlen(xml->txt)) + len)
-                   : strcpy(malloc((l = strlen(xml->txt)) + len), xml->txt);
-        strcpy(xml->txt + l, s); // add new char content
-        if (s != m) free(s); // free s if it was malloced by ezxml_decode()
-    }
-
-    if (xml->txt != m) ezxml_set_flag(xml, EZXML_TXTM);
-}
-
-// called when parser finds closing tag
-ezxml_t ezxml_close_tag(ezxml_root_t root, char *name, char *s)
-{
-    if (! root->cur || ! root->cur->name || strcmp(name, root->cur->name))
-        return ezxml_err(root, s, "unexpected closing tag </%s>", name);
-
-    root->cur = root->cur->parent;
-    return NULL;
-}
-
-// checks for circular entity references, returns non-zero if no circular
-// references are found, zero otherwise
-int ezxml_ent_ok(char *name, char *s, char **ent)
-{
-    int i;
-
-    for (; ; s++) {
-        while (*s && *s != '&') s++; // find next entity reference
-        if (! *s) return 1;
-        if (! strncmp(s + 1, name, strlen(name))) return 0; // circular ref.
-        for (i = 0; ent[i] && strncmp(ent[i], s + 1, strlen(ent[i])); i += 2);
-        if (ent[i] && ! ezxml_ent_ok(name, ent[i + 1], ent)) return 0;
-    }
-}
-
-// called when the parser finds a processing instruction
-void ezxml_proc_inst(ezxml_root_t root, char *s, size_t len)
-{
-    int i = 0, j = 1;
-    char *target = s;
-
-    s[len] = '\0'; // null terminate instruction
-    if (*(s += strcspn(s, EZXML_WS))) {
-        *s = '\0'; // null terminate target
-        s += strspn(s + 1, EZXML_WS) + 1; // skip whitespace after target
-    }
-
-    if (! strcmp(target, "xml")) { // <?xml ... ?>
-        if ((s = strstr(s, "standalone")) && ! strncmp(s + strspn(s + 10,
-            EZXML_WS "='\"") + 10, "yes", 3)) root->standalone = 1;
-        return;
-    }
-
-    if (! root->pi[0]) *(root->pi = malloc(sizeof(char **))) = NULL; //first pi
-
-    while (root->pi[i] && strcmp(target, root->pi[i][0])) i++; // find target
-    if (! root->pi[i]) { // new target
-        root->pi = realloc(root->pi, sizeof(char **) * (i + 2));
-        root->pi[i] = malloc(sizeof(char *) * 3);
-        root->pi[i][0] = target;
-        root->pi[i][1] = (char *)(root->pi[i + 1] = NULL); // terminate pi list
-        root->pi[i][2] = strdup(""); // empty document position list
-    }
-
-    while (root->pi[i][j]) j++; // find end of instruction list for this target
-    root->pi[i] = realloc(root->pi[i], sizeof(char *) * (j + 3));
-    root->pi[i][j + 2] = realloc(root->pi[i][j + 1], j + 1);
-    strcpy(root->pi[i][j + 2] + j - 1, (root->xml.name) ? ">" : "<");
-    root->pi[i][j + 1] = NULL; // null terminate pi list for this target
-    root->pi[i][j] = s; // set instruction
-}
-
-// called when the parser finds an internal doctype subset
-short ezxml_internal_dtd(ezxml_root_t root, char *s, size_t len)
-{
-    char q, *c, *t, *n = NULL, *v, **ent, **pe;
-    int i, j;
-
-    pe = memcpy(malloc(sizeof(EZXML_NIL)), EZXML_NIL, sizeof(EZXML_NIL));
-
-    for (s[len] = '\0'; s; ) {
-        while (*s && *s != '<' && *s != '%') s++; // find next declaration
-
-        if (! *s) break;
-        else if (! strncmp(s, "<!ENTITY", 8)) { // parse entity definitions
-            c = s += strspn(s + 8, EZXML_WS) + 8; // skip white space separator
-            n = s + strspn(s, EZXML_WS "%"); // find name
-            *(s = n + strcspn(n, EZXML_WS)) = ';'; // append ; to name
-
-            v = s + strspn(s + 1, EZXML_WS) + 1; // find value
-            if ((q = *(v++)) != '"' && q != '\'') { // skip externals
-                s = strchr(s, '>');
-                continue;
-            }
-
-            for (i = 0, ent = (*c == '%') ? pe : root->ent; ent[i]; i++);
-            ent = realloc(ent, (i + 3) * sizeof(char *)); // space for next ent
-            if (*c == '%') pe = ent;
-            else root->ent = ent;
-
-            *(++s) = '\0'; // null terminate name
-            if ((s = strchr(v, q))) *(s++) = '\0'; // null terminate value
-            ent[i + 1] = ezxml_decode(v, pe, '%'); // set value
-            ent[i + 2] = NULL; // null terminate entity list
-            if (! ezxml_ent_ok(n, ent[i + 1], ent)) { // circular reference
-                if (ent[i + 1] != v) free(ent[i + 1]);
-                ezxml_err(root, v, "circular entity declaration &%s", n);
-                break;
-            }
-            else ent[i] = n; // set entity name
-        }
-        else if (! strncmp(s, "<!ATTLIST", 9)) { // parse default attributes
-            t = s + strspn(s + 9, EZXML_WS) + 9; // skip whitespace separator
-            if (! *t) { ezxml_err(root, t, "unclosed <!ATTLIST"); break; }
-            if (*(s = t + strcspn(t, EZXML_WS ">")) == '>') continue;
-            else *s = '\0'; // null terminate tag name
-            for (i = 0; root->attr[i] && strcmp(n, root->attr[i][0]); i++);
-
-            while (*(n = ++s + strspn(s, EZXML_WS)) && *n != '>') {
-                if (*(s = n + strcspn(n, EZXML_WS))) *s = '\0'; // attr name
-                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
-
-                s += strspn(s + 1, EZXML_WS) + 1; // find next token
-                c = (strncmp(s, "CDATA", 5)) ? "*" : " "; // is it cdata?
-                if (! strncmp(s, "NOTATION", 8))
-                    s += strspn(s + 8, EZXML_WS) + 8;
-                s = (*s == '(') ? strchr(s, ')') : s + strcspn(s, EZXML_WS);
-                if (! s) { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
-
-                s += strspn(s, EZXML_WS ")"); // skip white space separator
-                if (! strncmp(s, "#FIXED", 6))
-                    s += strspn(s + 6, EZXML_WS) + 6;
-                if (*s == '#') { // no default value
-                    s += strcspn(s, EZXML_WS ">") - 1;
-                    if (*c == ' ') continue; // cdata is default, nothing to do
-                    v = NULL;
-                }
-                else if ((*s == '"' || *s == '\'')  &&  // default value
-                         (s = strchr(v = s + 1, *s))) *s = '\0';
-                else { ezxml_err(root, t, "malformed <!ATTLIST"); break; }
-
-                if (! root->attr[i]) { // new tag name
-                    root->attr = (! i) ? malloc(2 * sizeof(char **))
-                                       : realloc(root->attr,
-                                                 (i + 2) * sizeof(char **));
-                    root->attr[i] = malloc(2 * sizeof(char *));
-                    root->attr[i][0] = t; // set tag name
-                    root->attr[i][1] = (char *)(root->attr[i + 1] = NULL);
-                }
-
-                for (j = 1; root->attr[i][j]; j += 3); // find end of list
-                root->attr[i] = realloc(root->attr[i],
-                                        (j + 4) * sizeof(char *));
-
-                root->attr[i][j + 3] = NULL; // null terminate list
-                root->attr[i][j + 2] = c; // is it cdata?
-                root->attr[i][j + 1] = (v) ? ezxml_decode(v, root->ent, *c)
-                                           : NULL;
-                root->attr[i][j] = n; // attribute name
-            }
-        }
-        else if (! strncmp(s, "<!--", 4)) s = strstr(s + 4, "-->"); // comments
-        else if (! strncmp(s, "<?", 2)) { // processing instructions
-            if ((s = strstr(c = s + 2, "?>")))
-                ezxml_proc_inst(root, c, s++ - c);
-        }
-        else if (*s == '<') s = strchr(s, '>'); // skip other declarations
-        else if (*(s++) == '%' && ! root->standalone) break;
-    }
-
-    free(pe);
-    return ! *root->err;
-}
-
-// Converts a UTF-16 string to UTF-8. Returns a new string that must be freed
-// or NULL if no conversion was needed.
-char *ezxml_str2utf8(char **s, size_t *len)
-{
-    char *u;
-    size_t l = 0, sl, max = *len;
-    long c, d;
-    int b, be = (**s == '\xFE') ? 1 : (**s == '\xFF') ? 0 : -1;
-
-    if (be == -1) return NULL; // not UTF-16
-
-    u = malloc(max);
-    for (sl = 2; sl < *len - 1; sl += 2) {
-        c = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)  //UTF-16BE
-                 : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF); //UTF-16LE
-        if (c >= 0xD800 && c <= 0xDFFF && (sl += 2) < *len - 1) { // high-half
-            d = (be) ? (((*s)[sl] & 0xFF) << 8) | ((*s)[sl + 1] & 0xFF)
-                     : (((*s)[sl + 1] & 0xFF) << 8) | ((*s)[sl] & 0xFF);
-            c = (((c & 0x3FF) << 10) | (d & 0x3FF)) + 0x10000;
-        }
-
-        while (l + 6 > max) u = realloc(u, max += EZXML_BUFSIZE);
-        if (c < 0x80) u[l++] = c; // US-ASCII subset
-        else { // multi-byte UTF-8 sequence
-            for (b = 0, d = c; d; d /= 2) b++; // bits in c
-            b = (b - 2) / 5; // bytes in payload
-            u[l++] = (0xFF << (7 - b)) | (c >> (6 * b)); // head
-            while (b) u[l++] = 0x80 | ((c >> (6 * --b)) & 0x3F); // payload
-        }
-    }
-    return *s = realloc(u, *len = l);
-}
-
-// frees a tag attribute list
-void ezxml_free_attr(char **attr) {
-    int i = 0;
-    char *m;
-
-    if (! attr || attr == EZXML_NIL) return; // nothing to free
-    while (attr[i]) i += 2; // find end of attribute list
-    m = attr[i + 1]; // list of which names and values are malloced
-    for (i = 0; m[i]; i++) {
-        if (m[i] & EZXML_NAMEM) free(attr[i * 2]);
-        if (m[i] & EZXML_TXTM) free(attr[(i * 2) + 1]);
-    }
-    free(m);
-    free(attr);
-}
-
-// parse the given xml string and return an ezxml structure
-ezxml_t ezxml_parse_str(char *s, size_t len)
-{
-    ezxml_root_t root = (ezxml_root_t)ezxml_new(NULL);
-    char q, e, *d, **attr, **a = NULL; // initialize a to avoid compile warning
-    int l, i, j;
-
-    root->m = s;
-    if (! len) return ezxml_err(root, NULL, "root tag missing");
-    root->u = ezxml_str2utf8(&s, &len); // convert utf-16 to utf-8
-    root->e = (root->s = s) + len; // record start and end of work area
-
-    e = s[len - 1]; // save end char
-    s[len - 1] = '\0'; // turn end char into null terminator
-
-    while (*s && *s != '<') s++; // find first tag
-    if (! *s) return ezxml_err(root, s, "root tag missing");
-
-    for (; ; ) {
-        attr = (char **)EZXML_NIL;
-        d = ++s;
-
-        if (isalpha(*s) || *s == '_' || *s == ':' || *s < '\0') { // new tag
-            if (! root->cur)
-                return ezxml_err(root, d, "markup outside of root element");
-
-            s += strcspn(s, EZXML_WS "/>");
-            while (isspace(*s)) *(s++) = '\0'; // null terminate tag name
-
-            if (*s && *s != '/' && *s != '>') // find tag in default attr list
-                for (i = 0; (a = root->attr[i]) && strcmp(a[0], d); i++);
-
-            for (l = 0; *s && *s != '/' && *s != '>'; l += 2) { // new attrib
-                attr = (l) ? realloc(attr, (l + 4) * sizeof(char *))
-                           : malloc(4 * sizeof(char *)); // allocate space
-                attr[l + 3] = (l) ? realloc(attr[l + 1], (l / 2) + 2)
-                                  : malloc(2); // mem for list of maloced vals
-                strcpy(attr[l + 3] + (l / 2), " "); // value is not malloced
-                attr[l + 2] = NULL; // null terminate list
-                attr[l + 1] = ""; // temporary attribute value
-                attr[l] = s; // set attribute name
-
-                s += strcspn(s, EZXML_WS "=/>");
-                if (*s == '=' || isspace(*s)) {
-                    *(s++) = '\0'; // null terminate tag attribute name
-                    q = *(s += strspn(s, EZXML_WS "="));
-                    if (q == '"' || q == '\'') { // attribute value
-                        attr[l + 1] = ++s;
-                        while (*s && *s != q) s++;
-                        if (*s) *(s++) = '\0'; // null terminate attribute val
-                        else {
-                            ezxml_free_attr(attr);
-                            return ezxml_err(root, d, "missing %c", q);
-                        }
-
-                        for (j = 1; a && a[j] && strcmp(a[j], attr[l]); j +=3);
-                        attr[l + 1] = ezxml_decode(attr[l + 1], root->ent, (a
-                                                   && a[j]) ? *a[j + 2] : ' ');
-                        if (attr[l + 1] < d || attr[l + 1] > s)
-                            attr[l + 3][l / 2] = EZXML_TXTM; // value malloced
-                    }
-                }
-                while (isspace(*s)) s++;
-            }
-
-            if (*s == '/') { // self closing tag
-                *(s++) = '\0';
-                if ((*s && *s != '>') || (! *s && e != '>')) {
-                    if (l) ezxml_free_attr(attr);
-                    return ezxml_err(root, d, "missing >");
-                }
-                ezxml_open_tag(root, d, attr);
-                ezxml_close_tag(root, d, s);
-            }
-            else if ((q = *s) == '>' || (! *s && e == '>')) { // open tag
-                *s = '\0'; // temporarily null terminate tag name
-                ezxml_open_tag(root, d, attr);
-                *s = q;
-            }
-            else {
-                if (l) ezxml_free_attr(attr);
-                return ezxml_err(root, d, "missing >");
-            }
-        }
-        else if (*s == '/') { // close tag
-            s += strcspn(d = s + 1, EZXML_WS ">") + 1;
-            if (! (q = *s) && e != '>') return ezxml_err(root, d, "missing >");
-            *s = '\0'; // temporarily null terminate tag name
-            if (ezxml_close_tag(root, d, s)) return &root->xml;
-            if (isspace(*s = q)) s += strspn(s, EZXML_WS);
-        }
-        else if (! strncmp(s, "!--", 3)) { // xml comment
-            if (! (s = strstr(s + 3, "--")) || (*(s += 2) != '>' && *s) ||
-                (! *s && e != '>')) return ezxml_err(root, d, "unclosed <!--");
-        }
-        else if (! strncmp(s, "![CDATA[", 8)) { // cdata
-            if ((s = strstr(s, "]]>")))
-                ezxml_char_content(root, d + 8, (s += 2) - d - 10, 'c');
-            else return ezxml_err(root, d, "unclosed <![CDATA[");
-        }
-        else if (! strncmp(s, "!DOCTYPE", 8)) { // dtd
-            for (l = 0; *s && ((! l && *s != '>') || (l && (*s != ']' ||
-                 *(s + strspn(s + 1, EZXML_WS) + 1) != '>')));
-                 l = (*s == '[') ? 1 : l) s += strcspn(s + 1, "[]>") + 1;
-            if (! *s && e != '>')
-                return ezxml_err(root, d, "unclosed <!DOCTYPE");
-            d = (l) ? strchr(d, '[') + 1 : d;
-            if (l && ! ezxml_internal_dtd(root, d, s++ - d)) return &root->xml;
-        }
-        else if (*s == '?') { // <?...?> processing instructions
-            do { s = strchr(s, '?'); } while (s && *(++s) && *s != '>');
-            if (! s || (! *s && e != '>'))
-                return ezxml_err(root, d, "unclosed <?");
-            else ezxml_proc_inst(root, d + 1, s - d - 2);
-        }
-        else return ezxml_err(root, d, "unexpected <");
-
-        if (! s || ! *s) break;
-        *s = '\0';
-        d = ++s;
-        if (*s && *s != '<') { // tag character content
-            while (*s && *s != '<') s++;
-            if (*s) ezxml_char_content(root, d, s - d, '&');
-            else break;
-        }
-        else if (! *s) break;
-    }
-
-    if (! root->cur) return &root->xml;
-    else if (! root->cur->name) return ezxml_err(root, d, "root tag missing");
-    else return ezxml_err(root, d, "unclosed tag <%s>", root->cur->name);
-}
-
-// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
-// stream into memory and then parses it. For xml files, use ezxml_parse_file()
-// or ezxml_parse_fd()
-#if 0
-ezxml_t ezxml_parse_fp(FILE *fp)
-{
-    ezxml_root_t root;
-    size_t l, len = 0;
-    char *s;
-
-    if (! (s = malloc(EZXML_BUFSIZE))) return NULL;
-    do {
-        len += (l = fread((s + len), 1, EZXML_BUFSIZE, fp));
-        if (l == EZXML_BUFSIZE) s = realloc(s, len + EZXML_BUFSIZE);
-    } while (s && l == EZXML_BUFSIZE);
-
-    if (! s) return NULL;
-    root = (ezxml_root_t)ezxml_parse_str(s, len);
-    root->len = -1; // so we know to free s in ezxml_free()
-    return &root->xml;
-}
-#endif
-
-// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
-// attempts to mem map the file. Failing that, reads the file into memory.
-// Returns NULL on failure.
-ezxml_t ezxml_parse_fd(FILE *fd )
-{
-    ezxml_root_t root;
-    struct stat st;
-    size_t l;
-    void *m;
-    int err;
-    mm_segment_t fs;
-    loff_t pos;
-
-    if (!fd || !fd->f_op || !fd->f_op->read)
-    {
-        printk("WARNING: File (read) object is a null pointer!!!\n");
-        return NULL;
-    }
-
-    err = vfs_getattr(fd->f_vfsmnt,fd->f_dentry,&st);
-    if(err)
-    {
-        printk("can't get state of file err=%d\n",err);
-        return NULL;
-    }
-
-    m = malloc(st.size);
-    fs = get_fs();
-    set_fs(KERNEL_DS);
-    pos = 0;
-    l = vfs_read(fd, m, st.size, &pos);
-    set_fs(fs);
-    //l = read(fd, m , st.size);
-
-    root = (ezxml_root_t)ezxml_parse_str(m, l);
-
-    root->len = -1; // so we know to free s in ezxml_free()
-    return &root->xml;
-}
-
-// a wrapper for ezxml_parse_fd that accepts a file name
-ezxml_t ezxml_parse_file(char *name)
-{
-    FILE *fd = filp_open(name, O_RDONLY, 0);
-	ezxml_t xml;
-
-    if (IS_ERR(fd))
-        return NULL;
-
-    xml = ezxml_parse_fd(fd);
-
-    if (fd >= 0) filp_close(fd, 0);
-    return xml;
-}
-
-// Encodes ampersand sequences appending the results to *dst, reallocating *dst
-// if length excedes max. a is non-zero for attribute encoding. Returns *dst
-char *ezxml_ampencode(const char *s, size_t len, char **dst, size_t *dlen,
-                      size_t *max, short a)
-{
-    const char *e;
-
-    for (e = s + len; s != e; s++) {
-        while (*dlen + 10 > *max) *dst = realloc(*dst, *max += EZXML_BUFSIZE);
-
-        switch (*s) {
-        case '\0': return *dst;
-        case '&': *dlen += sprintf(*dst + *dlen, "&amp;"); break;
-        case '<': *dlen += sprintf(*dst + *dlen, "&lt;"); break;
-        case '>': *dlen += sprintf(*dst + *dlen, "&gt;"); break;
-        case '"': *dlen += sprintf(*dst + *dlen, (a) ? "&quot;" : "\""); break;
-        case '\n': *dlen += sprintf(*dst + *dlen, (a) ? "&#xA;" : "\n"); break;
-        case '\t': *dlen += sprintf(*dst + *dlen, (a) ? "&#x9;" : "\t"); break;
-        case '\r': *dlen += sprintf(*dst + *dlen, "&#xD;"); break;
-        default: (*dst)[(*dlen)++] = *s;
-        }
-    }
-    return *dst;
-}
-
-// Recursively converts each tag to xml appending it to *s. Reallocates *s if
-// its length excedes max. start is the location of the previous tag in the
-// parent tag's character content. Returns *s.
-char *ezxml_toxml_r(ezxml_t xml, char **s, size_t *len, size_t *max,
-                    size_t start, char ***attr)
-{
-    int i, j;
-    char *txt = (xml->parent) ? xml->parent->txt : "";
-    size_t off = 0;
-
-    // parent character content up to this tag
-    *s = ezxml_ampencode(txt + start, xml->off - start, s, len, max, 0);
-
-    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
-        *s = realloc(*s, *max += EZXML_BUFSIZE);
-
-    *len += sprintf(*s + *len, "<%s", xml->name); // open tag
-    for (i = 0; xml->attr[i]; i += 2) { // tag attributes
-        if (ezxml_attr(xml, xml->attr[i]) != xml->attr[i + 1]) continue;
-        while (*len + strlen(xml->attr[i]) + 7 > *max) // reallocate s
-            *s = realloc(*s, *max += EZXML_BUFSIZE);
-
-        *len += sprintf(*s + *len, " %s=\"", xml->attr[i]);
-        ezxml_ampencode(xml->attr[i + 1], -1, s, len, max, 1);
-        *len += sprintf(*s + *len, "\"");
-    }
-
-    for (i = 0; attr[i] && strcmp(attr[i][0], xml->name); i++);
-    for (j = 1; attr[i] && attr[i][j]; j += 3) { // default attributes
-        if (! attr[i][j + 1] || ezxml_attr(xml, attr[i][j]) != attr[i][j + 1])
-            continue; // skip duplicates and non-values
-        while (*len + strlen(attr[i][j]) + 7 > *max) // reallocate s
-            *s = realloc(*s, *max += EZXML_BUFSIZE);
-
-        *len += sprintf(*s + *len, " %s=\"", attr[i][j]);
-        ezxml_ampencode(attr[i][j + 1], -1, s, len, max, 1);
-        *len += sprintf(*s + *len, "\"");
-    }
-    *len += sprintf(*s + *len, ">");
-
-    *s = (xml->child) ? ezxml_toxml_r(xml->child, s, len, max, 0, attr) //child
-                      : ezxml_ampencode(xml->txt, -1, s, len, max, 0);  //data
-
-    while (*len + strlen(xml->name) + 4 > *max) // reallocate s
-        *s = realloc(*s, *max += EZXML_BUFSIZE);
-
-    *len += sprintf(*s + *len, "</%s>", xml->name); // close tag
-
-    while (txt[off] && off < xml->off) off++; // make sure off is within bounds
-    return (xml->ordered) ? ezxml_toxml_r(xml->ordered, s, len, max, off, attr)
-                          : ezxml_ampencode(txt + off, -1, s, len, max, 0);
-}
-
-// Converts an ezxml structure back to xml. Returns a string of xml data that
-// must be freed.
-char *ezxml_toxml(ezxml_t xml)
-{
-    ezxml_t p = (xml) ? xml->parent : NULL, o = (xml) ? xml->ordered : NULL;
-    ezxml_root_t root = (ezxml_root_t)xml;
-    size_t len = 0, max = EZXML_BUFSIZE;
-    char *s = strcpy(malloc(max), ""), *t, *n;
-    int i, j, k;
-
-    if (! xml || ! xml->name) return realloc(s, len + 1);
-    while (root->xml.parent) root = (ezxml_root_t)root->xml.parent; // root tag
-
-    for (i = 0; ! p && root->pi[i]; i++) { // pre-root processing instructions
-        for (k = 2; root->pi[i][k - 1]; k++);
-        for (j = 1; (n = root->pi[i][j]); j++) {
-            if (root->pi[i][k][j - 1] == '>') continue; // not pre-root
-            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
-                s = realloc(s, max += EZXML_BUFSIZE);
-            len += sprintf(s + len, "<?%s%s%s?>\n", t, *n ? " " : "", n);
-        }
-    }
-
-    xml->parent = xml->ordered = NULL;
-    s = ezxml_toxml_r(xml, &s, &len, &max, 0, root->attr);
-    xml->parent = p;
-    xml->ordered = o;
-
-    for (i = 0; ! p && root->pi[i]; i++) { // post-root processing instructions
-        for (k = 2; root->pi[i][k - 1]; k++);
-        for (j = 1; (n = root->pi[i][j]); j++) {
-            if (root->pi[i][k][j - 1] == '<') continue; // not post-root
-            while (len + strlen(t = root->pi[i][0]) + strlen(n) + 7 > max)
-                s = realloc(s, max += EZXML_BUFSIZE);
-            len += sprintf(s + len, "\n<?%s%s%s?>", t, *n ? " " : "", n);
-        }
-    }
-    return realloc(s, len + 1);
-}
-
-// free the memory allocated for the ezxml structure
-void ezxml_free(ezxml_t xml)
-{
-    ezxml_root_t root = (ezxml_root_t)xml;
-    int i, j;
-    char **a, *s;
-
-    if (! xml) return;
-    ezxml_free(xml->child);
-    ezxml_free(xml->ordered);
-
-    if (! xml->parent) { // free root tag allocations
-        for (i = 10; root->ent[i]; i += 2) // 0 - 9 are default entites (<>&"')
-            if ((s = root->ent[i + 1]) < root->s || s > root->e) free(s);
-        free(root->ent); // free list of general entities
-
-        for (i = 0; (a = root->attr[i]); i++) {
-            for (j = 1; a[j++]; j += 2) // free malloced attribute values
-                if (a[j] && (a[j] < root->s || a[j] > root->e)) free(a[j]);
-            free(a);
-        }
-        if (root->attr[0]) free(root->attr); // free default attribute list
-
-        for (i = 0; root->pi[i]; i++) {
-            for (j = 1; root->pi[i][j]; j++);
-            free(root->pi[i][j + 1]);
-            free(root->pi[i]);
-        }
-        if (root->pi[0]) free(root->pi); // free processing instructions
-
-        if (root->len == -1) free(root->m); // malloced xml data
-        if (root->u) free(root->u); // utf8 conversion
-    }
-
-    ezxml_free_attr(xml->attr); // tag attributes
-    if ((xml->flags & EZXML_TXTM)) free(xml->txt); // character content
-    if ((xml->flags & EZXML_NAMEM)) free(xml->name); // tag name
-    free(xml);
-}
-
-// return parser error message or empty string if none
-const char *ezxml_error(ezxml_t xml)
-{
-    while (xml && xml->parent) xml = xml->parent; // find root tag
-    return (xml) ? ((ezxml_root_t)xml)->err : "";
-}
-
-// returns a new empty ezxml structure with the given root tag name
-ezxml_t ezxml_new(const char *name)
-{
-    static char *ent[] = { "lt;", "&#60;", "gt;", "&#62;", "quot;", "&#34;",
-                           "apos;", "&#39;", "amp;", "&#38;", NULL };
-    ezxml_root_t root = (ezxml_root_t)memset(malloc(sizeof(struct ezxml_root)),
-                                             '\0', sizeof(struct ezxml_root));
-    root->xml.name = (char *)name;
-    root->cur = &root->xml;
-    strcpy(root->err, root->xml.txt = "");
-    root->ent = memcpy(malloc(sizeof(ent)), ent, sizeof(ent));
-    root->attr = root->pi = (char ***)(root->xml.attr = EZXML_NIL);
-    return &root->xml;
-}
-
-// inserts an existing tag into an ezxml structure
-ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off)
-{
-    ezxml_t cur, prev, head;
-
-    xml->next = xml->sibling = xml->ordered = NULL;
-    xml->off = off;
-    xml->parent = dest;
-
-    if ((head = dest->child)) { // already have sub tags
-        if (head->off <= off) { // not first subtag
-            for (cur = head; cur->ordered && cur->ordered->off <= off;
-                 cur = cur->ordered);
-            xml->ordered = cur->ordered;
-            cur->ordered = xml;
-        }
-        else { // first subtag
-            xml->ordered = head;
-            dest->child = xml;
-        }
-
-        for (cur = head, prev = NULL; cur && strcmp(cur->name, xml->name);
-             prev = cur, cur = cur->sibling); // find tag type
-        if (cur && cur->off <= off) { // not first of type
-            while (cur->next && cur->next->off <= off) cur = cur->next;
-            xml->next = cur->next;
-            cur->next = xml;
-        }
-        else { // first tag of this type
-            if (prev && cur) prev->sibling = cur->sibling; // remove old first
-            xml->next = cur; // old first tag is now next
-            for (cur = head, prev = NULL; cur && cur->off <= off;
-                 prev = cur, cur = cur->sibling); // new sibling insert point
-            xml->sibling = cur;
-            if (prev) prev->sibling = xml;
-        }
-    }
-    else dest->child = xml; // only sub tag
-
-    return xml;
-}
-
-// Adds a child tag. off is the offset of the child tag relative to the start
-// of the parent tag's character content. Returns the child tag.
-ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off)
-{
-    ezxml_t child;
-
-    if (! xml) return NULL;
-    child = (ezxml_t)memset(malloc(sizeof(struct ezxml)), '\0',
-                            sizeof(struct ezxml));
-    child->name = (char *)name;
-    child->attr = EZXML_NIL;
-    child->txt = "";
-
-    return ezxml_insert(child, xml, off);
-}
-
-// sets the character content for the given tag and returns the tag
-ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt)
-{
-    if (! xml) return NULL;
-    if (xml->flags & EZXML_TXTM) free(xml->txt); // existing txt was malloced
-    xml->flags &= ~EZXML_TXTM;
-    xml->txt = (char *)txt;
-    return xml;
-}
-
-// Sets the given tag attribute or adds a new attribute if not found. A value
-// of NULL will remove the specified attribute. Returns the tag given.
-ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value)
-{
-    int l = 0, c;
-
-    if (! xml) return NULL;
-    while (xml->attr[l] && strcmp(xml->attr[l], name)) l += 2;
-    if (! xml->attr[l]) { // not found, add as new attribute
-        if (! value) return xml; // nothing to do
-        if (xml->attr == EZXML_NIL) { // first attribute
-            xml->attr = malloc(4 * sizeof(char *));
-            xml->attr[1] = strdup(""); // empty list of malloced names/vals
-        }
-        else xml->attr = realloc(xml->attr, (l + 4) * sizeof(char *));
-
-        xml->attr[l] = (char *)name; // set attribute name
-        xml->attr[l + 2] = NULL; // null terminate attribute list
-        xml->attr[l + 3] = realloc(xml->attr[l + 1],
-                                   (c = strlen(xml->attr[l + 1])) + 2);
-        strcpy(xml->attr[l + 3] + c, " "); // set name/value as not malloced
-        if (xml->flags & EZXML_DUP) xml->attr[l + 3][c] = EZXML_NAMEM;
-    }
-    else if (xml->flags & EZXML_DUP) free((char *)name); // name was strduped
-
-    for (c = l; xml->attr[c]; c += 2); // find end of attribute list
-    if (xml->attr[c + 1][l / 2] & EZXML_TXTM) free(xml->attr[l + 1]); //old val
-    if (xml->flags & EZXML_DUP) xml->attr[c + 1][l / 2] |= EZXML_TXTM;
-    else xml->attr[c + 1][l / 2] &= ~EZXML_TXTM;
-
-    if (value) xml->attr[l + 1] = (char *)value; // set attribute value
-    else { // remove attribute
-        if (xml->attr[c + 1][l / 2] & EZXML_NAMEM) free(xml->attr[l]);
-        memmove(xml->attr + l, xml->attr + l + 2, (c - l + 2) * sizeof(char*));
-        xml->attr = realloc(xml->attr, (c + 2) * sizeof(char *));
-        memmove(xml->attr[c + 1] + (l / 2), xml->attr[c + 1] + (l / 2) + 1,
-                (c / 2) - (l / 2)); // fix list of which name/vals are malloced
-    }
-    xml->flags &= ~EZXML_DUP; // clear strdup() flag
-    return xml;
-}
-
-// sets a flag for the given tag and returns the tag
-ezxml_t ezxml_set_flag(ezxml_t xml, short flag)
-{
-    if (xml) xml->flags |= flag;
-    return xml;
-}
-
-// removes a tag along with its subtags without freeing its memory
-ezxml_t ezxml_cut(ezxml_t xml)
-{
-    ezxml_t cur;
-
-    if (! xml) return NULL; // nothing to do
-    if (xml->next) xml->next->sibling = xml->sibling; // patch sibling list
-
-    if (xml->parent) { // not root tag
-        cur = xml->parent->child; // find head of subtag list
-        if (cur == xml) xml->parent->child = xml->ordered; // first subtag
-        else { // not first subtag
-            while (cur->ordered != xml) cur = cur->ordered;
-            cur->ordered = cur->ordered->ordered; // patch ordered list
-
-            cur = xml->parent->child; // go back to head of subtag list
-            if (strcmp(cur->name, xml->name)) { // not in first sibling list
-                while (strcmp(cur->sibling->name, xml->name))
-                    cur = cur->sibling;
-                if (cur->sibling == xml) { // first of a sibling list
-                    cur->sibling = (xml->next) ? xml->next
-                                               : cur->sibling->sibling;
-                }
-                else cur = cur->sibling; // not first of a sibling list
-            }
-
-            while (cur->next && cur->next != xml) cur = cur->next;
-            if (cur->next) cur->next = cur->next->next; // patch next list
-        }
-    }
-    xml->ordered = xml->sibling = xml->next = NULL;
-    return xml;
-}
-
-void* ezxml_realloc(void *p, size_t new_size)
-{
-	void    *ret;
-    size_t  ks = 0;
-
-	if (!new_size)
-        return NULL;
-
-    if (p)
-        ks = ksize(p);
-
-    if (ks < new_size) {
-        ret = malloc(new_size);
-        if (ret && p)
-        {
-            memcpy(ret, p, new_size);
-            free(p);
-        }
-    }
-    else
-        ret = p;
-
-	return ret;
-}
-
-#if 0 /* Example */
-E_ErrorCodes        startupCFGModuleInit(void)
-{
-    ezxml_t xml;
-    ezxml_t xmlHead;
-    ezxml_t xmlElement;
-    ezxml_t xmlElement1;
-    ezxml_t xmlElement_childLoop;
-
-
-
-    xmlHead = ezxml_parse_file();
-    xml = xmlHead;
-
-
-    /*simple get child value example*/
-    xmlElement = ezxml_child(xml, "board_type");
-    if (xmlElement) {
-        printf("%s tag value  = %s\n",xmlElement->name, xmlElement->txt);
-    }
-    else{
-        printf("board_type tag was not found\n");
-        xml = xmlHead;
-    }
-
-    /*get consecutive child value example*/
-    xmlElement = ezxml_child(xml, "IP_host_supported");
-    if (xmlElement) {
-        printf("%s tag value  = %s\n",xmlElement->name, xmlElement->txt);
-    }
-    else{
-        xml = xmlHead;
-        printf("IP_host_supported tag was not found\n");
-
-    }
-
-    xml = xmlHead;
-    /*get consecutive child attribute example, return the first occurance of this tag*/
-    xmlElement = ezxml_get(xml,"port_init",0,"pots_ports",-1 );
-    if (xmlElement) {
-        printf("%s tag id attribute = %s\n",xmlElement->name,xmlElement->txt);
-    }
-    else{
-        xml = xmlHead;
-        printf("No pots_ports tag was found\n");
-    }
-
-
-    /*get size attribute of the first queue from the second TCONT*/
-    xmlElement = ezxml_get(xml,"port_init",0,"TCONT_parameters",0, "TCONT",1,"queue_map",0,"queue",-1 );
-    if (xmlElement) {
-        printf("Second TCONCT, first %s tag size attribute = %s\n",xmlElement->name, ezxml_attr(xmlElement, "size"));
-    }
-    else{
-        xml = xmlHead;
-        printf("The first queue from the second TCONT tag was not found\n");
-    }
-
-    /*point the the next occurance of this tag since xml propoagte internally*/
-    xmlElement = xmlElement->next;
-    if (xmlElement) {
-        printf("Second TCONCT, second %s tag weight attribute = %s\n",xmlElement->name, ezxml_attr(xmlElement, "weight"));
-    }
-    else{
-        xml = xmlHead;
-        printf("Next queue tag was not found\n");
-    }
-
-  /*get speed attribute of the first ethernet */
-    xml = xmlHead;
-    xmlElement = ezxml_get(xml,"port_init",0,"Ethernet_parameters",0,"Ethernet",-1 );
-    if (xmlElement) {
-        printf("First ethernet %s tag speed attribute = %s\n",xmlElement->name, ezxml_attr(xmlElement, "speed"));
-    }
-    else{
-        xml = xmlHead;
-        printf("The first ethernet tag was not found\n");
-    }
-    /*loop on all ethernets and get attributes*/
-    /*first set pointer to top of the XML tree*/
-    xml = xmlHead;
-    /*second set pointer to top of the relative hierarcy*/
-    xml = ezxml_get(xml,"port_init",0,"Ethernet_parameters",-1 );
-    for (xmlElement = ezxml_child(xml, "Ethernet"); xmlElement; xmlElement = xmlElement->next) {
-         printf("%s tag switch_port attribute = %s\n",xmlElement->name, ezxml_attr(xmlElement, "switch_port"));
-        }
-
-
-    /*loop on all TCONT & queues and get attributes*/
-    /*first set pointer to top of the XML tree*/
-    xml = xmlHead;
-    /*second set pointer to top of the relative hierarcy*/
-    xml = ezxml_get(xml,"port_init",0,"TCONT_parameters",-1 );
-    for (xmlElement = ezxml_child(xml, "TCONT"); xmlElement; xmlElement = xmlElement->next) {
-         printf("%s tag id attribute = %s\n",xmlElement->name, ezxml_attr(xmlElement, "id"));
-         xmlElement1 = ezxml_child(xmlElement, "scheduler_method");
-         printf("%s tag value  = %s\n",xmlElement1->name, xmlElement1->txt);
-         xmlElement1 = ezxml_child(xmlElement, "queue_map");
-         for (xmlElement_childLoop = ezxml_child(xmlElement1, "queue"); xmlElement_childLoop; xmlElement_childLoop = xmlElement_childLoop->next){
-              printf("%s tag weight attribute = %s\n",xmlElement_childLoop->name, ezxml_attr(xmlElement_childLoop, "weight"));
-        }
-
-    }
-    ezxml_free(xmlHead);
-    return (IAMBA_OK);
-}
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.h
deleted file mode 100644
index f2785a8..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_ezxml/ezxml.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/* ezxml.h
- *
- * Copyright 2004-2006 Aaron Voisine <aaron@voisine.org>
- *
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-
-#ifndef _EZXML_H
-#define _EZXML_H
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define EZXML_BUFSIZE 1024 // size of internal memory buffers
-#define EZXML_NAMEM   0x80 // name is malloced
-#define EZXML_TXTM    0x40 // txt is malloced
-#define EZXML_DUP     0x20 // attribute name and value are strduped
-
-typedef struct file FILE;
-
-typedef struct ezxml *ezxml_t;
-struct ezxml {
-    char *name;      // tag name
-    char **attr;     // tag attributes { name, value, name, value, ... NULL }
-    char *txt;       // tag character content, empty string if none
-    size_t off;      // tag offset from start of parent tag character content
-    ezxml_t next;    // next tag with same name in this section at this depth
-    ezxml_t sibling; // next tag with different name in same section and depth
-    ezxml_t ordered; // next tag, same section and depth, in original order
-    ezxml_t child;   // head of sub tag list, NULL if none
-    ezxml_t parent;  // parent tag, NULL if current tag is root tag
-    short flags;     // additional information
-};
-
-// Given a string of xml data and its length, parses it and creates an ezxml
-// structure. For efficiency, modifies the data by adding null terminators
-// and decoding ampersand sequences. If you don't want this, copy the data and
-// pass in the copy. Returns NULL on failure.
-ezxml_t ezxml_parse_str(char *s, size_t len);
-
-
-ezxml_t ezxml_parse_file( char *file);
-#ifdef EZXML_TEST
-// A wrapper for ezxml_parse_str() that accepts a file descriptor. First
-// attempts to mem map the file. Failing that, reads the file into memory.
-// Returns NULL on failure.
-ezxml_t ezxml_parse_fd(int fd);
-
-// a wrapper for ezxml_parse_fd() that accepts a file name
-
-// Wrapper for ezxml_parse_str() that accepts a file stream. Reads the entire
-// stream into memory and then parses it. For xml files, use ezxml_parse_file()
-// or ezxml_parse_fd()
-ezxml_t ezxml_parse_fp(FILE *fp);
-#endif
-
-// returns the first child tag (one level deeper) with the given name or NULL
-// if not found
-ezxml_t ezxml_child(ezxml_t xml, const char *name);
-
-// returns the next tag of the same name in the same section and depth or NULL
-// if not found
-#define ezxml_next(xml) ((xml) ? xml->next : NULL)
-
-// Returns the Nth tag with the same name in the same section at the same depth
-// or NULL if not found. An index of 0 returns the tag given.
-ezxml_t ezxml_idx(ezxml_t xml, int idx);
-
-// returns the name of the given tag
-#define ezxml_name(xml) ((xml) ? xml->name : NULL)
-
-// returns the given tag's character content or empty string if none
-#define ezxml_txt(xml) ((xml) ? xml->txt : "")
-
-// returns the value of the requested tag attribute, or NULL if not found
-const char *ezxml_attr(ezxml_t xml, const char *attr);
-
-// Traverses the ezxml sturcture to retrieve a specific subtag. Takes a
-// variable length list of tag names and indexes. The argument list must be
-// terminated by either an index of -1 or an empty string tag name. Example:
-// title = ezxml_get(library, "shelf", 0, "book", 2, "title", -1);
-// This retrieves the title of the 3rd book on the 1st shelf of library.
-// Returns NULL if not found.
-ezxml_t ezxml_get(ezxml_t xml, ...);
-
-// Converts an ezxml structure back to xml. Returns a string of xml data that
-// must be freed.
-char *ezxml_toxml(ezxml_t xml);
-
-// returns a NULL terminated array of processing instructions for the given
-// target
-const char **ezxml_pi(ezxml_t xml, const char *target);
-
-// frees the memory allocated for an ezxml structure
-void ezxml_free(ezxml_t xml);
-
-// returns parser error message or empty string if none
-const char *ezxml_error(ezxml_t xml);
-
-// returns a new empty ezxml structure with the given root tag name
-ezxml_t ezxml_new(const char *name);
-
-// wrapper for ezxml_new() that strdup()s name
-#define ezxml_new_d(name) ezxml_set_flag(ezxml_new(MMP_OS_STRDUP(name)), EZXML_NAMEM)
-
-// Adds a child tag. off is the offset of the child tag relative to the start
-// of the parent tag's character content. Returns the child tag.
-ezxml_t ezxml_add_child(ezxml_t xml, const char *name, size_t off);
-
-// wrapper for ezxml_add_child() that strdup()s name
-#define ezxml_add_child_d(xml, name, off) \
-    ezxml_set_flag(ezxml_add_child(xml, MMP_OS_STRDUP(name), off), EZXML_NAMEM)
-
-// sets the character content for the given tag and returns the tag
-ezxml_t ezxml_set_txt(ezxml_t xml, const char *txt);
-
-// wrapper for ezxml_set_txt() that strdup()s txt
-#define ezxml_set_txt_d(xml, txt) \
-    ezxml_set_flag(ezxml_set_txt(xml, MMP_OS_STRDUP(txt)), EZXML_TXTM)
-
-// Sets the given tag attribute or adds a new attribute if not found. A value
-// of NULL will remove the specified attribute. Returns the tag given.
-ezxml_t ezxml_set_attr(ezxml_t xml, const char *name, const char *value);
-
-// Wrapper for ezxml_set_attr() that strdup()s name/value. Value cannot be NULL
-#define ezxml_set_attr_d(xml, name, value) \
-    ezxml_set_attr(ezxml_set_flag(xml, EZXML_DUP), MMP_OS_STRDUP(name), MMP_OS_STRDUP(value))
-
-// sets a flag for the given tag and returns the tag
-ezxml_t ezxml_set_flag(ezxml_t xml, short flag);
-
-// removes a tag along with its subtags without freeing its memory
-ezxml_t ezxml_cut(ezxml_t xml);
-
-// inserts an existing tag into an ezxml structure
-ezxml_t ezxml_insert(ezxml_t xml, ezxml_t dest, size_t off);
-
-// Moves an existing tag to become a subtag of dest at the given offset from
-// the start of dest's character content. Returns the moved tag.
-#define ezxml_move(xml, dest, off) ezxml_insert(ezxml_cut(xml), dest, off)
-
-// removes a tag along with all its subtags
-#define ezxml_remove(xml) ezxml_free(ezxml_cut(xml))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // _EZXML_H
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Kconfig b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Kconfig
deleted file mode 100644
index 6d6ae13..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Kconfig
+++ /dev/null
@@ -1,9 +0,0 @@
-menu "SoC MAC learning support"
-depends on MV_INCLUDE_TPM
-
-config  MV_MAC_LEARN
-	bool "Support for MAC learning through PnC"
-	default n
-	---help---
-
-endmenu
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Makefile b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Makefile
deleted file mode 100644
index 5a3d01e..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# Makefile for the Marvell MAC learn module
-#
-ifeq ($(CONFIG_ARCH_FEROCEON),y)
-	include $(srctree)/$(MACHINE)/config/mvRules.mk
-endif
-
-ifdef CONFIG_MV_HAL_RULES_PATH
-include $(srctree)/include/config/auto.conf
-include $(srctree)/$(subst ",,$(CONFIG_MV_HAL_RULES_PATH))
-endif
-
-MAC_LEARN_OBJS += mv_mac_learn_mod.o \
-		  mv_mac_learn_netdev.o \
-		  mv_mac_learn_logic.o \
-		  mv_mac_learn_db.o \
-		  mv_mac_learn_api.o \
-		  mv_mac_learn_sysfs.o
-
-mv_mac_learn-objs := $(MAC_LEARN_OBJS)
-obj-$(CONFIG_MV_MAC_LEARN) += mv_mac_learn.o
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.c
deleted file mode 100644
index aa904f7..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_api.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include "mv_mac_learn_header.h"
-
-/***********************************************************
-* mv_mac_learn_static_entry_add
-* API for adding static learn entry
-* input:
-*	static_mac_addr: source MAC address
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-***********************************************************/
-int32_t mv_mac_learn_static_entry_add(char *static_mac_addr)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_logic_static_add(static_mac_addr);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn static entry adding failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_static_entry_add);
-
-/***********************************************************
-* mv_mac_learn_static_entry_del
-* API for del static learn entry
-* input:
-*	static_mac_addr: source MAC address
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_static_entry_del(char *static_mac_addr)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_logic_static_del(static_mac_addr);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn static entry del failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_static_entry_del);
-
-/***********************************************************
-* mv_mac_learn_enable_set
-* API for set MAC leaning enable state
-* input:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_enable_set(bool enable)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_enable_set(enable);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn enable operation failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_enable_set);
-
-/***********************************************************
-* mv_mac_learn_enable_get
-* API for get MAC leaning enable state
-* output:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_enable_get(bool *enable)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_enable_get(enable);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn enable operation failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_enable_get);
-
-/***********************************************************
-* mv_mac_learn_overwrite_enable_set
-* API for set MAC leaning overwrite enable state if FDB is full
-* input:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_overwrite_enable_set(bool enable)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_overwrite_set(enable);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn overwrite enable operation failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_overwrite_enable_set);
-
-/***********************************************************
-* mv_mac_learn_overwrite_enable_get
-* API for get MAC leaning overwrite enable state
-* output:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_overwrite_enable_get(bool *enable)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_overwrite_get(enable);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn overwrite enable operation failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_overwrite_enable_get);
-
-/***********************************************************
-* mv_mac_learn_max_count_set
-* API for set MAX count of MAC learning entry supported
-* input:
-*	max_count: max count
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_max_count_set(uint32_t max_count)
-{
-	int32_t ret;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)) {
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	if (max_count > (range_conf.api_end - range_conf.api_start + 1)) {
-		MVMACLEARN_ERR_PRINT("MAC learn max count larger than PNC range size\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	if (max_count > MAC_LEARN_FDB_MAX_COUNT)
-		max_count = MAC_LEARN_FDB_MAX_COUNT;
-
-	ret = mv_mac_learn_op_max_count_set(max_count);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn max count set failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_max_count_set);
-
-/***********************************************************
-* mv_mac_learn_max_count_get
-* API for get MAX count of MAC leaning entry supported
-* output:
-*	max_count: max count
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_max_count_get(uint32_t *max_count)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_max_count_get(max_count);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn max count get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_max_count_get);
-
-/***********************************************************
-* mv_mac_learn_expire_time_set
-* API for set expired time of MAC leaning non-static entry
-* input:
-*	expire_time: expire time, unit: second
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_expire_time_set(uint32_t expire_time)
-{
-	int32_t ret;
-
-	/*input check*/
-	if (expire_time == 0) {
-		MVMACLEARN_ERR_PRINT("MAC learn expire time invalid(%d)\n", expire_time);
-		return MAC_LEARN_FAIL;
-	}
-
-	ret = mv_mac_learn_op_expire_set(expire_time);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn expire time set failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_expire_time_set);
-
-/***********************************************************
-* mv_mac_learn_expire_time_get
-* API for get expired time of MAC leaning non-static entry
-* output:
-*	expire_time: expire time, unit: second
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_expire_time_get(uint32_t *expire_time)
-{
-	int32_t ret;
-
-	ret = mv_mac_learn_op_expire_get(expire_time);
-	if (ret) {
-		MVMACLEARN_ERR_PRINT("MAC learn expire time get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-EXPORT_SYMBOL(mv_mac_learn_expire_time_get);
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.h
deleted file mode 100644
index 11ccdc9..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_api.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_api.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_api_h__
-#define __mv_mac_learn_api_h__
-
-/* MACRO
-------------------------------------------------------------------------------*/
-#define MAC_LEARN_OK 0
-#define MAC_LEARN_FAIL 1
-
-/* CPU rate limit related*/
-#define MAC_LEARN_RATE_LIMIT 128
-#define MAC_LEARN_BUCKET_SIZE 2000
-
-/* Function protype
-------------------------------------------------------------------------------*/
-
-/***********************************************************
-* mv_mac_learn_static_entry_add
-* API for adding static learn entry
-* input:
-*	static_mac_addr: source MAC address
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-***********************************************************/
-int32_t mv_mac_learn_static_entry_add(char *static_mac_addr);
-
-
-/***********************************************************
-* mv_mac_learn_static_entry_del
-* API for del static learn entry
-* input:
-*	static_mac_addr: source MAC address
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_static_entry_del(char *static_mac_addr);
-
-/***********************************************************
-* mv_mac_learn_enable_set
-* API for set MAC leaning enable state
-* input:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_enable_set(bool enable);
-
-/***********************************************************
-* mv_mac_learn_enable_get
-* API for get MAC leaning enable state
-* output:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_enable_get(bool *enable);
-
-/***********************************************************
-* mv_mac_learn_overwrite_enable_set
-* API for set MAC leaning overwrite enable state if FDB is full
-* input:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_overwrite_enable_set(bool enable);
-
-/***********************************************************
-* mv_mac_learn_overwrite_enable_get
-* API for get MAC leaning overwrite enable state
-* output:
-*	enable: enable state, true: enable, false: disable
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_overwrite_enable_get(bool *enable);
-
-/***********************************************************
-* mv_mac_learn_max_count_set
-* API for set MAX count of MAC learning entry supported
-* input:
-*	max_count: max count
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_max_count_set(uint32_t max_count);
-
-/***********************************************************
-* mv_mac_learn_max_count_get
-* API for get MAX count of MAC leaning entry supported
-* output:
-*	max_count: max count
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_max_count_get(uint32_t *max_count);
-
-/***********************************************************
-* mv_mac_learn_expire_time_set
-* API for set expired time of MAC leaning non-static entry
-* input:
-*	expire_time: expire time, unit: second
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_expire_time_set(uint32_t expire_time);
-
-/***********************************************************
-* mv_mac_learn_expire_time_get
-* API for get expired time of MAC leaning non-static entry
-* output:
-*	expire_time: expire time, unit: second
-* return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-************************************************************/
-int32_t mv_mac_learn_expire_time_get(uint32_t *expire_time);
-
-#endif
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.c
deleted file mode 100644
index 0d1e236..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.c
+++ /dev/null
@@ -1,623 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_db.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include "mv_mac_learn_header.h"
-
-/*Global variable*/
-mac_learn_fdb_t mac_learn_fdb;
-
-/************************************************************************************
-*mac_learn_db_nohit_time_clear
-* clearn no hit time to 0 for all non-static entry in FDB
-*return:
-*	success--MAC_LEARN_FDB_OK
-************************************************************************************/
-int32_t mac_learn_db_nohit_time_clear(void)
-{
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid &&
-		    MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[i].state)
-			mac_learn_fdb.mac_learn_db_entry[i].no_hit_time = 0;
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-*mac_learn_db_reset
-* Reset FDB and delete all MAC learning PNC entry, including non-static and static
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_reset(void)
-{
-	tpm_l2_acl_key_t del_mac_key;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			memset(&del_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-			memset(del_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-			memcpy(del_mac_key.mac.mac_sa, mac_learn_fdb.mac_learn_db_entry[i].src_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-			/*Get spin lock*/
-			mac_learn_tpm_api_lock_get(MAC_LEARN_TPM_API_LOCK_DEL);
-			if (!tpm_del_mac_learn_rule(tpm_owner_id, &del_mac_key)) {
-				/* Release spin lock */
-				mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_DEL);
-				/*invalid FDB entry*/
-				mac_learn_fdb.mac_learn_db_entry[i].valid = MAC_LEARN_FDB_INVALID;
-				atomic_dec(&mac_learn_fdb.fdb_valid_count);
-				if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[i].state)
-					atomic_dec(&mac_learn_fdb.fdb_non_static_count);
-			} else {
-				MVMACLEARN_ERR_PRINT("TPM entry delete failed\n");
-				/* Release spin lock */
-				mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_DEL);
-				spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-
-				return MAC_LEARN_FDB_FAIL;
-			}
-		}
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-*mac_learn_db_nonstatic_clear
-* Clearn all non-static entry in PNC and FDB
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_nonstatic_clear()
-{
-	tpm_l2_acl_key_t del_mac_key;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	uint32_t pnc_idx = 1;
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid &&
-		    MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[i].state) {
-			/*Get spin lock*/
-			spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-
-			memset(&del_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-			memset(del_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-			memcpy(del_mac_key.mac.mac_sa, mac_learn_fdb.mac_learn_db_entry[i].src_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-			pnc_idx = mac_learn_fdb.mac_learn_db_entry[i].pnc_idx;
-			if (!tpm_del_mac_learn_rule(tpm_owner_id, &del_mac_key)) {
-				/*invalid FDB entry*/
-				mac_learn_fdb.mac_learn_db_entry[i].valid = MAC_LEARN_FDB_INVALID;
-				atomic_dec(&mac_learn_fdb.fdb_valid_count);
-				if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[i].state)
-					atomic_dec(&mac_learn_fdb.fdb_non_static_count);
-			} else {
-				MVMACLEARN_ERR_PRINT("TPM entry delete failed\n");
-				/* Release spin lock */
-				spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-
-				return MAC_LEARN_FDB_FAIL;
-			}
-
-			/* Release spin lock */
-			spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-
-			/* Update PnC index */
-			if (mac_learn_db_pncidx_update(0, pnc_idx)) {
-				MVMACLEARN_ERR_PRINT("TPM PNC index update failed(%d)\n", i);
-				return MAC_LEARN_FDB_FAIL;
-			}
-		}
-	}
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-*mac_learn_db_no_hit_time_get
-* Get no-hit time for a non-static MAC learning entry
-* input:
-*	fdb_idx: entry index in FDB
-*output:
-*	no_hit_time: no hit time, unit: second
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_no_hit_time_get(uint32_t fdb_idx, uint32_t *no_hit_time)
-{
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[fdb_idx].valid) {
-		if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[fdb_idx].state) {
-			*no_hit_time = mac_learn_fdb.mac_learn_db_entry[fdb_idx].no_hit_time;
-
-			spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-			return MAC_LEARN_FDB_OK;
-		}
-	}
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	*no_hit_time = 0;
-
-	return MAC_LEARN_FDB_FAIL;
-}
-
-/************************************************************************************
-*mac_learn_db_no_time_clear_update_hit
-* Clear no-hit time for a non-static MAC learning entry and update its pnc hit count
-* input:
-*	fdb_idx: entry index in FDB
-*	hit_count: new pnc hit count for non-static entry
-*return:
-*	void
-************************************************************************************/
-void mac_learn_db_no_time_clear_update_hit(uint32_t fdb_idx, uint32_t hit_count)
-{
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[fdb_idx].valid) {
-		if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[fdb_idx].state) {
-			mac_learn_fdb.mac_learn_db_entry[fdb_idx].hit_count = hit_count;
-			mac_learn_fdb.mac_learn_db_entry[fdb_idx].no_hit_time = 0;
-		}
-	}
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-}
-
-/************************************************************************************
-*mac_learn_db_no_time_clear_update_hit
-* Clear no-hit time for a non-static MAC learning entry and update its pnc hit count
-* input:
-*	fdb_idx: entry index in FDB
-*	hit_count: new pnc hit count for non-static entry
-*return:
-*	void
-************************************************************************************/
-void mac_learn_db_no_hit_time_inc_read(uint32_t fdb_idx, mac_learn_db_entry_t *mac_learn_db_entry)
-{
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[fdb_idx].valid) {
-		if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[fdb_idx].state) {
-			mac_learn_fdb.mac_learn_db_entry[fdb_idx].no_hit_time++;
-			memcpy(mac_learn_db_entry, &mac_learn_fdb.mac_learn_db_entry[fdb_idx], sizeof(mac_learn_db_entry_t));
-		}
-	}
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-}
-
-/************************************************************************************
-*mac_learn_db_nonstatic_pnc_get_by_fdbidx
-* Clear no-hit time for a non-static MAC learning entry and update its pnc hit count
-* input:
-*	fdb_idx: entry index in FDB
-* output:
-*	pnc_idx: the PNC index in TCAM of MAC learning entry
-*	hit_count: current hit count of non-static entry
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_nonstatic_pnc_get_by_fdbidx(uint32_t fdb_idx, uint32_t *pnc_idx, uint32_t *hit_count)
-{
-	/* Input check */
-	if (NULL == pnc_idx || NULL == hit_count)
-		return MAC_LEARN_FDB_FAIL;
-
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[fdb_idx].valid) {
-		if (MAC_LEARN_FDB_NON_STATIC == mac_learn_fdb.mac_learn_db_entry[fdb_idx].state) {
-			*pnc_idx = mac_learn_fdb.mac_learn_db_entry[fdb_idx].pnc_idx;
-			*hit_count = mac_learn_fdb.mac_learn_db_entry[fdb_idx].hit_count;
-
-			spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-			return MAC_LEARN_FDB_OK;
-		}
-	}
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-
-	*pnc_idx = MAC_LEARN_FDB_INVALID_PNC;
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_find_mac_addr
-* Find a source MAC address exist in FDB or not, if exist return info of related entry
-* input:
-*	src_mac_key: TPM L2 key contain souce MAC address
-* output:
-*	addr_exist: Indicate the MAC exist in FDB or not; 1--exist, 0--non-exist
-*	mac_learn_db_entry: related MAC learning entry info if MAC exist
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_find_mac_addr(tpm_l2_acl_key_t *src_mac_key, int32_t *addr_exist, mac_learn_db_entry_t *mac_learn_db_entry)
-{
-	uint32_t i;
-
-	if (NULL == src_mac_key)
-		return MAC_LEARN_FDB_FAIL;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			if (!memcmp(src_mac_key->mac.mac_sa, mac_learn_fdb.mac_learn_db_entry[i].src_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE)) {
-				if (addr_exist)
-					*addr_exist = 1;
-				if (mac_learn_db_entry) {
-					memcpy(mac_learn_db_entry, &mac_learn_fdb.mac_learn_db_entry[i], sizeof(mac_learn_db_entry_t));
-					mac_learn_db_entry->fdb_idx = i;
-				}
-				/* Release spin lock */
-				spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-				break;
-			}
-		}
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-	if (i == MAC_LEARN_FDB_MAX_COUNT) {
-		if (addr_exist)
-			*addr_exist = 0;
-	}
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_pncidx_update
-* Update PnC index when PNC entry changed in MAC learn range
-* input:
-*	rule_add: update reason; 1--rule add, 0--rule delete
-*	pnc_index: current PNC index before update
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_pncidx_update(uint8_t rule_add, uint32_t pnc_index)
-{
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			if (rule_add) {
-				if (pnc_index <= mac_learn_fdb.mac_learn_db_entry[i].pnc_idx)
-					mac_learn_fdb.mac_learn_db_entry[i].pnc_idx++;
-			} else {
-				if (pnc_index < mac_learn_fdb.mac_learn_db_entry[i].pnc_idx)
-					mac_learn_fdb.mac_learn_db_entry[i].pnc_idx--;
-			}
-		}
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_free_inx_get
-* Get the free FDB entry, the first entry find in FDB
-* output:
-*	free_idx: Free FBD index find
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_free_inx_get(uint32_t *free_idx)
-{
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_INVALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			mac_learn_fdb.mac_learn_db_entry[i].valid = MAC_LEARN_FDB_RESERVED;
-			*free_idx = i;
-			/* Release spin lock */
-			spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-			break;
-		}
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	if(i == MAC_LEARN_FDB_MAX_COUNT) {
-		*free_idx = 0xFFFF;
-		return MAC_LEARN_FDB_FAIL;
-	}
-	else
-		return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_entry_info_by_pncidx
-* Get the info the a valid FDB entry by its PNC index
-* input:
-*	pnc_idx: PnC index of MAC learning entry
-* output:
-*	free_idx: Free FBD index find
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_entry_info_by_pncidx(uint32_t pnc_idx, uint32_t *fdb_idx, mac_learn_db_entry_t *mac_learn_db_entry)
-{
-	uint32_t i;
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/*Get spin lock*/
-		spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-		if (MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			if (mac_learn_fdb.mac_learn_db_entry[i].pnc_idx == pnc_idx) {
-				if (NULL != fdb_idx)
-					*fdb_idx = i;
-				if (NULL != mac_learn_db_entry)
-					memcpy(mac_learn_db_entry, &mac_learn_fdb.mac_learn_db_entry[i], sizeof(mac_learn_db_entry_t));
-				/* Release spin lock */
-				spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-				break;
-			}
-		}
-		/* Release spin lock */
-		spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	if(i == MAC_LEARN_FDB_MAX_COUNT)
-		return MAC_LEARN_FDB_FAIL;
-	else
-		return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_entry_add
-* Add a new entry to FDB
-* input:
-*	mac_learn_db_entry: FDB entry to add
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_entry_add(mac_learn_db_entry_t *mac_learn_db_entry)
-{
-	uint32_t free_idx;
-	if (mac_learn_db_free_inx_get(&free_idx)) {
-		MVMACLEARN_ERR_PRINT("No Free FDB entry\n");
-		return MAC_LEARN_FDB_FAIL;
-	}
-	/*Get spin lock*/
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[free_idx]);
-	memcpy(&mac_learn_fdb.mac_learn_db_entry[free_idx], mac_learn_db_entry, sizeof(mac_learn_db_entry_t));
-	/* Release spin lock */
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[free_idx]);
-	/* Increase valid count */
-	atomic_inc(&mac_learn_fdb.fdb_valid_count);
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_entry_add
-* Delete an existing entry in FDB
-* input:
-*	del_idx: FDB index to delete
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_entry_del(uint32_t del_idx)
-{
-	if (del_idx >= MAC_LEARN_FDB_MAX_COUNT) {
-		MVMACLEARN_ERR_PRINT("Invalid input\n");
-		return MAC_LEARN_FDB_FAIL;
-	}
-
-	/*Get spin lock*/
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[del_idx]);
-	mac_learn_fdb.mac_learn_db_entry[del_idx].valid = MAC_LEARN_FDB_INVALID;
-	/* Release spin lock */
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[del_idx]);
-	/* Decrease valid count */
-	atomic_dec(&mac_learn_fdb.fdb_valid_count);
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_valid_count_get
-* Get the count of valid entry in FDB
-* output:
-*	valid_ount: valid entry count
-*return:
-*	success--MAC_LEARN_FDB_OK
-************************************************************************************/
-int32_t mac_learn_db_valid_count_get(uint32_t *valid_ount)
-{
-	*valid_ount = atomic_read(&mac_learn_fdb.fdb_valid_count);
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_nonstatic_count_inc
-* Increase count of non-static entry in FDB by 1
-*return:
-*	void
-************************************************************************************/
-void mac_learn_db_nonstatic_count_inc(void)
-{
-	atomic_inc(&mac_learn_fdb.fdb_non_static_count);
-}
-
-/************************************************************************************
-* mac_learn_db_nonstatic_count_dec
-* Decrease count of non-static entry in FDB by 1
-*return:
-*	void
-************************************************************************************/
-void mac_learn_db_nonstatic_count_dec(void)
-{
-	atomic_dec(&mac_learn_fdb.fdb_non_static_count);
-}
-
-/************************************************************************************
-* mac_learn_db_nonstatic_count_get
-* Get count of non-static entry in FDB
-*return:
-*	success--MAC_LEARN_FDB_OK
-************************************************************************************/
-int32_t mac_learn_db_nonstatic_count_get(uint32_t *nonstatic_ount)
-{
-	*nonstatic_ount = atomic_read(&mac_learn_fdb.fdb_non_static_count);
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/************************************************************************************
-* mac_learn_db_valid_print
-* Print current all valid MAC learning entry in FDB
-*return:
-*	void
-************************************************************************************/
-void mac_learn_db_valid_print(void)
-{
-	uint32_t i, j;
-	char entry_state[11];
-
-	/*print header*/
-	printk("+--------------+---------------------+--------------+\n");
-	printk("+-----State----+-----Source_MAC------+---PNC_Idex---+\n");
-	printk("+--------------+---------------------+--------------+\n");
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		if(MAC_LEARN_FDB_VALID == mac_learn_fdb.mac_learn_db_entry[i].valid) {
-			if (MAC_LEARN_FDB_STATIC == mac_learn_fdb.mac_learn_db_entry[i].state)
-				strcpy(entry_state, "Static    ");
-			else
-				strcpy(entry_state, "Non-Static");
-			printk("+--%s--+--", entry_state);
-			for (j = 0; j < 6; j++)
-				printk("%2.2x ", mac_learn_fdb.mac_learn_db_entry[i].src_mac_addr[j]);
-			printk("-+------%2d------+\n", mac_learn_fdb.mac_learn_db_entry[i].pnc_idx);
-		}
-	}
-	printk("+--------------+---------------------+--------------+\n");
-}
-
-/************************************************************************************
-* mac_learn_db_entry_state_update
-* Update entry state of an existing entry
-* input:
-*	fdb_idx: FDB entry index
-*	entry_state: FDB entry state
-*return:
-*	success--MAC_LEARN_FDB_OK
-*	failed --MAC_LEARN_FDB_FAIL
-************************************************************************************/
-int32_t mac_learn_db_entry_state_update(uint32_t fdb_idx, uint8_t entry_state)
-{
-	/* Para check */
-	if (fdb_idx >= MAC_LEARN_FDB_MAX_COUNT) {
-		MVMACLEARN_ERR_PRINT("MAC learn FDB entry index(%d) invalid\n", fdb_idx);
-		return MAC_LEARN_FDB_FAIL;
-	}
-
-	if ((MAC_LEARN_FDB_STATIC != entry_state) && (MAC_LEARN_FDB_NON_STATIC != entry_state)) {
-		MVMACLEARN_ERR_PRINT("MAC learn FDB entry state(%d) invalid\n", entry_state);
-		return MAC_LEARN_FDB_FAIL;
-	}
-
-	/* Get spin lock */
-	spin_lock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-	/* Update to expected state */
-	mac_learn_fdb.mac_learn_db_entry[fdb_idx].state = entry_state;
-	/* Release spin lock */
-	spin_unlock(&mac_learn_fdb.mac_learn_db_entry_lock[fdb_idx]);
-
-	return MAC_LEARN_FDB_OK;
-}
-
-/***************************************************************************************************************
-* mac_learn_fdb_init()
-*
-* DESCRIPTION: Perform DB Initialization. Set all structures to 0, and all valid fields to MAC_LEARN_FDB_INVALID
-*
-* INPUTS:
-*
-* OUTPUTS:
-*
-* RETURNS:
-* On success, the function returns MAC_LEARN_FDB_OK. On error different types are returned
-*
-* COMMENTS:
-*
-******************************************************************************************************************/
-int32_t mac_learn_fdb_init(void)
-{
-	uint32_t i;
-
-	/* Erase DB */
-	memset(&mac_learn_fdb, 0, sizeof(mac_learn_fdb_t));
-
-	/*init valid_count*/
-	atomic_set(&mac_learn_fdb.fdb_valid_count, 0);
-	atomic_set(&mac_learn_fdb.fdb_non_static_count, 0);
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		/* Invalid all FDB entry */
-		mac_learn_fdb.mac_learn_db_entry[i].valid = MAC_LEARN_FDB_INVALID;
-		/* Init Spinlock for each entry */
-		spin_lock_init(&mac_learn_fdb.mac_learn_db_entry_lock[i]);
-	}
-
-	mac_learn_fdb.mac_learn_fdb_init = true;
-
-	return MAC_LEARN_FDB_OK;
-}
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.h
deleted file mode 100644
index a650602..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_db.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_db.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_db_h__
-#define __mv_mac_learn_db_h__
-
-/* MACRO
-------------------------------------------------------------------------------*/
-#define MAC_LEARN_FDB_MAX_COUNT 32
-
-#define MAC_LEARN_FDB_OK 0
-#define MAC_LEARN_FDB_FAIL 1
-
-#define MAC_LEARN_FDB_INVALID 0xDE
-#define MAC_LEARN_FDB_VALID 0x01
-#define MAC_LEARN_FDB_RESERVED 0xCE
-
-#define MAC_LEARN_FDB_STATIC 0x0
-#define MAC_LEARN_FDB_NON_STATIC 0x1
-
-#define MAC_LEARN_FDB_INVALID_PNC 0xFFFF
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-typedef struct {
-	uint32_t fdb_idx;
-	uint8_t valid;
-	uint8_t state;
-	uint8_t port;
-	uint8_t src_mac_addr[6];
-	uint32_t pnc_idx;
-	uint32_t hit_count;
-	uint32_t no_hit_time;/* unit:s */
-} mac_learn_db_entry_t;
-
-typedef struct {
-	bool mac_learn_fdb_init;/* indicate whether db is init or not */
-	atomic_t fdb_valid_count;
-	atomic_t fdb_non_static_count;
-	spinlock_t mac_learn_db_entry_lock[MAC_LEARN_FDB_MAX_COUNT];
-	mac_learn_db_entry_t mac_learn_db_entry[MAC_LEARN_FDB_MAX_COUNT];
-} mac_learn_fdb_t;
-
-/* Function protype
-------------------------------------------------------------------------------*/
-int32_t mac_learn_db_nohit_time_clear(void);
-int32_t mac_learn_db_reset(void);
-int32_t mac_learn_db_nonstatic_clear(void);
-int32_t mac_learn_db_no_hit_time_get(uint32_t fdb_idx, uint32_t *no_hit_time);
-void mac_learn_db_no_time_clear_update_hit(uint32_t fdb_idx, uint32_t hit_count);
-void mac_learn_db_no_hit_time_inc_read(uint32_t fdb_idx, mac_learn_db_entry_t *mac_learn_db_entry);
-int32_t mac_learn_db_nonstatic_pnc_get_by_fdbidx(uint32_t fdb_idx, uint32_t *pnc_idx, uint32_t *hit_count);
-int32_t mac_learn_db_find_mac_addr(tpm_l2_acl_key_t *src_mac_key, int32_t *addr_exist, mac_learn_db_entry_t *mac_learn_db_entry);
-int32_t mac_learn_db_pncidx_update(uint8_t rule_add, uint32_t pnc_index);
-int32_t mac_learn_db_free_inx_get(uint32_t *free_idx);
-int32_t mac_learn_db_entry_info_by_pncidx(uint32_t pnc_idx, uint32_t *fdb_idx, mac_learn_db_entry_t *mac_learn_db_entry);
-int32_t mac_learn_db_entry_add(mac_learn_db_entry_t *mac_learn_db_entry);
-int32_t mac_learn_db_entry_del(uint32_t del_idx);
-int32_t mac_learn_db_valid_count_get(uint32_t *valid_ount);
-void mac_learn_db_nonstatic_count_inc(void);
-void mac_learn_db_nonstatic_count_dec(void);
-int32_t mac_learn_db_nonstatic_count_get(uint32_t *nonstatic_ount);
-void mac_learn_db_valid_print(void);
-int32_t mac_learn_db_entry_state_update(uint32_t fdb_idx, uint8_t entry_state);
-int32_t mac_learn_fdb_init(void);
-
-#endif
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_header.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_header.h
deleted file mode 100644
index 6516584..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_header.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_header.h
-*
-* DESCRIPTION: Include all mac learn header files needed
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_header_h__
-#define __mv_mac_learn_header_h__
-
-/* Include Files
-------------------------------------------------------------------------------*/
-#include "mv_mac_learn_mod.h"
-#include "mv_mac_learn_api.h"
-#include "mv_mac_learn_netdev.h"
-#include "mv_mac_learn_logic.h"
-#include "mv_mac_learn_db.h"
-#include "mv_mac_learn_sysfs.h"
-
-#endif /* __mv_mac_learn_header_h__ */
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.c
deleted file mode 100644
index ddb99d8..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.c
+++ /dev/null
@@ -1,605 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_logic.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-#include "mvOs.h"
-#include "mv_mac_learn_header.h"
-
-/************************************************************************************
-* mv_mac_learn_get_lu_hw()
-* Get LU of MAC leanring PnC entry; but this function is NOT used for long time delay
-*************************************************************************************/
-int32_t mv_mac_learn_get_lu_hw(uint32_t *pnc_idx)
-{
-	uint32_t i = 0;
-	uint32_t w32,tid;
-	tpm_api_lu_conf_t lu_conf;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	if (tpm_db_pnc_get_lu_conf(TPM_PNC_MAC_LEARN, &lu_conf)) {
-		MVMACLEARN_ERR_PRINT("TPM lookup conf get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	i = 0;
-	while (i < CONFIG_MV_PNC_TCAM_LINES) {
-		w32 = mvPncAgingLogEntryRead(lu_conf.cntr_grp, 0);
-		if ((w32 & PNC_AGING_LOG_VALID_MASK) == 0) {
-			MVMACLEARN_WARN_PRINT("LU Read ivalid\n");
-			tid = range_conf.range_start + range_conf.api_end;
-			break;
-		}
-		mvOsDelay(20);
-		tid = w32 & PNC_AGING_LOG_CNTR_IDX_MASK;
-		if (tid >= (range_conf.range_start + range_conf.api_start) && tid <= (range_conf.range_start + range_conf.api_end))
-			break;
-		i++;
-
-		if(!(i%8))
-			mvPncAgingTrigerSet();
-	}
-
-	if (CONFIG_MV_PNC_TCAM_LINES == i) {
-		MVMACLEARN_WARN_PRINT("LU Read failed\n");
-		tid = range_conf.range_start + range_conf.api_end;
-	}
-
-	*pnc_idx = tid;
-
-	return MAC_LEARN_OK;
-}
-
-/************************************************************************************
-* mv_mac_learn_get_lu
-* Get LU of MAC leanring PnC entry
-*output:
-*	pnc_idx: PNC index of LU entry
-*return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-*************************************************************************************/
-int32_t mv_mac_learn_get_lu(uint32_t *pnc_idx)
-{
-	int32_t i;
-	uint32_t hit_count = 0, temp;
-	uint32_t lu_idx = 0;
-	uint32_t first_lu = 0;
-	mac_learn_db_entry_t mac_learn_db_entry;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* If only one API entry */
-	if (range_conf.api_start == range_conf.api_end) {
-		*pnc_idx = range_conf.range_start + range_conf.api_start;
-		return MAC_LEARN_OK;
-	}
-
-	for (i = range_conf.range_start + range_conf.api_start; i <= range_conf.range_start + range_conf.api_end; i++) {
-		/* Static entry not be replaced */
-		if (!mac_learn_db_entry_info_by_pncidx(i, NULL, &mac_learn_db_entry)) {
-			if (mac_learn_db_entry.state == MAC_LEARN_FDB_STATIC)
-				continue;
-		} else {
-			continue;
-		}
-		if (first_lu == 0) {
-			lu_idx = i;
-			hit_count = mvPncAgingCntrRead(lu_idx) & PNC_AGING_CNTR_MASK;
-			first_lu = 1;
-		} else {
-			temp = mvPncAgingCntrRead(i) & PNC_AGING_CNTR_MASK;
-			if (hit_count > temp) {
-				hit_count = temp;
-				lu_idx = i;
-			}
-		}
-	}
-
-	/* All entries are static, can not replace */
-	if (first_lu == 0)
-		return MAC_LEARN_FAIL;
-
-	*pnc_idx = lu_idx;
-
-	return MAC_LEARN_OK;
-}
-
-/************************************************************************************
-* mv_mac_learn_aging
-* MAC learning aging function for aging timer
-*input:
-*	mac_learn_aging: pointer of global variable
-*return:
-*	void
-*************************************************************************************/
-void mv_mac_learn_aging(unsigned long mac_learn_aging)
-{
-	uint32_t i;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	uint32_t pnc_idx, read_count,hit_count = 0;
-	uint32_t fdb_nonstatic_valid_count;
-	tpm_l2_acl_key_t del_mac_key;
-	mac_learn_db_entry_t mac_learn_db_entry;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	mac_learn_t *mac_learn_age = (mac_learn_t *)mac_learn_aging;
-
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return;
-	}
-
-	for (i = 0; i < MAC_LEARN_FDB_MAX_COUNT; i++) {
-		if (!mac_learn_db_nonstatic_pnc_get_by_fdbidx(i, &pnc_idx, &hit_count)) {
-			if (MAC_LEARN_FDB_INVALID_PNC == pnc_idx)
-				continue;
-			/*check whether PnC hit in last 1s*/
-			read_count = mvPncAgingCntrRead(pnc_idx);
-			if (read_count & PNC_AGING_CNTR_MASK) {
-				/*clear no hit time*/
-				mac_learn_db_no_time_clear_update_hit(i, read_count & PNC_AGING_CNTR_MASK);
-				/*clear hit counter, avoid overflow*/
-				mvPncAgingCntrWrite(pnc_idx, read_count & (~PNC_AGING_CNTR_MASK));
-			} else {
-				/* Increase No hit time and read it */
-				mac_learn_db_no_hit_time_inc_read(i, &mac_learn_db_entry);
-				if (mac_learn_db_entry.no_hit_time >= mac_learn_age->mac_learn_expire_time) {
-					memset(&del_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-					memset(del_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-					memcpy(del_mac_key.mac.mac_sa, mac_learn_db_entry.src_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-					/*Get tpm del lock*/
-					spin_lock(&mac_learn_age->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-					if (!tpm_del_mac_learn_rule(tpm_owner_id, &del_mac_key)) {
-						/*release lock*/
-						spin_unlock(&mac_learn_age->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-						/*Update FDB first*/
-						if (TPM_RANGE_TYPE_ACL == range_conf.range_type)
-							mac_learn_db_pncidx_update(0, pnc_idx);
-						if (mac_learn_db_entry_del(i)) {
-							MVMACLEARN_ERR_PRINT("MAC learn FDB del failed\n");
-							continue;
-						} else {
-							/* dec non static entry count */
-							mac_learn_db_nonstatic_count_dec();
-							mac_learn_db_nonstatic_count_get(&fdb_nonstatic_valid_count);
-							/* start MAC learn again */
-							if ((mac_learn_age->mac_learn_max_count - fdb_nonstatic_valid_count == 1) &&
-							    (false == mac_learn_age->mac_learn_overwrite_enable)) {
-								/* Trap packet with new address to CPU again */
-								if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_TRAP)) {
-									MVMACLEARN_ERR_PRINT("MAC learn default rule action set failed\n");
-									continue;
-								}
-							}
-						}
-					} else {
-						/*release lock*/
-						spin_unlock(&mac_learn_age->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-						MVMACLEARN_ERR_PRINT("TPM MAC learn entry del failed\n");
-						continue;
-					}
-				}
-			}
-		}
-	}
-
-	/*Continue time*/
-	mod_timer(&mac_learn_age->mac_learn_timer, jiffies + HZ);
-}
-
-/************************************************************************************
-* mv_mac_learn_pnc_rule_add
-* Function to add new MAC leanring entry automatic in system
-*input:
-*	work: work queue the function on
-*return:
-*	void
-*************************************************************************************/
-void mv_mac_learn_pnc_rule_add(struct work_struct *work)
-{
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_l2_acl_key_t src_mac_key, del_mac_key;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	uint32_t valid_count, nonstatic_count;
-	mac_learn_db_entry_t mac_learn_db_entry;
-	int32_t addr_exist = 0;
-	int32_t fdb_addr_exist = 0;
-	uint32_t rule_num, pnc_idx;
-	uint32_t fdb_idx;
-	mac_learn_t *src_mac = container_of(work, mac_learn_t, mac_learn_work);
-
-	/*check mac learn enable state*/
-	if (false == src_mac->mac_learn_enable)
-		return;
-
-	/* Get pnc_mac_learn_enable from TPM XML */
-	if (tpm_db_pnc_mac_learn_enable_get(&pnc_mac_learn_enable))
-		return;
-	if (TPM_PNC_MAC_LEARN_DISABLED == pnc_mac_learn_enable) {
-		MVMACLEARN_ERR_PRINT("TPM PNC mac learn disabled\n");
-		return;
-	}
-
-	/* Check non-static max count, if 0 just return */
-	if (src_mac->mac_learn_max_count == 0) {
-		/* Read buffer, in order to clear it to avoid bad effection for following MAC learn */
-		mv_mac_learn_queue_read(src_mac_key.mac.mac_sa);
-		return;
-	}
-
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		/* Read buffer, in order to clear it to avoid bad effection for following MAC learn */
-		mv_mac_learn_queue_read(src_mac_key.mac.mac_sa);
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return;
-	}
-
-	memset(&src_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-	memset(src_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-	memset(&mac_learn_db_entry, 0, sizeof(mac_learn_db_entry_t));
-	/*Get source MAC address*/
-	if (mv_mac_learn_queue_read(src_mac_key.mac.mac_sa))
-		return;
-
-	/* Check the src mac exist in FDB or not*/
-	if (mac_learn_db_find_mac_addr(&src_mac_key, &fdb_addr_exist, NULL))
-		return;
-	/* If Addr exist in FDB, return */
-	if (fdb_addr_exist == 1)
-		return;
-
-	/* Get valid entry count currently */
-	if (mac_learn_db_valid_count_get(&valid_count) || mac_learn_db_nonstatic_count_get(&nonstatic_count)) {
-		MVMACLEARN_ERR_PRINT("Get valid count or nonstatic count failed\n");
-		return;
-	}
-
-	/* Check non-static Full or not */
-	if (src_mac->mac_learn_max_count == nonstatic_count) {
-		if (true == src_mac->mac_learn_overwrite_enable) {
-			/* Overwrite LU entry */
-			if (!mv_mac_learn_get_lu(&pnc_idx)) {
-				MVMACLEARN_DEBUG_PRINT("PnC index need to be overwritten: %d\n", pnc_idx);
-				/* Delete LU in PnC first */
-				if (!mac_learn_db_entry_info_by_pncidx(pnc_idx, &fdb_idx, &mac_learn_db_entry)) {
-					memset(&del_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-					memset(del_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-					memcpy(del_mac_key.mac.mac_sa, mac_learn_db_entry.src_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-					/*get lock*/
-					spin_lock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-					if (!tpm_del_mac_learn_rule(tpm_owner_id, &del_mac_key)) {
-						/*release lock*/
-						spin_unlock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-						/*Update FDB first*/
-						if (TPM_RANGE_TYPE_ACL == range_conf.range_type)
-							mac_learn_db_pncidx_update(0, pnc_idx);
-						if (mac_learn_db_entry_del(fdb_idx)) {
-							MVMACLEARN_ERR_PRINT("MAC learn FDB del failed\n");
-							return;
-						} else {
-							mac_learn_db_nonstatic_count_dec();
-						}
-					} else {
-						/*release lock*/
-						spin_unlock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-						MVMACLEARN_ERR_PRINT("TPM MAC learn entry del failed\n");
-						return;
-					}
-				} else {
-					MVMACLEARN_ERR_PRINT("MAC learn FDB info get failed\n");
-					return;
-				}
-			}else {
-				MVMACLEARN_ERR_PRINT("LU MAC learn entry get failed\n");
-				return;
-			}
-		} else {
-			/* Discarded packet with new address */
-			if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_DROP)) {
-				MVMACLEARN_ERR_PRINT("MAC learn default rule action set failed\n");
-				return;
-			}
-			/* Return from here */
-			return;
-		}
-	}
-
-	/*get lock*/
-	spin_lock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_ADD]);
-	if (!tpm_add_mac_learn_rule(tpm_owner_id, &src_mac_key)) {
-		/*Release lock*/
-		spin_unlock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_ADD]);
-		if (fdb_addr_exist == 0) {
-			/* Get PnC index */
-			if (!tpm_proc_find_mac_addr_db(&src_mac_key, &addr_exist, &rule_num, &pnc_idx)) {
-				if (addr_exist) {
-					memset(&mac_learn_db_entry, 0, sizeof(mac_learn_db_entry_t));
-					mac_learn_db_entry.valid = MAC_LEARN_FDB_VALID;
-					mac_learn_db_entry.state = MAC_LEARN_FDB_NON_STATIC;
-					mac_learn_db_entry.port = MAC_LEARN_ON_GMAC;
-					mac_learn_db_entry.pnc_idx = range_conf.range_start + range_conf.api_start + pnc_idx;
-					mac_learn_db_entry.hit_count = 0;
-					mac_learn_db_entry.no_hit_time = 0;
-					memcpy(mac_learn_db_entry.src_mac_addr, src_mac_key.mac.mac_sa, sizeof(char) * MV_MAC_ADDR_SIZE);
-					MVMACLEARN_DEBUG_PRINT("New non-static MAC learn entry adding, PnC idex: %d\n",mac_learn_db_entry.pnc_idx);
-					/*Update FDB first*/
-					if (TPM_RANGE_TYPE_ACL == range_conf.range_type)
-						mac_learn_db_pncidx_update(1, mac_learn_db_entry.pnc_idx);
-					/* Write to FDB */
-					if (!mac_learn_db_entry_add(&mac_learn_db_entry))
-						mac_learn_db_nonstatic_count_inc();
-				}
-			}
-		}
-	} else {
-		/*Release lock*/
-		spin_unlock(&src_mac->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_ADD]);
-	}
-}
-
-/************************************************************************************
-* mv_mac_learn_logic_static_add
-* Function to add new MAC leanring entry mannuly in system
-*input:
-*	static_mac_addr: source MAC address
-*return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-*************************************************************************************/
-int32_t mv_mac_learn_logic_static_add(char *static_mac_addr)
-{
-	tpm_l2_acl_key_t src_mac_key;
-	mac_learn_db_entry_t mac_learn_db_entry;
-	tpm_db_pnc_range_conf_t range_conf;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	int32_t addr_exist = 0;
-	int32_t fdb_addr_exist = 0;
-	uint32_t rule_num, pnc_idx, pnc_max_count, valid_count, non_static_count, non_static_max;
-	bool mac_learn_enable = false;
-
-	if (mv_mac_learn_op_enable_get(&mac_learn_enable))
-		return MAC_LEARN_FAIL;
-	if (false == mac_learn_enable) {
-		MVMACLEARN_ERR_PRINT("MAC learn disabled\n\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/*Input check*/
-	if (NULL == static_mac_addr) {
-		MVMACLEARN_ERR_PRINT("Invalid input\n");
-		return MAC_LEARN_FAIL;
-	}
-	MVMACLEARN_DEBUG_PRINT("MAC addr: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n", static_mac_addr[0], static_mac_addr[1], static_mac_addr[2],
-									    static_mac_addr[3], static_mac_addr[4], static_mac_addr[5]);
-	/*init src_mac_key*/
-	memset(&src_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-	memset(src_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-	memcpy(src_mac_key.mac.mac_sa, static_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-
-	/*Get MAC learn range info*/
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* get entry count info */
-	pnc_max_count = range_conf.api_end - range_conf.api_start + 1;
-	if (mac_learn_db_valid_count_get(&valid_count) ||
-	    mac_learn_db_nonstatic_count_get(&non_static_count) ||
-	    mv_mac_learn_op_max_count_get(&non_static_max))
-		return MAC_LEARN_FAIL;
-
-	/* Check the src mac exist in FDB or not*/
-	if (mac_learn_db_find_mac_addr(&src_mac_key, &fdb_addr_exist, &mac_learn_db_entry)) {
-		MVMACLEARN_ERR_PRINT("mac_learn_db_find_mac_addr failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* If Addr exist in FDB, return OK*/
-	if (fdb_addr_exist == 1) {
-		if (MAC_LEARN_FDB_STATIC == mac_learn_db_entry.state) {
-			MVMACLEARN_WARN_PRINT("Entry already exist\n");
-		} else {
-			/*check whether static free entry enough or not*/
-			if ((valid_count - non_static_count) >= (pnc_max_count - non_static_max)) {
-				MVMACLEARN_ERR_PRINT("No free entry for static entry\n");
-				return MAC_LEARN_FAIL;
-			}
-			/* Update original entry state */
-			if (mac_learn_db_entry_state_update(mac_learn_db_entry.fdb_idx, MAC_LEARN_FDB_STATIC)) {
-				MVMACLEARN_ERR_PRINT("MAC learn FDB entry state update failed\n");
-				return MAC_LEARN_FAIL;
-			}
-			mac_learn_db_nonstatic_count_dec();
-		}
-		return MAC_LEARN_OK;
-	}
-	/*check whether static free entry enough or not*/
-	if ((valid_count - non_static_count) >= (pnc_max_count - non_static_max)) {
-		MVMACLEARN_ERR_PRINT("No free entry for static entry\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/*Add entry through TPM API*/
-	/*get lock*/
-	mac_learn_tpm_api_lock_get(MAC_LEARN_TPM_API_LOCK_ADD);
-	if (!tpm_add_mac_learn_rule(tpm_owner_id, &src_mac_key)) {
-		/*release lock*/
-		mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_ADD);
-		/* Get PnC index */
-		if (!tpm_proc_find_mac_addr_db(&src_mac_key, &addr_exist, &rule_num, &pnc_idx)) {
-			/*Update FDB*/
-			if (addr_exist) {
-				memset(&mac_learn_db_entry, 0, sizeof(mac_learn_db_entry_t));
-				mac_learn_db_entry.valid = MAC_LEARN_FDB_VALID;
-				mac_learn_db_entry.state = MAC_LEARN_FDB_STATIC;
-				mac_learn_db_entry.port = MAC_LEARN_ON_GMAC;
-				mac_learn_db_entry.pnc_idx = range_conf.range_start + range_conf.api_start + pnc_idx;
-				mac_learn_db_entry.hit_count = 0;
-				memcpy(mac_learn_db_entry.src_mac_addr, src_mac_key.mac.mac_sa, sizeof(char) * MV_MAC_ADDR_SIZE);
-				MVMACLEARN_DEBUG_PRINT("New static MAC learn  entry adding, PnC idex: %d\n",mac_learn_db_entry.pnc_idx);
-				/*Update FDB first*/
-				if (TPM_RANGE_TYPE_ACL == range_conf.range_type)
-					mac_learn_db_pncidx_update(1, mac_learn_db_entry.pnc_idx);
-				/* Write to FDB */
-				if (mac_learn_db_entry_add(&mac_learn_db_entry)) {
-					MVMACLEARN_ERR_PRINT("mac_learn_db_entry_add failed\n");
-					return MAC_LEARN_FAIL;
-				}
-			}
-		} else {
-			MVMACLEARN_ERR_PRINT("tpm_proc_find_mac_addr_db failed\n");
-			return MAC_LEARN_FAIL;
-		}
-		return MAC_LEARN_OK;
-	} else {
-		/*release lock*/
-		mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_ADD);
-		MVMACLEARN_ERR_PRINT("tpm_add_mac_learn_rule failed\n");
-		return MAC_LEARN_FAIL;
-	}
-}
-
-/************************************************************************************
-* mv_mac_learn_logic_static_add
-* Function to delete a MAC leanring entry mannuly in system
-*input:
-*	static_mac_addr: source MAC address
-*return:
-*	success--MAC_LEARN_OK
-*	failed --MAC_LEARN_FAIL
-*************************************************************************************/
-int32_t mv_mac_learn_logic_static_del(char *static_mac_addr)
-{
-	tpm_l2_acl_key_t del_mac_key;
-	tpm_db_pnc_range_conf_t range_conf;
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	int32_t addr_exist = 0;
-	int32_t fdb_addr_exist = 1;
-	uint32_t rule_num, pnc_idx;
-	uint32_t fdb_idx;
-	bool mac_learn_enable = false;
-	mac_learn_db_entry_t mac_learn_db_entry_info;
-
-	if (mv_mac_learn_op_enable_get(&mac_learn_enable))
-		return MAC_LEARN_FAIL;
-	if (false == mac_learn_enable) {
-		MVMACLEARN_ERR_PRINT("MAC learn disabled\n\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/*Input check*/
-	if (NULL == static_mac_addr) {
-		MVMACLEARN_ERR_PRINT("Invalid input\n");
-		return MAC_LEARN_FAIL;
-	}
-	MVMACLEARN_DEBUG_PRINT("MAC addr: %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n", static_mac_addr[0], static_mac_addr[1], static_mac_addr[2],
-									    static_mac_addr[3], static_mac_addr[4], static_mac_addr[5]);
-	/*init src_mac_key*/
-	memset(&del_mac_key, 0, sizeof(tpm_l2_acl_key_t));
-	memset(del_mac_key.mac.mac_sa_mask, 0xff, sizeof(u8)*MV_MAC_ADDR_SIZE);
-	memcpy(del_mac_key.mac.mac_sa, static_mac_addr, sizeof(char) * MV_MAC_ADDR_SIZE);
-
-	/* Check the src mac exist in FDB or not*/
-	if (mac_learn_db_find_mac_addr(&del_mac_key, &fdb_addr_exist, &mac_learn_db_entry_info)) {
-		MVMACLEARN_ERR_PRINT("mac_learn_db_find_mac_addr failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* If Addr non-exist in FDB, return OK*/
-	if (fdb_addr_exist == 0) {
-		MVMACLEARN_ERR_PRINT("Entry non-exist\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/* If exist, check it is static mac or non-static, only static mac allow to del with API */
-	if (mac_learn_db_entry_info.state == MAC_LEARN_FDB_NON_STATIC) {
-		MVMACLEARN_ERR_PRINT("Non-static MAC, not allowed to del with static API\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-		MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/* Get PnC index */
-	if (!tpm_proc_find_mac_addr_db(&del_mac_key, &addr_exist, &rule_num, &pnc_idx)) {
-		if (addr_exist == 0) {
-			MVMACLEARN_ERR_PRINT("TPM DB inconsistent with MAC learn FDB\n");
-			return MAC_LEARN_FAIL;
-		}
-		pnc_idx = range_conf.range_start + range_conf.api_start + pnc_idx;
-		MVMACLEARN_DEBUG_PRINT("PnC index: %d\n", pnc_idx);
-		/*Get FDB entry by PnCidx*/
-		if (!mac_learn_db_entry_info_by_pncidx(pnc_idx, &fdb_idx, NULL)) {
-			MVMACLEARN_DEBUG_PRINT("FDB index: %d\n", fdb_idx);
-			/*get lock*/
-			mac_learn_tpm_api_lock_get(MAC_LEARN_TPM_API_LOCK_DEL);
-			if (!tpm_del_mac_learn_rule(tpm_owner_id, &del_mac_key)) {
-				/*release lock*/
-				mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_DEL);
-				/*Update FDB first*/
-				if (TPM_RANGE_TYPE_ACL == range_conf.range_type)
-					mac_learn_db_pncidx_update(0, pnc_idx);
-				if (mac_learn_db_entry_del(fdb_idx)) {
-					MVMACLEARN_ERR_PRINT("MAC learn FDB del failed\n");
-					return MAC_LEARN_FAIL;
-				} else {
-					/*start learn again, if fdb full, maybe learn is disabled*/
-					if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_TRAP)) {
-						MVMACLEARN_ERR_PRINT("MAC learn default rule action set failed\n");
-						return MAC_LEARN_FAIL;
-					}
-				}
-			} else {
-				/*release lock*/
-				mac_learn_tpm_api_lock_release(MAC_LEARN_TPM_API_LOCK_DEL);
-				MVMACLEARN_ERR_PRINT("tpm_del_mac_learn_rule failed\n");
-				return MAC_LEARN_FAIL;
-			}
-		} else {
-			MVMACLEARN_ERR_PRINT("mac_learn_db_entry_info_by_pncidx failed\n");
-			return MAC_LEARN_FAIL;
-		}
-		/*del success*/
-		return MAC_LEARN_OK;
-	} else {
-		MVMACLEARN_ERR_PRINT("tpm_proc_find_mac_addr_db failed\n");
-		return MAC_LEARN_FAIL;
-	}
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.h
deleted file mode 100644
index 6f3a682..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_logic.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_logic.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_logic_h__
-#define __mv_mac_learn_logic_h__
-
-/* GMAC MAC leanring ON
-------------------------------------------------------------------------------*/
-#define MAC_LEARN_ON_GMAC 0
-
-/* Function protype
-------------------------------------------------------------------------------*/
-void mv_mac_learn_aging(unsigned long mac_learn_aging);
-void mv_mac_learn_pnc_rule_add(struct work_struct *work);
-int32_t mv_mac_learn_logic_static_add(char *static_mac_addr);
-int32_t mv_mac_learn_logic_static_del(char *static_mac_addr);
-
-#endif
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.c
deleted file mode 100644
index 032a304..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.c
+++ /dev/null
@@ -1,720 +0,0 @@
-/*******************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-******************************************************************************/
-
-/******************************************************************************
-**  FILE        : mv_mac_learn_mod.c                                         **
-**                                                                           **
-**  DESCRIPTION : This file implements MAC learn module init                 **
-*******************************************************************************
-*                                                                             *
-*  MODIFICATION HISTORY:                                                      *
-*                                                                             *
-*   12June2012  Evan Wang   created                                           *
-* =========================================================================== *
-******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include "mv_mac_learn_header.h"
-
-/* Global variable */
-mac_learn_t mc_mac_learn;
-uint32_t mac_learn_glob_trace = 0;
-
-/*******************************************************************************
-* mac_learn_queue_work_insert()
-*
-* DESCRIPTION:  Insert a work into work queue for mac learning.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* void
-* COMMENTS:
-*
-*******************************************************************************/
-int mac_learn_queue_work_insert(void)
-{
-	if (true == mc_mac_learn.queue_init)
-		return queue_work(mc_mac_learn.mac_learn_queue, &mc_mac_learn.mac_learn_work);
-	return 0;
-}
-
-/*******************************************************************************
-* mac_learn_tpm_api_lock_get()
-*
-* DESCRIPTION:  Get spin lock for tpm api.
-*
-* INPUTS:
-* lock_type: TPM api, add or del
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* void
-* COMMENTS:
-*
-*******************************************************************************/
-void mac_learn_tpm_api_lock_get(mac_learn_tpm_lock_t lock_type)
-{
-	/*get lock*/
-	spin_lock(&mc_mac_learn.tpm_api_lock[lock_type]);
-}
-
-/*******************************************************************************
-* mac_learn_tpm_api_lock_release()
-*
-* DESCRIPTION:  Release spin lock for tpm api.
-*
-* INPUTS:
-* lock_type: TPM api, add or del
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* void
-* COMMENTS:
-*
-*******************************************************************************/
-void mac_learn_tpm_api_lock_release(mac_learn_tpm_lock_t lock_type)
-{
-	/*release lock*/
-	spin_unlock(&mc_mac_learn.tpm_api_lock[lock_type]);
-}
-
-/*******************************************************************************
-* mv_mac_learn_queue_write()
-*
-* DESCRIPTION:  Write the mac address to learn into buffer queue.
-*
-* INPUTS:
-* src_mac: pointer to mac address to learn
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* failed --MAC_LEARN_FAIL
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_queue_write(char *src_mac)
-{
-	uint32_t i;
-
-	if (down_trylock(&mc_mac_learn.sc_mac_queue.queue_sem))
-		return MAC_LEARN_FAIL;
-
-	for (i = 0; i < MAC_LEARN_QUEUE_SIZE; i ++) {
-		if (!memcmp(mc_mac_learn.sc_mac_queue.mc_src_mac[i].mac_addr_entry, src_mac, MV_MAC_ADDR_SIZE)) {
-			up(&mc_mac_learn.sc_mac_queue.queue_sem);
-			return MAC_LEARN_FAIL;
-		}
-	}
-
-	if (mc_mac_learn.sc_mac_queue.queue_full) {
-		up(&mc_mac_learn.sc_mac_queue.queue_sem);
-		return MAC_LEARN_FAIL;
-	}
-
-	memcpy(mc_mac_learn.sc_mac_queue.mc_src_mac[mc_mac_learn.sc_mac_queue.wr_idx].mac_addr_entry,
-	       src_mac, sizeof(char) * MV_MAC_ADDR_SIZE);
-
-	/* insert work queue, if failed remove MAC from cycle buffer */
-	if (1 != mac_learn_queue_work_insert()) {
-		memset(mc_mac_learn.sc_mac_queue.mc_src_mac[mc_mac_learn.sc_mac_queue.wr_idx].mac_addr_entry, 0,
-		       sizeof(char) * MV_MAC_ADDR_SIZE);
-		up(&mc_mac_learn.sc_mac_queue.queue_sem);
-		return MAC_LEARN_FAIL;
-	}
-
-	mc_mac_learn.sc_mac_queue.wr_idx++;
-	if (mc_mac_learn.sc_mac_queue.wr_idx == MAC_LEARN_QUEUE_SIZE)
-		mc_mac_learn.sc_mac_queue.wr_idx = 0;
-	if (mc_mac_learn.sc_mac_queue.wr_idx == mc_mac_learn.sc_mac_queue.rd_idx)
-		mc_mac_learn.sc_mac_queue.queue_full = true;
-
-	if (mc_mac_learn.sc_mac_queue.queue_empty)
-		mc_mac_learn.sc_mac_queue.queue_empty = false;
-
-	up(&mc_mac_learn.sc_mac_queue.queue_sem);
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_queue_read()
-*
-* DESCRIPTION:  Read the mac address to learn in buffer queue.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* src_mac: pointer to mac address to learn
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* failed --MAC_LEARN_FAIL
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_queue_read(char *src_mac)
-{
-	if (down_interruptible(&mc_mac_learn.sc_mac_queue.queue_sem))
-		return MAC_LEARN_FAIL;
-
-	if (mc_mac_learn.sc_mac_queue.queue_empty) {
-		up(&mc_mac_learn.sc_mac_queue.queue_sem);
-		return MAC_LEARN_FAIL;
-	}
-
-	memcpy(src_mac, mc_mac_learn.sc_mac_queue.mc_src_mac[mc_mac_learn.sc_mac_queue.rd_idx].mac_addr_entry,
-	       sizeof(char) * MV_MAC_ADDR_SIZE);
-	memset(mc_mac_learn.sc_mac_queue.mc_src_mac[mc_mac_learn.sc_mac_queue.rd_idx].mac_addr_entry, 0,
-	       sizeof(char) * MV_MAC_ADDR_SIZE);
-	mc_mac_learn.sc_mac_queue.rd_idx++;
-	if (mc_mac_learn.sc_mac_queue.rd_idx == MAC_LEARN_QUEUE_SIZE)
-		mc_mac_learn.sc_mac_queue.rd_idx = 0;
-	if (mc_mac_learn.sc_mac_queue.wr_idx == mc_mac_learn.sc_mac_queue.rd_idx)
-		mc_mac_learn.sc_mac_queue.queue_empty = true;
-
-	if (mc_mac_learn.sc_mac_queue.queue_full)
-		mc_mac_learn.sc_mac_queue.queue_full = false;
-
-	up(&mc_mac_learn.sc_mac_queue.queue_sem);
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_enable_set()
-*
-* DESCRIPTION:  Set the enable state of mac learning.
-*
-* INPUTS:
-* mac_learn_enable: enable state
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_enable_set(bool mac_learn_enable)
-{
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	tpm_db_pnc_range_conf_t range_conf;
-	tpm_init_pnc_mac_learn_enable_t pnc_mac_learn_enable;
-	tpm_gmacs_enum_t lpk_gmac;
-	uint32_t data_queue, mac_larn_queue;
-	uint32_t lpk_gmac_mh_en;
-
-	/*check original value and new value, if equal, return OK*/
-	if (mac_learn_enable == mc_mac_learn.mac_learn_enable)
-		return MAC_LEARN_OK;
-
-	if (true == mac_learn_enable) {
-		/*check TPM init succeed or not, before enable MAC learning*/
-		if (!tpm_db_init_done_get()) {
-			MVMACLEARN_ERR_PRINT("TPM initialization not success\n");
-			return MAC_LEARN_FAIL;
-		}
-		/*check TPM XML pnc_mac_learn_enable*/
-		tpm_db_pnc_mac_learn_enable_get(&pnc_mac_learn_enable);
-		if (TPM_PNC_MAC_LEARN_DISABLED == pnc_mac_learn_enable) {
-			MVMACLEARN_ERR_PRINT("TPM XML para pnc_mac_learn_enable not enabled\n");
-			return MAC_LEARN_FAIL;
-		}
-		/*Set MAX count to min(range_size, FDB_max_count)*/
-		if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-			MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-			return MAC_LEARN_FAIL;
-		}
-		if (range_conf.api_end - range_conf.api_start + 1 > MAC_LEARN_FDB_MAX_COUNT)
-			mc_mac_learn.mac_learn_max_count = MAC_LEARN_FDB_MAX_COUNT / 2;
-		else
-			mc_mac_learn.mac_learn_max_count = (range_conf.api_end - range_conf.api_start + 1) / 2;
-		MVMACLEARN_DEBUG_PRINT("non-static entry max count: %d\n",mc_mac_learn.mac_learn_max_count);
-
-		/* set PMT entry for MH modification on GMAC1 */
-		/*check data queue and mac learn queue, if equal, return error*/
-		if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-							   &data_queue,
-							   TPM_GMAC1_QUEUE_DATA_TRAFFIC)) {
-			MVMACLEARN_ERR_PRINT("loopback gmac data queue get failed \n");
-			return MAC_LEARN_FAIL;
-		}
-		if (TPM_DB_OK != tpm_db_gmac_lpk_queue_get(&lpk_gmac,
-							   &mac_larn_queue,
-							   TPM_GMAC1_QUEUE_MAC_LEARN_TRAFFIC)) {
-			MVMACLEARN_ERR_PRINT("loopback gmac mac learn queue get failed \n");
-			return MAC_LEARN_FAIL;
-		}
-		if (data_queue == mac_larn_queue) {
-			MVMACLEARN_ERR_PRINT("loopback gmac Tx queue %d for data traffix and MAC learn equal\n",
-					     data_queue);
-			return MAC_LEARN_FAIL;
-		}
-		MVMACLEARN_DEBUG_PRINT("lpk gmac %d Tx queue for mac learn: %d\n", lpk_gmac, mac_larn_queue);
-
-		/* limit band width on Tx mac learn queue of lpk gmac */
-		if (mvNetaTxqBurstSet((int)lpk_gmac, 0, mac_larn_queue, MAC_LEARN_BUCKET_SIZE) ||
-		    mvNetaTxqRateSet((int)lpk_gmac, 0, mac_larn_queue, MAC_LEARN_RATE_LIMIT)) {
-			MVMACLEARN_ERR_PRINT("MAC learning CPU rate limit on queue %d failed\n", mac_larn_queue);
-			return MAC_LEARN_FAIL;
-		}
-
-		/* Check MH on lpk gmac */
-		if (tpm_db_gmac_mh_en_conf_get(lpk_gmac, &lpk_gmac_mh_en)) {
-			MVMACLEARN_ERR_PRINT("Marvell Header enable info get failed on GMAC%d\n", lpk_gmac);
-			return MAC_LEARN_FAIL;
-		}
-		if (!lpk_gmac_mh_en) {
-			MVMACLEARN_ERR_PRINT("Marvell Header is not enabled on GMAC%d\n", lpk_gmac);
-			return MAC_LEARN_FAIL;
-		}
-
-		/* Trap packet to CPU */
-		if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_TRAP)) {
-			MVMACLEARN_ERR_PRINT("TPM default rule action set failed\n");
-			return MAC_LEARN_FAIL;
-		}
-		/*Add timer*/
-		add_timer(&mc_mac_learn.mac_learn_timer);
-	} else {
-		/*delete timer*/
-		del_timer(&mc_mac_learn.mac_learn_timer);
-		/*Forward packet to GMAC1*/
-		if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_CONTINUE)) {
-			MVMACLEARN_ERR_PRINT("TPM default rule action set failed\n");
-			return MAC_LEARN_FAIL;
-		}
-		/*Reset FDB and delete PNC rule*/
-		if (mac_learn_db_reset()) {
-			MVMACLEARN_ERR_PRINT("FDB reset failed\n");
-			return MAC_LEARN_FAIL;
-		}
-	}
-
-	mc_mac_learn.mac_learn_enable = mac_learn_enable;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_enable_get()
-*
-* DESCRIPTION:  Get the enable state of mac learning.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* mac_learn_enable: enable state
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_enable_get(bool *mac_learn_enable)
-{
-	*mac_learn_enable = mc_mac_learn.mac_learn_enable;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_overwrite_set()
-*
-* DESCRIPTION:  Set the enable state of overwrite if non-static up to max.
-*
-* INPUTS:
-* overwrite_enable: enable state
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_overwrite_set(bool overwrite_enable)
-{
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-
-	if ((true == overwrite_enable) && true == (mc_mac_learn.mac_learn_enable)) {
-		/* Trap packet to CPU when enable overwrite */
-		if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_TRAP)) {
-			MVMACLEARN_ERR_PRINT("MAC learn default rule action set failed\n");
-			return MAC_LEARN_FAIL;
-		}
-	}
-	mc_mac_learn.mac_learn_overwrite_enable = overwrite_enable;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_overwrite_get()
-*
-* DESCRIPTION:  Get the enable state of overwrite if non-static up to max.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* overwrite_enable: enable state
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_overwrite_get(bool *overwrite_enable)
-{
-	*overwrite_enable = mc_mac_learn.mac_learn_overwrite_enable;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_max_count_set()
-*
-* DESCRIPTION:  Set the max count of non-static entry.
-*
-* INPUTS:
-* mac_learn_max_count: max count
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_max_count_set(uint32_t mac_learn_max_count)
-{
-	const uint32_t tpm_owner_id = TPM_MOD_OWNER_TPM;
-	uint32_t non_static_count, valid_count, pnc_count;
-	tpm_db_pnc_range_conf_t range_conf;
-
-	if (true == mc_mac_learn.mac_learn_enable) {
-		MVMACLEARN_DEBUG_PRINT("Old max count: %d, New max count: %d\n", mc_mac_learn.mac_learn_max_count, mac_learn_max_count);
-		if (mac_learn_max_count < mc_mac_learn.mac_learn_max_count) {
-			if (!mac_learn_db_nonstatic_count_get(&non_static_count)) {
-				MVMACLEARN_DEBUG_PRINT("Current non-static num: %d\n", non_static_count);
-				if (mac_learn_max_count < non_static_count) {
-					/*delete timer*/
-					del_timer(&mc_mac_learn.mac_learn_timer);
-					/*Clear non-static in FDB and delete PNC rule*/
-					mc_mac_learn.mac_learn_enable = false;
-					if (mac_learn_db_nonstatic_clear()) {
-						mc_mac_learn.mac_learn_enable = true;
-						/*add timer*/
-						add_timer(&mc_mac_learn.mac_learn_timer);
-						MVMACLEARN_ERR_PRINT("FDB non-static entry clear failed\n");
-						return MAC_LEARN_FAIL;
-					}
-					mc_mac_learn.mac_learn_max_count = mac_learn_max_count;
-					mc_mac_learn.mac_learn_enable = true;
-					/*add timer*/
-					add_timer(&mc_mac_learn.mac_learn_timer);
-				} else
-					mc_mac_learn.mac_learn_max_count = mac_learn_max_count;
-			} else {
-				return MAC_LEARN_FAIL;
-			}
-		} else {
-			/* Get available PNC number */
-			if (tpm_db_pnc_rng_conf_get(TPM_PNC_MAC_LEARN, &range_conf)){
-				MVMACLEARN_ERR_PRINT("TPM PnC range info get failed\n");
-				return MAC_LEARN_FAIL;
-			}
-			pnc_count = range_conf.api_end - range_conf.api_start + 1;
-			if (mac_learn_db_valid_count_get(&valid_count) || mac_learn_db_nonstatic_count_get(&non_static_count))
-				return MAC_LEARN_FAIL;
-			if (mac_learn_max_count > (pnc_count - (valid_count - non_static_count))) {
-				MVMACLEARN_ERR_PRINT("Non enough free entry left\n");
-				return MAC_LEARN_FAIL;
-			}
-			mc_mac_learn.mac_learn_max_count = mac_learn_max_count;
-		}
-		/*Trap packet to CPU*/
-		if (tpm_mac_learn_default_rule_act_set(tpm_owner_id, TPM_UNK_MAC_TRAP)) {
-			MVMACLEARN_ERR_PRINT("TPM default rule action set failed\n");
-			return MAC_LEARN_FAIL;
-		}
-	} else {
-		mc_mac_learn.mac_learn_max_count = mac_learn_max_count;
-	}
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_max_count_get()
-*
-* DESCRIPTION:  Get the max count of non-static entry.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* mac_learn_max_count: max count
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_max_count_get(uint32_t *mac_learn_max_count)
-{
-	*mac_learn_max_count = mc_mac_learn.mac_learn_max_count;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_expire_set()
-*
-* DESCRIPTION:  Set the non-static entry expired time.
-*
-* INPUTS:
-* mac_learn_expire_time: expired time (s)
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_expire_set(uint32_t mac_learn_expire_time)
-{
-	/*Set new expired time*/
-	mc_mac_learn.mac_learn_expire_time = mac_learn_expire_time;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_expire_get()
-*
-* DESCRIPTION:  Get the non-static entry expired time.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* mac_learn_expire_time: expired time (s)
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_expire_get(uint32_t *mac_learn_expire_time)
-{
-	*mac_learn_expire_time = mc_mac_learn.mac_learn_expire_time;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_op_trace_level_set()
-*
-* DESCRIPTION:  Set the trace level for print info.
-*
-* INPUTS:
-* trace_level: trace level for print info
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* success--MAC_LEARN_OK
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_op_trace_level_set(uint32_t trace_level)
-{
-	/*Set trace level*/
-	mac_learn_glob_trace = trace_level;
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_var_init()
-*
-* DESCRIPTION: Init variable mac_learn_t *mc_mac_learn.
-*
-* INPUTS:
-* mc_mac_learn    Variable to init
-* aging_func      Function pointer for aging of non-static MAC learning entry
-* queue_work_func Function pointer for work queue, used to receive packet to CPU
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* Init success--MAC_LEARN_OK
-* Init failed --MAC_LEARN_FAIL
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_var_init(mac_learn_t *mc_mac_learn, void (*aging_func)(unsigned long mac_learn_aging), void (*queue_work_func)(struct work_struct *work))
-{
-	/* Input Check */
-	if (NULL == mc_mac_learn || NULL == aging_func) {
-		MVMACLEARN_ERR_PRINT("Invalid input, pointer NULL\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	/* Default init to disable mac learning */
-	mc_mac_learn->mac_learn_enable = false;
-	/* Default init to disable overwrite action after full */
-	mc_mac_learn->mac_learn_overwrite_enable = false;
-	/* Max count set to API range size */
-	mc_mac_learn->mac_learn_max_count = MAC_LEARN_NON_STATIC_DEFAULT;
-	/* Default expired time set to 300s*/
-	mc_mac_learn->mac_learn_expire_time = MAC_LEARN_EX_TIME_DEFAULT;
-	/* Init source MAC queue */
-	memset(mc_mac_learn->sc_mac_queue.mc_src_mac, 0, sizeof(src_mac_addr_t)*MAC_LEARN_QUEUE_SIZE);
-	mc_mac_learn->sc_mac_queue.rd_idx = 0;
-	mc_mac_learn->sc_mac_queue.wr_idx = 0;
-	mc_mac_learn->sc_mac_queue.queue_empty = true;
-	mc_mac_learn->sc_mac_queue.queue_full = false;
-	sema_init(&mc_mac_learn->sc_mac_queue.queue_sem, 1);
-	/* Init timer for aging */
-	init_timer(&mc_mac_learn->mac_learn_timer);
-	mc_mac_learn->mac_learn_timer.function = aging_func;
-	mc_mac_learn->mac_learn_timer.data = (unsigned long)mc_mac_learn;
-	mc_mac_learn->mac_learn_timer.expires = jiffies + HZ;
-	/*Init overwrite time*/
-	mc_mac_learn->mac_learn_overwrite_time = jiffies;
-	/* Init work queue for PnC rule adding */
-	mc_mac_learn->mac_learn_queue = create_workqueue("mac_work_queue");
-	INIT_WORK(&mc_mac_learn->mac_learn_work, queue_work_func);
-	mc_mac_learn->queue_init = true;
-
-	/*Init tpm api spin lock*/
-	spin_lock_init(&mc_mac_learn->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_ADD]);
-	spin_lock_init(&mc_mac_learn->tpm_api_lock[MAC_LEARN_TPM_API_LOCK_DEL]);
-
-	/* Debug Info */
-	MVMACLEARN_DEBUG_PRINT("MAC learn default init: enable = %d, mac_learn_max_count = %d, mac_learn_expire_time = %d\n",
-				mc_mac_learn->mac_learn_enable, mc_mac_learn->mac_learn_max_count, mc_mac_learn->mac_learn_expire_time);
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_module_exit()
-*
-* DESCRIPTION: Finish all initialization for module insmod.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* Init success--MAC_LEARN_OK
-* Init failed --MAC_LEARN_FAIL
-* COMMENTS:
-*
-*******************************************************************************/
-static int __init mv_mac_learn_module_init(void)
-{
-	/* Init Global Valriable */
-	if (mv_mac_learn_var_init(&mc_mac_learn, mv_mac_learn_aging, mv_mac_learn_pnc_rule_add)) {
-		MVMACLEARN_ERR_PRINT("MAC learn global variable init failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* Init FDB */
-	if (mac_learn_fdb_init()) {
-		MVMACLEARN_ERR_PRINT("MAC learn global variable init failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/* Init Netdev */
-	if (mv_mac_learn_netdev_init()) {
-		MVMACLEARN_ERR_PRINT("MAC learn netdev init failed\n");
-		return MAC_LEARN_FAIL;
-	}
-	/*Init sysfs*/
-	if(mv_mac_learn_sysfs_init()) {
-		MVMACLEARN_ERR_PRINT("MAC learn sysfs init failed\n");
-		return MAC_LEARN_FAIL;
-	}
-
-	return MAC_LEARN_OK;
-}
-
-/*******************************************************************************
-* mv_mac_learn_module_exit()
-*
-* DESCRIPTION: Release related resources when module del.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* void
-*
-* COMMENTS:
-*
-*******************************************************************************/
-static void __exit mv_mac_learn_module_exit(void)
-{
-	/*release sysfs*/
-	mv_mac_learn_sysfs_exit();
-}
-
-device_initcall_sync(mv_mac_learn_module_init);
-
-module_exit(mv_mac_learn_module_exit);
-
-MODULE_AUTHOR("Evan Wang");
-MODULE_DESCRIPTION("MAC learn module for Media Convert");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.h
deleted file mode 100644
index 5b7bfe2..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_mod.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_mod.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_mod_h__
-#define __mv_mac_learn_mod_h__
-
-/* MACRO
-------------------------------------------------------------------------------*/
-
-#define MAC_LEARN_QUEUE_SIZE 128
-#define MAC_LEARN_EX_TIME_DEFAULT 300
-#define MAC_LEARN_NON_STATIC_DEFAULT 4
-
-/*Debug info*/
-extern uint32_t mac_learn_glob_trace;
-
-#define MAC_LEARN_GLOB_TRACE mac_learn_glob_trace
-#define MAC_LEARN_DEBUG_MASK  0x00000001
-#define MAC_LEARN_WARN_MASK   0x00000002
-#define MAC_LEARN_ERR_MASK    0x00000004
-
-#define MVMACLEARN_DEBUG_PRINT(format , ...) \
-	{ \
-		if (MAC_LEARN_DEBUG_MASK & MAC_LEARN_GLOB_TRACE) \
-			printk("%s(%d):  "format,__FUNCTION__,__LINE__, ##__VA_ARGS__); \
-	}
-
-#define MVMACLEARN_WARN_PRINT(format , ...) \
-	{ \
-		if (MAC_LEARN_WARN_MASK & MAC_LEARN_GLOB_TRACE) \
-			printk("%s(%d) WARN:  "format,__FUNCTION__,__LINE__, ##__VA_ARGS__); \
-	}
-
-#define MVMACLEARN_ERR_PRINT(format, ...)     printk("%s(%d) ERROR:  "format,__FUNCTION__,__LINE__, ##__VA_ARGS__)
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-typedef enum
-{
-	MAC_LEARN_TPM_API_LOCK_ADD,
-	MAC_LEARN_TPM_API_LOCK_DEL,
-	MAC_LEARN_TPM_API_LOCK_MAX
-} mac_learn_tpm_lock_t;
-
-
-typedef struct {
-	char mac_addr_entry[MV_MAC_ADDR_SIZE];
-}src_mac_addr_t;
-
-typedef struct {
-	struct semaphore queue_sem;
-	src_mac_addr_t mc_src_mac[MAC_LEARN_QUEUE_SIZE];
-	uint32_t wr_idx;
-	uint32_t rd_idx;
-	bool queue_empty;
-	bool queue_full;
-}src_mac_queue_t;
-
-typedef struct {
-	volatile bool mac_learn_enable;
-	bool mac_learn_overwrite_enable;/*Used to control the action after full */
-	uint32_t mac_learn_max_count;/*Non-static max count*/
-	uint32_t mac_learn_expire_time;
-	uint32_t mac_learn_overwrite_time;
-	bool queue_init;
-	struct workqueue_struct *mac_learn_queue;
-	struct work_struct mac_learn_work;
-	src_mac_queue_t sc_mac_queue;/*Used to store MAC address from network*/
-	struct timer_list mac_learn_timer;
-	spinlock_t tpm_api_lock[MAC_LEARN_TPM_API_LOCK_MAX];
-} mac_learn_t;
-
-/* Function protype
-------------------------------------------------------------------------------*/
-int mac_learn_queue_work_insert(void);
-void mac_learn_tpm_api_lock_get(mac_learn_tpm_lock_t lock_type);
-void mac_learn_tpm_api_lock_release(mac_learn_tpm_lock_t lock_type);
-int mv_mac_learn_queue_write(char *src_mac);
-int mv_mac_learn_queue_read(char *src_mac);
-int mv_mac_learn_op_enable_set(bool mac_learn_enable);
-int mv_mac_learn_op_enable_get(bool *mac_learn_enable);
-int mv_mac_learn_op_overwrite_set(bool overwrite_enable);
-int mv_mac_learn_op_overwrite_get(bool *overwrite_enable);
-int mv_mac_learn_op_max_count_set(uint32_t mac_learn_max_count);
-int mv_mac_learn_op_max_count_get(uint32_t *mac_learn_max_count);
-int mv_mac_learn_op_expire_set(uint32_t mac_learn_expire_time);
-int mv_mac_learn_op_expire_get(uint32_t *mac_learn_expire_time);
-int mv_mac_learn_op_trace_level_set(uint32_t trace_level);
-
-
-#endif /* __mv_mac_learn_mod_h__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.c
deleted file mode 100644
index 5fb0b31..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_netdev.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include <ctrlEnv/mvCtrlEnvLib.h>
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include "mv_mac_learn_header.h"
-
-/*******************************************************************************
-* mv_mac_learn_eth_rx_func()
-*
-* DESCRIPTION:    Special RX function of mv_eth_rx in mv_netdev.c
-*
-* INPUTS:
-*  port: gmac port the packet from
-*  rxq: interrupt for rx
-*  dev: net device
-*  skb: buffer to receive packet
-*  rx_desc: RX descriptor
-*
-* RETURNS:
-* void
-* COMMENTS:
-*
-*******************************************************************************/
-void mv_mac_learn_eth_rx_func(int port, int rxq, struct net_device *dev, struct sk_buff *skb, struct neta_rx_desc *rx_desc)
-{
-	struct ethhdr *eth_hdr1;
-	bool mac_learn_enable = false;
-
-	/*check mac learn enable*/
-	if (mv_mac_learn_op_enable_get(&mac_learn_enable))
-		return;
-	if (false == mac_learn_enable)
-		return;
-
-	/* get source MAC address */
-	eth_hdr1 = eth_hdr(skb);
-	mv_mac_learn_queue_write(eth_hdr1->h_source);
-}
-
-/*******************************************************************************
-* mv_mac_learn_netdev_init()
-*
-* DESCRIPTION:    register special RX function netdev
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* Init success--0
-* COMMENTS:
-*
-*******************************************************************************/
-int mv_mac_learn_netdev_init(void)
-{
-	uint32_t port_i;
-	int mv_eth_ports_num = 0;
-
-	/* Retrieve num_ports, as in mv_eth_init_module*/
-	mv_eth_ports_num = mvCtrlEthMaxPortGet();
-
-	if (mv_eth_ports_num > CONFIG_MV_ETH_PORTS_NUM)
-		mv_eth_ports_num = CONFIG_MV_ETH_PORTS_NUM;
-
-	/* Register mac learn parse function */
-	for (port_i=0;port_i< mv_eth_ports_num;port_i++) {
-		if (port_i == 0 || port_i == 1)
-			mv_eth_rx_mac_learn_func(port_i, mv_mac_learn_eth_rx_func);
-		else
-			mv_eth_rx_mac_learn_func(port_i, NULL);
-	}
-
-	return 0;
-}
\ No newline at end of file
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.h
deleted file mode 100644
index 8a153ab..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_netdev.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_netdev.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_netdev_h__
-#define __mv_mac_learn_netdev_h__
-
-/* Function protype
-------------------------------------------------------------------------------*/
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <net/ip.h>
-
-#include <mvCommon.h>
-#include <mvOs.h>
-#include <mv_neta/net_dev/mv_netdev.h>
-
-/* Function protype
-------------------------------------------------------------------------------*/
-int mv_mac_learn_netdev_init(void);
-
-#endif /* __mv_mac_learn_netdev_h__ */
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.c b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.c
deleted file mode 100644
index 5831e77..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.c
+++ /dev/null
@@ -1,790 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_sysfsc.c
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#include "tpm_common.h"
-#include "tpm_header.h"
-
-#include "mv_mac_learn_header.h"
-
-/*******************************************************************************
-* sys_mac_learn_parse_addr
-*
-* DESCRIPTION:
-*           This function parses MAC address
-* INPUTS:
-*       buf - buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       bool
-*******************************************************************************/
-static bool sys_mac_learn_parse_addr (char *buf, uint32_t *macaddr_parts)
-{
-	if (6 == sscanf(buf, "%x:%x:%x:%x:%x:%x", &macaddr_parts[0], &macaddr_parts[1], &macaddr_parts[2], &macaddr_parts[3],
-	    &macaddr_parts[4], &macaddr_parts[5])) {
-		if (macaddr_parts[0] <= 255 && macaddr_parts[1] <= 255 && macaddr_parts[2] <= 255 && macaddr_parts[3] <= 255 &&
-		    macaddr_parts[4] <= 255 && macaddr_parts[5] <= 255)
-			return true;
-
-	}
-	return false;
-}
-
-/*******************************************************************************
-* sys_mac_learn_count_para
-*
-* DESCRIPTION:
-*           This function get the number of input parameters
-* INPUTS:
-*       buf - buffer with parameter string
-*
-* OUTPUTS:
-        NONE.
-*
-* RETURNS:
-*       int, number of input para
-*******************************************************************************/
-static int sys_mac_learn_count_para (const char *buf)
-{
-	char bufcopy[513];
-	char **ap, *argv[20];
-	char *inputstring = bufcopy;
-	int numparms = 0;
-
-	strcpy(bufcopy, buf);
-
-	for (ap = argv; ap < &argv[15] && (*ap = strsep(&inputstring, " \t")) != NULL;) {
-		if (**ap != '\0') {
-			ap++;
-			numparms++;
-		}
-	}
-	return numparms;
-}
-
-/***********************************************************************************
-**
-**  sfs_help_mac_learn_cfg_all - help for mac learn sysfs commands under cfg folder
-**
-************************************************************************************/
-int sfs_help_mac_learn_cfg_all(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "\necho [src_mac] > mac_learn_static_entry_add   - add one static MAC learn entry\n");
-	off += sprintf(buf+off, "\necho [src_mac] > mac_learn_static_entry_del   - del one static MAC learn entry\n");
-	off += sprintf(buf+off, "\tsrc_mac         (str)aa:bb:cc:dd:ee:ff  where each part is hexadecimal in range 0..FF\n");
-
-	off += sprintf(buf+off, "\n");
-
-	off += sprintf(buf+off, "\necho [enable] > mac_learn_enable   - enable/disable MAC learning\n");
-	off += sprintf(buf+off, "\necho [enable] > mac_learn_overwrite_enable   - enable/disable non-static MAC entry overwrite when FDB full\n");
-	off += sprintf(buf+off, "\tenable          (dec)0: disable, 1: enable\n");
-
-	off += sprintf(buf+off, "\n");
-
-	off += sprintf(buf+off, "\necho [max_count] > mac_learn_max_count_set   - Set max count of MAC learning \n");
-	off += sprintf(buf+off, "\tmax_count       (dec)Should not greater than PNC range size\n");
-
-	off += sprintf(buf+off, "\n");
-
-	off += sprintf(buf+off, "\necho [expired_time] > mac_learn_expired_time_set   - Set expired time for non-static MAC learning entry\n");
-	off += sprintf(buf+off, "\texpired_time    (dec)unit: second\n");
-
-	off += sprintf(buf+off, "\n");
-
-	off += sprintf(buf+off, "\necho [trace_level] > mac_learn_trace_level   - Set trace level for print info\n");
-	off += sprintf(buf+off, "\ttrace_level     (dec)0: no trace, 1: debug level, 2: warn level\n");
-
-	off += sprintf(buf+off, "\n");
-
-	return(off);
-}
-
-/*******************************************************************************
-* sfs_mac_learn_static_entry_add
-*
-* DESCRIPTION:
-*           This function adds static MAC address as MAC learn entry
-*
-*
-*******************************************************************************/
-void sfs_mac_learn_static_entry_add(const char *buf, size_t len)
-{
-	typedef enum {
-		mac_learn_static_mac, mac_learn_static_max
-	} l2_mac_rule_parm_indx_t;
-
-	uint32_t sa[6];
-	char temp_sa[30];
-	int numparms;
-	char src_mac[6];
-	int parsedargs;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_static_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%s", temp_sa);
-
-		if (sys_mac_learn_parse_addr(temp_sa, sa) == false) {
-			MVMACLEARN_ERR_PRINT("Invalid SA [%s]\n", temp_sa);
-		} else {
-			src_mac[0] = (char)sa[0];
-			src_mac[1] = (char)sa[1];
-			src_mac[2] = (char)sa[2];
-			src_mac[3] = (char)sa[3];
-			src_mac[4] = (char)sa[4];
-			src_mac[5] = (char)sa[5];
-			if (mv_mac_learn_static_entry_add(src_mac))
-				MVMACLEARN_ERR_PRINT("Faild to add static MAC entry");
-			else
-				printk("OK.\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_static_entry_del
-*
-* DESCRIPTION:
-*           This function deletes static MAC address as MAC learn entry
-*
-*
-*******************************************************************************/
-void sfs_mac_learn_static_entry_del(const char *buf, size_t len)
-{
-	typedef enum {
-		mac_learn_static_mac, mac_learn_static_max
-	} l2_mac_rule_parm_indx_t;
-
-	uint32_t sa[6];
-	char temp_sa[30];
-	int numparms;
-	char src_mac[6];
-	int parsedargs;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_static_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%s", temp_sa);
-
-		if (sys_mac_learn_parse_addr(temp_sa, sa) == false) {
-			MVMACLEARN_ERR_PRINT("Invalid SA [%s]\n", temp_sa);
-		} else {
-			src_mac[0] = (char)sa[0];
-			src_mac[1] = (char)sa[1];
-			src_mac[2] = (char)sa[2];
-			src_mac[3] = (char)sa[3];
-			src_mac[4] = (char)sa[4];
-			src_mac[5] = (char)sa[5];
-			if (mv_mac_learn_static_entry_del(src_mac))
-				MVMACLEARN_ERR_PRINT("Faild to del static MAC entry");
-			else
-				printk("OK.\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_enable_cfg
-*
-* DESCRIPTION:
-*           This function enable or disable MAC learning
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_mac_learn_enable_cfg(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_leanr_enable_bool, mac_leanr_enable_max
-	} mac_learn_enable_t;
-
-	uint32_t mac_learn_enable;
-	int parsedargs;
-	int numparms;
-
-	bool enable_para;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_leanr_enable_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &mac_learn_enable);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if (mac_learn_enable)
-				enable_para = true;
-			else
-				enable_para = false;
-			if (mv_mac_learn_enable_set(enable_para))
-				MVMACLEARN_ERR_PRINT("Faild to enable/diable MAC learning\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_overwrite_enable_cfg
-*
-* DESCRIPTION:
-*           This function enable or disable MAC learning overwrite when FDB full
-* INPUTS:
-*       buf	- Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_mac_learn_overwrite_enable_cfg(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_learn_overwrite_bool, mac_learn_overwrite_max
-	} mac_learn_overwrite_t;
-
-	uint32_t mac_learn_overwrite;
-	int parsedargs;
-	int numparms;
-
-	bool enable_para;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_overwrite_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &mac_learn_overwrite);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if (mac_learn_overwrite)
-				enable_para = true;
-			else
-				enable_para = false;
-			if (mv_mac_learn_overwrite_enable_set(enable_para))
-				MVMACLEARN_ERR_PRINT("Faild to enable/diable MAC learning overwrite function\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_max_count_cfg
-*
-* DESCRIPTION:
-*           This function set the max count of mac leanr entry
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_mac_learn_max_count_cfg(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_learn_max_count, mac_learn_max_count_max
-	} mac_learn_max_count_t;
-
-	uint32_t max_count;
-	int parsedargs;
-	int numparms;
-	int temp;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_max_count_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &temp);
-		if (temp < 0) {
-			printk(KERN_INFO "ERROR: Negative Input(%d) can not be accepted\n", temp);
-			return;
-		}
-
-		max_count = temp;
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if (mv_mac_learn_max_count_set(max_count))
-				MVMACLEARN_ERR_PRINT("Faild to cfg MAC learning max count\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_expire_time_cfg
-*
-* DESCRIPTION:
-*           This function set the expired time of non-static mac leanr entry
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_mac_learn_expired_time_cfg(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_learn_expire_time, mac_learn_expire_time_max
-	} mac_learn_expire_time_t;
-
-	uint32_t expire_time;
-	int parsedargs;
-	int numparms;
-	int temp;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_expire_time_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &temp);
-		if (temp < 0) {
-			printk(KERN_INFO "ERROR: Negative Input(%d) can not be accepted\n", temp);
-			return;
-		}
-
-		expire_time = temp;
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if (mv_mac_learn_expire_time_set(expire_time))
-				MVMACLEARN_ERR_PRINT("Faild to cfg MAC learning expired time\n");
-		}
-	}
-}
-
-/*******************************************************************************
-* sfs_mac_learn_trace_level_cfg
-*
-* DESCRIPTION:
-*           This function set the trace level of print info
-* INPUTS:
-*       buf - Shell parameters as char buffer
-*       len - Number of characters in buffer
-*
-*******************************************************************************/
-void sfs_mac_learn_trace_level_cfg(const char *buf, size_t len)
-{
-	typedef enum
-	{
-		mac_learn_trace_level, mac_learn_trace_level_max
-	} mac_learn_trace_level_t;
-
-	uint32_t trace_level;
-	int parsedargs;
-	int numparms;
-
-	numparms = sys_mac_learn_count_para(buf);
-	if (numparms != mac_learn_trace_level_max) {
-		MVMACLEARN_ERR_PRINT("Parameter number not right");
-	} else {
-		/* Get parameters */
-		parsedargs = sscanf(buf, "%d", &trace_level);
-
-		if (parsedargs != numparms) {
-			printk(KERN_INFO "Parse failure - %d/%d parameters were parsed\n", parsedargs, numparms);
-		} else {
-			if (mv_mac_learn_op_trace_level_set(trace_level))
-				MVMACLEARN_ERR_PRINT("Faild to cfg MAC learning expired time\n");
-		}
-	}
-}
-
-/***********************************************************************************
-**
-**  sfs_help_mac_learn_show_all - help for mac learn sysfs commands under show folder
-**
-************************************************************************************/
-int sfs_help_mac_learn_show_all(char *buf)
-{
-	int off = 0;
-
-	off += sprintf(buf+off, "\ncat show_mac_learn_enable             - show mac learn enable state\n");
-	off += sprintf(buf+off, "\ncat show_mac_learn_overwrite_enable   - show mac learn non-static entry overwrite enable state when FDB full\n");
-	off += sprintf(buf+off, "\ncat show_mac_learn_max_count          - show mac learn max entry count\n");
-	off += sprintf(buf+off, "\ncat show_mac_learn_expire_time        - show mac learn non-static entry expired time\n");
-	off += sprintf(buf+off, "\ncat show_mac_learn_fdb_entry          - show mac learn entries in FDB\n");
-
-	off += sprintf(buf+off, "\n");
-
-	return(off);
-}
-
-
-/*******************************************************************************
-* sfs_mac_learn_enable_get
-*
-* DESCRIPTION:
-*           This function show mac learn enable state
-*******************************************************************************/
-int sfs_mac_learn_enable_get(char *buf)
-{
-	int off = 0;
-	char result[8];
-	bool mac_learn_enable;
-
-	if (mv_mac_learn_enable_get(&mac_learn_enable)) {
-		memcpy(result, "failed", 8);
-	} else {
-		if (true == mac_learn_enable)
-			memcpy(result, "enable", 8);
-		else
-			memcpy(result, "disable", 8);
-	}
-	off += sprintf(buf+off, "\nmac learn enable get: %s\n", result);
-
-	return off;
-}
-
-/*******************************************************************************
-* sfs_mac_learn_overwrite_enable_get
-*
-* DESCRIPTION:
-*           This function show mac learn overwrite enable state when FDB full
-*******************************************************************************/
-int sfs_mac_learn_overwrite_enable_get(char *buf)
-{
-	int off = 0;
-	char result[8];
-	bool mac_learn_enable;
-
-	if (mv_mac_learn_overwrite_enable_get(&mac_learn_enable)) {
-		memcpy(result, "failed", 8);
-	} else {
-		if (true == mac_learn_enable)
-			memcpy(result, "enable", 8);
-		else
-			memcpy(result, "disable", 8);
-	}
-	off += sprintf(buf+off, "\nmac learn overwrite enable get: %s\n", result);
-
-	return off;
-}
-
-/*******************************************************************************
-* sfs_mac_learn_max_count_get
-*
-* DESCRIPTION:
-*           This function show mac learn MAX entry count configured
-*******************************************************************************/
-int sfs_mac_learn_max_count_get(char *buf)
-{
-	int off = 0;
-	char result[8];
-	uint32_t max_count;
-
-	if (mv_mac_learn_max_count_get(&max_count)) {
-		memcpy(result, "failed", 8);
-		off += sprintf(buf+off, "\nmac learn max count get: %s\n", result);
-	} else {
-		off += sprintf(buf+off, "\nmac learn max count get: %d\n", max_count);
-	}
-
-	return off;
-}
-
-/**************************************************************************************
-* sfs_mac_learn_expired_time_get
-*
-* DESCRIPTION:
-*           This function show mac learn expired time configured for non-static entry
-***************************************************************************************/
-int sfs_mac_learn_expired_time_get(char *buf)
-{
-	int off = 0;
-	char result[8];
-	uint32_t expire_time;
-
-	if (mv_mac_learn_expire_time_get(&expire_time)) {
-		memcpy(result, "failed", 8);
-		off += sprintf(buf+off, "\nmac learn expire time get: %s\n", result);
-	} else {
-		off += sprintf(buf+off, "\nmac learn expire time get: %d(s)\n", expire_time);
-	}
-
-	return off;
-}
-
-/**************************************************************************************
-* sfs_mac_learn_entry_print
-*
-* DESCRIPTION:
-*           This function print the MAC learning entries learned
-***************************************************************************************/
-int sfs_mac_learn_entry_print(char *buf)
-{
-	int off = 0;
-
-	mac_learn_db_valid_print();
-
-	return off;
-}
-
-
-
-static mac_learn_store_sysfs_func_t mac_learn_sysfs_func_ara[] =
-{
-	{"mac_learn_static_entry_add", sfs_mac_learn_static_entry_add},
-	{"mac_learn_static_entry_del", sfs_mac_learn_static_entry_del},
-	{"mac_learn_enable",           sfs_mac_learn_enable_cfg},
-	{"mac_learn_overwrite_enable", sfs_mac_learn_overwrite_enable_cfg},
-	{"mac_learn_max_count_set",    sfs_mac_learn_max_count_cfg},
-	{"mac_learn_expired_time_set", sfs_mac_learn_expired_time_cfg},
-	{"mac_learn_trace_level",      sfs_mac_learn_trace_level_cfg},
-};
-
-static int mac_learn_num_store = sizeof(mac_learn_sysfs_func_ara)/sizeof(mac_learn_sysfs_func_ara[0]);
-
-static ssize_t mac_learn_cfg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)
-{
-	const char *name = attr->attr.name;
-	mac_learn_store_sysfs_func_t *pnamefunc;
-	int indx;
-	bool found = false;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	for (indx = 0; indx < mac_learn_num_store; indx++){
-		pnamefunc = &mac_learn_sysfs_func_ara[indx];
-		if (!strcmp(name, pnamefunc->sysfs_name)) {
-			found = true;
-			(pnamefunc->sysfs_func)(buf, len);
-			break;
-		}
-	}
-
-	if (found == false){
-		printk("%s: operation <%s> not found\n", __FUNCTION__, attr->attr.name);
-	}
-
-	return(len);
-}
-
-static mac_learn_show_sysfs_func_t mac_learn_show_sysfs_func_ara[] =
-{
-	{"help_mac_learn_cfg", sfs_help_mac_learn_cfg_all},
-	{"help_mac_learn_show", sfs_help_mac_learn_show_all},
-	{"show_mac_learn_enable", sfs_mac_learn_enable_get},
-	{"show_mac_learn_overwrite_enable", sfs_mac_learn_overwrite_enable_get},
-	{"show_mac_learn_max_count", sfs_mac_learn_max_count_get},
-	{"show_mac_learn_expire_time", sfs_mac_learn_expired_time_get},
-	{"show_mac_learn_fdb_entry", sfs_mac_learn_entry_print},
-
-};
-
-static int mac_learn_num_show = sizeof(mac_learn_show_sysfs_func_ara)/sizeof(mac_learn_show_sysfs_func_ara[0]);
-
-
-static ssize_t mac_learn_cfg_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	const char *name = attr->attr.name;
-	mac_learn_show_sysfs_func_t *pnamefunc;
-	int indx;
-	bool found = false;
-	int buflen = 0;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	for (indx = 0; indx < mac_learn_num_show; indx++){
-		pnamefunc = &mac_learn_show_sysfs_func_ara[indx];
-		if (!strcmp(name, pnamefunc->sysfs_name)) {
-			found = true;
-			buflen = (pnamefunc->sysfs_func)(buf);
-			break;
-		}
-	}
-	if (found == false){
-		printk("%s: operation <%s> not found\n", __FUNCTION__, attr->attr.name);
-	}
-
-	return buflen;
-}
-
-/*store attr*/
-static DEVICE_ATTR(mac_learn_static_entry_add, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_static_entry_del, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_enable, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_overwrite_enable, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_max_count_set, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_expired_time_set, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(mac_learn_trace_level, S_IWUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-
-/*show attr*/
-static DEVICE_ATTR(help_mac_learn_cfg, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(help_mac_learn_show, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(show_mac_learn_enable, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(show_mac_learn_overwrite_enable, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(show_mac_learn_max_count, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(show_mac_learn_expire_time, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-static DEVICE_ATTR(show_mac_learn_fdb_entry, S_IRUSR, mac_learn_cfg_show, mac_learn_cfg_store);
-
-
-
-static struct attribute *mac_learn_cfg_attrs[] =
-{
-	&dev_attr_help_mac_learn_cfg.attr,
-	&dev_attr_mac_learn_static_entry_add.attr,
-	&dev_attr_mac_learn_static_entry_del.attr,
-	&dev_attr_mac_learn_enable.attr,
-	&dev_attr_mac_learn_overwrite_enable.attr,
-	&dev_attr_mac_learn_max_count_set.attr,
-	&dev_attr_mac_learn_expired_time_set.attr,
-	&dev_attr_mac_learn_trace_level.attr,
-
-	NULL
-};
-
-static struct attribute *mac_learn_show_attrs[] =
-{
-	&dev_attr_help_mac_learn_show.attr,
-	&dev_attr_show_mac_learn_enable.attr,
-	&dev_attr_show_mac_learn_overwrite_enable.attr,
-	&dev_attr_show_mac_learn_max_count.attr,
-	&dev_attr_show_mac_learn_expire_time.attr,
-	&dev_attr_show_mac_learn_fdb_entry.attr,
-	NULL
-};
-
-
-static struct attribute_group mac_learn_cfg_group =
-{
-	.name = "mac_learn_cfg",
-	.attrs = mac_learn_cfg_attrs
-};
-
-static struct attribute_group mac_learn_show_group =
-{
-	.name = "mac_learn_show",
-	.attrs = mac_learn_show_attrs
-};
-
-static mv_attr_group_pair_t mac_learn_attr_group_pair[] =
-{
-	{"mac_learn_cfg",          &mac_learn_cfg_group},
-	{"mac_learn_show",         &mac_learn_show_group},
-};
-static int num_attr_group_pairs = sizeof(mac_learn_attr_group_pair)/sizeof(mac_learn_attr_group_pair[0]);
-
-/*******************************************************************************
-* mv_mac_learn_sysfs_init()
-*
-* DESCRIPTION:    Finish all initialization for sysfs.
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* int, success--0; failed--non-zero
-*******************************************************************************/
-int mv_mac_learn_sysfs_init(void)
-{
-	int err;
-	struct device *pd;
-	int indx;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "mc_mac_learn");
-	if (!pd) {
-		platform_device_register_simple("mc_mac_learn", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "mc_mac_learn");
-	}
-
-	if (!pd) {
-		printk(KERN_ERR"%s: cannot find mc_mac_learn device\n", __FUNCTION__);
-		pd = &platform_bus;
-	}
-
-	for (indx = 0; indx < num_attr_group_pairs; indx++) {
-		mv_attr_group_pair_t *ppair;
-
-		ppair = &mac_learn_attr_group_pair[indx];
-
-		err = sysfs_create_group(&pd->kobj, ppair->pattrgroup);
-		if (err) {
-			printk(KERN_INFO "sysfs_create_group failed for %s, err = %d\n", ppair->folder_name, err);
-			goto out;
-		}
-	}
-	printk(KERN_INFO "= MC MAC LEARN Module SYS FS Init ended successfully =\n");
-
-out:
-	return err;
-}
-
-/*******************************************************************************
-* mv_mac_learn_sysfs_exit()
-*
-* DESCRIPTION:    unregister sysfs if exit
-*
-* INPUTS:
-* None
-*
-* OUTPUTS:
-* None
-*
-* RETURNS:
-* None
-*******************************************************************************/
-void mv_mac_learn_sysfs_exit(void)
-{
-	struct device *pd;
-	int indx;
-
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "mc_mac_learn");
-	if (!pd) {
-		printk(KERN_ERR"%s: cannot find mc_mac_learn device\n", __FUNCTION__);
-		return;
-	}
-
-	for (indx = 0; indx < num_attr_group_pairs; indx++) {
-		mv_attr_group_pair_t *ppair;
-		ppair = &mac_learn_attr_group_pair[indx];
-		sysfs_remove_group(&pd->kobj, ppair->pattrgroup);
-	}
-
-	printk(KERN_INFO "= MC MAC LEARN Module SYS FS Remove ended successfully =\n");
-}
diff --git a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.h b/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.h
deleted file mode 100644
index 3017992..0000000
--- a/arch/arm/plat-feroceon/mv_drivers_lsp/mv_mac_learn/mv_mac_learn_sysfs.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/************************************************************************
-* Copyright (C) 2010, Marvell Technology Group Ltd.
-* All Rights Reserved.
-*
-* This is UNPUBLISHED PROPRIETARY SOURCE CODE of Marvell Technology Group;
-* the contents of this file may not be disclosed to third parties, copied
-* or duplicated in any form, in whole or in part, without the prior
-* written permission of Marvell Technology Group.
-*
-*********************************************************************************
-* Marvell GPL License Option
-*
-* If you received this File from Marvell, you may opt to use, redistribute and/or
-* modify this File in accordance with the terms and conditions of the General
-* Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-* available along with the File in the license.txt file or by writing to the Free
-* Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-* on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-*
-* THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-* WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-* DISCLAIMED.  The GPL License provides additional details about this warranty
-* disclaimer.
-*
-*********************************************************************************
-* mv_mac_learn_sysfs.h
-*
-* DESCRIPTION:
-*
-*
-*******************************************************************************/
-#ifndef __mv_mac_learn_sysfs_h__
-#define __mv_mac_learn_sysfs_h__
-
-/* Include files
-------------------------------------------------------------------------------*/
-#include <linux/capability.h>
-#include <linux/platform_device.h>
-
-/* Typedefs
-------------------------------------------------------------------------------*/
-typedef struct {
-	char                   *folder_name;
-	struct attribute_group *pattrgroup;
-} mv_attr_group_pair_t;
-
-typedef struct
-{
-	char *sysfs_name;
-	void (*sysfs_func)(const char *buf, size_t len);
-} mac_learn_store_sysfs_func_t;
-
-typedef struct
-{
-	char *sysfs_name;
-	int (*sysfs_func)(char *buf);
-} mac_learn_show_sysfs_func_t;
-
-/* Function protype
-------------------------------------------------------------------------------*/
-int mv_mac_learn_sysfs_init(void);
-void mv_mac_learn_sysfs_exit(void);
-
-#endif
-- 
1.7.5.4

