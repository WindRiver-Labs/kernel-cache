From 06a9a4df8a74404f3c9bfcfa4ee919ba9693a5de Mon Sep 17 00:00:00 2001
From: Neta Zur <neta@marvell.com>
Date: Mon, 22 Jul 2013 11:17:16 +0300
Subject: [PATCH 0860/1825] usb: Move USB device directories from HALs to LSP
 drivers

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e764ec99e5a8dc0efab62b456e4e57d9c5c93e52

	USB device directories have GPL license, The HALs is common to all OSs, and can't include
	GPL code. Move the USB device the the mv_drivers_linux - used by the LSP only.

Change-Id: I992a0ed1b6a35a2e739e0ea05cac16ebcc5ade7a
Signed-off-by: Neta Zur <neta@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2749
Reviewed-by: Igor Patrik <igorp@marvell.com>
Tested-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile |   13 +-
 .../mv_drivers_lsp/mv_udc/mv_udc_main.c            |    4 +-
 .../mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbCh9.h   |  124 ++
 .../mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDebug.h |  109 +
 .../mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDefs.h  |  139 ++
 .../mv_udc/usb_hal/api/mvUsbDevApi.h               |  158 ++
 .../mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbTypes.h |  237 ++
 .../mv_udc/usb_hal/common/mvUsbCore.h              |  713 ++++++
 .../mv_udc/usb_hal/common/mvUsbDesc.h              |  162 ++
 .../mv_udc/usb_hal/device/mvUsbDevCh9.c            |  304 +++
 .../mv_udc/usb_hal/device/mvUsbDevMain.c           |  776 +++++++
 .../mv_udc/usb_hal/device/mvUsbDevPrv.h            |  267 +++
 .../mv_udc/usb_hal/device/mvUsbDevRecv.c           |  101 +
 .../mv_udc/usb_hal/device/mvUsbDevSend.c           |  375 ++++
 .../mv_udc/usb_hal/device/mvUsbDevUtl.c            |  634 ++++++
 .../mv_udc/usb_hal/device/mvUsbHsDevCncl.c         |  225 ++
 .../mv_udc/usb_hal/device/mvUsbHsDevMain.c         | 1870 ++++++++++++++++
 .../mv_udc/usb_hal/device/mvUsbHsDevUtl.c          |  273 +++
 .../mv_drivers_lsp/mv_udc/usb_hal/examples/disk.c  | 2298 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_udc/usb_hal/examples/disk.h  |   86 +
 .../mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.c | 1711 +++++++++++++++
 .../mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.h |   29 +
 22 files changed, 10599 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbCh9.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDebug.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDefs.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDevApi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbTypes.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbCore.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbDesc.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevCh9.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevMain.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevPrv.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevRecv.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevSend.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevUtl.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevCncl.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevMain.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevUtl.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
index 18b966d..e63dd0c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
@@ -5,16 +5,15 @@ ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-USB_DIR := ../mv_hal/usb/
-USB_PATH := $(srctree)/arch/arm/plat-feroceon/mv_hal/usb
+USB_PATH := $(srctree)/$(MACHINE)/../plat-armada/mv_drivers_lsp/mv_udc/usb_hal/
 
-USB_DEV_DIR := $(USB_DIR)/device
+USB_DEV_DIR := ./usb_hal/device
 
-EXTRA_CFLAGS += -I$(USB_PATH)/api -I$(USB_PATH)/common -I$(USB_PATH)/device
+EXTRA_CFLAGS += -I$(USB_PATH) -I$(USB_PATH)/api -I$(USB_PATH)/common -I$(USB_PATH)/device
 
-OBJS        := mv_udc_main.o ../$(USB_DEV_DIR)/mvUsbDevCh9.o ../$(USB_DEV_DIR)/mvUsbDevMain.o 	\
-               ../$(USB_DEV_DIR)/mvUsbDevRecv.o ../$(USB_DEV_DIR)/mvUsbDevSend.o ../$(USB_DEV_DIR)/mvUsbDevUtl.o 	\
-	       ../$(USB_DEV_DIR)/mvUsbHsDevUtl.o  ../$(USB_DEV_DIR)/mvUsbHsDevMain.o ../$(USB_DEV_DIR)/mvUsbHsDevCncl.o
+OBJS        := mv_udc_main.o $(USB_DEV_DIR)/mvUsbDevCh9.o $(USB_DEV_DIR)/mvUsbDevMain.o 	\
+               $(USB_DEV_DIR)/mvUsbDevRecv.o $(USB_DEV_DIR)/mvUsbDevSend.o $(USB_DEV_DIR)/mvUsbDevUtl.o 	\
+	       $(USB_DEV_DIR)/mvUsbHsDevUtl.o  $(USB_DEV_DIR)/mvUsbHsDevMain.o $(USB_DEV_DIR)/mvUsbHsDevCncl.o
 
 mv_udc-objs := $(OBJS)
 obj-m := mv_udc.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
index 7e860fc..8e5eb60 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
@@ -66,8 +66,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "config/mvSysHwConfig.h"
 #include "boardEnv/mvBoardEnvLib.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
-#include "usb/api/mvUsbDevApi.h"
-#include "usb/api/mvUsbCh9.h"
+#include "api/mvUsbDevApi.h"
+#include "api/mvUsbCh9.h"
 #include "usb/mvUsb.h"
 #include "usb/mvUsbRegs.h"
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbCh9.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbCh9.h
new file mode 100644
index 0000000..8e91566
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbCh9.h
@@ -0,0 +1,124 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbCh9_h__
+#define __mvUsbCh9_h__
+
+#include "api/mvUsbTypes.h"
+/*----------------------------------------------------------------**
+** Chapter 9.4 Standard Device Requests -- all devices            **
+** See Table 9-3 p. 250 of USB 2.0 spec for combinations          **
+**   of request type bitfields with requests, WVALUE, WINDEX etc. **
+**----------------------------------------------------------------*/
+#define REQ_RECIP_MASK          0x1f
+#define REQ_RECIP_DEVICE        0x00
+#define REQ_RECIP_INTERFACE     0x01
+#define REQ_RECIP_ENDPOINT      0x02
+#define REQ_RECIP_OTHER         0x03
+
+/* Also for class requests set the following bit */
+#define REQ_TYPE_OFFSET         5
+#define REQ_TYPE_MASK			(0x03 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_STANDARD		(0x00 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_CLASS			(0x01 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_VENDOR			(0x02 << REQ_TYPE_OFFSET)
+#define REQ_TYPE_RESERVED		(0x03 << REQ_TYPE_OFFSET)
+
+/* Combine one of the 3 above with one of the following 2 */
+#define REQ_DIR_OFFSET         7
+#define REQ_DIR_IN             (1 << REQ_DIR_OFFSET)
+#define REQ_DIR_OUT            (0 << REQ_DIR_OFFSET)
+
+/* Standard USB requests, see Chapter 9 */
+#define REQ_GET_STATUS          0
+#define REQ_CLEAR_FEATURE       1
+#define REQ_SET_FEATURE         3
+#define REQ_SET_ADDRESS         5
+#define REQ_GET_DESCRIPTOR      6
+#define REQ_SET_DESCRIPTOR      7
+#define REQ_GET_CONFIGURATION   8
+#define REQ_SET_CONFIGURATION   9
+#define REQ_GET_INTERFACE       10
+#define REQ_SET_INTERFACE       11
+#define REQ_SYNCH_FRAME         12
+
+#define DESC_TYPE_DEVICE         0x1
+#define DESC_TYPE_CONFIG         0x2
+#define DESC_TYPE_STRING         0x3
+#define DESC_TYPE_INTERFACE      0x4
+#define DESC_TYPE_ENDPOINT       0x5
+#define DESC_TYPE_QUALIFIER      0x6
+#define DESC_TYPE_OTHER_SPEED    0x7
+#define DESC_TYPE_INTF_POWER     0x8
+#define DESC_TYPE_OTG            0x9
+
+/*******************************************************************
+**
+** Values specific to CLEAR FEATURE commands (must go to common.h later)
+*/
+
+#define  ENDPOINT_HALT          0
+#define  DEVICE_SELF_POWERED    0
+#define  DEVICE_REMOTE_WAKEUP   1
+#define  DEVICE_TEST_MODE       2
+
+
+/* States of device instances on the device list */
+
+/* initial device state */
+#define  DEVSTATE_INITIAL        0x00
+
+/* device descriptor [0..7]*/
+#define  DEVSTATE_DEVDESC8       0x01
+
+/* address set */
+#define  DEVSTATE_ADDR_SET       0x02
+
+/* full device descriptor */
+#define  DEVSTATE_DEV_DESC       0x03
+
+/* config descriptor [0..7] */
+#define  DEVSTATE_GET_CFG9       0x04
+
+/* config set */
+#define  DEVSTATE_SET_CFG        0x05
+
+/* full config desc. read in */
+#define  DEVSTATE_CFG_READ       0x06
+
+/* application callbacks */
+#define  DEVSTATE_APP_CALL       0x07
+
+/* Select interface done */
+#define  DEVSTATE_SET_INTF       0x08
+
+#define  DEVSTATE_ENUM_OK        0x09
+
+#define  DEVSTATE_CHK_OTG        0x0A
+
+/* Event codes for attach/detach etc. callback */
+#define  USB_ATTACH_EVENT        1   /* device attach */
+#define  USB_DETACH_EVENT        2   /* device detach */
+#define  USB_CONFIG_EVENT        3   /* device reconfigured */
+#define  USB_INTF_EVENT          4   /* device interface selected */
+
+#endif /* __mvUsbCh9_h__ */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDebug.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDebug.h
new file mode 100644
index 0000000..1243af7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDebug.h
@@ -0,0 +1,109 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDebug_h__
+#define __mvUsbDebug_h__
+
+#include "mvUsbTypes.h"
+
+#define MV_USB_RT_DEBUG
+
+/************************************************************
+The following array is used to make a run time trace route
+inside the USB stack.
+*************************************************************/
+
+#define ARC_DEBUG_FLAG_ANY      0x00000000
+
+#define ARC_DEBUG_FLAG_TRACE    0x00000001
+#define ARC_DEBUG_FLAG_CTRL     0x00000002
+#define ARC_DEBUG_FLAG_RX       0x00000004
+#define ARC_DEBUG_FLAG_TX       0x00000008
+#define ARC_DEBUG_FLAG_STALL    0x00000010
+#define ARC_DEBUG_FLAG_STATUS   0x00000020
+#define ARC_DEBUG_FLAG_TRANSFER 0x00000040
+#define ARC_DEBUG_FLAG_INIT     0x00000080
+#define ARC_DEBUG_FLAG_ISR      0x00000100
+#define ARC_DEBUG_FLAG_ERROR    0x00000200
+#define ARC_DEBUG_FLAG_ADDR     0x00000400
+#define ARC_DEBUG_FLAG_DUMP     0x00000800
+#define ARC_DEBUG_FLAG_SETUP    0x00001000
+#define ARC_DEBUG_FLAG_CLASS    0x00002000
+#define ARC_DEBUG_FLAG_SPEED    0x00004000
+#define ARC_DEBUG_FLAG_RESET    0x00008000
+#define ARC_DEBUG_FLAG_SUSPEND  0x00010000
+#define ARC_DEBUG_FLAG_RESUME   0x00020000
+#define ARC_DEBUG_FLAG_EP0      0x00040000
+#define ARC_DEBUG_FLAG_EP1      0x00080000
+#define ARC_DEBUG_FLAG_STATS    0x00100000
+
+
+#define ARC_DEBUG_FLAG_ALL      0xffffffff
+
+extern uint_32  usbDebugFlags;
+
+#ifdef MV_USB_RT_DEBUG
+#   define ARC_DEBUG_CODE(flags, code)    	        \
+        if( (usbDebugFlags & (flags)) == (flags) )  \
+            code
+#else
+#   define ARC_DEBUG_CODE(flags, code)
+#endif
+
+#if defined(MV_USB_TRACE_LOG)
+
+#define TRACE_ARRAY_SIZE 400
+#define MAX_STRING_SIZE  132
+
+extern uint_16 DEBUG_TRACE_ARRAY_COUNTER;
+extern char    DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE][MAX_STRING_SIZE];
+
+#define ARC_DEBUG_TRACE(flags, format, x...)                                        \
+{                                                                                   \
+    if( (usbDebugFlags & (flags)) == (flags))                                   \
+    {                                                                               \
+        USB_sprintf(DEBUG_TRACE_ARRAY[DEBUG_TRACE_ARRAY_COUNTER], format, ##x);     \
+        DEBUG_TRACE_ARRAY_COUNTER++;                                                \
+        if(DEBUG_TRACE_ARRAY_COUNTER >= TRACE_ARRAY_SIZE)                           \
+            {DEBUG_TRACE_ARRAY_COUNTER = 0;}                                        \
+    }                                                                               \
+}
+
+#elif defined(MV_USB_TRACE_PRINT)
+
+#   define ARC_DEBUG_TRACE(flags, format, x...)           \
+        if((usbDebugFlags & (flags)) == (flags))      \
+            USB_printf(format, ##x)
+
+/*if trace switch is not enabled define debug log trace to empty*/
+#else
+#   define ARC_DEBUG_TRACE(flags, fromat, x...)
+#endif
+
+
+/************************************************************
+The following are global data structures that can be used
+to copy data from stack on run time. This structure can
+be analyzed at run time to see the state of various other
+data structures in the memory.
+*************************************************************/
+
+#endif /* __mvUsbDebug_h__ */
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDefs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDefs.h
new file mode 100644
index 0000000..6b4d16b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDefs.h
@@ -0,0 +1,139 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDefs_h__
+#define __mvUsbDefs_h__
+
+#include "mvUsbTypes.h"
+
+/* Host specific */
+#define  USB_DEBOUNCE_DELAY                  (101)
+#define  USB_RESET_RECOVERY_DELAY            (11)
+#define  USB_RESET_DELAY                     (60)
+
+/* Error codes */
+#define  USB_OK                              (0x00)
+#define  USBERR_ALLOC                        (0x81)
+#define  USBERR_BAD_STATUS                   (0x82)
+#define  USBERR_CLOSED_SERVICE               (0x83)
+#define  USBERR_OPEN_SERVICE                 (0x84)
+#define  USBERR_TRANSFER_IN_PROGRESS         (0x85)
+#define  USBERR_ENDPOINT_STALLED             (0x86)
+#define  USBERR_ALLOC_STATE                  (0x87)
+#define  USBERR_DRIVER_INSTALL_FAILED        (0x88)
+#define  USBERR_DRIVER_NOT_INSTALLED         (0x89)
+#define  USBERR_INSTALL_ISR                  (0x8A)
+#define  USBERR_INVALID_DEVICE_NUM           (0x8B)
+#define  USBERR_ALLOC_SERVICE                (0x8C)
+#define  USBERR_INIT_FAILED                  (0x8D)
+#define  USBERR_SHUTDOWN                     (0x8E)
+#define  USBERR_INVALID_PIPE_HANDLE          (0x8F)
+#define  USBERR_OPEN_PIPE_FAILED             (0x90)
+#define  USBERR_INIT_DATA                    (0x91)
+#define  USBERR_SRP_REQ_INVALID_STATE        (0x92)
+#define  USBERR_TX_FAILED                    (0x93)
+#define  USBERR_RX_FAILED                    (0x94)
+#define  USBERR_EP_INIT_FAILED               (0x95)
+#define  USBERR_EP_DEINIT_FAILED             (0x96)
+#define  USBERR_TR_FAILED                    (0x97)
+#define  USBERR_BANDWIDTH_ALLOC_FAILED       (0x98)
+#define  USBERR_INVALID_NUM_OF_ENDPOINTS     (0x99)
+
+#define  USBERR_DEVICE_NOT_FOUND             (0xC0)
+#define  USBERR_DEVICE_BUSY                  (0xC1)
+#define  USBERR_NO_DEVICE_CLASS              (0xC3)
+#define  USBERR_UNKNOWN_ERROR                (0xC4)
+#define  USBERR_INVALID_BMREQ_TYPE           (0xC5)
+#define  USBERR_GET_MEMORY_FAILED            (0xC6)
+#define  USBERR_INVALID_MEM_TYPE             (0xC7)
+#define  USBERR_NO_DESCRIPTOR                (0xC8)
+#define  USBERR_NULL_CALLBACK                (0xC9)
+#define  USBERR_NO_INTERFACE                 (0xCA)
+#define  USBERR_INVALID_CFIG_NUM             (0xCB)
+#define  USBERR_INVALID_ANCHOR               (0xCC)
+#define  USBERR_INVALID_REQ_TYPE             (0xCD)
+
+/* Error Codes for lower-layer */
+#define  USBERR_ALLOC_EP_QUEUE_HEAD          (0xA8)
+#define  USBERR_ALLOC_TR                     (0xA9)
+#define  USBERR_ALLOC_DTD_BASE               (0xAA)
+#define  USBERR_CLASS_DRIVER_INSTALL         (0xAB)
+
+
+/* Pipe Types */
+#define  USB_ISOCHRONOUS_PIPE                (0x01)
+#define  USB_INTERRUPT_PIPE                  (0x02)
+#define  USB_CONTROL_PIPE                    (0x03)
+#define  USB_BULK_PIPE                       (0x04)
+
+#define  ARC_USB_STATE_UNKNOWN               (0xff)
+#define  ARC_USB_STATE_POWERED               (0x03)
+#define  ARC_USB_STATE_DEFAULT               (0x02)
+#define  ARC_USB_STATE_ADDRESS               (0x01)
+#define  ARC_USB_STATE_CONFIG                (0x00)
+#define  ARC_USB_STATE_SUSPEND               (0x80)
+
+#define  ARC_USB_SELF_POWERED                (0x01)
+#define  ARC_USB_REMOTE_WAKEUP               (0x02)
+
+/* Bus Control values */
+#define  ARC_USB_NO_OPERATION                (0x00)
+#define  ARC_USB_ASSERT_BUS_RESET            (0x01)
+#define  ARC_USB_DEASSERT_BUS_RESET          (0x02)
+#define  ARC_USB_ASSERT_RESUME               (0x03)
+#define  ARC_USB_DEASSERT_RESUME             (0x04)
+#define  ARC_USB_SUSPEND_SOF                 (0x05)
+#define  ARC_USB_RESUME_SOF                  (0x06)
+
+/* possible values of XD->bStatus */
+#define  ARC_USB_STATUS_IDLE                 (0)
+#define  ARC_USB_STATUS_TRANSFER_ACCEPTED    (1)
+#define  ARC_USB_STATUS_TRANSFER_PENDING     (2)
+#define  ARC_USB_STATUS_TRANSFER_IN_PROGRESS (3)
+#define  ARC_USB_STATUS_ERROR                (4)
+#define  ARC_USB_STATUS_DISABLED             (5)
+#define  ARC_USB_STATUS_STALLED              (6)
+#define  ARC_USB_STATUS_TRANSFER_QUEUED      (7)
+
+#define  ARC_USB_RECV                        (0)
+#define  ARC_USB_SEND                        (1)
+
+#define  ARC_USB_DEVICE_DONT_ZERO_TERMINATE  (0x1)
+
+#define  ARC_USB_SETUP_DATA_XFER_DIRECTION   (0x80)
+
+#define  ARC_USB_SPEED_FULL                  (0)
+#define  ARC_USB_SPEED_LOW                   (1)
+#define  ARC_USB_SPEED_HIGH                  (2)
+
+#define  ARC_USB_MAX_PKTS_PER_UFRAME         (0x6)
+
+/* USB 1.1 Setup Packet */
+typedef struct setup_struct {
+   uint_8      REQUESTTYPE;
+   uint_8      REQUEST;
+   uint_16     VALUE;
+   uint_16     INDEX;
+   uint_16     LENGTH;
+} SETUP_STRUCT, _PTR_ SETUP_STRUCT_PTR;
+
+#endif /* __mvUsbDefs_h__ */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDevApi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDevApi.h
new file mode 100644
index 0000000..fe926f3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbDevApi.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDevApi_h__
+#define __mvUsbDevApi_h__
+
+#include "mvUsbTypes.h"
+#include "mvUsbDebug.h"
+#include "mvUsbDefs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+
+#define ARC_USB_MAX_ENDPOINTS               (16)
+
+#define MAX_EP_TR_DESCRS                    (48)
+#define MAX_XDS_FOR_TR_CALLS                (32)
+#define MAX_USB_DEVICES                     MV_USB_MAX_PORTS
+
+/*Assumption here is that all control endpoints are sequential 0,1,..
+if they are not you need to modify the tr_complete routine to handle that */
+#define USB_MAX_CONTROL_ENDPOINTS           (1)
+
+#define USB_MAX_CTRL_PAYLOAD                (64)
+
+
+/* Endpoint types */
+#define  ARC_USB_CONTROL_ENDPOINT             (0)
+#define  ARC_USB_ISOCHRONOUS_ENDPOINT         (1)
+#define  ARC_USB_BULK_ENDPOINT                (2)
+#define  ARC_USB_INTERRUPT_ENDPOINT           (3)
+
+/* Informational Request/Set Types */
+#define  ARC_USB_STATUS_DEVICE_STATE          (0x01)
+#define  ARC_USB_STATUS_INTERFACE             (0x02)
+#define  ARC_USB_STATUS_ADDRESS               (0x03)
+#define  ARC_USB_STATUS_CURRENT_CONFIG        (0x04)
+#define  ARC_USB_STATUS_SOF_COUNT             (0x05)
+#define  ARC_USB_STATUS_DEVICE                (0x06)
+#define  ARC_USB_STATUS_TEST_MODE             (0x07)
+#define  ARC_USB_FORCE_FULL_SPEED             (0x08)
+#define  ARC_USB_PHY_LOW_POWER_SUSPEND        (0x09)
+
+#define  ARC_USB_STATUS_ENDPOINT_NUMBER_MASK  (0x000F)
+#define  ARC_USB_STATUS_ENDPOINT_DIR_MASK     (0x0080)
+
+#define  ARC_USB_TEST_MODE_TEST_PACKET        (0x0400)
+
+/* Available service types */
+/* Services 0 through 15 are reserved for endpoints */
+#define  ARC_USB_SERVICE_EP0                  (0x00)
+#define  ARC_USB_SERVICE_EP1                  (0x01)
+#define  ARC_USB_SERVICE_EP2                  (0x02)
+#define  ARC_USB_SERVICE_EP3                  (0x03)
+#define  ARC_USB_SERVICE_BUS_RESET            (0x10)
+#define  ARC_USB_SERVICE_SUSPEND              (0x11)
+#define  ARC_USB_SERVICE_SOF                  (0x12)
+#define  ARC_USB_SERVICE_RESUME               (0x13)
+#define  ARC_USB_SERVICE_SLEEP                (0x14)
+#define  ARC_USB_SERVICE_SPEED_DETECTION      (0x15)
+#define  ARC_USB_SERVICE_ERROR                (0x16)
+#define  ARC_USB_SERVICE_STALL                (0x17)
+
+typedef pointer _usb_device_handle;
+typedef void (*USB_SERVICE_FUNC)(void* handle, uint_8, boolean, uint_8,
+                                                 uint_8_ptr, uint_32, uint_8);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void    _usb_dci_vusb20_isr(void* handle);
+
+void    _usb_device_set_bsp_funcs(USB_IMPORT_FUNCS* pBspFuncs);
+
+uint_8  _usb_device_init(uint_8 devNo, void** pHandle);
+
+uint_8  _usb_device_get_max_endpoint(void* handle);
+
+uint_8  _usb_device_get_dev_num(void* handle);
+
+void    _usb_device_shutdown(void* handle);
+
+void    _usb_device_stop(void* handle);
+void    _usb_device_start(void* handle);
+
+uint_8  _usb_device_init_endpoint(void* handle, uint_8 ep_num, uint_16 max_pkt_size,
+                                  uint_8 direction, uint_8 type, uint_8 flag);
+uint_8  _usb_device_deinit_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+
+uint_8  _usb_device_recv_data(void* handle, uint_8 ep_num, uint_8* buf_ptr, uint_32 size);
+uint_8  _usb_device_send_data(void* handle, uint_8 ep_num, uint_8* buf_ptr, uint_32 size);
+uint_8  _usb_device_cancel_transfer(void* handle, uint_8 ep_num, uint_8 direction);
+uint_8  _usb_device_get_transfer_status(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_stall_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_unstall_endpoint(void* handle, uint_8 ep_num, uint_8 direction);
+uint_8  _usb_device_is_endpoint_stalled(void* handle, uint_8 ep_num, uint_8 direction);
+void    _usb_device_assert_resume(void* handle);
+uint_8  _usb_device_get_status(void* handle, uint_8 component, uint_16* status_ptr);
+uint_8  _usb_device_set_status(void* handle, uint_8 component, uint_16 setting);
+void    _usb_device_read_setup_data(void* handle, uint_8 ep_num, uint_8* buf_ptr);
+
+uint_8  _usb_device_register_service(void* handle, uint_8 type, USB_SERVICE_FUNC serviceFunc);
+
+uint_8  _usb_device_unregister_service(void* handle, uint_8 type);
+
+
+
+/* These functions that implement USB 2.0 standard Chapter 9 Setup requests */
+void    mvUsbCh9GetStatus(void* handle, boolean setup,
+                                  SETUP_STRUCT* ctrl_req);
+
+void    mvUsbCh9ClearFeature(void* handle, boolean setup,
+                                   SETUP_STRUCT* setup_ptr);
+
+void    mvUsbCh9SetFeature(void* handle, boolean setup,
+                                 SETUP_STRUCT* setup_ptr);
+
+void    mvUsbCh9SetAddress(void* handle, boolean setup,
+                                   SETUP_STRUCT* setup_ptr);
+
+/* DEBUG Functions */
+void    _usb_dci_vusb20_set_test_mode(void* handle, uint_16 testMode);
+
+void    _usb_debug_set_flags(uint_32 flags);
+uint_32 _usb_debug_get_flags(void);
+
+void    _usb_debug_init_trace_log(void);
+void    _usb_debug_print_trace_log(void);
+
+void    _usb_regs(void* usbHandle);
+void    _usb_status(void* usbHandle);
+void    _usb_stats(void* usbHandle);
+void    _usb_clear_stats(void* usbHandle);
+void    _usb_ep_status(void* usbHandle, int ep_num, int direction);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __mvUsbDevApi_h__ */
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbTypes.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbTypes.h
new file mode 100644
index 0000000..7445339
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/api/mvUsbTypes.h
@@ -0,0 +1,237 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbTypes_h__
+#define __mvUsbTypes_h__
+
+#define _PTR_      *
+#define _CODE_PTR_ *
+
+typedef char _PTR_                    char_ptr;    /* signed character       */
+
+typedef signed   char  int_8, _PTR_   int_8_ptr;   /* 8-bit signed integer   */
+typedef unsigned char  uint_8, _PTR_   uint_8_ptr;  /* 8-bit signed integer   */
+
+typedef          short int_16, _PTR_   int_16_ptr;  /* 16-bit signed integer  */
+typedef unsigned short uint_16, _PTR_  uint_16_ptr; /* 16-bit unsigned integer*/
+
+typedef          int   int_32, _PTR_   int_32_ptr;  /* 32-bit signed integer  */
+typedef unsigned int   uint_32, _PTR_  uint_32_ptr; /* 32-bit unsigned integer*/
+
+typedef unsigned long  boolean;  /* Machine representation of a boolean */
+
+typedef void _PTR_     pointer;  /* Machine representation of a pointer */
+
+/*--------------------------------------------------------------------------*/
+/*
+**                          STANDARD CONSTANTS
+**
+**  Note that if standard 'C' library files are included after types.h,
+**  the defines of TRUE, FALSE and NULL may sometimes conflict, as most
+**  standard library files do not check for previous definitions.
+*/
+
+#ifndef  FALSE
+#   define FALSE ((boolean)0)
+#endif
+
+#ifndef  TRUE
+#   define TRUE ((boolean)!FALSE)
+#endif
+
+#ifndef  NULL
+#   ifdef __cplusplus
+#       define NULL (0)
+#   else
+#       define NULL ((pointer)0)
+#   endif
+#endif
+
+#ifndef _ASSERT_
+   #define ASSERT(X,Y)
+#else
+   #define ASSERT(X,Y) if(Y) { USB_printf(X); exit(1);}
+#endif
+
+#ifndef  MIN
+#   define MIN(a,b)   ((a) < (b) ? (a) : (b))
+#endif
+
+#define USB_MEM_ALIGN(n, align)            ((n) + (-(n) & (align-1)))
+
+/* Macro for aligning the EP queue head to 32 byte boundary */
+#define USB_MEM32_ALIGN(n)                  USB_MEM_ALIGN(n, 32)
+
+/* Macro for aligning the EP queue head to 1024 byte boundary */
+#define USB_MEM1024_ALIGN(n)                USB_MEM_ALIGN(n, 1024)
+
+/* Macro for aligning the EP queue head to 1024 byte boundary */
+#define USB_MEM2048_ALIGN(n)                USB_MEM_ALIGN(n, 2048)
+
+#define PSP_CACHE_LINE_SIZE                 32
+
+#define USB_uint_16_low(x)                  ((x) & 0xFF)
+#define USB_uint_16_high(x)                 (((x) >> 8) & 0xFF)
+
+#define USB_CACHE_ALIGN(n)                  USB_MEM_ALIGN(n, PSP_CACHE_LINE_SIZE)
+
+#ifndef INLINE
+#   if defined(MV_VXWORKS)
+#       define INLINE   __inline
+#   else
+#       define INLINE   inline
+#   endif /* MV_VXWORKS */
+#endif /* INLINE */
+
+/* 16bit byte swap. For example 0x1122 -> 0x2211                            */
+static INLINE uint_16 USB_BYTE_SWAP_16BIT(uint_16 value)
+{
+    return ( ((value & 0x00ff) << 8) |
+             ((value & 0xff00) >> 8) );
+}
+
+/* 32bit byte swap. For example 0x11223344 -> 0x44332211                    */
+static INLINE uint_32 USB_BYTE_SWAP_32BIT(uint_32 value)
+{
+    return ( ((value & 0x000000ff) << 24) |
+             ((value & 0x0000ff00) << 8)  |
+             ((value & 0x00ff0000) >> 8)  |
+             ((value & 0xff000000) >> 24));
+}
+
+
+/* Endianess macros.                                                        */
+#if defined(MV_CPU_LE)
+#   define USB_16BIT_LE(X)  (X)
+#   define USB_32BIT_LE(X)  (X)
+#   define USB_16BIT_BE(X)  USB_BYTE_SWAP_16BIT(X)
+#   define USB_32BIT_BE(X)  USB_BYTE_SWAP_32BIT(X)
+#elif defined(MV_CPU_BE)
+#   define USB_16BIT_LE(X)  USB_BYTE_SWAP_16BIT(X)
+#   define USB_32BIT_LE(X)  USB_BYTE_SWAP_32BIT(X)
+#   define USB_16BIT_BE(X)  (X)
+#   define USB_32BIT_BE(X)  (X)
+#else
+    #error "CPU endianess isn't defined!\n"
+#endif
+
+typedef struct
+{
+    void    (*bspPrintf)          (const char *  fmt, ...);
+    int     (*bspSprintf)         (char* buffer, const char *  fmt, ...);
+    void*   (*bspUncachedMalloc)  (void* pDev, uint_32 size, uint_32 align,
+                                   unsigned long* pPhyAddr);
+    void    (*bspUncachedFree)    (void* pDev, uint_32 size, unsigned long phyAddr,
+                                    void*  pVirtAddr);
+    void*   (*bspMalloc)          (unsigned int size);
+    void    (*bspFree)            (void* ptr);
+    void*   (*bspMemset)          (void* ptr, int val, unsigned int size);
+    void*   (*bspMemcpy)          (void* dst, const void* src, unsigned int size);
+    unsigned long (*bspCacheFlush)      (void* pDev, void* pVirtAddr, int size);
+    unsigned long (*bspCacheInv)        (void* pDev, void* pVirtAddr, int size);
+    unsigned long (*bspVirtToPhys)    (void* pDev, void* pVirtAddr);
+    int     (*bspLock)            (void);
+    void    (*bspUnlock)          (int lockKey);
+    uint_32 (*bspGetCapRegAddr)   (int devNo);
+    void    (*bspResetComplete)   (int devNo);
+
+} USB_IMPORT_FUNCS;
+
+extern USB_IMPORT_FUNCS*            global_import_funcs;
+
+#define USB_sprintf(frmt, x...)     if( (global_import_funcs != NULL) &&                \
+                                         global_import_funcs->bspSprintf != NULL)        \
+                                        global_import_funcs->bspSprintf(frmt, ##x)
+
+#define USB_printf(frmt, x...)      if( (global_import_funcs != NULL) &&                \
+                                        (global_import_funcs->bspPrintf != NULL) )        \
+                                        global_import_funcs->bspPrintf(frmt, ##x)
+
+
+#define USB_virt_to_phys(pVirt)     (global_import_funcs->bspVirtToPhys == NULL) ?      \
+                                        (uint_32)(pVirt) : global_import_funcs->bspVirtToPhys(NULL, pVirt)
+
+#define USB_get_cap_reg_addr(dev)   global_import_funcs->bspGetCapRegAddr(dev)
+
+static INLINE void* USB_uncached_memalloc(uint_32 size, uint_32 align, unsigned long* pPhyAddr)
+{
+    /*USB_printf("**** USB_uncached_memalloc: size=%d\n", (size));       */
+    return global_import_funcs->bspUncachedMalloc(NULL, size, align, pPhyAddr);
+}
+
+static INLINE void* USB_memalloc(uint_32 size)
+{
+    /*USB_printf("**** USB_memalloc: size=%d\n", (size)); */
+    return global_import_funcs->bspMalloc(size);
+}
+
+#define USB_uncached_memfree(pVirt, size, physAddr)                                 \
+                /*USB_printf("#### USB_uncached_memfree: pVirt=0x%x\n", (pVirt)); */\
+                global_import_funcs->bspUncachedFree(NULL, size, physAddr, pVirt);
+
+#define USB_memfree(ptr)                                                            \
+                /*USB_printf("#### USB_memfree: ptr=0x%x\n", (ptr));*/              \
+                global_import_funcs->bspFree(ptr);
+
+#define USB_memzero(ptr, n)         global_import_funcs->bspMemset(ptr, 0,  n)
+#define USB_memcopy(src, dst, n)    global_import_funcs->bspMemcpy(dst, src, n)
+
+#define USB_dcache_inv(ptr, size)   if(global_import_funcs->bspCacheInv != NULL)  \
+                                        global_import_funcs->bspCacheInv(NULL, ptr, size)
+
+#define USB_dcache_flush(ptr, size) if(global_import_funcs->bspCacheFlush != NULL)  \
+                                        global_import_funcs->bspCacheFlush(NULL, ptr, size)
+
+#define USB_lock()                  (global_import_funcs->bspLock == NULL) ?        \
+                                                    0 : global_import_funcs->bspLock()
+
+#define USB_unlock(key)             if(global_import_funcs->bspUnlock != NULL)  \
+                                        global_import_funcs->bspUnlock(key)
+
+#define USB_reset_complete(dev)     if(global_import_funcs->bspResetComplete)       \
+                                        global_import_funcs->bspResetComplete(dev)
+
+
+#if defined(USB_UNDERRUN_WA)
+
+#define USB_SRAM_MAX_PARTS  16
+
+typedef struct
+{
+    uint_32 (*bspGetSramAddr) (uint_32* pSize);
+    void    (*bspIdmaCopy) (void* dst, void* src, unsigned int size);
+
+} USB_WA_FUNCS;
+
+extern USB_WA_FUNCS*    global_wa_funcs;
+extern int              global_wa_sram_parts;
+extern int              global_wa_threshold;
+
+#define USB_get_sram_addr(pSize)        global_wa_funcs->bspGetSramAddr(pSize)
+
+#define USB_idma_copy(dst, src, size)                                   \
+            if(global_wa_funcs->bspIdmaCopy != NULL)                    \
+                global_wa_funcs->bspIdmaCopy(dst, src, size)
+
+#endif /* USB_UNDERRUN_WA */
+
+#endif /* __mvUsbTypes_h__ */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbCore.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbCore.h
new file mode 100644
index 0000000..72c18a1
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbCore.h
@@ -0,0 +1,713 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbCore_h__
+#define __mvUsbCore_h__
+
+#include "api/mvUsbTypes.h"
+
+/* VUSBHS specific defines */
+#define  VUSBHS_MAX_PORTS                          (8)
+#define  EHCI_CAP_LEN_MASK                         (0x000000FF)
+#define  EHCI_DATA_STRUCTURE_BASE_ADDRESS          (0)
+
+/* Command Register Bit Masks */
+#define  EHCI_CMD_RUN_STOP                         (0x00000001)
+#define  EHCI_CMD_CTRL_RESET                       (0x00000002)
+#define  EHCI_CMD_SETUP_TRIPWIRE_SET               (0x00002000)
+#define  EHCI_CMD_SETUP_TRIPWIRE_CLEAR             ~EHCI_CMD_SETUP_TRIPWIRE_SET
+
+#define  EHCI_CMD_ATDTW_TRIPWIRE_SET               (0x00004000)
+#define  EHCI_CMD_ATDTW_TRIPWIRE_CLEAR             ~EHCI_CMD_ATDTW_TRIPWIRE_SET
+
+/*bit 15,3,2 are for frame list size */
+#define  EHCI_CMD_FRAME_SIZE_1024                  (0x00000000) /* 000 */
+#define  EHCI_CMD_FRAME_SIZE_512                   (0x00000004) /* 001 */
+#define  EHCI_CMD_FRAME_SIZE_256                   (0x00000008) /* 010 */
+#define  EHCI_CMD_FRAME_SIZE_128                   (0x0000000C) /* 011 */
+#define  EHCI_CMD_FRAME_SIZE_64                    (0x00008000) /* 100 */
+#define  EHCI_CMD_FRAME_SIZE_32                    (0x00008004) /* 101 */
+#define  EHCI_CMD_FRAME_SIZE_16                    (0x00008008) /* 110 */
+#define  EHCI_CMD_FRAME_SIZE_8                     (0x0000800C) /* 111 */
+
+/* Hardware Rev 4.0 related change */
+/* Mode Register Bit Masks */
+#define  VUSBHS_MODE_CTRL_MODE_IDLE                (0x00000000)
+#define  VUSBHS_MODE_CTRL_MODE_DEV                 (0x00000002)
+#define  VUSBHS_MODE_CTRL_MODE_HOST                (0x00000003)
+#define  VUSBHS_MODE_BIG_ENDIAN                    (0x00000004)
+#define  VUSBHS_MODE_SETUP_LOCK_DISABLE            (0x00000008)
+#define  VUSBHS_MODE_STREAM_DISABLE                (0x00000010)
+
+/* Interrupt Enable Register Bit Masks */
+#define  EHCI_INTR_INT_EN                          (0x00000001)
+#define  EHCI_INTR_ERR_INT_EN                      (0x00000002)
+#define  EHCI_INTR_PORT_CHANGE_DETECT_EN           (0x00000004)
+
+#define  EHCI_INTR_ASYNC_ADV_AAE                   (0x00000020)
+#define  EHCI_INTR_ASYNC_ADV_AAE_ENABLE            (0x00000020) /* | with this to enable */
+#define  EHCI_INTR_ASYNC_ADV_AAE_DISABLE           (0xFFFFFFDF) /* & with this to disable */
+
+#define  EHCI_INTR_RESET_EN                        (0x00000040)
+#define  EHCI_INTR_SOF_UFRAME_EN                   (0x00000080)
+#define  EHCI_INTR_DEVICE_SUSPEND                  (0x00000100)
+
+/* Interrupt Status Register Masks */
+#define  EHCI_STS_SOF                              (0x00000080)
+#define  EHCI_STS_RESET                            (0x00000040)
+#define  EHCI_STS_PORT_CHANGE                      (0x00000004)
+#define  EHCI_STS_ERR                              (0x00000002)
+#define  EHCI_STS_INT                              (0x00000001)
+#define  EHCI_STS_SUSPEND                          (0x00000100)
+#define  EHCI_STS_HC_HALTED                        (0x00001000)
+
+/* Endpoint Queue Head Bit Masks */
+#define  VUSB_EP_QUEUE_HEAD_IOS                    (0x00008000)
+#define  VUSB_EP_QUEUE_HEAD_IOC                    (0x00008000)
+#define  VUSB_EP_QUEUE_HEAD_INT                    (0x00000100)
+#define  VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE         (0x00000001)
+#define  VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS        (16)
+#define  VUSB_EP_QUEUE_HEAD_ZERO_LEN_TER_SEL       (0x20000000)
+#define  VUSB_EP_QUEUE_HEAD_MULT_POS               (30)
+#define  VUSB_EP_MAX_LENGTH_TRANSFER               (0x4000)
+
+#define  VUSB_EP_QUEUE_HEAD_STATUS_ACTIVE          (0x00000080)
+
+#define  VUSBHS_TD_NEXT_TERMINATE                  (0x00000001)
+#define  VUSBHS_TD_IOC                             (0x00008000)
+#define  VUSBHS_TD_STATUS_ACTIVE                   (0x00000080)
+#define  VUSBHS_TD_STATUS_HALTED                   (0x00000040)
+#define  VUSBHS_TD_RESERVED_FIELDS                 (0x00007F00)
+#define  VUSBHS_TD_ERROR_MASK                      (0x68)
+#define  VUSBHS_TD_ADDR_MASK                       (0xFFFFFFE0)
+#define  VUSBHS_TD_LENGTH_BIT_POS                  (16)
+
+#define  EHCI_EPCTRL_TX_ALL_MASK                   (0xFFFF0000)
+#define  EHCI_EPCTRL_RX_ALL_MASK                   (0x0000FFFF)
+
+#define  EHCI_EPCTRL_TX_DATA_TOGGLE_RST            (0x00400000)
+#define  EHCI_EPCTRL_TX_EP_STALL                   (0x00010000)
+#define  EHCI_EPCTRL_RX_EP_STALL                   (0x00000001)
+#define  EHCI_EPCTRL_RX_DATA_TOGGLE_RST            (0x00000040)
+#define  EHCI_EPCTRL_RX_ENABLE                     (0x00000080)
+#define  EHCI_EPCTRL_TX_ENABLE                     (0x00800000)
+#define  EHCI_EPCTRL_CONTROL                       (0x00000000)
+#define  EHCI_EPCTRL_ISOCHRONOUS                   (0x00040000)
+#define  EHCI_EPCTRL_BULK                          (0x00080000)
+#define  EHCI_EPCTRL_INT                           (0x000C0000)
+#define  EHCI_EPCTRL_TX_TYPE                       (0x000C0000)
+#define  EHCI_EPCTRL_RX_TYPE                       (0x0000000C)
+#define  EHCI_EPCTRL_DATA_TOGGLE_INHIBIT           (0x00000020)
+#define  EHCI_EPCTRL_TX_EP_TYPE_SHIFT              (18)
+#define  EHCI_EPCTRL_RX_EP_TYPE_SHIFT              (2)
+
+/* set bit 24 (PFSC) in PORTSCX register */
+#define  EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT     (0x01000000)
+/* set bit 23 (PHCD) in PORTSCX register */
+#define  EHCI_PORTSCX_PHY_CLOCK_DISABLE            (0x00800000)
+
+#define  EHCI_PORTSCX_PORT_POWER                   (0x00001000)
+#define  EHCI_PORTSCX_LINE_STATUS_BITS             (0x00000C00)
+#define  EHCI_PORTSCX_LINE_STATUS_SE0              (0x00000000)
+#define  EHCI_PORTSCX_LINE_STATUS_KSTATE           (0x00000400)
+#define  EHCI_PORTSCX_LINE_STATUS_JSTATE           (0x00000800)
+#define  EHCI_PORTSCX_PORT_HIGH_SPEED              (0x00000200)
+#define  EHCI_PORTSCX_PORT_RESET                   (0x00000100)
+#define  EHCI_PORTSCX_PORT_SUSPEND                 (0x00000080)
+#define  EHCI_PORTSCX_PORT_FORCE_RESUME            (0x00000040)
+#define  EHCI_PORTSCX_PORT_EN_DIS_CHANGE           (0x00000008)
+#define  EHCI_PORTSCX_PORT_ENABLE                  (0x00000004)
+#define  EHCI_PORTSCX_CONNECT_STATUS_CHANGE        (0x00000002)
+#define  EHCI_PORTSCX_CURRENT_CONNECT_STATUS       (0x00000001)
+
+#define  VUSBHS_PORTSCX_PORT_SPEED_FULL            (0x00000000)
+#define  VUSBHS_PORTSCX_PORT_SPEED_LOW             (0x04000000)
+#define  VUSBHS_PORTSCX_PORT_SPEED_HIGH            (0x08000000)
+#define  VUSBHS_SPEED_MASK                         (0x0C000000)
+#define  VUSBHS_SPEED_BIT_POS                      (26)
+
+#define  EHCI_PORTSCX_W1C_BITS                     (0x2A)
+#define  VUSB_EP_QH_PACKET_SIZE                    (0x3FFF0000)
+#define  VUSB_EP_TR_PACKET_SIZE                    (0x7FFF0000)
+
+#define  VUSBHS_FRINDEX_MS_MASK                    (0xFFFFFFF8)
+#define  VUSBHS_ADDRESS_BIT_SHIFT                  (25)
+
+#define  VUSB20_DCC_MAX_ENDPTS_SUPPORTED           (0x1F)
+#define  VUSB20_DCC_HOST_MODE_MASK                 (1 << 8)
+#define  VUSB20_DCC_DEVICE_MODE_MASK               (1 << 7)
+
+#define  EHCI_HCC_PARAMS_64_BIT_ADDR_CAP           (0x01)
+#define  EHCI_HCC_PARAMS_PGM_FRM_LIST_FLAG         (0x02)
+#define  EHCI_HCC_PARAMS_ASYNC_PARK_CAP            (0x04)
+#define  EHCI_HCC_PARAMS_ISOCH_SCHED_THRESHOLD     (0xF0)
+#define  EHCI_HCC_PARAMS_ISOCH_FRAME_CACHED        (0x80)
+
+#define  VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG (0x10)
+
+#define  VUSB20_HOST_INTR_EN_BITS                  (0x37)
+
+#define  VUSB20_DEFAULT_PERIODIC_FRAME_LIST_SIZE   (1024)
+#define  VUSB20_NEW_PERIODIC_FRAME_LIST_BITS       (2)
+#define  EHCI_FRAME_LIST_ELEMENT_POINTER_T_BIT     (0x01)
+#define  EHCI_ITD_T_BIT                            (0x01)
+#define  EHCI_SITD_T_BIT                           (0x01)
+#define  EHCI_QUEUE_HEAD_POINTER_T_BIT             (0x01)
+
+
+/************************************************************
+Split transatcions specific defines
+************************************************************/
+#define  EHCI_START_SPLIT_MAX_BUDGET               188
+
+#define  EHCI_ELEMENT_TYPE_ITD                     (0x00)
+#define  EHCI_ELEMENT_TYPE_QH                      (0x02)
+#define  EHCI_ELEMENT_TYPE_SITD                    (0x04)
+#define  EHCI_ELEMENT_TYPE_FSTN                    (0x06)
+#define  EHCI_ELEMENT_TYPE_MASK                    (0x06)
+
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_ITD          (0x00)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_QH           (0x01)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_SITD         (0x02)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_FSTN         (0x03)
+#define  EHCI_FRAME_LIST_ELEMENT_TYPE_BIT_POS      (1)
+
+
+#define  EHCI_QH_ELEMENT_TYPE_ITD                  (0x00)
+#define  EHCI_QH_ELEMENT_TYPE_QH                   (0x01)
+#define  EHCI_QH_ELEMENT_TYPE_SITD                 (0x02)
+#define  EHCI_QH_ELEMENT_TYPE_FSTN                 (0x03)
+
+#define  EHCI_QH_ELEMENT_TYPE_BIT_POS              (1)
+
+#define  EHCI_QTD_PID_OUT_TOKEN                    (0x000)
+#define  EHCI_QTD_PID_IN_TOKEN                     (0x100)
+#define  EHCI_QTD_PID_SETUP_TOKEN                  (0x200)
+#define  EHCI_QTD_IOC                              (0x8000)
+#define  EHCI_QTD_STATUS_ACTIVE                    (0x0080)
+#define  EHCI_QTD_STATUS_HALTED                    (0x0040)
+#define  EHCI_QTD_PID_SETUP                        (0x0200)
+#define  EHCI_QTD_PID_IN                           (0x0100)
+#define  EHCI_QTD_PID_OUT                          (0x0000)
+#define  EHCI_QTD_LENGTH_BIT_POS                   (16)
+#define  EHCI_QTD_DATA_TOGGLE                      (0x80000000)
+#define  EHCI_QTD_DATA_TOGGLE_BIT_POS              (31)
+#define  EHCI_QTD_LENGTH_BIT_MASK                  (0x7FFF0000)
+#define  EHCI_QTD_ERROR_BITS_MASK                  (0x0000003E)
+#define  EHCI_QTD_DEFAULT_CERR_VALUE               (0xC00)
+
+#define  EHCI_SETUP_TOKEN                          (2)
+#define  EHCI_OUT_TOKEN                            (0)
+#define  EHCI_IN_TOKEN                             (1)
+
+#define  EHCI_QTD_T_BIT                            (0x01)
+
+#define  EHCI_QH_ENDPOINT_SPEED_FULL               (0x00)
+#define  EHCI_QH_ENDPOINT_SPEED_LOW                (0x01)
+#define  EHCI_QH_ENDPOINT_SPEED_HIGH               (0x02)
+#define  EHCI_QH_ENDPOINT_SPEED_RESERVED           (0x03)
+
+#define  EHCI_ITD_LENGTH_BIT_POS                   (16)
+#define  EHCI_ITD_IOC_BIT                          (0x00008000)
+#define  EHCI_ITD_ACTIVE_BIT                       (0x80000000)
+#define  EHCI_ITD_PG_SELECT_BIT_POS                (12)
+#define  EHCI_ITD_DIRECTION_BIT_POS                (11)
+#define  EHCI_ITD_EP_BIT_POS                       (8)
+#define  EHCI_ITD_STATUS                           (0xF0000000)
+#define  EHCI_ITD_STATUS_ACTIVE                    (0x80000000) /*bit 4 = 1000*/
+#define  EHCI_ITD_STATUS_DATA_BUFFER_ERR           (0x40000000) /*bit 3 = 0100*/
+#define  EHCI_ITD_STATUS_BABBLE_ERROR              (0x20000000) /*bit 2 = 0010*/
+#define  EHCI_ITD_STATUS_TRANSACTION_ERR           (0x10000000) /*bit 4 = 0001*/
+
+#define  EHCI_ITD_LENGTH_TRANSMITTED               (0x0FFF0000)
+#define  EHCI_ITD_BUFFER_OFFSET                    (0x00000FFF)
+#define  EHCI_ITD_PAGE_NUMBER                      (0x00007000)
+#define  EHCI_ITD_BUFFER_POINTER                   (0xFFFFF000)
+#define  EHCI_ITD_MULTI_TRANSACTION_BITS           (0x00000003)
+
+
+
+/* SITD position bits */
+#define  EHCI_SITD_DIRECTION_BIT_POS                (31)
+#define  EHCI_SITD_PORT_NUMBER_BIT_POS              (24)
+#define  EHCI_SITD_HUB_ADDR_BIT_POS                 (16)
+#define  EHCI_SITD_EP_ADDR_BIT_POS                  (8)
+
+#define  EHCI_SITD_COMPLETE_SPLIT_MASK_BIT_POS      (8)
+
+#define  EHCI_SITD_IOC_BIT_SET                      (0x80000000)
+#define  EHCI_SITD_PAGE_SELECT_BIT_POS              (30)
+#define  EHCI_SITD_TRANSFER_LENGTH_BIT_POS          (16)
+#define  EHCI_SITD_STATUS_ACTIVE                    (0x80)
+
+#define  EHCI_SITD_STATUS                           (0xFF)
+#define  EHCI_SITD_LENGTH_TRANSMITTED               (0x03FF0000)
+#define  EHCI_SITD_BUFFER_OFFSET                    (0x00000FFF)
+#define  EHCI_SITD_PAGE_NUMBER                      (0x40000000)
+#define  EHCI_SITD_BUFFER_POINTER                   (0xFFFFF000)
+
+
+
+#define  EHCI_SITD_BUFFER_PTR_BIT_POS              (12)
+#define  EHCI_SITD_TP_BIT_POS                      (3)
+#define  EHCI_SITD_TP_ALL                          (0)
+#define  EHCI_SITD_TP_BEGIN                        (1)
+#define  EHCI_SITD_TP_MID                          (2)
+#define  EHCI_SITD_TP_END                          (3)
+
+
+
+/* Interrupt enable bit masks */
+#define  EHCI_IER_ASYNCH_ADVANCE                   (0x00000020)
+#define  EHCI_IER_HOST_SYS_ERROR                   (0x00000010)
+#define  EHCI_IER_FRAME_LIST_ROLLOVER              (0x00000008)
+#define  EHCI_IER_PORT_CHANGE                      (0x00000004)
+#define  EHCI_IER_USB_ERROR                        (0x00000002)
+#define  EHCI_IER_USB_INTERRUPT                    (0x00000001)
+
+/* Interrupt status bit masks */
+#define  EHCI_STS_RECLAIMATION                     (0x00002000)
+#define  EHCI_STS_SOF_COUNT                        (0x00000080)
+#define  EHCI_STS_ASYNCH_ADVANCE                   (0x00000020)
+#define  EHCI_STS_HOST_SYS_ERROR                   (0x00000010)
+#define  EHCI_STS_FRAME_LIST_ROLLOVER              (0x00000008)
+#define  EHCI_STS_PORT_CHANGE                      (0x00000004)
+#define  EHCI_STS_USB_ERROR                        (0x00000002)
+#define  EHCI_STS_USB_INTERRUPT                    (0x00000001)
+
+/* Status bit masks */
+#define  EHCI_STS_ASYNCH_SCHEDULE                  (0x00008000)
+#define  EHCI_STS_PERIODIC_SCHEDULE                (0x00004000)
+#define  EHCI_STS_RECLAMATION                      (0x00002000)
+#define  EHCI_STS_HC_HALTED                        (0x00001000)
+
+/* USB command bit masks */
+#define  EHCI_USBCMD_ASYNC_SCHED_ENABLE            (0x00000020)
+#define  EHCI_USBCMD_PERIODIC_SCHED_ENABLE         (0x00000010)
+
+#define  EHCI_HCS_PARAMS_N_PORTS                   (0x0F)
+
+#define  VUSB_HS_DELAY                             (3500)
+
+#define  EHCI_QH_EP_NUM_MASK                       (0x0F00)
+#define  EHCI_QH_EP_NUM_BITS_POS                   (8)
+#define  EHCI_QH_DEVICE_ADDRESS_MASK               (0x7F)
+#define  EHCI_QH_SPEED_BITS_POS                    (12)
+#define  EHCI_QH_MAX_PKT_SIZE_BITS_POS             (16)
+#define  EHCI_QH_NAK_COUNT_RL_BITS_POS             (28)
+#define  EHCI_QH_EP_CTRL_FLAG_BIT_POS              (27)
+#define  EHCI_QH_HEAD_RECLAMATION_BIT_POS          (15)
+#define  EHCI_QH_DTC_BIT_POS                       (14)
+#define  EHCI_QH_HIGH_BW_MULT_BIT_POS              (30)
+#define  EHCI_QH_HUB_PORT_NUM_BITS_POS             (23)
+#define  EHCI_QH_HUB_ADDR_BITS_POS                 (16)
+#define  EHCI_QH_SPLIT_COMPLETION_MASK_BITS_POS    (8)
+#define  EHCI_QH_SPLIT_COMPLETION_MASK             (0xFF00)
+#define  EHCI_QH_INTR_SCHED_MASK                   (0xFF)
+#define  EHCI_QH_INACTIVATE_NEXT_TR_BIT_POS        (7)
+#define  EHCI_QH_HORIZ_PHY_ADDRESS_MASK            (0xFFFFFFE0)
+#define  EHCI_QH_TR_OVERLAY_DT_BIT                 (0x80000000)
+
+#define  EHCI_SITD_SPLIT_COMPLETION_MASK_BITS_POS  (8)
+
+#define  EHCI_INTR_NO_THRESHOLD_IMMEDIATE          (0x00010000)
+#define  EHCI_NEW_PERIODIC_FRAME_LIST_SIZE         (1024)
+#define  EHCI_FRAME_LIST_SIZE_BITS_POS             (2)
+#define  EHCI_HORIZ_PHY_ADDRESS_MASK              (0xFFFFFFE0)
+
+#define  DEFAULT_MAX_NAK_COUNT                     (15)
+
+/* OTG Status and control register bit masks */
+
+/* OTG interrupt enable bit masks */
+#define  VUSBHS_OTGSC_INTERRUPT_ENABLE_BITS_MASK   (0x5F000000)
+#define  VUSBHS_OTGSC_DPIE                         (0x40000000)   /* Data-line pulsing IE */
+#define  VUSBHS_OTGSC_1MSIE                        (0x20000000)
+#define  VUSBHS_OTGSC_BSEIE                        (0x10000000)   /* B-session end IE */
+#define  VUSBHS_OTGSC_BSVIE                        (0x08000000)   /* B-session valid IE */
+#define  VUSBHS_OTGSC_ASVIE                        (0x04000000)   /* A-session valid IE */
+#define  VUSBHS_OTGSC_AVVIE                        (0x02000000)   /* A-V-bus valid IE */
+#define  VUSBHS_OTGSC_IDIE                         (0x01000000)   /* OTG ID IE */
+
+/* OTG interrupt status bit masks */
+#define  VUSBHS_OTGSC_INTERRUPT_STATUS_BITS_MASK   (0x005F0000)
+#define  VUSBHS_OTGSC_DPIS                         (0x00400000)   /* Data-line pulsing IS */
+#define  VUSBHS_OTGSC_1MSIS                        (0x00200000)
+#define  VUSBHS_OTGSC_BSEIS                        (0x00100000)   /* B-session end IS */
+#define  VUSBHS_OTGSC_BSVIS                        (0x00080000)   /* B-session valid IS */
+#define  VUSBHS_OTGSC_ASVIS                        (0x00040000)   /* A-session valid IS */
+#define  VUSBHS_OTGSC_AVVIS                        (0x00020000)   /* A-Vbus valid IS */
+#define  VUSBHS_OTGSC_IDIS                         (0x00010000)   /* OTG ID IS */
+
+/* OTG status bit masks */
+#define  VUSBHS_OTGSC_DPS                          (0x00004000)
+#define  VUSBHS_OTGSC_BSE                          (0x00001000)   /* B-session end */
+#define  VUSBHS_OTGSC_BSV                          (0x00000800)   /* B-session valid */
+#define  VUSBHS_OTGSC_ASV                          (0x00000400)   /* A-session valid */
+#define  VUSBHS_OTGSC_AVV                          (0x00000200)   /* A-Vbus Valid */
+#define  VUSBHS_OTGSC_ID                           (0x00000100)   /* OTG ID */
+
+/* OTG control bit masks */
+#define  VUSBHS_OTGSC_CTL_BITS                     (0x2F)
+#define  VUSBHS_OTGSC_HABA                         (0x00000080)   /* hardware assisted data pulse bits*/
+#define  VUSBHS_OTGSC_HADP                         (0x00000040)   /* hardware assisted data pulse bits*/
+
+#ifdef PATCH_3
+/* the following change is to be compatable with 4.0 revision of
+hardware. Enable the following switch in config.mk to enable the
+changes. */
+
+    /* WEB20040409 below line changed from VUSBHS_OTGSC_B_HOST_EN to VUSBHS_OTGSC_IDPU
+       to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
+    #define  VUSBHS_OTGSC_IDPU                         (0x00000020)   /* ID pull enable */
+#else
+    #define  VUSBHS_OTGSC_B_HOST_EN                    (0x00000020)   /* B_host_enable */
+#endif
+
+#define  VUSBHS_OTGSC_DP                           (0x00000010)   /* Data-pulsing */
+#define  VUSBHS_OTGSC_OT                           (0x00000008)   /* OTG termination */
+#define  VUSBHS_OTGSC_HAAR                         (0x00000004)   /* Auto reset bit*/
+#define  VUSBHS_OTGSC_VC                           (0x00000002)   /* Vbus charge */
+#define  VUSBHS_OTGSC_VD                           (0x00000001)   /* Vbus discharge */
+
+typedef  uint_32  USB_REGISTER, _PTR_ USB_REGISTER_PTR;
+
+/* The VUSB register structure */
+typedef struct {
+   union  {
+      struct  {
+         volatile USB_REGISTER   CAPLENGTH_HCIVER;
+         volatile USB_REGISTER   HCS_PARAMS;       /* HC structural parameters */
+         volatile USB_REGISTER   HCC_PARAMS;       /* HC Capability Parameters*/
+         volatile USB_REGISTER   RESERVED1[5];
+         volatile USB_REGISTER   DCI_VERSION;      /* DC version number and reserved 16 bits */
+         volatile USB_REGISTER   DCC_PARAMS;       /* DC Capability Parameters */
+      } CAPABILITY_REGISTERS;
+
+      struct  {
+         volatile USB_REGISTER   USB_CMD;                   /* Command register */
+         volatile USB_REGISTER   USB_STS;                   /* Status register */
+         volatile USB_REGISTER   USB_INTR;                  /* Interrupt enable */
+         volatile USB_REGISTER   USB_FRINDEX;               /* Frame index */
+         volatile USB_REGISTER   CTRLDSSEGMENT;             /* 4G segment selector */
+         volatile USB_REGISTER   DEVICE_ADDR;               /* Device Address */
+         volatile USB_REGISTER   EP_LIST_ADDR;              /* Endpoint List Address */
+         volatile USB_REGISTER   RESERVED0[9];
+         volatile USB_REGISTER   CONFIG_FLAG;               /* Configured Flag register */
+         volatile USB_REGISTER   PORTSCX[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
+         volatile USB_REGISTER   OTGSC;
+         volatile USB_REGISTER   USB_MODE;                  /* USB Host/Device mode */
+         volatile USB_REGISTER   ENDPT_SETUP_STAT;          /* Endpoint Setup Status */
+         volatile USB_REGISTER   ENDPTPRIME;                /* Endpoint Initialize */
+         volatile USB_REGISTER   ENDPTFLUSH;                /* Endpoint De-initialize */
+         volatile USB_REGISTER   ENDPTSTATUS;               /* Endpoint Status */
+         volatile USB_REGISTER   ENDPTCOMPLETE;             /* Endpoint Interrupt On Complete */
+         volatile USB_REGISTER   ENDPTCTRLX[16];            /* Endpoint Control, where x = 0.. 15 */
+      } OPERATIONAL_DEVICE_REGISTERS;
+
+      struct  {
+         volatile USB_REGISTER   USB_CMD;                   /* Command register */
+         volatile USB_REGISTER   USB_STS;                   /* Status register */
+         volatile USB_REGISTER   USB_INTR;                  /* Interrupt enable */
+         volatile USB_REGISTER   USB_FRINDEX;               /* Frame index */
+         volatile USB_REGISTER   CTRLDSSEGMENT;             /* 4G segment selector */
+         volatile USB_REGISTER   PERIODIC_LIST_BASE_ADDR;   /* Periodic schedule list */
+         volatile USB_REGISTER   CURR_ASYNC_LIST_ADDR;      /* Current Asynch schedule list */
+         volatile USB_REGISTER   ASYNCTTSTS;                /* Async buffer in embedded TT control */
+         volatile USB_REGISTER   RESERVED0[8];
+         volatile USB_REGISTER   CONFIG_FLAG;               /* Configured Flag register */
+         volatile USB_REGISTER   PORTSCX[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
+         volatile USB_REGISTER   OTGSC;                     /* OTG status and control register */
+         volatile USB_REGISTER   USB_MODE;                  /* USB Host/Device mode */
+      } OPERATIONAL_HOST_REGISTERS;
+   } REGISTERS;
+} VUSB20_REG_STRUCT, _PTR_ VUSB20_REG_STRUCT_PTR;
+
+typedef struct {
+   volatile uint_32   MAX_PKT_LENGTH;    /* Bits 16..26 Bit 15 is Interrupt
+                                          ** On Setup
+                                          */
+   volatile uint_32   CURR_DTD_PTR;        /* Current dTD Pointer */
+   volatile uint_32   NEXT_DTD_PTR;        /* Next dTD Pointer */
+   volatile uint_32   SIZE_IOC_INT_STS;    /* Total bytes (16..30), IOC (15),
+                                          ** INT (8), STS (0-7)
+                                          */
+   volatile uint_32   BUFF_PTR0;           /* Buffer pointer Page 0 (12-31) */
+   volatile uint_32   BUFF_PTR1;           /* Buffer pointer Page 1 (12-31) */
+   volatile uint_32   BUFF_PTR2;           /* Buffer pointer Page 2 (12-31) */
+   volatile uint_32   BUFF_PTR3;           /* Buffer pointer Page 3 (12-31) */
+   volatile uint_32   BUFF_PTR4;           /* Buffer pointer Page 4 (12-31) */
+   volatile uint_32   RESERVED1;
+   volatile uint_8    SETUP_BUFFER[8];     /* 8 bytes of setup data that follows
+                                            ** the Setup PID
+                                            */
+   volatile uint_32   RESERVED2[4];
+} VUSB20_EP_QUEUE_HEAD_STRUCT, _PTR_ VUSB20_EP_QUEUE_HEAD_STRUCT_PTR;
+
+typedef struct {
+   pointer              PRIVATE;
+   void (_CODE_PTR_     FREE)(pointer);
+   pointer              XD_FOR_THIS_DTD;
+} SCRATCH_STRUCT, _PTR_ SCRATCH_STRUCT_PTR;
+
+typedef struct ep_tr_struct {
+   volatile uint_32      NEXT_TR_ELEM_PTR; /* Memory address of next
+                                          ** dTD to be processed (5-31)
+                                          ** and the T (bit 0) indicating
+                                          ** pointer validity
+                                          */
+   volatile uint_32      SIZE_IOC_STS;     /* total bytes (16-30),
+                                          ** IOC (15), Status (0-7)
+                                          */
+   volatile uint_32      BUFF_PTR0;        /* Buffer pointer Page 0 */
+   volatile uint_32      BUFF_PTR1;        /* Buffer pointer Page 1 */
+   volatile uint_32      BUFF_PTR2;        /* Buffer pointer Page 2 */
+   volatile uint_32      BUFF_PTR3;        /* Buffer pointer Page 3 */
+   volatile uint_32      BUFF_PTR4;        /* Buffer pointer Page 4 */
+   volatile SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+} VUSB20_EP_TR_STRUCT, _PTR_ VUSB20_EP_TR_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of
+                                          ** next schedule data structure
+                                          ** item Type (1..2 ) and the
+                                          ** T (bit 0) indicating pointer
+                                          ** validity
+                                          */
+   uint_32      TR_STATUS_CTL_LIST[8];  /* bits 31-28: Status,
+                                                ** bits 27-16: Tr X length
+                                                ** bit 15: Int on complete
+                                                ** bits 14-12: Page Select
+                                                ** bits 11-0: Tr X offset
+                                                */
+   uint_32      BUFFER_PAGE_PTR_LIST[7];  /* bits 31-12 4K aligned pointer
+                                                ** to physical memory
+                                                ** bits 11-8 endpoint no.
+                                                ** bit 7: reserved
+                                                ** bits 6-0 device address*/
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer      PIPE_DESCR_FOR_THIS_ITD;
+   pointer      PIPE_TR_DESCR_FOR_THIS_ITD;
+   uint_32_ptr  frame_list_ptr;
+   uint_32      number_of_transactions;
+   /* 32-byte aligned structures */
+   uint_32        RESERVED_A[11];
+} EHCI_ITD_STRUCT, _PTR_ EHCI_ITD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_LINK_PTR;    /* (5-31) Memory address of
+                                          ** next schedule data structure
+                                          ** item Type (1..2 ) and the
+                                          ** T (bit 0) indicating pointer
+                                          ** validity
+                                          */
+   uint_32      EP_CAPAB_CHARAC;  /* bits 31: Direction (I/O),
+                                          ** bits 30-24: Port number
+                                          ** bit 23: reserved
+                                          ** bits 22-16: Hub address
+                                          ** bits 15-12: Reserved
+                                          ** bits 11-8: Endpoint number
+                                          ** bit 7: reserved
+                                          ** bits 6-0: device address
+                                          */
+   uint_32      UFRAME_SCHED_CTL; /* bits 31-16: reserved
+                                          ** bits 15-8: Split completion mask
+                                          ** bits 7-0: Split start mask
+                                          */
+   uint_32      TRANSFER_STATE;   /* bit 31: int on complete
+                                          ** bit 30: Page Select
+                                          ** bits 29-26: Reserved
+                                          ** bits 25-16: total bytes to
+                                          ** transfer
+                                          ** bits 15-8: uframe
+                                          ** complete-split progress mask
+                                          ** bits 7-0: status
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bits 31-12: 4K aligned pointer
+                                          ** to physical memory
+                                          ** bits 11-0: Current offset
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bits 31-12: 4K aligned pointer
+                                          ** to physical memory
+                                          ** bits 11-5 reserved
+                                          ** bits 4-3 tr position
+                                          ** bits 2-0 tr count
+                                          */
+   uint_32      BACK_LINK_PTR;    /* bits 31-5 back pointer points to sITD
+                                          ** bits 4-1: reserved
+                                          ** bit 0: terminate
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer      PIPE_DESCR_FOR_THIS_SITD;
+   pointer      PIPE_TR_DESCR_FOR_THIS_SITD;
+   uint_32_ptr  frame_list_ptr;
+
+   /* align to 16 word boundry */
+   uint_32      RESERVED_B[5];
+
+} EHCI_SITD_STRUCT, _PTR_ EHCI_SITD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NEXT_QTD_PTR;     /* (5-31) Memory address of
+                                          ** next qTD to be processed
+                                          ** (4..1) reserved
+                                          ** T (bit 0) indicating pointer
+                                          ** validity
+                                          */
+   uint_32      ALT_NEXT_QTD_PTR; /* bits 31-5: alternate next
+                                          ** qTD if the above one encounters
+                                          ** a short packet
+                                          ** (4..1) reserved
+                                          ** T (bit 0) indicating pointer
+                                          ** validity
+                                          */
+   uint_32      TOKEN;            /* bits 31: data toggle
+                                          ** bits 30-16: Total bytes to transfer
+                                          ** bit 15: Interrupt on Complete
+                                          ** bits 14-12: Current page
+                                          ** bits 11-10: Error Counter
+                                          ** bits 9-8: PID code
+                                          ** bits 7-0: status
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: Current Offset
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_2;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer     PIPE_DESCR_FOR_THIS_QTD;
+   pointer     TR_FOR_THIS_QTD;
+   uint_32     RESERVED_C[5];
+} EHCI_QTD_STRUCT, _PTR_ EHCI_QTD_STRUCT_PTR;
+
+typedef struct {
+   uint_32      HORIZ_LINK_PTR;   /* (5-31) Memory address of
+                                          ** next data object to be processed
+                                          ** (4..3) reserved
+                                          ** (2..1) type of the item
+                                          ** T (bit 0) indicating pointer
+                                          ** validity
+                                          */
+   uint_32      EP_CAPAB_CHARAC1; /* bits 31-28: NAK count reload,
+                                          ** bit 27: Control endpoint flag
+                                          ** bit 26-16: Maximum packet length
+                                          ** bit 15: Head of reclamation
+                                          ** list flag
+                                          ** bit 14: data toggle control
+                                          ** bits 13-12: endpoint speed
+                                          ** bit 11-8: endpoint number
+                                          ** bits 7: Inactivate on next tr
+                                          ** bits 6-0: Device address
+                                          */
+   uint_32      EP_CAPAB_CHARAC2; /* bits 31-30: High-BW pipe
+                                          ** Multiplier,
+                                          ** bit 29-23: Port number
+                                          ** bit 22-16: Hub address
+                                          ** bit 15-8: Split completion mask
+                                          ** bit 7-0: Interrupt schedule mask
+                                          */
+   uint_32      CURR_QTD_LINK_PTR;/* bits 31-5: physical memory address
+                                          ** of the current xaction processed
+                                          */
+   uint_32      NEXT_QTD_LINK_PTR;/* bits 31-5: physical memory address
+                                          ** of the current xaction processed
+                                          ** bit 0: Terminate bit
+                                          */
+   uint_32      ALT_NEXT_QTD_LINK_PTR;  /* bits 31-5: physical memory address
+                                                ** of the current xaction processed
+                                                ** bits 4-1: NAK counter
+                                                ** bit 0: Terminate bit
+                                                */
+   uint_32      STATUS;           /* bit 31: data-toggle
+                                          ** bits 30-16: total bytes to transfer
+                                          ** bit 15: Interrupt on complete
+                                          ** bits 11-10: Error counter
+                                          ** bit 0: Ping state/Err
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_0;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_1;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 7-0: Split-transaction,
+                                          ** complete-split progress
+                                          */
+   uint_32      BUFFER_PTR_2;     /* bits 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bits 11-5: S-bytes
+                                          ** bits 4-0: Split-transaction
+                                          ** frame tag
+                                          */
+   uint_32      BUFFER_PTR_3;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   uint_32      BUFFER_PTR_4;     /* bit 31-12: 4K-page aligned
+                                          ** physical memory address
+                                          ** bit 11-0: reserved
+                                          */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   pointer     PIPE_DESCR_FOR_THIS_QH;
+   uint_32     RESERVED_D[18];
+} EHCI_QH_STRUCT, _PTR_ EHCI_QH_STRUCT_PTR;
+
+typedef struct {
+   uint_32      NORMAL_PATH_LINK_PTR;   /* (5-31) Memory address of
+                                                ** next data object to be processed
+                                                ** in the periodic list
+                                                ** bits 4-3: reserved
+                                                ** (2..1) type of the item
+                                                ** T (bit 0) indicating pointer
+                                                ** validity
+                                                */
+   uint_32      BACK_PATH_LINK_PTR;     /* bits 31-5: Memory address of
+                                                ** the queue head,
+                                                ** bit 4-3: reserved
+                                                ** (2..1) type of the item
+                                                ** T (bit 0) indicating pointer
+                                                ** validity
+                                                */
+   SCRATCH_STRUCT_PTR   SCRATCH_PTR;
+   /* 32-bytes aligned */
+   uint_32              RESERVED_E[6];
+} EHCI_FSTN_STRUCT, _PTR_ EHCI_FSTN_STRUCT_PTR;
+
+typedef uint_32   EHCI_FRAME_LIST_ELEMENT_POINTER;
+
+#endif /* __mvUsbCore_h__ */
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbDesc.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbDesc.h
new file mode 100644
index 0000000..7a04e93
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/common/mvUsbDesc.h
@@ -0,0 +1,162 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDesc_h__
+#define __mvUsbDesc_h__
+
+#include "mvUsbTypes.h"
+
+typedef struct usb_device_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 18 */
+   uint_8   bDescriptorType;  /* DEVICE descriptor type = 1 */
+   uint_8   bcdUSD[2];        /* USB spec in BCD, e.g. 0x0200 */
+   uint_8   bDeviceClass;     /* Class code, if 0 see interface */
+   uint_8   bDeviceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bDeviceProtocol;  /* Protocol, if 0 see interface */
+   uint_8   bMaxPacketSize;   /* Endpoint 0 max. size */
+   uint_8   idVendor[2];      /* Vendor ID per USB-IF */
+   uint_8   idProduct[2];     /* Product ID per manufacturer */
+   uint_8   bcdDevice[2];     /* Device release # in BCD */
+   uint_8   iManufacturer;    /* Index to manufacturer string */
+   uint_8   iProduct;         /* Index to product string */
+   uint_8   iSerialNumber;    /* Index to serial number string */
+   uint_8   bNumConfigurations; /* Number of possible configurations */
+} DEVICE_DESCRIPTOR, _PTR_ DEVICE_DESCRIPTOR_PTR;
+
+typedef struct usb_configuration_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* CONFIGURATION type = 2 or 7 */
+   uint_8   wTotalLength[2];  /* Length of concatenated descriptors */
+   uint_8   bNumInterfaces;   /* Number of interfaces, this config. */
+   uint_8   bConfigurationValue;  /* Value to set this config. */
+   uint_8   iConfig;          /* Index to configuration string */
+   uint_8   bmAttributes;     /* Config. characteristics */
+   #define  CONFIG_RES7       (0x80)  /* Reserved, always = 1 */
+   #define  CONFIG_SELF_PWR   (0x40)  /* Self-powered device */
+   #define  CONFIG_WAKEUP     (0x20)  /* Remote wakeup */
+   uint_8   bMaxPower;        /* Max.power from bus, 2mA units */
+} CONFIGURATION_DESCRIPTOR, _PTR_ CONFIGURATION_DESCRIPTOR_PTR;
+
+typedef struct usb_interface_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* INTERFACE descriptor type = 4 */
+   uint_8   bInterfaceNumber; /* Interface no.*/
+   uint_8   bAlternateSetting;  /* Value to select this IF */
+   uint_8   bNumEndpoints;    /* Number of endpoints excluding 0 */
+   uint_8   bInterfaceClass;  /* Class code, 0xFF = vendor */
+   uint_8   bInterfaceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bInterfaceProtocol;  /* Protocol, 0xFF = vendor */
+   uint_8   iInterface;       /* Index to interface string */
+} INTERFACE_DESCRIPTOR, _PTR_ INTERFACE_DESCRIPTOR_PTR;
+
+typedef struct usb_endpoint_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 7 */
+   uint_8   bDescriptorType;  /* ENDPOINT descriptor type = 5 */
+   uint_8   bEndpointAddress; /* Endpoint # 0 - 15 | IN/OUT */
+   #define  IN_ENDPOINT    (0x80)   /* IN endpoint, device to host */
+   #define  OUT_ENDPOINT   (0x00)   /* OUT endpoint, host to device */
+   #define  ENDPOINT_MASK  (0x0F)   /* Mask endpoint # */
+   uint_8   bmAttributes;     /* Transfer type */
+   #define  CONTROL_ENDPOINT  (0x00)   /* Control transfers */
+   #define  ISOCH_ENDPOINT    (0x01)   /* Isochronous transfers */
+   #define  BULK_ENDPOINT     (0x02)   /* Bulk transfers */
+   #define  IRRPT_ENDPOINT    (0x03)   /* Interrupt transfers */
+   #define  EP_TYPE_MASK      (0x03)   /* Mask type bits */
+   /* Following must be zero except for isochronous endpoints */
+   #define  ISOCH_NOSYNC      (0x00)   /* No synchronization */
+   #define  ISOCH_ASYNC       (0x04)   /* Asynchronous */
+   #define  ISOCH_ADAPT       (0x08)   /* Adaptive */
+   #define  ISOCH_SYNCH       (0x0C)   /* Synchrounous */
+   #define  ISOCH_DATA        (0x00)   /* Data endpoint */
+   #define  ISOCH_FEEDBACK    (0x10)   /* Feedback endpoint */
+   #define  ISOCH_IMPLICIT    (0x20)   /* Implicit feedback */
+   #define  ISOCH_RESERVED    (0x30)   /* Reserved */
+   uint_8   wMaxPacketSize[2];   /* Bits 10:0 = max. packet size */
+   /* For high-speed interrupt or isochronous only, additional
+   **   transaction opportunities per microframe follow.*/
+   #define  PACKET_SIZE_MASK     (0x7FF)  /* packet size bits */
+   #define  NO_ADDITONAL      (0x0000)   /* 1 / microframe */
+   #define  ONE_ADDITIONAL    (0x0800)   /* 2 / microframe */
+   #define  TWO_ADDITIONAL    (0x1000)   /* 3 / microframe */
+   #define  ADDITIONAL_MASK   (ONE_ADDITIONAL | TWO_ADDITIONAL)
+   uint_8   iInterval;        /* Polling interval in (micro) frames */
+} ENDPOINT_DESCRIPTOR, _PTR_ ENDPOINT_DESCRIPTOR_PTR;
+
+typedef struct usb_qualifier_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 10 */
+   uint_8   bDescriptorType;  /* DEVICE QUALIFIER type = 6 */
+   uint_8   bcdUSD[2];        /* USB spec in BCD, e.g. 0x0200 */
+   uint_8   bDeviceClass;     /* Class code, if 0 see interface */
+   uint_8   bDeviceSubClass;  /* Sub-Class code, 0 if class = 0 */
+   uint_8   bDeviceProtocol;  /* Protocol, if 0 see interface */
+   uint_8   bMaxPacketSize;   /* Endpoint 0 max. size */
+   uint_8   bNumConfigurations; /* Number of possible configurations */
+   uint_8   bReserved;        /* Reserved = 0 */
+} QUALIFIER_DESCRIPTOR, _PTR_ QUALIFIER_DESCRIPTOR_PTR;
+
+/* Other-Config type 7 fields are identical to type 2 above */
+
+/* Interface-Power descriptor  type 8 not used  in this version */
+
+typedef struct usb_otg_descriptor
+{
+   uint_8   bLength;          /* Descriptor size in bytes = 9 */
+   uint_8   bDescriptorType;  /* CONFIGURATION type = 2 or 7 */
+   uint_8   bmAttributes;     /* OTG characteristics */
+   #define  OTG_SRP_SUPPORT   (0x01)  /* Supports SRP */
+   #define  OTG_HNP_SUPPORT   (0x02)  /* Supports HNP */
+} OTG_DESCRIPTOR, _PTR_ OTG_DESCRIPTOR_PTR;
+
+typedef union descriptor_union
+{
+   uint_32                       word;
+   uint_8_ptr                    bufr;
+   pointer                       pntr;
+   DEVICE_DESCRIPTOR_PTR         dvic;
+   CONFIGURATION_DESCRIPTOR_PTR  cfig;
+   INTERFACE_DESCRIPTOR_PTR      intf;
+   ENDPOINT_DESCRIPTOR_PTR       ndpt;
+   QUALIFIER_DESCRIPTOR_PTR      qual;
+   OTG_DESCRIPTOR_PTR            otg;
+}  DESCRIPTOR_UNION, _PTR_ DESCRIPTOR_UNION_PTR;
+
+/* Prototypes */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern uint_32 usb_host_init(uint_8, uint_32,
+                  _usb_host_handle _PTR_);
+extern uint_32 _usb_host_open_pipe(_usb_host_handle,
+                  PIPE_INIT_PARAM_STRUCT_PTR, _usb_pipe_handle _PTR_ );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __mvUsbDesc_h__ */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevCh9.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevCh9.c
new file mode 100644
index 0000000..b6bbb73
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevCh9.c
@@ -0,0 +1,304 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+#include "api/mvUsbCh9.h"
+
+static volatile boolean  ENTER_TEST_MODE = FALSE;
+static volatile uint_16  test_mode_index = 0;
+
+
+void    mvUsbCh9GetStatus(_usb_device_handle handle, boolean setup,
+                         SETUP_STRUCT* ctrl_req)
+{ /* Body */
+    uint_8                  endpoint, direction;
+    uint_16                 usb_status;
+    USB_DEV_STATE_STRUCT*   usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    if(!setup)
+        return;
+
+    switch (ctrl_req->REQUESTTYPE)
+    {
+       case (REQ_DIR_IN | REQ_RECIP_DEVICE):
+          /* Device request */
+          _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+          break;
+
+       case (REQ_DIR_IN | REQ_RECIP_INTERFACE):
+          /* Interface request */
+          _usb_device_get_status(handle, ARC_USB_STATUS_INTERFACE, &usb_status);
+          break;
+
+       case (REQ_DIR_IN | REQ_RECIP_ENDPOINT):
+          /* Endpoint request */
+          endpoint = ctrl_req->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+          if( (ctrl_req->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+            direction = ARC_USB_SEND;
+          else
+            direction = ARC_USB_RECV;
+
+          usb_status = _usb_device_is_endpoint_stalled(handle, endpoint, direction);
+          break;
+
+       default:
+          /* Unknown request */
+           USB_printf("GetStatus: Unknown request type 0x%x\n", ctrl_req->REQUESTTYPE);
+          _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+          return;
+    } /* Endswitch */
+
+    /* Send the requested data */
+    *usb_dev_ptr->STATUS_PTR = USB_16BIT_LE(usb_status);
+    _usb_device_send_data(handle, 0, (uint_8_ptr)usb_dev_ptr->STATUS_PTR, sizeof(uint_16));
+
+    /* status phase */
+    _usb_device_recv_data(handle, 0, NULL, 0);
+
+    return;
+} /* Endbody */
+
+void    mvUsbCh9ClearFeature(_usb_device_handle handle, boolean setup,
+                            SETUP_STRUCT* setup_ptr)
+{ /* Body */
+    uint_8   endpoint, direction;
+    uint_16  usb_status;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
+    if ((usb_status != ARC_USB_STATE_CONFIG) && (usb_status != ARC_USB_STATE_ADDRESS))
+    {
+        USB_printf("ClearFeature: Wrong USB state %d\n", usb_status);
+        _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+        return;
+    } /* Endif */
+
+    if(!setup)
+        return;
+
+    switch (setup_ptr->REQUESTTYPE)
+    {
+        case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
+            /* DEVICE */
+            switch(setup_ptr->VALUE)
+            {
+                case DEVICE_REMOTE_WAKEUP:
+                    /* clear remote wakeup */
+                    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+                    usb_status &= ~ARC_USB_REMOTE_WAKEUP;
+                    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, usb_status);
+                    USB_printf("Clear REMOTE_WAKEUP feature\n");
+                    break;
+
+                case DEVICE_TEST_MODE:
+                    /* Exit Test Mode */
+                    _usb_device_set_status(handle, ARC_USB_STATUS_TEST_MODE, 0);
+                    break;
+
+                default:
+                    USB_printf("ClearFeature: Unknown Device feature %d\n",
+                                setup_ptr->VALUE);
+                    _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                    return;
+            } /* Endif */
+            break;
+
+        case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
+            /* ENDPOINT */
+            if (setup_ptr->VALUE != ENDPOINT_HALT)
+            {
+                USB_printf("ClearFeature: Wrong Endpoint feature %d\n",
+                            setup_ptr->VALUE);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+            } /* Endif */
+
+            endpoint = setup_ptr->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+            if( (setup_ptr->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+                direction = ARC_USB_SEND;
+            else
+                direction = ARC_USB_RECV;
+
+            _usb_device_unstall_endpoint(handle, endpoint, direction);
+            break;
+
+        default:
+            USB_printf("ClearFeature: Unknown REQUEST_TYPE %d\n",
+                                setup_ptr->REQUESTTYPE);
+
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+    } /* Endswitch */
+
+    /* status phase */
+    _usb_device_send_data(handle, 0, 0, 0);
+}
+
+void    mvUsbCh9SetFeature(_usb_device_handle handle, boolean setup,
+                          SETUP_STRUCT* setup_ptr)
+{
+   uint_16                  usb_status;
+   uint_8                   endpoint, direction;
+   USB_DEV_STATE_STRUCT*    usb_dev_ptr = (USB_DEV_STATE_STRUCT*)handle;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "%s: setup=%d\n", __FUNCTION__, (int)setup);
+
+   if (setup)
+   {
+      switch (setup_ptr->REQUESTTYPE)
+      {
+         case (REQ_DIR_OUT | REQ_RECIP_DEVICE):
+            /* DEVICE */
+            switch (setup_ptr->VALUE)
+            {
+               case DEVICE_REMOTE_WAKEUP:
+                  /* set remote wakeup */
+                  _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+                  usb_status |= ARC_USB_REMOTE_WAKEUP;
+                  _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, usb_status);
+                  USB_printf("Set REMOTE_WAKEUP feature\n");
+                  break;
+
+               case DEVICE_TEST_MODE:
+                  /* Test Mode */
+                  if( (setup_ptr->INDEX & 0x00FF) || (usb_dev_ptr->SPEED != ARC_USB_SPEED_HIGH) )
+                  {
+                     USB_printf("SetFeature: Wrong Test mode parameters: mode=%d, speed=%d\n",
+                                (setup_ptr->INDEX & 0x00FF), usb_dev_ptr->SPEED);
+                     _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                     return;
+                  } /* Endif */
+
+                  _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_status);
+                  if( (usb_status == ARC_USB_STATE_CONFIG)  ||
+                      (usb_status == ARC_USB_STATE_ADDRESS) ||
+                      (usb_status == ARC_USB_STATE_DEFAULT))
+                  {
+                      /* wait with Set Test mode */
+                      ENTER_TEST_MODE = TRUE;
+                      test_mode_index = (setup_ptr->INDEX & 0xFF00);
+                      USB_printf("SetFeature: Prepare for Test mode 0x%x\n", test_mode_index);
+                  }
+                  else
+                  {
+                     USB_printf("SetFeature: Wrong USB state for Test mode: state=%d\n",
+                                usb_status);
+                     _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                     return;
+                  } /* Endif */
+                  break;
+
+               default:
+                    USB_printf("SetFeature: Unknown Device feature %d\n",
+                                setup_ptr->VALUE);
+                  _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                  return;
+            } /* Endswitch */
+            break;
+
+         case (REQ_DIR_OUT | REQ_RECIP_ENDPOINT):
+            /* ENDPOINT */
+            if (setup_ptr->VALUE != ENDPOINT_HALT)
+            {
+                USB_printf("SetFeature: Unknown Endpoint feature %d\n",
+                            setup_ptr->VALUE);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+            } /* Endif */
+
+            endpoint = setup_ptr->INDEX & ARC_USB_STATUS_ENDPOINT_NUMBER_MASK;
+            if( (setup_ptr->INDEX & (1 << REQ_DIR_OFFSET)) == REQ_DIR_IN)
+                direction = ARC_USB_SEND;
+            else
+                direction = ARC_USB_RECV;
+
+            _usb_device_stall_endpoint(handle, endpoint, direction);
+            break;
+
+         default:
+            USB_printf("SetFeature: Unknown REQUEST_TYPE %d\n",
+                       setup_ptr->REQUESTTYPE);
+
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+      } /* Endswitch */
+
+      /* status phase */
+      _usb_device_send_data(handle, 0, 0, 0);
+   }
+   else
+   {
+      if (ENTER_TEST_MODE)
+      {
+         /* Enter Test Mode */
+          USB_printf("SetFeature: Activate Test mode 0x%x\n", test_mode_index);
+         _usb_device_set_status(handle, ARC_USB_STATUS_TEST_MODE, test_mode_index);
+      } /* Endif */
+   } /* Endif */
+}
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetAddress
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetAddress command
+*     We setup a TX packet of 0 length ready for the IN token
+*     Once we get the TOK_DNE interrupt for the IN token, then
+*     we change the ADDR register and go to the ADDRESS state.
+*
+*END*--------------------------------------------------------------------*/
+void    mvUsbCh9SetAddress(_usb_device_handle handle,
+                        boolean setup, SETUP_STRUCT* setup_ptr)
+{ /* Body */
+   static uint_8            new_address;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "usbDisk %s: setup=%d, address=%d\n",
+                                    __FUNCTION__, (int)setup, setup_ptr->VALUE);
+
+   if (setup)
+   {
+      new_address = setup_ptr->VALUE;
+      /*******************************************************
+       * if hardware assitance is enabled for set_address (see
+       * hardware rev for details) we need to do the set_address
+       * before queuing the status phase.
+       *******************************************************/
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE
+       _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
+#endif
+      /* ack */
+      _usb_device_send_data(handle, 0, 0, 0);
+   }
+   else
+   {
+#ifndef SET_ADDRESS_HARDWARE_ASSISTANCE
+      _usb_device_set_status(handle, ARC_USB_STATUS_ADDRESS, new_address);
+#endif
+      _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE, ARC_USB_STATE_ADDRESS);
+   }
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevMain.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevMain.c
new file mode 100644
index 0000000..e2c8893
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevMain.c
@@ -0,0 +1,776 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+USB_IMPORT_FUNCS*           global_import_funcs = NULL;
+
+#ifdef USB_UNDERRUN_WA
+USB_WA_FUNCS*               global_wa_funcs = NULL;
+int                         global_wa_threshold = 64;
+int                         global_wa_sram_parts = 2;
+#endif /* USB_UNDERRUN_WA */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_cleanup
+*  Returned Value : void
+*  Comments       :
+*        Cleanup allocated structures.
+*
+*END*-----------------------------------------------------------------*/
+
+static void    _usb_device_cleanup(USB_DEV_STATE_STRUCT_PTR usb_dev_ptr)
+{
+    /* Free all internal transfer descriptors */
+    if(usb_dev_ptr->XD_BASE != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->XD_BASE);
+    }
+
+    /* Free all XD scratch memory */
+    if(usb_dev_ptr->XD_SCRATCH_STRUCT_BASE != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->XD_SCRATCH_STRUCT_BASE);
+    }
+    /* Free the temp ep init XD */
+    if(usb_dev_ptr->TEMP_XD_PTR != NULL)
+    {
+        USB_memfree((pointer)usb_dev_ptr->TEMP_XD_PTR);
+    }
+
+    if(usb_dev_ptr->STATUS_UNAIGNED_PTR != NULL)
+        USB_memfree((pointer)usb_dev_ptr->STATUS_UNAIGNED_PTR);
+
+    if(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR != NULL)
+        USB_memfree((pointer)usb_dev_ptr->TEST_PKT_UNAIGNED_PTR);
+
+    /* Free the USB state structure */
+    USB_memfree((pointer)usb_dev_ptr);
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_free_XD
+*  Returned Value : void
+*  Comments       :
+*        Enqueues a XD onto the free XD ring.
+*
+*END*-----------------------------------------------------------------*/
+
+void _usb_device_free_XD
+   (
+      /* [IN] the dTD to enqueue */
+      pointer  xd_ptr
+   )
+{ /* Body */
+    int                         lockKey;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)(((XD_STRUCT_PTR)xd_ptr)->SCRATCH_PTR->PRIVATE);
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "free_XD: xd_ptr=0x%x\n", (unsigned)xd_ptr);
+
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.free_XD_count++));
+
+   /*
+   ** This function can be called from any context, and it needs mutual
+   ** exclusion with itself.
+   */
+
+   lockKey = USB_lock();
+
+   /*
+   ** Add the XD to the free XD queue (linked via PRIVATE) and
+   ** increment the tail to the next descriptor
+   */
+   USB_XD_QADD(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, (XD_STRUCT_PTR)xd_ptr);
+   usb_dev_ptr->XD_ENTRIES++;
+
+   USB_unlock(lockKey);
+
+} /* Endbody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_set_bsp_funcs
+*  Returned Value : NONE
+*  Comments       :
+*        Set pointer to structure of imported BSP functions
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_set_bsp_funcs(USB_IMPORT_FUNCS* pBspFuncs)
+{
+    static  boolean isFirst = TRUE;
+
+    if(isFirst)
+    {
+        global_import_funcs = pBspFuncs;
+       _usb_debug_init_trace_log();
+       isFirst = FALSE;
+    }
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_max_endpoint
+*  Returned Value : handle or NULL
+*  Comments       :
+*        Return maximum number of endpoints supportedby USB device
+*        (for DEBUG only)
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_get_max_endpoint(_usb_device_handle handle)
+{
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    return usb_dev_ptr->MAX_ENDPOINTS;
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_dev_num
+*  Returned Value : handle or NULL
+*  Comments       :
+*        Return unique USB device number
+*        (for DEBUG only)
+*
+*END*-----------------------------------------------------------------*/
+uint_8  _usb_device_get_dev_num(_usb_device_handle handle)
+{
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    return usb_dev_ptr->DEV_NUM;
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_init
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device specific data structures and calls
+*  the low-level device controller chip initialization routine.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_init
+   (
+      /* [IN] the USB device controller to initialize */
+      uint_8                    devnum,
+
+      /* [OUT] the USB_USB_dev_initialize state structure */
+      _usb_device_handle*       handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+   XD_STRUCT_PTR                    xd_ptr;
+   uint_8                           i, error;
+   SCRATCH_STRUCT_PTR               temp_scratch_ptr;
+
+   /* global_import_funcs must be initailized before */
+   if(global_import_funcs == NULL)
+       return USBERR_INIT_FAILED;
+
+   if (devnum > MAX_USB_DEVICES)
+   {
+        USB_printf("_usb_device_init, error invalid device number");
+        return USBERR_INVALID_DEVICE_NUM;
+   } /* Endif */
+
+   /* Allocate memory for the state structure */
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)USB_memalloc(sizeof(USB_DEV_STATE_STRUCT));
+   if (usb_dev_ptr == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_DEV_STATE_STRUCT failed\n",
+                    sizeof(USB_DEV_STATE_STRUCT));
+        return USBERR_ALLOC_STATE;
+   } /* Endif */
+
+   /* Zero out the internal USB state structure */
+   USB_memzero(usb_dev_ptr, sizeof(USB_DEV_STATE_STRUCT));
+
+   usb_dev_ptr->DEV_NUM = devnum;
+
+   /* Multiple devices will have different base addresses and
+   ** interrupt vectors (For future)
+   */
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+
+   /* Allocate MAX_XDS_FOR_TR_CALLS */
+   xd_ptr = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+   if (xd_ptr == NULL)
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n",
+                        sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
+        return USBERR_ALLOC_TR;
+   } /* Endif */
+
+   usb_dev_ptr->XD_BASE = xd_ptr;
+
+   _usb_clear_stats(usb_dev_ptr);
+
+   USB_memzero(xd_ptr, sizeof(XD_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+
+   /* Allocate memory for internal scratch structure */
+   usb_dev_ptr->XD_SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)
+                    USB_memalloc(sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS);
+   if (usb_dev_ptr->XD_SCRATCH_STRUCT_BASE == NULL)
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, malloc of %d bytes for %d XD_STRUCT failed\n",
+                        sizeof(SCRATCH_STRUCT) * MAX_XDS_FOR_TR_CALLS, MAX_XDS_FOR_TR_CALLS);
+        return USBERR_ALLOC;
+   } /* Endif */
+
+   temp_scratch_ptr = usb_dev_ptr->XD_SCRATCH_STRUCT_BASE;
+   usb_dev_ptr->XD_HEAD = NULL;
+   usb_dev_ptr->XD_TAIL = NULL;
+   usb_dev_ptr->XD_ENTRIES = 0;
+
+   /* Enqueue all the XDs */
+   for (i=0;i<MAX_XDS_FOR_TR_CALLS;i++)
+   {
+      xd_ptr->SCRATCH_PTR = temp_scratch_ptr;
+      xd_ptr->SCRATCH_PTR->FREE = _usb_device_free_XD;
+      xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+      _usb_device_free_XD((pointer)xd_ptr);
+      xd_ptr++;
+      temp_scratch_ptr++;
+   } /* Endfor */
+
+   usb_dev_ptr->TEMP_XD_PTR = (XD_STRUCT_PTR)USB_memalloc(sizeof(XD_STRUCT));
+   if(usb_dev_ptr->TEMP_XD_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for TEMP_XD_STRUCT failed\n",
+                        sizeof(XD_STRUCT));
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->TEMP_XD_PTR, sizeof(XD_STRUCT));
+
+   /* Allocate 2 bytes for USB_STATUS to be sent over USB, so Cache line aligned */
+   usb_dev_ptr->STATUS_UNAIGNED_PTR = (uint_8*)USB_memalloc(sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+   if(usb_dev_ptr->STATUS_UNAIGNED_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB_STATUS failed\n",
+                        sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->STATUS_UNAIGNED_PTR, sizeof(uint_16) + PSP_CACHE_LINE_SIZE);
+   usb_dev_ptr->STATUS_PTR = (uint_16*)USB_CACHE_ALIGN((uint_32)usb_dev_ptr->STATUS_UNAIGNED_PTR);
+
+   /* Allocate 53 bytes for USB Test packet to be sent over USB, so Cache line aligned */
+   usb_dev_ptr->TEST_PKT_UNAIGNED_PTR = (uint_8*)USB_memalloc(USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+   if(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR == NULL)
+   {
+        USB_printf("_usb_device_init, malloc of %d bytes for USB Test packet failed\n",
+                        USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+        _usb_device_cleanup(usb_dev_ptr);
+        return USBERR_ALLOC;
+   }
+   USB_memzero(usb_dev_ptr->TEST_PKT_UNAIGNED_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH + PSP_CACHE_LINE_SIZE);
+   usb_dev_ptr->TEST_PKT_PTR = (uint_8*)USB_CACHE_ALIGN((uint_32)usb_dev_ptr->TEST_PKT_UNAIGNED_PTR);
+
+   /* Initialize the USB controller chip */
+   error = _usb_dci_vusb20_init(devnum, usb_dev_ptr);
+   if (error)
+   {
+        _usb_device_cleanup(usb_dev_ptr);
+        USB_printf("_usb_device_init, init failed");
+        return USBERR_INIT_FAILED;
+   } /* Endif */
+
+   USB_printf("device_init: pDev=0x%x, pXD(%d)=0x%x, pSCRATCH(%d)=0x%x, pTempXD=0x%x\n",
+                (unsigned)usb_dev_ptr, MAX_XDS_FOR_TR_CALLS, (unsigned)usb_dev_ptr->XD_BASE,
+                MAX_XDS_FOR_TR_CALLS, (unsigned)usb_dev_ptr->XD_SCRATCH_STRUCT_BASE,
+                (unsigned)usb_dev_ptr->TEMP_XD_PTR);
+
+   *handle = usb_dev_ptr;
+   return USB_OK;
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_shutdown
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Shutdown an initialized USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_shutdown(_usb_device_handle handle)
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+    SERVICE_STRUCT_PTR           service_ptr;
+    int                          ep;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CTRL, "shutdown\n");
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    for(ep=0; ep<(usb_dev_ptr->MAX_ENDPOINTS); ep++)
+    {
+        /* Cancel all transfers on all endpoints */
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_RECV) !=
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(handle, ep, ARC_USB_RECV);
+        }
+        while(_usb_device_get_transfer_status(handle, ep, ARC_USB_SEND) !=
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            _usb_device_cancel_transfer(handle, ep, ARC_USB_SEND);
+        }
+    }
+    _usb_dci_vusb20_shutdown(usb_dev_ptr);
+
+    /* Free all the Callback function structure memory */
+    for( service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR; service_ptr;
+         service_ptr = service_ptr->NEXT)
+    {
+        USB_printf("_usb_device_shutdown: free service_ptr = 0x%x\n",
+                            service_ptr);
+        USB_memfree(service_ptr);
+    }
+    usb_dev_ptr->SERVICE_HEAD_PTR = NULL;
+
+    _usb_device_cleanup(usb_dev_ptr);
+} /* EndBody */
+
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_device_register_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Registers a callback routine for a specified event or endpoint.
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_register_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle         handle,
+
+      /* [IN] type of event or endpoint number to service */
+      uint_8                     type,
+
+      /* [IN] Pointer to the service's callback function */
+      void(_CODE_PTR_ service)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8)
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   usb_dev_ptr;
+   SERVICE_STRUCT_PTR         service_ptr;
+   SERVICE_STRUCT_PTR _PTR_   search_ptr;
+   int                        lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+
+   /* Search for an existing entry for type */
+   for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
+      *search_ptr;
+      search_ptr = &(*search_ptr)->NEXT)
+   {
+      if ((*search_ptr)->TYPE == type)
+      {
+         /* Found an existing entry */
+         USB_unlock(lockKey);
+         USB_printf("_usb_device_register_service, service %d already opened\n");
+         return USBERR_OPEN_SERVICE;
+      } /* Endif */
+   } /* Endfor */
+
+   /* No existing entry found - create a new one */
+   service_ptr = (SERVICE_STRUCT_PTR)USB_memalloc(sizeof(SERVICE_STRUCT));
+   if (!service_ptr)
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_register_service, malloc for %d bytes failed\n",
+                    sizeof(SERVICE_STRUCT));
+      return USBERR_ALLOC;
+   } /* Endif */
+
+   service_ptr->TYPE = type;
+   service_ptr->SERVICE = service;
+   service_ptr->NEXT = NULL;
+   *search_ptr = service_ptr;
+
+   USB_unlock(lockKey);
+
+   return USB_OK;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_device_unregister_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Unregisters a callback routine for a specified event or endpoint.
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_unregister_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle         handle,
+
+      /* [IN] type of event or endpoint number to service */
+      uint_8                     type
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   usb_dev_ptr;
+   SERVICE_STRUCT_PTR         service_ptr;
+   SERVICE_STRUCT_PTR _PTR_   search_ptr;
+   int                        lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+
+   /* Search for an existing entry for type */
+   for (search_ptr = &usb_dev_ptr->SERVICE_HEAD_PTR;
+      *search_ptr;
+      search_ptr = &(*search_ptr)->NEXT)
+   {
+      if ((*search_ptr)->TYPE == type) {
+         /* Found an existing entry - delete it */
+         break;
+      } /* Endif */
+   } /* Endfor */
+
+   /* No existing entry found */
+   if (!*search_ptr)
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_unregister_service, no service found\n");
+      return USBERR_CLOSED_SERVICE;
+   } /* Endif */
+
+   service_ptr = *search_ptr;
+   *search_ptr = service_ptr->NEXT;
+
+   USB_memfree((pointer)service_ptr);
+
+   USB_unlock(lockKey);
+
+   return USB_OK;
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_device_call_service
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Calls the appropriate service for the specified type, if one is
+*     registered. Used internally only.
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_call_service
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+
+      /* [OUT] Type of service or endpoint */
+      uint_8               type,
+
+      /* [OUT] Is it a Setup transfer? */
+      boolean              setup,
+
+      /* [OUT] Direction of transmission; is it a Transmit? */
+      boolean              direction,
+
+      /* [OUT] Pointer to the data */
+      uint_8_ptr           buffer_ptr,
+
+      /* [OUT] Number of bytes in transmission */
+      uint_32              length,
+
+      /* [OUT] Any errors */
+      uint_8               errors
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   SERVICE_STRUCT _PTR_         service_ptr;
+   int                          lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   /* Needs mutual exclusion */
+   lockKey = USB_lock();
+
+   /* Search for an existing entry for type */
+   for (service_ptr = usb_dev_ptr->SERVICE_HEAD_PTR;
+        service_ptr;
+        service_ptr = service_ptr->NEXT)
+   {
+      if (service_ptr->TYPE == type)
+      {
+#ifdef CONFIG_MV_SP_I_FTCH_DB_INV
+        if( (direction == ARC_USB_RECV) && (buffer_ptr != NULL) && (length > 0) )
+            USB_dcache_inv( buffer_ptr, length);
+#endif /* CONFIG_MV_SP_I_FTCH_DB_INV */
+
+         service_ptr->SERVICE(handle, type, setup, direction, buffer_ptr, length, errors);
+         USB_unlock(lockKey);
+
+         return USB_OK;
+      } /* Endif */
+
+   } /* Endfor */
+
+   USB_unlock(lockKey);
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CTRL, "_usb_device_call_service, service %d is closed\n", type);
+
+   return USBERR_CLOSED_SERVICE;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_init_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Initializes the endpoint and the data structures associated with the
+*  endpoint
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_init_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] MAX Packet size for this endpoint */
+      uint_16                    max_pkt_size,
+
+      /* [IN] Direction */
+      uint_8                     direction,
+
+      /* [IN] Type of Endpoint */
+      uint_8                     type,
+
+      /* [IN] After all data is transfered, should we terminate the transfer
+      ** with a zero length packet if the last packet size == MAX_PACKET_SIZE?
+      */
+      uint_8                     flag
+   )
+{ /* Body */
+
+    int                         lockKey;
+    uint_8                      error = 0;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    /* Initialize the transfer descriptor */
+    usb_dev_ptr->TEMP_XD_PTR->EP_NUM = ep_num;
+    usb_dev_ptr->TEMP_XD_PTR->BDIRECTION = direction;
+    usb_dev_ptr->TEMP_XD_PTR->WMAXPACKETSIZE = max_pkt_size;
+    usb_dev_ptr->TEMP_XD_PTR->EP_TYPE = type;
+    usb_dev_ptr->TEMP_XD_PTR->DONT_ZERO_TERMINATE = flag;
+    usb_dev_ptr->TEMP_XD_PTR->MAX_PKTS_PER_UFRAME =
+                    ((flag & ARC_USB_MAX_PKTS_PER_UFRAME) >> 1);
+
+    lockKey = USB_lock();
+    error = _usb_dci_vusb20_init_endpoint(handle, usb_dev_ptr->TEMP_XD_PTR);
+    USB_unlock(lockKey);
+
+   return error;
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_deinit_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*  Disables the endpoint and the data structures associated with the
+*  endpoint
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_deinit_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                    ep_num,
+
+      /* [IN] Direction */
+      uint_8                    direction
+   )
+{ /* Body */
+   int                          lockKey;
+   uint_8                       error = 0;
+   lockKey = USB_lock();
+
+   error = _usb_dci_vusb20_deinit_endpoint(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   return error;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_get_transfer_status
+*  Returned Value : Status of the transfer
+*  Comments       :
+*        returns the status of the transaction on the specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_get_transfer_status
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   uint_8                       status;
+   int                          lockKey;
+
+   lockKey = USB_lock();
+
+   status = _usb_dci_vusb20_get_transfer_status(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   /* Return the status of the last queued transfer */
+   return (status);
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_read_setup_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Reads the setup data from the hardware
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_read_setup_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] buffer for receiving Setup packet */
+      uint_8_ptr                  buff_ptr
+   )
+{ /* Body */
+   int                           lockKey;
+
+   lockKey = USB_lock();
+
+   _usb_dci_vusb20_get_setup_data(handle, ep_num, buff_ptr);
+
+   USB_unlock(lockKey);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_cancel_transfer
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        returns the status of the transaction on the specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_cancel_transfer
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   uint_8                        error = USB_OK;
+   int                           lockKey;
+
+   lockKey = USB_lock();
+
+   /* Cancel transfer on the specified endpoint for the specified
+   ** direction
+   */
+   error = _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   return error;
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_stop
+*  Returned Value : None
+*  Comments       :
+*        Stop USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_stop(_usb_device_handle handle)
+{
+    int         lockKey;
+
+    lockKey = USB_lock();
+    _usb_dci_vusb20_stop(handle);
+    USB_unlock(lockKey);
+}
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_start
+*  Returned Value : None
+*  Comments       :
+*        Start USB device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_start(_usb_device_handle handle)
+{
+    int         lockKey;
+
+    lockKey = USB_lock();
+    _usb_dci_vusb20_start(handle);
+    USB_unlock(lockKey);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevPrv.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevPrv.h
new file mode 100644
index 0000000..c37787c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevPrv.h
@@ -0,0 +1,267 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mvUsbDevPrv_h__
+#define __mvUsbDevPrv_h__
+
+#include "common/mvUsbCore.h"
+
+
+#define USB_TEST_MODE_TEST_PACKET_LENGTH   (53)
+
+
+#define USB_XD_QADD(head,tail,XD)      \
+   if ((head) == NULL) {         \
+      (head) = (XD);            \
+   } else {                      \
+      (tail)->SCRATCH_PTR->PRIVATE = (XD);   \
+   } /* Endif */                 \
+   (tail) = (XD);               \
+   (XD)->SCRATCH_PTR->PRIVATE = NULL
+
+#define USB_XD_QGET(head,tail,XD)      \
+   (XD) = (head);               \
+   if (head) {                   \
+      (head) = (XD_STRUCT_PTR)((head)->SCRATCH_PTR->PRIVATE);  \
+      if ((head) == NULL) {      \
+         (tail) = NULL;          \
+      } /* Endif */              \
+   } /* Endif */
+
+#define EHCI_DTD_QADD(head,tail,dTD)      \
+   if ((head) == NULL) {         \
+      (head) = (dTD);            \
+   } else {                      \
+      (tail)->SCRATCH_PTR->PRIVATE = (void *) (dTD);   \
+   } /* Endif */                 \
+   (tail) = (dTD);               \
+   (dTD)->SCRATCH_PTR->PRIVATE = NULL
+
+#define EHCI_DTD_QGET(head,tail,dTD)      \
+   (dTD) = (head);               \
+   if (head) {                   \
+      (head) = (head)->SCRATCH_PTR->PRIVATE;  \
+      if ((head) == NULL) {      \
+         (tail) = NULL;          \
+      } /* Endif */              \
+   } /* Endif */
+
+/***************************************
+**
+** Data structures
+**
+*/
+
+typedef struct
+{
+    uint_32     usb_isr_count;
+    uint_32     usb_reset_count;
+    uint_32     usb_send_count;
+    uint_32     usb_recv_count;
+    uint_32     usb_setup_count;
+    uint_32     free_XD_count;
+    uint_32     free_dTD_count;
+    uint_32     usb_cancel_count;
+    uint_32     usb_add_count;
+    uint_32     usb_add_not_empty_count;
+    uint_32     usb_empty_isr_count;
+    uint_32     usb_empty_complete_count;
+    uint_32     usb_read_setup_count;
+    uint_32     usb_complete_isr_count;
+    uint_32     usb_complete_count;
+    uint_32     usb_complete_max_count;
+    uint_32     usb_port_change_count;
+    uint_32     usb_suspend_count;
+    uint_32     usb_complete_ep_count[ARC_USB_MAX_ENDPOINTS*2];
+
+} USB_STATS;
+
+
+
+/* Callback function storage structure */
+typedef struct service_struct
+{
+    uint_8   TYPE;
+    void     (_CODE_PTR_ SERVICE)(pointer, uint_8, boolean, uint_8, uint_8_ptr, uint_32, uint_8);
+    struct service_struct _PTR_   NEXT;
+
+} SERVICE_STRUCT, _PTR_ SERVICE_STRUCT_PTR;
+
+typedef struct xd_struct
+{
+    uint_8         EP_NUM;           /* Endpoint number */
+    uint_8         BDIRECTION;       /* Direction : Send/Receive */
+    uint_8         EP_TYPE;          /* Type of the endpoint: Ctrl, Isoch, Bulk, Int */
+    uint_8         BSTATUS;          /* Current transfer status */
+    uint_8_ptr     WSTARTADDRESS;    /* Address of first byte */
+    uint_32        WTOTALLENGTH;     /* Number of bytes to send/recv */
+    uint_32        WSOFAR;           /* Number of bytes recv'd so far */
+    uint_16        WMAXPACKETSIZE;   /* Max Packet size */
+    boolean        DONT_ZERO_TERMINATE;
+    uint_8         MAX_PKTS_PER_UFRAME;
+    SCRATCH_STRUCT *SCRATCH_PTR;
+} XD_STRUCT, _PTR_ XD_STRUCT_PTR;
+
+/* The USB Device State Structure */
+typedef struct
+{
+    boolean                          BUS_RESETTING;       /* Device is
+                                                         ** being reset */
+    volatile VUSB20_REG_STRUCT_PTR   CAP_REGS_PTR;        /* Capabilities registers */
+
+    volatile VUSB20_REG_STRUCT_PTR   DEV_PTR;            /* Device Controller
+                                                         ** Register base
+                                                         ** address */
+
+    SERVICE_STRUCT_PTR               SERVICE_HEAD_PTR;   /* Head struct
+                                                         ** address of
+                                                         ** registered services
+                                                         */
+    XD_STRUCT_PTR                    TEMP_XD_PTR;         /* Temp xd for ep init */
+    XD_STRUCT_PTR                    XD_BASE;
+    XD_STRUCT_PTR                    XD_HEAD;             /* Head Transaction
+                                                         ** descriptors
+                                                         */
+    XD_STRUCT_PTR                    XD_TAIL;             /* Tail Transaction
+                                                         ** descriptors
+                                                         */
+    uint_32                          XD_ENTRIES;
+    uint_8*                          EP_QUEUE_HEAD_BASE;
+    uint_32                          EP_QUEUE_HEAD_PHYS;
+    uint_32                          EP_QUEUE_HEAD_SIZE;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  EP_QUEUE_HEAD_PTR;   /* Endpoint Queue head */
+
+    uint_8*                          DTD_BASE_PTR;        /* Device transfer descriptor pool address */
+    uint_32                          DTD_BASE_PHYS;
+    uint_32                          DTD_SIZE;
+    VUSB20_EP_TR_STRUCT_PTR          DTD_ALIGNED_BASE_PTR;/* Aligned transfer descriptor pool address */
+
+    VUSB20_EP_TR_STRUCT_PTR          DTD_HEAD;
+    VUSB20_EP_TR_STRUCT_PTR          DTD_TAIL;
+    VUSB20_EP_TR_STRUCT_PTR          EP_DTD_HEADS[ARC_USB_MAX_ENDPOINTS * 2];
+    VUSB20_EP_TR_STRUCT_PTR          EP_DTD_TAILS[ARC_USB_MAX_ENDPOINTS * 2];
+    SCRATCH_STRUCT_PTR               XD_SCRATCH_STRUCT_BASE;
+
+
+    SCRATCH_STRUCT_PTR               SCRATCH_STRUCT_BASE;
+
+    uint_16                          USB_STATE;
+    uint_16                          USB_DEVICE_STATE;
+    uint_16                          USB_SOF_COUNT;
+    uint_16                          DTD_ENTRIES;
+    uint_16                          ERRORS;
+    uint_16                          ERROR_STATE;
+    uint_16                          USB_DEV_STATE_B4_SUSPEND;
+    uint_8                           DEV_NUM;             /* USB device number
+                                                         ** on the board
+                                                         */
+    uint_8                           SPEED;               /* Low Speed,
+                                                         ** High Speed,
+                                                         ** Full Speed
+                                                         */
+    uint_8                           MAX_ENDPOINTS;       /* Max endpoints
+                                                         ** supported by this
+                                                         ** device
+                                                         */
+
+    uint_8                           USB_CURR_CONFIG;
+    uint_8                           DEVICE_ADDRESS;
+    uint_8                           FORCE_FS;
+    USB_STATS                        STATS;
+
+    uint_8*                          STATUS_UNAIGNED_PTR;
+    uint_16*                         STATUS_PTR;
+
+    uint_8*                          TEST_PKT_UNAIGNED_PTR;
+    uint_8*                          TEST_PKT_PTR;
+
+} USB_DEV_STATE_STRUCT, _PTR_ USB_DEV_STATE_STRUCT_PTR;
+
+/* ONLY For data bases allocated by the driver (when PHYS and VIRT bases are known) */
+#define USB_EP_QH_VIRT_TO_PHYS(handle, virtAddr)                                                    \
+    (((virtAddr) == NULL) ? 0 : ((handle)->EP_QUEUE_HEAD_PHYS +                                \
+                          ((uint_32)(virtAddr) - (uint_32)(handle)->EP_QUEUE_HEAD_BASE)))
+
+#define USB_DTD_VIRT_TO_PHYS(handle, virtAddr)                                                    \
+    (((virtAddr) == NULL) ? 0 : ((handle)->DTD_BASE_PHYS +                                \
+                          ((uint_32)(virtAddr) - (uint_32)(handle)->DTD_BASE_PTR)))
+
+#define USB_DTD_PHYS_TO_VIRT(handle, physAddr)                                                    \
+    (((physAddr) == 0) ? NULL : ((handle)->DTD_BASE_PTR +                             \
+                                ((physAddr) - (handle)->DTD_BASE_PHYS)))
+
+
+/***************************************
+**
+** Prototypes
+**
+*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern uint_8  _usb_device_call_service(void* handle, uint_8, boolean,
+                                 boolean, uint_8_ptr, uint_32, uint_8);
+
+extern uint_8   _usb_dci_vusb20_init(uint_8, _usb_device_handle);
+extern void     _usb_device_free_XD(pointer);
+extern void     _usb_dci_vusb20_free_dTD(pointer);
+extern uint_8   _usb_dci_vusb20_add_dTD(_usb_device_handle, XD_STRUCT_PTR);
+extern uint_8   _usb_dci_vusb20_cancel_transfer(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_get_transfer_status(_usb_device_handle, uint_8, uint_8);
+extern XD_STRUCT_PTR _usb_dci_vusb20_get_transfer_details(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_process_tr_complete(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_reset(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_tr_complete(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_suspend(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_SOF(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_port_change(_usb_device_handle);
+extern void     _usb_dci_vusb20_process_error(_usb_device_handle);
+extern void     _usb_dci_vusb20_shutdown(_usb_device_handle);
+extern void     _usb_dci_vusb20_set_speed_full(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_suspend_phy(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_hnp_shutdown(void);
+extern void     _usb_dci_vusb20_set_address(_usb_device_handle, uint_8);
+extern void     _usb_dci_vusb20_get_setup_data(_usb_device_handle, uint_8, uint_8_ptr);
+extern void     _usb_dci_vusb20_assert_resume(_usb_device_handle);
+extern uint_8   _usb_dci_vusb20_init_endpoint(_usb_device_handle, XD_STRUCT_PTR);
+extern void     _usb_dci_vusb20_stall_endpoint(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_unstall_endpoint(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_is_endpoint_stalled(_usb_device_handle, uint_8, uint_8);
+extern uint_8   _usb_dci_vusb20_deinit_endpoint(_usb_device_handle, uint_8, uint_8);
+extern void     _usb_dci_vusb20_chip_initialize(_usb_device_handle);
+extern void     _usb_dci_vusb20_stop(_usb_device_handle handle);
+extern void     _usb_dci_vusb20_start(_usb_device_handle handle);
+
+#if defined(USB_UNDERRUN_WA)
+
+extern uint_8*  usbSramBase;
+extern int      usbSramSize;
+
+void    _usb_reset_send_queue(void);
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir,
+                        uint_8_ptr buffer, uint_32 length, uint_8 error);
+#endif /* USB_UNDERRUN_WA */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevRecv.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevRecv.c
new file mode 100644
index 0000000..b17a8ff
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevRecv.c
@@ -0,0 +1,101 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_recv_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Receives data on a specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_recv_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] buffer to receive data */
+      uint_8_ptr                 buff_ptr,
+
+      /* [IN] length of the transfer */
+      uint_32                    size
+   )
+{ /* Body */
+    int                              lockKey;
+    uint_8                           error = USB_OK;
+    XD_STRUCT_PTR                    xd_ptr;
+    USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RX, "recv_data: ep=%d, buf_ptr=0x%x, size=%d\n",
+                                       ep_num, (unsigned)buff_ptr, (int)size);
+
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_recv_count++));
+
+    if(buff_ptr != NULL)
+        USB_dcache_inv((pointer)buff_ptr,size);
+
+    lockKey = USB_lock();
+
+    if (!usb_dev_ptr->XD_ENTRIES)
+    {
+        USB_unlock(lockKey);
+        USB_printf("_usb_device_recv_data, transfer in progress\n");
+        return ARC_USB_STATUS_TRANSFER_IN_PROGRESS;
+    } /* Endif */
+
+    /* Get a transfer descriptor for the specified endpoint
+    ** and direction
+    */
+    USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+
+    usb_dev_ptr->XD_ENTRIES--;
+
+    /* Initialize the new transfer descriptor */
+    xd_ptr->EP_NUM = ep_num;
+    xd_ptr->BDIRECTION = ARC_USB_RECV;
+    xd_ptr->WTOTALLENGTH = size;
+    xd_ptr->WSOFAR = 0;
+    xd_ptr->WSTARTADDRESS = buff_ptr;
+
+    xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+    error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+
+    USB_unlock(lockKey);
+
+    if (error)
+    {
+        USB_printf("_usb_device_recv_data, receive failed\n");
+        return USBERR_RX_FAILED;
+    } /* Endif */
+
+    return error;
+
+} /* EndBody */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevSend.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevSend.c
new file mode 100644
index 0000000..4b56c27
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevSend.c
@@ -0,0 +1,375 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+#if defined(USB_UNDERRUN_WA)
+
+typedef struct
+{
+    uint_8*     buff_ptr[MAX_XDS_FOR_TR_CALLS];
+    uint_32     size[MAX_XDS_FOR_TR_CALLS];
+    uint_8      ep_num[MAX_XDS_FOR_TR_CALLS];
+    int         head;
+    int         tail;
+    int         tail_dma;
+    int         num;
+    int         num_dma;
+
+} USB_SEND_QUEUE;
+
+uint_8*         usbSramBase;
+int             usbSramSize;
+int		        usbSramPartSize;
+USB_SEND_QUEUE  usbSendQueue;
+
+uint_32         usbSentSize = 0;
+uint_32         usbDmaSize = 0;
+
+#define S_FREE	    0
+#define S_BUSY	    1
+
+uint_32		    dma_index = 0;
+uint_32		    sent_index = 0;
+uint_32		    sram_parts[USB_SRAM_MAX_PARTS];
+
+
+void    _usb_reset_send_queue(void)
+{
+    int     i;
+
+    usbSendQueue.num = 0;
+	usbSendQueue.num_dma = 0;
+    usbSendQueue.head = 0;
+    usbSendQueue.tail = 0;
+	usbSendQueue.tail_dma = 0;
+    for(i=0; i<MAX_XDS_FOR_TR_CALLS; i++)
+    {
+        usbSendQueue.size[i] = 0;
+        usbSendQueue.buff_ptr[i] = NULL;
+        usbSendQueue.ep_num[i] = 0;
+    }
+	usbSramPartSize = usbSramSize/global_wa_sram_parts;
+
+    for(i=0; i<global_wa_sram_parts; i++)
+    {
+		sram_parts[i] = S_FREE;
+    }
+}
+
+uint_8 _usb_prepare_to_send(void*   handle)
+{
+    XD_STRUCT_PTR               xd_ptr;
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+    uint_8*                     buff_ptr;
+    uint_8*			            tmp_buff;
+    uint_32                     size;
+    int                         num_dma, tail_dma, i;
+    uint_8			            error = 0;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    tail_dma = usbSendQueue.tail_dma;
+    num_dma = usbSendQueue.num_dma;
+    buff_ptr = usbSendQueue.buff_ptr[tail_dma];
+    size = usbSendQueue.size[tail_dma];
+
+    if(num_dma == 0)
+	    return 0;
+
+/*
+    USB_printf("_usb_prepare_to_send: num=%d, tail=%d, sentSize=%d, size=%d, buff=%p\n",
+                num_dma, tail_dma, usbSentSize, size, buff_ptr);
+*/
+    for(i=0; i<global_wa_sram_parts; i++)
+    {
+	    if(sram_parts[dma_index] != S_FREE)
+	        break;
+
+	    if(usbDmaSize >= usbSendQueue.size[tail_dma])
+	    {
+	        /* Remove from the usbSendQueues */
+	        num_dma--;
+            tail_dma++;
+            if(tail_dma == MAX_XDS_FOR_TR_CALLS)
+                tail_dma = 0;
+
+            usbSendQueue.tail_dma = tail_dma;
+            usbSendQueue.num_dma = num_dma;
+            usbDmaSize = 0;
+
+            if(num_dma == 0)
+                break;
+        }
+
+	    buff_ptr = usbSendQueue.buff_ptr[tail_dma] + usbDmaSize;
+	    size = MIN(usbSramPartSize, (usbSendQueue.size[tail_dma] - usbDmaSize) );
+
+	    usbDmaSize += size;
+
+	    if(size > global_wa_threshold)
+	    {
+	        tmp_buff = buff_ptr;
+	        buff_ptr = (uint_8*)((int)usbSramBase + (dma_index * usbSramPartSize));
+	        USB_idma_copy(buff_ptr, tmp_buff, size);
+
+	        sram_parts[dma_index] = S_BUSY;
+            dma_index++;
+            if(dma_index == global_wa_sram_parts)
+                dma_index = 0;
+	    }
+
+
+	    /* Get a transfer descriptor */
+	    USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+
+	    usb_dev_ptr->XD_ENTRIES--;
+	    USB_dcache_flush((pointer)buff_ptr, size);
+
+	    /* Initialize the new transfer descriptor */
+	    xd_ptr->EP_NUM = usbSendQueue.ep_num[tail_dma];
+	    xd_ptr->BDIRECTION = ARC_USB_SEND;
+	    xd_ptr->WTOTALLENGTH = size;
+	    xd_ptr->WSOFAR = 0;
+	    xd_ptr->WSTARTADDRESS = buff_ptr;
+	    xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+	    error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+
+	    if(error)
+	        break;
+    }
+
+    return error;
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : usbSendComplete
+*  Returned Value : None
+*  Comments       :
+*        Callback for send transfer complete event.
+*
+*END*-----------------------------------------------------------------*/
+void    usbSendComplete(void* handle, uint_8 type, boolean setup, uint_8 dir,
+                        uint_8_ptr buffer, uint_32 length, uint_8 error)
+{
+    /* Check if this complete is one from the sendQueue */
+    if( (usbSendQueue.ep_num[usbSendQueue.tail] == type) &&
+        (usbSendQueue.num > 0) )
+    {
+        USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+        uint_8*                     buff_ptr;
+        uint_32                     size;
+        int                         num, tail;
+
+        usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+        tail = usbSendQueue.tail;
+        num = usbSendQueue.num;
+        buff_ptr = usbSendQueue.buff_ptr[tail];
+        size = usbSendQueue.size[tail];
+/*
+        USB_printf("usbSendComplete: num=%d, tail=%d, usbSentSize=%d, type=%d, length=%d (%d), buff=%p (%p)\n",
+                num, tail, usbSentSize, type, length, usbSendQueue.size[tail],
+                buffer, usbSendQueue.buff_ptr[tail]);
+*/
+        usbSentSize += length;
+
+	    /* if the buffer was on the SRAM */
+	    if( ((unsigned)buffer >= (unsigned)usbSramBase) &&
+	    ((unsigned)buffer < ((unsigned)usbSramBase + (usbSramPartSize * global_wa_sram_parts))) )
+	    {
+	        sram_parts[sent_index] = S_FREE;
+            sent_index++;
+            if(sent_index == global_wa_sram_parts)
+                sent_index = 0;
+	    }
+
+        if(usbSentSize >= usbSendQueue.size[tail])
+        {
+            /* Remove from the usbSendQueues */
+            num--;
+            tail++;
+            if(tail == MAX_XDS_FOR_TR_CALLS)
+                tail = 0;
+
+            usbSendQueue.tail = tail;
+            usbSendQueue.num = num;
+            usbSentSize = 0;
+
+            /* Call complete callback */
+            _usb_device_call_service(handle, type, setup, dir,
+                         buff_ptr, size, error);
+
+            if(num == 0)
+                return;
+        }
+
+	    error = _usb_prepare_to_send(handle);
+        if (error)
+        {
+            USB_printf("usbSendComplete, add_dTD failed\n");
+        }
+
+    }
+    else
+    {
+        /* Call complete callback */
+        _usb_device_call_service(handle, type, setup, dir,
+                        buffer, length, error);
+    }
+}
+#endif /* USB_UNDERRUN_WA */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_send_data
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Sends data on a specified endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_send_data
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] buffer to send */
+      uint_8_ptr                 buff_ptr,
+
+      /* [IN] length of the transfer */
+      uint_32                    size
+   )
+{ /* Body */
+   int 	                        lockKey;
+   uint_8                       error = 0;
+   XD_STRUCT_PTR                xd_ptr;
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   boolean                      toSend = TRUE;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TX,
+       "send_data: handle=%p, ep=%d, pBuf=0x%x, size=%d, EP_QH=%p\n",
+       handle, ep_num, (unsigned)buff_ptr, (int)size, usb_dev_ptr->EP_QUEUE_HEAD_PTR);
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_send_count++));
+
+   lockKey = USB_lock();
+
+   if (!usb_dev_ptr->XD_ENTRIES)
+   {
+      USB_unlock(lockKey);
+      USB_printf("_usb_device_send_data, transfer in progress\n");
+      return ARC_USB_STATUS_TRANSFER_IN_PROGRESS;
+   } /* Endif */
+
+#if defined(USB_UNDERRUN_WA)
+    {
+        int 			                head;
+	VUSB20_EP_QUEUE_HEAD_STRUCT* 	ep_queue_head_ptr;
+
+		ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+								                  2*ep_num + ARC_USB_SEND;
+
+        if( ((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold)
+        {
+            /* Only Endpoints with maxPktSize more than 128 bytes need special processing */
+            if( (size > global_wa_threshold) ||
+                (usbSendQueue.num != 0) )
+            {
+/*
+                USB_printf("_usb_device_send_data: ep_num=%d, maxPktSize=%d, size=%d\n",
+                        ep_num, (ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF, size);
+*/
+                /* Check if usbSendQueue is not Full */
+                if(usbSendQueue.num == MAX_XDS_FOR_TR_CALLS)
+                {
+                    USB_printf("ep=%d: usbSendQueue is FULL\n", ep_num);
+                    USB_unlock(lockKey);
+                    return USBERR_TX_FAILED;
+                }
+
+                /* Add to usbSendQueu */
+                head = usbSendQueue.head;
+
+                usbSendQueue.num++;
+		        usbSendQueue.num_dma++;
+                usbSendQueue.size[head] = size;
+                usbSendQueue.buff_ptr[head] = buff_ptr;
+                usbSendQueue.ep_num[head] = ep_num;
+
+                head++;
+                if(head == MAX_XDS_FOR_TR_CALLS)
+                    head = 0;
+
+                usbSendQueue.head = head;
+
+                /* Process first usbSendQueue element if possible */
+                if(usbSendQueue.num == 1)
+                {
+		            error = _usb_prepare_to_send(handle);
+		        }
+		        toSend = FALSE;
+            }
+        }
+    }
+#endif /* USB_UNDERRUN_WA */
+
+    if(toSend == TRUE)
+    {
+        /* Get a transfer descriptor */
+        USB_XD_QGET(usb_dev_ptr->XD_HEAD, usb_dev_ptr->XD_TAIL, xd_ptr);
+
+        usb_dev_ptr->XD_ENTRIES--;
+
+        if(buff_ptr != NULL)
+            USB_dcache_flush((pointer)buff_ptr, size);
+
+        /* Initialize the new transfer descriptor */
+        xd_ptr->EP_NUM = ep_num;
+        xd_ptr->BDIRECTION = ARC_USB_SEND;
+        xd_ptr->WTOTALLENGTH = size;
+        xd_ptr->WSOFAR = 0;
+        xd_ptr->WSTARTADDRESS = buff_ptr;
+        xd_ptr->BSTATUS = ARC_USB_STATUS_TRANSFER_ACCEPTED;
+
+        error = _usb_dci_vusb20_add_dTD(handle, xd_ptr);
+    }
+    USB_unlock(lockKey);
+
+    if (error)
+    {
+        USB_printf("_usb_device_send_data, transfer failed\n");
+        return USBERR_TX_FAILED;
+    } /* Endif */
+    return error;
+
+} /* EndBody */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevUtl.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevUtl.c
new file mode 100644
index 0000000..b7d564f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbDevUtl.c
@@ -0,0 +1,634 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_unstall_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Unstalls the endpoint in specified direction
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_unstall_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR   	usb_dev_ptr;
+   int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   _usb_dci_vusb20_unstall_endpoint(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_device_get_status
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Provides API to access the USB internal state.
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_get_status
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] What to get the status of */
+      uint_8               component,
+
+      /* [OUT] The requested status */
+      uint_16_ptr          status
+   )
+{ /* Body */
+	USB_DEV_STATE_STRUCT_PTR 	usb_dev_ptr;
+	int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   switch (component)
+   {
+      case ARC_USB_STATUS_DEVICE_STATE:
+         *status = usb_dev_ptr->USB_STATE;
+         break;
+
+      case ARC_USB_STATUS_DEVICE:
+         *status = usb_dev_ptr->USB_DEVICE_STATE;
+         break;
+
+      case ARC_USB_STATUS_INTERFACE:
+          *status = 0;
+         break;
+
+      case ARC_USB_STATUS_ADDRESS:
+         *status = usb_dev_ptr->DEVICE_ADDRESS;
+         break;
+
+      case ARC_USB_STATUS_CURRENT_CONFIG:
+         *status = usb_dev_ptr->USB_CURR_CONFIG;
+         break;
+
+      case ARC_USB_STATUS_SOF_COUNT:
+         *status = usb_dev_ptr->USB_SOF_COUNT;
+         break;
+
+      default:
+            USB_unlock(lockKey);
+            USB_printf("_usb_device_get_status, bad status\n");
+            return USBERR_BAD_STATUS;
+
+   } /* Endswitch */
+   USB_unlock(lockKey);
+
+   return USB_OK;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_device_set_status
+* Returned Value : USB_OK or error code
+* Comments       :
+*     Provides API to set internal state
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_device_set_status
+   (
+      /* [IN] Handle to the usb device */
+      _usb_device_handle   handle,
+
+      /* [IN] What to set the status of */
+      uint_8               component,
+
+      /* [IN] What to set the status to */
+      uint_16              setting
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR usb_dev_ptr;
+   int 					    lockKey;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STATUS,
+            "set_status: component=0x%x, value=0x%x\n", component, setting);
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   lockKey = USB_lock();
+
+   switch (component)
+   {
+      case ARC_USB_STATUS_DEVICE_STATE:
+         usb_dev_ptr->USB_STATE = setting;
+         break;
+
+      case ARC_USB_STATUS_DEVICE:
+         usb_dev_ptr->USB_DEVICE_STATE = setting;
+         break;
+
+      case ARC_USB_STATUS_INTERFACE:
+         break;
+
+      case ARC_USB_STATUS_CURRENT_CONFIG:
+         usb_dev_ptr->USB_CURR_CONFIG = setting;
+         break;
+
+      case ARC_USB_STATUS_SOF_COUNT:
+         usb_dev_ptr->USB_SOF_COUNT = setting;
+         break;
+
+      case ARC_USB_FORCE_FULL_SPEED:
+         _usb_dci_vusb20_set_speed_full((pointer)usb_dev_ptr, setting);
+         break;
+
+      case ARC_USB_PHY_LOW_POWER_SUSPEND:
+         _usb_dci_vusb20_suspend_phy((pointer)usb_dev_ptr, setting);
+         break;
+
+      case ARC_USB_STATUS_ADDRESS:
+         usb_dev_ptr->DEVICE_ADDRESS = setting;
+
+         _usb_dci_vusb20_set_address((pointer)usb_dev_ptr, setting);
+         break;
+
+      case ARC_USB_STATUS_TEST_MODE:
+         _usb_dci_vusb20_set_test_mode(handle, setting);
+         break;
+
+      default:
+            USB_unlock(lockKey);
+            USB_printf("_usb_device_set_status, bad status\n");
+            return USBERR_BAD_STATUS;
+
+   } /* Endswitch */
+
+   USB_unlock(lockKey);
+
+   return USB_OK;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_stall_endpoint
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Stalls the endpoint.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_stall_endpoint
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   _usb_dci_vusb20_stall_endpoint(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_is_endpoint_stalled
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*     Stalls the endpoint.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_device_is_endpoint_stalled
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   uint_8                       val;
+   int							lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   lockKey = USB_lock();
+
+   val = _usb_dci_vusb20_is_endpoint_stalled(handle, ep_num, direction);
+
+   USB_unlock(lockKey);
+
+   return val;
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_device_process_resume
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Process Resume event
+*
+*END*-----------------------------------------------------------------*/
+void _usb_device_assert_resume
+   (
+      /* [IN] the USB_USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR      usb_dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   _usb_dci_vusb20_assert_resume(handle);
+
+} /* EndBody */
+
+
+/***************************/
+/* ARC USB Debug functions */
+/***************************/
+void _usb_status(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+
+    USB_printf("\n\tUSB Status\n\n");
+
+    USB_printf("DEV_NUM=%d, DEV_ADDR=%d, CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
+                pUsbDev->DEV_NUM,
+                pUsbDev->DEVICE_ADDRESS,
+                (unsigned)pUsbDev->CAP_REGS_PTR,
+                (unsigned)pUsbDev->DEV_PTR,
+                pUsbDev->MAX_ENDPOINTS);
+
+    USB_printf("BUS_RESET=%s, STATE=0x%02x, DEV_STATE=0x%02x, SPEED=%d, ERRORS=%d, ERROR_STATE=0x%04x\n",
+                pUsbDev->BUS_RESETTING ? "Yes" : "No",
+                pUsbDev->USB_STATE,
+                pUsbDev->USB_DEVICE_STATE,
+                pUsbDev->SPEED,
+                pUsbDev->ERRORS,
+                pUsbDev->ERROR_STATE);
+
+    USB_printf("EP_QUEUE_HEAD: SIZE=%d, BASE=%p (0x%08x), ALIGNED=%p, SERVICE_HEAD=%p\n",
+                pUsbDev->EP_QUEUE_HEAD_SIZE,
+                pUsbDev->EP_QUEUE_HEAD_BASE,
+                pUsbDev->EP_QUEUE_HEAD_PHYS,
+                pUsbDev->EP_QUEUE_HEAD_PTR,
+                pUsbDev->SERVICE_HEAD_PTR);
+
+    USB_printf("XD: BASE=%p, HEAD=%p, TAIL=%p, ENTRIES=%d, SCRATCH=%p, TEMP=%p\n",
+                pUsbDev->XD_BASE,
+                pUsbDev->XD_HEAD,
+                pUsbDev->XD_TAIL,
+                pUsbDev->XD_ENTRIES,
+                pUsbDev->XD_SCRATCH_STRUCT_BASE,
+                pUsbDev->TEMP_XD_PTR);
+
+    USB_printf("DTD: SIZE=%d, BASE=%p (0x%08x), ALIGNED=%p, HEAD=0x%08x, TAIL=0x%08x, ENTRIES=%d, SCRATCH=%p\n",
+                pUsbDev->DTD_SIZE,
+                pUsbDev->DTD_BASE_PTR,
+                pUsbDev->DTD_BASE_PHYS,
+                pUsbDev->DTD_ALIGNED_BASE_PTR,
+                pUsbDev->DTD_HEAD,
+                pUsbDev->DTD_TAIL,
+                pUsbDev->DTD_ENTRIES,
+                pUsbDev->SCRATCH_STRUCT_BASE);
+}
+
+void _usb_stats(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    USB_STATS*              pUsbStats = &pUsbDev->STATS;
+    int                     i;
+
+    USB_printf("\n\tUSB Statistics\n\n");
+
+    USB_printf("isr=%u, empty_isr=%u, reset=%u, setup=%u, read_setup=%u\n",
+                    pUsbStats->usb_isr_count, pUsbStats->usb_empty_isr_count,
+                    pUsbStats->usb_reset_count, pUsbStats->usb_setup_count,
+                    pUsbStats->usb_read_setup_count);
+
+    USB_printf("recv=%u, send=%u, add=%u (%u), cancel=%u\n",
+                pUsbStats->usb_recv_count, pUsbStats->usb_send_count,
+                pUsbStats->usb_add_count, pUsbStats->usb_add_not_empty_count,
+                pUsbStats->usb_cancel_count);
+
+    USB_printf("free_XD=%u, free_dTD=%u\n",
+            pUsbStats->free_XD_count, pUsbStats->free_dTD_count);
+
+    USB_printf("complete_isr=%u, complete=%u, empty_complete=%u, max_complete=%u\n",
+                pUsbStats->usb_complete_isr_count, pUsbStats->usb_complete_count,
+                pUsbStats->usb_empty_complete_count, pUsbStats->usb_complete_max_count);
+
+    USB_printf("port_change=%u, suspend=%u\n",
+                pUsbStats->usb_port_change_count, pUsbStats->usb_suspend_count);
+    for(i=0; i<(pUsbDev->MAX_ENDPOINTS); i++)
+    {
+        if( (pUsbStats->usb_complete_ep_count[i*2] == 0) &&
+            (pUsbStats->usb_complete_ep_count[i*2+1] == 0) )
+            continue;
+
+        USB_printf("EP #%d: RECV (OUT) = %3u, \tSEND (IN) = %u\n", i,
+                    pUsbStats->usb_complete_ep_count[i*2],
+                    pUsbStats->usb_complete_ep_count[i*2+1]);
+    }
+    USB_printf("\n");
+}
+
+void _usb_clear_stats(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+
+    USB_memzero(&pUsbDev->STATS, sizeof(pUsbDev->STATS));
+}
+
+void _usb_regs(void* usbHandle)
+{
+    USB_DEV_STATE_STRUCT*   pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    VUSB20_REG_STRUCT*      cap_regs, *dev_regs;
+    int                     dev_num;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+    USB_printf("\n\tUSB Capability Registers\n\n");
+
+    cap_regs = pUsbDev->CAP_REGS_PTR;
+    USB_printf("CAPLENGTH_HCIVER (0x%08x) = 0x%08x\n",
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER));
+
+    USB_printf("DCI_VERSION      (0x%08x) = 0x%08x\n",
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCI_VERSION));
+
+    USB_printf("DCC_PARAMS       (0x%08x) = 0x%08x\n",
+        (unsigned)&cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS,
+        (unsigned)USB_32BIT_LE(cap_regs->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS));
+
+    dev_regs = pUsbDev->DEV_PTR;
+    dev_num = pUsbDev->DEV_NUM;
+    USB_printf("\n\tUSB Device Operational Registers\n\n");
+
+    USB_printf("USB_CMD          (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+
+    USB_printf("USB_STS          (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS));
+
+    USB_printf("USB_INTR         (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR));
+
+    USB_printf("USB_FRINDEX      (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX));
+
+    /* Skip CTRLDSSEGMENT register */
+    USB_printf("DEVICE_ADDR      (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR));
+
+    USB_printf("EP_LIST_ADDR     (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR));
+
+    /* Skip CONFIG_FLAG register */
+
+    /* Skip PORTSCX[0..15] registers*/
+    USB_printf("PORTSCX[0]       (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0],
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]));
+
+    /* Skip OTGSC register */
+
+    USB_printf("USB_MODE         (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_MODE));
+
+    USB_printf("ENDPT_SETUP_STAT (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT));
+
+    USB_printf("ENDPTPRIME       (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
+
+    USB_printf("ENDPTFLUSH       (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH));
+
+    USB_printf("ENDPTSTATUS      (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS));
+
+    USB_printf("ENDPTCOMPLETE    (0x%08x) = 0x%08x\n",
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE,
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE));
+}
+
+
+void _usb_ep_status(void* usbHandle, int ep_num, int direction)
+{
+    USB_DEV_STATE_STRUCT*               pUsbDev = (USB_DEV_STATE_STRUCT*)usbHandle;
+    int                                 i, ep_idx;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR     ep_queue_head_ptr;
+    VUSB20_EP_TR_STRUCT_PTR             dTD_ptr, head_dTD_ptr, tail_dTD_ptr, next_dTD_ptr;
+    XD_STRUCT_PTR                       xd_ptr, next_xd_ptr;
+    VUSB20_REG_STRUCT_PTR               dev_regs;
+
+    if(pUsbDev == NULL)
+    {
+        USB_printf("USB Device core is not initialized\n");
+        return;
+    }
+
+    USB_printf("\n\tUSB Endpoint #%d - %s status\n\n", ep_num,
+        (direction == ARC_USB_SEND) ? "SEND (IN)" : "RECV (OUT)" );
+
+    ep_idx = ep_num*2 + direction;
+    dev_regs = pUsbDev->DEV_PTR;
+
+    USB_printf("ENDPTCTRLX[%d]    (0x%08x) = 0x%08x\n", ep_num,
+        (unsigned)&dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num],
+        (unsigned)USB_32BIT_LE(dev_regs->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]));
+
+    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)pUsbDev->EP_QUEUE_HEAD_PTR + ep_idx;
+
+    head_dTD_ptr = pUsbDev->EP_DTD_HEADS[ep_idx];
+    tail_dTD_ptr = pUsbDev->EP_DTD_TAILS[ep_idx];
+
+    USB_printf("EP_QH=0x%08x: MAX_PKT=0x%x, SIZE_IOC_INT_STS=0x%x, CURR_DTD=0x%x, NEXT_DTD=0x%x\n",
+                (unsigned)ep_queue_head_ptr, (unsigned)USB_32BIT_LE(ep_queue_head_ptr->MAX_PKT_LENGTH),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR));
+
+    USB_printf("\tBUF_0=0x%08x, BUF_1=0x%08x, BUF_2=0x%08x, BUF_3=0x%08x, BUF_4=0x%08x\n",
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR0),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR1),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR2),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR3),
+                (unsigned)USB_32BIT_LE(ep_queue_head_ptr->BUFF_PTR4));
+
+    USB_printf("\tSETUP_BUFFER (%p): ", ep_queue_head_ptr->SETUP_BUFFER);
+    for(i=0; i<sizeof(ep_queue_head_ptr->SETUP_BUFFER); i++)
+        USB_printf("%02x", ep_queue_head_ptr->SETUP_BUFFER[i] & 0xFF);
+    USB_printf("\n");
+
+    USB_printf("\ndTD_HEAD=0x%08x, dTD_TAIL=0x%08x\n",
+                (unsigned)head_dTD_ptr, (unsigned)tail_dTD_ptr);
+
+    dTD_ptr = head_dTD_ptr;
+    i = 0;
+    while(dTD_ptr != NULL)
+    {
+        USB_printf("%d. dTD=0x%08x (0x%08x), SIZE_IOC_STS=0x%08x, BUF_0=0x%08x, NEXT=0x%08x\n",
+                    i, (unsigned)dTD_ptr, USB_DTD_VIRT_TO_PHYS(pUsbDev, dTD_ptr),
+                    (unsigned)USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS),
+                    (unsigned)USB_32BIT_LE(dTD_ptr->BUFF_PTR0),
+                    (unsigned)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR));
+
+        xd_ptr = dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+
+        next_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(pUsbDev,
+                           (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
+        if(next_dTD_ptr != NULL)
+            next_xd_ptr = next_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+        else
+            next_xd_ptr = NULL;
+
+        if(next_xd_ptr != xd_ptr)
+        {
+            USB_printf("\tXD=0x%08x, ADDR=0x%08x, SIZE=%u, STATUS=0x%02x\n",
+                (unsigned)xd_ptr, (unsigned)xd_ptr->WSTARTADDRESS,
+                (unsigned)xd_ptr->WTOTALLENGTH, xd_ptr->BSTATUS);
+        }
+        i++;
+        dTD_ptr = next_dTD_ptr;
+    }
+}
+
+
+/* DEBUG */
+uint_32 usbDebugFlags = ARC_DEBUG_FLAG_STATS
+                      | ARC_DEBUG_FLAG_INIT
+                      | ARC_DEBUG_FLAG_ERROR
+                      | ARC_DEBUG_FLAG_STALL
+                      | ARC_DEBUG_FLAG_RESET;
+                      /*| ARC_DEBUG_FLAG_TRANSFER;*/
+
+void    _usb_debug_set_flags(uint_32 flags)
+{
+    usbDebugFlags = (flags);
+}
+
+uint_32 _usb_debug_get_flags(void)
+{
+    return usbDebugFlags;
+}
+
+#if defined(MV_USB_TRACE_LOG)
+
+uint_16 DEBUG_TRACE_ARRAY_COUNTER = 0;
+char    DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE][MAX_STRING_SIZE];
+
+void  _usb_debug_init_trace_log(void)
+{
+    USB_memzero(DEBUG_TRACE_ARRAY, TRACE_ARRAY_SIZE*MAX_STRING_SIZE);
+	DEBUG_TRACE_ARRAY_COUNTER =0;
+}
+
+void    _usb_debug_print_trace_log(void)
+{
+    int     i;
+
+    USB_printf("USB Trace log: start=0x%x, end=0x%x, idx=%d, flags=0x%x\n\n",
+               &DEBUG_TRACE_ARRAY[0][0], &DEBUG_TRACE_ARRAY[TRACE_ARRAY_SIZE-1][0],
+               DEBUG_TRACE_ARRAY_COUNTER, usbDebugFlags);
+
+    for(i=DEBUG_TRACE_ARRAY_COUNTER; i<TRACE_ARRAY_SIZE; i++)
+    {
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')
+            continue;
+
+        USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
+    }
+    for(i=0; i<DEBUG_TRACE_ARRAY_COUNTER; i++)
+    {
+        if(DEBUG_TRACE_ARRAY[i][0] == '\0')
+            continue;
+        USB_printf("%3d. %s", i, DEBUG_TRACE_ARRAY[i]);
+    }
+    _usb_debug_init_trace_log();
+}
+#else
+void  _usb_debug_init_trace_log(void)
+{
+}
+
+void    _usb_debug_print_trace_log(void)
+{
+    USB_printf("USB trace log is not supported\n");
+}
+#endif /* MV_USB_TRACE_LOG */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevCncl.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevCncl.c
new file mode 100644
index 0000000..ffbc3c6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevCncl.c
@@ -0,0 +1,225 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_cancel_transfer
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Cancels a transfer
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_cancel_transfer
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR             usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR              dTD_ptr, check_dTD_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR      ep_queue_head_ptr;
+   XD_STRUCT_PTR                        xd_ptr;
+   uint_32                              temp, bit_pos;
+   volatile unsigned long               timeout, status_timeout;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   bit_pos = (1 << (16 * direction + ep_num));
+   temp = (2*ep_num + direction);
+
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+
+   if (dTD_ptr)
+   {
+      ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_cancel_count++));
+
+      check_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
+                            ((uint_32)USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK));
+
+      if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
+      {
+         /* Flushing will halt the pipe */
+         /* Write 1 to the Flush register */
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(bit_pos);
+
+         /* Wait until flushing completed */
+         timeout = 0x1000000;
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos)
+         {
+            /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
+            timeout--;
+            if(timeout == 0)
+            {
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, bit_pos=0x%x \n",
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH),
+                      (unsigned)bit_pos);
+                break;
+            }
+         } /* EndWhile */
+         status_timeout = 0x100000;
+         while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)
+         {
+            status_timeout--;
+            if(status_timeout == 0)
+            {
+                USB_printf("USB Cancel: - TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                      (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                      (unsigned)bit_pos);
+                break;
+            }
+
+            /* Write 1 to the Flush register */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(bit_pos);
+
+            /* Wait until flushing completed */
+            timeout = 0x1000000;
+            while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH) & bit_pos)
+            {
+               /* ENDPTFLUSH bit should be cleared to indicate this operation is complete */
+               timeout--;
+               if(timeout == 0)
+                {
+                    USB_printf("USB Cancel: - TIMEOUT for ENDPTFLUSH=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH),
+                            (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                            (unsigned)bit_pos);
+                    break;
+                }
+            } /* EndWhile */
+         } /* EndWhile */
+      } /* Endif */
+
+      /* Retire the current dTD */
+      dTD_ptr->SIZE_IOC_STS = 0;
+      dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSBHS_TD_NEXT_TERMINATE);
+
+      /* The transfer descriptor for this dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      dTD_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+                      "cncl_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, bit=0x%x\n",
+                       usb_dev_ptr->STATS.usb_cancel_count & 0xFFFF,
+                       USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                       ep_num, direction ? "in" : "out",
+                       xd_ptr->WSTARTADDRESS, xd_ptr->WTOTALLENGTH, xd_ptr,
+                       dTD_ptr, check_dTD_ptr, bit_pos);
+
+      /* Free the dTD */
+      _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+
+      /* Update the dTD head and tail for specific endpoint/direction */
+      if (!check_dTD_ptr)
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = NULL;
+         usb_dev_ptr->EP_DTD_TAILS[temp] = NULL;
+         if (xd_ptr)
+         {
+            xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+            /* Free the transfer descriptor */
+            _usb_device_free_XD((pointer)xd_ptr);
+         } /* Endif */
+         /* No other transfers on the queue */
+         ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
+         ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+      }
+      else
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = check_dTD_ptr;
+
+         if (xd_ptr)
+         {
+            if ((uint_32)check_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != (uint_32)xd_ptr)
+            {
+               xd_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+               /* Free the transfer descriptor */
+               _usb_device_free_XD((pointer)xd_ptr);
+            } /* Endif */
+         } /* Endif */
+
+         if (USB_32BIT_LE(check_dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
+         {
+            /* Start CR 1015 */
+            /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+
+            if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos))
+            {
+               timeout = 0x100000;
+               while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)
+               {
+                  /* Wait for the ENDPTPRIME to go to zero */
+                  timeout--;
+                  if(timeout == 0)
+                  {
+                      USB_printf("USB Cancel: - TIMEOUT for ENDPTPRIME=0x%x, bit_pos=0x%x\n",
+                                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                                (unsigned)bit_pos);
+                      break;
+                  }
+               } /* EndWhile */
+
+               if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)
+               {
+                  /* The endpoint was not not primed so no other transfers on
+                  ** the queue
+                  */
+                  goto done;
+               } /* Endif */
+            }
+            else
+            {
+               goto done;
+            } /* Endif */
+
+            /* No other transfers on the queue */
+            ep_queue_head_ptr->NEXT_DTD_PTR = (uint_32)USB_32BIT_LE((uint_32)check_dTD_ptr);
+            ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+
+            /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+         } /* Endif */
+      } /* Endif */
+   } /* Endif */
+
+done:
+
+   /* End CR 1015 */
+   return USB_OK;
+} /* EndBody */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevMain.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevMain.c
new file mode 100644
index 0000000..9b5479a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevMain.c
@@ -0,0 +1,1870 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_init
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device controller.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_init
+   (
+      /* [IN] the USB device controller to initialize */
+      uint_8                     devnum,
+
+      /* [OUT] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR    usb_dev_ptr;
+    uint_32                     temp;
+    uint_8*                     pBuf;
+    unsigned long               phyAddr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    usb_dev_ptr->CAP_REGS_PTR =
+       (VUSB20_REG_STRUCT_PTR)USB_get_cap_reg_addr(devnum);
+
+    /* Get the base address of the VUSB_HS registers */
+    usb_dev_ptr->DEV_PTR =
+      (VUSB20_REG_STRUCT_PTR)(((uint_32)usb_dev_ptr->CAP_REGS_PTR) +
+       (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.CAPLENGTH_HCIVER) &
+                                                                EHCI_CAP_LEN_MASK));
+
+    /* Get the maximum number of endpoints supported by this USB controller */
+    usb_dev_ptr->MAX_ENDPOINTS =
+      (USB_32BIT_LE(usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.DCC_PARAMS) &
+                                                VUSB20_DCC_MAX_ENDPTS_SUPPORTED);
+
+    USB_printf("USB init: CAP_REGS=0x%x, DEV_REGS=0x%x, MAX_EP=%d\n",
+                (unsigned)usb_dev_ptr->CAP_REGS_PTR, (unsigned)usb_dev_ptr->DEV_PTR,
+                usb_dev_ptr->MAX_ENDPOINTS);
+
+    temp = (usb_dev_ptr->MAX_ENDPOINTS * 2);
+
+    pBuf = (uint_8*)USB_uncached_memalloc(temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT),
+                                          2048, &phyAddr);
+    if (pBuf == NULL)
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
+                        temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
+        return USBERR_ALLOC;
+    }
+
+    /****************************************************************
+      Assign QH base
+    ****************************************************************/
+    usb_dev_ptr->EP_QUEUE_HEAD_BASE = pBuf;
+    usb_dev_ptr->EP_QUEUE_HEAD_PHYS = (uint_32)phyAddr;
+
+    /* Align the endpoint queue head to 2K boundary */
+    usb_dev_ptr->EP_QUEUE_HEAD_PTR = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)
+                USB_MEM2048_ALIGN((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    usb_dev_ptr->EP_QUEUE_HEAD_SIZE = temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT) +
+                                      ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR -
+                                       (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    /****************************************************************
+      Zero out the memory allocated
+    ****************************************************************/
+    USB_memzero( (void*)usb_dev_ptr->EP_QUEUE_HEAD_PTR,
+                 temp*sizeof(VUSB20_EP_QUEUE_HEAD_STRUCT));
+
+    USB_printf("USB EP_QH: Base=%p (0x%x), Aligned(%d)=%p, Size=%d\n",
+                usb_dev_ptr->EP_QUEUE_HEAD_BASE, usb_dev_ptr->EP_QUEUE_HEAD_PHYS,
+                2048, usb_dev_ptr->EP_QUEUE_HEAD_PTR, usb_dev_ptr->EP_QUEUE_HEAD_SIZE);
+
+    /****************************************************************
+      Assign DTD base
+    ****************************************************************/
+    pBuf = (uint_8*)USB_uncached_memalloc(MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT),
+                                          32, &phyAddr);
+    if (pBuf == NULL)
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes in Uncached area failed\n",
+                        MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
+        return USBERR_ALLOC;
+    }
+
+    usb_dev_ptr->DTD_BASE_PTR = pBuf;
+    usb_dev_ptr->DTD_BASE_PHYS = (uint_32)phyAddr;
+
+    /* Align the dTD base to 32 byte boundary */
+    usb_dev_ptr->DTD_ALIGNED_BASE_PTR = (VUSB20_EP_TR_STRUCT_PTR)
+                        USB_MEM32_ALIGN((uint_32)usb_dev_ptr->DTD_BASE_PTR);
+
+    usb_dev_ptr->DTD_SIZE = MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT) +
+                                ((uint_32)usb_dev_ptr->EP_QUEUE_HEAD_PTR -
+                                 (uint_32)usb_dev_ptr->EP_QUEUE_HEAD_BASE);
+
+    /****************************************************************
+      Zero out the memory allocated
+    ****************************************************************/
+    USB_memzero((void*)usb_dev_ptr->DTD_ALIGNED_BASE_PTR,
+                MAX_EP_TR_DESCRS*sizeof(VUSB20_EP_TR_STRUCT));
+
+    /****************************************************************
+      Assign SCRATCH Structure base
+    ****************************************************************/
+    /* Allocate memory for internal scratch structure */
+    pBuf = USB_memalloc(MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+    if (pBuf == NULL)
+    {
+        USB_printf("_usb_dci_vusb20_init, malloc of %d bytes failed\n",
+                        MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+        return USBERR_ALLOC;
+    }
+    usb_dev_ptr->SCRATCH_STRUCT_BASE = (SCRATCH_STRUCT_PTR)pBuf;
+    USB_memzero(usb_dev_ptr->SCRATCH_STRUCT_BASE,
+            MAX_EP_TR_DESCRS*sizeof(SCRATCH_STRUCT));
+
+    USB_printf("USB dTD(%d): Base=%p (0x%x), Aligned(%d)=%p, Size=%d, Scratch=%p\n",
+                MAX_EP_TR_DESCRS, usb_dev_ptr->DTD_BASE_PTR, usb_dev_ptr->DTD_BASE_PHYS,
+                32, usb_dev_ptr->DTD_ALIGNED_BASE_PTR, usb_dev_ptr->DTD_SIZE,
+                usb_dev_ptr->SCRATCH_STRUCT_BASE);
+
+#ifdef USB_UNDERRUN_WA
+    usbSramBase = (uint_8*)USB_get_sram_addr(&usbSramSize);
+    if (usbSramBase == NULL)
+    {
+        USB_printf("_usb_dci_vusb20_init, SRAM is not available\n");
+        return USBERR_ALLOC;
+    }
+    USB_memzero(usbSramBase, usbSramSize);
+    USB_printf("USB WA_Queue: base=%p, size=%d, parts=%d\n",
+                    usbSramBase, usbSramSize, global_wa_sram_parts);
+#endif /* USB_UNDERRUN_WA */
+
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+
+    /* Initialize the VUSB_HS controller */
+    _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
+
+    return USB_OK;
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_chip_initialize
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Initializes the USB device controller.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_chip_initialize
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR            dev_ptr;
+    VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  ep_queue_head_ptr;
+    VUSB20_EP_TR_STRUCT_PTR          dTD_ptr;
+    uint_32                          i, port_control;
+    SCRATCH_STRUCT_PTR               temp_scratch_ptr;
+    volatile unsigned long           delay;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "chip_initialize\n");
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    /* Stop the controller */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~(USB_32BIT_LE(EHCI_CMD_RUN_STOP));
+
+    /* Reset the controller to get default values */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
+
+    USB_printf("USB Init: Wait for RESET completed\n");
+
+    delay = 0x100000;
+    while (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &
+                                    (USB_32BIT_LE(EHCI_CMD_CTRL_RESET)))
+    {
+        /* Wait for the controller reset to complete */
+        delay--;
+        if(delay == 0)
+            break;
+    } /* EndWhile */
+
+    if(delay == 0)
+    {
+        USB_printf("USB Init: Wait for RESET completed TIMEOUT\n");
+    }
+    else
+    {
+        USB_printf("USB Init: RESET completed\n");
+    }
+    /* Call BSP callback to complete reset process */
+    USB_reset_complete(usb_dev_ptr->DEV_NUM);
+
+    /* Initialize the internal dTD head and tail to NULL */
+    usb_dev_ptr->DTD_HEAD = NULL;
+    usb_dev_ptr->DTD_TAIL = NULL;
+    usb_dev_ptr->DTD_ENTRIES = 0;
+    usb_dev_ptr->ERROR_STATE = 0;
+
+   /* Make sure the 16 MSBs of this register are 0s */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(0);
+
+   ep_queue_head_ptr = usb_dev_ptr->EP_QUEUE_HEAD_PTR;
+
+   /* Initialize all device queue heads */
+   for (i=0; i<(usb_dev_ptr->MAX_ENDPOINTS*2); i++)
+   {
+      /* Interrupt on Setup packet */
+      (ep_queue_head_ptr + i)->MAX_PKT_LENGTH = (USB_32BIT_LE(
+          ((uint_32)USB_MAX_CTRL_PAYLOAD << VUSB_EP_QUEUE_HEAD_MAX_PKT_LEN_POS) |
+            VUSB_EP_QUEUE_HEAD_IOS));
+
+      (ep_queue_head_ptr + i)->NEXT_DTD_PTR = (USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE));
+   } /* Endfor */
+
+   /* Configure the Endpoint List Address */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.EP_LIST_ADDR =
+                            USB_32BIT_LE(USB_EP_QH_VIRT_TO_PHYS(usb_dev_ptr, ep_queue_head_ptr));
+
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   if (usb_dev_ptr->CAP_REGS_PTR->REGISTERS.CAPABILITY_REGISTERS.HCS_PARAMS &
+                                        USB_32BIT_LE(VUSB20_HCS_PARAMS_PORT_POWER_CONTROL_FLAG))
+   {
+      port_control &= (~EHCI_PORTSCX_W1C_BITS | ~EHCI_PORTSCX_PORT_POWER);
+   } /* Endif */
+
+   if(usb_dev_ptr->FORCE_FS == TRUE)
+   {
+       port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
+   }
+   else
+   {
+       port_control &= (~EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT);
+   }
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = USB_32BIT_LE(port_control);
+
+   dTD_ptr = usb_dev_ptr->DTD_ALIGNED_BASE_PTR;
+
+   temp_scratch_ptr = usb_dev_ptr->SCRATCH_STRUCT_BASE;
+
+   /* Enqueue all the dTDs */
+   for (i=0; i<MAX_EP_TR_DESCRS; i++)
+   {
+      dTD_ptr->SCRATCH_PTR = temp_scratch_ptr;
+      dTD_ptr->SCRATCH_PTR->FREE = _usb_dci_vusb20_free_dTD;
+      /* Set the dTD to be invalid */
+      dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSBHS_TD_NEXT_TERMINATE);
+      /* Set the Reserved fields to 0 */
+      dTD_ptr->SIZE_IOC_STS &= ~(USB_32BIT_LE(VUSBHS_TD_RESERVED_FIELDS));
+      dTD_ptr->SCRATCH_PTR->PRIVATE = (pointer)usb_dev_ptr;
+      _usb_dci_vusb20_free_dTD((pointer)dTD_ptr);
+      dTD_ptr++;
+      temp_scratch_ptr++;
+   } /* Endfor */
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_free_dTD
+*  Returned Value : void
+*  Comments       :
+*        Enqueues a dTD onto the free DTD ring.
+*
+*END*-----------------------------------------------------------------*/
+
+void _usb_dci_vusb20_free_dTD
+   (
+      /* [IN] the dTD to enqueue */
+      pointer  dTD_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   int                          lockKey;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)(((VUSB20_EP_TR_STRUCT_PTR)dTD_ptr)->SCRATCH_PTR->PRIVATE);
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "free_dTD: dTD_ptr=0x%x\n", (unsigned)dTD_ptr);
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.free_dTD_count++));
+
+
+   /*
+   ** This function can be called from any context, and it needs mutual
+   ** exclusion with itself.
+   */
+   lockKey = USB_lock();
+
+   /*
+   ** Add the dTD to the free dTD queue (linked via PRIVATE) and
+   ** increment the tail to the next descriptor
+   */
+   EHCI_DTD_QADD(usb_dev_ptr->DTD_HEAD, usb_dev_ptr->DTD_TAIL, (VUSB20_EP_TR_STRUCT_PTR)dTD_ptr);
+   usb_dev_ptr->DTD_ENTRIES++;
+
+   USB_unlock(lockKey);
+
+} /* Endbody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_add_dTD
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Adds a device transfer desriptor(s) to the queue.
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_add_dTD
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] The transfer descriptor address */
+      XD_STRUCT_PTR              xd_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR         usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR            dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR          dTD_ptr, temp_dTD_ptr, first_dTD_ptr = NULL;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR  ep_queue_head_ptr;
+   uint_32                          curr_pkt_len, remaining_len;
+   uint_32                          curr_offset, temp, bit_pos;
+   volatile unsigned long           timeout;
+
+   /*********************************************************************
+   For a optimal implementation, we need to detect the fact that
+   we are adding DTD to an empty list. If list is empty, we can
+   actually skip several programming steps esp. those for ensuring
+   that there is no race condition.The following boolean will be useful
+   in skipping some code here.
+   *********************************************************************/
+   boolean           list_empty = FALSE;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   remaining_len = xd_ptr->WTOTALLENGTH;
+
+   curr_offset = 0;
+   temp = (2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION);
+   bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
+
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+   /*********************************************************************
+   This loops iterates through the length of the transfer and divides
+   the data in to DTDs each handling the a max of 0x4000 bytes of data.
+   The first DTD in the list is stored in a pointer called first_dTD_ptr.
+   This pointer is later linked in to QH for processing by the hardware.
+   *********************************************************************/
+
+    do
+    {
+        /* Check if we need to split the transfer into multiple dTDs */
+        if (remaining_len > VUSB_EP_MAX_LENGTH_TRANSFER)
+        {
+            curr_pkt_len = VUSB_EP_MAX_LENGTH_TRANSFER;
+        }
+        else
+        {
+            curr_pkt_len = remaining_len;
+        } /* Endif */
+
+        /* Get a dTD from the queue */
+        EHCI_DTD_QGET(usb_dev_ptr->DTD_HEAD, usb_dev_ptr->DTD_TAIL, dTD_ptr);
+
+        if (!dTD_ptr)
+        {
+            USB_printf("Error: Can't get dTD\n");
+            return USBERR_TR_FAILED;
+        } /* Endif */
+
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_add_count++));
+
+        remaining_len -= curr_pkt_len;
+
+        usb_dev_ptr->DTD_ENTRIES--;
+
+        if (curr_offset == 0)
+        {
+            first_dTD_ptr = dTD_ptr;
+        } /* Endif */
+
+        /* Zero the dTD. Leave the last 4 bytes as that is the scratch pointer */
+        USB_memzero((void *) dTD_ptr,(sizeof(VUSB20_EP_TR_STRUCT) - 4));
+
+        /* Initialize the dTD */
+        dTD_ptr->SCRATCH_PTR->PRIVATE = handle;
+
+        /* Set the Terminate bit */
+        dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_NEXT_TERMINATE);
+
+        /*************************************************************
+        FIX ME: For hig-speed and high-bandwidth ISO IN endpoints,
+        we must initialize the multiplied field so that Host can issues
+        multiple IN transactions on the endpoint. See the DTD data
+        structure for MultiIO field.
+
+        S Garg 11/06/2003
+        *************************************************************/
+
+        /* Fill in the transfer size */
+        if (!remaining_len)
+        {
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len <<
+                    VUSBHS_TD_LENGTH_BIT_POS) | (VUSBHS_TD_IOC) | (VUSBHS_TD_STATUS_ACTIVE));
+        }
+        else
+        {
+            dTD_ptr->SIZE_IOC_STS = USB_32BIT_LE((curr_pkt_len << VUSBHS_TD_LENGTH_BIT_POS)
+                                                   | VUSBHS_TD_STATUS_ACTIVE);
+        } /* Endif */
+
+        /* Set the reserved field to 0 */
+        dTD_ptr->SIZE_IOC_STS &= ~USB_32BIT_LE(VUSBHS_TD_RESERVED_FIELDS);
+
+        /* 4K apart buffer page pointers */
+        if(xd_ptr->WSTARTADDRESS != NULL)
+        {
+            uint_32 physAddr = USB_virt_to_phys((uint_8*)xd_ptr->WSTARTADDRESS + curr_offset);
+
+            dTD_ptr->BUFF_PTR0 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR1 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR2 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR3 = USB_32BIT_LE(physAddr);
+
+            physAddr += 4096;
+            dTD_ptr->BUFF_PTR4 = USB_32BIT_LE(physAddr);
+        }
+        else
+        {
+            dTD_ptr->BUFF_PTR0 = dTD_ptr->BUFF_PTR1 = dTD_ptr->BUFF_PTR2 = 0;
+            dTD_ptr->BUFF_PTR3 = dTD_ptr->BUFF_PTR4 = 0;
+        }
+        curr_offset += curr_pkt_len;
+
+      /* Maintain the first and last device transfer descriptor per
+      ** endpoint and direction
+      */
+      if (!usb_dev_ptr->EP_DTD_HEADS[temp])
+      {
+         usb_dev_ptr->EP_DTD_HEADS[temp] = dTD_ptr;
+         /***********************************************
+         If list does not have a head, it means that list
+         is empty. An empty condition is detected.
+         ***********************************************/
+         list_empty = TRUE;
+      } /* Endif */
+
+      /* Check if the transfer is to be queued at the end or beginning */
+      temp_dTD_ptr = usb_dev_ptr->EP_DTD_TAILS[temp];
+
+      /* Remember which XD to use for this dTD */
+      dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD = (pointer)xd_ptr;
+
+      /* New tail */
+      usb_dev_ptr->EP_DTD_TAILS[temp] = dTD_ptr;
+      if (temp_dTD_ptr)
+      {
+         /* Should not do |=. The Terminate bit should be zero */
+         temp_dTD_ptr->NEXT_TR_ELEM_PTR = USB_32BIT_LE(USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, dTD_ptr));
+      } /* Endif */
+   } while (remaining_len); /* EndWhile */
+
+
+   /**************************************************************
+   In the loop above DTD has already been added to the list
+   However endpoint has not been primed yet. If list is not empty
+   we need safter ways to add DTD to the existing list.
+   Else we just skip to adding DTD to QH safely.
+   **************************************************************/
+
+    if(list_empty == FALSE)
+    {
+        volatile boolean    read_safe = FALSE;
+        uint_32             prime, temp_ep_stat=0;
+
+        /*********************************************************
+        Hardware v3.2+ require the use of semaphore to ensure that
+        QH is safely updated.
+        *********************************************************/
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_add_not_empty_count++));
+
+        /*********************************************************
+        Check the prime bit. If set goto done
+        *********************************************************/
+        prime = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME);
+/*
+        USB_printf("%03d: Add not empty: bit_pos=%x, prime=0x%x, status=0x%x\n",
+                    usb_dev_ptr->STATS.usb_add_not_empty_count, prime, bit_pos,
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                    USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) );
+*/
+        if(prime & bit_pos)
+        {
+            timeout = 0x1000;
+            while( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME
+                    & USB_32BIT_LE(bit_pos) )
+            {
+               /* Wait for the ENDPTPRIME to go to zero */
+                timeout--;
+                if(timeout <= 0)
+                {
+                    USB_printf(
+                        "timeout: CTRL=%x, PRIME=%x, STAT=%x, INTR=%x, ADDR=%x, PORTSC=%x, dTD=%p, temp_dTD=%p\n",
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR),
+                        USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                        first_dTD_ptr, temp_dTD_ptr);
+
+                    _usb_ep_status(handle, xd_ptr->EP_NUM, xd_ptr->BDIRECTION);
+
+                    return USBERR_TR_FAILED;
+                }
+            } /* EndWhile */
+
+            /*ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,*/
+            if(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS & USB_32BIT_LE(bit_pos))
+            {
+                goto done;
+            }
+        }
+
+        read_safe = FALSE;
+        timeout = 1000000;
+        while(read_safe == FALSE)
+        {
+            timeout--;
+            if(timeout <= 0)
+            {
+                USB_printf("%s: Timeout for ATDTW_TRIPWIRE reg = 0x%x\n", __FUNCTION__,
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+                return USBERR_TR_FAILED;
+            }
+
+           /*********************************************************
+           start with setting the semaphores
+           *********************************************************/
+           dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |=
+                                          USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET);
+
+           /*********************************************************
+           Read the endpoint status
+           *********************************************************/
+           temp_ep_stat = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS)
+                                        & bit_pos;
+
+           /*********************************************************
+           Reread the ATDTW semaphore bit to check if it is cleared.
+           When hardware see a hazard, it will clear the bit or
+           else we remain set to 1 and we can proceed with priming
+           of endpoint if not already primed.
+           *********************************************************/
+           if( dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &
+                                          USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_SET))
+           {
+               read_safe = TRUE;
+           }
+
+        }/*end while loop */
+
+        /*********************************************************
+        Clear the semaphore
+        *********************************************************/
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &=
+                                       USB_32BIT_LE(EHCI_CMD_ATDTW_TRIPWIRE_CLEAR);
+
+        /*********************************************************
+         * If endpoint is not active, we activate it now.
+         *********************************************************/
+         if(!temp_ep_stat)
+         {
+            /* No other transfers on the queue */
+            ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(
+                        USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, first_dTD_ptr));
+            ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+
+            /* Prime the Endpoint */
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+         }
+    }
+    else
+    {
+         /* No other transfers on the queue */
+         ep_queue_head_ptr->NEXT_DTD_PTR = USB_32BIT_LE(
+                            USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, first_dTD_ptr));
+         ep_queue_head_ptr->SIZE_IOC_INT_STS = 0;
+
+         /* Prime the Endpoint */
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+         /* delay */
+         timeout = 0x100;
+         while(timeout > 0)
+             timeout--;
+
+         dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME = USB_32BIT_LE(bit_pos);
+    }
+
+done:
+   if(first_dTD_ptr == NULL)
+       USB_printf("ERROR !!!! first_dTD_ptr=NULL\n");
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+               " add_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p, empty=%d\n",
+               usb_dev_ptr->STATS.usb_add_count & 0xFFFF,
+               USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+               xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "in" : "out",
+               xd_ptr->WSTARTADDRESS, (int)xd_ptr->WTOTALLENGTH,
+               xd_ptr, (unsigned)first_dTD_ptr,
+               usb_dev_ptr->EP_DTD_HEADS[temp], list_empty);
+
+
+   return USB_OK;
+   /* End CR 1015 */
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_tr_complete
+*  Returned Value : None
+*  Comments       :
+*        Services transaction complete interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_tr_complete
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   volatile VUSB20_REG_STRUCT_PTR               dev_ptr;
+   volatile VUSB20_EP_TR_STRUCT_PTR             dTD_ptr;
+   VUSB20_EP_TR_STRUCT_PTR                      temp_dTD_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
+   uint_32                                      temp, i, ep_num = 0, direction = 0, bit_pos;
+   uint_32                                      remaining_length = 0;
+   uint_32                                      actual_transfer_length = 0;
+   uint_32                                      counter, errors = 0;
+   XD_STRUCT_PTR                                xd_ptr;
+   XD_STRUCT_PTR                                temp_xd_ptr = NULL;
+   uint_8_ptr                                   buff_start_address = NULL;
+   boolean                                      endpoint_detected = FALSE;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_isr_count++));
+
+   /* We use separate loops for ENDPTSETUPSTAT and ENDPTCOMPLETE because the
+   ** setup packets are to be read ASAP
+   */
+
+   /* Process all Setup packet received interrupts */
+   bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
+
+   if (bit_pos)
+   {
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "setup_isr: bit_pos=0x%x\n", (unsigned)bit_pos);
+      for(i=0; i<USB_MAX_CONTROL_ENDPOINTS; i++)
+      {
+         if (bit_pos & (1 << i))
+         {
+            ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_setup_count++));
+            _usb_device_call_service(handle, i, TRUE, 0, 0, 8, 0);
+         } /* Endif */
+      } /* Endfor */
+   } /* Endif */
+
+   /* Don't clear the endpoint setup status register here. It is cleared as a
+   ** setup packet is read out of the buffer
+   */
+
+   /* Process non-setup transaction complete interrupts */
+   bit_pos = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
+
+   /* Clear the bits in the register */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(bit_pos);
+
+   if (bit_pos)
+   {
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_count++));
+
+        /* Get the endpoint number and the direction of transfer */
+        counter = 0;
+        for (i=0; i<(ARC_USB_MAX_ENDPOINTS*2); i++)
+        {
+            endpoint_detected = FALSE;
+            if ((i < ARC_USB_MAX_ENDPOINTS) && (bit_pos & (1 << i)))
+            {
+                ep_num = i;
+                direction = ARC_USB_RECV;
+                endpoint_detected = TRUE;
+            }
+            else
+            {
+                if( (i >= ARC_USB_MAX_ENDPOINTS) &&
+                    (bit_pos & (1 << (i+16-ARC_USB_MAX_ENDPOINTS))))
+                {
+                    ep_num = (i - ARC_USB_MAX_ENDPOINTS);
+                    direction = ARC_USB_SEND;
+                    endpoint_detected = TRUE;
+                }
+            }
+
+            if(endpoint_detected)
+            {
+                temp = (2*ep_num + direction);
+
+                /* Get the first dTD */
+                dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+
+                ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+                /* Process all the dTDs for respective transfers */
+                while (dTD_ptr)
+                {
+                    if (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_STATUS_ACTIVE)
+                    {
+                        /* No more dTDs to process. Next one is owned by VUSB */
+                        if(counter == 0)
+                        {
+                            ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "tr_complete - break: ep=%d %s, bit_pos=0x%x\n",
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV", (unsigned)bit_pos);
+
+                            ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_empty_complete_count++));
+                        }
+                        break;
+                    } /* Endif */
+
+                    /* Get the correct internal transfer descriptor */
+                    xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+                    if (xd_ptr)
+                    {
+                        buff_start_address = xd_ptr->WSTARTADDRESS;
+                        actual_transfer_length = xd_ptr->WTOTALLENGTH;
+                        temp_xd_ptr = xd_ptr;
+                    } /* Endif */
+
+                    /* Get the address of the next dTD */
+                    temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
+                                (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
+
+                    /* Read the errors */
+                    errors = (USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSBHS_TD_ERROR_MASK);
+                    if (!errors)
+                    {
+                        /* No errors */
+                        /* Get the length of transfer from the current dTD */
+                        remaining_length += ((USB_32BIT_LE(dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+                        actual_transfer_length -= remaining_length;
+                    }
+                    else
+                    {
+                        if (errors & VUSBHS_TD_STATUS_HALTED)
+                        {
+                            /* Clear the errors and Halt condition */
+                            ep_queue_head_ptr->SIZE_IOC_INT_STS &= USB_32BIT_LE(~errors);
+                        } /* Endif */
+
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR,
+                            "complete_tr ERROR: ep=%d %s: STS=0x%x, dTD=%p, dTD_next=%p, xd=%p, qh->sts=0x%x\n",
+                                    (unsigned)ep_num, direction ? "SEND" : "RECV",
+                                    (unsigned)dTD_ptr->SIZE_IOC_STS, dTD_ptr, temp_dTD_ptr,
+                                    xd_ptr, ep_queue_head_ptr->SIZE_IOC_INT_STS);
+                    } /* Endif */
+
+                    /* Retire the processed dTD */
+                    counter++;
+                    _usb_dci_vusb20_cancel_transfer(handle, ep_num, direction);
+                    if( (temp_dTD_ptr == NULL) ||
+                        (temp_dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD != temp_xd_ptr) )
+                    {
+                        /* Transfer complete. Call the register service function for the endpoint */
+                        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_complete_ep_count[temp]++));
+
+#if defined(USB_UNDERRUN_WA)
+                        if( (direction == ARC_USB_SEND) &&
+                            (((ep_queue_head_ptr->MAX_PKT_LENGTH >> 16) & 0x7FF) > global_wa_threshold) )
+                            usbSendComplete(handle, ep_num, FALSE, direction,
+                                   buff_start_address, actual_transfer_length, errors);
+                        else
+#endif /* USB_UNDERRUN_WA */
+                            _usb_device_call_service(handle, ep_num, FALSE, direction,
+                                   buff_start_address, actual_transfer_length, errors);
+                        remaining_length = 0;
+
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER,
+                            "comp_%d: fri=0x%x, ep=%d%s, buf=%p, size=%d, xd=%p, dTD=%p %p %p, COMP=0x%x\n",
+                            usb_dev_ptr->STATS.usb_complete_count & 0xFFFF,
+                            USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                            (unsigned)ep_num, direction ? "in" : "out",
+                            buff_start_address, actual_transfer_length,
+                            temp_xd_ptr, dTD_ptr, temp_dTD_ptr, usb_dev_ptr->EP_DTD_HEADS[temp], (unsigned)bit_pos);
+
+                    } /* Endif */
+                    else
+                    {
+                        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRANSFER, "tr_complete not completed: ep=%d %s\n",
+                                (unsigned)ep_num, direction ? "SEND" : "RECV");
+                    }
+                    if( (temp_dTD_ptr == NULL) && (usb_dev_ptr->EP_DTD_HEADS[temp] != NULL) )
+                    {
+/*
+                        USB_printf("tr_complete: ep=%d, temp_dTD=%p, dTD_ptr=%p (%p), DTD_HEADS=%p, remain=%d\n",
+                                    temp, temp_dTD_ptr, dTD_ptr,
+                                    USB_DTD_PHYS_TO_VIRT(usb_dev_ptr, (uint_32)(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) ),
+                                    usb_dev_ptr->EP_DTD_HEADS[temp], remaining_length);
+*/
+                        dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[temp];
+                    }
+                    else
+                    {
+                        dTD_ptr = temp_dTD_ptr;
+                    }
+                    errors = 0;
+                } /* Endwhile */
+            } /* Endif */
+        } /* Endfor */
+        ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS,
+               ( {if(usb_dev_ptr->STATS.usb_complete_max_count < counter)
+                            usb_dev_ptr->STATS.usb_complete_max_count = counter;}));
+   } /* Endif */
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_isr
+*  Returned Value : None
+*  Comments       :
+*        Services all the VUSB_HS interrupt sources
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_isr
+   (
+      _usb_device_handle handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      status;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_isr_count++));
+
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   status = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS);
+
+   status &= USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR);
+
+   if(status == 0)
+   {
+       ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_empty_isr_count++));
+       return;
+   } /* Endif */
+/*
+    USB_printf("USB_ISR: FRINDEX=0x%x, status=0x%x, PORTSC=0x%x, EP_SETUP=0x%x, EP_COMPLETE=0x%x\n",
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                    status,
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
+*/
+   /* Clear all the interrupts occured */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_STS = USB_32BIT_LE(status);
+
+   if (status & EHCI_STS_ERR)
+   {
+        usb_dev_ptr->ERROR_STATE = (status & 0xFFFF);
+
+      _usb_dci_vusb20_process_error((pointer)usb_dev_ptr);
+        /* do tr_complete if no STS_INT set */
+        if( (status & EHCI_STS_INT) == 0)
+            _usb_dci_vusb20_process_tr_complete((pointer)usb_dev_ptr);
+
+        /*USB_printf("USB process error: status=0x%x\n", status);*/
+   } /* Endif */
+
+   if (status & EHCI_STS_RESET)
+   {
+       _usb_dci_vusb20_process_reset((pointer)usb_dev_ptr);
+   } /* Endif */
+
+   if (status & EHCI_STS_PORT_CHANGE)
+   {
+      _usb_dci_vusb20_process_port_change((pointer)usb_dev_ptr);
+   } /* Endif */
+
+   if (status & EHCI_STS_SOF)
+   {
+      _usb_dci_vusb20_process_SOF((pointer)usb_dev_ptr);
+   } /* Endif */
+
+   if (status & EHCI_STS_INT)
+   {
+      _usb_dci_vusb20_process_tr_complete((pointer)usb_dev_ptr);
+   } /* Endif */
+
+    if (status & EHCI_STS_SUSPEND)
+    {
+        _usb_dci_vusb20_process_suspend((pointer)usb_dev_ptr);
+    } /* Endif */
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_reset
+*  Returned Value : None
+*  Comments       :
+*        Services reset interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_reset
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      temp;
+   volatile unsigned long       timeout;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_reset\n");
+   ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_reset_count++));
+
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Inform the application so that it can cancel all previously queued transfers */
+   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_BUS_RESET, 0, 0, 0, 0, 0);
+
+#if defined(USB_UNDERRUN_WA)
+    _usb_reset_send_queue();
+#endif /* USB_UNDERRUN_WA */
+
+   /* The address bits are past bit 25-31. Set the address */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR &= ~USB_32BIT_LE(0xFE000000);
+
+   /* Clear all the setup token semaphores */
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT);
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(temp);
+
+   /* Clear all the endpoint complete status bits */
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE);
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE = USB_32BIT_LE(temp);
+
+    timeout = 0x10000;
+    while (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & 0xFFFFFFFF)
+    {
+        timeout--;
+        if(timeout <= 0)
+        {
+            USB_printf("%s: Timeout for ENDPTPRIME = 0x%x\n", __FUNCTION__,
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME));
+            break;
+        }
+
+      /* Wait until all ENDPTPRIME bits cleared */
+    } /* Endif */
+
+   /* Write 1s to the Flush register */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTFLUSH = USB_32BIT_LE(0xFFFFFFFF);
+
+    if( (usb_dev_ptr->ERROR_STATE == 0x0) &&
+        (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                                EHCI_PORTSCX_PORT_RESET) )
+    {
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET,
+                    "USB Bus Reset: fri=0x%x, dev_ptr=%p, STATE=%d, PORTSC=0x%x, CMD=0x%x, ENDPT[0]=0x%x\n",
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX),
+                    usb_dev_ptr, usb_dev_ptr->USB_STATE,
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD),
+                    USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]));
+
+        usb_dev_ptr->BUS_RESETTING = TRUE;
+        usb_dev_ptr->USB_STATE = ARC_USB_STATE_POWERED;
+    }
+    else
+    {
+        USB_printf("USB Chip reinit: PORTSC=0x%x\n",
+                USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]));
+
+        /* re-initialize */
+        _usb_dci_vusb20_chip_initialize((pointer)usb_dev_ptr);
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "process_reset, Chip reinit hw\n");
+    } /* Endif */
+
+    _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_BUS_RESET, 1, 0, 0, 0, 0);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_suspend
+*  Returned Value : None
+*  Comments       :
+*        Services suspend interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_suspend
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR        dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_suspend\n");
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_suspend_count++));
+
+    usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
+
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
+
+    /* Inform the upper layers */
+    _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SLEEP, 0, 0, 0, 0, 0);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_SOF
+*  Returned Value : None
+*  Comments       :
+*        Services SOF interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_SOF
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_SOF\n");
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Inform the upper layer */
+   _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SOF, 0, 0, 0,
+      USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_FRINDEX), 0);
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_port_change
+*  Returned Value : None
+*  Comments       :
+*        Services port change detect interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_port_change
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR                        dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ISR, "process_port_change\n");
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_port_change_count++));
+
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+/*
+    USB_printf("port_change: PORTSC=0x%x, DTD_ENTRIES=%d, XD_ENTRIES=%d\n",
+                USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]),
+                usb_dev_ptr->DTD_ENTRIES, usb_dev_ptr->XD_ENTRIES);
+*/
+    if (usb_dev_ptr->BUS_RESETTING)
+    {
+        /* Bus reset operation complete */
+        usb_dev_ptr->BUS_RESETTING = FALSE;
+    } /* Endif */
+
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                                EHCI_PORTSCX_PORT_RESET))
+    {
+        /* Get the speed */
+        if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                            EHCI_PORTSCX_PORT_HIGH_SPEED)
+        {
+            usb_dev_ptr->SPEED = ARC_USB_SPEED_HIGH;
+        }
+        else
+        {
+            usb_dev_ptr->SPEED = ARC_USB_SPEED_FULL;
+        } /* Endif */
+/*
+        USB_printf("USB %s speed device detected\n",
+                (usb_dev_ptr->SPEED == ARC_USB_SPEED_HIGH) ? "High" : "Full");
+*/
+        /* Inform the upper layers of the speed of operation */
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SPEED_DETECTION, 0, 0,
+                                0, usb_dev_ptr->SPEED, 0);
+    } /* Endif */
+
+    if (USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) &
+                                                EHCI_PORTSCX_PORT_SUSPEND)
+    {
+        usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND = usb_dev_ptr->USB_STATE;
+        usb_dev_ptr->USB_STATE = ARC_USB_STATE_SUSPEND;
+
+        /* Inform the upper layers */
+        USB_printf("USB suspend\n");
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_SUSPEND, 0, 0, 0, 0, 0);
+    } /* Endif */
+
+    if (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]) & EHCI_PORTSCX_PORT_SUSPEND)
+                    && (usb_dev_ptr->USB_STATE == ARC_USB_STATE_SUSPEND))
+    {
+        USB_printf("USB resume\n");
+        usb_dev_ptr->USB_STATE = usb_dev_ptr->USB_DEV_STATE_B4_SUSPEND;
+        /* Inform the upper layers */
+        _usb_device_call_service(usb_dev_ptr, ARC_USB_SERVICE_RESUME, 0, 0, 0, 0, 0);
+
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "process_port_change, SUCCESSFUL, resumed\n");
+        return;
+    } /* Endif */
+
+    usb_dev_ptr->USB_STATE = ARC_USB_STATE_DEFAULT;
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_process_error
+*  Returned Value : None
+*  Comments       :
+*        Services error interrupt
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_process_error
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR          usb_dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   /* Increment the error count */
+   usb_dev_ptr->ERRORS++;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ERROR,
+                "process_error_%d: state=0x%x\n",
+                    usb_dev_ptr->ERRORS, usb_dev_ptr->ERROR_STATE);
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_set_speed_full
+*  Returned Value : None
+*  Comments       :
+*        Force the controller port in full speed mode.
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_set_speed_full
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* The port number on the device */
+      uint_8                     port_number
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      port_control;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "FORCE set_speed_full\n");
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);
+   port_control |= EHCI_PORTSCX_FORCE_FULL_SPEED_CONNECT;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_suspend_phy
+*  Returned Value : None
+*  Comments       :
+*        Suspends the PHY in low power mode
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_suspend_phy
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* The port number on the device */
+      uint_8                     port_number
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      port_control;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SUSPEND, "set_suspend_phy\n");
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   port_control = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number]);
+   port_control |= EHCI_PORTSCX_PHY_CLOCK_DISABLE;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[port_number] = USB_32BIT_LE(port_control);
+
+} /* EndBody */
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_set_address
+*  Returned Value : None
+*  Comments       :
+*        Sets the newly assigned device address
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_set_address
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* Address of the device assigned by the host */
+      uint_8                     address
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR          usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR             dev_ptr;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ADDR, "set_address: address=%d\n",address);
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+#ifdef SET_ADDRESS_HARDWARE_ASSISTANCE
+   /***********************************************************
+   Hardware Rev 4.0 onwards have special assistance built in
+   for handling the set_address command. As per the USB specs
+   a device should be able to receive the response on a new
+   address, within 2 msecs after status phase of set_address is
+   completed. Since 2 mili second may be a very small time window
+   (on high interrupt latency systems) before software could
+   come to the code below and write the device register,
+   this routine will be called in advance when status phase of
+   set_address is still not finished. The following line in the
+   code will set the bit 24 to '1' and hardware will take
+   the address and queue it in an internal buffer. From which
+   it will use it to decode the next USB token. Please look
+   at hardware rev details for the implementation of this
+   assistance.
+
+   Also note that writing bit 24 to 0x01 will not break
+   any old hardware revs because it was an unused bit.
+   ***********************************************************/
+   /* The address bits are past bit 25-31. Set the address
+   also set the bit 24 to 0x01 to start hardware assitance*/
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR =
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT) |
+      (0x01 << (VUSBHS_ADDRESS_BIT_SHIFT -1));
+#else
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.DEVICE_ADDR =
+      USB_32BIT_LE((uint_32)address << VUSBHS_ADDRESS_BIT_SHIFT);
+#endif /* SET_ADDRESS_HARDWARE_ASSISTANCE */
+
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_ADDRESS;
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_setup_data
+*  Returned Value : None
+*  Comments       :
+*        Reads the Setup data from the 8-byte setup buffer
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_get_setup_data
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [OUT] address of the buffer to read the setup data into */
+      uint_8_ptr                  buffer_ptr
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                    usb_dev_ptr;
+    volatile VUSB20_REG_STRUCT_PTR              dev_ptr;
+    volatile VUSB20_EP_QUEUE_HEAD_STRUCT_PTR    ep_queue_head_ptr;
+    volatile boolean                            read_safe = FALSE;
+    volatile unsigned long                      timeout;
+
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Get the endpoint queue head */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+                                                                2*ep_num + ARC_USB_RECV;
+
+   /********************************************************************
+   CR 1219. Hardware versions 2.3+ have a implementation of tripwire
+   semaphore mechanism that requires that we read the contents of
+   QH safely by using the semaphore. Read the USBHS document to under
+   stand how the code uses the semaphore mechanism. The following are
+   the steps in brief
+
+   1. USBCMD Write 1 to Setup Tripwire in register.
+   2. Duplicate contents of dQH.StatusBuffer into local software byte
+      array.
+   3  Read Setup TripWire in register. (if set - continue; if
+      cleared goto 1.)
+   4. Write '0' to clear Setup Tripwire in register.
+   5. Process setup packet using local software byte array copy and
+      execute status/handshake phases.
+
+
+   ********************************************************************/
+    timeout = 0x100000;
+    while(!read_safe)
+    {
+        /*********************************************************
+        start with setting the semaphores
+        *********************************************************/
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD |=
+                                                USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_SET);
+
+        /* Copy the setup packet to private buffer */
+        USB_memcopy((uint_8_ptr)ep_queue_head_ptr->SETUP_BUFFER, buffer_ptr, 8);
+
+        /*********************************************************
+        If setup tripwire semaphore is cleared by hardware it means
+        that we have a danger and we need to restart.
+        else we can exit out of loop safely.
+        *********************************************************/
+        if(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD) &
+                                                   EHCI_CMD_SETUP_TRIPWIRE_SET)
+        {
+            read_safe = TRUE; /* we can proceed exiting out of loop*/
+        }
+        if(timeout <= 0)
+        {
+            USB_printf("%s: Timeout for SETUP_TRIPWIRE = 0x%x\n", __FUNCTION__,
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD));
+            break;
+        }
+    }
+    ARC_DEBUG_CODE(ARC_DEBUG_FLAG_STATS, (usb_dev_ptr->STATS.usb_read_setup_count++));
+
+   /*********************************************************
+   Clear the semaphore bit now
+   *********************************************************/
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &=
+                                    USB_32BIT_LE(EHCI_CMD_SETUP_TRIPWIRE_CLEAR);
+
+   /* Clear the bit in the ENDPTSETUPSTAT */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT = USB_32BIT_LE(1 << ep_num);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_init_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Initializes the specified endpoint and the endpoint queue head
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_init_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the transaction descriptor address */
+      XD_STRUCT_PTR              xd_ptr
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_            ep_queue_head_ptr;
+   uint_32                                      val, bit_pos;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Get the endpoint queue head address */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+                                                    2*xd_ptr->EP_NUM + xd_ptr->BDIRECTION;
+
+   bit_pos = (1 << (16 * xd_ptr->BDIRECTION + xd_ptr->EP_NUM));
+
+   /* Check if the Endpoint is Primed */
+   if ((!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) &&
+       (!(USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)))
+   {
+      /* Set the max packet length, interrupt on Setup and Mult fields */
+      if (xd_ptr->EP_TYPE == ARC_USB_ISOCHRONOUS_ENDPOINT)
+      {
+         /* Mult bit should be set for isochronous endpoints */
+         ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
+            ((xd_ptr->MAX_PKTS_PER_UFRAME ?  xd_ptr->MAX_PKTS_PER_UFRAME : 1) <<
+            VUSB_EP_QUEUE_HEAD_MULT_POS));
+      }
+      else
+      {
+         if (xd_ptr->EP_TYPE != ARC_USB_CONTROL_ENDPOINT)
+         {
+             /* BULK or INTERRUPT */
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
+               (xd_ptr->DONT_ZERO_TERMINATE ? VUSB_EP_QUEUE_HEAD_ZERO_LEN_TER_SEL : 0));
+         }
+         else
+         {
+             /* CONTROL */
+            ep_queue_head_ptr->MAX_PKT_LENGTH = USB_32BIT_LE((xd_ptr->WMAXPACKETSIZE << 16) |
+                                                    VUSB_EP_QUEUE_HEAD_IOS);
+         } /* Endif */
+      } /* Endif */
+
+      /* Enable the endpoint for Rx or Tx and set the endpoint type */
+      val = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM];
+      if(xd_ptr->BDIRECTION  == ARC_USB_SEND)
+      {
+          val &= ~(USB_32BIT_LE(EHCI_EPCTRL_TX_ALL_MASK));
+          val |= USB_32BIT_LE((EHCI_EPCTRL_TX_ENABLE | EHCI_EPCTRL_TX_DATA_TOGGLE_RST) |
+                          (xd_ptr->EP_TYPE << EHCI_EPCTRL_TX_EP_TYPE_SHIFT));
+      }
+      else
+      {
+          val &= ~(USB_32BIT_LE(EHCI_EPCTRL_RX_ALL_MASK));
+          val |= USB_32BIT_LE((EHCI_EPCTRL_RX_ENABLE | EHCI_EPCTRL_RX_DATA_TOGGLE_RST) |
+                          (xd_ptr->EP_TYPE << EHCI_EPCTRL_RX_EP_TYPE_SHIFT));
+      }
+      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] = val;
+
+      /* Implement Guideline (GL# USB-7) The unused endpoint type must  */
+      /* be programmed to bulk.                                         */
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] &
+            USB_32BIT_LE(EHCI_EPCTRL_RX_ENABLE)) == 0)
+      {
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |=
+              USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_RX_EP_TYPE_SHIFT);
+      }
+
+      if( (dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] &
+            USB_32BIT_LE(EHCI_EPCTRL_TX_ENABLE)) == 0)
+      {
+          dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM] |=
+              USB_32BIT_LE(ARC_USB_BULK_ENDPOINT << EHCI_EPCTRL_TX_EP_TYPE_SHIFT);
+      }
+
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
+                    "init ep #%d %s: type=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n",
+                        xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV", xd_ptr->EP_TYPE,
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[xd_ptr->EP_NUM]),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                        (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
+   }
+   else
+   {
+      USB_printf("ep=%d %s: Init ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                (unsigned)xd_ptr->EP_NUM, xd_ptr->BDIRECTION ? "SEND" : "RECV",
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                (unsigned)bit_pos);
+        return USBERR_EP_INIT_FAILED;
+   } /* Endif */
+
+   return USB_OK;
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_transfer_status
+*  Returned Value : USB_OK or error code
+*  Comments       :
+*        Gets the status of a transfer
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_get_transfer_status
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR                      dTD_ptr;
+   XD_STRUCT_PTR                                xd_ptr;
+   uint_8                                       status;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
+
+   if (dTD_ptr)
+   {
+      /* Get the transfer descriptor for the dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      status = xd_ptr->BSTATUS;
+   }
+   else
+   {
+      status = ARC_USB_STATUS_IDLE;
+   } /* Endif */
+
+   return (status);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_get_transfer_details
+*  Returned Value : pointer to structure that has details for transfer
+*        Gets the status of a transfer
+*
+*END*-----------------------------------------------------------------*/
+XD_STRUCT_PTR  _usb_dci_vusb20_get_transfer_details
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   VUSB20_EP_TR_STRUCT_PTR                      dTD_ptr, temp_dTD_ptr;
+   XD_STRUCT_PTR                                xd_ptr;
+   uint_32                                      temp, remaining_bytes;
+   VUSB20_EP_QUEUE_HEAD_STRUCT_PTR              ep_queue_head_ptr;
+
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+   temp = (2*ep_num + direction);
+
+   /* get a pointer to QH for this endpoint */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR + temp;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "get_transfer_details\n");
+
+   /* Unlink the dTD */
+   dTD_ptr = usb_dev_ptr->EP_DTD_HEADS[2*ep_num + direction];
+
+   if (dTD_ptr)
+   {
+      /* Get the transfer descriptor for the dTD */
+      xd_ptr = (XD_STRUCT_PTR)dTD_ptr->SCRATCH_PTR->XD_FOR_THIS_DTD;
+      if(!xd_ptr) return NULL;
+
+      /* Initialize the transfer length field */
+      xd_ptr->WSOFAR =0;
+      remaining_bytes =0;
+
+      /*if length of this transfer is greater than 20K
+      we have multiple DTDs to count */
+      if(xd_ptr->WTOTALLENGTH > VUSB_EP_MAX_LENGTH_TRANSFER)
+      {
+         /* it is a valid DTD. We should parse all DTDs for this XD
+         and find the total bytes used so far */
+         temp_dTD_ptr = dTD_ptr;
+
+         /*loop through the list of DTDS until an active DTD is found
+         or list has finished */
+         while(!(USB_32BIT_LE(dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_NEXT_TERMINATE))
+         {
+
+            /**********************************************************
+            If this DTD has been overlayed, we take the actual length
+            from QH.
+            **********************************************************/
+
+            if ((uint_32)(USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR) & VUSBHS_TD_ADDR_MASK) ==
+                                     USB_DTD_VIRT_TO_PHYS(usb_dev_ptr, temp_dTD_ptr) )
+            {
+                remaining_bytes +=
+                  ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+            }
+            else
+            {
+               /* take the length from DTD itself */
+                remaining_bytes +=
+                  ((USB_32BIT_LE(temp_dTD_ptr->SIZE_IOC_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+            }
+
+            dTD_ptr = temp_dTD_ptr;
+
+            /* Get the address of the next dTD */
+            temp_dTD_ptr = (VUSB20_EP_TR_STRUCT_PTR)USB_DTD_PHYS_TO_VIRT(usb_dev_ptr,
+                                (uint_32)(USB_32BIT_LE(temp_dTD_ptr->NEXT_TR_ELEM_PTR) & VUSBHS_TD_ADDR_MASK) );
+         }
+         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH - remaining_bytes;
+      }
+      else
+      {
+         /*look at actual length from QH*/
+         xd_ptr->WSOFAR = xd_ptr->WTOTALLENGTH -
+            ((USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS) & VUSB_EP_TR_PACKET_SIZE) >> 16);
+      }
+   }
+   else
+   {
+      xd_ptr = NULL;
+   } /* Endif */
+
+   return (xd_ptr);
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_deinit_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Disables the specified endpoint and the endpoint queue head
+*
+*END*-----------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_deinit_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR        usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR           dev_ptr;
+    VUSB20_EP_QUEUE_HEAD_STRUCT*    ep_queue_head_ptr;
+    uint_32                         bit_pos;
+    uint_8                          status = USB_OK;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    /* Get the endpoint queue head address */
+    ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+                                                                    (2*ep_num + direction);
+
+    bit_pos = (1 << (16 * direction + ep_num));
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT,
+               "deinit ep #%d-%s: bit_pos=0x%x, EPCTRLX=0x%x, SETUP=0x%x, PRIME=0x%x, STATUS=0x%x, COMPL=0x%x\n",
+                   ep_num, direction ? "SEND" : "RECV", bit_pos,
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPT_SETUP_STAT),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                   (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCOMPLETE) );
+
+    /* Check if the Endpoint is Primed */
+    if( ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME) & bit_pos)) ||
+        ((USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS) & bit_pos)) )
+    {
+        USB_printf("ep=%d %s: Deinit ERROR: ENDPTPRIME=0x%x, ENDPTSTATUS=0x%x, bit_pos=0x%x\n",
+                (unsigned)ep_num, direction ? "SEND" : "RECV",
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTPRIME),
+                (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTSTATUS),
+                (unsigned)bit_pos);
+        status = USBERR_EP_DEINIT_FAILED;
+    }
+
+    /* Reset the max packet length and the interrupt on Setup */
+    ep_queue_head_ptr->MAX_PKT_LENGTH = 0;
+
+    /* Disable the endpoint for Rx or Tx and reset the endpoint type */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
+         USB_32BIT_LE( ~((direction ? EHCI_EPCTRL_TX_ENABLE : EHCI_EPCTRL_RX_ENABLE) |
+                        (direction ? EHCI_EPCTRL_TX_TYPE : EHCI_EPCTRL_RX_TYPE)));
+
+   return status;
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_shutdown
+*  Returned Value : None
+*  Comments       :
+*        Shuts down the VUSB_HS Device
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_shutdown
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+    USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+    VUSB20_REG_STRUCT_PTR                        dev_ptr;
+
+    usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+    dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    /* Disable interrupts */
+    dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &=
+      ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
+      EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
+
+    USB_uncached_memfree(usb_dev_ptr->EP_QUEUE_HEAD_BASE,
+                        usb_dev_ptr->EP_QUEUE_HEAD_SIZE,
+                        usb_dev_ptr->EP_QUEUE_HEAD_PHYS);
+
+    USB_uncached_memfree(usb_dev_ptr->DTD_BASE_PTR,
+                        usb_dev_ptr->DTD_SIZE,
+                        usb_dev_ptr->DTD_BASE_PHYS);
+
+    USB_memfree(usb_dev_ptr->SCRATCH_STRUCT_BASE);
+
+    USB_printf("USB shutdown: usb_dev_ptr=%p\n", usb_dev_ptr);
+
+   /* Reset the Run the bit in the command register to stop VUSB */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+
+   /* Reset the controller to get default values */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_CTRL_RESET);
+
+} /* EndBody */
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_stop
+*  Returned Value : None
+*  Comments       :
+*        Stop USB device controller
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_stop(_usb_device_handle handle)
+{
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+    /* Disable interrupts */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR &=
+            ~(USB_32BIT_LE(EHCI_INTR_INT_EN | EHCI_INTR_ERR_INT_EN |
+                           EHCI_INTR_PORT_CHANGE_DETECT_EN | EHCI_INTR_RESET_EN));
+
+   /* Reset the Run the bit in the command register to stop VUSB */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD &= ~USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+}
+
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_start
+*  Returned Value : None
+*  Comments       :
+*        Start USB device controller
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_start(_usb_device_handle handle)
+{
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+      /* Enable interrupts */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_INTR = USB_32BIT_LE(
+                           EHCI_INTR_INT_EN
+                         | EHCI_INTR_ERR_INT_EN
+                         | EHCI_INTR_PORT_CHANGE_DETECT_EN
+                         | EHCI_INTR_RESET_EN
+                         | EHCI_INTR_DEVICE_SUSPEND
+                       /*
+                         | EHCI_INTR_SOF_UFRAME_EN
+                        */
+                         );
+
+   usb_dev_ptr->USB_STATE = ARC_USB_STATE_UNKNOWN;
+
+   /* Set the Run bit in the command register */
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.USB_CMD = USB_32BIT_LE(EHCI_CMD_RUN_STOP);
+}
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevUtl.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevUtl.c
new file mode 100644
index 0000000..b1b0254
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/device/mvUsbHsDevUtl.c
@@ -0,0 +1,273 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "api/mvUsbDevApi.h"
+#include "device/mvUsbDevPrv.h"
+#include "api/mvUsbDefs.h"
+
+/* Test packet for Test Mode : TEST_PACKET. USB 2.0 Specification section 7.1.20 */
+uint_8 test_packet[USB_TEST_MODE_TEST_PACKET_LENGTH] =
+{
+   /* Synch */
+   /* DATA 0 PID */
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
+   0xAA, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
+   0xEE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xBF, 0xDF,
+   0xEF, 0xF7, 0xFB, 0xFD, 0xFC, 0x7E, 0xBF, 0xDF,
+   0xEF, 0xF7, 0xFB, 0xFD, 0x7E
+};
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_assert_resume
+*  Returned Value : None
+*  Comments       :
+*        Resume signalling for remote wakeup
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_assert_resume
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR             dev_ptr;
+   uint_32                                      temp;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Assert the Resume signal */
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   temp &= ~EHCI_PORTSCX_W1C_BITS;
+   temp |= EHCI_PORTSCX_PORT_FORCE_RESUME;
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] = USB_32BIT_LE(temp);
+
+   /* Port change interrupt will be asserted at the end of resume
+   ** operation
+   */
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_stall_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Stalls the specified endpoint
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_stall_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR             usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                dev_ptr;
+   VUSB20_EP_QUEUE_HEAD_STRUCT _PTR_    ep_queue_head_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Get the endpoint queue head address */
+   ep_queue_head_ptr = (VUSB20_EP_QUEUE_HEAD_STRUCT_PTR)usb_dev_ptr->EP_QUEUE_HEAD_PTR +
+                                                                    2*ep_num + direction;
+   /* Stall the endpoint for Rx or Tx and set the endpoint type */
+   if (ep_queue_head_ptr->MAX_PKT_LENGTH & USB_32BIT_LE(VUSB_EP_QUEUE_HEAD_IOS))
+   {
+      /* This is a control endpoint so STALL both directions */
+      dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
+         USB_32BIT_LE((EHCI_EPCTRL_TX_EP_STALL | EHCI_EPCTRL_RX_EP_STALL));
+   }
+   else
+   {
+       if(direction)
+       {
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
+                        USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL);
+       }
+       else {
+            dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
+                        USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL);
+       }
+   } /* Endif */
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL,
+                    "STALL ep=%d %s: EPCTRLX=0x%x, CURR_dTD=0x%x, NEXT_dTD=0x%x, SIZE=0x%x\n",
+                    ep_num, direction ? "SEND" : "RECV",
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]),
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->CURR_DTD_PTR),
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->NEXT_DTD_PTR),
+                    (unsigned)USB_32BIT_LE(ep_queue_head_ptr->SIZE_IOC_INT_STS));
+
+} /* EndBody */
+
+/*FUNCTION*-------------------------------------------------------------
+*
+*  Function Name  : _usb_dci_vusb20_unstall_endpoint
+*  Returned Value : None
+*  Comments       :
+*        Unstall the specified endpoint in the specified direction
+*
+*END*-----------------------------------------------------------------*/
+void _usb_dci_vusb20_unstall_endpoint
+   (
+      /* [IN] the USB_dev_initialize state structure */
+      _usb_device_handle         handle,
+
+      /* [IN] the Endpoint number */
+      uint_8                     ep_num,
+
+      /* [IN] direction */
+      uint_8                     direction
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   /* Enable the endpoint for Rx or Tx and set the endpoint type */
+   if(direction)
+   {
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
+              USB_32BIT_LE(EHCI_EPCTRL_TX_DATA_TOGGLE_RST);
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
+                ~(USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
+   }
+   else
+   {
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] |=
+              USB_32BIT_LE(EHCI_EPCTRL_RX_DATA_TOGGLE_RST);
+
+        dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num] &=
+                ~(USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
+   }
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_STALL,
+                    "UNSTALL ep=%d %s: EPCTRLX=0x%x\n",
+                    ep_num, direction ? "SEND" : "RECV",
+                    (unsigned)USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep_num]));
+
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_dci_vusb20_is_endpoint_stalled
+* Returned Value : None
+* Comments       :
+*     Gets the endpoint status
+*
+*END*--------------------------------------------------------------------*/
+uint_8 _usb_dci_vusb20_is_endpoint_stalled
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep,
+
+      /* [IN] Endpoint direction */
+      uint_8               dir
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR        dev_ptr;
+   uint_32                      value;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_TRACE, "is_endpoint_stalled\n");
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   if(dir)
+   {
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] &
+                                    (USB_32BIT_LE(EHCI_EPCTRL_TX_EP_STALL));
+   }
+   else
+   {
+        value = dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[ep] &
+                                    (USB_32BIT_LE(EHCI_EPCTRL_RX_EP_STALL));
+   }
+   return (value) ? 1 : 0;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _usb_dci_vusb20_set_test_mode
+* Returned Value : None
+* Comments       :
+*     sets/resets the test mode
+*
+*END*--------------------------------------------------------------------*/
+void _usb_dci_vusb20_set_test_mode
+   (
+      /* [IN] Handle to the USB device */
+      _usb_device_handle handle,
+
+      /* [IN] Test mode */
+      uint_16 test_mode
+   )
+{ /* Body */
+   USB_DEV_STATE_STRUCT_PTR                     usb_dev_ptr;
+   VUSB20_REG_STRUCT_PTR                        dev_ptr;
+   uint_32                                      temp;
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_ANY, "set_test_mode\n");
+
+   usb_dev_ptr = (USB_DEV_STATE_STRUCT_PTR)handle;
+   dev_ptr = (VUSB20_REG_STRUCT_PTR)usb_dev_ptr->DEV_PTR;
+
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0]);
+
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.ENDPTCTRLX[0] =
+                                USB_32BIT_LE((temp | EHCI_EPCTRL_TX_DATA_TOGGLE_RST));
+
+   if (test_mode == ARC_USB_TEST_MODE_TEST_PACKET)
+   {
+       USB_memcopy(test_packet, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH);
+      _usb_device_send_data(handle, 0, usb_dev_ptr->TEST_PKT_PTR, USB_TEST_MODE_TEST_PACKET_LENGTH);
+
+   } /* Endif */
+
+   temp = USB_32BIT_LE(dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0]);
+   temp &= ~EHCI_PORTSCX_W1C_BITS;
+
+   dev_ptr->REGISTERS.OPERATIONAL_DEVICE_REGISTERS.PORTSCX[0] =
+                                    USB_32BIT_LE(temp | ((uint_32)test_mode << 8));
+
+} /* EndBody */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.c
new file mode 100644
index 0000000..fb5c19d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.c
@@ -0,0 +1,2298 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+/**************************************************************************
+Include the USB stack and local header files.
+**************************************************************************/
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+
+#include "usb/api/mvUsbDefs.h"
+#include "usb/api/mvUsbCh9.h"
+#include "usb/api/mvUsbDebug.h"
+#include "usb/api/mvUsbDevApi.h"
+#include "usb/examples/disk.h"
+
+/* MSB of debug flags for USB device usage */
+#define ARC_DEBUG_FLAG_DISK         0x01000000
+#define ARC_DEBUG_FLAG_DISK_READ    0x02000000
+#define ARC_DEBUG_FLAG_DISK_WRITE   0x04000000
+#define ARC_DEBUG_FLAG_DISK_CAP     0x08000000
+#define ARC_DEBUG_FLAG_DISK_DATA    0x10000000
+#define ARC_DEBUG_FLAG_DISK_DUMP    0x20000000
+
+
+/**************************************************************************
+Include the OS and BSP dependent files that define IO functions and
+basic types. You may like to change these files for your board and RTOS
+**************************************************************************/
+
+
+/**************************************************************************
+Global variables and some defines for device.
+**************************************************************************/
+
+#define BUFFERSIZE                      (2048)
+
+#define EP_TEMP_BUFFERSIZE              (32)
+#define MASS_STORAGE_INTERFACE          (0)
+
+#define APP_CONTROL_MAX_PKT_SIZE        (64)
+#define DEV_DESC_MAX_PACKET_SIZE        (7)
+#define DISK_FS_MAX_PACKET_SIZE         (64)
+#define DISK_HS_MAX_PACKET_SIZE         (512)
+
+#define CFG_DESC_EP_IN_TYPE_OFFSET              (21)
+#define CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET   (22)
+#define CFG_DESC_EP_OUT_TYPE_OFFSET             (28)
+#define CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET  (29)
+
+#define TOTAL_LOGICAL_ADDRESS_BLOCKS    (4096)
+#define LENGTH_OF_EACH_LAB              (512)
+
+#define DISK_IN_EP_NO       1
+#define DISK_OUT_EP_NO      2
+
+#define DISK_IN_EP_TYPE     2 /* Bulk */
+#define DISK_OUT_EP_TYPE    2 /* Bulk */
+
+typedef struct
+{
+    _usb_device_handle  usbDevHandle;     /* Must be first field */
+    uint_32             devNo;
+    uint_8_ptr          Send_Buffer_Unaligned;
+
+    uint_8_ptr          DevDesc;
+    uint_8_ptr          DevQualifierDesc;
+    uint_8_ptr          ConfigDesc;
+    uint_8_ptr          other_speed_config;
+    uint_8_ptr          ep1_buf;
+    uint_8_ptr          epTemp_buf;
+    DISK_READ_CAPACITY* pReadCapacity;
+    CSW_STRUCT*         pCSW;
+    uint_8_ptr          MASS_STORAGE_DISK;
+
+    SETUP_STRUCT        local_setup_packet;
+
+    volatile boolean    TEST_ENABLED;
+    volatile boolean    ENTER_TEST_MODE;
+    volatile uint_16    test_mode_index;
+    volatile uint_8     speed;
+    uint_16             logicalBlocks;
+    uint_32             hsMaxPktSize;
+    uint_32             fsMaxPktSize;
+
+    uint_32             inEpType;
+    uint_32             outEpType;
+
+    uint_32             inEpNo;
+    uint_32             outEpNo;
+    boolean             CBW_PROCESSED;
+    boolean             ZERO_TERMINATE;
+
+} USB_DISK_STRUCT;
+
+uint_32             diskHsMaxPktSize = DISK_HS_MAX_PACKET_SIZE;
+uint_32             diskFsMaxPktSize = DISK_FS_MAX_PACKET_SIZE;
+
+uint_32             diskInEpType = DISK_IN_EP_TYPE;
+uint_32             diskOutEpType = DISK_OUT_EP_TYPE;
+
+uint_32             diskInEpNo = DISK_IN_EP_NO;
+uint_32             diskOutEpNo = DISK_OUT_EP_NO;
+
+static USB_DISK_STRUCT*  usbDisksPtr[MAX_USB_DEVICES] = { NULL, NULL };
+
+/**************************************************************************
+DESCRIPTORS DESCRIPTORS DESCRIPTORS DESCRIPTORS DESCRIPTORS DESCRIPTORS
+**************************************************************************/
+
+#define DEVICE_DESCRIPTOR_SIZE 18
+static const uint_8  DevDescData[DEVICE_DESCRIPTOR_SIZE] =
+{
+   /* Length of DevDesc */
+   DEVICE_DESCRIPTOR_SIZE,
+   /* "Device" Type of descriptor */
+   1,
+   /* BCD USB version */
+   0, 2,
+   /* Device Class is indicated in the interface descriptors */
+   0x00,
+   /* Device Subclass is indicated in the interface descriptors */
+   0x00,
+   /* Mass storage devices do not use class-specific protocols */
+   0x00,
+   /* Max packet size */
+   APP_CONTROL_MAX_PKT_SIZE,
+   /* Vendor ID */
+   USB_uint_16_low(0x1286), USB_uint_16_high(0x1286),
+   /* Product ID */
+   USB_uint_16_low(0x1), USB_uint_16_high(0x1),
+   /* BCD Device version */
+   USB_uint_16_low(0x0002), USB_uint_16_high(0x0002),
+   /* Manufacturer string index */
+   0x1,
+   /* Product string index */
+   0x2,
+   /* Serial number string index */
+   0x6,
+   /* Number of configurations available */
+   0x1
+};
+
+/* USB 2.0 specific descriptor */
+#define DEVICE_QUALIFIER_DESCRIPTOR_SIZE 10
+static const uint_8  DevQualifierDescData[DEVICE_QUALIFIER_DESCRIPTOR_SIZE] =
+{
+   DEVICE_QUALIFIER_DESCRIPTOR_SIZE,  /* bLength Length of this descriptor */
+   6,                         /* bDescType This is a DEVICE Qualifier descr */
+   0,2,                       /* bcdUSB USB revision 2.0 */
+   0,                         /* bDeviceClass */
+   0,                         /* bDeviceSubClass */
+   0,                         /* bDeviceProtocol */
+   APP_CONTROL_MAX_PKT_SIZE,  /* bMaxPacketSize0 */
+   0x01,                      /* bNumConfigurations */
+   0
+};
+
+#define CONFIG_DESC_NUM_INTERFACES  (4)
+/* This must be counted manually and updated with the descriptor */
+/* 1*Config(9) + 1*Interface(9) + 2*Endpoint(7) = 32 bytes */
+#define CONFIG_DESC_SIZE            (32)
+
+/**************************************************************
+we declare the config desc as USB_Uncached because this descriptor
+is updated on the fly for max packet size during enumeration. Making
+it uncached ensures that main memory is updated whenever this
+descriptor pointer is used.
+**************************************************************/
+static const uint_8 ConfigDescData[CONFIG_DESC_SIZE] =
+{
+   /* Configuration Descriptor - always 9 bytes */
+   9,
+   /* "Configuration" type of descriptor */
+   2,
+   /* Total length of the Configuration descriptor */
+   USB_uint_16_low(CONFIG_DESC_SIZE),
+   USB_uint_16_high(CONFIG_DESC_SIZE),
+   /* NumInterfaces */
+   1,
+   /* Configuration Value */
+   1,
+   /* Configuration Description String Index*/
+   4,
+   /* Attributes.  Self-powered. */
+   0xc0,
+   /* Current draw from bus */
+   0,
+   /* Interface 0 Descriptor - always 9 bytes */
+   9,
+   /* "Interface" type of descriptor */
+   4,
+   /* Number of this interface */
+   MASS_STORAGE_INTERFACE,
+   /* Alternate Setting */
+   0,
+   /* Number of endpoints on this interface */
+   2,
+   /* Interface Class */
+   0x08,
+   /* Interface Subclass: SCSI transparent command set */
+   0x06,
+   /* Interface Protocol: Bulk only protocol */
+   0x50,
+   /* Interface Description String Index */
+   0,
+   /* Endpoint 1 (Bulk In Endpoint), Interface 0 Descriptor - always 7 bytes*/
+   7,
+   /* "Endpoint" type of descriptor */
+   5,
+   /*
+   ** Endpoint address.  The low nibble contains the endpoint number and the
+   ** high bit indicates TX(1) or RX(0).
+   */
+   ((ARC_USB_SEND<<7) | DISK_IN_EP_NO) /*0x81*/,
+   /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
+   DISK_IN_EP_TYPE,
+   /* Max Packet Size for this endpoint */
+   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE),
+   USB_uint_16_high(DISK_FS_MAX_PACKET_SIZE),
+   /* Polling Interval (ms) */
+   0,
+   /* Endpoint 2 (Bulk Out Endpoint), Interface 0 Descriptor - always 7 bytes*/
+   7,
+   /* "Endpoint" type of descriptor */
+   5,
+   /*
+   ** Endpoint address.  The low nibble contains the endpoint number and the
+   ** high bit indicates TX(1) or RX(0).
+   */
+   ((ARC_USB_RECV<<7) | DISK_OUT_EP_NO), /*0x02*/
+   /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
+   DISK_OUT_EP_TYPE,
+   /* Max Packet Size for this endpoint */
+   USB_uint_16_low(DISK_FS_MAX_PACKET_SIZE),
+   USB_uint_16_high(DISK_FS_MAX_PACKET_SIZE),
+   /* Polling Interval (ms) */
+   0
+};
+
+#define OTHER_SPEED_CONFIG_DESC_SIZE  CONFIG_DESC_SIZE
+static const uint_8  other_speed_config_data[CONFIG_DESC_SIZE] =
+{
+   9,                         /* bLength Length of this descriptor */
+   7,                         /* bDescType This is a Other speed config descr */
+   USB_uint_16_low(OTHER_SPEED_CONFIG_DESC_SIZE),
+   USB_uint_16_high(OTHER_SPEED_CONFIG_DESC_SIZE),
+   1,
+   1,
+   4,
+   0xc0,
+   0,
+   /* Interface 0 Descriptor - always 9 bytes */
+   9,
+   /* "Interface" type of descriptor */
+   4,
+   /* Number of this interface */
+   MASS_STORAGE_INTERFACE,
+   /* Alternate Setting */
+   0,
+   /* Number of endpoints on this interface */
+   2,
+   /* Interface Class */
+   0x08,
+   /* Interface Subclass: SCSI transparent command set */
+   0x06,
+   /* Interface Protocol: Bulk only protocol */
+   0x50,
+   /* Interface Description String Index */
+   0,
+   /* Endpoint 1 (Bulk In Endpoint), Interface 0 Descriptor - always 7 bytes*/
+   7,
+   /* "Endpoint" type of descriptor */
+   5,
+   /*
+   ** Endpoint address.  The low nibble contains the endpoint number and the
+   ** high bit indicates TX(1) or RX(0).
+   */
+   ((ARC_USB_SEND<<7) | DISK_IN_EP_NO), /*0x81*/
+   /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
+   DISK_IN_EP_TYPE,
+   /* Max Packet Size for this endpoint */
+   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE),
+   USB_uint_16_high(DISK_HS_MAX_PACKET_SIZE),
+   /* Polling Interval (ms) */
+   0,
+   /* Endpoint 2 (Bulk Out Endpoint), Interface 0 Descriptor - always 7 bytes*/
+   7,
+   /* "Endpoint" type of descriptor */
+   5,
+   /*
+   ** Endpoint address.  The low nibble contains the endpoint number and the
+   ** high bit indicates TX(1) or RX(0).
+   */
+   ((ARC_USB_RECV<<7) | DISK_OUT_EP_NO), /*0x02*/
+
+   /* Attributes.  0=Control 1=Isochronous 2=Bulk 3=Interrupt */
+   DISK_OUT_EP_TYPE,
+   /* Max Packet Size for this endpoint */
+   USB_uint_16_low(DISK_HS_MAX_PACKET_SIZE),
+   USB_uint_16_high(DISK_HS_MAX_PACKET_SIZE),
+   /* Polling Interval (ms) */
+   0
+};
+
+static uint_8 USB_IF_ALT[4] = { 0, 0, 0, 0};
+
+/* number of strings in the table not including 0 or n. */
+static const uint_8 USB_STR_NUM = 7;
+
+/*
+** if the number of strings changes, look for USB_STR_0 everywhere and make
+** the obvious changes.  It should be found in 3 places.
+*/
+
+static uint_16 USB_STR_0[ 2] = {(0x300 + sizeof(USB_STR_0)),(0x0409)};
+static uint_16 USB_STR_1[26] = {(0x300 + sizeof(USB_STR_1)),
+      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};
+static uint_16 USB_STR_2[28] = {(0x300 + sizeof(USB_STR_2)),
+      'M','A','R','V','E','L','L',' ','M','a','s','s',' ','S','t','o','r','a','g','e',' ',\
+      'D','e','v','i','c','e'};
+static uint_16 USB_STR_3[ 5] = {(0x300 + sizeof(USB_STR_3)),
+      'B','E','T','A'};
+static uint_16 USB_STR_4[ 4] = {(0x300 + sizeof(USB_STR_4)),
+      '#','0','2'};
+static uint_16 USB_STR_5[ 4] = {(0x300 + sizeof(USB_STR_5)),
+      '_','A','1'};
+      /* Serial number has to be at least 12 bytes */
+static uint_16 USB_STR_6[ 13] = {(0x300 + sizeof(USB_STR_6)),
+      '0','0','0','0','0','0','0','0','0','0','0','1'};
+static uint_16 USB_STR_7[15] = {(0x300 + sizeof(USB_STR_7)),
+      'Y','o','u','r',' ','n','a','m','e',' ','h','e','r','e'};
+static uint_16 USB_STR_n[17] = {(0x300 + sizeof(USB_STR_n)),
+      'B','A','D',' ','S','T','R','I','N','G',' ','I','n','d','e','x'};
+
+#define USB_STRING_ARRAY_SIZE  9
+static uint_8_ptr USB_STRING_DESC[USB_STRING_ARRAY_SIZE] =
+{
+   (uint_8_ptr)((pointer)USB_STR_0),
+   (uint_8_ptr)((pointer)USB_STR_1),
+   (uint_8_ptr)((pointer)USB_STR_2),
+   (uint_8_ptr)((pointer)USB_STR_3),
+   (uint_8_ptr)((pointer)USB_STR_4),
+   (uint_8_ptr)((pointer)USB_STR_5),
+   (uint_8_ptr)((pointer)USB_STR_6),
+   (uint_8_ptr)((pointer)USB_STR_7),
+   (uint_8_ptr)((pointer)USB_STR_n)
+};
+
+/*****************************************************************
+MASS STORAGE SPECIFIC GLOBALS
+*****************************************************************/
+
+static const DISK_DEVICE_INFO device_information_data =
+{
+   0, 0x80, 0, 0x01, 0x1F,
+   /* Reserved */
+   {0, 0, 0},
+   /* Vendor information: "MARVELL  " */
+   {0x4D, 0x41, 0x52, 0x56, 0x45, 0x4C, 0x4C, 0x20,},
+   /* Product information: "Disk            " */
+   {0x44, 0x69, 0x73, 0x6B, 0x20, 0x20, 0x20, 0x20,
+   0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
+   /* Product Revision level: "Demo" */
+   {0x44, 0x65, 0x6D, 0x6F}
+};
+
+static const DISK_READ_CAPACITY read_capacity =
+{
+   /* Data for the capacity */
+   {
+      0x00, 0x00, USB_uint_16_high(TOTAL_LOGICAL_ADDRESS_BLOCKS-14),
+      USB_uint_16_low(TOTAL_LOGICAL_ADDRESS_BLOCKS-14)
+   },
+   {
+      0x00, 0x00, USB_uint_16_high(LENGTH_OF_EACH_LAB),
+      USB_uint_16_low(LENGTH_OF_EACH_LAB)
+   }
+};
+
+static const uint_8 BOOT_SECTOR_AREA[512] =
+{
+   /* Block 0 is the boot sector. Following is the data in the boot sector */
+   /* 80x86 "short: jump instruction, indicating that the disk is formatted */
+    0xEB,
+    /* 8-bit displacement */
+    0x3C,
+    /* NOP OPCode */
+    0x90,
+    /* 8-bytes for OEM identification: "ARC 4.3 " */
+    0x41, 0x52, 0x43, 0x20, 0x34, 0x2E, 0x33, 0x20,
+    /* bytes/sector: 512 bytes (0x0200) */
+    0x00, 0x02,
+    /* Sectors/allocation unit */
+    0x01,
+    /* Reserved sectors: 0x0001 */
+    0x01, 0x00,
+    /* Number of File Allocation Tables (FATs): 2 */
+    0x02,
+    /* Number of root directory entries */
+    0x00, 0x02,
+    /* Total Small sectors in logical volume */
+    USB_uint_16_low(TOTAL_LOGICAL_ADDRESS_BLOCKS),
+    USB_uint_16_high(TOTAL_LOGICAL_ADDRESS_BLOCKS),
+    /* Media descriptor byte: 0xF8: Fixed disk */
+    0xF8,
+    /* Sectors/FAT: 3 (Each FAT starts at a new sector) */
+    0x80, 0x00,
+    /* Sectors/track: 9 */
+    0x09, 0x00,
+    /* Number of heads */
+    0x02, 0x00,
+    /* Number of hidden sectors: 0 */
+    0x00, 0x00, 0x00, 0x00,
+    /* Total Large sectors in logical volume */
+    0x00, 0x00, 0x00, 0x00,
+    /* Physical drive number */
+    0x00,
+    /* Reserved */
+    0x00,
+    /* Extended boot signature record: 0x29 */
+    0x29,
+    /* 32-bit binary volume ID */
+    0x01, 0x02, 0x03, 0x04,
+    /* Volume label */
+    0x53, 0x54, 0x55, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    /* Reserved FAT-16*/
+    0x46, 0x41, 0x54, 0x31, 0x36, 0x00, 0x00, 0x00,
+    /* Bootstrap */
+    0x33, 0xC0, 0x8E, 0xD0, 0xBC, 0x00, 0x7C, 0xFC, 0xE8, 0x45, 0x00,
+    /* String: \r\nNon-System disk\r\nPress any key to reboot\r\n" */
+    0x0D, 0x0A, 0x4E, 0x6F, 0x6E, 0x2D, 0x53, 0x79, 0x73, 0x74, 0x65,
+    0x6D, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x0D, 0x0A, 0x50, 0x72, 0x65,
+    0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20,
+    0x74, 0x6F, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x6F, 0x74, 0x0D, 0x0A,
+    0x5E, 0xEB, 0x02, 0xCD, 0x10, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 0x2E,
+    0xAC, 0x84, 0xC0, 0x75, 0xF3, 0x98, 0xCD, 0x16, 0xCD, 0x19, 0xEB,
+    0xB1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    /* Partition descriptors */
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
+};
+
+
+static const uint_8 FAT16_SPECIAL_BYTES[3] =
+{
+   /* FAT ID: Same as Media descriptor */
+   0xF8, 0xFF, 0xFF
+};
+
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetDescription
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetDescription command
+*     The Device Request can ask for Device/Config/string/interface/endpoint
+*     descriptors (via wValue). We then post an IN response to return the
+*     requested descriptor.
+*     And then wait for the OUT which terminates the control transfer.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetDescription
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+    uint_32             max_pkt_size;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x, length=%d\n",
+                __FUNCTION__, (int)setup, setup_ptr->VALUE, setup_ptr->LENGTH);
+
+    if (setup)
+    {
+        /* Load the appropriate string depending on the descriptor requested.*/
+        switch (setup_ptr->VALUE & 0xFF00)
+        {
+            case 0x0100:
+                _usb_device_send_data(handle, 0, pDiskCtrl->DevDesc,
+                    MIN(setup_ptr->LENGTH, DEVICE_DESCRIPTOR_SIZE));
+                break;
+
+            case 0x0200:
+                /* Set the Max Packet Size in the config and other speed config */
+                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
+                {
+                    max_pkt_size = pDiskCtrl->hsMaxPktSize;
+                }
+                else
+                {
+                    max_pkt_size = pDiskCtrl->fsMaxPktSize;
+                } /* Endif */
+
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_TYPE_OFFSET) = (uint_8)pDiskCtrl->inEpType;
+
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) =
+                                                USB_uint_16_low(max_pkt_size);
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) =
+                                                USB_uint_16_high(max_pkt_size);
+
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_TYPE_OFFSET) = (uint_8)pDiskCtrl->outEpType;
+
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) =
+                                                USB_uint_16_low(max_pkt_size);
+                *(pDiskCtrl->ConfigDesc + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) =
+                                                USB_uint_16_high(max_pkt_size);
+
+                _usb_device_send_data(handle, 0, pDiskCtrl->ConfigDesc,
+                            MIN(setup_ptr->LENGTH, CONFIG_DESC_SIZE));
+                break;
+
+            case 0x0300:
+                if ((setup_ptr->VALUE & 0x00FF) > USB_STR_NUM) {
+                    _usb_device_send_data(handle, 0, USB_STRING_DESC[USB_STR_NUM+1],
+                            MIN(setup_ptr->LENGTH, USB_STRING_DESC[USB_STR_NUM+1][0]));
+                }
+                else
+                {
+                    _usb_device_send_data(handle, 0, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF],
+                            MIN(setup_ptr->LENGTH, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF][0]));
+                } /* Endif */
+                break;
+
+            case 0x600:
+                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->DevQualifierDesc,
+                        MIN(setup_ptr->LENGTH, DEVICE_QUALIFIER_DESCRIPTOR_SIZE));
+                break;
+
+            case 0x700:
+                if(pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
+                {
+                    max_pkt_size = pDiskCtrl->fsMaxPktSize;
+                }
+                else
+                {
+                    max_pkt_size = pDiskCtrl->hsMaxPktSize;
+                } /* Endif */
+
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_TYPE_OFFSET) = (uint_8)pDiskCtrl->inEpType;
+
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET) =
+                    USB_uint_16_low(max_pkt_size);
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_IN_MAX_PACKET_SIZE_OFFSET+1) =
+                    USB_uint_16_high(max_pkt_size);
+
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_TYPE_OFFSET) = (uint_8)pDiskCtrl->outEpType;
+
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET) =
+                    USB_uint_16_low(max_pkt_size);
+                *(pDiskCtrl->other_speed_config + CFG_DESC_EP_OUT_MAX_PACKET_SIZE_OFFSET+1) =
+                    USB_uint_16_high(max_pkt_size);
+
+                _usb_device_send_data(handle, 0, (uint_8_ptr)pDiskCtrl->other_speed_config,
+                            MIN(setup_ptr->LENGTH, OTHER_SPEED_CONFIG_DESC_SIZE));
+
+                break;
+
+            default:
+                USB_printf("usbDisk_%d, %s: Unexpected VALUE=0x%04x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+                return;
+        } /* Endswitch */
+        /* status phase */
+        _usb_device_recv_data(handle, 0, NULL, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetDescription
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetDescription command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetDescription
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+   USB_printf("usbDisk_%d, %s: setup=%d\n",
+        _usb_device_get_dev_num(handle), __FUNCTION__, (int)setup);
+   _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetConfig
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetConfig command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetConfig
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    uint_16             current_config;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    /* Return the currently selected configuration */
+    if (setup)
+    {
+        _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
+                                &current_config);
+        *pDiskCtrl->epTemp_buf = (current_config & 0xFF);
+        _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, sizeof(uint_8));
+        /* status phase */
+        _usb_device_recv_data(handle, 0, NULL, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetConfig
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetConfig command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetConfig
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+    uint_16             usb_state;
+    uint_32             max_pkt_size;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d, value=0x%x\n",
+                    __FUNCTION__, (int)setup, setup_ptr->VALUE);
+
+    if (setup)
+    {
+        if ((setup_ptr->VALUE & 0x00FF) > 1)
+        {
+            /* generate stall */
+            USB_printf("usbDisk_%d, %s: Wrong VALUE=0x%04x\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+        } /* Endif */
+
+        /* 0 indicates return to unconfigured state */
+        if ((setup_ptr->VALUE & 0x00FF) == 0)
+        {
+            _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
+            if( (usb_state == ARC_USB_STATE_CONFIG) ||
+                (usb_state == ARC_USB_STATE_ADDRESS) )
+            {
+                /* clear the currently selected config value */
+                _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, 0);
+                _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
+                                                    ARC_USB_STATE_ADDRESS);
+                /* status phase */
+                _usb_device_send_data(handle, 0, 0, 0);
+            }
+            else
+            {
+                USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
+                _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            } /* Endif */
+            return;
+        } /* Endif */
+
+        /*
+        ** If the configuration value (setup_ptr->VALUE & 0x00FF) differs
+        ** from the current configuration value, then endpoints must be
+        ** reconfigured to match the new device configuration
+        */
+        _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
+                                                        &usb_state);
+
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk: Set configuration: old=%d, new=%d\n",
+                    usb_state, setup_ptr->VALUE & 0x00FF);
+
+        if (usb_state != (setup_ptr->VALUE & 0x00FF))
+        {
+            /* Reconfigure endpoints here */
+            switch (setup_ptr->VALUE & 0x00FF)
+            {
+                default:
+                break;
+            } /* Endswitch */
+
+            _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
+                                    setup_ptr->VALUE & 0x00FF);
+        } /* Endif */
+
+        if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
+        {
+            max_pkt_size = pDiskCtrl->hsMaxPktSize;
+        }
+        else
+        {
+            max_pkt_size = pDiskCtrl->fsMaxPktSize;
+        } /* Endif */
+
+        _usb_device_init_endpoint(handle, pDiskCtrl->outEpNo, max_pkt_size,
+                ARC_USB_RECV, ARC_USB_BULK_ENDPOINT, ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
+        _usb_device_init_endpoint(handle, pDiskCtrl->inEpNo, max_pkt_size,
+                ARC_USB_SEND, ARC_USB_BULK_ENDPOINT, ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
+
+        if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) == USB_OK)
+        {
+            _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+        } /* Endif */
+
+        pDiskCtrl->TEST_ENABLED = TRUE;
+
+        _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
+                                ARC_USB_STATE_CONFIG);
+        /* status phase */
+        _usb_device_send_data(handle, 0, 0, 0);
+
+        USB_printf("USB %s speed disk: config = %d\n",
+            (pDiskCtrl->speed == ARC_USB_SPEED_HIGH) ? "High" : "Full",
+            setup_ptr->VALUE & 0x00FF);
+
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetInterface
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetInterface command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetInterface
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    uint_16 usb_state;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
+    if (usb_state != ARC_USB_STATE_CONFIG)
+    {
+        USB_printf("usbDisk_%d, %s: Wrong usb_state=%d\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
+        _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+        return;
+    } /* Endif */
+
+    if (setup)
+    {
+        _usb_device_send_data(handle, 0, &USB_IF_ALT[setup_ptr->INDEX & 0x00FF],
+                            MIN(setup_ptr->LENGTH, sizeof(uint_8)));
+        /* status phase */
+        _usb_device_recv_data(handle, 0, NULL, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetInterface
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetInterface command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetInterface
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n", __FUNCTION__, (int)setup);
+
+    if (setup)
+    {
+        if (setup_ptr->REQUESTTYPE != 0x01)
+        {
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
+                        setup_ptr->REQUESTTYPE);
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+        } /* Endif */
+
+        /*
+        ** If the alternate value (setup_ptr->VALUE & 0x00FF) differs
+        ** from the current alternate value for the specified interface,
+        ** then endpoints must be reconfigured to match the new alternate
+        */
+        if (USB_IF_ALT[setup_ptr->INDEX & 0x00FF]
+                        != (setup_ptr->VALUE & 0x00FF))
+        {
+            USB_IF_ALT[setup_ptr->INDEX & 0x00FF] = (setup_ptr->VALUE & 0x00FF);
+            /* Reconfigure endpoints here. */
+
+        } /* Endif */
+
+        /* status phase */
+        _usb_device_send_data(handle, 0, 0, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SynchFrame
+* Returned Value :
+* Comments       :
+*     Chapter 9 SynchFrame command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SynchFrame
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+
+    uint_16             usbStatus;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP, "usbDisk %s: setup=%d\n",
+                                        __FUNCTION__, (int)setup);
+
+    if (setup)
+    {
+        if (setup_ptr->REQUESTTYPE != (REQ_RECIP_ENDPOINT | REQ_TYPE_STANDARD | REQ_DIR_OUT) )
+        {
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
+                        setup_ptr->REQUESTTYPE);
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+        } /* Endif */
+
+        if ((setup_ptr->INDEX & 0x00FF) >=
+            pDiskCtrl->ConfigDesc[CONFIG_DESC_NUM_INTERFACES])
+        {
+            USB_printf("usbDisk_%d, %s: Wrong INDEX=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->INDEX);
+            _usb_device_stall_endpoint(handle, 0, ARC_USB_RECV);
+            return;
+        } /* Endif */
+
+        _usb_device_get_status(handle, ARC_USB_STATUS_SOF_COUNT, &usbStatus);
+        pDiskCtrl->epTemp_buf[0] = USB_uint_16_low(usbStatus);
+        pDiskCtrl->epTemp_buf[1] = USB_uint_16_high(usbStatus);
+        _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, MIN(setup_ptr->LENGTH, sizeof(uint_16)));
+        /* status phase */
+        _usb_device_recv_data(handle, 0, NULL, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9Class
+* Returned Value :
+* Comments       :
+*     Chapter 9 Class specific request
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9Class
+   (
+      _usb_device_handle handle,
+      boolean setup,
+      uint_8  direction,
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_CLASS,
+                "usbDisk %s: setup=%d, request=0x%x, value=%d, index=%d, size=%d\n",
+                __FUNCTION__, (int)setup, setup_ptr->REQUEST,
+                setup_ptr->VALUE, setup_ptr->INDEX, setup_ptr->LENGTH);
+
+    if (setup)
+    {
+        switch (setup_ptr->REQUEST)
+        {
+            case 0xFF:
+                /* Bulk-Only Mass Storage Reset: Ready the device for the next
+                ** CBW from the host
+                */
+                if ((setup_ptr->VALUE != 0) ||
+                    (setup_ptr->INDEX != MASS_STORAGE_INTERFACE) ||
+                    (setup_ptr->LENGTH != 0))
+                {
+                    USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE,
+                        setup_ptr->INDEX, setup_ptr->LENGTH);
+
+                    _usb_device_stall_endpoint(handle, 0, 0);
+                }
+                else
+                { /* Body */
+                    pDiskCtrl->CBW_PROCESSED = FALSE;
+                    pDiskCtrl->ZERO_TERMINATE = FALSE;
+                    _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+                    _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
+
+                    /* unstall bulk endpoint */
+                    _usb_device_unstall_endpoint(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+                    _usb_device_unstall_endpoint(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
+
+                    _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+                    /* send zero packet to control pipe */
+                    _usb_device_send_data(handle, 0, NULL, 0);
+                } /* Endbody */
+                break;
+
+            case 0xFE:
+                /* For Get Max LUN use any of these responses*/
+                if (setup_ptr->LENGTH == 0)
+                { /* Body */
+
+                    USB_printf("usbDisk_%d, %s: Wrong Length: LENGTH=%d\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->LENGTH);
+
+                    _usb_device_stall_endpoint(handle, 0, 0);
+                }
+                else
+                {
+                    if ((setup_ptr->VALUE != 0) ||
+                        (setup_ptr->INDEX != MASS_STORAGE_INTERFACE) ||
+                        (setup_ptr->LENGTH != 1))
+                    { /* Body */
+                        USB_printf("usbDisk_%d, %s: Wrong Setup: VALUE=%d, INDEX=%d, LENGTH=%d\n",
+                                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE,
+                                    setup_ptr->INDEX, setup_ptr->LENGTH);
+                        _usb_device_stall_endpoint(handle, 0, 0);
+                    }
+                    else
+                    { /* Body */
+                        /* Send Max LUN = 0 to the the control pipe */
+                        *pDiskCtrl->epTemp_buf = 0;
+                        _usb_device_send_data(handle, 0, pDiskCtrl->epTemp_buf, 1);
+                        /* status phase */
+                        _usb_device_recv_data(handle, 0, 0, 0);
+                    } /* Endbody */
+                }
+                break;
+
+            default :
+                USB_printf("usbDisk_%d, %s: Wrong REQUEST=0x%02x\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->REQUEST);
+                _usb_device_stall_endpoint(handle, 0, 0);
+                return;
+        } /* EndSwitch */
+    }
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_ep0
+* Returned Value : None
+* Comments       :
+*     Called upon a completed endpoint 0 (USB 1.1 Chapter 9) transfer
+*
+*END*--------------------------------------------------------------------*/
+static void service_ep0
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Is it a setup packet? */
+      boolean              setup,
+
+      /* [IN] Direction of the transfer.  Is it transmit? */
+      uint_8               direction,
+
+      /* [IN] Pointer to the data buffer */
+      uint_8_ptr           buffer,
+
+      /* [IN] Length of the transfer */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+    SETUP_STRUCT*       pSetupPacket = &pDiskCtrl->local_setup_packet;
+
+   if (setup)
+   {
+      _usb_device_read_setup_data(handle, 0, (uint_8_ptr)pSetupPacket);
+        pSetupPacket->VALUE = USB_16BIT_LE(pSetupPacket->VALUE);
+        pSetupPacket->INDEX = USB_16BIT_LE(pSetupPacket->INDEX);
+        pSetupPacket->LENGTH = USB_16BIT_LE(pSetupPacket->LENGTH);
+   }
+
+   ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_EP0,
+              "disk %s: setup=%s, dir=%s, pBuf=0x%x, length=%d, reqType=0x%x, req=0x%x\n",
+                    __FUNCTION__, (setup ? "YES" : "NO"),
+                    (direction == ARC_USB_RECV) ? "RECV" : "SEND",
+                    (unsigned)buffer, (int)length, pSetupPacket->REQUESTTYPE,
+                    pSetupPacket->REQUEST);
+
+   switch (pSetupPacket->REQUESTTYPE & REQ_TYPE_MASK)
+   {
+      case REQ_TYPE_STANDARD:
+         switch (pSetupPacket->REQUEST)
+         {
+            case REQ_GET_STATUS:
+               mvUsbCh9GetStatus(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_CLEAR_FEATURE:
+               mvUsbCh9ClearFeature(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SET_FEATURE:
+               mvUsbCh9SetFeature(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SET_ADDRESS:
+               mvUsbCh9SetAddress(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_GET_DESCRIPTOR:
+               ch9GetDescription(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SET_DESCRIPTOR:
+               ch9SetDescription(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_GET_CONFIGURATION:
+               ch9GetConfig(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SET_CONFIGURATION:
+               ch9SetConfig(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_GET_INTERFACE:
+               ch9GetInterface(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SET_INTERFACE:
+               ch9SetInterface(handle, setup, pSetupPacket);
+               break;
+
+            case REQ_SYNCH_FRAME:
+               ch9SynchFrame(handle, setup, pSetupPacket);
+               break;
+
+            default:
+                USB_printf("usbDisk_%d, %s: Wrong REQUEST = 0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, pSetupPacket->REQUEST);
+               _usb_device_stall_endpoint(handle, 0, 0);
+               break;
+
+         } /* Endswitch */
+
+         break;
+
+      case REQ_TYPE_CLASS:
+         /* class specific request */
+         ch9Class(handle, setup, direction, pSetupPacket);
+         return;
+
+      case REQ_TYPE_VENDOR:
+         /* vendor specific request can be handled here*/
+         USB_printf("usbDisk_%d, %s: Vendor REQUESTTYPE (%d) not supported\n",
+               _usb_device_get_dev_num(handle), __FUNCTION__, REQ_TYPE_VENDOR);
+
+         _usb_device_stall_endpoint(handle, 0, 0);
+         break;
+
+      default:
+         USB_printf("usbDisk_%d, %s: Unexpected REQUESTTYPE = 0x%x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__,
+                pSetupPacket->REQUESTTYPE);
+
+         _usb_device_stall_endpoint(handle, 0, 0);
+         break;
+
+   } /* Endswitch */
+
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_inquiry_command
+* Returned Value : None
+* Comments       :
+*     Process a Mass storage class Inquiry command
+*
+*END*--------------------------------------------------------------------*/
+void _process_inquiry_command
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    if (cbw_ptr->DCBWDATALENGTH)
+    {
+        if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+        {
+            /* Send the device information */
+            _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)&device_information_data, 36);
+        } /* Endif */
+    } /* Endif */
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
+    pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - 36);
+    pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_unsupported_command
+* Returned Value : None
+* Comments       :
+*     Responds appropriately to unsupported commands
+*
+*END*--------------------------------------------------------------------*/
+void _process_unsupported_command
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK,
+                    "disk unsupported command: BMCBWFLAGS = 0x%02x\n", cbw_ptr->BMCBWFLAGS);
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
+    pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+    pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
+        /* Send a zero-length packet */
+        _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)NULL, 0);
+    }
+    else
+    {
+        pDiskCtrl->CBW_PROCESSED = FALSE;
+        /* Send the command status information */
+        _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+        _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+    } /* Endif */
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_report_capacity
+* Returned Value : None
+* Comments       :
+*     Reports the media capacity as a response to READ CAPACITY Command.
+*
+*END*--------------------------------------------------------------------*/
+void _process_report_capacity
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_CAP,
+                    "disk read_capacity: BMCBWFLAGS = 0x%02x\n", cbw_ptr->BMCBWFLAGS);
+
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
+        /* Send a zero-length packet */
+        _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pReadCapacity, 8);
+
+    } /* Endif */
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
+    pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+    pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_read_command
+* Returned Value : None
+* Comments       :
+*     Sends data as a response to READ Command.
+*
+*END*--------------------------------------------------------------------*/
+void _process_read_command
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    uint_32             index1 = 0, index2 = 0;
+    uint_32             max_pkt_size, byteSize;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    if (cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT)
+    {
+      /* Send a zero-length packet */
+      index1  = ((uint_32)cbw_ptr->CBWCB[4] << 8);
+      index1  |= cbw_ptr->CBWCB[5];
+      index2 = ((uint_32)cbw_ptr->CBWCB[7] << 8);
+      index2 |= (uint_32)cbw_ptr->CBWCB[8];
+
+      ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_READ,
+                    "disk read: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n",
+                    cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH, index1, index2);
+
+      if(cbw_ptr->CBWCB[0] != 0x3E)
+      {
+          byteSize = index2 * LENGTH_OF_EACH_LAB;
+      }
+      else
+      {
+          byteSize = index2;
+          index2 = (USB_MEM_ALIGN(byteSize, LENGTH_OF_EACH_LAB) / LENGTH_OF_EACH_LAB);
+      }
+
+      /* Check index validities */
+      if( (index1 + index2) >= pDiskCtrl->logicalBlocks)
+      {
+          USB_printf("USB disk read: invalid indexes - addr=%d, size=%d\n",
+                        index1, index2);
+          pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+          pDiskCtrl->pCSW->BCSWSTATUS = 1;
+          /* Send zero size packet */
+          _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)NULL, 0);
+          return;
+      }
+
+      if (cbw_ptr->DCBWDATALENGTH == 0)
+      { /* Body */
+         pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+         pDiskCtrl->pCSW->BCSWSTATUS = 2;
+         pDiskCtrl->CBW_PROCESSED = FALSE;
+         /* Send the command status information */
+         _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+         _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+         return;
+      }
+      else
+      { /* Body */
+         pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+         pDiskCtrl->pCSW->BCSWSTATUS = 0;
+         if (byteSize > cbw_ptr->DCBWDATALENGTH)
+         { /* Body */
+            byteSize = cbw_ptr->DCBWDATALENGTH;
+            pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+            pDiskCtrl->pCSW->BCSWSTATUS = 2;
+         }
+         else
+         {
+            if (byteSize < cbw_ptr->DCBWDATALENGTH)
+            { /* Body */
+                pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - index2);
+                if (byteSize > 0)
+                { /* Body */
+                    if (pDiskCtrl->speed == ARC_USB_SPEED_HIGH)
+                    {
+                        max_pkt_size = pDiskCtrl->hsMaxPktSize;
+                    }
+                    else
+                    {
+                        max_pkt_size = pDiskCtrl->fsMaxPktSize;
+                    }
+
+                    if( (byteSize % max_pkt_size) == 0)
+                    { /* Body */
+                        /* Need send a zero terminate packet to host */
+                        pDiskCtrl->ZERO_TERMINATE = TRUE;
+                    } /* Endbody */
+                } /* Endbody */
+            } /* Endbody */
+         }
+
+         _usb_device_send_data(handle, pDiskCtrl->inEpNo,
+            pDiskCtrl->MASS_STORAGE_DISK + (index1*LENGTH_OF_EACH_LAB), byteSize);
+      } /* Endbody */
+   }
+   else
+   { /* Body */
+      USB_printf("disk read incorrect: FLAGS=0x%02x, LENGTH=0x%x\n",
+                    cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
+
+      /* Incorrect but valid CBW */
+      if (cbw_ptr->DCBWDATALENGTH > BUFFERSIZE)
+         byteSize = BUFFERSIZE;
+      else
+         byteSize = cbw_ptr->DCBWDATALENGTH;
+
+      pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+      pDiskCtrl->pCSW->BCSWSTATUS = 2;
+       _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, index2);
+   } /* Endbody */
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_write_command
+* Returned Value : None
+* Comments       :
+*     Sends data as a response to WRITE Command.
+*
+*END*--------------------------------------------------------------------*/
+void _process_write_command
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    uint_32             index1 = 0, index2 = 0;
+    uint_32             byteSize;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    if (!(cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT))
+    {
+        index1  = ((uint_32)cbw_ptr->CBWCB[4] << 8);
+        index1  |= cbw_ptr->CBWCB[5];
+        index2 = ((uint_32)cbw_ptr->CBWCB[7] << 8);
+        index2 |= (uint_32)cbw_ptr->CBWCB[8];
+
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_WRITE,
+                      "disk write: FLAGS=0x%02x, LENGTH=0x%x, index1=0x%x, index2=0x%x\n",
+                      cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH, index1, index2);
+
+        if(cbw_ptr->CBWCB[0] != 0x3F)
+        {
+            byteSize = index2 * LENGTH_OF_EACH_LAB;
+        }
+        else
+        {
+            byteSize = index2;
+            index2 = (USB_MEM_ALIGN(byteSize, LENGTH_OF_EACH_LAB) / LENGTH_OF_EACH_LAB);
+        }
+
+        /* Check index validities */
+        if( (index1 + index2) >= pDiskCtrl->logicalBlocks)
+        {
+            USB_printf("USB disk write: invalid indexes - addr=%d, size=%d\n",
+                          index1, index2);
+            pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+            pDiskCtrl->pCSW->BCSWSTATUS = 1;
+            pDiskCtrl->CBW_PROCESSED = FALSE;
+            /* Send the command status information */
+            _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+            _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+            return;
+        }
+
+        if (cbw_ptr->DCBWDATALENGTH == 0)
+        { /* Body */
+            /* Zero transfer length */
+            pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+            pDiskCtrl->pCSW->BCSWSTATUS = 2;
+            pDiskCtrl->CBW_PROCESSED = FALSE;
+
+            /* Send the command status information */
+            _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+
+            _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+            return;
+        }
+        else
+        { /* Body */
+            pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+            pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+            if (byteSize < cbw_ptr->DCBWDATALENGTH)
+            { /* Body */
+                /* The actual length will never exceed the DCBWDATALENGTH */
+                pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH - byteSize);
+                byteSize = cbw_ptr->DCBWDATALENGTH;
+            }
+            else if (byteSize > cbw_ptr->DCBWDATALENGTH)
+            { /* Body */
+                pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+                pDiskCtrl->pCSW->BCSWSTATUS = 2;
+                byteSize = cbw_ptr->DCBWDATALENGTH;
+            } /* Endbody */
+
+            if (_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) != USB_OK)
+            {
+                _usb_device_cancel_transfer(handle, ep_num, ARC_USB_RECV);
+            } /* Endif */
+
+            _usb_device_recv_data(handle, pDiskCtrl->outEpNo,
+                    pDiskCtrl->MASS_STORAGE_DISK + (index1*LENGTH_OF_EACH_LAB), byteSize);
+        }
+    }
+    else
+    { /* Body */
+        USB_printf("disk write incorrect: FLAGS=0x%02x, LENGTH=0x%x\n",
+                    cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
+
+        /* Incorrect but valid CBW */
+        pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+        pDiskCtrl->pCSW->BCSWSTATUS = 2;
+        _usb_device_send_data(handle, pDiskCtrl->inEpNo, 0, 0);
+        return;
+    } /* Endbody */
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_test_unit_ready
+* Returned Value : None
+* Comments       :
+*     Responds appropriately to unit ready query
+*
+*END*--------------------------------------------------------------------*/
+void _process_test_unit_ready
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    uint_32             bufSize;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    if ((cbw_ptr->BMCBWFLAGS & USB_CBW_DIRECTION_BIT) ||
+        (cbw_ptr->DCBWDATALENGTH == 0))
+    {
+        /* The actual length will never exceed the DCBWDATALENGTH */
+        pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+        pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+        pDiskCtrl->CBW_PROCESSED = FALSE;
+
+        /* Send the command status information */
+        _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+        _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+    }
+    else
+    { /* Body */
+      /* Incorrect but valid CBW */
+        if (cbw_ptr->DCBWDATALENGTH > BUFFERSIZE)
+            bufSize = BUFFERSIZE;
+        else
+            bufSize = cbw_ptr->DCBWDATALENGTH;
+
+        pDiskCtrl->pCSW->DCSWDATARESIDUE = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+        pDiskCtrl->pCSW->BCSWSTATUS = 1;
+        _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, bufSize);
+    } /* Endbody */
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_prevent_allow_medium_removal
+* Returned Value : None
+* Comments       :
+*     Responds appropriately to unit ready query
+*
+*END*--------------------------------------------------------------------*/
+void _process_prevent_allow_medium_removal
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    /* The actual length will never exceed the DCBWDATALENGTH */
+    pDiskCtrl->pCSW->DCSWDATARESIDUE = 0;
+    pDiskCtrl->pCSW->BCSWSTATUS = 0;
+
+    pDiskCtrl->CBW_PROCESSED = FALSE;
+
+    /* Send the command status information */
+    _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+    _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : _process_mass_storage_command
+* Returned Value : None
+* Comments       :
+*     Process a Mass storage class command
+*
+*END*--------------------------------------------------------------------*/
+void _process_mass_storage_command
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Endpoint number */
+      uint_8               ep_num,
+
+      /* [IN] Pointer to the data buffer */
+      CBW_STRUCT_PTR       cbw_ptr
+   )
+{ /* Body */
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK,
+                    "disk command: CBWCB[0]=0x%02x, FLAGS=0x%02x, LENGTH=0x%x\n",
+                    cbw_ptr->CBWCB[0], cbw_ptr->BMCBWFLAGS, cbw_ptr->DCBWDATALENGTH);
+
+   switch (cbw_ptr->CBWCB[0])
+   {
+      case 0x00: /* Request the device to report if it is ready */
+         _process_test_unit_ready(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x12: /* Inquity command. Get device information */
+         _process_inquiry_command(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x1A:
+         _process_unsupported_command(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x1E: /* Prevent or allow the removal of media from a removable media device */
+         _process_prevent_allow_medium_removal(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x23: /* Read Format Capacities. Report current media capacity and
+                 ** formattable capacities supported by media
+                  */
+         /* We bahave like already installed medium. No need to send any data */
+         _process_unsupported_command(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x25: /* Report current media capacity */
+         _process_report_capacity(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x28: /* Read (10) Transfer binary data from media to the host */
+      case 0x3E:
+          _process_read_command(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x2A: /* Write (10) Transfer binary data from the host to the media */
+      case 0x3F:
+         _process_write_command(handle, ep_num, cbw_ptr);
+         break;
+
+      case 0x01: /* Position a head of the drive to zero track */
+      case 0x03: /* Transfer status sense data to the host */
+      case 0x04: /* Format unformatted media */
+      case 0x1B: /* Request a request a removable-media device to load or
+                 ** unload its media
+                 */
+      case 0x1D: /* Perform a hard reset and execute diagnostics */
+      case 0x2B: /* Seek the device to a specified address */
+      case 0x2E: /* Transfer binary data from the host to the media and
+                 ** verify data
+                 */
+      case 0x2F: /* Verify data on the media */
+      case 0x55: /* Allow the host to set parameters in a peripheral */
+      case 0x5A: /* Report parameters to the host */
+      case 0xA8: /* Read (12) Transfer binary data from the media to the host */
+      case 0xAA: /* Write (12) Transfer binary data from the host to the
+                 ** media
+                 */
+      default:
+         _process_unsupported_command(handle, ep_num, cbw_ptr);
+         break;
+   } /* Endswitch */
+
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_ep1
+* Returned Value : None
+* Comments       :
+*     Called upon a completed endpoint 1 (USB 1.1 Chapter 9) transfer
+*
+*END*--------------------------------------------------------------------*/
+static void service_ep1
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] Service type as registered */
+      uint_8               type,
+
+      /* [IN] Is it a setup packet? */
+      boolean              setup,
+
+      /* [IN] Direction of the transfer.  Is it transmit? */
+      uint_8               direction,
+
+      /* [IN] Pointer to the data buffer */
+      uint_8_ptr           buffer,
+
+      /* [IN] Length of the transfer */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+    CBW_STRUCT_PTR cbw_ptr = (CBW_STRUCT_PTR)((pointer)buffer);
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_EP1,
+                    "disk %s: ep=%d, dir=%s, pBuf=0x%x, length=%d, error=0x%x\n",
+                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND",
+                    (unsigned)buffer, (int)length, error);
+
+    if ((!direction) && (!pDiskCtrl->CBW_PROCESSED) && (length == 31) &&
+        (cbw_ptr->DCBWSIGNATURE == USB_32BIT_LE(USB_DCBWSIGNATURE)))
+    {
+        /* A valid CBW was received */
+        pDiskCtrl->pCSW->DCSWSIGNATURE = USB_32BIT_LE(USB_DCSWSIGNATURE);
+        pDiskCtrl->pCSW->DCSWTAG = cbw_ptr->DCBWTAG;
+        pDiskCtrl->CBW_PROCESSED = TRUE;
+
+        /* Swap 32 bit fields if neccessary */
+        cbw_ptr->DCBWDATALENGTH = USB_32BIT_LE(cbw_ptr->DCBWDATALENGTH);
+
+        /* Process the command */
+        _process_mass_storage_command(handle, type, cbw_ptr);
+    }
+    else
+    {
+        /* If a CBW was processed then send the status information and
+        ** queue another cbw receive request, else just queue another CBW receive
+        ** request if we received an invalid CBW
+        */
+        if (pDiskCtrl->CBW_PROCESSED)
+        {
+            int     i;
+
+            ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DATA,
+                    "disk %s: ep=%d, dir=%s, pBuf=0x%x, length=%d, error=0x%x\n",
+                    __FUNCTION__, type, (direction == ARC_USB_RECV) ? "RECV" : "SEND",
+                    (unsigned)buffer, (int)length, error);
+
+            for(i=0; i<64; i++)
+            {
+                if( (i % 16) == 0)
+                {
+                    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, "\n0x%08x: ", &buffer[i]);
+                }
+                ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, "%02x ", buffer[i]);
+                if( (i % 3) == 0)
+                    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_DISK_DUMP, " ");
+            }
+
+            if (pDiskCtrl->ZERO_TERMINATE)
+            { /* Body */
+                pDiskCtrl->ZERO_TERMINATE = FALSE;
+                _usb_device_send_data(handle, pDiskCtrl->inEpNo, 0, 0);
+            }
+            else
+            { /* Body */
+                pDiskCtrl->CBW_PROCESSED = FALSE;
+
+                /* Send the command status information */
+                _usb_device_send_data(handle, pDiskCtrl->inEpNo, (uint_8_ptr)pDiskCtrl->pCSW, 13);
+                _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+            }
+        }
+        else
+        {
+            if (!direction)
+            {
+                USB_printf("usbDisk_%d, %s: Wrong direction = %d\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, direction);
+                _usb_device_stall_endpoint(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+                _usb_device_stall_endpoint(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
+
+                /* Invalid CBW received. Queue another receive buffer */
+                _usb_device_recv_data(handle, pDiskCtrl->outEpNo, pDiskCtrl->ep1_buf, 31);
+            }
+        } /* Endif */
+    } /* Endif */
+
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_speed
+* Returned Value : None
+* Comments       :
+*     Called upon a speed detection event.
+*
+*END*--------------------------------------------------------------------*/
+static void service_speed
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Unused */
+      boolean              setup,
+
+      /* [IN] Unused */
+      uint_8               direction,
+
+      /* [IN] Unused */
+      uint_8_ptr           buffer,
+
+      /* [IN] Unused */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+   )
+{ /* EndBody */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SPEED, "disk %s: speed = %d\n", __FUNCTION__, (unsigned)length);
+
+    pDiskCtrl->speed = length;
+    return;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : reset_ep0
+* Returned Value : None
+* Comments       :
+*     Called upon a bus reset event.  Initialises the control endpoint.
+*
+*END*--------------------------------------------------------------------*/
+static void reset_ep0
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Unused */
+      boolean              setup,
+
+      /* [IN] Unused */
+      uint_8               direction,
+
+      /* [IN] Unused */
+      uint_8_ptr           buffer,
+
+      /* [IN] Unused */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+   )
+{ /* Body */
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk-%d %s: pDiskCtrl=%p, handle=%p\n",
+                    devNo, __FUNCTION__, pDiskCtrl, handle);
+
+    /* on a reset always ensure all transfers are cancelled on control EP*/
+    _usb_device_cancel_transfer(handle, 0, ARC_USB_RECV);
+    _usb_device_cancel_transfer(handle, 0, ARC_USB_SEND);
+
+    _usb_device_start(handle);
+    /* Initialize the endpoint 0 in both directions */
+    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE],
+                                ARC_USB_RECV, ARC_USB_CONTROL_ENDPOINT, 0);
+    _usb_device_init_endpoint(handle, 0, pDiskCtrl->DevDesc[DEV_DESC_MAX_PACKET_SIZE],
+                                ARC_USB_SEND, ARC_USB_CONTROL_ENDPOINT, 0);
+
+
+    if (pDiskCtrl->TEST_ENABLED)
+    {
+        int out_ep_count=0, in_ep_count=0;
+
+        while(_usb_device_get_transfer_status(handle, pDiskCtrl->outEpNo, ARC_USB_RECV) !=
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            out_ep_count++;
+            _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+        }
+        while(_usb_device_get_transfer_status(handle, pDiskCtrl->inEpNo, ARC_USB_SEND) !=
+                                                    ARC_USB_STATUS_IDLE)
+        {
+            in_ep_count++;
+            _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
+        }
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_RESET, "disk %s: out_ep_count=%d, in_ep_count=%d\n",
+                        __FUNCTION__, out_ep_count, in_ep_count);
+    } /* Endif */
+
+    pDiskCtrl->TEST_ENABLED = FALSE;
+
+    return;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : usbDiskLoad - main task
+* Inputs:
+*   int diskSize  - size of created disk in KBytes
+* Returned Value : None
+* Comments       :
+*     First function called.  Initialises the USB and registers Chapter 9
+*     callback functions.
+*
+*END*--------------------------------------------------------------------*/
+_usb_device_handle  usbDiskLoad(int devNo, int diskSize)
+{ /* Body */
+    _usb_device_handle  handle;
+    USB_DISK_STRUCT*    pDiskCtrl;
+    uint_8_ptr          Send_Buffer_aligned;
+    uint_8              error;
+    uint_32             send_data_buffer_size=0;
+    uint_8_ptr          temp;
+    int                 lockKey, i, j;
+    static boolean      isFirst = TRUE;
+
+    ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_INIT, "%s: devNo=%d, diskSize=%d\n",
+                        __FUNCTION__, devNo, diskSize);
+
+    if(devNo >= MAX_USB_DEVICES)
+    {
+        USB_printf("USB disk: devNo=%d too large\n", devNo);
+        return NULL;
+    }
+
+    /*lock interrupts */
+    lockKey = USB_lock();
+
+    if(isFirst)
+    {
+        for(i=0; i<MAX_USB_DEVICES; i++)
+        {
+            usbDisksPtr[i] = NULL;
+        }
+        /* Swap all USB_STRING_DESC */
+        for(i=0; i<(sizeof(USB_STRING_DESC)/sizeof(USB_STRING_DESC[0])); i++)
+        {
+            uint_16* usbStr = (uint_16*)(USB_STRING_DESC[i]);
+            uint_16 size = (usbStr[0]-0x300)/sizeof(uint_16);
+
+            for(j=0; j<size; j++)
+            {
+                usbStr[j] = USB_16BIT_LE(usbStr[j]);
+            }
+        }
+        isFirst = FALSE;
+    }
+
+    if(usbDisksPtr[devNo] != NULL)
+    {
+        USB_printf("USB disk: devNo=%d is busy\n", devNo);
+        USB_unlock(lockKey);
+        return NULL;
+    }
+
+    /* Allocate Disk control structure */
+    pDiskCtrl = USB_memalloc(sizeof(USB_DISK_STRUCT));
+    if(pDiskCtrl == NULL)
+    {
+        USB_printf("USB disk #%d: Can't allocate USB_DISK_STRUCT (%d bytes)\n",
+                    devNo, sizeof(USB_DISK_STRUCT));
+        USB_unlock(lockKey);
+        return NULL;
+    }
+    USB_memzero(pDiskCtrl, sizeof(USB_DISK_STRUCT));
+
+    if(diskSize == 0)
+        pDiskCtrl->logicalBlocks = TOTAL_LOGICAL_ADDRESS_BLOCKS;
+    else
+        pDiskCtrl->logicalBlocks = (diskSize*1024)/LENGTH_OF_EACH_LAB;
+
+    if(pDiskCtrl->logicalBlocks < 16)
+    {
+        USB_printf("USB disk size (%d) is too small. Minimum is 8 Kbytes\n",
+                    diskSize);
+        USB_unlock(lockKey);
+        return NULL;
+    }
+
+    pDiskCtrl->devNo = devNo;
+    pDiskCtrl->hsMaxPktSize = diskHsMaxPktSize;
+    pDiskCtrl->fsMaxPktSize = diskFsMaxPktSize;
+
+    pDiskCtrl->inEpType     = diskInEpType;
+    pDiskCtrl->outEpType    = diskOutEpType;
+
+    pDiskCtrl->inEpNo       = diskInEpNo;
+    pDiskCtrl->outEpNo      = diskOutEpNo;
+
+    /* Initialize the USB interface */
+    error = _usb_device_init(devNo, &handle);
+    if (error != USB_OK)
+    {
+        USB_unlock(lockKey);
+        USB_printf("\nUSB Initialization failed. Error: %x", error);
+        return NULL;
+    } /* Endif */
+
+    /* Self Power, Remote wakeup disable */
+    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_EP0, service_ep0);
+    if (error != USB_OK)
+    {
+        USB_unlock(lockKey);
+        USB_printf("\nUSB Service Registration failed. Error: %x", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_BUS_RESET, reset_ep0);
+    if (error != USB_OK)
+    {
+        USB_unlock(lockKey);
+        USB_printf("\nUSB Service Registration failed. Error: %x", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_SPEED_DETECTION,
+                                                        service_speed);
+    if (error != USB_OK)
+    {
+        USB_unlock(lockKey);
+        USB_printf("\nUSB Service Registration failed. Error: %x", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, pDiskCtrl->outEpNo, service_ep1);
+    if (error != USB_OK)
+    {
+        USB_unlock(lockKey);
+        USB_printf("\nUSB Service Registration failed. Error: %x", error);
+        return NULL;
+    } /* Endif */
+
+    if(pDiskCtrl->outEpNo != pDiskCtrl->inEpNo)
+    {
+        error = _usb_device_register_service(handle, pDiskCtrl->inEpNo, service_ep1);
+        if (error != USB_OK)
+        {
+            USB_unlock(lockKey);
+            USB_printf("\nUSB Service Registration failed. Error: %x", error);
+            return NULL;
+        } /* Endif */
+    }
+
+    /**************************************************************************
+    Best way to handle the Data cache is to allocate a large buffer that is
+    cache aligned and keep all data inside it. Flush the line of the cache
+    that you have changed. In this program, we have static data such as
+    descriptors which never changes. Such data can be kept in this buffer
+    and flushed only once. Note that you can reduce the size of this buffer
+    by aligning the addresses in a different way.
+    ***************************************************************************/
+    send_data_buffer_size =  (DEVICE_DESCRIPTOR_SIZE +  PSP_CACHE_LINE_SIZE) +
+                            (CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
+                            (DEVICE_QUALIFIER_DESCRIPTOR_SIZE + PSP_CACHE_LINE_SIZE) +
+                            (OTHER_SPEED_CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
+                            (BUFFERSIZE + PSP_CACHE_LINE_SIZE) +
+                            (EP_TEMP_BUFFERSIZE + PSP_CACHE_LINE_SIZE) +
+                            (sizeof(DISK_READ_CAPACITY) + PSP_CACHE_LINE_SIZE) +
+                            (sizeof(CSW_STRUCT) + PSP_CACHE_LINE_SIZE) +
+                            (pDiskCtrl->logicalBlocks*LENGTH_OF_EACH_LAB + PSP_CACHE_LINE_SIZE);
+
+    pDiskCtrl->Send_Buffer_Unaligned   = (uint_8_ptr) USB_memalloc(send_data_buffer_size);
+    if (pDiskCtrl->Send_Buffer_Unaligned == NULL)
+    {
+        USB_unlock(lockKey);
+        USB_printf("diskLoad: Buffer allocation of %d bytes is failed\n",
+                    (unsigned)send_data_buffer_size);
+        return NULL;
+    }
+
+    Send_Buffer_aligned = (uint_8_ptr) USB_CACHE_ALIGN((uint_32)pDiskCtrl->Send_Buffer_Unaligned);
+    /* keep a temporary copy of the aligned address */
+    temp = Send_Buffer_aligned;
+
+    /**************************************************************************
+    Assign pointers to different buffers from it and copy data inside.
+    ***************************************************************************/
+    pDiskCtrl->DevDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(DevDescData, pDiskCtrl->DevDesc, DEVICE_DESCRIPTOR_SIZE);
+    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    pDiskCtrl->ConfigDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(ConfigDescData, pDiskCtrl->ConfigDesc, CONFIG_DESC_SIZE);
+    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    pDiskCtrl->DevQualifierDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(DevQualifierDescData, pDiskCtrl->DevQualifierDesc, DEVICE_QUALIFIER_DESCRIPTOR_SIZE);
+    Send_Buffer_aligned += ((DEVICE_QUALIFIER_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
+
+    pDiskCtrl->other_speed_config =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(other_speed_config_data, pDiskCtrl->other_speed_config, OTHER_SPEED_CONFIG_DESC_SIZE);
+    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    /*buffer to receive data from Bulk OUT */
+    pDiskCtrl->ep1_buf =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memzero(pDiskCtrl->ep1_buf, BUFFERSIZE);
+    Send_Buffer_aligned += ((BUFFERSIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    /*buffer for control endpoint to send data */
+    pDiskCtrl->epTemp_buf =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memzero(pDiskCtrl->epTemp_buf, EP_TEMP_BUFFERSIZE);
+
+    Send_Buffer_aligned += ((EP_TEMP_BUFFERSIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    /* Buffer for read Capacity message */
+    pDiskCtrl->pReadCapacity = (DISK_READ_CAPACITY*)Send_Buffer_aligned;
+    USB_memcopy((void*)&read_capacity, pDiskCtrl->pReadCapacity, sizeof(DISK_READ_CAPACITY));
+
+    /* Update read_capacity */
+    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[2] =
+                            USB_uint_16_high(pDiskCtrl->logicalBlocks-14);
+    pDiskCtrl->pReadCapacity->LAST_LOGICAL_BLOCK_ADDRESS[3] =
+                            USB_uint_16_low(pDiskCtrl->logicalBlocks-14);
+
+    Send_Buffer_aligned += ((sizeof(DISK_READ_CAPACITY)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
+
+    /* Buffer for CSW message */
+    pDiskCtrl->pCSW = (CSW_STRUCT*)Send_Buffer_aligned;
+    USB_memzero(pDiskCtrl->pCSW , sizeof(CSW_STRUCT));
+
+    Send_Buffer_aligned += ((sizeof(CSW_STRUCT)/PSP_CACHE_LINE_SIZE) + 1) * PSP_CACHE_LINE_SIZE;
+
+    /*buffer for storage disk */
+    pDiskCtrl->MASS_STORAGE_DISK = (uint_8_ptr)Send_Buffer_aligned;
+
+    USB_printf("usbDisk-%d: pDiskCtrl=%p, %d bytes allocated addr=0x%x\n",
+                 devNo, pDiskCtrl, (unsigned)send_data_buffer_size,
+                 (unsigned)pDiskCtrl->Send_Buffer_Unaligned);
+    USB_printf("usbDisk-%d: DevDesc=0x%x, ConfigDesc=0x%x, QualifierDesc=0x%x, otherSpeedDesc=0x%x\n",
+                 devNo, (unsigned)pDiskCtrl->DevDesc, (unsigned)pDiskCtrl->ConfigDesc,
+                 (unsigned)pDiskCtrl->DevQualifierDesc, (unsigned)pDiskCtrl->other_speed_config);
+    USB_printf("usbDisk-%d: ep1_buf=0x%x, epTemp_buf=0x%x, MASS_STORAGE_DISK=0x%x\n",
+                 devNo, (unsigned)pDiskCtrl->ep1_buf, (unsigned)pDiskCtrl->epTemp_buf,
+                 (unsigned)pDiskCtrl->MASS_STORAGE_DISK);
+
+    USB_memzero(pDiskCtrl->MASS_STORAGE_DISK, (pDiskCtrl->logicalBlocks*LENGTH_OF_EACH_LAB));
+
+    /* Format the "disk" */
+    USB_memcopy(BOOT_SECTOR_AREA, pDiskCtrl->MASS_STORAGE_DISK, 512);
+
+    /* Update BOOT Sector "Total Small sectors" field */
+    pDiskCtrl->MASS_STORAGE_DISK[19] = USB_uint_16_low(pDiskCtrl->logicalBlocks);
+    pDiskCtrl->MASS_STORAGE_DISK[20] = USB_uint_16_high(pDiskCtrl->logicalBlocks);
+
+    USB_memcopy((void *)FAT16_SPECIAL_BYTES, pDiskCtrl->MASS_STORAGE_DISK + 512, 3);
+    USB_memcopy((void *)FAT16_SPECIAL_BYTES, pDiskCtrl->MASS_STORAGE_DISK + 512*4, 3);
+
+    /**************************************************************************
+    Flush the cache to ensure main memory is updated.
+    ***************************************************************************/
+    USB_dcache_flush(temp, send_data_buffer_size);
+
+    pDiskCtrl->usbDevHandle = handle;
+    usbDisksPtr[devNo] = pDiskCtrl;
+
+    USB_unlock(lockKey);
+
+    USB_printf("USB Disk is READY: diskSize=%d KBytes, blockSize=%d Bytes, numBlocks=%d\n",
+                diskSize, LENGTH_OF_EACH_LAB, pDiskCtrl->logicalBlocks);
+
+    return pDiskCtrl->usbDevHandle;
+} /* Endbody */
+
+void    usbDiskUnload(_usb_device_handle handle)
+{
+    int                 lockKey;
+    int                 devNo = _usb_device_get_dev_num(handle);
+    USB_DISK_STRUCT*    pDiskCtrl = usbDisksPtr[devNo];
+
+    if(pDiskCtrl == NULL)
+    {
+        USB_printf("USB disk #%d: Disk is not loaded\n", pDiskCtrl->devNo);
+        return;
+    }
+    /*lock interrupts */
+    lockKey = USB_lock();
+
+    /* ensure all transfers are cancelled */
+    _usb_device_cancel_transfer(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+    _usb_device_cancel_transfer(handle, pDiskCtrl->inEpNo,  ARC_USB_SEND);
+
+    /* Stop Endpoints */
+    _usb_device_deinit_endpoint(handle, pDiskCtrl->outEpNo, ARC_USB_RECV);
+    _usb_device_deinit_endpoint(handle, pDiskCtrl->inEpNo, ARC_USB_SEND);
+
+    _usb_device_deinit_endpoint(handle, 0, ARC_USB_RECV);
+    _usb_device_deinit_endpoint(handle, 0, ARC_USB_SEND);
+
+    _usb_device_stop(handle);
+
+    /* Deregister all services */
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_SPEED_DETECTION);
+    _usb_device_unregister_service(handle, pDiskCtrl->outEpNo);
+    if(pDiskCtrl->outEpNo != pDiskCtrl->inEpNo)
+    {
+        _usb_device_unregister_service(handle, pDiskCtrl->inEpNo);
+    }
+
+    _usb_device_shutdown(handle);
+
+    /* Free memory allocated for Disk device */
+    if(pDiskCtrl->Send_Buffer_Unaligned != NULL)
+    {
+        USB_memfree(pDiskCtrl->Send_Buffer_Unaligned);
+    }
+
+    /* Free Control structure */
+    USB_memfree(pDiskCtrl);
+    usbDisksPtr[devNo] = NULL;
+
+    USB_unlock(lockKey);
+}
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.h
new file mode 100644
index 0000000..de44780
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/disk.h
@@ -0,0 +1,86 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __disk_h__
+#define __disk_h__
+
+#define  USB_DCBWSIGNATURE       (0x43425355)
+#define  USB_DCSWSIGNATURE       (0x53425355)
+#define  USB_CBW_DIRECTION_BIT   (0x80)
+
+/* USB Command Block Wrapper */
+typedef struct cbw_struct {
+   uint_32  DCBWSIGNATURE;
+   uint_32  DCBWTAG;
+   uint_32  DCBWDATALENGTH;
+   uint_8   BMCBWFLAGS;
+   /* 4 MSBs bits reserved */
+   uint_8   BCBWCBLUN;
+   /* 3 MSB reserved */
+   uint_8   BCBWCBLENGTH;
+   uint_8   CBWCB[16];
+} CBW_STRUCT, _PTR_ CBW_STRUCT_PTR;
+
+/* USB Command Status Wrapper */
+typedef struct csw_struct {
+   uint_32  DCSWSIGNATURE;
+   uint_32  DCSWTAG;
+   uint_32  DCSWDATARESIDUE;
+   uint_8   BCSWSTATUS;
+} CSW_STRUCT, _PTR_ CSW_STRUCT_PTR;
+
+/* USB Mass storage Inquiry Command */
+typedef struct mass_storage_inquiry {
+   uint_8   OPCODE;
+   uint_8   LUN;
+   uint_8   PAGE_CODE;
+   uint_8   RESERVED1;
+   uint_8   ALLOCATION_LENGTH;
+   uint_8   RESERVED2[7];
+} DISK_INQUIRY, _PTR_ DISK_INQUIRY_PTR;
+
+/* USB Mass storage READ CAPACITY Data */
+typedef struct mass_storage_read_capacity {
+   uint_8   LAST_LOGICAL_BLOCK_ADDRESS[4];
+   uint_8   BLOCK_LENGTH_IN_BYTES[4];
+} DISK_READ_CAPACITY, _PTR_ DISK_READ_CAPACITY_PTR;
+
+/* USB Mass storage Device information */
+typedef struct mass_storage_device_info {
+   uint_8   PERIPHERAL_DEVICE_TYPE;    /* Bits 0-4. All other bits reserved */
+   uint_8   RMB;                       /* Bit 7. All other bits reserved */
+   uint_8   ANSI_ECMA_ISO_VERSION;     /* ANSI: bits 0-2, ECMA: bits 3-5,
+                                       ** ISO: bits 6-7
+                                       */
+   uint_8   RESPONSE_DATA_FORMAT;      /* bits 0-3. All other bits reserved */
+   uint_8   ADDITIONAL_LENGTH;         /* For UFI device: always set to 0x1F */
+   uint_8   RESERVED1[3];
+   uint_8   VENDOR_INFORMATION[8];
+   uint_8   PRODUCT_ID[16];
+   uint_8   PRODUCT_REVISION_LEVEL[4];
+} DISK_DEVICE_INFO, _PTR_ DISK_DEVICE_INFO_PTR;
+
+
+extern _usb_device_handle  usbDiskLoad(int devNo, int diskSize);
+extern void                usbDiskUnload(_usb_device_handle  handle);
+
+#endif /* __disk_h__ */
+
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.c
new file mode 100644
index 0000000..e1f81f6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.c
@@ -0,0 +1,1711 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+/**************************************************************************
+Include the USB stack header files.
+**************************************************************************/
+#ifdef MV_VXWORKS
+#include <vxWorks.h>
+#endif
+#include "usb/api/mvUsbDefs.h"
+#include "usb/api/mvUsbDebug.h"
+#include "usb/api/mvUsbCh9.h"
+#include "usb/api/mvUsbDevApi.h"
+
+#include "usb/examples/mouse.h"
+
+/**************************************************************************
+global variables and some defines for device.
+**************************************************************************/
+
+#define CONTROL_MAX_PACKET_SIZE         (64)
+#define INTERRUPT_MAX_PACKET_SIZE       (0x0008)
+#define DEV_DESC_MAX_PACKET_SIZE        (7)
+#define INTERRUPT_EP                    (1)
+#define FRAME_INTERVAL                  (15)
+
+/**************************************************************************
+Include the OS and BSP dependent files that define IO functions and
+basic types. You may like to change these files for your board and RTOS
+**************************************************************************/
+
+int frame_interval = FRAME_INTERVAL;
+int mouseCntr = 0;
+int mouseDelay = 2;
+
+static volatile boolean TEST_ENABLED = FALSE;
+static volatile boolean USB_SUSPENDED = FALSE;
+
+#define EP1_RECV_BUFFER_SIZE 10
+static uint_8_ptr hid_test_rep_data;
+static uint_8_ptr hid_test_rep_data_unaligned;
+
+/********************************
+Buffers for sending data to stack
+********************************/
+#define EP0_SEND_BUFFER_SIZE 200
+static uint_8_ptr Send_Buffer_Unaligned;
+static uint_8_ptr Send_Buffer_aligned;
+
+static uint_8         data_to_send;
+static uint_16        sof_count;
+static SETUP_STRUCT   local_setup_packet;
+
+
+/*************************************************************************
+Device descriptors are always 18 bytes
+
+Offset|       Field        | Value |  Description
+------|--------------------|-------|--------------------
+  0   |      bLength       |  0x12 |The size of this
+      |                    |       |descriptor is 18 bytes
+------|--------------------|-------|--------------------
+  1   |  bDescriptorType   |  0x01 |DEVICE Descriptor Type
+------|--------------------|-------|--------------------
+  2   |       bcdUSB       | 0x0100|Device compliant to
+      |                    |       |the USB
+      |                    |       |specification
+      |                    |       |version 1.00
+------|--------------------|-------|--------------------
+  4   |    bDeviceClass    |  0x00 |Each interface
+      |                    |       |specifies its own
+      |                    |       |class information
+------|--------------------|-------|--------------------
+  5   |  bDeviceSubClass   |  0x00 |Each interface
+      |                    |       |specifies its own
+      |                    |       |subclass information
+------|--------------------|-------|--------------------
+  6   |  bDeviceProtocol   |  0x00 |No protocols on the
+      |                    |       |device basis
+------|--------------------|-------|--------------------
+  7   |  bMaxPacketSize0   |  0x08 |Maximum packet size
+      |                    |       |for endpoint zero is 8
+------|--------------------|-------|--------------------
+  8   |      idVendor      | 0x0261|Vendor ID is 609:
+      |                    |
+------|--------------------|-------|--------------------
+  10  |     idProduct      | 0x4D03|The Product ID is 0x4D03
+------|--------------------|-------|--------------------
+  12  |     bcdDevice      | 0x0441|The device release
+      |                    |       |number is 4.41
+------|--------------------|-------|--------------------
+  14  |   iManufacturer    |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
+      |                    |       |describing the manufacturer
+------|--------------------|-------|--------------------
+  15  |      iProduct      |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
+      |                    |       |describing the product
+------|--------------------|-------|--------------------
+  16  |   iSerialNumber    |  0x00 |
+------|--------------------|-------|--------------------
+  17  | bNumConfigurations |  0x01 |
+------|--------------------|-------|--------------------
+*************************************************************************/
+#define DEVICE_DESCRIPTOR_SIZE 18
+static uint_8_ptr DevDesc;
+static uint_8  DevDescData[DEVICE_DESCRIPTOR_SIZE] =
+{
+   DEVICE_DESCRIPTOR_SIZE,
+   0x01,
+   0x0,2,
+
+   0x00,
+   0x00,
+   0x00,
+   CONTROL_MAX_PACKET_SIZE,
+   /* Vendor ID = MARVELL */
+   USB_uint_16_low(0x1286), USB_uint_16_high(0x1286),
+   /* Product ID */
+   USB_uint_16_low(0x1), USB_uint_16_high(0x1),
+   /* BCD Device version */
+   USB_uint_16_low(0x0002), USB_uint_16_high(0x0002),
+
+   0x01,                      /* iManufacturer */
+   0x02,                      /* iProduct */
+   0x00,                      /* iSerialNumber */
+   0x01                       /* bNumConfigurations */
+
+};
+
+/* USB 2.0 specific descriptor */
+#define DEVICE_QUALIFIER_DESCRIPTOR_SIZE 10
+static uint_8_ptr DevQualifierDesc;
+static uint_8  DevQualifierDescData[DEVICE_QUALIFIER_DESCRIPTOR_SIZE] =
+{
+   DEVICE_QUALIFIER_DESCRIPTOR_SIZE,  /* bLength Length of this descriptor */
+   6,                         /* bDescType This is a DEVICE Qualifier descr */
+   0,2,                       /* bcdUSB USB revision 2.0 */
+   0,                         /* bDeviceClass */
+   0,                         /* bDeviceSubClass */
+   0,                         /* bDeviceProtocol */
+   CONTROL_MAX_PACKET_SIZE,  /* bMaxPacketSize0 */
+   0x01,                      /* bNumConfigurations */
+   0
+};
+
+
+/*******************************************************************
+   CONFIG DESCRIPTOR
+
+Data stage (34 bytes) :
+------------------------------------
+
+       CONFIGURATION Descriptor
+       ------------------------
+Offset|        Field        | Value |  Description
+------|---------------------|-------|--------------------
+  0   |       bLength       |  0x09 |The size of this
+      |                     |       |descriptor is 9 bytes
+------|---------------------|-------|--------------------
+  1   |   bDescriptorType   |  0x02 |CONFIGURATION
+      |                     |       |Descriptor Type
+------|---------------------|-------|--------------------
+  2   |    wTotalLength     | 0x0022|The total length of
+      |                     |       |data for this
+      |                     |       |configuration is 34.
+      |                     |       |This includes the
+      |                     |       |combined length of
+      |                     |       |all the descriptors returned
+------|---------------------|-------|--------------------
+  4   |   bNumInterfaces    |  0x01 |This configuration
+      |                     |       |supports 1 interfaces
+------|---------------------|-------|--------------------
+  5   | bConfigurationValue |  0x01 |The value 1 should
+      |                     |       |be used to select
+      |                     |       |this configuration
+------|---------------------|-------|--------------------
+  6   |   iConfiguration    |  0x00 |The device doesn't
+      |                     |       |have the string
+      |                     |       |descriptor
+      |                     |       |describing this configuration
+------|---------------------|-------|--------------------
+  7   |    bmAttributes     |  0x80 |Configuration characteristics :
+      |                     |       |Bit 7: Reserved (set to one) 1
+      |                     |       |Bit 6: Self-powered          0
+      |                     |       |Bit 5: Remote Wakeup         1
+------|---------------------|-------|--------------------
+  8   |      MaxPower       |  0x32 |Maximum power
+      |                     |       |consumption of the
+      |                     |       |device in this
+      |                     |       |configuration is 100 mA
+------|---------------------|-------|--------------------
+
+       INTERFACE Descriptor
+       --------------------
+Offset|       Field        | Value |  Description
+------|--------------------|-------|--------------------
+  0   |      bLength       |  0x09 |The size of this
+      |                    |       |descriptor is 9 bytes
+------|--------------------|-------|--------------------
+  1   |  bDescriptorType   |  0x04 |INTERFACE Descriptor Type
+------|--------------------|-------|--------------------
+  2   |  bInterfaceNumber  |  0x00 |The number of this
+      |                    |       |interface is 0
+------|--------------------|-------|--------------------
+  3   | bAlternateSetting  |  0x00 |The value used to
+      |                    |       |select alternate
+      |                    |       |setting for this
+      |                    |       |interface is 0
+------|--------------------|-------|--------------------
+  4   |   bNumEndpoints    |  0x01 |The number of
+      |                    |       |endpoints used by
+      |                    |       |this interface is 1
+      |                    |       |(excluding endpoint zero)
+------|--------------------|-------|--------------------
+  5   |  bInterfaceClass   |  0x03 |The interface
+      |                    |       |implements HID class
+------|--------------------|-------|--------------------
+  6   | bInterfaceSubClass |  0x01 |The subclass code is 0x01
+------|--------------------|-------|--------------------
+  7   | bInterfaceProtocol |  0x02 |The protocol code is 0x02
+------|--------------------|-------|--------------------
+  8   |     iInterface     |  0x00 |The device doesn't
+      |                    |       |have the string
+      |                    |       |descriptor
+      |                    |       |describing this interface
+------|--------------------|-------|--------------------
+
+       HID Descriptor
+       --------------
+Offset|       Field       | Value |  Description
+------|-------------------|-------|--------------------
+  0   |      bLength      |  0x09 |The size of this
+      |                   |       |descriptor is 9 bytes
+------|-------------------|-------|--------------------
+  1   |  bDescriptorType  |  0x21 |HID Descriptor Type
+------|-------------------|-------|--------------------
+  2   |      bcdHID       | 0x0100|Device compliant to
+      |                   |       |the HID
+      |                   |       |specification
+      |                   |       |version 1.00
+------|-------------------|-------|--------------------
+  4   |   bCountryCode    |  0x00 |The country code is 0x00
+------|-------------------|-------|--------------------
+  5   |  bNumDescriptors  |  0x01 |The number of class
+      |                   |       |descriptors is 1
+------|-------------------|-------|--------------------
+  6   |  bDescriptorType  |  0x22 |The class descriptor
+      |                   |       |is Report descriptor
+------|-------------------|-------|--------------------
+  7   | wDescriptorlength | 0x0034|The total size of
+      |                   |       |the class descriptor
+      |                   |       |is 52
+------|-------------------|-------|--------------------
+
+       ENDPOINT Descriptor
+       -------------------
+Offset|      Field       | Value |  Description
+------|------------------|-------|--------------------
+  0   |     bLength      |  0x07 |The size of this
+      |                  |       |descriptor is 7 bytes
+------|------------------|-------|--------------------
+  1   | bDescriptorType  |  0x05 |ENDPOINT Descriptor Type
+------|------------------|-------|--------------------
+  2   | bEndpointAddress |  0x81 |This is an IN
+      |                  |       |endpoint with
+      |                  |       |address (endpoint
+      |                  |       |number) 1
+------|------------------|-------|--------------------
+  3   |   bmAttributes   |  0x03 |Types -
+      |                  |       |Transfer:INTERRUPT
+      |                  |       |Sync:No Sync
+      |                  |       |Usage:Data EP
+------|------------------|-------|--------------------
+  4   |  wMaxPacketSize  | 0x0004|Maximum packet size
+      |                  |       |value for this
+      |                  |       |endpoint is 0x4
+      |                  |       |(Bits 12-11: Addtl. Transactions/frame)
+------|------------------|-------|--------------------
+  6   |    bInterval     |  0x0A |bInterval:10. The
+      |                  |       |polling interval
+      |                  |       |value is bInterval
+      |                  |       |or 2**(bInterval-1)
+------|------------------|-------|--------------------
+
+*******************************************************************/
+
+
+#define CONFIG_DESC_NUM_INTERFACES  (4)
+
+/* This must be counted manually and updated with the descriptor */
+/* 1*Config(9) + 1*Interface(9) + 1*HID(9) + 1* Endpoint (7)= 34 bytes */
+#define CONFIG_DESC_SIZE            (34)
+
+static uint_8_ptr ConfigDesc;
+
+static uint_8 ConfigDescData[CONFIG_DESC_SIZE] =
+{
+   /*Config Descriptor */
+   0x09,
+   0x02,
+   USB_uint_16_low(CONFIG_DESC_SIZE),
+   USB_uint_16_high(CONFIG_DESC_SIZE),
+   0x01,
+   0x01,
+   0x00,
+   0xE0, /* 0x80, */
+   0x0,
+   /* Interface Descriptor */
+   0x09,
+   0x04,
+   0x00,
+   0x00,
+   0x01,
+   0x03,
+   0x01,
+   0x02,
+   0x00,
+
+   /* HID descriptor */
+   0x09,
+   0x21,
+   USB_uint_16_low(0x0100),
+   USB_uint_16_high(0x0100),
+   0x00,
+   0x01,
+   0x22,
+   USB_uint_16_low(0x0034),
+   USB_uint_16_high(0x0034),
+
+   /*Endpoint descriptor */
+   0x07,
+   0x05,
+   (0x80+INTERRUPT_EP),
+   0x03,
+   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE),
+   USB_uint_16_high(INTERRUPT_MAX_PACKET_SIZE),
+   FRAME_INTERVAL
+};
+
+#define OTHER_SPEED_CONFIG_DESC_SIZE  CONFIG_DESC_SIZE
+static uint_8_ptr  other_speed_config;
+static uint_8  other_speed_config_data[CONFIG_DESC_SIZE] =
+{
+   /*Config Descriptor */
+   0x09,
+   0x07,
+   USB_uint_16_low(CONFIG_DESC_SIZE),
+   USB_uint_16_high(CONFIG_DESC_SIZE),
+   0x01,
+   0x01,
+   0x00,
+   0xE0, /* 0x80, */
+   0x0,
+   /* Interface Descriptor */
+   0x09,
+   0x04,
+   0x00,
+   0x00,
+   0x01,
+   0x03,
+   0x01,
+   0x02,
+   0x00,
+
+   /* HID descriptor */
+   0x09,
+   0x21,
+   USB_uint_16_low(0x0100),
+   USB_uint_16_high(0x0100),
+   0x00,
+   0x01,
+   0x22,
+   USB_uint_16_low(0x0034),
+   USB_uint_16_high(0x0034),
+
+   /*Endpoint descriptor */
+   0x07,
+   0x05,
+   (0x80+INTERRUPT_EP),
+   0x03,
+   USB_uint_16_low(INTERRUPT_MAX_PACKET_SIZE),
+   USB_uint_16_high(INTERRUPT_MAX_PACKET_SIZE),
+   FRAME_INTERVAL
+
+};
+/************************************************************************
+
+HID Class Report Descriptor :
+
+Item						Value(Hex)
+------------------------------------------------------------------------------------------------------------
+Usage Page (Generic Desktop Control)			05 01
+Usage (Mouse)					09 02
+Collection (Application)				A1 01
+  Usage (Pointer)					09 01
+  Collection (Physical)				A1 00
+    Usage Page (Button)				05 09
+    Usage Minimum (1)				19 01
+    Usage Maximum (3)				29 03
+    Logical Minimum (0)				15 00
+    Logical Maximum (1)				25 01
+    Report Count (3)					95 03
+    Report Size (1)					75 01
+    Input (Data, Variable, Absolute)			81 02
+    Report Count (1)					95 01
+    Report Size (5)					75 05
+    Input (Constant)					81 01
+    Usage Page (Generic Desktop Control)		05 01
+    Usage (X)					09 30
+    Usage (Y)					09 31
+    Usage (Wheel)					09 38
+    Logical Minimum (-127)				15 81
+    Logical Maximum (127)				25 7F
+    Report Size (8)					75 08
+    Report Count (3)					95 03
+    Input (Data, Variable, Relative)			81 06
+  End Collection					C0
+End Collection					C0
+
+
+************************************************************************/
+
+#define REPORT_DESC_SIZE            (52)
+static uint_8_ptr ReportDesc;
+
+static uint_8 ReportDescData[REPORT_DESC_SIZE] =
+{
+   0x05,
+   0x01,
+   0x09,
+   0x02,
+   0xA1,
+   0x01,
+   0x09,
+   0x01,
+
+   0xA1,
+   0x00,
+   0x05,
+   0x09,
+   0x19,
+   0x01,
+   0x29,
+   0x03,
+
+   0x15,
+   0x00,
+   0x25,
+   0x01,
+   0x95,
+   0x03,
+   0x75,
+   0x01,
+
+   0x81,
+   0x02,
+   0x95,
+   0x01,
+   0x75,
+   0x05,
+   0x81,
+   0x01,
+
+   0x05,
+   0x01,
+   0x09,
+   0x30,
+   0x09,
+   0x31,
+   0x09,
+   0x38,
+
+   0x15,
+   0x81,
+   0x25,
+   0x7F,
+   0x75,
+   0x08,
+   0x95,
+   0x03,
+
+   0x81,
+   0x06,
+   0xC0,
+   0xC0
+};
+
+/**************************************************************
+This report descriptor can be used to report the set_report
+and get_report capability to host. When this is used, modify
+the config descriptor to reflect the size of report descriptor.
+The following lines should be changed,
+
+USB_uint_16_low(0x0038),  //   Changed from USB_uint_16_low(0x0034),
+USB_uint_16_high(0x0038), //   Changed from USB_uint_16_high(0x0034),
+
+
+
+
+uint_8  ReportDesc[56] = {
+    0x06, 0x00, 0xff,              		// USAGE_PAGE (Generic Desktop)
+    0x09, 0x01,                    		// USAGE (Vendor Usage 1)
+    0xa1, 0x01,                    		// COLLECTION (Application)
+
+    0x09, 0x02,                    		//   USAGE (Vendor Usage 2)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
+    0x75, 0x08,                    		//   REPORT_SIZE (8)
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0x09, 0x03,                    		//   USAGE (Vendor Usage 3)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
+    0x75, 0x08,                    		//   REPORT_SIZE (8)
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0x09, 0x04,                    		//   USAGE (Vendor Usage 4)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
+    0x75, 0x08,                    		//   REPORT_SIZE (8)
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0x09, 0x05,                    		//   USAGE (Vendor Usage 5)
+    0x15, 0x80,                    		//   LOGICAL_MINIMUM (-128)
+    0x25, 0x7f,                    		//   LOGICAL_MAXIMUM (127)
+    0x95, 0x01,                    		//   REPORT_COUNT (1)
+    0x75, 0x08,                    		//   REPORT_SIZE (8)
+    0xb1, 0x02,                    		//   FEATURE (Data,Var,Abs)
+
+    0xc0                           		// END_COLLECTION
+};
+***************************************************************/
+
+/**********************************************************************
+Mouse data (this structure is used to send mouse movement information)
+**********************************************************************/
+typedef struct   _MOUSE_DATA {
+   char  a;
+   char  b;
+   char  c;
+   char  d;
+
+} MOUSE_DATA_STRUCT;
+
+static MOUSE_DATA_STRUCT mouse_data = {0,0,0,0};
+
+static uint_8 USB_IF_ALT[4] = { 0, 0, 0, 0};
+
+/* number of strings in the table not including 0 or n. */
+static const uint_8 USB_STR_NUM  = 6;
+
+/*
+** if the number of strings changes, look for USB_STR_0 everywhere and make
+** the obvious changes.  It should be found in 3 places.
+*/
+
+static const uint_16 USB_STR_0[ 2] = {0x0300 + sizeof(USB_STR_0),0x0409};
+static const uint_16 USB_STR_1[26] = {0x0300 + sizeof(USB_STR_1),
+      'M','a','r','v','e','l','l',' ','S','e','m','i','c','o','n','d','u','c','t','o','r',' ','L','t','d'};
+static const uint_16 USB_STR_2[28] = {0x0300 + sizeof(USB_STR_2),
+      'M','A','R','V','E','L','L',' ','U','S','B',' ','h','i','d','m','o','u','s','e',' ',\
+      'D','e','v','i','c','e'};
+static const uint_16 USB_STR_3[ 5] = {0x0300 + sizeof(USB_STR_3),
+      'B','E','T','A'};
+static const uint_16 USB_STR_4[ 4] = {0x0300 + sizeof(USB_STR_4),
+      '#','0','2'};
+static const uint_16 USB_STR_5[ 4] = {0x0300 + sizeof(USB_STR_5),
+      '_','A','1'};
+static const uint_16 USB_STR_6[15] = {0x0300 + sizeof(USB_STR_6),
+      'Y','o','u','r',' ','n','a','m','e',' ','h','e','r','e'};
+static const uint_16 USB_STR_n[17] = {0x0300 + sizeof(USB_STR_n),
+      'B','A','D',' ','S','T','R','I','N','G',' ','I','n','d','e','x'};
+
+#define USB_STRING_ARRAY_SIZE  8
+static const uint_8_ptr USB_STRING_DESC[USB_STRING_ARRAY_SIZE] =
+{
+   (uint_8_ptr)USB_STR_0,
+   (uint_8_ptr)USB_STR_1,
+   (uint_8_ptr)USB_STR_2,
+   (uint_8_ptr)USB_STR_3,
+   (uint_8_ptr)USB_STR_4,
+   (uint_8_ptr)USB_STR_5,
+   (uint_8_ptr)USB_STR_6,
+   (uint_8_ptr)USB_STR_n
+};
+
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetDescription
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetDescription command
+*     The Device Request can ask for Device/Config/string/interface/endpoint
+*     descriptors (via wValue). We then post an IN response to return the
+*     requested descriptor.
+*     And then wait for the OUT which terminates the control transfer.
+*     See section 9.4.3 (page 189) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetDescription
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+   if (setup) {
+      /* Load the appropriate string depending on the descriptor requested.*/
+      switch (setup_ptr->VALUE & 0xFF00) {
+
+         case 0x0100:
+            _usb_device_send_data(handle, 0, DevDesc,
+               MIN(setup_ptr->LENGTH, DEVICE_DESCRIPTOR_SIZE));
+
+            break;
+
+         case 0x0200:
+             *(ConfigDesc + 33) = frame_interval;
+            _usb_device_send_data(handle, 0, ConfigDesc,
+               MIN(setup_ptr->LENGTH, CONFIG_DESC_SIZE));
+
+            break;
+
+         case 0x2200:
+         _usb_device_send_data(handle, 0, ReportDesc,
+            MIN(setup_ptr->LENGTH, REPORT_DESC_SIZE));
+
+         /*send some data for the mouse in the interrupt pipe queue */
+         _usb_device_send_data(handle, INTERRUPT_EP, (uint_8_ptr)((pointer)&mouse_data),
+                                sizeof(MOUSE_DATA_STRUCT));
+
+            break;
+
+         case 0x0300:
+            if ((setup_ptr->VALUE & 0x00FF) > USB_STR_NUM) {
+               _usb_device_send_data(handle, 0, USB_STRING_DESC[USB_STR_NUM+1],
+                  MIN(setup_ptr->LENGTH, USB_STRING_DESC[USB_STR_NUM+1][0]));
+            } else {
+               _usb_device_send_data(handle, 0,
+                  USB_STRING_DESC[setup_ptr->VALUE & 0x00FF],
+                  MIN(setup_ptr->LENGTH, USB_STRING_DESC[setup_ptr->VALUE & 0x00FF][0]));
+            } /* Endif */
+            break;
+
+         case 0x600:
+            _usb_device_send_data(handle, 0, (uint_8_ptr)DevQualifierDesc,
+               MIN(setup_ptr->LENGTH, DEVICE_QUALIFIER_DESCRIPTOR_SIZE));
+            break;
+
+         case 0x700:
+            *(other_speed_config + 33) = frame_interval;
+
+            _usb_device_send_data(handle, 0, (uint_8_ptr)other_speed_config,
+               MIN(setup_ptr->LENGTH, OTHER_SPEED_CONFIG_DESC_SIZE));
+            break;
+
+         default:
+            USB_printf("usbMouse_%d, %s: Unexpected VALUE=0x%04x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
+            _usb_device_stall_endpoint(handle, 0, 0);
+            return;
+      } /* Endswitch */
+      /* status phase */
+      _usb_device_recv_data(handle, 0, 0, 0);
+   } /* Endif */
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetDescription
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetDescription command
+*     See section 9.4.8 (page 193) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetDescription
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    USB_printf("usbMouse_%d, %s: setup=%d\n",
+            _usb_device_get_dev_num(handle), __FUNCTION__, (int)setup);
+   _usb_device_stall_endpoint(handle, 0, 0);
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetConfig
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetConfig command
+*     See section 9.4.2 (page 189) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetConfig
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+   uint_16 current_config;
+   /* Return the currently selected configuration */
+   if (setup){
+      _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
+         &current_config);
+      data_to_send = (uint_8)current_config;
+      _usb_device_send_data(handle, 0, (pointer) &data_to_send, sizeof(data_to_send));
+      /* status phase */
+      _usb_device_recv_data(handle, 0, 0, 0);
+   } /* Endif */
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetConfig
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetConfig command
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetConfig
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    uint_16 usb_state;
+
+    if (setup)
+    {
+        if ((setup_ptr->VALUE & 0x00FF) > 1)
+        {
+            /* generate stall */
+            USB_printf("usbMouse_%d, %s: Wrong VALUE=0x%04x\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->VALUE);
+            _usb_device_stall_endpoint(handle, 0, 0);
+            return;
+        } /* Endif */
+
+        /* 0 indicates return to unconfigured state */
+        if ((setup_ptr->VALUE & 0x00FF) == 0)
+        {
+            _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
+            if ((usb_state == ARC_USB_STATE_CONFIG) ||
+                (usb_state == ARC_USB_STATE_ADDRESS))
+            {
+                /* clear the currently selected config value */
+                _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, 0);
+                _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
+                                                        ARC_USB_STATE_ADDRESS);
+                /* status phase */
+                _usb_device_send_data(handle, 0, 0, 0);
+            }
+            else
+            {
+                USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
+
+                _usb_device_stall_endpoint(handle, 0, 0);
+            } /* Endif */
+            return;
+        } /* Endif */
+
+        /*
+        ** If the configuration value (setup_ptr->VALUE & 0x00FF) differs
+        ** from the current configuration value, then endpoints must be
+        ** reconfigured to match the new device configuration
+        */
+        _usb_device_get_status(handle, ARC_USB_STATUS_CURRENT_CONFIG, &usb_state);
+        ARC_DEBUG_TRACE(ARC_DEBUG_FLAG_SETUP,
+                        "usbMouse: Set configuration: old=%d, new=%d\n",
+                        usb_state, setup_ptr->VALUE & 0x00FF);
+
+        if (usb_state != (setup_ptr->VALUE & 0x00FF))
+        {
+            /* Reconfigure endpoints here */
+            switch (setup_ptr->VALUE & 0x00FF)
+            {
+                default:
+                break;
+            } /* Endswitch */
+            _usb_device_set_status(handle, ARC_USB_STATUS_CURRENT_CONFIG,
+                                setup_ptr->VALUE & 0x00FF);
+        } /* Endif */
+        /* Init Interrupt endpoint */
+        _usb_device_init_endpoint(handle,INTERRUPT_EP, INTERRUPT_MAX_PACKET_SIZE,
+                                   ARC_USB_SEND, ARC_USB_INTERRUPT_ENDPOINT,
+                                   ARC_USB_DEVICE_DONT_ZERO_TERMINATE);
+
+        TEST_ENABLED = TRUE;
+
+        _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE_STATE,
+                             ARC_USB_STATE_CONFIG);
+        /* status phase */
+        _usb_device_send_data(handle, 0, 0, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9GetInterface
+* Returned Value : None
+* Comments       :
+*     Chapter 9 GetInterface command
+*     See section 9.4.4 (page 190) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9GetInterface
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    uint_16 usb_state;
+
+    _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE_STATE, &usb_state);
+    if (usb_state != ARC_USB_STATE_CONFIG)
+    {
+        USB_printf("usbMouse_%d, %s: Wrong usb_state=%d\n",
+                    _usb_device_get_dev_num(handle), __FUNCTION__, usb_state);
+        _usb_device_stall_endpoint(handle, 0, 0);
+        return;
+    } /* Endif */
+
+    if (setup)
+    {
+        _usb_device_send_data(handle, 0, &USB_IF_ALT[setup_ptr->INDEX & 0x00FF],
+                                MIN(setup_ptr->LENGTH, sizeof(uint_8)));
+        /* status phase */
+        _usb_device_recv_data(handle, 0, 0, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SetInterface
+* Returned Value : None
+* Comments       :
+*     Chapter 9 SetInterface command
+*     See section 9.4.10 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SetInterface
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+    if (setup)
+    {
+        if (setup_ptr->REQUESTTYPE != 0x01)
+        {
+            USB_printf("usbDisk_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
+                        setup_ptr->REQUESTTYPE);
+
+            _usb_device_stall_endpoint(handle, 0, 0);
+            return;
+        } /* Endif */
+
+        /*
+        ** If the alternate value (setup_ptr->VALUE & 0x00FF) differs
+        ** from the current alternate value for the specified interface,
+        ** then endpoints must be reconfigured to match the new alternate
+        */
+        if (USB_IF_ALT[setup_ptr->INDEX & 0x00FF]
+                    != (setup_ptr->VALUE & 0x00FF))
+        {
+            USB_IF_ALT[setup_ptr->INDEX & 0x00FF] = (setup_ptr->VALUE & 0x00FF);
+            /* Reconfigure endpoints here. */
+
+        } /* Endif */
+
+        /* status phase */
+        _usb_device_send_data(handle, 0, 0, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9SynchFrame
+* Returned Value :
+* Comments       :
+*     Chapter 9 SynchFrame command
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9SynchFrame
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+
+    if (setup)
+    {
+        if (setup_ptr->REQUESTTYPE != 0x02)
+        {
+            USB_printf("usbMouse_%d, %s: Wrong REQUESTTYPE=0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__,
+                        setup_ptr->REQUESTTYPE);
+            _usb_device_stall_endpoint(handle, 0, 0);
+            return;
+        } /* Endif */
+
+        if ((setup_ptr->INDEX & 0x00FF) >=
+                ConfigDesc[CONFIG_DESC_NUM_INTERFACES])
+        {
+            USB_printf("usbMouse_%d, %s: Wrong INDEX=0x%04x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->INDEX);
+            _usb_device_stall_endpoint(handle, 0, 0);
+            return;
+        } /* Endif */
+
+        _usb_device_get_status(handle, ARC_USB_STATUS_SOF_COUNT, &sof_count);
+
+        sof_count = USB_16BIT_LE(sof_count);
+        _usb_device_send_data(handle, 0, (uint_8_ptr)&sof_count,
+                        MIN(setup_ptr->LENGTH, sizeof(sof_count)));
+        /* status phase */
+        _usb_device_recv_data(handle, 0, 0, 0);
+    } /* Endif */
+    return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : get_report
+* Returned Value :
+* Comments       :
+*     Chapter 9 Class specific request
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+
+void get_report
+	(
+	/* USB handle */
+	_usb_device_handle handle,
+
+	/* Is it a Setup phase? */
+	boolean     setup,
+
+   /* [IN] Direction of the transfer. (1 for USB IN token)*/
+   uint_8      direction,
+
+	/* The setup packet pointer */
+	SETUP_STRUCT_PTR setup_ptr
+
+	)
+{
+    int i;
+
+   for(i=0;i<10;i++)
+	{
+		hid_test_rep_data[i] = (uint_8) i;
+	}
+
+	if (setup)
+	{
+		_usb_device_send_data(handle, 0, (uint_8_ptr)hid_test_rep_data, MIN(setup_ptr->LENGTH,4));
+	}
+
+   _usb_device_recv_data(handle, 0, 0, 0);
+
+
+	return;
+}
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : set_report
+* Returned Value :
+* Comments       :
+*     Chapter 9 Class specific request
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+
+void set_report
+	(
+	/* USB handle */
+	_usb_device_handle handle,
+
+	/* Is it a Setup phase? */
+	boolean setup,
+
+   /* [IN] Direction of the transfer. (1 for USB IN token)*/
+   uint_8               direction,
+
+
+	/* The setup packet pointer */
+	SETUP_STRUCT_PTR setup_ptr
+	)
+{
+	if (setup)      /*on a SetUP packet*/
+   {
+	  _usb_device_recv_data(handle, 0, (uint_8_ptr)hid_test_rep_data, MIN(setup_ptr->LENGTH,4));
+
+	}
+   else if(direction == ARC_USB_RECV)   /*on a OUT packet*/
+   {
+	_usb_device_recv_data(handle, 0, (uint_8_ptr)hid_test_rep_data, MIN(setup_ptr->LENGTH,4));
+     _usb_device_send_data(handle, 0, 0, 0);
+   }
+
+	return;
+}
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : set_idle
+* Returned Value :
+* Comments       :
+*     Chapter 9 Class specific request
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+
+void set_idle
+	(
+	/* USB handle */
+	_usb_device_handle handle,
+
+	/* Is it a Setup phase? */
+	boolean setup,
+
+   /* [IN] Direction of the transfer. (1 for USB IN token)*/
+   uint_8               direction,
+
+
+	/* The setup packet pointer */
+	SETUP_STRUCT_PTR setup_ptr
+	)
+{
+   /* SET_IDLE is a No data phase transaction from HID class. All it needs
+   is a terminating IN token */
+	if (setup)      /*on a SetUP packet*/
+   {
+	  _usb_device_send_data(handle, 0, 0, 0);
+	}
+	return;
+}
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : ch9Class
+* Returned Value :
+* Comments       :
+*     Chapter 9 Class specific request
+*     See section 9.4.11 (page 195) of the USB 1.1 Specification.
+*
+*END*--------------------------------------------------------------------*/
+static void ch9Class
+   (
+      /* USB handle */
+      _usb_device_handle handle,
+
+      /* Is it a Setup phase? */
+      boolean setup,
+
+      /* [IN] Direction of the transfer. (1 for USB IN token)*/
+      uint_8               direction,
+
+      /* The setup packet pointer */
+      SETUP_STRUCT_PTR setup_ptr
+   )
+{ /* Body */
+
+   switch (setup_ptr->REQUEST)
+   {
+
+      case 0x01:
+         get_report(handle, setup, direction, setup_ptr);
+         break;
+
+      case 0x09:
+         set_report(handle, setup, direction, setup_ptr);
+         break;
+
+      case 0x0A:
+         set_idle(handle, setup, direction, setup_ptr);
+         break;
+
+      default:
+        USB_printf("usbMouse_%d, %s: Wrong REQUEST=0x%02x\n",
+              _usb_device_get_dev_num(handle), __FUNCTION__, setup_ptr->REQUEST);
+
+         _usb_device_stall_endpoint(handle, 0, 0);
+         break;
+
+   } /* EndSwitch */
+
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_ep0
+* Returned Value : None
+* Comments       :
+*     Called upon a completed endpoint 0 (USB 1.1 Chapter 9) transfer
+*
+*END*--------------------------------------------------------------------*/
+static void service_ep0
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Is it a setup packet? */
+      boolean              setup,
+
+      /* [IN] Direction of the transfer.  Is it transmit? */
+      uint_8               direction,
+
+      /* [IN] Pointer to the data buffer */
+      uint_8_ptr           buffer,
+
+      /* [IN] Length of the transfer */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+
+   )
+{ /* Body */
+   boolean  class_request = FALSE;
+
+   if (setup)
+   {
+      _usb_device_read_setup_data(handle, 0, (uint_8_ptr)&local_setup_packet);
+      local_setup_packet.VALUE = USB_16BIT_LE(local_setup_packet.VALUE);
+      local_setup_packet.INDEX = USB_16BIT_LE(local_setup_packet.INDEX);
+      local_setup_packet.LENGTH = USB_16BIT_LE(local_setup_packet.LENGTH);
+   }
+   else if (class_request) {
+      class_request = FALSE;
+      /* Finish your class or vendor request here */
+
+      return;
+   } /* Endif */
+
+   switch (local_setup_packet.REQUESTTYPE & 0x60) {
+
+      case 0x00:
+         switch (local_setup_packet.REQUEST) {
+
+            case 0x0:
+               mvUsbCh9GetStatus(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x1:
+               mvUsbCh9ClearFeature(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x3:
+               mvUsbCh9SetFeature(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x5:
+               mvUsbCh9SetAddress(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x6:
+               ch9GetDescription(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x7:
+               ch9SetDescription(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x8:
+               ch9GetConfig(handle, setup, &local_setup_packet);
+               break;
+
+            case 0x9:
+               ch9SetConfig(handle, setup, &local_setup_packet);
+               break;
+
+            case 0xa:
+               ch9GetInterface(handle, setup, &local_setup_packet);
+               break;
+
+            case 0xb:
+               ch9SetInterface(handle, setup, &local_setup_packet);
+               break;
+
+            case 0xc:
+               ch9SynchFrame(handle, setup, &local_setup_packet);
+               break;
+
+            default:
+                USB_printf("usbMouse_%d, %s: Wrong REQUEST = 0x%02x\n",
+                        _usb_device_get_dev_num(handle), __FUNCTION__, local_setup_packet.REQUEST);
+               _usb_device_stall_endpoint(handle, 0, 0);
+               break;
+
+         } /* Endswitch */
+
+         break;
+
+      case 0x20:
+         ch9Class(handle, setup, direction, &local_setup_packet);
+
+         break;
+
+      case 0x40:
+         /* vendor specific request */
+         break;
+
+      default:
+         USB_printf("usbMouse_%d, %s: Unexpected REQUESTTYPE = 0x%x\n",
+                _usb_device_get_dev_num(handle), __FUNCTION__,
+                local_setup_packet.REQUESTTYPE);
+
+         _usb_device_stall_endpoint(handle, 0, 0);
+         break;
+
+   } /* Endswitch */
+
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_ep1
+* Returned Value : None
+* Comments       :
+*     Called upon a completed endpoint 1 (USB 1.1 Chapter 9) transfer
+*
+*END*--------------------------------------------------------------------*/
+static void service_ep1
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Is it a setup packet? */
+      boolean              setup,
+
+      /* [IN] Direction of the transfer.  Is it transmit? */
+      uint_8               direction,
+
+      /* [IN] Pointer to the data buffer */
+      uint_8_ptr           buffer,
+
+      /* [IN] Length of the transfer */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+
+   )
+{ /* Body */
+
+/********************************************************************
+   The following code will move the mouse right and left on the screen.
+   Comment this out if this behaviour is not desired.
+********************************************************************/
+
+    static int       x = 0;
+    static boolean   right = FALSE;
+    static int       wait = 0;
+
+    mouseCntr++;
+    if(wait == 0)
+    {
+        if (right == FALSE)
+        {
+            mouse_data.b = 1;
+            x++;
+            right = (x > 200) ? TRUE : FALSE;
+        }
+
+        if (right == TRUE)
+        {
+            mouse_data.b = -1;
+            x--;
+            right = (x < 0) ? FALSE : TRUE;
+        }
+        wait = mouseDelay;
+    }
+    else
+    {
+        wait--;
+        mouse_data.b = 0;
+    }
+
+   _usb_device_send_data(handle, INTERRUPT_EP, (uint_8_ptr)((pointer)&mouse_data),
+                            sizeof(MOUSE_DATA_STRUCT));
+
+   return;
+} /* Endbody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : reset_ep0
+* Returned Value : None
+* Comments       :
+*     Called upon a bus reset event.  Initialises the control endpoint.
+*
+*END*--------------------------------------------------------------------*/
+static void reset_ep0
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Unused */
+      boolean              setup,
+
+      /* [IN] Unused */
+      uint_8               direction,
+
+      /* [IN] Unused */
+      uint_8_ptr           buffer,
+
+      /* [IN] Unused */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+
+
+   )
+{ /* Body */
+
+   /*on a reset always cancel all transfers all EP 0 */
+   _usb_device_cancel_transfer(handle, 0, ARC_USB_RECV);
+   _usb_device_cancel_transfer(handle, 0, ARC_USB_SEND);
+
+   _usb_device_start(handle);
+
+   /* Initialize the endpoint 0 in both directions */
+   _usb_device_init_endpoint(handle, 0, DevDesc[DEV_DESC_MAX_PACKET_SIZE], 0,
+      ARC_USB_CONTROL_ENDPOINT, 0);
+   _usb_device_init_endpoint(handle, 0, DevDesc[DEV_DESC_MAX_PACKET_SIZE], 1,
+      ARC_USB_CONTROL_ENDPOINT, 0);
+
+   if (TEST_ENABLED)
+   {
+      _usb_device_cancel_transfer(handle, INTERRUPT_EP, ARC_USB_SEND);
+   } /* Endif */
+
+   TEST_ENABLED = FALSE;
+   mouseCntr = 0;
+
+   return;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : service_suspend
+* Returned Value : None
+* Comments       :
+*     Called when host suspend the USB port. Do remote wake up if desired.
+*
+*END*--------------------------------------------------------------------*/
+static void service_suspend
+   (
+      /* [IN] Handle of the USB device */
+      _usb_device_handle   handle,
+
+      /* [IN] request type as registered */
+      uint_8               type,
+
+      /* [IN] Unused */
+      boolean              setup,
+
+      /* [IN] Unused */
+      uint_8               direction,
+
+      /* [IN] Unused */
+      uint_8_ptr           buffer,
+
+      /* [IN] Unused */
+      uint_32              length,
+
+      /* [IN] Error, if any */
+      uint_8               error
+   )
+{ /* Body */
+   uint_16      usb_status;
+   int          lockKey;
+
+   _usb_device_get_status(handle, ARC_USB_STATUS_DEVICE, &usb_status);
+   if (usb_status & ARC_USB_REMOTE_WAKEUP)
+   {
+       lockKey = USB_lock();
+
+       USB_printf("Mouse Suspended: type=%d, usbStatus=0x%x\n", type, usb_status);
+       USB_SUSPENDED = TRUE;
+
+       USB_unlock(lockKey);
+   }
+
+   return;
+} /* EndBody */
+
+/*FUNCTION*----------------------------------------------------------------
+*
+* Function Name  : usbMouseLoad
+* Returned Value : None
+* Comments       :
+*     First function called.  Initialises the USB and registers Chapter 9
+*     callback functions.
+*
+*END*--------------------------------------------------------------------*/
+_usb_device_handle  usbMouseLoad(int devNo)
+{ /* Body */
+   _usb_device_handle   handle;
+   uint_8               error;
+   uint_32              send_data_buffer_size=0;
+   uint_8_ptr           temp;
+   int                  lockKey, i, j;
+   static boolean       isFirst = TRUE;
+
+    if(isFirst)
+    {
+        /* Swap all USB_STRING_DESC */
+        for(i=0; i<(sizeof(USB_STRING_DESC)/sizeof(USB_STRING_DESC[0])); i++)
+        {
+            uint_16* usbStr = (uint_16*)(USB_STRING_DESC[i]);
+            uint_16 size = (usbStr[0]-0x300)/sizeof(uint_16);
+
+            for(j=0; j<size; j++)
+            {
+                usbStr[j] = USB_16BIT_LE(usbStr[j]);
+            }
+        }
+        isFirst = FALSE;
+    }
+
+   lockKey = USB_lock();
+
+    /* Initialize the USB interface */
+    error = _usb_device_init(devNo, &handle);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB Initialization failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    /* Self Power, Remote wakeup disable */
+    _usb_device_set_status(handle, ARC_USB_STATUS_DEVICE, (1 << DEVICE_SELF_POWERED));
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_EP0, service_ep0);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB EP0 Service Registration failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_BUS_RESET, reset_ep0);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB BUS_RESET Service Registration failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, INTERRUPT_EP, service_ep1);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB EP1 Service Registration failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_SUSPEND, service_suspend);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB SUSPEND Service Registration failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    error = _usb_device_register_service(handle, ARC_USB_SERVICE_SLEEP, service_suspend);
+    if (error != USB_OK)
+    {
+        USB_printf("\nUSB SUSPEND Service Registration failed. Error: %x\n", error);
+        return NULL;
+    } /* Endif */
+
+    /***********************************************************************
+    Allocate memory to receive data at endpoint 0. Ensure that buffers are
+    cache aligned.
+    ***********************************************************************/
+    hid_test_rep_data_unaligned   = (uint_8_ptr) USB_memalloc((EP1_RECV_BUFFER_SIZE + PSP_CACHE_LINE_SIZE));
+    if(hid_test_rep_data_unaligned == NULL)
+    {
+        USB_printf("mouseLoad: Buffer allocation of %d bytes is failed\n",
+                    (unsigned)EP1_RECV_BUFFER_SIZE + PSP_CACHE_LINE_SIZE);
+        return NULL;
+    }
+
+    hid_test_rep_data = (uint_8_ptr) USB_CACHE_ALIGN((uint_32) hid_test_rep_data_unaligned);
+
+    /**************************************************************************
+    Best way to handle the Data cache is to allocate a large buffer that is
+    cache aligned and keep all data inside it. Flush the line of the cache
+    that you have changed. In this program, we have static data such as
+    descriptors which never changes. Such data can be kept in this buffer
+    and flushed only once. Note that you can reduce the size of this buffer
+    by aligning the addresses in a different way.
+    ***************************************************************************/
+    send_data_buffer_size =  (DEVICE_DESCRIPTOR_SIZE +  PSP_CACHE_LINE_SIZE) +
+                             (CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
+                             (REPORT_DESC_SIZE + PSP_CACHE_LINE_SIZE) +
+                             (DEVICE_QUALIFIER_DESCRIPTOR_SIZE + PSP_CACHE_LINE_SIZE) +
+                             (OTHER_SPEED_CONFIG_DESC_SIZE + PSP_CACHE_LINE_SIZE);
+
+    Send_Buffer_Unaligned   = (uint_8_ptr) USB_memalloc(send_data_buffer_size);
+    if (Send_Buffer_Unaligned == NULL)
+    {
+        USB_printf("\nMouse: %d bytes Buffer allocation failed\n", send_data_buffer_size);
+        return NULL;
+    }
+
+    Send_Buffer_aligned = (uint_8_ptr) USB_CACHE_ALIGN((uint_32) Send_Buffer_Unaligned);
+    /* keep a temporary copy of the aligned address */
+    temp = Send_Buffer_aligned;
+
+
+    /**************************************************************************
+    Assign pointers to different descriptors from it and copy descriptors inside.
+    ***************************************************************************/
+    DevDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(DevDescData, DevDesc, DEVICE_DESCRIPTOR_SIZE);
+    Send_Buffer_aligned += ((DEVICE_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    ConfigDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(ConfigDescData, ConfigDesc, CONFIG_DESC_SIZE);
+
+    Send_Buffer_aligned += ((CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    ReportDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(ReportDescData, ReportDesc, REPORT_DESC_SIZE);
+    Send_Buffer_aligned += ((REPORT_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+
+    DevQualifierDesc =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(DevQualifierDescData, DevQualifierDesc, DEVICE_QUALIFIER_DESCRIPTOR_SIZE);
+    Send_Buffer_aligned += ((DEVICE_QUALIFIER_DESCRIPTOR_SIZE/PSP_CACHE_LINE_SIZE) + \
+                           1)* PSP_CACHE_LINE_SIZE;
+
+    other_speed_config =  (uint_8_ptr) Send_Buffer_aligned;
+    USB_memcopy(other_speed_config_data, other_speed_config, OTHER_SPEED_CONFIG_DESC_SIZE);
+    Send_Buffer_aligned += ((OTHER_SPEED_CONFIG_DESC_SIZE/PSP_CACHE_LINE_SIZE) + 1)* PSP_CACHE_LINE_SIZE;
+
+    /**************************************************************************
+    Flush the cache to ensure main memory is updated.
+    ***************************************************************************/
+    USB_dcache_flush(temp,send_data_buffer_size);
+
+     /* Initialize the endpoint 0 in both directions */
+    _usb_device_init_endpoint(handle, 0, DevDesc[DEV_DESC_MAX_PACKET_SIZE], 0,
+                            ARC_USB_CONTROL_ENDPOINT, 0);
+    _usb_device_init_endpoint(handle, 0, DevDesc[DEV_DESC_MAX_PACKET_SIZE], 1,
+                            ARC_USB_CONTROL_ENDPOINT, 0);
+
+    USB_unlock(lockKey);
+
+    USB_printf("USB Mouse example is READY\n");
+
+    return handle;
+} /* Endbody */
+
+void    usbMouseUnload(_usb_device_handle handle)
+{
+    int     lockKey;
+
+    if(handle == NULL)
+        return;
+
+    /*lock interrupts */
+    lockKey = USB_lock();
+
+    /* ensure all transfers are cancelled */
+    _usb_device_cancel_transfer(handle, INTERRUPT_EP,  ARC_USB_SEND);
+
+    /* Stop Endpoints */
+    _usb_device_deinit_endpoint(handle, INTERRUPT_EP, ARC_USB_SEND);
+
+    _usb_device_deinit_endpoint(handle, 0, ARC_USB_RECV);
+    _usb_device_deinit_endpoint(handle, 0, ARC_USB_SEND);
+
+    _usb_device_stop(handle);
+
+    /* Deregister all services */
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_EP0);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_BUS_RESET);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_SUSPEND);
+    _usb_device_unregister_service(handle, ARC_USB_SERVICE_SLEEP);
+    _usb_device_unregister_service(handle, INTERRUPT_EP);
+
+    _usb_device_shutdown(handle);
+
+    /* Free memory allocated for Disk device */
+    if(Send_Buffer_Unaligned != NULL)
+    {
+        USB_memfree(Send_Buffer_Unaligned);
+        Send_Buffer_Unaligned = NULL;
+    }
+
+    if(hid_test_rep_data_unaligned != NULL)
+    {
+        USB_memfree(hid_test_rep_data_unaligned);
+        hid_test_rep_data_unaligned  = NULL;
+    }
+
+    /* Clear gloabal variables */
+    TEST_ENABLED = FALSE;
+    USB_SUSPENDED = FALSE;
+
+    USB_unlock(lockKey);
+}
+
+void    usbMousePeriodicResume(_usb_device_handle handle)
+{
+    if (USB_SUSPENDED)
+    {
+       /*
+        * Send RESUME signal whenever host suspends the USB port. In real case, we should
+        *  send RESUME signal only when a mouse button being clicked.
+        */
+        USB_printf("Mouse Resumed\n");
+
+        _usb_device_assert_resume(handle);
+        USB_SUSPENDED = FALSE;
+    } /* Endbody */
+}
+/* EOF */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.h
new file mode 100644
index 0000000..54fb4be
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/usb_hal/examples/mouse.h
@@ -0,0 +1,29 @@
+/*******************************************************************************
+
+This software file (the "File") is distributed by Marvell International Ltd.
+or its affiliate(s) under the terms of the GNU General Public License Version 2,
+June 1991 (the "License").  You may use, redistribute and/or modify this File
+in accordance with the terms and conditions of the License, a copy of which
+is available along with the File in the license.txt file or by writing to the
+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+(C) Copyright 2004 - 2007 Marvell Semiconductor Israel Ltd. All Rights Reserved.
+(C) Copyright 1999 - 2004 Chipidea Microelectronica, S.A. All Rights Reserved.
+
+*******************************************************************************/
+
+#ifndef __mouse_h__
+#define __mouse_h__
+
+extern _usb_device_handle   usbMouseLoad(int devNo);
+extern void                 usbMouseUnload(_usb_device_handle handle);
+extern void                 usbMousePeriodicResume(_usb_device_handle handle);
+
+#endif /* __mouse_h__ */
+/* EOF */
-- 
1.7.5.4

